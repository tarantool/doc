
msgid "Creating an application"
msgstr "Создание приложения"

#, fuzzy
msgid ""
"Further we walk you through key programming practices that will give you a "
"good start in writing Lua applications for Tarantool. We will implement a "
"real microservice based on Tarantool! It is a backend for a simplified "
"version of `Pokémon Go <https://en.wikipedia.org/wiki/Pokémon_Go>`_, a "
"location-based augmented reality game launched in mid-2016."
msgstr ""
"Далее мы пошагово разберем ключевые методики программирования, что послужит "
"хорошим началом для написания Lua-приложений для Tarantool. Для интереса "
"возьмем историю реализации... настоящего микросервиса на основе Tarantool! "
"Мы реализуем бэкенд для упрощенной версии `Pokémon Go  "
"<https://ru.wikipedia.org/wiki/Pok%C3%A9mon_Go>`_, игры на основе "
"определения местоположения дополненной реальности, выпущенной в середине "
"2016 года. В этой игре игроки используют GPS-возможности мобильных "
"устройств, чтобы находить, захватывать, сражаться и тренировать виртуальных "
"существ, или покемонов, которые появляются на экране, как если бы они "
"находились в том же реальном месте, как и игрок."

msgid ""
"In this game, players use the GPS capability of a mobile device to locate, "
"catch, battle, and train virtual monsters called \"pokémon\" that appear on "
"the screen as if they were in the same real-world location as the player."
msgstr ""

#, fuzzy
msgid ""
"To stay within the walk-through format, let's narrow the original gameplay "
"as follows. We have a map with pokémon spawn locations. Next, we have "
"multiple players who can send catch-a-pokémon requests to the server (which "
"runs our Tarantool microservice). The server responds whether the pokémon is"
" caught or not, increases the player's pokémon counter if yes, and triggers "
"the respawn-a-pokémon method that spawns a new pokémon at the same location "
"in a while."
msgstr ""
"Чтобы не выходить за рамки пошагового примера, ограничим оригинальный сюжет "
"игры. У нас есть карта с местами появления покемонов. Далее у нас есть "
"несколько игроков, которые могут отправлять запросы на поимку покемона на "
"сервер (где работает микросервис Tarantool). Сервер отвечает, пойман ли "
"покемон, увеличивает счетчик покемонов, если пойман, и вызывает метод "
"респауна покемона, который через некоторое время создает нового покемона на "
"том же самом месте."

#, fuzzy
msgid ""
"We leave client-side applications outside the scope of this story. However, "
"we promise a mini-demo in the end to simulate real users and give us some "
"fun."
msgstr ""
"Мы вынесем клиентские приложения за рамки рассказа. Но в конце обещаем "
"небольшую демонстрацию с моделированием настоящих пользователей, чтобы "
"немного поразвлечься. :-)"

msgid "Follow these topics to implement our application:"
msgstr ""

#~ msgid "First, what would be the best way to deliver our microservice?"
#~ msgstr "Для начала как лучше всего предоставить микросервис?"

#~ msgid "Modules, rocks and applications"
#~ msgstr "Модули и приложения"

#~ msgid ""
#~ "To make our game logic available to other developers and Lua applications, "
#~ "let's put it into a Lua module."
#~ msgstr ""
#~ "Чтобы наша логическая схема игры была доступна другим разработчикам и Lua-"
#~ "приложениям, поместим ее в Lua-модуль."

#~ msgid ""
#~ "A **module** (called \"rock\" in Lua) is an optional library which enhances "
#~ "Tarantool functionality. So, we can install our logic as a module in "
#~ "Tarantool and use it from any Tarantool application or module. Like "
#~ "applications, modules in Tarantool can be written in Lua (rocks), C or C++."
#~ msgstr ""
#~ "**Модуль** (который называется \"rock\" в Lua) -- это дополнительная "
#~ "библиотека, которая расширяет функции Tarantool. Поэтому можно установить "
#~ "нашу логическую схему в виде модуля в Tarantool и использовать ее из любого "
#~ "Tarantool-приложения или модуля. Как и приложения, модули в Tarantool могут "
#~ "быть написаны на Lua (rocks), C или C++."

#~ msgid "Modules are good for two things:"
#~ msgstr "Модули хороши для двух целей:"

#~ msgid "easier **code management** (reuse, packaging, versioning), and"
#~ msgstr ""
#~ "облегченное **управление кодом** (переиспользование, подготовка к "
#~ "развертыванию, версионирование) и"

#~ msgid "hot **code reload** without restarting the Tarantool instance."
#~ msgstr "горячая **перезагрузка кода** без перезапуска экземпляра Tarantool."

#~ msgid ""
#~ "Technically, a module is a file with source code that exports its functions "
#~ "in an API. For example, here is a Lua module named ``mymodule.lua`` that "
#~ "exports one function named ``myfun``:"
#~ msgstr ""
#~ "В техническом смысле, модуль - это файл с исходным кодом, который "
#~ "экспортирует свои функции в API. Например, вот Lua-модуль под названием "
#~ "``mymodule.lua``, который экспортирует одну функцию под названием ``myfun``:"

#~ msgid ""
#~ "local exports = {}\n"
#~ "exports.myfun = function(input_string)\n"
#~ "   print('Hello', input_string)\n"
#~ "end\n"
#~ "return exports"
#~ msgstr ""
#~ "local exports = {}\n"
#~ "exports.myfun = function(input_string)\n"
#~ "   print('Hello', input_string)\n"
#~ "end\n"
#~ "return exports"

#~ msgid ""
#~ "To launch the function ``myfun()`` -- from another module, from a Lua "
#~ "application, or from Tarantool itself, -- we need to save this module as a "
#~ "file, then load this module with the ``require()`` directive and call the "
#~ "exported function."
#~ msgstr ""
#~ "Чтобы запустить функцию ``myfun()`` -- из другого модуля, из Lua-приложения "
#~ "или из самого Tarantool -- необходимо сохранить этот модуль в виде файла, а "
#~ "затем загрузить этот модуль с директивой ``require()`` и вызвать "
#~ "экспортированную функцию."

#~ msgid ""
#~ "For example, here's a Lua application that uses ``myfun()`` function from "
#~ "``mymodule.lua`` module:"
#~ msgstr ""
#~ "Например, вот Lua-приложение, которое использует функцию ``myfun()`` из "
#~ "модуля ``mymodule.lua``:"

#~ msgid ""
#~ "-- loading the module\n"
#~ "local mymodule = require('mymodule')\n"
#~ "\n"
#~ "-- calling myfun() from within test() function\n"
#~ "local test = function()\n"
#~ "  mymodule.myfun()\n"
#~ "end"
#~ msgstr ""
#~ "-- загрузка модуля\n"
#~ "local mymodule = require('mymodule')\n"
#~ "\n"
#~ "-- вызов myfun() из функции test\n"
#~ "local test = function()\n"
#~ "  mymodule.myfun()\n"
#~ "end"

#~ msgid ""
#~ "A thing to remember here is that the ``require()`` directive takes load "
#~ "paths to Lua modules from the ``package.path`` variable. This is a "
#~ "semicolon-separated string, where a question mark is used to interpolate the"
#~ " module name. By default, this variable contains system-wide Lua paths and "
#~ "the working directory. But if we put our modules inside a specific folder "
#~ "(e.g. ``scripts/``), we need to add this folder to ``package.path`` before "
#~ "any calls to ``require()``:"
#~ msgstr ""
#~ "Здесь важно запомнить, что директива ``require()`` берет пути загрузки к "
#~ "Lua-модулям из переменной ``package.path``. Она представляет собой строку с "
#~ "разделителями в виде точки с запятой, где знак вопроса используется для "
#~ "вставки имени модуля. По умолчанию, эта переменная содержит пути в системе и"
#~ " рабочую директорию. Но если мы поместим наши модули в особую папку "
#~ "(например, ``scripts/``), необходимо будет добавить эту папку в "
#~ "``package.path`` до вызова ``require()``:"

#~ msgid "package.path = 'scripts/?.lua;' .. package.path"
#~ msgstr "package.path = 'scripts/?.lua;' .. package.path"

#~ msgid ""
#~ "For our microservice, a simple and convenient solution would be to put all "
#~ "methods in a Lua module (say ``pokemon.lua``) and to write a Lua application"
#~ " (say ``game.lua``) that initializes the gaming environment and starts the "
#~ "game loop."
#~ msgstr ""
#~ "Для нашего микросервиса простым и удобным решением будет разместить все "
#~ "методы в Lua-модуле (скажем, ``pokemon.lua``) и написать Lua-приложение "
#~ "(скажем, ``game.lua``), которое запустит игровое окружение и цикл игры."

#~ msgid ""
#~ "Now let's get down to implementation details. In our game, we need three "
#~ "entities:"
#~ msgstr ""
#~ "Теперь приступим к деталям реализации. В игре нам необходимы три сущности:"

#~ msgid ""
#~ "**map**, which is an array of pokémons with coordinates of respawn "
#~ "locations; in this version of the game, let a location be a rectangle "
#~ "identified with two points, upper-left and lower-right;"
#~ msgstr ""
#~ "**карта**, которая представляет собой массив покемонов с координатами мест "
#~ "респауна; в данной версии игры пусть местом будет прямоугольник, "
#~ "установленный по двум точкам, верхней левой и нижней правой;"

#~ msgid ""
#~ "**player**, which has an ID, a name, and coordinates of the player's "
#~ "location point;"
#~ msgstr ""
#~ "**игрок**, у которого есть ID, имя и координаты местонахождения игрока;"

#~ msgid ""
#~ "**pokémon**, which has the same fields as the player, plus a status "
#~ "(active/inactive, that is present on the map or not) and a catch probability"
#~ " (well, let's give our pokémons a chance to escape :-) )"
#~ msgstr ""
#~ "**покемон**, у которого такие же поля, как и у игрока, плюс статус "
#~ "(активный/неактивный, то есть находится ли на карте) и возможность поимки "
#~ "(давайте уж дадим нашим покемонам шанс сбежать :-) )"

#~ msgid ""
#~ "We'll store these entities as tuples in Tarantool spaces. But to deliver our"
#~ " backend application as a microservice, the good practice would be to "
#~ "send/receive our data in the universal JSON format, thus using Tarantool as "
#~ "a document storage."
#~ msgstr ""
#~ "Эти данные будем хранить как кортежи в спейсах Tarantool. Но чтобы бэкенд-"
#~ "приложение работало как микросервис, правильно будет отправлять/получать "
#~ "данные в универсальном формате JSON, используя Tarantool в качестве системы "
#~ "хранения документов."

#~ msgid "Avro schemas"
#~ msgstr "Avro-схемы"

#~ msgid ""
#~ "To store JSON data as tuples, we will apply a savvy practice which reduces "
#~ "data footprint and ensures all stored documents are valid. We will use "
#~ "Tarantool module `avro-schema <https://github.com/tarantool/avro-schema>`_ "
#~ "which checks the schema of a JSON document and converts it to a Tarantool "
#~ "tuple. The tuple will contain only field values, and thus take a lot less "
#~ "space than the original document. In avro-schema terms, converting JSON "
#~ "documents to tuples is \"flattening\", and restoring the original documents "
#~ "is \"unflattening\"."
#~ msgstr ""
#~ "Чтобы хранить JSON-данные в виде кортежей, используем продвинутую методику, "
#~ "которая уменьшит отпечаток данных и обеспечит пригодность всех сохраняемых "
#~ "документов. Будем использовать Tarantool-модуль `avro-schema "
#~ "<https://github.com/tarantool/avro-schema>`_, который проверяет схему JSON-"
#~ "документа и конвертирует его в кортеж Tarantool. Кортеж будет содержать "
#~ "только значения полей, таким образом, занимая меньше места, чем оригинальный"
#~ " документ. С точки зрения avro-схемы, конвертация JSON-документов в кортежи "
#~ "-- \"flattening\" (конвертация в плоские файлы), а восстановление "
#~ "оригинальных документов -- \"unflattening\" (конвертация из плоских файлов)."

#~ msgid ""
#~ "First you need to `install </book/app_server/installing_module/>`_ the "
#~ "module with ``tarantoolctl rocks install avro-schema``."
#~ msgstr ""
#~ "Для начала необходимо `установить </book/app_server/installing_module/>`_ "
#~ "модуль с помощью команды ``tarantoolctl rocks install avro-schema``."

#~ msgid "Further usage is quite straightforward:"
#~ msgstr "Использовать модуль достаточно просто:"

#~ msgid ""
#~ "For each entity, we need to define a schema in `Apache Avro schema "
#~ "<https://en.wikipedia.org/wiki/Apache_Avro>`_ syntax, where we list the "
#~ "entity's fields with their names and `Avro data types "
#~ "<http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."
#~ msgstr ""
#~ "Для каждой сущности необходимо определить схему в синтаксисе `схемы Apache "
#~ "Avro <https://en.wikipedia.org/wiki/Apache_Avro>`_, где мы перечисляем поля "
#~ "сущности с их наименованиями и `типами данных по Avro "
#~ "<http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."

#~ msgid ""
#~ "At initialization, we call ``avro-schema.create()`` that creates objects in "
#~ "memory for all schema entities, and ``compile()`` that generates "
#~ "flatten/unflatten methods for each entity."
#~ msgstr ""
#~ "При инициализации мы вызываем функцию ``avro-schema.create()``, которая "
#~ "создает объекты в памяти для всех сущностей схемы, а также функцию "
#~ "``compile()``, которая создает методы flatten/unflatten (конвертация в "
#~ "плоские файлы и обратно) для каждой сущности."

#~ msgid ""
#~ "Further on, we just call flatten/unflatten methods for a respective entity "
#~ "on receiving/sending the entity's data."
#~ msgstr ""
#~ "Далее мы просто вызываем методы flatten/unflatten для соответствующей "
#~ "сущности при получении/отправке данных об этой сущности."

#~ msgid ""
#~ "Here's what our schema definitions for the player and pokémon entities look "
#~ "like:"
#~ msgstr ""
#~ "Вот как будут выглядеть определения схемы для сущностей игрока и покемона:"

#~ msgid ""
#~ "local schema = {\n"
#~ "    player = {\n"
#~ "        type=\"record\",\n"
#~ "        name=\"player_schema\",\n"
#~ "        fields={\n"
#~ "            {name=\"id\", type=\"long\"},\n"
#~ "            {name=\"name\", type=\"string\"},\n"
#~ "            {\n"
#~ "                name=\"location\",\n"
#~ "                type= {\n"
#~ "                    type=\"record\",\n"
#~ "                    name=\"player_location\",\n"
#~ "                    fields={\n"
#~ "                        {name=\"x\", type=\"double\"},\n"
#~ "                        {name=\"y\", type=\"double\"}\n"
#~ "                    }\n"
#~ "                }\n"
#~ "            }\n"
#~ "        }\n"
#~ "    },\n"
#~ "    pokemon = {\n"
#~ "        type=\"record\",\n"
#~ "        name=\"pokemon_schema\",\n"
#~ "        fields={\n"
#~ "            {name=\"id\", type=\"long\"},\n"
#~ "            {name=\"status\", type=\"string\"},\n"
#~ "            {name=\"name\", type=\"string\"},\n"
#~ "            {name=\"chance\", type=\"double\"},\n"
#~ "            {\n"
#~ "                name=\"location\",\n"
#~ "                type= {\n"
#~ "                    type=\"record\",\n"
#~ "                    name=\"pokemon_location\",\n"
#~ "                    fields={\n"
#~ "                        {name=\"x\", type=\"double\"},\n"
#~ "                        {name=\"y\", type=\"double\"}\n"
#~ "                    }\n"
#~ "                }\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "local schema = {\n"
#~ "    player = {\n"
#~ "        type=\"record\",\n"
#~ "        name=\"player_schema\",\n"
#~ "        fields={\n"
#~ "            {name=\"id\", type=\"long\"},\n"
#~ "            {name=\"name\", type=\"string\"},\n"
#~ "            {\n"
#~ "                name=\"location\",\n"
#~ "                type= {\n"
#~ "                    type=\"record\",\n"
#~ "                    name=\"player_location\",\n"
#~ "                    fields={\n"
#~ "                        {name=\"x\", type=\"double\"},\n"
#~ "                        {name=\"y\", type=\"double\"}\n"
#~ "                    }\n"
#~ "                }\n"
#~ "            }\n"
#~ "        }\n"
#~ "    },\n"
#~ "    pokemon = {\n"
#~ "        type=\"record\",\n"
#~ "        name=\"pokemon_schema\",\n"
#~ "        fields={\n"
#~ "            {name=\"id\", type=\"long\"},\n"
#~ "            {name=\"status\", type=\"string\"},\n"
#~ "            {name=\"name\", type=\"string\"},\n"
#~ "            {name=\"chance\", type=\"double\"},\n"
#~ "            {\n"
#~ "                name=\"location\",\n"
#~ "                type= {\n"
#~ "                    type=\"record\",\n"
#~ "                    name=\"pokemon_location\",\n"
#~ "                    fields={\n"
#~ "                        {name=\"x\", type=\"double\"},\n"
#~ "                        {name=\"y\", type=\"double\"}\n"
#~ "                    }\n"
#~ "                }\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"

#~ msgid "And here's how we create and compile our entities at initialization:"
#~ msgstr "А вот как мы создадим и скомпилируем наши сущности при инициализации:"

#~ msgid ""
#~ "-- load avro-schema module with require()\n"
#~ "local avro = require('avro_schema')\n"
#~ "\n"
#~ "-- create models\n"
#~ "local ok_m, pokemon = avro.create(schema.pokemon)\n"
#~ "local ok_p, player = avro.create(schema.player)\n"
#~ "if ok_m and ok_p then\n"
#~ "    -- compile models\n"
#~ "    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
#~ "    local ok_cp, compiled_player = avro.compile(player)\n"
#~ "    if ok_cm and ok_cp then\n"
#~ "        -- start the game\n"
#~ "        <...>\n"
#~ "    else\n"
#~ "        log.error('Schema compilation failed')\n"
#~ "    end\n"
#~ "else\n"
#~ "    log.info('Schema creation failed')\n"
#~ "end\n"
#~ "return false"
#~ msgstr ""
#~ "-- загрузить модуль avro-schema с директивой require()\n"
#~ "local avro = require('avro_schema')\n"
#~ "\n"
#~ "-- создать модели\n"
#~ "local ok_m, pokemon = avro.create(schema.pokemon)\n"
#~ "local ok_p, player = avro.create(schema.player)\n"
#~ "if ok_m and ok_p then\n"
#~ "    -- скомпилировать модели\n"
#~ "    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
#~ "    local ok_cp, compiled_player = avro.compile(player)\n"
#~ "    if ok_cm and ok_cp then\n"
#~ "        -- начать игру\n"
#~ "        <...>\n"
#~ "    else\n"
#~ "        log.error('Schema compilation failed')\n"
#~ "    end\n"
#~ "else\n"
#~ "    log.info('Schema creation failed')\n"
#~ "end\n"
#~ "return false"

#~ msgid ""
#~ "As for the map entity, it would be an overkill to introduce a schema for it,"
#~ " because we have only one map in the game, it has very few fields, and -- "
#~ "which is most important -- we use the map only inside our logic, never "
#~ "exposing it to external users."
#~ msgstr ""
#~ "Что касается сущности карты, вводить для нее схему будет перебор, потому что"
#~ " в игре всего одна карта, у нее мало полей, и -- что самое главное -- мы "
#~ "используем карту только внутри нашей логики, не показывая ее внешним "
#~ "пользователям."

#~ msgid ""
#~ "Next, we need methods to implement the game logic. To simulate object-"
#~ "oriented programming in our Lua code, let's store all Lua functions and "
#~ "shared variables in a single local variable (let's name it as ``game``). "
#~ "This will allow us to address functions or variables from within our module "
#~ "as ``self.func_name`` or ``self.var_name``. Like this:"
#~ msgstr ""
#~ "Далее нам нужны методы для реализации игровой логики. Чтобы смоделировать "
#~ "объектно-ориентированное программирование в нашем Lua-коде, будем хранить "
#~ "все Lua-функции и общие переменные в одной внутренней переменной (назовем ее"
#~ " ``game``). Это позволит нам обращаться к функциям или переменным из нашего "
#~ "модуля с помощью ``self.func_name`` или ``self.var_name`` следующим образом:"

#~ msgid ""
#~ "local game = {\n"
#~ "    -- a local variable\n"
#~ "    num_players = 0,\n"
#~ "\n"
#~ "    -- a method that prints a local variable\n"
#~ "    hello = function(self)\n"
#~ "      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
#~ "    end,\n"
#~ "\n"
#~ "    -- a method that calls another method and returns a local variable\n"
#~ "    sign_in = function(self)\n"
#~ "      self.num_players = self.num_players + 1\n"
#~ "      self:hello()\n"
#~ "      return self.num_players\n"
#~ "    end\n"
#~ "}"
#~ msgstr ""
#~ "local game = {\n"
#~ "    -- локальная переменная\n"
#~ "    num_players = 0,\n"
#~ "\n"
#~ "    -- метод, который выводит локальную переменную\n"
#~ "    hello = function(self)\n"
#~ "      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
#~ "    end,\n"
#~ "\n"
#~ "    -- метод, который вызывает другой метод и возвращает локальную переменную\n"
#~ "    sign_in = function(self)\n"
#~ "      self.num_players = self.num_players + 1\n"
#~ "      self:hello()\n"
#~ "      return self.num_players\n"
#~ "    end\n"
#~ "}"

#~ msgid ""
#~ "In OOP terms, we can now regard local variables inside ``game`` as object "
#~ "fields, and local functions as object methods."
#~ msgstr ""
#~ "В терминах ООП сейчас мы можем рассматривать внутренние переменные внутри "
#~ "переменной ``game`` как поля объекта, а внутренние функции -- как методы "
#~ "объекта."

#~ msgid ""
#~ "In this manual, Lua examples use **local** variables. Use **global** "
#~ "variables with caution, since the module’s users may be unaware of them."
#~ msgstr ""
#~ "Обратите внимание, что в текущей документации в примерах Lua-кода "
#~ "используются *локальные* переменные. Используйте *глобальные* переменные "
#~ "аккуратно, поскольку пользователи ваших модулей могут не знать об этих "
#~ "переменных."

#~ msgid ""
#~ "To enable/disable the use of undeclared global variables in your Lua code, "
#~ "use Tarantool's :ref:`strict <strict-module>` module."
#~ msgstr ""
#~ "Чтобы включить/отключить использование необъявленных глобальных переменных в"
#~ " вашем коде на языке Lua, используйте модуль Tarantool :ref:`strict <strict-"
#~ "module>`."

#~ msgid "So, our game module will have the following methods:"
#~ msgstr "Таким образом, в модуле игры будут следующие методы:"

#~ msgid ""
#~ "``catch()`` to calculate whether the pokémon was caught (besides the "
#~ "coordinates of both the player and pokémon, this method will apply a "
#~ "probability factor, so not every pokémon within the player's reach will be "
#~ "caught);"
#~ msgstr ""
#~ "``catch()`` (поймать) для расчета, когда был пойман покемон (помимо "
#~ "координат как игрока, так и покемона, этот метод будет использовать "
#~ "коэффициент вероятности, чтобы в пределах досягаемости игрока можно было "
#~ "поймать не каждого покемона);"

#~ msgid ""
#~ "``respawn()`` to add missing pokémons to the map, say, every 60 seconds (we "
#~ "assume that a frightened pokémon runs away, so we remove a pokémon from the "
#~ "map on any catch attempt and add it back to the map in a while);"
#~ msgstr ""
#~ "``respawn()`` (респаун) для добавления отсутствующих покемонов на карту, "
#~ "скажем, каждые 60 секунд (предположим, что испуганный покемон убегает, "
#~ "поэтому мы убираем покемона с карты при любой попытке поймать его и через "
#~ "некоторое время добавляем обратно на карту);"

#~ msgid ""
#~ "``notify()`` to log information about caught pokémons (like \"Player 1 "
#~ "caught pokémon A\");"
#~ msgstr ""
#~ "``notify()`` (уведомить) для записи информации о пойманных покемонах "
#~ "(например, \"Игрок 1 поймал покемона A\");"

#~ msgid ""
#~ "``start()`` to initialize the game (it will create database spaces, create "
#~ "and compile avro schemas, and launch ``respawn()``)."
#~ msgstr ""
#~ "``start()`` (начать) для инициализации игры (метод создаст спейсы в базе "
#~ "данных, создаст и скомпилирует avro-схемы, а также запустит метод "
#~ "``respawn()``)."

#~ msgid ""
#~ "Besides, it would be convenient to have methods for working with Tarantool "
#~ "storage. For example:"
#~ msgstr ""
#~ "Кроме того, было бы удобно завести методы для работы с хранилищем Tarantool."
#~ " Например:"

#~ msgid "``add_pokemon()`` to add a pokémon to the database, and"
#~ msgstr ""
#~ "``add_pokemon()`` (добавить покемона) для добавления покемона в базу данных "
#~ "и"

#~ msgid "``map()`` to populate the map with all pokémons stored in Tarantool."
#~ msgstr ""
#~ "``map()`` (карта) для заполнения карты всеми покемонами, которые хранятся в "
#~ "Tarantool."

#~ msgid ""
#~ "We'll need these two methods primarily when initializing our game, but we "
#~ "can also call them later, for example to test our code."
#~ msgstr ""
#~ "Эти два метода будут главным образом использоваться во время инициализации "
#~ "нашей игры, но их также можно вызывать позднее, например для тестирования "
#~ "кода."

#~ msgid "Bootstrapping a database"
#~ msgstr "Настройка базы данных"

#~ msgid ""
#~ "Let's discuss game initialization. In ``start()`` method, we need to "
#~ "populate Tarantool spaces with pokémon data. Why not keep all game data in "
#~ "memory? Why use a database? The answer is: :ref:`persistence <index-"
#~ "box_persistence>`. Without a database, we risk losing data on power outage, "
#~ "for example. But if we store our data in an in-memory database, Tarantool "
#~ "takes care to persist it on disk whenever it's changed. This gives us one "
#~ "more benefit: quick startup in case of failure. Tarantool has a :ref:`smart "
#~ "algorithm <internals-recovery_process>` that quickly loads all data from "
#~ "disk into memory on startup, so the warm-up takes little time."
#~ msgstr ""
#~ "Обсудим инициализацию игры. В методе ``start()`` нам нужно заполнить спейсы "
#~ "Tarantool данными о покемонах. Почему бы не хранить все игровые данные в "
#~ "памяти? Зачем нужна база данных? Ответ на это: :ref:`персистентность <index-"
#~ "box_persistence>`. Без базы данных мы рискуем потерять данные при отключении"
#~ " электроэнергии, например. Но если мы храним данные в in-memory базе данных,"
#~ " Tarantool позаботится о том, чтобы обеспечить постоянное хранение данных "
#~ "при их изменении. Это дает дополнительное преимущество: быстрая загрузка в "
#~ "случае отказа. :ref:`Умный алгоритм <internals-recovery_process>` Tarantool "
#~ "быстро загружает все данные с диска в память при начале работы, так что "
#~ "подготовка к работе не займет много времени."

#~ msgid ""
#~ "We'll be using functions from Tarantool built-in :ref:`box <box-module>` "
#~ "module:"
#~ msgstr ""
#~ "Мы будем использовать функции из встроенного модуля Tarantool :ref:`box "
#~ "<box-module>`:"

#~ msgid ""
#~ "``box.schema.create_space('pokemons')`` to create a space named ``pokemon`` "
#~ "for storing information about pokémons (we don't create a similar space for "
#~ "players, because we intend to only send/receive player information via API "
#~ "calls, so we needn't store it);"
#~ msgstr ""
#~ "``box.schema.create_space('pokemons')`` для создания спейса под названием "
#~ "``pokemon`` (покемон), чтобы хранить информацию о покемонах (мы не создаем "
#~ "аналогичный спейс по игрокам, потому что планируем только отправлять и "
#~ "получать информацию об игроках с помощью вызовов API, так что нет "
#~ "необходимости хранить ее);"

#~ msgid ""
#~ "``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
#~ "'unsigned'}})`` to create a primary HASH index by pokémon ID;"
#~ msgstr ""
#~ "``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
#~ "'unsigned'}})`` для создания первичного HASH-индекса по ID покемона;"

#~ msgid ""
#~ "``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
#~ "'str'}})`` to create a secondary TREE index by pokémon status."
#~ msgstr ""
#~ "``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
#~ "'str'}})`` для создания вторичного TREE-индекса по статусу покемона."

#~ msgid ""
#~ "Notice the ``parts =`` argument in the index specification. The pokémon ID "
#~ "is the first field in a Tarantool tuple since it’s the first member of the "
#~ "respective Avro type. So does the pokémon status. The actual JSON document "
#~ "may have ID or status fields at any position of the JSON map."
#~ msgstr ""
#~ "Обратите внимание на аргумент ``parts =`` в спецификации индекса. ID "
#~ "покемона -- это первое поле в кортеже Tarantool, потому что это первый "
#~ "элемент соответствующего типа Avro. То же относится к статусу покемона. В "
#~ "самом JSON-файле поля ID или статуса могут быть в любом положении на JSON-"
#~ "карте."

#~ msgid "The implementation of ``start()`` method looks like this:"
#~ msgstr "Реализация метода ``start()`` выглядит следующим образом:"

#~ msgid ""
#~ "-- create game object\n"
#~ "start = function(self)\n"
#~ "    -- create spaces and indexes\n"
#~ "    box.once('init', function()\n"
#~ "        box.schema.create_space('pokemons')\n"
#~ "        box.space.pokemons:create_index(\n"
#~ "            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
#~ "        )\n"
#~ "        box.space.pokemons:create_index(\n"
#~ "            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
#~ "        )\n"
#~ "    end)\n"
#~ "\n"
#~ "    -- create models\n"
#~ "    local ok_m, pokemon = avro.create(schema.pokemon)\n"
#~ "    local ok_p, player = avro.create(schema.player)\n"
#~ "    if ok_m and ok_p then\n"
#~ "        -- compile models\n"
#~ "        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
#~ "        local ok_cp, compiled_player = avro.compile(player)\n"
#~ "        if ok_cm and ok_cp then\n"
#~ "            -- start the game\n"
#~ "            <...>\n"
#~ "        else\n"
#~ "            log.error('Schema compilation failed')\n"
#~ "        end\n"
#~ "    else\n"
#~ "        log.info('Schema creation failed')\n"
#~ "    end\n"
#~ "    return false\n"
#~ "end"
#~ msgstr ""
#~ "-- создать игровой объект\n"
#~ "start = function(self)\n"
#~ "    -- создать спейсы и индексы\n"
#~ "    box.once('init', function()\n"
#~ "        box.schema.create_space('pokemons')\n"
#~ "        box.space.pokemons:create_index(\n"
#~ "            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
#~ "        )\n"
#~ "        box.space.pokemons:create_index(\n"
#~ "            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
#~ "        )\n"
#~ "    end)\n"
#~ "\n"
#~ "    -- создать модели\n"
#~ "    local ok_m, pokemon = avro.create(schema.pokemon)\n"
#~ "    local ok_p, player = avro.create(schema.player)\n"
#~ "    if ok_m and ok_p then\n"
#~ "        -- скомпилировать модели\n"
#~ "        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
#~ "        local ok_cp, compiled_player = avro.compile(player)\n"
#~ "        if ok_cm and ok_cp then\n"
#~ "            -- начать игру\n"
#~ "            <...>\n"
#~ "        else\n"
#~ "            log.error('Schema compilation failed')\n"
#~ "        end\n"
#~ "    else\n"
#~ "        log.info('Schema creation failed')\n"
#~ "    end\n"
#~ "    return false\n"
#~ "end"

#~ msgid "GIS"
#~ msgstr "ГИС"

#~ msgid ""
#~ "Now let's discuss ``catch()``, which is the main method in our gaming logic."
#~ msgstr ""
#~ "Теперь обсудим метод ``catch()``, который является основным в логике нашей "
#~ "игры."

#~ msgid ""
#~ "Here we receive the player's coordinates and the target pokémon's ID number,"
#~ " and we need to answer whether the player has actually caught the pokémon or"
#~ " not (remember that each pokémon has a chance to escape)."
#~ msgstr ""
#~ "Здесь мы получаем координаты игрока и номер ID искомого покемона, а нужен "
#~ "нам ответ на вопрос, поймали ли игрок покемона (помните, что у каждого "
#~ "покемона есть шанс убежать)."

#~ msgid ""
#~ "First thing, we validate the received player data against its :ref:`Avro "
#~ "schema <app_server-avro_schemas>`. And we check whether such a pokémon "
#~ "exists in our database and is displayed on the map (the pokémon must have "
#~ "the active status):"
#~ msgstr ""
#~ "Для начала проверим полученные данные об игроке по :ref:`Avro-схеме "
#~ "<app_server-avro_schemas>`. Также проверим, есть ли такой покемон в базе "
#~ "данных, и отображается ли он на карте (у покемона должен быть активный "
#~ "статус):"

#~ msgid ""
#~ "catch = function(self, pokemon_id, player)\n"
#~ "    -- check player data\n"
#~ "    local ok, tuple = self.player_model.flatten(player)\n"
#~ "    if not ok then\n"
#~ "        return false\n"
#~ "    end\n"
#~ "    -- get pokemon data\n"
#~ "    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
#~ "    if p_tuple == nil then\n"
#~ "        return false\n"
#~ "    end\n"
#~ "    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
#~ "    if not ok then\n"
#~ "        return false\n"
#~ "    end\n"
#~ "    if pokemon.status ~= self.state.ACTIVE then\n"
#~ "        return false\n"
#~ "    end\n"
#~ "    -- more catch logic to follow\n"
#~ "    <...>\n"
#~ "end"
#~ msgstr ""
#~ "catch = function(self, pokemon_id, player)\n"
#~ "    -- проверить данные игрока\n"
#~ "    local ok, tuple = self.player_model.flatten(player)\n"
#~ "    if not ok then\n"
#~ "        return false\n"
#~ "    end\n"
#~ "    -- получить данные покемона\n"
#~ "    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
#~ "    if p_tuple == nil then\n"
#~ "        return false\n"
#~ "    end\n"
#~ "    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
#~ "    if not ok then\n"
#~ "        return false\n"
#~ "    end\n"
#~ "    if pokemon.status ~= self.state.ACTIVE then\n"
#~ "        return false\n"
#~ "    end\n"
#~ "    -- логика поимки будет дополняться\n"
#~ "    <...>\n"
#~ "end"

#~ msgid "Next, we calculate the answer: caught or not."
#~ msgstr "Далее вычисляем ответ: пойман или нет."

#~ msgid ""
#~ "To work with geographical coordinates, we use Tarantool `gis "
#~ "<https://github.com/tarantool/gis>`_ module."
#~ msgstr ""
#~ "Чтобы работать с географическими координатами, используем модуль Tarantool "
#~ "`gis <https://github.com/tarantool/gis>`_."

#~ msgid ""
#~ "To keep things simple, we don't load any specific map, assuming that we deal"
#~ " with a world map. And we do not validate incoming coordinates, assuming "
#~ "again that all received locations are within the planet Earth."
#~ msgstr ""
#~ "Чтобы не усложнять, не будем загружать какую-то особую карту, допуская, что "
#~ "рассматриваем карту мира. Также не будет проверять поступающие координаты, "
#~ "снова допуская, что все места находятся на планете Земля."

#~ msgid "We use two geo-specific variables:"
#~ msgstr "Используем две географические переменные:"

#~ msgid ""
#~ "``wgs84``, which stands for the latest revision of the World Geodetic System"
#~ " standard, `WGS84 "
#~ "<https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. Basically, it"
#~ " comprises a standard coordinate system for the Earth and represents the "
#~ "Earth as an ellipsoid."
#~ msgstr ""
#~ "``wgs84``, что означает последнюю редакцию стандарта Мировой геодезической "
#~ "системы координат, `WGS84 "
#~ "<https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. В целом, она "
#~ "представляет собой стандартную систему координат Земли и изображает Землю "
#~ "как эллипсоид."

#~ msgid ""
#~ "``nationalmap``, which stands for the `US National Atlas Equal Area "
#~ "<https://epsg.io/2163>`_. This is a projected coordinates system based on "
#~ "WGS84. It gives us a zero base for location projection and allows "
#~ "positioning our players and pokémons in meters."
#~ msgstr ""
#~ "``nationalmap``, что означает `Государственный атлас США в равновеликой "
#~ "проекции (US National Atlas Equal Area) <https://epsg.io/2163>`_. Это "
#~ "система спроецированных координат на основании WGS84. Она дает основу для "
#~ "проецирования мест и позволяет определить местоположение наших игроков и "
#~ "покемонов в метрах."

#~ msgid ""
#~ "Both these systems are listed in the EPSG Geodetic Parameter Registry, where"
#~ " each system has a unique number. In our code, we assign these listing "
#~ "numbers to respective variables:"
#~ msgstr ""
#~ "Обе системы указаны в Реестре геодезических параметров EPSG, где каждой "
#~ "системе присвоен уникальный номер. Мы назначим эти числа соответствующим "
#~ "переменным в нашем коде:"

#~ msgid ""
#~ "wgs84 = 4326,\n"
#~ "nationalmap = 2163,"
#~ msgstr ""
#~ "wgs84 = 4326,\n"
#~ "nationalmap = 2163,"

#~ msgid ""
#~ "For our game logic, we need one more variable, ``catch_distance``, which "
#~ "defines how close a player must get to a pokémon before trying to catch it. "
#~ "Let's set the distance to 100 meters."
#~ msgstr ""
#~ "Для игровой логики необходима еще одна переменная ``catch_distance``, "
#~ "которая определяет, насколько близко игрок должен подойти к покемону, чтобы "
#~ "попытаться поймать его. Определим это расстояние в 100 метров."

#~ msgid "catch_distance = 100,"
#~ msgstr "catch_distance = 100,"

#~ msgid ""
#~ "Now we're ready to calculate the answer. We need to project the current "
#~ "location of both player (``p_pos``) and pokémon (``m_pos``) on the map, "
#~ "check whether the player is close enough to the pokémon (using "
#~ "``catch_distance``), and calculate whether the player has caught the pokémon"
#~ " (here we generate some random value and let the pokémon escape if the "
#~ "random value happens to be less than 100 minus pokémon's chance value):"
#~ msgstr ""
#~ "Теперь можно рассчитать ответ. Необходимо спроецировать текущее "
#~ "местоположение как игрока (``p_pos``), так и покемона (``m_pos``) на карте, "
#~ "проверить, достаточно ли близко к покемону находится игрок (с помощью "
#~ "``catch_distance``), и рассчитать, поймал ли игрок покемона (здесь мы "
#~ "генерируем случайное значение, и покемон убегает, если случайное значение "
#~ "оказывается меньше, чем 100 минус случайная величина покемона):"

#~ msgid ""
#~ "-- project locations\n"
#~ "local m_pos = gis.Point(\n"
#~ "    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
#~ "):transform(self.nationalmap)\n"
#~ "local p_pos = gis.Point(\n"
#~ "    {player.location.x, player.location.y}, self.wgs84\n"
#~ "):transform(self.nationalmap)\n"
#~ "\n"
#~ "-- check catch distance condition\n"
#~ "if p_pos:distance(m_pos) > self.catch_distance then\n"
#~ "    return false\n"
#~ "end\n"
#~ "-- try to catch pokemon\n"
#~ "local caught = math.random(100) >= 100 - pokemon.chance\n"
#~ "if caught then\n"
#~ "    -- update and notify on success\n"
#~ "    box.space.pokemons:update(\n"
#~ "        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
#~ "    )\n"
#~ "    self:notify(player, pokemon)\n"
#~ "end\n"
#~ "return caught"
#~ msgstr ""
#~ "-- спроецировать местоположение\n"
#~ " local m_pos = gis.Point(\n"
#~ "     {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
#~ " ):transform(self.nationalmap)\n"
#~ " local p_pos = gis.Point(\n"
#~ "     {player.location.x, player.location.y}, self.wgs84\n"
#~ " ):transform(self.nationalmap)\n"
#~ " \n"
#~ " -- проверить условие близости игрока\n"
#~ " if p_pos:distance(m_pos) > self.catch_distance then\n"
#~ "     return false\n"
#~ " end\n"
#~ " -- попытаться поймать покемона\n"
#~ " local caught = math.random(100) >= 100 - pokemon.chance\n"
#~ " if caught then\n"
#~ "     -- обновить и сообщить об успехе\n"
#~ "     box.space.pokemons:update(\n"
#~ "         pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
#~ "     )\n"
#~ "     self:notify(player, pokemon)\n"
#~ " end\n"
#~ " return caught"

#~ msgid "Index iterators"
#~ msgstr "Итератор с индексом"

#~ msgid ""
#~ "By our gameplay, all caught pokémons are returned back to the map. We do "
#~ "this for all pokémons on the map every 60 seconds using ``respawn()`` "
#~ "method. We iterate through pokémons by status using Tarantool index iterator"
#~ " function :doc:`/reference/reference_lua/box_index/pairs` and reset the "
#~ "statuses of all \"caught\" pokémons back to \"active\" using "
#~ "``box.space.pokemons:update()``."
#~ msgstr ""
#~ "По сюжету игры все пойманные покемоны возвращаются на карту. Метод "
#~ "``respawn()`` обеспечивает это для всех покемонов на карте каждые 60 секунд."
#~ " Мы выполняем перебор покемонов по статусу с помощью функции Tarantool "
#~ "итератора с индексом :doc:`/reference/reference_lua/box_index/pairs` и "
#~ "сбрасываем статусы всех \"пойманных\" покемонов обратно на \"активный\" с "
#~ "помощью ``box.space.pokemons:update()``."

#~ msgid ""
#~ "respawn = function(self)\n"
#~ "    fiber.name('Respawn fiber')\n"
#~ "    for _, tuple in box.space.pokemons.index.status:pairs(\n"
#~ "           self.state.CAUGHT) do\n"
#~ "        box.space.pokemons:update(\n"
#~ "            tuple[self.ID],\n"
#~ "            {{'=', self.STATUS, self.state.ACTIVE}}\n"
#~ "        )\n"
#~ "    end\n"
#~ " end"
#~ msgstr ""
#~ "respawn = function(self)\n"
#~ "    fiber.name('Respawn fiber')\n"
#~ "    for _, tuple in box.space.pokemons.index.status:pairs(\n"
#~ "           self.state.CAUGHT) do\n"
#~ "        box.space.pokemons:update(\n"
#~ "            tuple[self.ID],\n"
#~ "            {{'=', self.STATUS, self.state.ACTIVE}}\n"
#~ "        )\n"
#~ "    end\n"
#~ " end"

#~ msgid "For readability, we introduce named fields:"
#~ msgstr "Для удобства введем именованные поля:"

#~ msgid "ID = 1, STATUS = 2,"
#~ msgstr "ID = 1, STATUS = 2,"

#~ msgid "The complete implementation of ``start()`` now looks like this:"
#~ msgstr "Реализация метода ``start()`` полностью теперь выглядит так:"

#~ msgid ""
#~ "-- create game object\n"
#~ "start = function(self)\n"
#~ "    -- create spaces and indexes\n"
#~ "    box.once('init', function()\n"
#~ "       box.schema.create_space('pokemons')\n"
#~ "       box.space.pokemons:create_index(\n"
#~ "           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
#~ "       )\n"
#~ "       box.space.pokemons:create_index(\n"
#~ "           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
#~ "       )\n"
#~ "    end)\n"
#~ "\n"
#~ "    -- create models\n"
#~ "    local ok_m, pokemon = avro.create(schema.pokemon)\n"
#~ "    local ok_p, player = avro.create(schema.player)\n"
#~ "    if ok_m and ok_p then\n"
#~ "        -- compile models\n"
#~ "        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
#~ "        local ok_cp, compiled_player = avro.compile(player)\n"
#~ "        if ok_cm and ok_cp then\n"
#~ "            -- start the game\n"
#~ "            self.pokemon_model = compiled_pokemon\n"
#~ "            self.player_model = compiled_player\n"
#~ "            self.respawn()\n"
#~ "            log.info('Started')\n"
#~ "            return true\n"
#~ "         else\n"
#~ "            log.error('Schema compilation failed')\n"
#~ "         end\n"
#~ "    else\n"
#~ "        log.info('Schema creation failed')\n"
#~ "    end\n"
#~ "    return false\n"
#~ "end"
#~ msgstr ""
#~ "-- создать игровой объект\n"
#~ "start = function(self)\n"
#~ "    -- создать спейсы и индексы\n"
#~ "    box.once('init', function()\n"
#~ "       box.schema.create_space('pokemons')\n"
#~ "       box.space.pokemons:create_index(\n"
#~ "           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
#~ "       )\n"
#~ "       box.space.pokemons:create_index(\n"
#~ "           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
#~ "       )\n"
#~ "    end)\n"
#~ "\n"
#~ "    -- создать модели\n"
#~ "    local ok_m, pokemon = avro.create(schema.pokemon)\n"
#~ "    local ok_p, player = avro.create(schema.player)\n"
#~ "    if ok_m and ok_p then\n"
#~ "        -- скомпилировать модели\n"
#~ "        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
#~ "        local ok_cp, compiled_player = avro.compile(player)\n"
#~ "        if ok_cm and ok_cp then\n"
#~ "            -- начать игру\n"
#~ "            self.pokemon_model = compiled_pokemon\n"
#~ "            self.player_model = compiled_player\n"
#~ "            self.respawn()\n"
#~ "            log.info('Started')\n"
#~ "            return true\n"
#~ "         else\n"
#~ "            log.error('Schema compilation failed')\n"
#~ "         end\n"
#~ "    else\n"
#~ "        log.info('Schema creation failed')\n"
#~ "    end\n"
#~ "    return false\n"
#~ "end"

#~ msgid "Fibers"
#~ msgstr "Файберы"

#~ msgid ""
#~ "But wait! If we launch it as shown above -- ``self.respawn()`` -- the "
#~ "function will be executed only once, just like all the other methods. But we"
#~ " need to execute ``respawn()`` every 60 seconds. Creating a :ref:`fiber "
#~ "<fiber-module>` is the Tarantool way of making application logic work in the"
#~ " background at all times."
#~ msgstr ""
#~ "Но подождите! Если мы запустим функцию ``self.respawn()``, как показано "
#~ "выше, то она запустится только один раз, как и остальные методы. А нам "
#~ "необходимо запускать ``respawn()`` каждые 60 секунд. Tarantool заставляет "
#~ "логику приложения непрерывно работать в фоновом режиме с помощью "
#~ ":ref:`файбера <fiber-module>`."

#~ msgid ""
#~ "A **fiber** exists for executing instruction sequences but it is not a "
#~ "thread. The key difference is that threads use preemptive multitasking, "
#~ "while fibers use cooperative multitasking. This gives fibers the following "
#~ "two advantages over threads:"
#~ msgstr ""
#~ "**Файбер** предназначен для выполнения последовательностей команд, но это не"
#~ " поток. Ключевое отличие в том, что потоки используют многозадачность с "
#~ "реализацией приоритетов, тогда как файберы используют кооперативную "
#~ "многозадачность. Это дает файберам два преимущества над потоками:"

#~ msgid ""
#~ "Better controllability. Threads often depend on the kernel's thread "
#~ "scheduler to preempt a busy thread and resume another thread, so preemption "
#~ "may occur unpredictably. Fibers yield themselves to run another fiber while "
#~ "executing, so yields are controlled by application logic."
#~ msgstr ""
#~ "Улучшенная управляемость. Потоки часто зависят от планировщика потока ядра в"
#~ " вопросе вытеснения занятого потока и возобновления другого потока, поэтому "
#~ "вытеснение может быть непредвиденным. Файберы передают управление "
#~ "самостоятельно другому файберу во время работы, поэтому управление файберами"
#~ " осуществляется логикой приложения."

#~ msgid ""
#~ "Higher performance. Threads require more resources to preempt as they need "
#~ "to address the system kernel. Fibers are lighter and faster as they don't "
#~ "need to address the kernel to yield."
#~ msgstr ""
#~ "Повышенная производительность. Потокам необходимо больше ресурсов для "
#~ "вытеснения, поскольку они обращаются к ядру системы. Файберы легче и "
#~ "быстрее, поскольку для передачи управления им не нужно обращаться к ядру."

#~ msgid ""
#~ "Yet fibers have some limitations as compared with threads, the main "
#~ "limitation being no multi-core mode. All fibers in an application belong to "
#~ "a single thread, so they all use the same CPU core as the parent thread. "
#~ "Meanwhile, this limitation is not really serious for Tarantool applications,"
#~ " because a typical bottleneck for Tarantool is the HDD, not the CPU."
#~ msgstr ""
#~ "Однако у файберов есть определенные ограничения, по сравнению с потоками, "
#~ "основное из которых -- отсутствие режима работы с многоядерной системой. Все"
#~ " файберы в приложении относятся к одному потоку, поэтому они используют то "
#~ "же ядро процессора, что и родительский поток. В то же время, это ограничение"
#~ " незначительно для приложений Tarantool, поскольку узкое место Tarantool -- "
#~ "жесткий диск, а не ЦП."

#~ msgid ""
#~ "A fiber has all the features of a Lua `coroutine "
#~ "<http://www.lua.org/pil/contents.html#9>`_ and all programming concepts that"
#~ " apply for Lua coroutines will apply for fibers as well. However, Tarantool "
#~ "has made some enhancements for fibers and has used fibers internally. So, "
#~ "although use of coroutines is possible and supported, use of fibers is "
#~ "recommended."
#~ msgstr ""
#~ "У файбера есть все возможности `сопрограммы "
#~ "<http://www.lua.org/pil/contents.html#9>`_ на языке Lua, и все принципы "
#~ "программирования, которые применяются к сопрограммам на Lua, применимы и к "
#~ "файберам. Однако Tarantool расширил возможности файберов для внутреннего "
#~ "использования. Поэтому, несмотря на возможность и поддержку использования "
#~ "сопрограмм, рекомендуется использовать файберы."

#~ msgid ""
#~ "Well, performance or controllability are of little importance in our case. "
#~ "We'll launch ``respawn()`` in a fiber to make it work in the background all "
#~ "the time. To do so, we'll need to amend ``respawn()``:"
#~ msgstr ""
#~ "Производительность или управляемость не слишком важны в нашем случае. "
#~ "Запустим ``respawn()`` в файбере для непрерывной работы в фоновом режиме. "
#~ "Для этого необходимо изменить ``respawn()``:"

#~ msgid ""
#~ "respawn = function(self)\n"
#~ "    -- let's give our fiber a name;\n"
#~ "    -- this will produce neat output in fiber.info()\n"
#~ "    fiber.name('Respawn fiber')\n"
#~ "    while true do\n"
#~ "        for _, tuple in box.space.pokemons.index.status:pairs(\n"
#~ "                self.state.CAUGHT) do\n"
#~ "            box.space.pokemons:update(\n"
#~ "                tuple[self.ID],\n"
#~ "                {{'=', self.STATUS, self.state.ACTIVE}}\n"
#~ "            )\n"
#~ "        end\n"
#~ "        fiber.sleep(self.respawn_time)\n"
#~ "    end\n"
#~ "end"
#~ msgstr ""
#~ "respawn = function(self)\n"
#~ "    -- назовем наш файбер;\n"
#~ "    -- это выполнит чистый вывод в fiber.info()\n"
#~ "    fiber.name('Respawn fiber')\n"
#~ "    while true do\n"
#~ "        for _, tuple in box.space.pokemons.index.status:pairs(\n"
#~ "                self.state.CAUGHT) do\n"
#~ "            box.space.pokemons:update(\n"
#~ "                tuple[self.ID],\n"
#~ "                {{'=', self.STATUS, self.state.ACTIVE}}\n"
#~ "            )\n"
#~ "        end\n"
#~ "        fiber.sleep(self.respawn_time)\n"
#~ "    end\n"
#~ "end"

#~ msgid "and call it as a fiber in ``start()``:"
#~ msgstr "и назвать его файбером в ``start()``:"

#~ msgid ""
#~ "start = function(self)\n"
#~ "    -- create spaces and indexes\n"
#~ "        <...>\n"
#~ "    -- create models\n"
#~ "        <...>\n"
#~ "    -- compile models\n"
#~ "        <...>\n"
#~ "    -- start the game\n"
#~ "       self.pokemon_model = compiled_pokemon\n"
#~ "       self.player_model = compiled_player\n"
#~ "       fiber.create(self.respawn, self)\n"
#~ "       log.info('Started')\n"
#~ "    -- errors if schema creation or compilation fails\n"
#~ "       <...>\n"
#~ "end"
#~ msgstr ""
#~ "start = function(self)\n"
#~ "    -- создать спейсы и индексы\n"
#~ "        <...>\n"
#~ "    -- создать модели\n"
#~ "        <...>\n"
#~ "    -- скомпилировать модели\n"
#~ "        <...>\n"
#~ "    -- начать игру\n"
#~ "       self.pokemon_model = compiled_pokemon\n"
#~ "       self.player_model = compiled_player\n"
#~ "       fiber.create(self.respawn, self)\n"
#~ "       log.info('Started')\n"
#~ "    -- ошибки, если создание схемы или компиляция не работает\n"
#~ "       <...>\n"
#~ "end"

#~ msgid "Logging"
#~ msgstr "Запись в журнал"

#~ msgid ""
#~ "One more helpful function that we used in ``start()`` was ``log.infо()`` "
#~ "from Tarantool :ref:`log <log-module>` module. We also need this function in"
#~ " ``notify()`` to add a record to the log file on every successful catch:"
#~ msgstr ""
#~ "В  ``start()`` мы использовали еще одну полезную функцию -- ``log.infо()`` "
#~ "из :ref:`модуля log <log-module>` Tarantool . Эта функция также понадобится "
#~ "в ``notify()`` для добавления записи в файл журнала при каждой успешной "
#~ "поимке:"

#~ msgid ""
#~ "-- event notification\n"
#~ "notify = function(self, player, pokemon)\n"
#~ "    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
#~ "end"
#~ msgstr ""
#~ "-- уведомление о событии\n"
#~ "notify = function(self, player, pokemon)\n"
#~ "    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
#~ "end"

#~ msgid ""
#~ "We use default Tarantool :ref:`log settings <cfg_logging>`, so we'll see the"
#~ " log output in console when we launch our application in script mode."
#~ msgstr ""
#~ "Мы используем стандартные :ref:`настройки журнала <cfg_logging>` Tarantool, "
#~ "поэтому увидим вывод записей журнала в консоли, когда запустим приложение в "
#~ "режиме скрипта."

#~ msgid ""
#~ "Great! We've discussed all programming practices used in our Lua module (see"
#~ " `pokemon.lua "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/src/pokemon.lua>`_)."
#~ msgstr ""
#~ "Отлично! Мы обсудили все методики программирования, используемые в нашем  "
#~ "Lua-модуле (см. `pokemon.lua "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/src/pokemon.lua>`_)."

#~ msgid ""
#~ "Now let's prepare the test environment. As planned, we write a Lua "
#~ "application (see `game.lua "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/game.lua>`_) to initialize "
#~ "Tarantool's database module, initialize our game, call the game loop and "
#~ "simulate a couple of player requests."
#~ msgstr ""
#~ "Теперь подготовим среду тестирования. Как и планировалось, напишем "
#~ "приложение на языке Lua (см. `game.lua "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/game.lua>`_), чтобы "
#~ "инициализировать модуль базы данных Tarantool, инициализировать нашу игру, "
#~ "вызвать цикл игры и смоделировать пару запросов от игроков."

#~ msgid ""
#~ "To launch our microservice, we put both the ``pokemon.lua`` module and the "
#~ "``game.lua`` application in the current directory, install all external "
#~ "modules, and launch the Tarantool instance running our ``game.lua`` "
#~ "application (this example is for Ubuntu):"
#~ msgstr ""
#~ "Чтобы запустить микросервис, поместим модуль ``pokemon.lua`` и приложение  "
#~ "``game.lua`` в текущую директорию, установим все внешние модули и запустим "
#~ "экземпляр Tarantool с работающим приложением ``game.lua`` (это пример для "
#~ "Ubuntu):"

#~ msgid ""
#~ "$ ls\n"
#~ "game.lua  pokemon.lua\n"
#~ "$ sudo apt-get install tarantool-gis\n"
#~ "$ sudo apt-get install tarantool-avro-schema\n"
#~ "$ tarantool game.lua"
#~ msgstr ""
#~ "$ ls\n"
#~ "game.lua  pokemon.lua\n"
#~ "$ sudo apt-get install tarantool-gis\n"
#~ "$ sudo apt-get install tarantool-avro-schema\n"
#~ "$ tarantool game.lua"

#~ msgid ""
#~ "Tarantool starts and initializes the database. Then Tarantool executes the "
#~ "demo logic from ``game.lua``: adds a pokémon named Pikachu (its chance to be"
#~ " caught is very high, 99.1), displays the current map (it contains one "
#~ "active pokémon, Pikachu) and processes catch requests from two players. "
#~ "Player1 is located just near the lonely Pikachu pokémon and Player2 is "
#~ "located far away from it. As expected, the catch results in this output are "
#~ "\"true\" for Player1 and \"false\" for Player2. Finally, Tarantool displays "
#~ "the current map which is empty, because Pikachu is caught and temporarily "
#~ "inactive:"
#~ msgstr ""
#~ "Tarantool запускает и инициализирует базу данных. Затем Tarantool выполняет "
#~ "демо-логику из ``game.lua``: добавляет покемона под названием Пикачу "
#~ "(Pikachu) (шанс его поимки очень высок -- 99,1), отображает текущую карту "
#~ "(на ней расположен один активный покемон, Пикачу) и обрабатывает запросы "
#~ "поимки от двух игроков. Player1 (Игрок 1) находится очень близко к одинокому"
#~ " покемону Пикачу, а Player2 (Игрок 2) находится очень далеко от него. Как "
#~ "предполагается, результаты поимки в таком выводе будут \"true\" для Player1 "
#~ "и \"false\" для Player2. Наконец, Tarantool отображает текущую карту, "
#~ "которая пуста, потому что Пикачу пойман и временно неактивен:"

#~ msgid ""
#~ "$ tarantool game.lua\n"
#~ "2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version 1.7.3-43-gf5fa1e1\n"
#~ "2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
#~ "2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 bytes for tuple arena...\n"
#~ "2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty data directory\n"
#~ "2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
#~ "2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
#~ "2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept requests\n"
#~ "2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
#~ "---\n"
#~ "- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': 'Pikachu', 'chance': 99.1}\n"
#~ "...\n"
#~ "\n"
#~ "2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' caught 'Pikachu'\n"
#~ "true\n"
#~ "false\n"
#~ "--- []\n"
#~ "...\n"
#~ "\n"
#~ "2017-01-09 20:19:24.789 [6282] main C> entering the event loop"
#~ msgstr ""
#~ "$ tarantool game.lua\n"
#~ "2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version 1.7.3-43-gf5fa1e1\n"
#~ "2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
#~ "2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 bytes for tuple arena...\n"
#~ "2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty data directory\n"
#~ "2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
#~ "2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
#~ "2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept requests\n"
#~ "2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
#~ "---\n"
#~ "- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': 'Pikachu', 'chance': 99.1}\n"
#~ "...\n"
#~ "\n"
#~ "2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' caught 'Pikachu'\n"
#~ "true\n"
#~ "false\n"
#~ "--- []\n"
#~ "...\n"
#~ "\n"
#~ "2017-01-09 20:19:24.789 [6282] main C> entering the event loop"

#~ msgid "nginx"
#~ msgstr "nginx"

#~ msgid ""
#~ "In the real life, this microservice would work over HTTP. Let's add `nginx "
#~ "<https://nginx.org/en/>`_ web server to our environment and make a similar "
#~ "demo. But how do we make Tarantool methods callable via REST API? We use "
#~ "nginx with `Tarantool nginx upstream "
#~ "<https://github.com/tarantool/nginx_upstream_module>`_ module and create one"
#~ " more Lua script (`app.lua "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/src/app.lua>`_) that exports "
#~ "three of our game methods -- ``add_pokemon()``, ``map()`` and ``catch()`` --"
#~ " as REST endpoints of the nginx upstream module:"
#~ msgstr ""
#~ "В реальной жизни такой микросервис работал бы по HTTP. Добавим веб-сервер "
#~ "`nginx <https://nginx.org/en/>`_ в нашу среду и сделаем аналогичный пример. "
#~ "Но как вызывать методы Tarantool с помощью REST API? Мы используем nginx с "
#~ "модулем `Tarantool nginx upstream "
#~ "<https://github.com/tarantool/nginx_upstream_module>`_ и создадим еще один "
#~ "скрипт на Lua (`app.lua "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/src/app.lua>`_), который "
#~ "экспортирует три наших игровых метода -- ``add_pokemon()``, ``map()`` и "
#~ "``catch()`` -- в качестве конечных точек обработки запросов REST модуля "
#~ "nginx upstream:"

#~ msgid ""
#~ "local game = require('pokemon')\n"
#~ "box.cfg{listen=3301}\n"
#~ "game:start()\n"
#~ "\n"
#~ "-- add, map and catch functions exposed to REST API\n"
#~ "function add(request, pokemon)\n"
#~ "    return {\n"
#~ "        result=game:add_pokemon(pokemon)\n"
#~ "    }\n"
#~ "end\n"
#~ "\n"
#~ "function map(request)\n"
#~ "    return {\n"
#~ "        map=game:map()\n"
#~ "    }\n"
#~ "end\n"
#~ "\n"
#~ "function catch(request, pid, player)\n"
#~ "    local id = tonumber(pid)\n"
#~ "    if id == nil then\n"
#~ "        return {result=false}\n"
#~ "    end\n"
#~ "    return {\n"
#~ "        result=game:catch(id, player)\n"
#~ "    }\n"
#~ "end"
#~ msgstr ""
#~ "local game = require('pokemon')\n"
#~ "box.cfg{listen=3301}\n"
#~ "game:start()\n"
#~ "\n"
#~ "-- функции add, map и catch по REST API\n"
#~ "function add(request, pokemon)\n"
#~ "    return {\n"
#~ "        result=game:add_pokemon(pokemon)\n"
#~ "    }\n"
#~ "end\n"
#~ "\n"
#~ "function map(request)\n"
#~ "    return {\n"
#~ "        map=game:map()\n"
#~ "    }\n"
#~ "end\n"
#~ "\n"
#~ "function catch(request, pid, player)\n"
#~ "    local id = tonumber(pid)\n"
#~ "    if id == nil then\n"
#~ "        return {result=false}\n"
#~ "    end\n"
#~ "    return {\n"
#~ "        result=game:catch(id, player)\n"
#~ "    }\n"
#~ "end"

#~ msgid ""
#~ "An easy way to configure and launch nginx would be to create a Docker "
#~ "container based on a `Docker image "
#~ "<https://hub.docker.com/r/tarantool/tarantool-nginx/>`_ with nginx and the "
#~ "upstream module already installed (see `http/Dockerfile "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/http/Dockerfile>`_). We take "
#~ "a standard `nginx.conf "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/http/nginx.conf>`_, where we "
#~ "define an upstream with our Tarantool backend running (this is another "
#~ "Docker container, see details below):"
#~ msgstr ""
#~ "Чтобы с легкостью настроить и запустить nginx, необходимо создать Docker-"
#~ "контейнер на основе `Docker-образа <https://hub.docker.com/r/tarantool "
#~ "/tarantool-nginx/>`_ с уже установленными nginx и модулем upstream (см. "
#~ "`http/Dockerfile "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/http/Dockerfile>`_). Берем "
#~ "стандартный `nginx.conf "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/http/nginx.conf>`_, где "
#~ "определяем upstream с работающим бэкендом Tarantool (это еще один Docker-"
#~ "контейнер, см. нижеприведенную информацию):"

#~ msgid ""
#~ "upstream tnt {\n"
#~ "      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
#~ "      keepalive 250000;\n"
#~ "}"
#~ msgstr ""
#~ "upstream tnt {\n"
#~ "      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
#~ "      keepalive 250000;\n"
#~ "}"

#~ msgid ""
#~ "and add some Tarantool-specific parameters (see descriptions in the upstream"
#~ " module's `README "
#~ "<https://github.com/tarantool/nginx_upstream_module#directives>`_ file):"
#~ msgstr ""
#~ "и добавляем специальные параметры для Tarantool (см. описание в файле "
#~ "`README <https://github.com/tarantool/nginx_upstream_module#directives>`_ "
#~ "модуля upstream):"

#~ msgid ""
#~ "server {\n"
#~ "  server_name tnt_test;\n"
#~ "\n"
#~ "  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
#~ "\n"
#~ "  location = / {\n"
#~ "      root /usr/local/nginx/html;\n"
#~ "  }\n"
#~ "\n"
#~ "  location /api {\n"
#~ "    # answers check infinity timeout\n"
#~ "    tnt_read_timeout 60m;\n"
#~ "    if ( $request_method = GET ) {\n"
#~ "       tnt_method \"map\";\n"
#~ "    }\n"
#~ "    tnt_http_rest_methods get;\n"
#~ "    tnt_http_methods all;\n"
#~ "    tnt_multireturn_skip_count 2;\n"
#~ "    tnt_pure_result on;\n"
#~ "    tnt_pass_http_request on parse_args;\n"
#~ "    tnt_pass tnt;\n"
#~ "  }\n"
#~ "}"
#~ msgstr ""
#~ "server {\n"
#~ "  server_name tnt_test;\n"
#~ "\n"
#~ "  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
#~ "\n"
#~ "  location = / {\n"
#~ "      root /usr/local/nginx/html;\n"
#~ "  }\n"
#~ "\n"
#~ "  location /api {\n"
#~ "    # ответы проверяют бесконечное время ожидания\n"
#~ "    tnt_read_timeout 60m;\n"
#~ "    if ( $request_method = GET ) {\n"
#~ "       tnt_method \"map\";\n"
#~ "    }\n"
#~ "    tnt_http_rest_methods get;\n"
#~ "    tnt_http_methods all;\n"
#~ "    tnt_multireturn_skip_count 2;\n"
#~ "    tnt_pure_result on;\n"
#~ "    tnt_pass_http_request on parse_args;\n"
#~ "    tnt_pass tnt;\n"
#~ "  }\n"
#~ "}"

#~ msgid ""
#~ "Likewise, we put Tarantool server and all our game logic in a second Docker "
#~ "container based on the `official Tarantool 1.9 image "
#~ "<https://github.com/tarantool/docker>`_ (see `src/Dockerfile "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/src/Dockerfile>`_) and set "
#~ "the container's default command to ``tarantool app.lua``. This is the "
#~ "backend."
#~ msgstr ""
#~ "Аналогичным образом, поместим Tarantool-сервер и всю игровую логику в другой"
#~ " Docker-контейнер на основе `официального образа Tarantool 1.9 "
#~ "<https://github.com/tarantool/docker>`_ (см. `src/Dockerfile "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/src/Dockerfile>`_) и "
#~ "установим ``tarantool app.lua`` в качестве стандартной команды для "
#~ "контейнера. Это бэкенд."

#~ msgid "Non-blocking IO"
#~ msgstr "Неблокирующий ввод-вывод"

#~ msgid ""
#~ "To test the REST API, we create a new script (`client.lua "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/client/client.lua>`_), which "
#~ "is similar to our ``game.lua`` application, but makes HTTP POST and GET "
#~ "requests rather than calling Lua functions:"
#~ msgstr ""
#~ "Чтобы протестировать REST API, создадим новый скрипт (`client.lua "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/client/client.lua>`_), "
#~ "который похож на наше приложение ``game.lua``, но отправляет запросы HTTP "
#~ "POST и GET, а не вызывает Lua-функции:"

#~ msgid ""
#~ "local http = require('curl').http()\n"
#~ "local json = require('json')\n"
#~ "local URI = os.getenv('SERVER_URI')\n"
#~ "local fiber = require('fiber')\n"
#~ "\n"
#~ "local player1 = {\n"
#~ "    name=\"Player1\",\n"
#~ "    id=1,\n"
#~ "    location = {\n"
#~ "        x=1.0001,\n"
#~ "        y=2.0003\n"
#~ "    }\n"
#~ "}\n"
#~ "local player2 = {\n"
#~ "    name=\"Player2\",\n"
#~ "    id=2,\n"
#~ "    location = {\n"
#~ "        x=30.123,\n"
#~ "        y=40.456\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "local pokemon = {\n"
#~ "    name=\"Pikachu\",\n"
#~ "    chance=99.1,\n"
#~ "    id=1,\n"
#~ "    status=\"active\",\n"
#~ "    location = {\n"
#~ "        x=1,\n"
#~ "        y=2\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "function request(method, body, id)\n"
#~ "    local resp = http:request(\n"
#~ "        method, URI, body\n"
#~ "    )\n"
#~ "    if id ~= nil then\n"
#~ "        print(string.format('Player %d result: %s',\n"
#~ "            id, resp.body))\n"
#~ "    else\n"
#~ "        print(resp.body)\n"
#~ "    end\n"
#~ "end\n"
#~ "\n"
#~ "local players = {}\n"
#~ "function catch(player)\n"
#~ "    fiber.sleep(math.random(5))\n"
#~ "    print('Catch pokemon by player ' .. tostring(player.id))\n"
#~ "    request(\n"
#~ "        'POST', '{\"method\": \"catch\",\n"
#~ "        \"params\": [1, '..json.encode(player)..']}',\n"
#~ "        tostring(player.id)\n"
#~ "    )\n"
#~ "    table.insert(players, player.id)\n"
#~ "end\n"
#~ "\n"
#~ "print('Create pokemon')\n"
#~ "request('POST', '{\"method\": \"add\",\n"
#~ "    \"params\": ['..json.encode(pokemon)..']}')\n"
#~ "request('GET', '')\n"
#~ "\n"
#~ "fiber.create(catch, player1)\n"
#~ "fiber.create(catch, player2)\n"
#~ "\n"
#~ "-- wait for players\n"
#~ "while #players ~= 2 do\n"
#~ "    fiber.sleep(0.001)\n"
#~ "end\n"
#~ "\n"
#~ "request('GET', '')\n"
#~ "os.exit()"
#~ msgstr ""
#~ "local http = require('curl').http()\n"
#~ "local json = require('json')\n"
#~ "local URI = os.getenv('SERVER_URI')\n"
#~ "local fiber = require('fiber')\n"
#~ "\n"
#~ "local player1 = {\n"
#~ "    name=\"Player1\",\n"
#~ "    id=1,\n"
#~ "    location = {\n"
#~ "        x=1.0001,\n"
#~ "        y=2.0003\n"
#~ "    }\n"
#~ "}\n"
#~ "local player2 = {\n"
#~ "    name=\"Player2\",\n"
#~ "    id=2,\n"
#~ "    location = {\n"
#~ "        x=30.123,\n"
#~ "        y=40.456\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "local pokemon = {\n"
#~ "    name=\"Pikachu\",\n"
#~ "    chance=99.1,\n"
#~ "    id=1,\n"
#~ "    status=\"active\",\n"
#~ "    location = {\n"
#~ "        x=1,\n"
#~ "        y=2\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "function request(method, body, id)\n"
#~ "    local resp = http:request(\n"
#~ "        method, URI, body\n"
#~ "    )\n"
#~ "    if id ~= nil then\n"
#~ "        print(string.format('Player %d result: %s',\n"
#~ "            id, resp.body))\n"
#~ "    else\n"
#~ "        print(resp.body)\n"
#~ "    end\n"
#~ "end\n"
#~ "\n"
#~ "local players = {}\n"
#~ "function catch(player)\n"
#~ "    fiber.sleep(math.random(5))\n"
#~ "    print('Catch pokemon by player ' .. tostring(player.id))\n"
#~ "    request(\n"
#~ "        'POST', '{\"method\": \"catch\",\n"
#~ "        \"params\": [1, '..json.encode(player)..']}',\n"
#~ "        tostring(player.id)\n"
#~ "    )\n"
#~ "    table.insert(players, player.id)\n"
#~ "end\n"
#~ "\n"
#~ "print('Create pokemon')\n"
#~ "request('POST', '{\"method\": \"add\",\n"
#~ "    \"params\": ['..json.encode(pokemon)..']}')\n"
#~ "request('GET', '')\n"
#~ "\n"
#~ "fiber.create(catch, player1)\n"
#~ "fiber.create(catch, player2)\n"
#~ "\n"
#~ "-- подождать игроков\n"
#~ "while #players ~= 2 do\n"
#~ "    fiber.sleep(0.001)\n"
#~ "end\n"
#~ "\n"
#~ "request('GET', '')\n"
#~ "os.exit()"

#~ msgid ""
#~ "When you run this script, you’ll notice that both players have equal chances"
#~ " to make the first attempt at catching the pokémon. In a classical Lua "
#~ "script, a networked call blocks the script until it’s finished, so the first"
#~ " catch attempt can only be done by the player who entered the game first. In"
#~ " Tarantool, both players play concurrently, since all modules are integrated"
#~ " with Tarantool :ref:`cooperative multitasking <atomic-"
#~ "cooperative_multitasking>` and use non-blocking I/O."
#~ msgstr ""
#~ "При запуске этого скрипта вы заметите, что у обоих игроков одинаковые шансы "
#~ "сделать первую попытку поимки покемона. В классическом Lua-скрипте сетевой "
#~ "вызов блокирует скрипт, пока он не будет выполнен, поэтому первым попытаться"
#~ " поймать может тот игрок, который раньше зашел в игру. В Tarantool оба "
#~ "игрока играют одновременно, поскольку все модули объединены в "
#~ ":ref:`кооперативной многозадачности <atomic-cooperative_multitasking>` и "
#~ "используют неблокирующий ввод-вывод."

#~ msgid ""
#~ "Indeed, when Player1 makes its first REST call, the script doesn’t block. "
#~ "The fiber running ``catch()`` function on behalf of Player1 issues a non-"
#~ "blocking call to the operating system and yields control to the next fiber, "
#~ "which happens to be the fiber of Player2. Player2’s fiber does the same. "
#~ "When the network response is received, Player1's fiber is activated by "
#~ "Tarantool cooperative scheduler, and resumes its work. All Tarantool "
#~ ":ref:`modules <built_in_modules>` use non-blocking I/O and are integrated "
#~ "with Tarantool cooperative scheduler. For module developers, Tarantool "
#~ "provides an :ref:`API <index-c_api_reference>`."
#~ msgstr ""
#~ "Действительно, когда Player1 посылает первый REST-вызов, скрипт не "
#~ "блокируется. Файбер, выполняющий функцию ``catch()`` от Player1, посылает "
#~ "неблокирующий вызов в операционную систему и передает управление на "
#~ "следующий файбер, которым оказывается файбер от Player2. Файбер от Player2 "
#~ "делает то же самое. Когда получен сетевой ответ, файбер от Player1 "
#~ "активируется  с помощью кооперативного планировщика Tarantool и возобновляет"
#~ " работу. Все :ref:`модули <built_in_modules>` Tarantool используют "
#~ "неблокирующий ввод-вывод и интегрированы с кооперативным планировщиком "
#~ "Tarantool. Разработчикам модулей Tarantool предоставляет :ref:`API <index-"
#~ "c_api_reference>`."

#~ msgid ""
#~ "For our HTTP test, we create a third container based on the `official "
#~ "Tarantool 1.9 image <https://github.com/tarantool/docker>`_ (see "
#~ "`client/Dockerfile "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/client/Dockerfile>`_) and set"
#~ " the container's default command to ``tarantool client.lua``."
#~ msgstr ""
#~ "Для HTTP-теста создадим третий контейнер на основе `официального образа "
#~ "Tarantool 1.9 <https://github.com/tarantool/docker>`_ (см. "
#~ "`client/Dockerfile "
#~ "<https://github.com/tarantool/pokemon/blob/1.9/client/Dockerfile>`_)  "
#~ "установим ``tarantool client.lua`` в качестве стандартной команды для "
#~ "контейнера."

#~ msgid ""
#~ "To run this test locally, download our `pokemon "
#~ "<https://github.com/tarantool/pokemon>`_ project from GitHub and say:"
#~ msgstr ""
#~ "Чтобы запустить тест локально, скачайте наш проект `покемон "
#~ "<https://github.com/tarantool/pokemon>`_ из GitHub и вызовите:"

#~ msgid ""
#~ "$ docker-compose build\n"
#~ "$ docker-compose up"
#~ msgstr ""
#~ "$ docker-compose build\n"
#~ "$ docker-compose up"

#~ msgid ""
#~ "Docker Compose builds and runs all the three containers: ``pserver`` "
#~ "(Tarantool backend), ``phttp`` (nginx) and ``pclient`` (demo client). You "
#~ "can see log messages from all these containers in the console, pclient "
#~ "saying that it made an HTTP request to create a pokémon, made two catch "
#~ "requests, requested the map (empty since the pokémon is caught and "
#~ "temporarily inactive) and exited:"
#~ msgstr ""
#~ "Docker Compose собирает и запускает все три контейнера: ``pserver`` (бэкенд "
#~ "Tarantool), ``phttp`` (nginx) и``pclient`` (демо-клиент). ВЫ можете увидеть "
#~ "все сообщения журнала из всех этих контейнеров в консоли. pclient выведет, "
#~ "что сделал HTTP-запрос на создание покемона, два запроса на поимку покемона,"
#~ " запросил карту (пустая, поскольку покемон пойман и временно неактивен) и "
#~ "завершил работу:"

#~ msgid ""
#~ "pclient_1  | Create pokemon\n"
#~ "<...>\n"
#~ "pclient_1  | {\"result\":true}\n"
#~ "pclient_1  | {\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}\n"
#~ "pclient_1  | Catch pokemon by player 2\n"
#~ "pclient_1  | Catch pokemon by player 1\n"
#~ "pclient_1  | Player 1 result: {\"result\":true}\n"
#~ "pclient_1  | Player 2 result: {\"result\":false}\n"
#~ "pclient_1  | {\"map\":[]}\n"
#~ "pokemon_pclient_1 exited with code 0"
#~ msgstr ""
#~ "pclient_1  | Create pokemon\n"
#~ "<...>\n"
#~ "pclient_1  | {\"result\":true}\n"
#~ "pclient_1  | {\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}\n"
#~ "pclient_1  | Catch pokemon by player 2\n"
#~ "pclient_1  | Catch pokemon by player 1\n"
#~ "pclient_1  | Player 1 result: {\"result\":true}\n"
#~ "pclient_1  | Player 2 result: {\"result\":false}\n"
#~ "pclient_1  | {\"map\":[]}\n"
#~ "pokemon_pclient_1 exited with code 0"

#~ msgid ""
#~ "Congratulations! Here's the end point of our walk-through. As further "
#~ "reading, see more about :ref:`installing <app_server-installing_module>` and"
#~ " :ref:`contributing <app_server-contributing_module>` a module."
#~ msgstr ""
#~ "Поздравляем! Вот мы и закончили наш пошаговый пример. Для дальнейшего "
#~ "изучения рекомендуем :ref:`установку <app_server-installing_module>` и "
#~ ":ref:`добавление <app_server-contributing_module>` модуля."

#~ msgid ""
#~ "See also reference on :ref:`Tarantool modules <built_in_modules>` and "
#~ ":ref:`C API <index-c_api_reference>`, and don't miss our :ref:`Lua cookbook "
#~ "recipes <cookbook>`."
#~ msgstr ""
#~ "См. также справочник по :ref:`модулям Tarantool <built_in_modules>` и "
#~ ":ref:`C API <index-c_api_reference>` и не пропустите наши :ref:`рекомендации"
#~ " по разработке на Lua <cookbook>`."
