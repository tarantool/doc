
msgid "GIS"
msgstr ""

msgid ""
"Now let's discuss ``catch()``, which is the main method in our gaming logic."
msgstr ""

msgid ""
"Here we receive the player's coordinates and the target pokémon's ID number,"
" and we need to answer whether the player has actually caught the pokémon or"
" not (remember that each pokémon has a chance to escape)."
msgstr ""

msgid ""
"First thing, we validate the received player data against its :ref:`Avro "
"schema <app_server-avro_schemas>`. And we check whether such a pokémon "
"exists in our database and is displayed on the map (the pokémon must have "
"the active status):"
msgstr ""

msgid ""
"catch = function(self, pokemon_id, player)\n"
"    -- check player data\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- get pokemon data\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- more catch logic to follow\n"
"    <...>\n"
"end"
msgstr ""

msgid "Next, we calculate the answer: caught or not."
msgstr ""

msgid ""
"To work with geographical coordinates, we use Tarantool `gis "
"<https://github.com/tarantool/gis>`_ module."
msgstr ""

msgid ""
"To keep things simple, we don't load any specific map, assuming that we deal"
" with a world map. And we do not validate incoming coordinates, assuming "
"again that all received locations are within the planet Earth."
msgstr ""

msgid "We use two geo-specific variables:"
msgstr ""

msgid ""
"``wgs84``, which stands for the latest revision of the World Geodetic System"
" standard, `WGS84 "
"<https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. Basically, it"
" comprises a standard coordinate system for the Earth and represents the "
"Earth as an ellipsoid."
msgstr ""

msgid ""
"``nationalmap``, which stands for the `US National Atlas Equal Area "
"<https://epsg.io/2163>`_. This is a projected coordinates system based on "
"WGS84. It gives us a zero base for location projection and allows "
"positioning our players and pokémons in meters."
msgstr ""

msgid ""
"Both these systems are listed in the EPSG Geodetic Parameter Registry, where"
" each system has a unique number. In our code, we assign these listing "
"numbers to respective variables:"
msgstr ""

msgid ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"
msgstr ""

msgid ""
"For our game logic, we need one more variable, ``catch_distance``, which "
"defines how close a player must get to a pokémon before trying to catch it. "
"Let's set the distance to 100 meters."
msgstr ""

msgid "catch_distance = 100,"
msgstr ""

msgid ""
"Now we're ready to calculate the answer. We need to project the current "
"location of both player (``p_pos``) and pokémon (``m_pos``) on the map, "
"check whether the player is close enough to the pokémon (using "
"``catch_distance``), and calculate whether the player has caught the pokémon"
" (here we generate some random value and let the pokémon escape if the "
"random value happens to be less than 100 minus pokémon's chance value):"
msgstr ""

msgid ""
"-- project locations\n"
"local m_pos = gis.Point(\n"
"    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"local p_pos = gis.Point(\n"
"    {player.location.x, player.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"\n"
"-- check catch distance condition\n"
"if p_pos:distance(m_pos) > self.catch_distance then\n"
"    return false\n"
"end\n"
"-- try to catch pokemon\n"
"local caught = math.random(100) >= 100 - pokemon.chance\n"
"if caught then\n"
"    -- update and notify on success\n"
"    box.space.pokemons:update(\n"
"        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"    )\n"
"    self:notify(player, pokemon)\n"
"end\n"
"return caught"
msgstr ""
