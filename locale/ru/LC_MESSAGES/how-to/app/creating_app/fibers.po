
msgid "Fibers, yields and cooperative multitasking"
msgstr ""

msgid ""
"But wait! If we launch it as shown above -- ``self.respawn()`` -- the "
"function will be executed only once, just like all the other methods. But we"
" need to execute ``respawn()`` every 60 seconds. Creating a :ref:`fiber "
"<app-fibers>` is the Tarantool way of making application logic work in the "
"background at all times."
msgstr ""

msgid ""
"A **fiber** is a set of instructions that are executed with "
":ref:`cooperative multitasking <app-cooperative_multitasking>`: the "
"instructions contain :ref:`yield <app-yields>` signals, upon which control "
"is passed to another fiber."
msgstr ""

msgid ""
"Let's launch ``respawn()`` in a fiber to make it work in the background all "
"the time. To do so, we'll need to amend ``respawn()``:"
msgstr ""

msgid ""
"respawn = function(self)\n"
"    -- let's give our fiber a name;\n"
"    -- this will produce neat output in fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"
msgstr ""

msgid "and call it as a fiber in ``start()``:"
msgstr ""

msgid ""
"start = function(self)\n"
"    -- create spaces and indexes\n"
"        <...>\n"
"    -- create models\n"
"        <...>\n"
"    -- compile models\n"
"        <...>\n"
"    -- start the game\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- errors if schema creation or compilation fails\n"
"       <...>\n"
"end"
msgstr ""
