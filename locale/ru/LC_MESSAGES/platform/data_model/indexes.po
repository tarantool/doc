
msgid "Indexes"
msgstr "Индексы"

msgid ""
"Read the full information about indexes on page :doc:`Indexes "
"</book/box/indexes>`."
msgstr ""
"Всю информацию про индексы можно найти на странице :doc:`Индексы "
"</book/box/indexes>`."

msgid ""
"An **index** is a special data structure that stores a group of key values "
"and pointers. It is used for efficient manipulations with data."
msgstr ""
"**Индекс** — это специальная структура данных, которая хранит группу "
"ключевых значений и указателей. Индекс используется для эффективного "
"управления данными."

msgid ""
"As with spaces, you should specify the index **name** and let Tarantool come"
" up with a unique **numeric identifier** (\"index id\")."
msgstr ""
"Как и для спейсов, для индексов следует указать **имена**, а Tarantool "
"определит уникальный **числовой идентификатор** (\"ID индекса\")."

msgid ""
"An index always has a **type**. The default index type is :ref:`TREE "
"<indexes-tree>`. TREE indexes are provided by all Tarantool engines, can "
"index unique and non-unique values, support partial key searches, "
"comparisons, and ordered results. Additionally, the memtx engine supports "
":ref:`HASH <indexes-hash>`, :ref:`RTREE <indexes-rtree>` and :ref:`BITSET "
"<indexes-bitset>` indexes."
msgstr ""
"У индекса всегда есть определенный **тип**. Тип индекса по умолчанию — "
":ref:`TREE <indexes-tree>`. TREE-индексы поддерживаются обоими движками "
"Tarantool, могут индексировать уникальные и неуникальные значения, "
"поддерживают поиск по компонентам ключа, сравнение ключей и упорядочивание "
"результатов. Движок memtx поддерживает и другие типы индексов: :ref:`HASH "
"<indexes-hash>`, :ref:`RTREE <indexes-rtree>` и :ref:`BITSET <indexes-"
"bitset>`."

msgid ""
"An index may be **multi-part**, that is, you can declare that an index key "
"value is composed of two or more fields in the tuple, in any order. For "
"example, for an ordinary TREE index, the maximum number of parts is 255."
msgstr ""
"Индекс может быть **многокомпонентным**, то есть можно объявить, что ключ "
"индекса состоит из двух или более полей в кортеже в любом порядке. Например,"
" для обычного TREE-индекса максимальное количество частей равно 255."

msgid ""
"An index may be **unique**, that is, you can declare that it would be "
"illegal to have the same key value twice."
msgstr ""
"Индекс может быть **уникальным**, то есть можно объявить, что недопустимо "
"дважды задавать одно значение ключа."

msgid ""
"The first index defined on a space is called the **primary key index**, and "
"it must be unique. All other indexes are called **secondary indexes**, and "
"they may be non-unique."
msgstr ""
"Первый индекс, определенный для спейса, называется **первичный индекс**. Он "
"должен быть уникальным. Все остальные индексы называются **вторичными "
"индексами**, они могут строиться по неуникальным значениям."

msgid ""
"Indexes have certain limitations. See details on page :doc:`Limitations "
"</book/box/limitations>`."
msgstr ""
"На индексы распространяются определенные ограничения. Более подробную "
"информацию см. на странице :doc:`Ограничения </book/box/limitations>`."

msgid "Indexed field types"
msgstr "Типы индексированных полей"

msgid ""
"Not to be confused with :ref:`index types <index-types>` -- the types of the data structure that is an index. "
"See more about index types :ref:`below <index-types>`."
msgstr ""
"Типы полей не следует путать с :ref:`типами индексов <index-types>` как структур данных. "
"О типах индексов можно прочитать :ref:`ниже <index-types>`."

msgid ""
"Indexes restrict values that Tarantool can store with MsgPack. This is why, "
"for example, ``'unsigned'`` and ``'integer'`` are different field types, "
"although in MsgPack they are both stored as integer values. An "
"``'unsigned'`` index contains only *non-negative* integer values, while an "
"``‘integer’`` index contains *any* integer values."
msgstr ""
"Индексы ограничивают значения, которые Tarantool может хранить в формате "
"MsgPack. Вот почему, например, есть отдельные типы полей ``'unsigned'`` "
"(число без знака) и ``'integer'`` (целое число), хотя в MsgPack они оба "
"хранятся как целочисленные значения. Индекс типа ``'unsigned'`` содержит "
"только *неотрицательные* целочисленные значения, а индекс типа ``'integer'``"
" содержит *любые* целочисленные значения."

msgid ""
"The default field type is ``'unsigned'`` and the default index type is TREE. "
"Although ``'nil'`` is not a legal indexed field type, indexes may contain "
"`nil` :ref:`as a non-default option <box_space-is_nullable>`."
msgstr ""
"По умолчанию тип поля — ``'unsigned'``, тип индекса — TREE. "
"Хотя в качестве типа индексированого поля ``'nil'`` использовать нельзя, "
"индексы могут содержать `nil` как :ref:`опцию, которая не используется по "
"умолчанию <box_space-is_nullable>`."

msgid ""
"To learn more about field types, check the "
":ref:`Field type details <index_box_field_type_details>` section and the more elaborate"
" :ref:`Details about index field types <details_about_index_field_types>` in the reference."
msgstr ""
"Подробную информацию см. на странице :ref:`Описание типов полей <index_box_field_type_details>`, "
"а также в более развернутом :ref:`Описании типов индексированных полей "
"<details_about_index_field_types>` в справочнике."

msgid "Field type name string"
msgstr "Имя типа поля"

msgid "Field type |br|"
msgstr "Тип поля |br|"

msgid "Index type"
msgstr "Тип индекса"

msgid "``'boolean'``"
msgstr "``'boolean'``"

msgid ":ref:`boolean <index-box_boolean>`"
msgstr ":ref:`boolean <index-box_boolean>`"

msgid ":ref:`TREE or HASH <box_index-type>`"
msgstr ":ref:`TREE или HASH <box_index-type>`"

msgid "``'integer'`` (may also be called ``‘int’``)"
msgstr "``'integer'`` (также может называться ``‘int’``)"

msgid ":ref:`integer <index-box_integer>`, which may include unsigned values"
msgstr ""
":ref:`integer <index-box_integer>`, может включать в себя значения unsigned "
"(без знака)"

msgid "TREE or HASH"
msgstr "TREE или HASH"

msgid ""
"``'unsigned'`` (may also be called ``'uint'`` or ``'num'``, but ``'num'`` is"
" deprecated)"
msgstr ""
"``'unsigned'`` (без знака, также может называться ``'uint'`` или ``'num'``, "
"но ``'num'`` объявлен устаревшим)"

msgid ":ref:`unsigned <index-box_unsigned>`"
msgstr ":ref:`unsigned <index-box_unsigned>`"

msgid "TREE, BITSET, or HASH"
msgstr "TREE, BITSET или HASH"

msgid "``'double'``"
msgstr "``'double'``"

msgid ":ref:`double <index-box_double>`"
msgstr ":ref:`double <index-box_double>`"

msgid "``'number'``"
msgstr "``'number'``"

msgid ""
":ref:`number <index-box_number>`, which may include :ref:`integer <index-"
"box_integer>`, :ref:`double <index-box_double>`, or :ref:`decimal <index-box_decimal>` values"
msgstr ""
":ref:`number <index-box_number>`, может включать в себя значения типа "
":ref:`integer <index-box_integer>`, :ref:`double <index-box_double>` или :ref:`decimal <index-box_decimal>`"

msgid "``'decimal'``"
msgstr "``'decimal'``"

msgid ":ref:`decimal <index-box_decimal>`"
msgstr ":ref:`decimal <index-box_decimal>`"

msgid "``'string'`` (may also be called ``'str'``)"
msgstr "``'string'`` (строка, также может называться ``'str'``)"

msgid ":ref:`string <index-box_string>`"
msgstr ":ref:`string <index-box_string>`"

msgid "``'varbinary'``"
msgstr "``'varbinary'``"

msgid ":ref:`varbinary <index-box_bin>`"
msgstr ":ref:`varbinary <index-box_bin>`"

msgid "TREE, HASH, or BITSET (since version 2.7)"
msgstr "TREE, HASH или BITSET (с версии 2.7)"

msgid "``'uuid'``"
msgstr "``'uuid'``"

msgid ":ref:`uuid <index-box_uuid>`"
msgstr ":ref:`uuid <index-box_uuid>`"

msgid "``'array'``"
msgstr "``'array'``"

msgid ":ref:`array <index-box_array>`"
msgstr ":ref:`array <index-box_array>`"

msgid ":ref:`RTREE <box_index-rtree>`"
msgstr ":ref:`RTREE <box_index-rtree>`"

msgid "``'scalar'``"
msgstr "``'scalar'``"

msgid ""
"may include :ref:`nil <index-box_nil>`, :ref:`boolean <index-box_boolean>`, "
":ref:`integer <index-box_integer>`, :ref:`unsigned <index-box_unsigned>`, "
":ref:`number <index-box_number>`, :ref:`decimal <index-box_decimal>`, "
":ref:`string <index-box_string>`, :ref:`varbinary <index-box_bin>`, or "
":ref:`uuid <index-box_uuid>` values"
msgstr ""
"может содержать значения :ref:`nil <index-box_nil>`, :ref:`boolean <index-"
"box_boolean>`, :ref:`integer <index-box_integer>`, :ref:`unsigned <index-"
"box_unsigned>`, :ref:`number <index-box_number>`, :ref:`decimal <index-"
"box_decimal>`, :ref:`string <index-box_string>` или :ref:`varbinary <index-"
"box_bin>`"

msgid ""
"When a scalar field contains values of different underlying types, the key "
"order is: nils, then booleans, then numbers, then strings, then varbinaries,"
" then uuids."
msgstr ""
"Когда поле типа scalar содержит значения различных базовых типов, то порядок"
" ключей следующий: nil, затем boolean, затем number, затем string, затем "
"varbinary, затем uuid."

msgid ""
"To create a generator for indexes, you can use a sequence object. "
"Learn how to do it in the :ref:`tutorial <index-box_sequence>`."
msgstr ""
"Можно создать генератор индексов, используя последовательность (sequence). "
"Чтобы узнать подробности, обратитесь к :ref:`практическому руководству <index-box_sequence>`."


msgid "Index types"
msgstr "Типы индексов"

msgid ""
"An index always has a **type**. Different types are intended for different "
"usage scenarios."
msgstr ""
"Индекс всегда относится к определенному **типу**. Для разных сценариев "
"использования требуются разные типы индексов."

msgid "We give an overview of index features in the following table:"
msgstr "Обзор характеристик индексов приведен в следующей таблице:"

msgid "Feature"
msgstr "Характеристика"

msgid "TREE"
msgstr "TREE"

msgid "HASH"
msgstr "HASH"

msgid "RTREE"
msgstr "RTREE"

msgid "BITSET"
msgstr "BITSET"

msgid "unique"
msgstr "уникальный"

msgid "\\+"
msgstr "\\+"

msgid "\\-"
msgstr "\\-"

msgid "non-unique"
msgstr "неуникальный"

msgid ":ref:`is_nullable <box_space-is_nullable>`"
msgstr ":ref:`is_nullable <box_space-is_nullable>`"

msgid "can be multi-part"
msgstr "может быть составным (multi-part)"

msgid ":ref:`multikey <box_space-path_multikey>`"
msgstr ":ref:`индекс по массиву (multikey) <box_space-path_multikey>`"

msgid ":ref:`partial-key search <partial_key_search>`"
msgstr ":ref:`поиск по части ключа <partial_key_search>`"

msgid "can be primary key"
msgstr "может быть по первичному ключу"

msgid "``exclude_null`` (version 2.8+)"
msgstr "``exclude_null`` (версии 2.8+)"

msgid ":doc:`iterator types </reference/reference_lua/box_index/pairs>`"
msgstr ":doc:`типы итераторов </reference/reference_lua/box_index/pairs>`"

msgid "ALL, EQ, REQ, GT, GE, LT, LE"
msgstr "ALL, EQ, REQ, GT, GE, LT, LE"

msgid "ALL, EQ, GT"
msgstr "ALL, EQ, GT"

msgid "ALL, EQ, GT, GE, LT, LE, OVERLAPS, NEIGHBOR"
msgstr "ALL, EQ, GT, GE, LT, LE, OVERLAPS, NEIGHBOR"

msgid "ALL, EQ, BITS_ALL_SET, BITS_ANY_SET, BITS_ALL_NOT_SET"
msgstr "ALL, EQ, BITS_ALL_SET, BITS_ANY_SET, BITS_ALL_NOT_SET"

msgid "TREE indexes"
msgstr "TREE-индексы"

msgid ""
"The default index type is 'TREE'. TREE indexes are provided by memtx and "
"vinyl engines, can index unique and non-unique values, support partial key "
"searches, comparisons and ordered results."
msgstr ""
"Тип индекса по умолчанию — 'TREE'. Движки memtx и vinyl предоставляют TREE-"
"индексы, которые могут индексировать уникальные и неуникальные значения, "
"поддерживают поиск по компонентам ключа, сравнение ключей и упорядоченные "
"результаты."

msgid ""
"This is a universal type of indexes, for most cases it will be the best "
"choice."
msgstr ""
"Это универсальный тип индексов, в большинстве случаев он подойдет лучше "
"всего."

msgid "Additionally, memtx engine supports HASH, RTREE and BITSET indexes."
msgstr ""
"Кроме того, движок memtx поддерживает следующие типы индексов: HASH, RTREE и"
" BITSET."

msgid "HASH indexes"
msgstr "HASH-индексы"

msgid ""
"HASH indexes require unique fields and loses to TREE in almost all respects."
" So we do not recommend to use it in the applications. HASH is now present "
"in Tarantool mainly because of backward compatibility."
msgstr ""
"HASH-индексы требуют уникальности полей и почти во всех отношениях "
"проигрывают индексам типа TREE. Поэтому мы не рекомендуем использовать их в "
"приложениях. В настоящее время Tarantool поддерживает HASH в основном для "
"обратной совместимости."

msgid "Here are some tips. Do not use HASH index:"
msgstr "Вот несколько советов. Не используйте HASH-индекс:"

msgid "just if you want to"
msgstr "если просто хочется"

msgid "if you think that HASH is faster with no performance metering"
msgstr "если вы думаете, что HASH быстрее, без измерения производительности"

msgid "if you want to iterate over the data"
msgstr "если вы хотите выполнять перебор данных"

msgid "for primary key"
msgstr "по первичному ключу"

msgid "as an only index"
msgstr "как единственный индекс"

msgid "Use HASH index:"
msgstr "Используйте HASH-индекс:"

msgid "if it is a secondary key"
msgstr "если это вторичный ключ"

msgid "if you 100% won't need to make it non-unique"
msgstr ""
"если вы на сто процентов уверены, что его не придется делать неуникальным"

msgid ""
"if you have taken measurements on your data and you see an accountable "
"increase in performance"
msgstr ""
"если вы обнаружили значимое увеличение производительности в ходе проведенных"
" измерений"

msgid "if you save every byte on tuples (HASH is a little more compact)"
msgstr "если вы экономите каждый байт на кортежах (HASH немного компактнее)"

msgid "RTREE indexes"
msgstr "RTREE-индексы"

msgid ""
"RTREE is a multidimensional index supporting up to 20 dimensions. It is used"
" especially for indexing spatial information, such as geographical objects. "
"In :ref:`this example <box_index-rtree>` we demonstrate spatial searches via"
" RTREE index."
msgstr ""
"RTREE — это многомерный индекс, который поддерживает до 20 измерений. Он "
"используется, в частности, для индексирования пространственной информации, "
"такой как географические объекты. В :ref:`этом примере <box_index-rtree>` мы"
" показываем, как использовать пространственный поиск с помощью RTREE-"
"индекса."

msgid ""
"RTREE index could not be primary, and could not be unique. The option list "
"of this type of index may contain ``dimension`` and ``distance`` options. "
"The ``parts`` definition must contain the one and only part with type "
"``array``. RTREE index can accept two types of ``distance`` functions: "
"``euclid`` and ``manhattan``."
msgstr ""
"RTREE-индекс не может быть первичным и не может быть уникальным. Индекс "
"такого типа может содержать параметры измерения и расстояния — ``dimension``"
" и ``distance`` соответственно. Определение ``parts`` должно включать только"
" один компонент типа ``array``. RTREE-индекс может принимать два типа "
"функции расстояния ``distance``: ``euclid``, то есть Евклидова метрика, или "
"``manhattan``, то есть расстояние городских кварталов."

msgid "**Example 1:**"
msgstr "**Пример 1:**"

msgid ""
"my_space = box.schema.create_space(\"tester\")\n"
"my_space:format({ { type = 'number', name = 'id' }, { type = 'array', name = 'content' } })\n"
"hash_index = my_space:create_index('primary', { type = 'tree', parts = {'id'} })\n"
"rtree_index = my_space:create_index('spatial', { type = 'RTREE', unique = false, parts = {'content'} })"
msgstr ""
"my_space = box.schema.create_space(\"tester\")\n"
"my_space:format({ { type = 'number', name = 'id' }, { type = 'array', name = 'content' } })\n"
"hash_index = my_space:create_index('primary', { type = 'tree', parts = {'id'} })\n"
"rtree_index = my_space:create_index('spatial', { type = 'RTREE', unique = false, parts = {'content'} })"

msgid ""
"Corresponding tuple field thus must be an array of 2 or 4 numbers. 2 numbers"
" mean a point {x, y}; 4 numbers mean a rectangle {x1, y1, x2, y2}, where "
"(x1, y1) and (x2, y2) - diagonal point of the rectangle."
msgstr ""
"Таким образом, соответствующее поле кортежа может быть массивом типа array "
"из 2 или 4 чисел. 2 числа обозначают точку {x, y}; 4 числа обозначают "
"прямоугольник {x1, y1, x2, y2}, где (x1, y1) и (x2, y2) — диагональные точки"
" прямоугольника."

msgid ""
"my_space:insert{1, {1, 1}}\n"
"my_space:insert{2, {2, 2, 3, 3}}"
msgstr ""
"my_space:insert{1, {1, 1}}\n"
"my_space:insert{2, {2, 2, 3, 3}}"

msgid ""
"Selection results depend on a chosen iterator. The default EQ iterator "
"searches for an exact rectangle, a point is treated as zero width and height"
" rectangle:"
msgstr ""
"Результаты выборки зависят от выбранного итератора. Итератор EQ, который "
"используется по умолчанию, ищет точный прямоугольник, точка рассматривается "
"как прямоугольник нулевой ширины и высоты:"

msgid ""
"tarantool> rtree_index:select{1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n"
"\n"
"tarantool> rtree_index:select{1, 1, 1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n"
"\n"
"tarantool> rtree_index:select{2, 2}\n"
"---\n"
"- []\n"
"...\n"
"\n"
"tarantool> rtree_index:select{2, 2, 3, 3}\n"
"---\n"
"- - [2, [2, 2, 3, 3]]\n"
"..."
msgstr ""
"tarantool> rtree_index:select{1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n"
"\n"
"tarantool> rtree_index:select{1, 1, 1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n"
"\n"
"tarantool> rtree_index:select{2, 2}\n"
"---\n"
"- []\n"
"...\n"
"\n"
"tarantool> rtree_index:select{2, 2, 3, 3}\n"
"---\n"
"- - [2, [2, 2, 3, 3]]\n"
"..."

msgid ""
"Iterator ALL, which is the default when no key is specified, selects all "
"tuples in arbitrary order:"
msgstr ""
"Итератор ALL, который используется по умолчанию, если не указан ключ, "
"выбирает все кортежи в произвольном порядке:"

msgid ""
"tarantool> rtree_index:select{}\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."
msgstr ""
"tarantool> rtree_index:select{}\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."

msgid ""
"Iterator LE (less or equal) searches for tuples with their rectangles within"
" a specified rectangle:"
msgstr ""
"Итератор LE (меньше или равно) ищет кортежи с прямоугольниками, которые "
"находятся в пределах заданного прямоугольника:"

msgid ""
"tarantool> rtree_index:select({1, 1, 2, 2}, {iterator='le'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."
msgstr ""
"tarantool> rtree_index:select({1, 1, 2, 2}, {iterator='le'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."

msgid ""
"Iterator LT (less than, or strictly less) searches for tuples with their "
"rectangles strictly within a specified rectangle:"
msgstr ""
"Итератор LT (меньше или строго меньше) ищет кортежи с прямоугольниками, "
"которые находятся строго в пределах заданного прямоугольника:"

msgid ""
"tarantool> rtree_index:select({0, 0, 3, 3}, {iterator = 'lt'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."
msgstr ""
"tarantool> rtree_index:select({0, 0, 3, 3}, {iterator = 'lt'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."

msgid ""
"Iterator GE searches for tuples with a specified rectangle within their "
"rectangles:"
msgstr ""
"Итератор GE ищет кортежи с прямоугольниками, в пределах которых находится "
"заданный прямоугольник:"

msgid ""
"tarantool> rtree_index:select({1, 1}, {iterator = 'ge'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."
msgstr ""
"tarantool> rtree_index:select({1, 1}, {iterator = 'ge'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."

msgid ""
"Iterator GT searches for tuples with a specified rectangle strictly within "
"their rectangles:"
msgstr ""
"Итератор GT ищет кортежи с прямоугольниками, строго в пределах которых "
"находится заданный прямоугольник:"

msgid ""
"tarantool> rtree_index:select({2.1, 2.1, 2.9, 2.9}, {iterator = 'gt'})\n"
"---\n"
"- []\n"
"..."
msgstr ""

msgid ""
"Iterator OVERLAPS searches for tuples with their rectangles overlapping "
"specified rectangle:"
msgstr ""
"Итератор OVERLAPS ищет кортежи с прямоугольниками, перекрывающими указанный "
"прямоугольник:"

msgid ""
"tarantool> rtree_index:select({0, 0, 10, 2}, {iterator='overlaps'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."
msgstr ""
"tarantool> rtree_index:select({0, 0, 10, 2}, {iterator='overlaps'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."

msgid ""
"Iterator NEIGHBOR searches for all tuples and orders them by distance to the"
" specified point:"
msgstr ""
"Итератор NEIGHBOR ищет все кортежи и упорядочивает их по расстоянию до "
"заданной точки:"

msgid ""
"tarantool> for i=1,10 do\n"
"         >    for j=1,10 do\n"
"         >        my_space:insert{i*10+j, {i, j, i+1, j+1}}\n"
"         >    end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> rtree_index:select({1, 1}, {iterator = 'neighbor', limit = 5})\n"
"---\n"
"- - [11, [1, 1, 2, 2]]\n"
"  - [12, [1, 2, 2, 3]]\n"
"  - [21, [2, 1, 3, 2]]\n"
"  - [22, [2, 2, 3, 3]]\n"
"  - [31, [3, 1, 4, 2]]\n"
"..."
msgstr ""
"tarantool> for i=1,10 do\n"
"         >    for j=1,10 do\n"
"         >        my_space:insert{i*10+j, {i, j, i+1, j+1}}\n"
"         >    end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> rtree_index:select({1, 1}, {iterator = 'neighbor', limit = 5})\n"
"---\n"
"- - [11, [1, 1, 2, 2]]\n"
"  - [12, [1, 2, 2, 3]]\n"
"  - [21, [2, 1, 3, 2]]\n"
"  - [22, [2, 2, 3, 3]]\n"
"  - [31, [3, 1, 4, 2]]\n"
"..."

msgid "**Example 2:**"
msgstr "**Пример 2:**"

msgid ""
"3D, 4D and more dimensional RTREE indexes work in the same way as 2D except "
"that user must specify more coordinates in requests. Here's short example of"
" using 4D tree:"
msgstr ""
"3-мерные, 4-мерные или многомерные RTREE индексы используются так же, как и "
"для двумерные, только пользователь должен указать больше координат в "
"запросах. Вот небольшой пример использования для 4-мерного дерева:"

msgid ""
"tarantool> my_space = box.schema.create_space(\"tester\")\n"
"tarantool> my_space:format{ { type = 'number', name = 'id' }, { type = 'array', name = 'content' } }\n"
"tarantool> primary_index = my_space:create_index('primary', { type = 'TREE', parts = {'id'} })\n"
"tarantool> rtree_index = my_space:create_index('spatial', { type = 'RTREE', unique = false, dimension = 4, parts = {'content'} })\n"
"tarantool> my_space:insert{1, {1, 2, 3, 4}} -- insert 4D point\n"
"tarantool> my_space:insert{2, {1, 1, 1, 1, 2, 2, 2, 2}} -- insert 4D box\n"
"\n"
"tarantool> rtree_index:select{1, 2, 3, 4} -- find exact point\n"
"---\n"
"- - [1, [1, 2, 3, 4]]\n"
"...\n"
"\n"
"tarantool> rtree_index:select({0, 0, 0, 0, 3, 3, 3, 3}, {iterator = 'LE'}) -- select from 4D box\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"...\n"
"\n"
"tarantool> rtree_index:select({0, 0, 0, 0}, {iterator = 'neighbor'}) -- select neighbours\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"  - [1, [1, 2, 3, 4]]\n"
"..."
msgstr ""
"tarantool> my_space = box.schema.create_space(\"tester\")\n"
"tarantool> my_space:format{ { type = 'number', name = 'id' }, { type = 'array', name = 'content' } }\n"
"tarantool> primary_index = my_space:create_index('primary', { type = 'TREE', parts = {'id'} })\n"
"tarantool> rtree_index = my_space:create_index('spatial', { type = 'RTREE', unique = false, dimension = 4, parts = {'content'} })\n"
"tarantool> my_space:insert{1, {1, 2, 3, 4}} -- вставка 4D-точки\n"
"tarantool> my_space:insert{2, {1, 1, 1, 1, 2, 2, 2, 2}} -- вставка 4D-тела\n"
"\n"
"tarantool> rtree_index:select{1, 2, 3, 4} -- поиск определенной точки\n"
"---\n"
"- - [1, [1, 2, 3, 4]]\n"
"...\n"
"\n"
"tarantool> rtree_index:select({0, 0, 0, 0, 3, 3, 3, 3}, {iterator = 'LE'}) -- выборка из 4D-тела\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"...\n"
"\n"
"tarantool> rtree_index:select({0, 0, 0, 0}, {iterator = 'neighbor'}) -- выборка соседей\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"  - [1, [1, 2, 3, 4]]\n"
"..."

msgid ""
"Keep in mind that select NEIGHBOR iterator with unset limits extracts the "
"entire space in order of increasing distance. And there can be tons of data,"
" and this can affect the performance."
msgstr "Не рекомендуется использовать с операцией select итератор NEIGHBOR без указанного значения ``limit``. "
"В этом случае будет получен спейс целиком, упорядоченный по возрастанию расстояния. "
"Это может отразиться на производительности, поскольку в спейсе может храниться огромное количество данных."

msgid ""
"And another frequent mistake is to specify iterator type without quotes, in "
"such way: ``rtree_index:select(rect, {iterator = LE})``. This leads to "
"silent EQ select, because ``LE`` is undefined variable and treated as nil, "
"so iterator is unset and default used."
msgstr ""
"Другая типичная ошибка --- указать тип итератора без кавычек следующим "
"образом: ``rtree_index:select(rect, {iterator = LE})``. В этом случае "
"``LE`` представляет собой неопределенную переменную и обрабатывается как "
"nil, поэтому итератор считается незаданным, и будет использован итератор по "
"умолчанию EQ."

msgid "BITSET indexes"
msgstr "BITSET-индексы"

msgid ""
"Bitset is a bit mask. You should use it when you need to search by bit "
"masks. This can be, for example, storing a vector of attributes and "
"searching by these attributes."
msgstr ""
"Bitset — это битовая маска. BITSET следует использовать для поиска по "
"битовым маскам. Это может быть, например, сохранение вектора атрибутов и "
"поиск по этим атрибутам."

msgid ""
"The following script shows creating and searching with a BITSET index. "
"Notice that BITSET cannot be unique, so first a primary-key index is "
"created, and bit values are entered as hexadecimal literals for easier "
"reading."
msgstr ""
"Скрипт ниже показывает создание и поиск с помощью индекса BITSET. Обратите "
"внимание, что BITSET не может быть уникальным, поэтому сначала создается "
"индекс по первичному ключу, а битовые значения вводятся в шестнадцатеричном "
"виде для удобства чтения."

msgid ""
"tarantool> my_space = box.schema.space.create('space_with_bitset')\n"
"tarantool> my_space:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> my_space:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> my_space:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> my_space:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> my_space:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""
"tarantool> my_space = box.schema.space.create('space_with_bitset')\n"
"tarantool> my_space:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> my_space:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> my_space:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> my_space:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> my_space:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."

msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique = false, type = 'BITSET', parts = {2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, {iterator = 'BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique = false, type = 'BITSET', parts = {2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, {iterator = 'BITS_ANY_SET'})"

msgid "The result will be:"
msgstr "Получим следующий результат:"

msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0, и (3 AND 2) не равно 0."

msgid ""
"Additionally, there exist :doc:`index iterator operations "
"</reference/reference_lua/box_index/pairs>`. They can only be used with code"
" in Lua and C/C++. Index iterators are for traversing indexes one key at a "
"time, taking advantage of features that are specific to an index type. For "
"example, they can be used for evaluating Boolean expressions when traversing"
" BITSET indexes, or for going in descending order when traversing TREE "
"indexes."
msgstr ""
"Кроме того, есть :doc:`операции с итераторами с индексом "
"</reference/reference_lua/box_index/pairs>`. Их можно использовать только с "
"кодом на языках Lua и C/C++. Итераторы с индексом предназначены для обхода "
"индексов по одному ключу за раз, поскольку используют особенности каждого "
"типа индекса. Например, их можно использовать для оценки логических "
"выражений при обходе BITSET-индексов или при обходе TREE-индексов в порядке "
"по убыванию."
