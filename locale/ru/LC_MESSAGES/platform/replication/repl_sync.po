
msgid "Synchronous replication"
msgstr "Синхронная репликация"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"By default, replication in Tarantool is **asynchronous**: if a transaction "
"is committed locally on a master node, it does not mean it is replicated "
"onto any replicas. If a master responds success to a client and then dies, "
"after failover to a replica, from the client's point of view the transaction"
" will disappear."
msgstr ""
"По умолчанию репликация в Tarantool **асинхронная**: локальный коммит "
"транзакции на мастере не означает, что эта транзакция будет сразу же "
"выполнена на репликах. Если мастер сообщит клиенту об успешном выполнении "
"операции, а потом прекратит работу и после отказа восстановится на реплике, "
"то с точки зрения клиента транзакция пропадет."

msgid ""
"**Synchronous** replication exists to solve this problem. Synchronous "
"transactions are not considered committed and are not responded to a client "
"until they are replicated onto some number of replicas."
msgstr ""
"Эту проблему решает **синхронная** репликация. Каждая синхронная транзакция "
"проходит коммит лишь после репликации на некотором количестве экземпляров, и"
" только тогда клиенту приходит ответ о завершении транзакции."

msgid ""
"To learn how to enable and use synchronous replication, "
"check the :ref:`guide <how-to-repl_sync>`."
msgstr ""
"Подробная информация о включении и настройке синхронной репликации "
"приведена в :ref:`соответствующем руководстве <how-to-repl_sync>`."

msgid "Synchronous and asynchronous transactions"
msgstr "Синхронные и асинхронные транзакции"

msgid ""
"A killer feature of Tarantool's synchronous replication is its being *per-"
"space*. So, if you need it only rarely for some critical data changes, you "
"won't pay for it in performance terms."
msgstr ""
"В Tarantool синхронную репликацию можно настроить для отдельных спейсов. Эта"
" удобная функция позволит вам не потерять в производительности, если "
"синхронная репликация нужна вам лишь изредка для изменения критически важных"
" данных."

msgid ""
"When there is more than one synchronous transaction, they all wait for being"
" replicated. Moreover, if an asynchronous transaction appears, it will also "
"be blocked by the existing synchronous transactions. This behavior is very "
"similar to a regular queue of asynchronous transactions because all the "
"transactions are committed in the same order as they make the "
":ref:`box.commit() <box-commit>` call. So, here comes **the commit rule**: transactions are "
"committed in the same order as they make the ``box.commit()`` "
"call -- regardless of being synchronous or asynchronous."
msgstr ""
"Если наряду с несколькими синхронными транзакциями, ожидающими репликации, "
"совершается асинхронная транзакция, она блокируется синхронными. Коммиты при"
" этом выполняются в той последовательности, в которой для каждой из "
"транзакций вызывается метод :ref:`box.commit() <box-commit>`. Похожим образом работает "
"обычная очередь асинхронных транзакций. Можно сформулировать **правило "
"коммитов**: порядок коммитов соответствует порядку вызова ``box.commit()`` "
"для каждой из транзакций, независимо от того, синхронные транзакции или "
"асинхронные."

msgid ""
"If one of the waiting synchronous transactions times out and is rolled back,"
" it will first roll back all the newer pending transactions. Again, just "
"like how asynchronous transactions are rolled back when WAL write fails. So,"
" here comes **the rollback rule:** transactions are always rolled back in "
"the order reversed from the one they make the ``box.commit()`` "
"call -- regardless of being synchronous or asynchronous."
msgstr ""
"Если для одной из синхронных транзакций истечет время ожидания, эта "
"транзакция будет отменена, а вместе с ней и все последующие транзакции в "
"очереди на репликацию. Похожим образом отменяются и асинхронные транзакции "
"при ошибке записи в WAL. Действует **правило отмены**: транзакции отменяются"
" в порядке, обратном порядку вызова ``box.commit()`` для каждой из них, "
"независимо от того, синхронные транзакции или асинхронные."

msgid ""
"One more important thing is that if an asynchronous transaction is blocked "
"by a synchronous transaction, it does not become synchronous as well. This "
"just means it will wait for the synchronous transaction to be committed. But"
" once it is done, the asynchronous transaction will be committed "
"immediately -- it won't wait for being replicated itself."
msgstr ""
"Асинхронная транзакция, заблокированная синхронной, не становится сама "
"синхронной, а просто ожидает коммита синхронной транзакции. Как только это "
"произойдет, асинхронная транзакция сразу сможет пройти коммит, не ожидая "
"репликации."

msgid ""
"Be careful when using synchronous and asynchronous transactions together. "
"Asynchronous transactions are considered committed even if there is no "
"connection to other nodes. Therefore, an old leader node "
"(:ref:`synchronous transaction queue owner <box_info_synchro>`) might have "
"some committed asynchronous transactions that no other replica set member has."
msgstr ""
"Будьте осторожны при одновременном использовании синхронных и асинхронных транзакций. "
"Для асинхронных транзакций коммит засчитывается успешным даже в том случае, если нет "
"соединения с другими узлами. Поэтому на старом ``leader``-узле "
"(:ref:`владельце очереди синхронных транзакций <box_info_synchro>`) могут быть "
"асинхронные транзакции, которые прошли коммит, но отсутствуют на других узлах набора реплик."

msgid ""
"When the connection to such an old (previous) leader node is restored, "
"it starts receiving data from the new leader. At the same time, "
"other replica set members receive the data from the previous leader that they don't have yet. "
"The data from the previous leader contains some committed asynchronous transactions. "
"At this time, the integrity protection "
"will throw the :ref:`ER_SPLIT_BRAIN <repl_leader_elect_splitbrain>` error, "
"which will force the user to rebootstrap the previous leader."
msgstr ""
"Когда предыдущий лидер снова становится доступен в наборе реплик, "
"он начинает получать данные с нового лидера. В это же время "
"остальные узлы в наборе реплик начинают получать данные со старого лидера, которых у них еще нет. "
"Эти данные содержат и асинхронные транзакции, прошедшие коммит. "
"В этот момент система выдаст ошибку "
":ref:`ER_SPLIT_BRAIN <repl_leader_elect_splitbrain>`, заставляя "
"пользователя провести повторную настройку (rebootstrap) предыдущего лидера."

msgid "Limitations and known problems"
msgstr "Ограничения и известные проблемы"

msgid ""
"Until version :doc:`2.5.2 </release/2.5.2>`, there was no way to enable "
"synchronous replication for existing spaces, but since 2.5.2 it can be "
"enabled by :ref:`space_object:alter({is_sync = true}) <box_space-alter>`."
msgstr ""
"До версии :doc:`2.5.2 </release/2.5.2>` способа настроить синхронную "
"репликацию для существующих спейсов не было. Однако, начиная с версии 2.5.2,"
" ее можно включить, вызвав метод :ref:`space_object:alter({is_sync = true}) "
"<box_space-alter>`."

msgid ""
"Synchronous transactions work only for master-slave topology. You can have "
"multiple replicas, anonymous replicas, but only one node can make "
"synchronous transactions."
msgstr ""
"Синхронные транзакции работают исключительно в топологии \"мастер-реплика\"."
" В кластере может быть несколько реплик, в том числе анонимных, однако "
"синхронные транзакции должен совершать только один узел."

msgid ""
"Since Tarantool :doc:`2.10.0 </release/2.10.0>`, anonymous replicas "
"do not participate in the quorum."
msgstr ""
"Начиная с версии Tarantool :doc:`2.10.0 </release/2.10.0>`, анонимные реплики не участвуют в кворуме."

msgid "Leader election"
msgstr "Выборы лидера"

msgid ""
"Starting from version :doc:`2.6.1 </release/2.6.1>`, Tarantool has the "
"built-in functionality managing automated leader election in a replica set. "
"For more information, refer to the :ref:`corresponding chapter "
"<repl_leader_elect>`."
msgstr ""
"В Tarantool, начиная с версии :doc:`2.6.1 </release/2.6.1>`, есть встроенная"
" функциональность для управления автоматическими выборами лидера (automated "
"leader election) в наборе реплик. Подробности можно найти в "
":ref:`соответствующей главе <repl_leader_elect>`."
