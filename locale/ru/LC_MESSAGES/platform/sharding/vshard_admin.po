
msgid "Sharding with vshard"
msgstr "Шардирование с vshard"

msgid ""
"Sharding in Tarantool is implemented in the ``vshard`` module. "
"For a quick start with ``vshard``, refer to the :ref:`guide <vshard-quick-start>`."
msgstr ""
"Шардирование БД в Tarantool реализует модуль ``vshard``. "
"Вы можете обратиться к :ref:`руководству по быстрому запуску <vshard-quick-start>` "
"этого модуля."

msgid "Installation"
msgstr "Установка"

msgid ""
"The ``vshard`` module is distributed separately from the main Tarantool "
"package. To install the module, execute the following command:"
msgstr ""
"Модуль ``vshard`` не входит в основной дистрибутив Tarantool. Чтобы "
"установить модуль, выполните команду:"

msgid "$ tarantoolctl rocks install vshard"
msgstr "$ tarantoolctl rocks install vshard"

msgid ""
"The ``vshard`` module requires Tarantool of the version 1.10.1 or higher, "
":ref:`Tarantool development package <f_c_tutorial-c_stored_procedures>`, "
"``git``, ``cmake`` and ``gcc`` packages installed."
msgstr ""
"Для работы с модулем ``vshard`` необходимо установить: Tarantool версии "
"1.10.1 или выше, :ref:`пакет программ для разработки Tarantool "
"<f_c_tutorial-c_stored_procedures>`, ``git``, ``cmake`` и ``gcc``."

msgid "Configuration"
msgstr "Настройка"

msgid "Any viable sharded cluster consists of:"
msgstr "Любой рабочий сегментированный кластер состоит из:"

msgid ""
"one or more replica sets, each containing two or more :ref:`storage <vshard-"
"storage>` instances,"
msgstr ""
"одного или нескольких наборов реплик с двумя или несколькими "
":ref:`хранилищами <vshard-storage>` в каждом,"

msgid "one or more :ref:`router <vshard-router>` instances."
msgstr "одного или нескольких :ref:`роутеров <vshard-router>`."

msgid ""
"The number of ``storage`` instances in a replica set defines the redundancy "
"factor of the data. The recommended value is 3 or more. The number of "
"``router`` instances is not limited, because routers are completely "
"stateless. We recommend increasing the number of routers when an existing "
"``router`` instance becomes CPU or I/O bound."
msgstr ""
"Количество хранилищ в наборе реплик определяет коэффициент избыточности "
"данных. Рекомендуемое значение: 3 или более. Количество роутеров не "
"ограничено, потому что у роутеров нет состояния. Рекомендуем увеличивать "
"количество роутеров, если существующий экземпляр роутера ограничен "
"возможностями процессора или ввода-вывода."

msgid ""
"``vshard`` supports multiple ``router`` instances on a single Tarantool "
"instance. Each ``router`` can be connected to any ``vshard`` cluster. "
"Multiple ``router`` instances can be connected to the same cluster."
msgstr ""
"``vshard`` поддерживает работу с несколькими роутерами в отдельном "
"экземпляре Tarantool. Каждый роутер может подключиться к любому кластеру "
"``vshard``. Несколько роутеров могут быть подключены к одному кластеру."

msgid ""
"As the ``router`` and ``storage`` applications perform completely different "
"sets of functions, they should be deployed to different Tarantool instances."
" Although it is technically possible to place the router application on "
"every ``storage`` node, this approach is highly discouraged and should be "
"avoided on production deployments."
msgstr ""
"Поскольку приложения роутера (``router``) и хранилища (``storage``) "
"выполняют совершенно разные наборы функций, их следует разворачивать на "
"различных экземплярах Tarantool. Хотя технически возможно разместить "
"приложение роутера на каждом узле типа хранилища, такой подход крайне не "
"рекомендуется, и его следует избегать при развертывании в производственной "
"среде."

msgid ""
"All ``storage`` instances can be deployed using identical instance "
"(configuration) files."
msgstr ""
"Все хранилища можно развернуть, используя один набор файлов экземпляра "
"(конфигурационных файлов)."

msgid "Self-identification is currently performed using ``tarantoolctl``:"
msgstr ""
"Самоопределение в настоящий момент осуществляется с помощью "
"``tarantoolctl``:"

msgid "$ tarantoolctl instance_name"
msgstr "$ tarantoolctl имя_экземпляра"

msgid ""
"All ``router`` instances can also be deployed using identical instance "
"(configuration) files."
msgstr ""
"Все роутеры также можно развернуть, используя один набор файлов экземпляра "
"(конфигурационных файлов)."

msgid ""
"All cluster nodes must share a common topology. An administrator must ensure"
" that the configurations are identical. We suggest using a configuration "
"management tool like Ansible or Puppet to deploy the cluster."
msgstr ""
"Топология всех узлов кластера должна быть одинаковой. Администратор должен "
"убедиться, что конфигурации совпадают. Рекомендуем использовать инструмент "
"управления конфигурациями, такой как Ansible или Puppet, во время "
"развертывания кластера."

msgid ""
"Sharding is not integrated into any system for centralized configuration "
"management. It is expected that the application itself is responsible for "
"interacting with such a system and passing the sharding parameters."
msgstr ""
"Шардинг не интегрирован ни в одну систему для централизованного управления "
"конфигурациями. Предполагается, что само приложение отвечает за "
"взаимодействие с такой системой и передачу параметров шардинга."

msgid ""
"The configuration example of a simple sharded cluster is available "
":ref:`here <vshard-config-cluster-example>`."
msgstr ""
"Пример настройки простого сегментированного кластера можно найти :ref:`здесь"
" <vshard-config-cluster-example>`."

msgid "Replica weights"
msgstr "Вес реплики"

msgid ""
"The ``router`` sends all read-write requests to the master instance only. "
"Setting replica weights allows sending read-only requests not only to the "
"master instance, but to any available replica that is the 'nearest' to the "
"``router``. Weights are used to define distances between replicas within a "
"replica set."
msgstr ""
"Роутер отправляет все запросы чтения и записи только на мастер-экземпляр. "
"Задав вес реплики, можно разрешить отправку запросов только на чтение не "
"только на мастер-экземпляр, но и на доступную реплику, которая находится "
"ближе всего к роутеру. Вес используется для определения расстояния между "
"репликами в наборе реплик."

msgid ""
"Weights can be used, for example, to define the physical distance between "
"the ``router`` and each replica in each replica set. In this case read "
"requests are sent to the nearest replica (with the lowest weight)."
msgstr ""
"Например, вес можно использовать для определения физического расстояния "
"между роутером и каждой репликой в наборе реплик. В таком случае запросы на "
"чтение будут отправляться на ближайшую реплику (с наименьшим весом)."

msgid ""
"Setting weights can also help to define the most powerful replicas: the ones"
" that can process the largest number of requests per second."
msgstr ""
"Кроме того, можно задать вес реплик, чтобы определить наиболее мощную "
"реплику, которая может обрабатывать наибольшее количество запросов в "
"секунду."

msgid ""
"The idea is to specify the zone for every ``router`` and every replica, "
"therefore filling a matrix of relative zone weights. This approach allows "
"setting different weights in different zones for the same replica set."
msgstr ""
"Основная идея состоит в том, чтобы указать зону для каждого ``роутера`` и "
"каждой реплики, и таким образом составить матрицу относительных весов зоны. "
"Этот подход позволяет устанавливать разный вес в разных зонах для одного "
"набора реплик."

msgid ""
"To set weights, use the zone attribute for each replica during "
"configuration:"
msgstr ""
"Чтобы задать вес, используйте атрибут zone (зона) для каждой реплики во "
"время конфигурации:"

msgid ""
"local cfg = {\n"
"   sharding = {\n"
"      ['...replicaset_uuid...'] = {\n"
"         replicas = {\n"
"            ['...replica_uuid...'] = {\n"
"                 ...,\n"
"                 zone = <number or string>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"
msgstr ""
"local cfg = {\n"
"   sharding = {\n"
"      ['...uuid_набора_реплик...'] = {\n"
"         replicas = {\n"
"            ['...uuid_реплики...'] = {\n"
"                 ...,\n"
"                 zone = <число или строка>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"

msgid ""
"Then, specify relative weights for each zone pair in the ``weights`` "
"parameter of ``vshard.router.cfg``. For example:"
msgstr ""
"Затем укажите относительный вес для каждой пары зон в параметре ``weights`` "
"(вес) в ``vshard.router.cfg``. Например:"

msgid ""
"weights = {\n"
"    [1] = {\n"
"        [2] = 1, -- Routers of the 1st zone see the weight of the 2nd zone as 1.\n"
"        [3] = 2, -- Routers of the 1st zone see the weight of the 3rd zone as 2.\n"
"        [4] = 3, -- ...\n"
"    },\n"
"    [2] = {\n"
"        [1] = 10,\n"
"        [2] = 0,\n"
"        [3] = 10,\n"
"        [4] = 20,\n"
"    },\n"
"    [3] = {\n"
"        [1] = 100,\n"
"        [2] = 200, -- Routers of the 3rd zone see the weight of the 2nd zone as 200.\n"
"                   -- Mind that it is not equal to the weight of the 2nd zone visible\n"
"                   -- from the 1st zone (= 1).\n"
"        [4] = 1000,\n"
"    }\n"
"}\n"
"\n"
"local cfg = vshard.router.cfg({weights = weights, sharding = ...})"
msgstr ""
"weights = {\n"
"    [1] = {\n"
"        [2] = 1, -- Роутеры 1 зоны видят вес 2 зоны = 1.\n"
"        [3] = 2, -- Роутеры 1 зоны видят вес 3 зоны = 2 .\n"
"        [4] = 3, -- ...\n"
"    },\n"
"    [2] = {\n"
"        [1] = 10,\n"
"        [2] = 0,\n"
"        [3] = 10,\n"
"        [4] = 20,\n"
"    },\n"
"    [3] = {\n"
"        [1] = 100,\n"
"        [2] = 200, -- Роутеры 3 зоны видят вес 2 зоны = 200.\n"
"                   -- Обратите внимание, что этот вес не равен весу 2 зоны (= 2),\n"
"                   -- который видят роутеры 1 зоны (= 1).\n"
"        [4] = 1000,\n"
"    }\n"
"}\n"
"\n"
"local cfg = vshard.router.cfg({weights = weights, sharding = ...})"

msgid "Replica set weights"
msgstr "Вес набора реплик"

msgid ""
"A replica set weight is not the same as the replica weight. The weight of a "
"replica set defines the capacity of the replica set: the larger the weight, "
"the more buckets the replica set can store. The total size of all sharded "
"spaces in the replica set is also its capacity metric."
msgstr ""
"Вес набора реплик не равноценен весу реплики. Вес набора реплик определяет "
"производительность набора реплик: чем больше вес, тем больше сегментов может"
" хранить набор реплик. Общий размер всех сегментированных спейсов в наборе "
"реплик также определяет его производительность."

msgid ""
"You can consider replica set weights as the relative amount of data within a"
" replica set. For example, if ``replicaset_1 = 100``, and ``replicaset_2 = "
"200``, the second replica set stores twice as many buckets as the first one."
" By default, all weights of all replica sets are equal."
msgstr ""
"Вес набора реплик можно рассматривать как относительный объем данных в "
"наборе реплик. Например, если ``replicaset_1 = 100``, и ``replicaset_2 = "
"200``, второй набор реплик хранит в два раза больше сегментов, чем первый. "
"По умолчанию веса всех наборов реплик равны."

msgid ""
"You can use weights, for example, to store the prevailing amount of data on "
"a replica set with more memory space."
msgstr ""
"Вес можно использовать, к примеру, чтобы хранить преобладающий объем данных "
"в наборе реплик с большим объемом памяти."

msgid "Rebalancing process"
msgstr "Процесс балансировки"

msgid ""
"There is an **etalon number** of buckets for a replica set. (Etalon in this "
"context means \"ideal\".) If there is no deviation from this number in the "
"whole replica set, then the buckets are distributed evenly."
msgstr ""
"Существует **эталонное число** сегментов в наборе реплик (\"эталонный\" в "
"данном случае значит идеальный). Если во всем наборе реплик это число "
"остается неизменным, то сегменты распределяются равномерно."

msgid ""
"The etalon number is calculated automatically considering the number of "
"buckets in the cluster and weights of the replica sets."
msgstr ""
"Эталонное число рассчитывается автоматически с учетом количества сегментов в"
" кластере и веса наборов реплик."

msgid ""
"Rebalancing starts if the **disbalance threshold of a replica set** exceeds "
"the disbalance threshold :ref:`specified in the configuration <cfg_basic-"
"rebalancer_disbalance_threshold>`."
msgstr ""
"Балансировка начинается, когда **предел дисбаланса в наборе реплик** "
"превышает предел дисбаланса, :ref:`указанный в конфигурации<cfg_basic-"
"rebalancer_disbalance_threshold>`."

msgid "The disbalance threshold of a replica set is calculated as follows:"
msgstr "Предел дисбаланса набора реплик рассчитывается следующим образом:"

msgid ""
"|etalon_bucket_number - real_bucket_number| / etalon_bucket_number * 100"
msgstr ""
"|эталонное_число_сегментов - текущее_число_сегментов| / "
"эталонное_число_сегментов * 100"

msgid ""
"For example: The user specified the number of buckets is 3000, and weights "
"of 3 replica sets are 1, 0.5, and 1.5. The resulting etalon numbers of "
"buckets for the replica sets are: 1st replica set – 1000, 2nd replica set – "
"500, 3rd replica set – 1500."
msgstr ""
"Например: Пользователь указал, что количество сегментов = 3000, а вес 3 "
"наборов реплик составляет 1, 0,5 и 1,5. В результате получаем следующее "
"эталонное число сегментов для наборов реплик: 1 набор реплик – 1000, 2 набор"
" реплик – 500, 3 набор реплик – 1500."

msgid ""
"This approach allows assigning a zero weight to a replica set, which "
"initiates migration of its buckets to the remaining cluster nodes. It also "
"allows adding a new zero-load replica set, which initiates migration of the "
"buckets from the loaded replica sets to the zero-load replica set."
msgstr ""
"Такой подход позволяет назначить нулевой вес для набора реплик, который "
"запускает миграцию сегментов на оставшиеся узлы кластера. Это также "
"позволяет добавить новый набор реплик с нулевой нагрузкой, который запускает"
" миграцию сегментов из загруженных наборов реплик в набор реплик с нулевой "
"нагрузкой."

msgid ""
"A new zero-load replica set should be assigned a weight for rebalancing to "
"start."
msgstr ""
"Новому набору реплик с нулевой нагрузкой следует присвоить вес, чтобы начать"
" процесс балансировки."

msgid ""
"When a new shard is added, the configuration can be updated dynamically:"
msgstr "При добавлении нового шарда конфигурацию можно обновить динамически:"

msgid ""
"The configuration should be updated on all the ``routers`` first, and then "
"on all the ``storages``."
msgstr ""
"Конфигурацию следует сначала обновить на всех роутерах, а затем на всех "
"хранилищах."

msgid ""
"The new shard becomes available for rebalancing in the ``storage`` layer."
msgstr ""
"Новый шард становится доступен для балансирования на уровне хранилища."

msgid "As a result of rebalancing, buckets are migrated to the new shard."
msgstr ""
"В результате балансировки происходит миграция сегментов на новый шард."

msgid ""
"If a migrated bucket is requested, ``router`` receives an error code "
"containing information about the new location of the bucket."
msgstr ""
"Если происходит запрос к перемещенному сегменту, ``роутер`` получает код "
"ошибки с информацией о новом местонахождении сегмента."

msgid ""
"At this time, the new shard is already present in the ``router``'s pool of "
"connections, so redirection is transparent for the application."
msgstr ""
"В это время новый шард уже включен в пул соединений ``роутера``, поэтому "
"переадресация видима для приложения."

msgid "Parallel rebalancing"
msgstr "Параллельная балансировка"

msgid ""
"Originally, ``vshard`` had quite a simple ``rebalancer`` – one process on "
"one node that calculated *routes* which should send buckets, how many, and "
"to whom. The nodes applied these routes one by one sequentially."
msgstr ""
"Балансировщик в ``vshard`` первоначально был довольно прост: один процесс на"
" одном узле, который рассчитывал *маршруты* отправки сегментов, сколько их "
"отправлять и куда. Узлы применяли эти маршруты один за другим "
"последовательно."

msgid ""
"Unfortunately, such a simple schema worked not fast enough, especially for "
"Vinyl, where costs of reading disk were comparable with network costs. In "
"fact, with Vinyl the ``rebalancer`` routes applier was sleeping most of the "
"time."
msgstr ""
"К сожалению, такая простая схема работала недостаточно быстро, особенно для "
"Vinyl'а, где затраты ресурсов на чтение диска были сопоставимы с сетевыми "
"затратами. На самом деле, механизм применения маршрутов в балансировщике "
"Vinyl'а большую часть времени был в режиме ожидания."

msgid ""
"Now each node can send multiple buckets in parallel in a round-robin manner "
"to multiple destinations, or to just one."
msgstr ""
"Теперь каждый узел может параллельно посылать несколько сегментов по кругу в"
" несколько пунктов назначения или всего в один."

msgid ""
"To set the degree of parallelism, a new option was added -- "
":ref:`rebalancer_max_sending <cfg_basic-rebalancer_max_sending>`. You can "
"specify it in a storage configuration in the root table:"
msgstr ""
"Чтобы определять степень параллельности, используется новая опция "
":ref:`rebalancer_max_sending <cfg_basic-rebalancer_max_sending>`. Задавать "
"ее можно в конфигурации хранилища в корневой таблице:"

msgid ""
"cfg.rebalancer_max_sending = 5\n"
"vshard.storage.cfg(cfg, box.info.uuid)"
msgstr ""
"cfg.rebalancer_max_sending = 5\n"
"vshard.storage.cfg(cfg, box.info.uuid)"

msgid "In routers, this option is ignored."
msgstr "Этот параметр не учитывается для роутеров."

msgid ""
"Specifying ``cfg.rebalancer_max_sending = N`` probably won't give N times "
"speed up. It depends on network, disk, number of other fibers in the system."
msgstr ""
"Задав ``cfg.rebalancer_max_sending = N``, вы вряд ли получите N-кратное "
"ускорение. На это влияют многие факторы: сеть, диск, количество других "
"файберов в системе."

msgid "**Example #1:**"
msgstr "**Пример №1:**"

msgid ""
"You have 10 replica sets and a new one is added. Now all the 10 replica sets"
" will try to send buckets to the new one."
msgstr ""
"У вас уже есть 10 наборов реплик, добавили новый. Теперь все 10 наборов "
"реплик будут пытаться отправить сегменты на новый."

msgid ""
"Assume that each replica set can send up to 5 buckets at once. In that case,"
" the new replica set will experience a rather big load of 50 buckets being "
"downloaded at once. If the node needs to do some other work, perhaps such a "
"big load is undesirable. Also too many parallel buckets can cause timeouts "
"in the rebalancing process itself."
msgstr ""
"Предположим, каждый набор реплик может отправить до 5 сегментов "
"одновременно. В этом случае будет довольно большая нагрузка на новый набор "
"реплик: одновременная загрузка 50 сегментов. Если узлу нужно выполнить "
"какую-то другую работу, возможно, такая большая нагрузка нежелательна. Кроме"
" того, слишком большое количество параллельно загружаемых сегментов может "
"привести к задержкам самого процесса балансировки."

msgid ""
"To fix the problem, you can set a lower value for ``rebalancer_max_sending``"
" for old replica sets, or decrease ``rebalancer_max_receiving`` for the new "
"one. In the latter case some workers on old nodes will be throttled, and you"
" will see that in the logs."
msgstr ""
"Чтобы исправить это, можно установить меньшее значение "
"``rebalancer_max_sending`` для старых наборов реплик или же уменьшить "
"``rebalancer_max_receiving`` для нового набора реплик. В последнем случае "
"будет происходить управление загрузкой на старых узлах, и вы увидите это в "
"логах."

msgid ""
"``rebalancer_max_sending`` is important, if you have restrictions for the "
"maximal number of buckets that can be read-only at once in the cluster. As "
"you remember, when a bucket is being sent, it does not accept new write "
"requests."
msgstr ""
"Важно значение параметра ``rebalancer_max_sending``, если у вас есть "
"ограничение на максимальное количество сегментов, которые могут быть "
"одновременно доступны только для чтения в кластере. Как упоминалось выше, во"
" время отправки сегмент не принимает новые запросов на запись."

msgid "**Example #2:**"
msgstr "**Пример №2:**"

msgid ""
"You have 100000 buckets and each bucket stores ~0.001% of your data. The "
"cluster has 10 replica sets. And you never can afford > 0.1% of data locked "
"on write. Then you should not set ``rebalancer_max_sending`` > 10 on these "
"nodes. It guarantees that the rebalancer won't send more than 100 buckets at"
" once in the whole cluster."
msgstr ""
"У вас есть 100 000 сегментов, и каждый сегмент хранит ~ 0,001% ваших данных."
" В кластере 10 наборов реплик. И нельзя позволить себе заблокировать для "
"записи > 0,1% данных. Таким образом, не следует устанавливать значение "
"``rebalancer_max_sending`` > 10 на этих узлах. Тогда балансировщик не будет "
"посылать более 100 сегментов одновременно по всему кластеру."

msgid ""
"If ``max_sending`` is too high and ``max_receiving`` is too low, then some "
"buckets will try to get relocated – and will fail with that. This problem "
"will consume network resources and time. It is important to configure these "
"parameters to not conflict with each other."
msgstr ""
"Если значение ``max_sending`` задано слишком высоко, а ``max_receiving`` "
"слишком низко, то некоторые сегменты будут пытаться переместиться -- и не "
"смогут. При этом будут расходоваться сетевые ресурсы и время. Важно "
"настроить эти параметры так, чтобы они не конфликтовали друг с другом."

msgid "Replica set lock and bucket pin"
msgstr "Блокировка набора реплик и закрепление корзины"

msgid ""
"A replica set lock makes a replica set invisible to the ``rebalancer``: a "
"locked replica set can neither receive new buckets nor migrate its own "
"buckets."
msgstr ""
"Блокировка набора реплик делает набор реплик невидимым для балансировщика: "
"заблокированный набор реплик не может ни принимать новые сегменты, ни "
"мигрировать собственные сегменты."

msgid ""
"A bucket pin blocks a specific bucket from migrating: a pinned bucket stays "
"on the replica set to which it is pinned, until it is unpinned."
msgstr ""
"В результате закрепления сегмента определенный сегмент блокируется для "
"миграции: закрепленный сегмент остается в наборе реплик, в котором он "
"закреплен, до отмены закрепления."

msgid ""
"Pinning all replica set buckets is not equivalent to locking a replica set. "
"Even if you pin all buckets, a non-locked replica set can still receive new "
"buckets."
msgstr ""
"Закрепление всех сегментов в наборе реплик не означает блокирование набора "
"реплик. Даже после закрепления всех сегментов незаблокированный набор реплик"
" может принимать новые сегменты."

msgid ""
"Replica set lock is helpful, for example, to separate a replica set from "
"production replica sets for testing, or to preserve some application "
"metadata that must not be sharded for a while. A bucket pin is used for "
"similar cases but in a smaller scope."
msgstr ""
"Блокировка набора реплик используется, к примеру, чтобы выделить для "
"тестирования набор реплик из наборов реплик, используемых в производстве, "
"или чтобы сохранить некоторые метаданные приложения, которые в течение "
"некоторого времени не должны быть сегментированы. Закрепление сегмента "
"используется в похожих случаях, но в меньшем масштабе."

msgid ""
"By both locking a replica set and pinning all buckets, one can isolate an "
"entire replica set."
msgstr ""
"Блокировка набора реплик и закрепление всех сегментов означает изоляцию "
"целого набора реплик."

msgid ""
"Locked replica sets and pinned buckets affect the rebalancing algorithm as "
"the ``rebalancer`` must ignore locked replica sets and consider pinned "
"buckets when attempting to reach the best possible balance."
msgstr ""
"Заблокированные наборы реплик и закрепленные сегменты влияют на алгоритм "
"балансировки, так как ``балансировщик`` должен игнорировать заблокированные "
"наборы реплик и учитывать закрепленные сегменты при попытке достичь "
"наилучшего возможного баланса."

msgid ""
"The issue is not trivial as a user can pin too many buckets to a replica "
"set, so a perfect balance becomes unreachable. For example, consider the "
"following cluster (assume all replica set weights are equal to 1)."
msgstr ""
"Это нетривиальная задача, поскольку пользователь может закрепить слишком "
"много сегментов в наборе реплик, так что становится невозможным достижение "
"идеального баланса. Например, рассмотрим следующий кластер (предположим, что"
" все веса наборов реплик равны 1)."

msgid "The initial configuration:"
msgstr "Начальная конфигурация:"

msgid ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120"
msgstr ""
"rs1: bucket_count = 150 -- число сегментов\n"
"rs2: bucket_count = 150, pinned_count = 120 -- число сегментов, число закрепленных сегментов"

msgid "Adding a new replica set:"
msgstr "Добавление нового набора реплик:"

msgid ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"
msgstr ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"

msgid ""
"The perfect balance would be ``100 - 100 - 100``, which is impossible since "
"the ``rs2`` replica set has 120 pinned buckets. The best possible balance "
"here is the following:"
msgstr ""
"Идеальным балансом было бы ``100 - 100 - 100``, чего невозможно достичь, "
"поскольку набор реплик ``rs2`` содержит 120 закрепленных сегментов. The best"
" possible balance here is the following:"

msgid ""
"rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"
msgstr ""
"rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"

msgid ""
"The ``rebalancer`` moved as many buckets as possible from ``rs2`` to "
"decrease the disbalance. At the same time it respected equal weights of "
"``rs1`` and ``rs3``."
msgstr ""
"``Балансировщик`` переместил максимально возможное количество сегментов из "
"``rs2``, чтобы уменьшить дисбаланс. В то же время он учел одинаковый вес "
"respected ``rs1`` и ``rs3``."

msgid ""
"The algorithms for implementing locks and pins are completely different, "
"although they look similar in terms of functionality."
msgstr ""
"Алгоритмы реализации блокировки и закрепления совершенно разные, хотя с "
"точки зрения функций они похожи."

msgid "Replica set lock and rebalancing"
msgstr "Заблокированный набор реплик и балансировка"

msgid ""
"Locked replica sets simply do not participate in rebalancing. This means "
"that even if the actual total number of buckets is not equal to the etalon "
"number, the disbalance cannot be fixed due to the lock. When the rebalancer "
"detects that one of the replica sets is locked, it recalculates the etalon "
"number of buckets of the non-locked replica sets as if the locked replica "
"set and its buckets did not exist at all."
msgstr ""
"Заблокированные наборы реплик просто не участвуют в балансировке. Это "
"означает, что даже если фактическое общее количество сегментов не равно "
"эталонному числу, дисбаланс нельзя исправить из-за блокировки. Когда "
"балансировщик обнаруживает, что один из наборов реплик заблокирован, он "
"пересчитывает эталонное число сегментов неблокированных наборов реплик, как "
"если бы заблокированный набор реплик и его сегменты вообще не существовали."

msgid "Bucket pin and rebalancing"
msgstr "Закрепленный набор реплик и балансировка"

msgid ""
"Rebalancing replica sets with pinned buckets requires a more complex "
"algorithm. Here ``pinned_count[o]`` is the number of pinned buckets, and "
"``etalon_count`` is the etalon number of buckets for a replica set:"
msgstr ""
"Балансировка наборов реплик с закрепленными сегментами требует более "
"сложного алгоритма. Здесь ``pinned_count[o]`` -- это число закрепленных "
"сегментов, а ``etalon_count`` -- это эталонное число сегментов для набора "
"реплик:"

msgid ""
"The ``rebalancer`` calculates the etalon number of buckets as if all buckets"
" were not pinned. Then the rebalancer checks each replica set and compares "
"the etalon number of buckets with the number of pinned buckets in a replica "
"set. If ``pinned_count < etalon_count``, non-locked replica sets (at this "
"point all locked replica sets already are filtered out) with pinned buckets "
"can receive new buckets."
msgstr ""
"Балансировщик рассчитывает эталонное число сегментов, как если бы все "
"сегменты не были закреплены. Затем балансировщик проверяет каждый набор "
"реплик и сопоставляет эталонное число сегментов с числом закрепленных "
"сегментов в наборе реплик. Если ``pinned_count < etalon_count``, "
"незаблокированные наборы реплик (на данном этапе все заблокированные наборы "
"реплик уже отфильтрованы) с закрепленными сегментами могут получать новые "
"сегменты."

msgid ""
"If ``pinned_count > etalon_count``, the disbalance cannot be fixed, as the "
"``rebalancer`` cannot move pinned buckets out of this replica set. In such a"
" case the etalon number is updated and set equal to the number of pinned "
"buckets. The replica sets with ``pinned_count > etalon_count`` are not "
"processed by the ``rebalancer``, and the number of pinned buckets is "
"subtracted from the total number of buckets. The rebalancer tries to move "
"out as many buckets as possible from such replica sets."
msgstr ""
"Если же ``pinned_count > etalon_count``, дисбаланс исправить нельзя, так как"
" балансировщик не может вывести закрепленные сегменты из этого набора "
"реплик. В таком случае эталонное число обновляется как равное числу "
"закрепленных сегментов. Наборы реплик с ``pinned_count > etalon_count`` не "
"обрабатываются балансировщиком`, а число закрепленных сегментов вычитается "
"из общего числа сегментов. Балансировщик пытается вывести как можно больше "
"сегментов из таких наборов реплик."

msgid ""
"This procedure is restarted from step 1 for replica sets with ``pinned_count"
" >= etalon_count`` until ``pinned_count <= etalon_count`` on all replica "
"sets. The procedure is also restarted when the total number of buckets is "
"changed."
msgstr ""
"Эта процедура перезапускается с шага 1 для наборов реплик с ``pinned_count "
">= etalon_count`` до тех пор, пока не будет выполнено условие ``pinned_count"
" <= etalon_count`` для всех наборов реплик. Процедура также перезапускается "
"при изменении общего числа сегментов."

msgid "Here is the pseudocode for the algorithm:"
msgstr "Псевдокод для данного алгоритма будет следующим:"

msgid ""
"function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- rebalance the buckets using weights of the still viable replica sets --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"
msgstr ""
"function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- балансировка сегментов с использованием веса рабочих наборов реплик --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"

msgid ""
"The complexity of the algorithm is ``O(N^2)``, where N is the number of "
"replica sets. On each step, the algorithm either finishes the calculation, "
"or ignores at least one new replica set overloaded with the pinned buckets, "
"and updates the etalon number of buckets on other replica sets."
msgstr ""
"Сложность алгоритма составляет ``O(N^2)``, где N -- количество наборов "
"реплик. На каждом шаге алгоритм либо завершает вычисление, либо игнорирует "
"хотя бы один новый набор реплик, перегруженный закрепленными сегментами, и "
"обновляет эталонное число сегментов в других наборах реплик."

msgid "Bucket ref"
msgstr "Ссылка в сегменте"

msgid ""
"Bucket ref is an in-memory counter that is similar to the :ref:`bucket pin "
"<vshard-lock-pin>`, but has the following differences:"
msgstr ""
"Ссылка в сегменте -- это счетчик в оперативной памяти, который похож на "
":ref:`закрепление сегмента <vshard-lock-pin>` со следующими отличиями:"

msgid ""
"Bucket ref is not persistent. Refs are intended for forbidding bucket "
"transfer during request execution, but on restart all requests are dropped."
msgstr ""
"Ссылка в сегменте никогда не сохраняется. Ссылки предназначены для запрета "
"передачи сегментов во время выполнения запроса, но при перезапуске все "
"запросы отбрасываются."

msgid ""
"There are two types of bucket refs: read-only (RO) and read-write (RW)."
msgstr ""
"Есть 2 типа ссылок в сегменте: только чтение (RO) и чтение-запись (RW)."

msgid ""
"If a bucket has RW refs, it cannot be moved. However, when the rebalancer "
"needs it to be sent, it locks the bucket for new write requests, waits until"
" all current requests are finished, and then sends the bucket."
msgstr ""
"Если в сегменте есть ссылки типа RW, его нельзя перемещать. Однако, если "
"балансировщику требуется отправка этого сегмента, он блокирует его для новых"
" запросов на запись, ожидает завершения всех текущих запросов, а затем "
"отправляет сегмент."

msgid ""
"If a bucket has RO refs, it can be sent, but cannot be dropped. Such a "
"bucket can even enter GARBAGE or SENT state, but its data is kept until the "
"last reader is gone."
msgstr ""
"Если в сегменте есть ссылки типа RO, его можно отправить, но нельзя удалить."
" Такой сегмент может даже перейти в статус мусора GARBAGE или отправки SENT,"
" но его данные сохраняются до тех пор, пока не уйдет последний читатель."

msgid "A single bucket can have both RO and RW refs."
msgstr "В одном сегменте могут быть ссылки как типа RO, так и типа RW."

msgid "Bucket ref is countable."
msgstr "Ссылки в сегменте исчисляются."

msgid ""
"The :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` methods"
" are called automatically when :ref:`vshard.router.call() <router_api-call>`"
" or :ref:`vshard.storage.call() <storage_api-call>` is used. For raw API "
"like ``r = vshard.router.route() r:callro/callrw`` you should explicitly "
"call the ``bucket_ref()`` method inside the function. Also, make sure that "
"you call ``bucket_unref()`` after ``bucket_ref()``, otherwise the bucket "
"cannot be moved from the storage until the instance restart."
msgstr ""
"Методы :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` "
"вызываются автоматически при использовании :ref:`vshard.router.call() "
"<router_api-call>` или :ref:`vshard.storage.call() <storage_api-call>`. При "
"использовании API, например ``r = vshard.router.route() r:callro/callrw``, "
"следует дополнительно вызвать метод ``bucket_ref()`` в рамках функции. Кроме"
" того, следует убедиться, что после ``bucket_ref()`` вызывается "
"``bucket_unref()``, иначе сегмент нельзя перемещать из хранилища до "
"перезапуска экземпляра."

msgid ""
"To see how many refs there are for a bucket, use "
":ref:`vshard.storage.buckets_info([bucket_id]) <storage_api-buckets_info>` "
"(the ``bucket_id`` parameter is optional)."
msgstr ""
"Чтобы узнать количество ссылок в сегменте, используйте "
":ref:`vshard.storage.buckets_info([идентификатор_сегмента]) <storage_api-"
"buckets_info>` (параметр ``идентификатор_сегмента`` необязателен)."

msgid "For example:"
msgstr "Пример:"

msgid ""
"vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"
msgstr ""
"vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"

msgid "Defining spaces"
msgstr "Определение спейса"

msgid ""
"Database Schema is stored on ``storages``, while ``routers`` know nothing "
"about spaces and tuples."
msgstr ""
"Схема базы данных хранится на хранилищах, а роутеры ничего не знают о "
"спейсах и кортежах."

msgid ""
"Spaces should be defined within a storage application using ``box.once()``. "
"For example:"
msgstr ""
"В приложении хранилища следует определить спейсы с помощью ``box.once()``. "
"Например:"

msgid ""
"box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique = false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', 'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"
msgstr ""
"box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique = false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', 'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"

msgid ""
"Every space you plan to shard must have a field with :ref:`bucket id "
"<vshard-vbuckets>` numbers, indexed by the :ref:`shard index <cfg_basic-"
"shard_index>`."
msgstr ""
"В каждом спейсе, который вы планируете шардировать, должно быть поле с "
":ref:`идентификаторами сегментов <vshard-vbuckets>`, проиндексированное с "
"помощью :ref:`shard index <cfg_basic-shard_index>`."

msgid "Adding data"
msgstr "Добавление данных"

msgid ""
"All DML operations with data should be performed via ``router``. The only "
"operation supported by ``router`` is `CALL` via ``bucket_id``:"
msgstr ""
"Все DML-операции с данными следует выполнять через роутер. Роутер "
"поддерживает только вызов `CALL` через идентификатор сегмента ``bucket_id``:"

msgid "result = vshard.router.call(bucket_id, mode, func, args)"
msgstr ""
"result = vshard.router.call(идентификатор_сегмента, режим, функция, "
"аргументы)"

msgid ""
"``vshard.router.call()`` routes ``result = func(unpack(args))`` call to a "
"shard which serves ``bucket_id``."
msgstr ""
"``vshard.router.call()`` направляет вызов ``result = func(unpack(args))`` на"
" шард, который обслуживает идентификатор сегмента ``bucket_id``."

msgid ""
"``bucket_id`` is just a regular number in the range "
"``1..``:ref:`bucket_count<cfg_basic-bucket_count>`. This number can be "
"assigned in an arbitrary way by the client application. A sharded Tarantool "
"cluster uses this number as an opaque unique identifier to distribute data "
"across replica sets. It is guaranteed that all records with the same "
"``bucket_id`` will be stored on the same replica set."
msgstr ""
"Идентификатор сегмента ``bucket_id`` -- это обычное число в диапазоне "
"``1...```:ref:`bucket_count<cfg_basic-bucket_count>\". Этот номер можно "
"произвольным образом назначить с помощью клиентского приложения. "
"Сегментированный кластер Tarantool использует этот номер в качестве "
"непрозрачного уникального идентификатора для распределения данных по "
"множествам реплик. Мы гарантируем, что все записи с одним и тем же "
"``bucket_id`` будут храниться в одном и том же наборе реплик."

msgid "Bootstrapping and restarting a storage"
msgstr "Настройка и перезапуск хранилища"

msgid "If a replica set master fails, it is recommended to:"
msgstr "В случае отказа мастера в наборе реплик рекомендуется:"

msgid ""
"Switch one of the replicas into the master mode. This allows the new master "
"to process all the incoming requests."
msgstr ""
"Переключить одну из реплик в режим мастера, что позволит новому мастеру "
"обрабатывать все входящие запросы."

msgid ""
"Update the configuration of all the cluster members. This forwards all the "
"requests to the new master."
msgstr ""
"Обновить конфигурацию всех членов кластера, в результате чего все запросы "
"будут перенаправлены на новый мастер."

msgid ""
"Monitoring the master and switching the instance modes can be handled by any"
" external utility."
msgstr ""
"Мониторинг состояния мастера и переключение режимов экземпляров можно "
"осуществлять с помощью внешней утилиты."

msgid ""
"To perform a scheduled downtime of a replica set master, it is recommended "
"to:"
msgstr ""
"Для проведения запланированного остановки мастера в наборе реплик "
"рекомендуется:"

msgid ""
"Update the configuration of the master and wait for the replicas to get into"
" sync. All the requests then are forwarded to a new master."
msgstr ""
"Обновить конфигурацию мастера и подождать синхронизации всех реплик, в "
"результате чего все запросы будут перенаправлены на новый мастер."

msgid "Switch another instance into the master mode."
msgstr "Переключить другой экземпляр в режим мастера."

msgid "Update the configuration of all the nodes."
msgstr "Обновить конфигурацию всех узлов."

msgid "Shut down the old master."
msgstr "Отключить старый мастер."

msgid ""
"To perform a scheduled downtime of a replica set, it is recommended to:"
msgstr "Для проведения запланированной остановки набора реплик рекомендуется:"

msgid "Migrate all the buckets to the other cluster storages."
msgstr "Произвести миграцию всех сегментов в другие хранилища кластера."

msgid "Shut down the replica set."
msgstr "Отключить набор реплик."

msgid ""
"In case a whole replica set fails, some part of the dataset becomes "
"inaccessible. Meanwhile, the ``router`` tries to reconnect to the master of "
"the failed replica set. This way, once the replica set is up and running "
"again, the cluster is automatically restored."
msgstr ""
"В случае отказа всего набора реплик некоторая часть набора данных становится"
" недоступной. Тем временем ``роутер`` пытается повторно подключиться к "
"мастеру отказавшего набора реплик. Таким образом, после того, как набор "
"реплик снова запущен, кластер автоматически восстанавливается."

msgid "Fibers"
msgstr "Файберы"

msgid ""
"Searches for buckets, buckets recovery, and buckets rebalancing are "
"performed automatically and do not require manual intervention."
msgstr ""
"Поиск сегментов, восстановление сегментов и балансировка сегментов "
"выполняются автоматически и не требуют ручного вмешательства."

msgid ""
"Technically, there are multiple fibers responsible for different types of "
"operations:"
msgstr ""
"С технической точки зрения есть несколько файберов, которые отвечают за "
"различные типы действий:"

msgid ""
"a **discovery** fiber on the ``router`` searches for buckets in the "
"background"
msgstr ""
"файбер **обнаружения** на ``роутере`` выполняет поиск сегментов в фоновом "
"режиме"

msgid "a **failover** fiber on the ``router`` maintains replica connections"
msgstr ""
"файбер **восстановления после отказа** на ``роутере`` поддерживает "
"соединения с репликами"

msgid ""
"a **garbage collector** fiber on each master ``storage`` removes the "
"contents of buckets that were moved"
msgstr ""
"файбер **сборки мусора** на каждом мастер-хранилище удаляет содержимое "
"перемещенных сегментов"

msgid ""
"a **bucket recovery** fiber on each master ``storage`` recovers buckets in "
"the SENDING and RECEIVING states in case of reboot"
msgstr ""
"файбер **восстановления сегмента** на каждом мастер-хранилище "
"восстанавливает сегменты в статусах отправки SENDING и получения RECEIVING в"
" случае перезагрузки"

msgid ""
"a **rebalancer** on a single master ``storage`` among all replica sets "
"executes the rebalancing process."
msgstr ""
"**балансировщик** на отдельном мастер-хранилище среди множества наборов "
"реплик выполняет процесс балансировки."

msgid ""
"See the :ref:`Rebalancing process <vshard-rebalancing>` and :ref:`Migration "
"of buckets <vshard-migrate-buckets>` sections for details."
msgstr ""
"Для получения подробной информации см. разделы :ref:`Процесс балансировки "
"<vshard-rebalancing>` и :ref:`Миграция сегментов <vshard-migrate-buckets>`."

msgid "Garbage collector"
msgstr "Сборщик мусора"

msgid ""
"A **garbage collector** fiber runs in the background on the master storages "
"of each replica set. It starts deleting the contents of the bucket in the "
"GARBAGE state part by part. Once the bucket is empty, its record is deleted "
"from the ``_bucket`` system space."
msgstr ""
"Файбер **сборщик мусора** работает в фоновом режиме на мастер-хранилищах в "
"каждом наборе реплик. Он начинает удалять содержимое сегмента в состоянии "
"мусора GARBAGE по частям. Когда сегмент пуст, запись о нем удаляется из "
"системного спейса ``_bucket``."

msgid "Bucket recovery"
msgstr "Восстановление сегмента"

msgid ""
"A **bucket recovery** fiber runs on the master storages. It helps to recover"
" buckets in the SENDING and RECEIVING states in case of reboot."
msgstr ""
"Файбер **восстановления сегмента** работает на мастер-хранилищах. Он "
"помогает восстановить сегменты в статусах отправки SENDING и получения "
"RECEIVING в случае перезагрузки."

msgid "Buckets in the SENDING state are recovered as follows:"
msgstr "Сегменты в статусе SENDING восстанавливаются следующим образом:"

msgid "The system first searches for buckets in the SENDING state."
msgstr "Сначала система ищет сегменты в статусе SENDING."

msgid ""
"If such a bucket is found, the system sends a request to the destination "
"replica set."
msgstr ""
"Если такой сегмент обнаружен, система отправляет запрос в целевой набор "
"реплик."

msgid ""
"If the bucket on the destination replica set is ACTIVE, the original bucket "
"is deleted from the source node."
msgstr ""
"Если сегмент в целевом наборе реплик находится в активном статусе ACTIVE, "
"исходный сегмент удаляется из исходного узла."

msgid "Buckets in the RECEIVING state are deleted without extra checks."
msgstr "Сегменты в статусе RECEIVING удаляются без дополнительных проверок."

msgid "Failover"
msgstr "Восстановление после отказа"

msgid ""
"A **failover** fiber runs on every ``router``. If a master of a replica set "
"becomes unavailable, the failover fiber redirects read requests to the "
"replicas. Write requests are rejected with an error until the master becomes"
" available."
msgstr ""
"Файбер **восстановления после отказа** работает на каждом роутере. Если "
"мастер набора реплик становится недоступным, файбер перенаправляет запросы "
"на чтение к репликам. Запросы на запись отклоняются с ошибкой до тех пор, "
"пока мастер не будет доступен."
