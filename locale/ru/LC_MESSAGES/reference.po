# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-06 17:39+0000\n"
"PO-Revision-Date: 2019-12-06 16:16+0300\n"
"Last-Translator: \n"
"Language: ru\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../doc/reference/configuration/cfg_basic.rst:1
msgid ":ref:`background <cfg_basic-background>`"
msgstr ":ref:`background <cfg_basic-background>`"

#: ../doc/reference/configuration/cfg_basic.rst:2
msgid ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"
msgstr ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"

#: ../doc/reference/configuration/cfg_basic.rst:3
msgid ":ref:`listen <cfg_basic-listen>`"
msgstr ":ref:`listen <cfg_basic-listen>`"

#: ../doc/reference/configuration/cfg_basic.rst:4
msgid ":ref:`memtx_dir <cfg_basic-memtx_dir>`"
msgstr ":ref:`memtx_dir <cfg_basic-memtx_dir>`"

#: ../doc/reference/configuration/cfg_basic.rst:5
msgid ":ref:`pid_file <cfg_basic-pid_file>`"
msgstr ":ref:`pid_file <cfg_basic-pid_file>`"

#: ../doc/reference/configuration/cfg_basic.rst:6
msgid ":ref:`read_only <cfg_basic-read_only>`"
msgstr ":ref:`read_only <cfg_basic-read_only>`"

#: ../doc/reference/configuration/cfg_basic.rst:7
msgid ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"
msgstr ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"

#: ../doc/reference/configuration/cfg_basic.rst:8
msgid ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"
msgstr ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"

#: ../doc/reference/configuration/cfg_basic.rst:9
msgid ":ref:`username <cfg_basic-username>`"
msgstr ":ref:`username <cfg_basic-username>`"

#: ../doc/reference/configuration/cfg_basic.rst:10
msgid ":ref:`wal_dir <cfg_basic-wal_dir>`"
msgstr ":ref:`wal_dir <cfg_basic-wal_dir>`"

#: ../doc/reference/configuration/cfg_basic.rst:11
msgid ":ref:`work_dir <cfg_basic-work_dir>`"
msgstr ":ref:`work_dir <cfg_basic-work_dir>`"

#: ../doc/reference/configuration/cfg_basic.rst:12
msgid ":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`"
msgstr ":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`"

#: ../doc/reference/configuration/cfg_basic.rst:13
#, fuzzy
msgid ":ref:`strip_core <cfg_basic-strip_core>`"
msgstr ":ref:`listen <cfg_basic-listen>`"

#: ../doc/reference/configuration/cfg_basic.rst:19
msgid ""
"Run the server as a background task. The :ref:`log <cfg_logging-log>` and"
" :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for "
"this to work."
msgstr ""
"Запуск сервера в виде фоновой задачи. Параметры :ref:`log <cfg_logging-"
"log>` и :ref:`pid_file <cfg_basic-pid_file>` должны быть не равны нулю, "
"что это сработало."

#: ../doc/reference/configuration/cfg_basic.rst:23
#: ../doc/reference/configuration/cfg_basic.rst:112
#: ../doc/reference/configuration/cfg_basic.rst:233
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:22
#: ../doc/reference/configuration/cfg_deprecated.rst:25
#: ../doc/reference/configuration/cfg_deprecated.rst:55
#: ../doc/reference/configuration/cfg_deprecated.rst:66
#: ../doc/reference/configuration/cfg_hot_standby.rst:48
#: ../doc/reference/configuration/cfg_logging.rst:134
#: ../doc/reference/configuration/cfg_logging.rst:291
#: ../doc/reference/configuration/cfg_replication.rst:124
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:95
msgid "Type: boolean"
msgstr "Тип: логический"

#: ../doc/reference/configuration/cfg_basic.rst:24
#: ../doc/reference/configuration/cfg_basic.rst:113
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:23
#: ../doc/reference/configuration/cfg_deprecated.rst:26
#: ../doc/reference/configuration/cfg_hot_standby.rst:49
#: ../doc/reference/configuration/cfg_replication.rst:125
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:31
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:42
msgid "Default: false"
msgstr "По умолчанию: false (ложь)"

#: ../doc/reference/configuration/cfg_basic.rst:25
#: ../doc/reference/configuration/cfg_basic.rst:87
#: ../doc/reference/configuration/cfg_basic.rst:98
#: ../doc/reference/configuration/cfg_basic.rst:142
#: ../doc/reference/configuration/cfg_basic.rst:169
#: ../doc/reference/configuration/cfg_basic.rst:183
#: ../doc/reference/configuration/cfg_basic.rst:208
#: ../doc/reference/configuration/cfg_basic.rst:235
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:24
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:37
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:52
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:86
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:98
#: ../doc/reference/configuration/cfg_deprecated.rst:27
#: ../doc/reference/configuration/cfg_deprecated.rst:57
#: ../doc/reference/configuration/cfg_deprecated.rst:95
#: ../doc/reference/configuration/cfg_deprecated.rst:110
#: ../doc/reference/configuration/cfg_hot_standby.rst:50
#: ../doc/reference/configuration/cfg_logging.rst:112
#: ../doc/reference/configuration/cfg_logging.rst:136
#: ../doc/reference/configuration/cfg_replication.rst:216
#: ../doc/reference/configuration/cfg_replication.rst:238
#: ../doc/reference/configuration/cfg_storage.rst:43
#: ../doc/reference/configuration/cfg_storage.rst:55
#: ../doc/reference/configuration/cfg_storage.rst:69
#: ../doc/reference/configuration/cfg_storage.rst:93
#: ../doc/reference/configuration/cfg_storage.rst:115
#: ../doc/reference/configuration/cfg_storage.rst:139
#: ../doc/reference/configuration/cfg_storage.rst:152
#: ../doc/reference/configuration/cfg_storage.rst:164
#: ../doc/reference/configuration/cfg_storage.rst:175
#: ../doc/reference/configuration/cfg_storage.rst:186
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:53
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:77
msgid "Dynamic: no"
msgstr "Динамический: нет"

#: ../doc/reference/configuration/cfg_basic.rst:31
msgid ""
"Add the given string to the server's process title (what’s shown in the "
"COMMAND column for ``ps -ef`` and ``top -c`` commands)."
msgstr ""
"Добавление заданной строки к названию процесса сервера (что показано в "
"столбце COMMAND для команд ``ps -ef`` и ``top -c``."

#: ../doc/reference/configuration/cfg_basic.rst:35
msgid ""
"For example, ordinarily :samp:`ps -ef` shows the Tarantool server process"
" thus:"
msgstr ""
"Например, как правило, :samp:`ps -ef` показывает процесс "
"Tarantool-сервера так:"

#: ../doc/reference/configuration/cfg_basic.rst:38
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"

#: ../doc/reference/configuration/cfg_basic.rst:43
msgid ""
"But if the configuration parameters include "
"``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""
"Но если указан конфигурационный параметр "
"``custom_proc_title='sessions'``, вывод выглядит так:"

#: ../doc/reference/configuration/cfg_basic.rst:46
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: "
"sessions"
msgstr ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: "
"sessions"

#: ../doc/reference/configuration/cfg_basic.rst:51
#: ../doc/reference/configuration/cfg_basic.rst:85
#: ../doc/reference/configuration/cfg_basic.rst:96
#: ../doc/reference/configuration/cfg_basic.rst:140
#: ../doc/reference/configuration/cfg_basic.rst:167
#: ../doc/reference/configuration/cfg_basic.rst:181
#: ../doc/reference/configuration/cfg_basic.rst:206
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:84
#: ../doc/reference/configuration/cfg_logging.rst:110
#: ../doc/reference/configuration/cfg_logging.rst:189
#: ../doc/reference/configuration/cfg_logging.rst:302
#: ../doc/reference/configuration/cfg_replication.rst:44
#: ../doc/reference/configuration/cfg_replication.rst:214
#: ../doc/reference/configuration/cfg_replication.rst:236
msgid "Type: string"
msgstr "Тип: строка"

#: ../doc/reference/configuration/cfg_basic.rst:52
#: ../doc/reference/configuration/cfg_basic.rst:74
#: ../doc/reference/configuration/cfg_basic.rst:97
#: ../doc/reference/configuration/cfg_basic.rst:168
#: ../doc/reference/configuration/cfg_basic.rst:207
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:69
#: ../doc/reference/configuration/cfg_logging.rst:111
#: ../doc/reference/configuration/cfg_networking.rst:15
#: ../doc/reference/configuration/cfg_replication.rst:45
#: ../doc/reference/configuration/cfg_replication.rst:104
#: ../doc/reference/configuration/cfg_replication.rst:215
#: ../doc/reference/configuration/cfg_replication.rst:237
msgid "Default: null"
msgstr "По умолчанию: null"

#: ../doc/reference/configuration/cfg_basic.rst:53
#: ../doc/reference/configuration/cfg_basic.rst:75
#: ../doc/reference/configuration/cfg_basic.rst:114
#: ../doc/reference/configuration/cfg_basic.rst:159
#: ../doc/reference/configuration/cfg_basic.rst:222
#: ../doc/reference/configuration/cfg_deprecated.rst:68
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:71
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:100
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:112
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:32
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:43
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:87
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:97
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:109
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:124
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:145
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:160
msgid "Dynamic: yes"
msgstr "Динамический: да"

#: ../doc/reference/configuration/cfg_basic.rst:59
msgid ""
"The read/write data port number or :ref:`URI <index-uri>` (Universal "
"Resource Identifier) string. Has no default value, so **must be "
"specified** if connections will occur from remote clients that do not use"
" the :ref:`“admin port” <admin-security>`. Connections made with "
":samp:`listen = {URI}` are called \"binary port\" or \"binary protocol\" "
"connections."
msgstr ""
"Номер порта для чтения/записи данных или строка :ref:`URI <index-uri>` "
"(унифицированный идентификатор ресурса). Значение, используемое по "
"умолчанию, отсутствует, поэтому его **обязательно указать**, если "
"подключение выполняется с удаленных клиентов, которые не используют "
":ref:`“порт администрирования” <admin-security>`. Подключения, "
"выполняемые с помощью :samp:`listen = {URI}`, называются соединения по "
"бинарному порту или бинарному протоколу."

#: ../doc/reference/configuration/cfg_basic.rst:66
msgid "A typical value is 3301."
msgstr "Как правило, используется значение 3301."

#: ../doc/reference/configuration/cfg_basic.rst:70
msgid ""
"A replica also binds to this port, and accepts connections, but these "
"connections can only serve reads until the replica becomes a master."
msgstr ""
"Реплика также привязана на этот порт и принимает соединения, но эти "
"соединения служат только для чтения до тех пор, пока реплика не станет "
"мастером."

#: ../doc/reference/configuration/cfg_basic.rst:73
msgid "Type: integer or string"
msgstr "Тип: целое число или строка"

#: ../doc/reference/configuration/cfg_basic.rst:81
msgid ""
"A directory where memtx stores snapshot (.snap) files. Can be relative to"
" :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to "
"``work_dir``. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""
"Директория, где memtx хранит файлы снимков (.snap). Может относиться к "
":ref:`work_dir <cfg_basic-work_dir>`. Если не указан, по умолчанию "
"``work_dir``. См. также :ref:`wal_dir <cfg_basic-wal_dir>`."

#: ../doc/reference/configuration/cfg_basic.rst:86
#: ../doc/reference/configuration/cfg_basic.rst:141
#: ../doc/reference/configuration/cfg_basic.rst:182
msgid "Default: \".\""
msgstr "По умолчанию: \".\""

#: ../doc/reference/configuration/cfg_basic.rst:93
msgid ""
"Store the process id in this file. Can be relative to :ref:`work_dir "
"<cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""
"Хранение идентификатора процесса в данном файле. Может относиться к "
":ref:`work_dir <cfg_basic-work_dir>`. Как правило, используется значение "
"“:file:`tarantool.pid`”."

#: ../doc/reference/configuration/cfg_basic.rst:104
msgid ""
"Say ``box.cfg{read_only=true...}`` to put the server instance in read-"
"only mode. After this, any requests that try to change persistent data "
"will fail with error :errcode:`ER_READONLY`. Read-only mode should be "
"used for master-replica :ref:`replication <replication>`. Read-only mode "
"does not affect data-change requests for spaces defined as "
":ref:`temporary <box_schema-space_create>`. Although read-only mode "
"prevents the server from writing to the :ref:`WAL <internals-wal>`, it "
"does not prevent writing diagnostics with the :ref:`log module <log-"
"module>`."
msgstr ""
"Чтобы ввести экземпляр сервера в режим только для чтения, выполните "
"команду ``box.cfg{read_only=true...}``. После этого не будут выполняться "
"любые запросы по изменению персистентных данных с ошибкой "
":errcode:`ER_READONLY`. Режим только для чтения следует использовать в "
":ref:`репликации <replication>` типа мастер-реплика. Режим только для "
"чтения не влияет на запросы по изменению данных в спейсах, которые "
"считаются :ref:`временными <box_schema-space_create>`. Хотя режим только "
"для чтения не позволяет серверу делать записи в :ref:`WAL-файлы "
"<internals-wal>`, запись диагностической информации в :ref:`модуле log "
"<log-module>` все равно осуществляется."

#: ../doc/reference/configuration/cfg_basic.rst:116
msgid ""
"Setting ``read_only == true`` affects spaces differently depending on the"
" options that were used during :ref:`box.schema.space.create <box_schema-"
"space_create>`, as summarized by this chart:"
msgstr ""
"Установка ``read_only == true`` по-разному влияет на спейсы в зависимости"
" от опций, использованных во время :ref:`box.schema.space.create "
"<box_schema-space_create>`, как описано в таблице:"

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Option"
msgstr "Характеристика"

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Can be created?"
msgstr "Можно создать?"

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Can be written to?"
msgstr "Допускает запись?"

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Is replicated?"
msgstr "Реплицируется?"

#: ../doc/reference/configuration/cfg_basic.rst:123
msgid "Is persistent?"
msgstr "Сохраняется?"

#: ../doc/reference/configuration/cfg_basic.rst:125
msgid "(default)"
msgstr "(по умолчанию)"

#: ../doc/reference/configuration/cfg_basic.rst:125
#: ../doc/reference/configuration/cfg_basic.rst:127
#: ../doc/reference/configuration/cfg_basic.rst:129
msgid "no"
msgstr "нет"

#: ../doc/reference/configuration/cfg_basic.rst:125
#: ../doc/reference/configuration/cfg_basic.rst:127
#: ../doc/reference/configuration/cfg_basic.rst:129
msgid "yes"
msgstr "да"

#: ../doc/reference/configuration/cfg_basic.rst:127
msgid "temporary"
msgstr "temporary"

#: ../doc/reference/configuration/cfg_basic.rst:129
msgid "is_local"
msgstr "is_local"

#: ../doc/reference/configuration/cfg_basic.rst:136
msgid ""
"A directory where vinyl files or subdirectories will be stored. Can be "
"relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, "
"defaults to ``work_dir``."
msgstr ""
"Директория, где хранятся файлы или поддиректории vinyl'а. Может "
"относиться к :ref:`work_dir <cfg_basic-work_dir>`. Если не указан, по "
"умолчанию ``work_dir``."

#: ../doc/reference/configuration/cfg_basic.rst:148
msgid ""
"The vinyl storage engine has a scheduler which does compaction. When "
"vinyl is low on available memory, the compaction scheduler may be unable "
"to keep up with incoming update requests. In that situation, queries may "
"time out after ``vinyl_timeout`` seconds. This should rarely occur, since"
" normally vinyl would throttle inserts when it is running low on "
"compaction bandwidth. Compaction can also be ordered manually with "
":ref:`index_object:compact() <box_index-compact>`."
msgstr ""
"В движке базы данных vinyl есть планировщик, который осуществляет "
"слияние. Когда vinyl'у не хватает доступной памяти, планировщик не сможет"
" поддерживать скорость слияния в соответствии со входящими запросами "
"обновления. В такой ситуации время ожидания обработки запроса может "
"истечь после ``vinyl_timeout`` секунд. Это происходит редко, поскольку "
"обычно vinyl управляет загрузкой при операциях вставки, когда не хватает "
"скорости для слияния. Слияние можно запустить автоматически с помощью "
":ref:`index_object:compact() <box_index-compact>`."

#: ../doc/reference/configuration/cfg_basic.rst:157
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:68
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:96
#: ../doc/reference/configuration/cfg_deprecated.rst:93
#: ../doc/reference/configuration/cfg_deprecated.rst:108
#: ../doc/reference/configuration/cfg_logging.rst:146
#: ../doc/reference/configuration/cfg_logging.rst:312
#: ../doc/reference/configuration/cfg_networking.rst:14
#: ../doc/reference/configuration/cfg_replication.rst:75
#: ../doc/reference/configuration/cfg_replication.rst:148
#: ../doc/reference/configuration/cfg_replication.rst:165
#: ../doc/reference/configuration/cfg_storage.rst:28
#: ../doc/reference/configuration/cfg_storage.rst:67
#: ../doc/reference/configuration/cfg_storage.rst:162
msgid "Type: float"
msgstr "Тип: число с плавающей запятой"

#: ../doc/reference/configuration/cfg_basic.rst:158
msgid "Default: 60"
msgstr "По умолчанию: 60"

#: ../doc/reference/configuration/cfg_basic.rst:165
msgid "UNIX user name to switch to after start."
msgstr "Имя пользователя в UNIX, на которое переключается система после запуска."

#: ../doc/reference/configuration/cfg_basic.rst:175
msgid ""
"A directory where write-ahead log (.xlog) files are stored. Can be "
"relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes ``wal_dir`` "
"and :ref:`memtx_dir <cfg_basic-memtx_dir>` are specified with different "
"values, so that write-ahead log files and snapshot files can be stored on"
" different disks. If not specified, defaults to ``work_dir``."
msgstr ""
"Директория, где хранятся файлы журнала упреждающей записи (.xlog). Может "
"относиться к :ref:`work_dir <cfg_basic-work_dir>`. Иногда в ``wal_dir`` и"
" :ref:`memtx_dir <cfg_basic-memtx_dir>` указываются разные значения, "
"чтобы WAL-файлы и файлы снимков хранились на разных дисках. Если не "
"указан, по умолчанию ``work_dir``."

#: ../doc/reference/configuration/cfg_basic.rst:189
msgid ""
"A directory where database working files will be stored. The server "
"instance switches to ``work_dir`` with :manpage:`chdir(2)` after start. "
"Can be relative to the current directory. If not specified, defaults to "
"the current directory. Other directory parameters may be relative to "
"``work_dir``, for example:"
msgstr ""
"Директория, где хранятся рабочие файлы базы данных. Экземпляр сервера "
"переключается на ``work_dir`` с помощью :manpage:`chdir(2)` после "
"запуска. Может относиться к текущей директории.  Если не указан, по "
"умолчанию = текущей директории. Другие параметры директории могут "
"относиться к ``work_dir``, например:"

#: ../doc/reference/configuration/cfg_basic.rst:195
msgid ""
"box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"
msgstr ""
"box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"

#: ../doc/reference/configuration/cfg_basic.rst:203
msgid ""
"will put xlog files in ``/home/user/A/B``, snapshot files in "
"``/home/user/A/C``, and all other files or subdirectories in "
"``/home/user/A``."
msgstr ""
"поместит xlog-файлы в ``/home/user/A/B``, файлы снимков в "
"``/home/user/A/C``, а все остальные файлы или поддиректории в "
"``/home/user/A``."

#: ../doc/reference/configuration/cfg_basic.rst:215
msgid ""
"The maximum number of threads to use during execution of certain internal"
" processes (currently :ref:`socket.getaddrinfo() <socket-getaddrinfo>` "
"and :ref:`coio_call() <c_api-coio-coio_call>`)."
msgstr ""
"Максимальное количество потоков, используемых во время исполнения "
"определенных внутренних процессов (сейчас :ref:`socket.getaddrinfo() "
"<socket-getaddrinfo>` и :ref:`coio_call() <c_api-coio-coio_call>`)."

#: ../doc/reference/configuration/cfg_basic.rst:220
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:35
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:50
#: ../doc/reference/configuration/cfg_logging.rst:28
#: ../doc/reference/configuration/cfg_networking.rst:50
#: ../doc/reference/configuration/cfg_networking.rst:67
#: ../doc/reference/configuration/cfg_replication.rst:58
#: ../doc/reference/configuration/cfg_replication.rst:103
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:69
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:98
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:110
#: ../doc/reference/configuration/cfg_storage.rst:41
#: ../doc/reference/configuration/cfg_storage.rst:53
#: ../doc/reference/configuration/cfg_storage.rst:78
#: ../doc/reference/configuration/cfg_storage.rst:91
#: ../doc/reference/configuration/cfg_storage.rst:101
#: ../doc/reference/configuration/cfg_storage.rst:113
#: ../doc/reference/configuration/cfg_storage.rst:137
#: ../doc/reference/configuration/cfg_storage.rst:150
#: ../doc/reference/configuration/cfg_storage.rst:173
#: ../doc/reference/configuration/cfg_storage.rst:184
msgid "Type: integer"
msgstr "Тип: целое число"

#: ../doc/reference/configuration/cfg_basic.rst:221
#: ../doc/reference/configuration/cfg_replication.rst:76
msgid "Default: 4"
msgstr "По умолчанию: 4"

#: ../doc/reference/configuration/cfg_basic.rst:228
msgid ""
"Whether coredump files should include memory allocated for tuples. (This "
"can be large if Tarantool runs under heavy load.) Setting to ``true`` "
"means \"do not include\". In an older version of Tarantool the default "
"value of this parameter was ``false``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:234
#: ../doc/reference/configuration/cfg_deprecated.rst:56
#: ../doc/reference/configuration/cfg_deprecated.rst:67
#: ../doc/reference/configuration/cfg_logging.rst:292
msgid "Default: true"
msgstr "По умолчанию: true"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:1
msgid ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"
msgstr ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:2
msgid ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"
msgstr ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:3
msgid ":ref:`wal_max_size <cfg_binary_logging_snapshots-wal_max_size>`,"
msgstr ":ref:`wal_max_size <cfg_binary_logging_snapshots-wal_max_size>`,"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:4
msgid ""
":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-"
"snap_io_rate_limit>`,"
msgstr ""
":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-"
"snap_io_rate_limit>`,"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:5
msgid ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
msgstr ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:6
msgid ""
":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-"
"wal_dir_rescan_delay>`"
msgstr ""
":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-"
"wal_dir_rescan_delay>`"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:12
msgid ""
"If ``force_recovery`` equals true, Tarantool tries to continue if there "
"is an error while reading a :ref:`snapshot file<index-box_persistence>` "
"(at server instance start) or a :ref:`write-ahead log file<internals-"
"wal>` (at server instance start or when applying an update at a replica):"
" skips invalid records, reads as much data as possible and lets the "
"process finish with a warning. Users can prevent the error from recurring"
" by writing to the database and executing :ref:`box.snapshot() <box-"
"snapshot>`."
msgstr ""
"Если значение ``force_recovery`` равно true (правда), Tarantool пытается "
"продолжать работу при обнаружении ошибки во время чтения :ref:`файла "
"снимка <index-box_persistence>` (при запуске экземпляра сервера) или "
":ref:`файла журнала упреждающей записи <internals-wal>` (при запуске "
"экземпляра сервера или применении обновлений к реплике): пропускает "
"нерабочие записи, считывает максимальное количество данных и позволяет "
"завершить процесс предупреждением. Пользователи могут предотвратить "
"повторное появление ошибки, записав данные в базу и выполнив "
":ref:`box.snapshot() <box-snapshot>`."

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:20
msgid "Otherwise, Tarantool aborts recovery if there is an error while reading."
msgstr "В остальных случаях Tarantool прерывает восстановление на ошибке чтения."

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:30
msgid ""
"How many log records to store in a single write-ahead log file. When this"
" limit is reached, Tarantool creates another WAL file named :samp"
":`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based "
"backups."
msgstr ""
"Количество записей журнала, которое хранится в отдельном WAL-файле. При "
"достижении предельного значения Tarantool создает другой WAL-файл под "
"названием :samp:`{<первый-lsn-в-журнале>}.xlog`. Эту функцию можно "
"использовать для простого резервного копирования на основе rsync."

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:36
msgid "Default: 500000"
msgstr "По умолчанию: 500000"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:43
msgid ""
"The maximum number of bytes in a single write-ahead log file. When a "
"request would cause an .xlog file to become larger than ``wal_max_size``,"
" Tarantool creates another WAL file -- the same effect that happens when "
"the :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>` limit"
" is reached."
msgstr ""
"Максимальное количество байтов в отдельном журнале упреждающей записи. "
"Если в результате запроса файл .xlog будет больше, чем указано в "
"параметре ``wal_max_size``, Tarantool создает другой WAL-файл -- то же "
"самое происходит, когда достигнуто количество строк в журнале, указанное "
"в :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`."

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:51
msgid "Default: 268435456 (256 * 1024 * 1024)"
msgstr "По умолчанию: 268435456 (256 * 1024 * 1024)"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:58
msgid ""
"Reduce the throttling effect of :ref:`box.snapshot <box-snapshot>` on "
"INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes"
" per second it can write to disk. The same can be achieved by splitting "
":ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-"
"memtx_dir>` locations and moving snapshots to a separate disk. The limit "
"also affects what :ref:`box.stat.vinyl().regulator <box_introspection-"
"box_stat_vinyl_regulator>` may show for the write rate of dumps to .run "
"and .index files."
msgstr ""
"Уменьшение загрузки :ref:`box.snapshot <box-snapshot>` при выполнении "
"операций вставки, обновления и удаления (INSERT/UPDATE/DELETE) путем "
"установки предела скорости записи на диск -- количества мегабайт в "
"секунду. Того же эффекта можно достичь, разделив директории :ref:`wal_dir"
" <cfg_basic-wal_dir>` и :ref:`memtx_dir <cfg_basic-memtx_dir>` и перенося"
" снимки на отдельный диск. Такой предел также ограничивает результат "
":ref:`box.stat.vinyl().regulator <box_introspection-"
"box_stat_vinyl_regulator>` относительно скорости записи дампов в файлы "
"формата .run и .index."

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:70
#: ../doc/reference/configuration/cfg_logging.rst:30
#: ../doc/reference/configuration/cfg_logging.rst:148
#: ../doc/reference/configuration/cfg_logging.rst:191
#: ../doc/reference/configuration/cfg_logging.rst:293
#: ../doc/reference/configuration/cfg_logging.rst:304
#: ../doc/reference/configuration/cfg_logging.rst:314
#: ../doc/reference/configuration/cfg_networking.rst:16
#: ../doc/reference/configuration/cfg_networking.rst:52
#: ../doc/reference/configuration/cfg_networking.rst:69
#: ../doc/reference/configuration/cfg_replication.rst:46
#: ../doc/reference/configuration/cfg_replication.rst:60
#: ../doc/reference/configuration/cfg_replication.rst:77
#: ../doc/reference/configuration/cfg_replication.rst:105
#: ../doc/reference/configuration/cfg_replication.rst:126
#: ../doc/reference/configuration/cfg_replication.rst:150
#: ../doc/reference/configuration/cfg_replication.rst:167
#: ../doc/reference/configuration/cfg_storage.rst:80
msgid "Dynamic: **yes**"
msgstr "Динамический: **да**"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:76
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr "Определение синхронизации работы файбера с журналом упреждающей записи:"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:78
msgid "``none``: write-ahead log is not maintained;"
msgstr "``none``: журнал упреждающей записи не поддерживается;"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:79
msgid ""
"``write``: :ref:`fibers <fiber-fibers>` wait for their data to be written"
" to the write-ahead log (no :manpage:`fsync(2)`);"
msgstr ""
"``write``: :ref:`файберы <fiber-fibers>` ожидают записи данных в журнал "
"упреждающей записи (не :manpage:`fsync(2)`);"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:81
msgid ""
"``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each "
":manpage:`write(2)`;"
msgstr ""
"``fsync``: файберы ожидают данные, синхронизация :manpage:`fsync(2)` "
"следует за каждой операцией записи :manpage:`write(2)`;"

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:85
msgid "Default: \"write\""
msgstr "По умолчанию: \"write\""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:92
msgid ""
"Number of seconds between periodic scans of the write-ahead-log file "
"directory, when checking for changes to write-ahead-log files for the "
"sake of :ref:`replication <replication>` or :ref:`hot standby <index-"
"hot_standby>`."
msgstr ""
"Количество секунд между периодическим сканирование директории WAL-файла "
"при проверке изменений в WAL-файле для целей :ref:`репликации "
"<replication>` или :ref:`горячего резервирования <index-hot_standby>`."

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:97
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:99
msgid "Default: 2"
msgstr "По умолчанию: 2"

#: ../doc/reference/configuration/cfg_deprecated.rst:3
msgid "These parameters are deprecated since Tarantool version 1.7.4:"
msgstr "Данные параметры объявлены устаревшими с версии Tarantool'а 1.7.4:"

#: ../doc/reference/configuration/cfg_deprecated.rst:5
msgid ":ref:`coredump <cfg_basic-coredump_deprecated>`"
msgstr ":ref:`coredump <cfg_basic-coredump_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:6
msgid ":ref:`logger <cfg_logging-logger_deprecated>`"
msgstr ":ref:`logger <cfg_logging-logger_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:7
msgid ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"
msgstr ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:8
msgid ""
":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-"
"panic_on_snap_error_deprecated>`,"
msgstr ""
":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-"
"panic_on_snap_error_deprecated>`,"

#: ../doc/reference/configuration/cfg_deprecated.rst:9
msgid ""
":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-"
"panic_on_wal_error_deprecated>`"
msgstr ""
":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-"
"panic_on_wal_error_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:10
msgid ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"
msgstr ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:11
msgid ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"
msgstr ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:12
msgid ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"
msgstr ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:13
msgid ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"
msgstr ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:14
msgid ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"
msgstr ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:15
msgid ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"
msgstr ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:16
msgid ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"
msgstr ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:17
msgid ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"
msgstr ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"

#: ../doc/reference/configuration/cfg_deprecated.rst:23
#: ../doc/reference/configuration/cfg_deprecated.rst:101
msgid "**Deprecated**, do not use."
msgstr "**Устаревший**, не использовать."

#: ../doc/reference/configuration/cfg_deprecated.rst:33
msgid ""
"**Deprecated** in favor of :ref:`log <cfg_logging-log>`. The parameter "
"was only renamed, while the type, values and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`log <cfg_logging-log>`. Параметр"
" был лишь переименован, его тип, значения и семантика остались прежними."

#: ../doc/reference/configuration/cfg_deprecated.rst:41
msgid ""
"**Deprecated** in favor of :ref:`log_nonblock <cfg_logging-"
"log_nonblock>`. The parameter was only renamed, while the type, values "
"and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`log_nonblock <cfg_logging-"
"log_nonblock>`. Параметр был лишь переименован, его тип, значения и "
"семантика остались прежними."

#: ../doc/reference/configuration/cfg_deprecated.rst:49
#: ../doc/reference/configuration/cfg_deprecated.rst:63
msgid ""
"**Deprecated** in favor of :ref:`force_recovery "
"<cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""
"**Устаревший**, заменен параметром :ref:`force_recovery "
"<cfg_binary_logging_snapshots-force_recovery>`."

#: ../doc/reference/configuration/cfg_deprecated.rst:52
msgid ""
"If there is an error while reading a snapshot file (at server instance "
"start), abort."
msgstr ""
"Если при чтении файла снимка произошла ошибка (при запуске экземпляра "
"сервера), прервать выполнение."

#: ../doc/reference/configuration/cfg_deprecated.rst:74
msgid ""
"**Deprecated** in favor of :ref:`replication <cfg_replication-"
"replication>`. The parameter was only renamed, while the type, values and"
" semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`replication <cfg_replication-"
"replication>`. Параметр был лишь переименован, его тип, значения и "
"семантика остались прежними."

#: ../doc/reference/configuration/cfg_deprecated.rst:83
msgid "**Deprecated** in favor of :ref:`memtx_memory <cfg_storage-memtx_memory>`."
msgstr ""
"**Устаревший**, заменен параметром :ref:`memtx_memory <cfg_storage-"
"memtx_memory>`."

#: ../doc/reference/configuration/cfg_deprecated.rst:86
msgid ""
"How much memory Tarantool allocates to actually store tuples, **in "
"gigabytes**. When the limit is reached, INSERT or UPDATE requests begin "
"failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not "
"go beyond the defined limit to allocate tuples, there is additional "
"memory used to store indexes and connection information. Depending on "
"actual configuration and workload, Tarantool can consume up to 20% more "
"than the limit set here."
msgstr ""
"Количество памяти, которое Tarantool выделяет для фактического хранения "
"кортежей, **в гигабайтах**. При достижении предельного значения запросы "
"вставки INSERT или обновления UPDATE выполняться не будут, выдавая ошибку"
" :errcode:`ER_MEMORY_ISSUE`. Сервер не выходит за установленный предел "
"памяти ``memtx_memory`` при распределении кортежей, но есть "
"дополнительная память, которая используется для хранения индексов и "
"информации о подключении. В зависимости от рабочей конфигурации и "
"загрузки, Tarantool может потреблять на 20% больше установленного "
"предела."

#: ../doc/reference/configuration/cfg_deprecated.rst:94
msgid "Default: 1.0"
msgstr "По умолчанию: 1.0"

#: ../doc/reference/configuration/cfg_deprecated.rst:103
msgid ""
"The multiplier for computing the sizes of memory chunks that tuples are "
"stored in. A lower value may result in less wasted memory depending on "
"the total amount of memory available and the distribution of item sizes."
msgstr ""
"Множитель для вычисления размеров блоков памяти, в которых хранятся "
"кортежи. Уменьшение значения может привести к уменьшению потерь памяти в "
"зависимости от общего объема доступной памяти и распределения размеров "
"элементов."

#: ../doc/reference/configuration/cfg_deprecated.rst:109
msgid "Default: 1.1"
msgstr "По умолчанию: 1.1"

#: ../doc/reference/configuration/cfg_deprecated.rst:116
msgid ""
"**Deprecated** in favor of :ref:`memtx_max_tuple_size <cfg_storage-"
"memtx_max_tuple_size>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`memtx_max_tuple_size "
"<cfg_storage-memtx_max_tuple_size>`. Параметр был лишь переименован, его "
"тип, значения и семантика остались прежними."

#: ../doc/reference/configuration/cfg_deprecated.rst:125
msgid ""
"**Deprecated** in favor of :ref:`memtx_min_tuple_size <cfg_storage-"
"memtx_min_tuple_size>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`memtx_min_tuple_size "
"<cfg_storage-memtx_min_tuple_size>`. Параметр был лишь переименован, его "
"тип, значения и семантика остались прежними."

#: ../doc/reference/configuration/cfg_deprecated.rst:134
msgid ""
"**Deprecated** in favor of :ref:`memtx_dir <cfg_basic-memtx_dir>`. The "
"parameter was only renamed, while the type, values and semantics remained"
" intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`. Параметр был лишь переименован, его тип, значения и "
"семантика остались прежними."

#: ../doc/reference/configuration/cfg_deprecated.rst:142
msgid ""
"**Deprecated** in favor of :ref:`checkpoint_interval "
"<cfg_checkpoint_daemon-checkpoint_interval>`. The parameter was only "
"renamed, while the type, values and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`checkpoint_interval "
"<cfg_checkpoint_daemon-checkpoint_interval>`. Параметр был лишь "
"переименован, его тип, значения и семантика остались прежними."

#: ../doc/reference/configuration/cfg_deprecated.rst:151
msgid ""
"**Deprecated** in favor of :ref:`checkpoint_count <cfg_checkpoint_daemon-"
"checkpoint_count>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`checkpoint_count "
"<cfg_checkpoint_daemon-checkpoint_count>`. Параметр был лишь "
"переименован, его тип, значения и семантика остались прежними."

#: ../doc/reference/configuration/cfg_hot_standby.rst:3
msgid "Whether to start the server in **hot standby** mode."
msgstr "Запуск сервера в режиме **горячего резервирования**."

#: ../doc/reference/configuration/cfg_hot_standby.rst:5
msgid ""
"Hot standby is a feature which provides a simple form of failover without"
" :ref:`replication <replication>`."
msgstr ""
"Горячее резервирование -- это функция, которая обеспечивает простое "
"восстановление после отказа без :ref:`репликации <replication>`."

#: ../doc/reference/configuration/cfg_hot_standby.rst:8
msgid ""
"The expectation is that there will be two instances of the server using "
"the same configuration. The first one to start will be the \"primary\" "
"instance. The second one to start will be the \"standby\" instance."
msgstr ""
"Предполагается, что есть два экземпляра сервера, использующих одну и ту "
"же конфигурацию. Первый из них станет \"основным\" экземпляром. Тот, "
"который запускается вторым, станет \"резервным\" экземпляром."

#: ../doc/reference/configuration/cfg_hot_standby.rst:12
msgid ""
"To initiate the standby instance, start a second instance of the "
"Tarantool server on the same computer with the same :ref:`box.cfg "
"<box_introspection-box_cfg>` configuration settings -- including the same"
" directories and same non-null URIs -- and with the additional "
"configuration setting ``hot_standby = true``. Expect to see a "
"notification ending with the words ``I> Entering hot standby mode``. This"
" is fine. It means that the standby instance is ready to take over if the"
" primary instance goes down."
msgstr ""
"Чтобы создать резервный экземпляр, запустите второй экземпляр "
"Tarantool-сервера на том же компьютере с теми же настройками конфигурации"
" :ref:`box.cfg <box_introspection-box_cfg>` -- включая одинаковые "
"директории и ненулевые URI -- и с дополнительной настройкой конфигурации "
"``hot_standby = true``. В ближайшее время вы увидите уведомление, которое"
" заканчивается словами ``I> Entering hot standby mode`` (вход в режим "
"горячего резервирования). Всё в порядке -- это означает, что резервный "
"экземпляр готов взять работу на себя, если основной экземпляр прекратит "
"работу."

#: ../doc/reference/configuration/cfg_hot_standby.rst:22
msgid ""
"The standby instance will initialize and will try to take a lock on "
":ref:`wal_dir <cfg_basic-wal_dir>`, but will fail because the primary "
"instance has made a lock on ``wal_dir``. So the standby instance goes "
"into a loop, reading the write ahead log which the primary instance is "
"writing (so the two instances are always in sync), and trying to take the"
" lock. If the primary instance goes down for any reason, the lock will be"
" released. In this case, the standby instance will succeed in taking the "
"lock, will connect on the :ref:`listen <cfg_basic-listen>` address and "
"will become the primary instance. Expect to see a notification ending "
"with the words ``I> ready to accept requests``."
msgstr ""
"Резервный экземпляр начнет инициализацию и попытается заблокировать "
":ref:`wal_dir <cfg_basic-wal_dir>`, но не сможет, поскольку директория "
"``wal_dir`` заблокирована основным экземпляром. Поэтому резервный "
"экземпляр входит в цикл, выполняя чтение журнала упреждающей записи, в "
"который записывает данные основной экземпляр (поэтому два экземпляра "
"всегда синхронизированы), и пытаясь произвести блокировку. Если основной "
"экземпляр по какой-либо причине прекращает работу, блокировка снимается. "
"В таком случае резервный экземпляр сможет заблокировать директорию на "
"себя, подключится по адресу для :ref:`прослушивания <cfg_basic-listen>` и"
" станет основным экземпляром. В ближайшее время вы увидите уведомление, "
"которое заканчивается словами ``I> ready to accept requests`` (готов "
"принимать запросы)."

#: ../doc/reference/configuration/cfg_hot_standby.rst:35
msgid "Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""
"Таким образом, если основной экземпляр прекращает работу, время простоя "
"отсутствует."

#: ../doc/reference/configuration/cfg_hot_standby.rst:37
msgid "Hot standby feature has no effect:"
msgstr "Функция горячего резервирования не работает:"

#: ../doc/reference/configuration/cfg_hot_standby.rst:39
msgid ""
"if :ref:`wal_dir_rescan_delay = a large number "
"<cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (on Mac OS and "
"FreeBSD); on these platforms, it is designed so that the loop repeats "
"every ``wal_dir_rescan_delay`` seconds."
msgstr ""
"если :ref:`wal_dir_rescan_delay = большое число "
"<cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (в Mac OS и "
"FreeBSD); на этих платформах цикл запрограммирован на повторение каждые "
"``wal_dir_rescan_delay`` секунд."

#: ../doc/reference/configuration/cfg_hot_standby.rst:43
msgid ""
"if :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; it "
"is designed to work with ``wal_mode = 'write'`` or ``wal_mode = "
"'fsync'``."
msgstr ""
"если :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; "
"будет работать только при ``wal_mode = 'write'`` или ``wal_mode = "
"'fsync'``."

#: ../doc/reference/configuration/cfg_hot_standby.rst:45
msgid ""
"for spaces created with :ref:`engine = 'vinyl' <box_schema-"
"space_create>`; it is designed to work for spaces created with ``engine ="
" 'memtx'``."
msgstr ""
"со спейсами, созданными на движке vinyl :ref:`engine = 'vinyl' "
"<box_schema-space_create>`; работает с движком memtx ``engine = "
"'memtx'``."

#: ../doc/reference/configuration/cfg_logging.rst:3
msgid ":ref:`log_level <cfg_logging-log_level>`"
msgstr ":ref:`log_level <cfg_logging-log_level>`"

#: ../doc/reference/configuration/cfg_logging.rst:4
msgid ":ref:`log <cfg_logging-log>`"
msgstr ":ref:`log <cfg_logging-log>`"

#: ../doc/reference/configuration/cfg_logging.rst:5
msgid ":ref:`log_nonblock <cfg_logging-log_nonblock>`"
msgstr ":ref:`log_nonblock <cfg_logging-log_nonblock>`"

#: ../doc/reference/configuration/cfg_logging.rst:6
msgid ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"
msgstr ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"

#: ../doc/reference/configuration/cfg_logging.rst:7
msgid ":ref:`log_format <cfg_logging-log_format>`"
msgstr ":ref:`log_format <cfg_logging-log_format>`"

#: ../doc/reference/configuration/cfg_logging.rst:13
msgid ""
"What level of detail the :ref:`log <admin-logs>` will have. There are "
"seven levels:"
msgstr "Уровень детализации записей :ref:`журнала <admin-logs>`. Есть 7 уровней:"

#: ../doc/reference/configuration/cfg_logging.rst:15
#: ../doc/reference/reference_lua/log.rst:91
msgid "1 – ``SYSERROR``"
msgstr "1 – ``SYSERROR``"

#: ../doc/reference/configuration/cfg_logging.rst:16
msgid "2 – ``ERROR``"
msgstr "2 – ``ERROR``"

#: ../doc/reference/configuration/cfg_logging.rst:17
#: ../doc/reference/reference_lua/log.rst:93
msgid "3 – ``CRITICAL``"
msgstr "3 – ``CRITICAL``"

#: ../doc/reference/configuration/cfg_logging.rst:18
msgid "4 – ``WARNING``"
msgstr "4 – ``WARNING``"

#: ../doc/reference/configuration/cfg_logging.rst:19
msgid "5 – ``INFO``"
msgstr "5 – ``INFO``"

#: ../doc/reference/configuration/cfg_logging.rst:20
msgid "6 – ``VERBOSE``"
msgstr "6 – ``VERBOSE``"

#: ../doc/reference/configuration/cfg_logging.rst:21
msgid "7 – ``DEBUG``"
msgstr "7 – ``DEBUG``"

#: ../doc/reference/configuration/cfg_logging.rst:23
msgid ""
"By setting log_level, one can enable logging of all classes below or "
"equal to the given level. Tarantool prints its logs to the standard error"
" stream by default, but this can be changed with the :ref:`log "
"<cfg_logging-log>` configuration parameter."
msgstr ""
"Задав значение параметра log_level, можно включить запись в журнал всех "
"событий заданного уровня или ниже. По умолчанию, Tarantool выводит записи"
" в стандартный поток сообщений об ошибках, но это можно изменить с "
"помощью конфигурационного параметра :ref:`log <cfg_logging-log>`."

#: ../doc/reference/configuration/cfg_logging.rst:29
msgid "Default: 5"
msgstr "По умолчанию: 5"

#: ../doc/reference/configuration/cfg_logging.rst:32
msgid ""
"Warning: prior to Tarantool 1.7.5 there were only six levels and "
"``DEBUG`` was level 6. Starting with Tarantool 1.7.5 ``VERBOSE`` is level"
" 6 and ``DEBUG`` is level 7. ``VERBOSE`` is a new level for monitoring "
"repetitive events which would cause too much log writing if ``INFO`` were"
" used instead."
msgstr ""
"Внимание: до версии Tarantool'а 1.7.5 было только 6 уровней, из них "
"шестым был уровень ``DEBUG``. Начиная с версии Tarantool'а 1.7.5 "
"``VERBOSE`` становится уровнем 6, а ``DEBUG`` -- уровнем 7. ``VERBOSE`` "
"представляет собой новый уровень для мониторинга повторяющихся событий, "
"которые бы привели к слишком большому количеству записей журнала при "
"использовании уровня ``INFO``."

#: ../doc/reference/configuration/cfg_logging.rst:41
msgid ""
"By default, Tarantool sends the log to the standard error stream "
"(``stderr``). If ``log`` is specified, Tarantool sends the log to a file,"
" or to a pipe, or to the system logger."
msgstr ""
"По умолчанию, Tarantool выводит записи в стандартный поток сообщений об "
"ошибках (``stderr``). Если задан параметр ``log``, Tarantool отправит "
"записи журнала в файл, в конвейер или в системный журнал syslog."

#: ../doc/reference/configuration/cfg_logging.rst:45
msgid "Example setting for sending the log to a file:"
msgstr "Пример настройки для отправки журнала в файл:"

#: ../doc/reference/configuration/cfg_logging.rst:47
msgid ""
"box.cfg{log = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'file:tarantool.log'}"
msgstr ""
"box.cfg{log = 'tarantool.log'}\n"
"-- или\n"
"box.cfg{log = 'file:tarantool.log'}"

#: ../doc/reference/configuration/cfg_logging.rst:53
msgid ""
"This will open the file ``tarantool.log`` for output on the server’s "
"default directory. If the ``log`` string has no prefix or has the prefix "
"\"file:\", then the string is interpreted as a file path."
msgstr ""
"Откроется файл ``tarantool.log`` для вывода в директории сервера, "
"используемой по умолчанию. Если в строке ``log`` нет префикса или есть "
"префикс \"file:\", то строка считается путем к файлу."

#: ../doc/reference/configuration/cfg_logging.rst:57
msgid "Example setting for sending the log to a pipe:"
msgstr "Пример настройки для отправки журнала в конвейер:"

#: ../doc/reference/configuration/cfg_logging.rst:59
msgid ""
"box.cfg{log = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"
msgstr ""
"box.cfg{log = '| cronolog tarantool.log'}\n"
"-- или\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"

#: ../doc/reference/configuration/cfg_logging.rst:65
msgid ""
"This will start the program `cronolog "
"<https://linux.die.net/man/1/cronolog>`_ when the server starts, and will"
" send all log messages to the standard input (``stdin``) of cronolog. If "
"the ``log`` string begins with '|' or has the prefix \"pipe:\", then the "
"string is interpreted as a Unix `pipeline "
"<https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""
"Запустится программа `cronolog <https://linux.die.net/man/1/cronolog>`_ "
"при запуске сервера, которая будет отправлять все сообщения журнала на "
"стандартный вывод (``stdin``) в cronolog. Если строка ``log`` начинается "
"с '|' или содержит префикс \"pipe:\", то строка считается "
"Unix-`конвейером <https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."

#: ../doc/reference/configuration/cfg_logging.rst:71
msgid "Example setting for sending the log to syslog:"
msgstr "Пример настройки для отправки журнала в системный журнал syslog:"

#: ../doc/reference/configuration/cfg_logging.rst:73
msgid ""
"box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:server=unix:/dev/log'}"
msgstr ""
"box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- или\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- или\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}\n"
"-- или\n"
"box.cfg{log = 'syslog:server=unix:/dev/log'}"

#: ../doc/reference/configuration/cfg_logging.rst:83
msgid ""
"If the ``log`` string begins with \"syslog:\", then it is interpreted as "
"a message for the `syslogd <http://www.rfc-base.org/txt/rfc-5424.txt>`_ "
"program which normally is running in the background of any Unix-like "
"platform. The setting can be 'syslog:', 'syslog:facility=...', "
"'syslog:identity=...', 'syslog:server=...', or a combination."
msgstr ""
"Если строка ``log`` начинается с \"syslog:\", это считается сообщением "
"для программы `syslogd <http://www.rfc-base.org/txt/rfc-5424.txt>`_, "
"которая, как правило, работает в фоне на любой Unix-платформе. Настройка "
"может быть: 'syslog:', 'syslog:facility=...', 'syslog:identity=...', "
"'syslog:server=...', или их комбинация."

#: ../doc/reference/configuration/cfg_logging.rst:90
msgid ""
"The ``syslog:identity`` setting is an arbitrary string which will be "
"placed at the beginning of all messages. The default value is: tarantool."
msgstr ""
"Настройка ``syslog:identity`` представляет собой произвольную строку, "
"которая размещается в начале всех сообщений. По умолчанию: tarantool."

#: ../doc/reference/configuration/cfg_logging.rst:93
msgid ""
"The ``syslog:facility`` setting is currently ignored but will be used in "
"the future. The value must be one of the `syslog "
"<https://en.wikipedia.org/wiki/Syslog>`_ keywords, which tell syslogd "
"where the message should go. The possible values are: auth, authpriv, "
"cron, daemon, ftp, kern, lpr, mail, news, security, syslog, user, uucp, "
"local0, local1, local2, local3, local4, local5, local6, local7. The "
"default value is: user."
msgstr ""
"В настоящий момент настройка ``syslog:facility`` не учитывается, но будет"
" использоваться в дальнейшем. Ее значением должно быть одно из ключевых "
"слов `syslog <https://en.wikipedia.org/wiki/Syslog>`_, которые сообщают "
"программе syslogd, куда отправлять сообщение. Возможные значения: auth, "
"authpriv, cron, daemon, ftp, kern, lpr, mail, news, security, syslog, "
"user, uucp, local0, local1, local2, local3, local4, local5, local6, "
"local7. По умолчанию: user."

#: ../doc/reference/configuration/cfg_logging.rst:100
msgid ""
"The ``syslog:server`` setting is the locator for the syslog server. It "
"can be a Unix socket path beginning with \"unix:\", or an ipv4 port "
"number. The default socket value is: dev/log (on Linux) or "
"/var/run/syslog (on Mac OS). The default port value is: 514, the UDP "
"port."
msgstr ""
"Настройка ``syslog:server`` -- это указатель для сервера syslog. Это "
"может быть путь к сокету Unix, который начинается с \"unix:\", или же "
"номер IPv4-порта. Значение по умолчанию для сокета: dev/log (в Linux) или"
" /var/run/syslog (в Mac OS). Значение по умолчанию для порта: 514, "
"UDP-порт."

#: ../doc/reference/configuration/cfg_logging.rst:105
msgid ""
"When logging to a file, Tarantool reopens the log on `SIGHUP "
"<https://en.wikipedia.org/wiki/SIGHUP>`_. When log is a program, its pid "
"is saved in the :ref:`log.logger_pid <log-logger_pid>` variable. You need"
" to send it a signal to rotate logs."
msgstr ""
"При записи в файл Tarantool повторно открывает журнал при сигнале `SIGHUP"
" <https://en.wikipedia.org/wiki/SIGHUP>`_. Если журнал является "
"программой, его PID сохраняется в переменной :ref:`log.logger_pid <log-"
"logger_pid>`. Необходимо отправить сигнал для ротации файлов журнала."

#: ../doc/reference/configuration/cfg_logging.rst:118
msgid ""
"If ``log_nonblock`` equals true, Tarantool does not block during logging "
"when the system is not ready for writing, and drops the message instead. "
"If :ref:`log_level <cfg_logging-log_level>` is high, and many messages go"
" to the log, setting ``log_nonblock`` to true may improve logging "
"performance at the cost of some log messages getting lost."
msgstr ""
"Если значение ``log_nonblock`` равно true (правда), Tarantool не "
"блокирует дескриптор файла журнала, когда он не готов вести запись, а "
"вместо этого сбрасывает сообщение. Если задан высокий уровень "
":ref:`log_level <cfg_logging-log_level>`,и много сообщений попадают в "
"файл журнала, перевод ``log_nonblock`` в true может улучшить "
"производительность ценой потери некоторых сообщений журнала."

#: ../doc/reference/configuration/cfg_logging.rst:124
#, fuzzy
msgid ""
"This parameter has effect only if the output is going to \"syslog:\" or "
"\"pipe:\". Setting ``log_nonblock`` to true is illegal if the output is "
"going to a file."
msgstr ""
"Данный параметр сработает, только если вывод производится в системный "
"журнал ``syslog`` или в конвейер."

#: ../doc/reference/configuration/cfg_logging.rst:129
msgid ""
"The default ``log_nonblock`` value is nil, which means that blocking "
"behavior corresponds to the type of logger. This is a behavior change: in"
" earlier versions of the Tarantool server, the default value was true."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:135
msgid "Default: nil"
msgstr "По умолчанию: null"

#: ../doc/reference/configuration/cfg_logging.rst:142
msgid ""
"If processing a request takes longer than the given value (in seconds), "
"warn about it in the log. Has effect only if :ref:`log_level "
"<cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""
"Если обработка запроса занимает дольше времени, чем заданное значение (в "
"секундах), в журнал заносится соответствующее предупреждение. Сработает, "
"только если в :ref:`log_level <cfg_logging-log_level>` задан уровень 4 "
"(WARNING) или выше."

#: ../doc/reference/configuration/cfg_logging.rst:147
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:86
msgid "Default: 0.5"
msgstr "По умолчанию: 0.5"

#: ../doc/reference/configuration/cfg_logging.rst:154
msgid "Log entries have two possible formats:"
msgstr "Данные в журнал записываются в двух форматах:"

#: ../doc/reference/configuration/cfg_logging.rst:156
#: ../doc/reference/reference_lua/log.rst:21
msgid "'plain' (the default), or"
msgstr "'plain' (по умолчанию) или"

#: ../doc/reference/configuration/cfg_logging.rst:157
#: ../doc/reference/reference_lua/log.rst:22
msgid "'json' (with more detail and with JSON labels)."
msgstr "'json' (более детально с JSON-метками)."

#: ../doc/reference/configuration/cfg_logging.rst:159
#: ../doc/reference/reference_lua/log.rst:24
msgid "Here is what a log entry looks like after ``box.cfg{log_format='plain'}``:"
msgstr ""
"Вот как будет выглядеть запись в журнале после выполнения "
"``box.cfg{log_format='plain'}``:"

#: ../doc/reference/configuration/cfg_logging.rst:161
#: ../doc/reference/reference_lua/log.rst:26
msgid ""
"2017-10-16 11:36:01.508 [18081] main/101/interactive I> set 'log_format' "
"configuration option to \"plain\""
msgstr ""
"2017-10-16 11:36:01.508 [18081] main/101/interactive I> set 'log_format' "
"configuration option to \"plain\""

#: ../doc/reference/configuration/cfg_logging.rst:165
#: ../doc/reference/reference_lua/log.rst:30
msgid "Here is what a log entry looks like after ``box.cfg{log_format='json'}``:"
msgstr ""
"Вот как будет выглядеть запись в журнале после выполнения "
"``box.cfg{log_format='json'}``:"

#: ../doc/reference/configuration/cfg_logging.rst:167
#: ../doc/reference/reference_lua/log.rst:32
msgid ""
"{\"time\": \"2017-10-16T11:36:17.996-0600\",\n"
"\"level\": \"INFO\",\n"
"\"message\": \"set 'log_format' configuration option to \\\"json\\\"\",\n"
"\"pid\": 18081,|\n"
"\"cord_name\": \"main\",\n"
"\"fiber_id\": 101,\n"
"\"fiber_name\": \"interactive\",\n"
"\"file\": \"builtin\\/box\\/load_cfg.lua\",\n"
"\"line\": 317}"
msgstr ""
"{\"time\": \"2017-10-16T11:36:17.996-0600\",\n"
"\"level\": \"INFO\",\n"
"\"message\": \"set 'log_format' configuration option to \\\"json\\\"\",\n"
"\"pid\": 18081,|\n"
"\"cord_name\": \"main\",\n"
"\"fiber_id\": 101,\n"
"\"fiber_name\": \"interactive\",\n"
"\"file\": \"builtin\\/box\\/load_cfg.lua\",\n"
"\"line\": 317}"

#: ../doc/reference/configuration/cfg_logging.rst:179
msgid ""
"The ``log_format='plain'`` entry has time, process id, cord name, "
":ref:`fiber_id <fiber_object-id>`, :ref:`fiber_name <fiber_object-"
"name_get>`, :ref:`log level <cfg_logging-log_level>`, and message."
msgstr ""
"В простом формате (``log_format='plain'``) запись содержит время, "
"идентификатор процесса, имя файбера, идентификатор файбера :ref:`fiber_id"
" <fiber_object-id>`, имя файбера :ref:`fiber_name <fiber_object-"
"name_get>`, :ref:`уровень записи в журнал <cfg_logging-log_level>` и "
"сообщение."

#: ../doc/reference/configuration/cfg_logging.rst:184
msgid ""
"The ``log_format='json'`` entry has the same things along with their "
"labels, and in addition has the file name and line number of the "
"Tarantool source."
msgstr ""
"В JSON-формате (``log_format='json'``) запись содержит все "
"вышеперечисленное с соответствующими метками, а также имя файла и номер "
"строки Tarantool-источника."

#: ../doc/reference/configuration/cfg_logging.rst:187
msgid ""
"Setting ``log_format`` to 'json' is illegal if the output is going to "
"\"syslog:\"."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:190
msgid "Default: 'plain'"
msgstr "По умолчанию: 'plain'"

#: ../doc/reference/configuration/cfg_logging.rst:197
msgid "Logging example"
msgstr "Пример записи в журнал"

#: ../doc/reference/configuration/cfg_logging.rst:199
msgid ""
"This will illustrate how \"rotation\" works, that is, what happens when "
"the server instance is writing to a log and signals are used when "
"archiving it."
msgstr ""
"Данный пример проиллюстрирует ротацию файлов журнала, то есть что "
"происходит, когда экземпляр сервера производит запись в журнал? а при "
"архивировании используются сигналы."

#: ../doc/reference/configuration/cfg_logging.rst:202
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr "Запустите две оболочки, терминал №1 и терминал №2."

#: ../doc/reference/configuration/cfg_logging.rst:204
msgid ""
"On Terminal #1: start an interactive Tarantool session, then say the "
"logging will go to `Log_file`, then put a message \"Log Line #1\" in the "
"log file:"
msgstr ""
"На терминале №1 запустите интерактивную сессию Tarantool'а, затем "
"укажите, что запись в журнал ведется в файл `Log_file`, а затем поместите"
" сообщение \"Log Line #1\" в файл журнала:"

#: ../doc/reference/configuration/cfg_logging.rst:207
msgid ""
"box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""
"box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"

#: ../doc/reference/configuration/cfg_logging.rst:213
msgid ""
"On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. "
"The result of this is: the next log message will go to `Log_file.bak`."
msgstr ""
"На терминале №2 используйте команду ``mv``, чтобы файл журнала назывался "
"`Log_file.bak`. Результатом будет то, что следующее сообщение журнала "
"пойдет в файл `Log_file.bak`."

#: ../doc/reference/configuration/cfg_logging.rst:253
#: ../doc/reference/configuration/cfg_logging.rst:1517
msgid "mv Log_file Log_file.bak"
msgstr "mv Log_file Log_file.bak"

#: ../doc/reference/configuration/cfg_logging.rst:221
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file."
msgstr "На терминале №1 поместите сообщение \"Log Line #2\" в файл журнала."

#: ../doc/reference/configuration/cfg_logging.rst:223
msgid "log.info('Log Line #2')"
msgstr "log.info('Log Line #2')"

#: ../doc/reference/configuration/cfg_logging.rst:227
msgid ""
"On Terminal #2: use ``ps`` to find the process ID of the Tarantool "
"instance."
msgstr ""
"На терминале №2 используйте команду ``ps``, чтобы найти ID процесса "
"экземпляра Tarantool'а."

#: ../doc/reference/configuration/cfg_logging.rst:266
#: ../doc/reference/configuration/cfg_logging.rst:1530
msgid "ps -A | grep tarantool"
msgstr "ps -A | grep tarantool"

#: ../doc/reference/configuration/cfg_logging.rst:234
msgid ""
"On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the "
"Tarantool instance. The result of this is: Tarantool will open `Log_file`"
" again, and the next log message will go to `Log_file`. (The same effect "
"could be accomplished by executing log.rotate() on the instance.)"
msgstr ""
"На терминале №2 используйте команду ``kill -HUP`` для отправки сигнала "
"SIGHUP на экземпляр Tarantool'а. Результат: Tarantool снова откроет "
"`Log_file`, и следующее сообщение журнала пойдет в `Log_file`. (Тот же "
"результат можно получить путем выполнения команды log.rotate() на "
"экземпляре.)"

#: ../doc/reference/configuration/cfg_logging.rst:276
#: ../doc/reference/configuration/cfg_logging.rst:1540
msgid "kill -HUP *process_id*"
msgstr "kill -HUP *process_id*"

#: ../doc/reference/configuration/cfg_logging.rst:244
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr "На терминале №1 поместите сообщение \"Log Line #3\" в файл журнала."

#: ../doc/reference/configuration/cfg_logging.rst:246
msgid "log.info('Log Line #3')"
msgstr "log.info('Log Line #3')"

#: ../doc/reference/configuration/cfg_logging.rst:250
msgid ""
"On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have "
"these lines, except that the date and time will depend on when the "
"example is done:"
msgstr ""
"На терминале №2 используйте команду ``less`` для просмотра файлов. "
"`Log_file.bak` будет содержать следующие строки, но дата и время будут "
"указаны в зависимости от времени выполнения примера:"

#: ../doc/reference/configuration/cfg_logging.rst:290
#: ../doc/reference/configuration/cfg_logging.rst:1554
msgid ""
"2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""
"2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"

#: ../doc/reference/configuration/cfg_logging.rst:259
msgid "and `Log_file` will have"
msgstr "а `Log_file` будет содержать"

#: ../doc/reference/configuration/cfg_logging.rst:298
#: ../doc/reference/configuration/cfg_logging.rst:1562
msgid ""
"log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""
"log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"

#: ../doc/reference/configuration/cfg_logging.rst:269
msgid "Feedback"
msgstr "Обратная связь"

#: ../doc/reference/configuration/cfg_logging.rst:271
msgid ":ref:`feedback_enabled <cfg_logging-feedback_enabled>`"
msgstr ":ref:`feedback_enabled <cfg_logging-feedback_enabled>`"

#: ../doc/reference/configuration/cfg_logging.rst:272
msgid ":ref:`feedback_host <cfg_logging-feedback_host>`"
msgstr ":ref:`feedback_host <cfg_logging-feedback_host>`"

#: ../doc/reference/configuration/cfg_logging.rst:273
msgid ":ref:`feedback_interval <cfg_logging-feedback_interval>`"
msgstr ":ref:`feedback_interval <cfg_logging-feedback_interval>`"

#: ../doc/reference/configuration/cfg_logging.rst:275
msgid ""
"By default a Tarantool daemon sends a small packet once per hour, to "
"https://feedback.tarantool.io. The packet contains three values from "
":ref:`box.info <box_introspection-box_info>`: ``box.info.version``, "
"``box.info.uuid``, and ``box.info.cluster_uuid``. By changing the "
"feedback configuration parameters, users can adjust or turn off this "
"feature."
msgstr ""
"По умолчанию, демон Tarantool'а отправляет небольшой пакет каждый час на "
"https://feedback.tarantool.io. Пакет содержит три значения из "
":ref:`box.info <box_introspection-box_info>`: ``box.info.version``, "
"``box.info.uuid`` и ``box.info.cluster_uuid``. Изменив конфигурационные "
"параметры обратной связи, пользователи могут настроить или отключить эту "
"функцию."

#: ../doc/reference/configuration/cfg_logging.rst:286
msgid "Whether to send feedback."
msgstr "Отправлять обратную связь или нет."

#: ../doc/reference/configuration/cfg_logging.rst:288
msgid ""
"If this is set to ``true``, feedback will be sent as described above. If "
"this is set to ``false``, no feedback will be sent."
msgstr ""
"Если задано значение ``true``, обратная связь будет отправлена, как "
"описано выше. Если задано значение ``false``, обратная связь не "
"отправляется."

#: ../doc/reference/configuration/cfg_logging.rst:299
msgid ""
"The address to which the packet is sent. Usually the recipient is "
"Tarantool, but it can be any URL."
msgstr ""
"Адрес, на который отправляется пакет. Как правило, получателем будет "
"Tarantool, но можно указать любой URL."

#: ../doc/reference/configuration/cfg_logging.rst:303
msgid "Default: 'https://feedback.tarantool.io'"
msgstr "По умолчанию: 'https://feedback.tarantool.io'"

#: ../doc/reference/configuration/cfg_logging.rst:310
msgid "The number of seconds between sendings, usually 3600 (1 hour)."
msgstr "Количество секунд между отправками, обычно 3600 (1 час)."

#: ../doc/reference/configuration/cfg_logging.rst:313
msgid "Default: 3600"
msgstr "По умолчанию: 3600"

#: ../doc/reference/configuration/cfg_networking.rst:1
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"
msgstr ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"

#: ../doc/reference/configuration/cfg_networking.rst:2
msgid ":ref:`net_msg_max <cfg_networking-net_msg_max>`"
msgstr ":ref:`net_msg_max <cfg_networking-net_msg_max>`"

#: ../doc/reference/configuration/cfg_networking.rst:3
msgid ":ref:`readahead <cfg_networking-readahead>`,"
msgstr ":ref:`readahead <cfg_networking-readahead>`,"

#: ../doc/reference/configuration/cfg_networking.rst:9
msgid ""
"The instance will sleep for io_collect_interval seconds between "
"iterations of the event loop. Can be used to reduce CPU load in "
"deployments in which the number of client connections is large, but "
"requests are not so frequent (for example, each connection issues just a "
"handful of requests per second)."
msgstr ""
"Экземпляр уходит в режим ожидания на io_collect_interval секунд между "
"итерациями событийного цикла. Это можно использовать для снижения "
"загрузки процессора в системах с большим количество клиентских "
"соединений, но нечастыми запросами (например, каждое соединение передает "
"лишь небольшое количество запросов в секунду)."

#: ../doc/reference/configuration/cfg_networking.rst:22
msgid ""
"To handle messages, Tarantool allocates fibers. To prevent fiber overhead"
" from affecting the whole system, Tarantool restricts how many messages "
"the fibers handle, so that some pending requests are blocked."
msgstr ""
"Для обработки сообщений Tarantool выделяет файберы. Чтобы не допустить "
"перегрузки файберов, которая влияет на всю систему, Tarantool "
"ограничивает число сообщений, которые могут обрабатывать файберы, чтобы "
"блокировать некоторые отложенные запросы."

#: ../doc/reference/configuration/cfg_networking.rst:27
msgid ""
"On powerful systems, increase ``net_msg_max`` and the scheduler will "
"immediately start processing pending requests."
msgstr ""
"В мощных системах увеличьте значение ``net_msg_max``, и планировщик "
"немедленно приступит к обработке отложенных запросов."

#: ../doc/reference/configuration/cfg_networking.rst:30
msgid ""
"On weaker systems, decrease ``net_msg_max`` and the overhead may decrease"
" although this may take some time because the scheduler must wait until "
"already-running requests finish."
msgstr ""
"В более слабых системах уменьшите значение``net_msg_max``, чтобы снизить "
"загрузку, хотя это и займет некоторое время, поскольку планировщик будет "
"ожидать завершения уже запущенных запросов."

#: ../doc/reference/configuration/cfg_networking.rst:34
msgid ""
"When ``net_msg_max`` is reached, Tarantool suspends processing of "
"incoming packages until it has processed earlier messages. This is not a "
"direct restriction of the number of fibers that handle network messages, "
"rather it is a system-wide restriction of channel bandwidth. This in turn"
" causes restriction of the number of incoming network messages that the "
":ref:`transaction processor thread <atomic-threads_fibers_yields>` "
"handles, and therefore indirectly affects the fibers that handle network "
"messages. (The number of fibers is smaller than the number of messages "
"because messages can be released as soon as they are delivered, while "
"incoming requests might not be processed until some time after delivery.)"
msgstr ""
"По достижении значения ``net_msg_max`` Tarantool приостанавливает "
"обработку входящих пакетов до тех пор, пока не обработает ранее "
"полученные сообщения. Это не ограничение количества файберов, которые "
"обрабатывают сетевые сообщения, напрямую, а скорее общесистемное "
"ограничение ширины полосы канала. В свою очередь, это вызывает "
"ограничение количества входящих сетевых сообщений, которые обрабатывает "
":ref:`поток обработки транзакций <atomic-threads_fibers_yields>`, таким "
"образом косвенно воздействуя на количество файберов, которые обрабатывают"
" сетевые сообщения. (Количество файберов меньше количества сообщений, "
"поскольку сообщения можно освободить сразу после доставки, а входящие "
"запросы могут ждать обработки в течение некоторого времени после "
"доставки.)"

#: ../doc/reference/configuration/cfg_networking.rst:48
msgid "On typical systems, the default value (768) is correct."
msgstr "Для стандартных систем подойдет значение, используемое по умолчанию (768)."

#: ../doc/reference/configuration/cfg_networking.rst:51
msgid "Default: 768"
msgstr "По умолчанию: 768"

#: ../doc/reference/configuration/cfg_networking.rst:58
msgid ""
"The size of the read-ahead buffer associated with a client connection. "
"The larger the buffer, the more memory an active connection consumes and "
"the more requests can be read from the operating system buffer in a "
"single system call. The rule of thumb is to make sure the buffer can "
"contain at least a few dozen requests. Therefore, if a typical tuple in a"
" request is large, e.g. a few kilobytes or even megabytes, the read-ahead"
" buffer size should be increased. If batched request processing is not "
"used, it’s prudent to leave this setting at its default."
msgstr ""
"Размер буфера опережающего считывания, связанный с клиентским "
"соединением. Чем больше буфер, тем больше памяти потребляет активное "
"соединение и тем больше запросов можно считать из буфера операционной "
"системы за отдельный системный вызов. Общее правило состоит в том, чтобы "
"убедиться, что буфер может содержать как минимум несколько десятков "
"соединений. Таким образом, если размер стандартного кортежа в запросе "
"значительный, например, несколько килобайтов или даже мегабайтов, следует"
" увеличить размер буфера опережающего считывания. Если не используется "
"пакетная обработка запросов, будет целесообразно оставить значение, "
"используемое по умолчанию."

#: ../doc/reference/configuration/cfg_networking.rst:68
msgid "Default: 16320"
msgstr "По умолчанию: 16320"

#: ../doc/reference/configuration/cfg_replication.rst:1
msgid ":ref:`replication <cfg_replication-replication>`"
msgstr ":ref:`replication <cfg_replication-replication>`"

#: ../doc/reference/configuration/cfg_replication.rst:2
msgid ":ref:`replication_timeout <cfg_replication-replication_timeout>`"
msgstr ":ref:`replication_timeout <cfg_replication-replication_timeout>`"

#: ../doc/reference/configuration/cfg_replication.rst:3
msgid ""
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>`"
msgstr ""
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>`"

#: ../doc/reference/configuration/cfg_replication.rst:4
msgid ""
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`"
msgstr ""
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`"

#: ../doc/reference/configuration/cfg_replication.rst:5
msgid ""
":ref:`replication_skip_conflict <cfg_replication-"
"replication_skip_conflict>`"
msgstr ""
":ref:`replication_skip_conflict <cfg_replication-"
"replication_skip_conflict>`"

#: ../doc/reference/configuration/cfg_replication.rst:6
msgid ":ref:`replication_sync_lag <cfg_replication-replication_sync_lag>`"
msgstr ":ref:`replication_sync_lag <cfg_replication-replication_sync_lag>`"

#: ../doc/reference/configuration/cfg_replication.rst:7
msgid ":ref:`replication_sync_timeout <cfg_replication-replication_sync_timeout>`"
msgstr ":ref:`replication_sync_timeout <cfg_replication-replication_sync_timeout>`"

#: ../doc/reference/configuration/cfg_replication.rst:8
msgid ":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`"
msgstr ":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`"

#: ../doc/reference/configuration/cfg_replication.rst:9
msgid ":ref:`instance_uuid <cfg_replication-instance_uuid>`"
msgstr ":ref:`instance_uuid <cfg_replication-instance_uuid>`"

#: ../doc/reference/configuration/cfg_replication.rst:15
msgid ""
"If ``replication`` is not an empty string, the instance is considered to "
"be a Tarantool :ref:`replica <replication>`. The replica will try to "
"connect to the master specified in ``replication`` with a :ref:`URI "
"<index-uri>` (Universal Resource Identifier), for example:"
msgstr ""
"Если ``replication`` не содержит пустую строку, экземпляр считается "
":ref:`репликой <replication>`. Реплика попытается подключиться к мастеру,"
" указанному в параметре ``replication`` по :ref:`URI <index-uri>` "
"(унифицированному идентификатору ресурса), например:"

#: ../doc/reference/configuration/cfg_replication.rst:20
msgid ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"
msgstr ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"

#: ../doc/reference/configuration/cfg_replication.rst:22
msgid ""
"If there is more than one replication source in a replica set, specify an"
" array of URIs, for example (replace 'uri' and 'uri2' in this example "
"with valid URIs):"
msgstr ""
"Если в наборе реплик более одного источника репликации, укажите массив "
"URI, например (замените 'uri' и 'uri2' в данном примере на рабочие URI):"

#: ../doc/reference/configuration/cfg_replication.rst:26
msgid ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"
msgstr ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"

#: ../doc/reference/configuration/cfg_replication.rst:28
msgid ""
"If one of the URIs is \"self\" -- that is, if one of the URIs is for the "
"instance where ``box.cfg{}`` is being executed on -- then it is ignored. "
"Thus it is possible to use the same ``replication`` specification on "
"multiple server instances, as shown in :ref:`these examples <replication-"
"bootstrap>`."
msgstr ""
"Если один из URI \"свой\" -- то есть один URI принадлежит экземпляру, где"
" выполняется ``box.cfg{}`` -- он не принимается во внимание. Таким "
"образом, можно использовать одну и ту же настройку параметра "
"``replication`` на нескольких экземплярах сервера, как показано в "
":ref:`этих примерах <replication-bootstrap>`."

#: ../doc/reference/configuration/cfg_replication.rst:34
msgid "The default user name is 'guest'."
msgstr "По умолчанию, пользователем считается 'guest'."

#: ../doc/reference/configuration/cfg_replication.rst:36
msgid ""
"A read-only replica does not accept data-change requests on the "
":ref:`listen <cfg_basic-listen>` port."
msgstr ""
"Реплика в режиме только для чтения не принимает запросы по изменению "
"данных по порту для :ref:`прослушивания <cfg_basic-listen>`."

#: ../doc/reference/configuration/cfg_replication.rst:39
msgid ""
"The ``replication`` parameter is dynamic, that is, to enter master mode, "
"simply set ``replication`` to an empty string and issue:"
msgstr ""
"Параметр ``replication`` является динамическим, то есть для входа в режим"
" мастера необходимо просто присвоить параметру ``replication`` пустую "
"строку и выполнить следующее:"

#: ../doc/reference/configuration/cfg_replication.rst:42
msgid ":extsamp:`box.cfg{ replication = {*{new-value}*} }`"
msgstr ":extsamp:`box.cfg{ replication = {*{новое-значение}*} }`"

#: ../doc/reference/configuration/cfg_replication.rst:52
msgid ""
"A replica sends heartbeat messages to the master every second, and the "
"master is programmed to reconnect automatically if it doesn’t see "
"heartbeat messages more often than ``replication_timeout`` seconds."
msgstr ""
"Реплика отправляет сообщения контрольного сигнала на мастер каждую "
"секунду, и мастер запрограммирован на автоматическое переподключение, "
"если он не получает сообщения контрольного сигнала дольше количества "
"секунд, указанного в ``replication_timeout``."

#: ../doc/reference/configuration/cfg_replication.rst:56
msgid "See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""
"См. дополнительную информацию в разделе :ref:`Мониторинг набора реплик "
"<replication-monitoring>`."

#: ../doc/reference/configuration/cfg_replication.rst:59
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:108
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:123
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:159
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:189
msgid "Default: 1"
msgstr "По умолчанию: 1"

#: ../doc/reference/configuration/cfg_replication.rst:66
msgid ""
"The number of seconds that a replica will wait when trying to connect to "
"a master in a cluster. See :ref:`orphan status <replication-"
"orphan_status>` for details."
msgstr ""
"Количество секунд, в течение которых реплика ожидает попытки подключения "
"к мастеру в кластере. Для получения подробной информации, см. "
":ref:`статус orphan <replication-orphan_status>`."

#: ../doc/reference/configuration/cfg_replication.rst:70
msgid ""
"This parameter is different from :ref:`replication_timeout "
"<cfg_replication-replication_timeout>`, which is only used to "
"automatically reconnect replication when it gets no heartbeats."
msgstr ""
"Данный параметр отличается от :ref:`replication_timeout <cfg_replication-"
"replication_timeout>`, который используется только для автоматического "
"переподключения репликации, когда отсутствуют сообщения контрольного "
"сигнала."

#: ../doc/reference/configuration/cfg_replication.rst:83
msgid ""
"By default a replica will try to connect to all the masters, or it will "
"not start. (The default is recommended so that all replicas will receive "
"the same replica set UUID.)"
msgstr ""
"По умолчанию, реплика попытается подключиться ко всем мастерам или не "
"запустится. (По умолчанию, рекомендуется, чтобы у всех реплик был "
"одинаковый UUID набора реплик)."

#: ../doc/reference/configuration/cfg_replication.rst:87
msgid ""
"However, by specifying ``replication_connect_quorum = N``, where N is a "
"number greater than or equal to zero, users can state that the replica "
"only needs to connect to N masters."
msgstr ""
"Однако, если указать ``replication_connect_quorum = N``, где N означает "
"число больше или равное нулю, это будет означать, что реплике нужно "
"подключиться к N количеству мастеров."

#: ../doc/reference/configuration/cfg_replication.rst:91
msgid ""
"This parameter has effect during bootstrap and during :ref:`configuration"
" update <replication-configuration_update>`. Setting "
"``replication_connect_quorum = 0`` makes Tarantool require no immediate "
"reconnect only in case of recovery. See :ref:`orphan status <replication-"
"orphan_status>` for details."
msgstr ""
"Данный параметр используется во время настройки и :ref:`обновления "
"конфигурации <replication-configuration_update>`. При настройке "
"``replication_connect_quorum = 0`` Tarantool не требует немедленного "
"переподключения в случае восстановления. Для получения подробной "
"информации, см. :ref:`статус orphan <replication-orphan_status>`."

#: ../doc/reference/configuration/cfg_replication.rst:97
#: ../doc/reference/configuration/cfg_replication.rst:118
#: ../doc/reference/configuration/cfg_replication.rst:208
#: ../doc/reference/configuration/cfg_replication.rst:230
#: ../doc/reference/reference_lua/other.rst:163
#: ../doc/reference/reference_lua/swim.rst:142
#: ../doc/reference/reference_lua/swim.rst:225
#: ../doc/reference/reference_lua/swim.rst:238
#: ../doc/reference/reference_lua/swim.rst:336
#: ../doc/reference/reference_lua/swim.rst:517
#: ../doc/reference/reference_lua/swim.rst:549
#: ../doc/reference/reference_lua/swim.rst:711
#: ../doc/reference/reference_lua/swim.rst:736
#: ../doc/reference/reference_lua/swim.rst:921
#: ../doc/reference/reference_sql/sql.rst:758
#: ../doc/reference/reference_sql/sql.rst:1335
#: ../doc/reference/reference_sql/sql.rst:1423
#: ../doc/reference/reference_sql/sql.rst:2269
#: ../doc/reference/reference_sql/sql.rst:2294
#: ../doc/reference/reference_sql/sql.rst:2346
#: ../doc/reference/reference_sql/sql.rst:2424
#: ../doc/reference/reference_sql/sql.rst:2465
#: ../doc/reference/reference_sql/sql.rst:2495
#: ../doc/reference/reference_sql/sql.rst:2524
#: ../doc/reference/reference_sql/sql.rst:2645
#: ../doc/reference/reference_sql/sql.rst:2687
msgid "Example:"
msgstr "Пример:"

#: ../doc/reference/configuration/cfg_replication.rst:99
msgid "box.cfg{replication_connect_quorum=2}"
msgstr "box.cfg{replication_connect_quorum=2}"

#: ../doc/reference/configuration/cfg_replication.rst:111
msgid ""
"By default, if a replica adds a unique key that another replica has "
"added, replication :ref:`stops <replication-replication_stops>` with "
"error = ER_TUPLE_FOUND."
msgstr ""
"По умолчанию, если реплика добавляет уникальный ключ, который уже "
"добавила другая реплика, репликация :ref:`останавливается <replication-"
"replication_stops>` с ошибкой = ER_TUPLE_FOUND."

#: ../doc/reference/configuration/cfg_replication.rst:115
msgid ""
"However, by specifying ``replication_skip_conflict = true``, users can "
"state that such errors may be ignored."
msgstr ""
"Однако если указать ``replication_skip_conflict = true``, пользователи "
"могут задать пропуск таких ошибок."

#: ../doc/reference/configuration/cfg_replication.rst:120
msgid "box.cfg{replication_skip_conflict=true}"
msgstr "box.cfg{replication_skip_conflict=true}"

#: ../doc/reference/configuration/cfg_replication.rst:133
msgid ""
"The maximum :ref:`lag <box_info_replication_upstream_lag>` allowed for a "
"replica. When a replica :ref:`syncs <replication-orphan_status>` (gets "
"updates from a master), it may not catch up completely. The number of "
"seconds that the replica is behind the master is called the \"lag\". "
"Syncing is considered to be complete when the replica's lag is less than "
"or equal to ``replication_sync_lag``."
msgstr ""
"Максимально допустимое :ref:`отставание "
"<box_info_replication_upstream_lag>` для реплики. Если реплика "
":ref:`синхронизируется <replication-orphan_status>` (то есть получает "
"обновления от мастера), она может обновиться не полностью. Количество "
"секунд, когда реплика находится позади мастера, называется \"отставание\""
" (lag). Синхронизация считается завершенной, когда отставание реплики "
"меньше или равно ``replication_sync_lag``."

#: ../doc/reference/configuration/cfg_replication.rst:140
msgid ""
"If a user sets ``replication_sync_lag`` to nil or to 365 * 100 * 86400 "
"(TIMEOUT_INFINITY), then lag does not matter -- the replica is always "
"considered to be \"synced\". Also, the lag is ignored (assumed to be "
"infinite) in case the master is running Tarantool older than 1.7.7, which"
" does not send :ref:`heartbeat messages <heartbeat>`."
msgstr ""
"Если пользователь задает значение ``replication_sync_lag``, равное nil "
"или 365 * 100 * 86400 (TIMEOUT_INFINITY), то отставание не имеет значения"
" -- реплика всегда будет синхронизирована. Кроме того, отставание не "
"учитывается (считается бесконечным), если мастер работает на версии "
"Tarantool'а старше 1.7.7, которая не отправляет :ref:`сообщения "
"контрольного сигнала <heartbeat>`."

#: ../doc/reference/configuration/cfg_replication.rst:145
msgid ""
"This parameter is ignored during bootstrap. See :ref:`orphan status "
"<replication-orphan_status>` for details."
msgstr ""
"Этот параметр не учитывается во время настройки. Для получения подробной "
"информации, см. :ref:`статус orphan <replication-orphan_status>`."

#: ../doc/reference/configuration/cfg_replication.rst:149
msgid "Default: 10"
msgstr "По умолчанию: 10"

#: ../doc/reference/configuration/cfg_replication.rst:156
msgid ""
"The number of seconds that a replica will wait when trying to sync with a"
" master in a cluster, or a :ref:`quorum <cfg_replication-"
"replication_connect_quorum>` of masters, after connecting or during "
":ref:`configuration update <replication-configuration_update>`. This "
"could fail indefinitely if ``replication_sync_lag`` is smaller than "
"network latency, or if the replica cannot keep pace with master updates. "
"If ``replication_sync_timeout`` expires, the replica enters :ref:`orphan "
"status <replication-orphan_status>`."
msgstr ""
"Количество секунд, в течение которых реплика ожидает попытки "
"синхронизации с мастером в кластере или :ref:`кворумом <cfg_replication-"
"replication_connect_quorum>` мастеров после подключения или во время "
":ref:`обновления конфигурации <replication-configuration_update>`, что "
"может никогда не произойти, если значение ``replication_sync_lag`` меньше"
" сетевой задержки, или реплика не может поддерживать темп обновлений "
"мастера. По истечении времени ``replication_sync_timeout`` реплика "
"получает :ref:`статус orphan <replication-orphan_status>`."

#: ../doc/reference/configuration/cfg_replication.rst:166
msgid "Default: 300"
msgstr "По умолчанию: 300"

#: ../doc/reference/configuration/cfg_replication.rst:173
msgid ""
"As described in section :ref:`\"Replication architecture\" <replication-"
"architecture>`, each replica set is identified by a `universally unique "
"identifier "
"<https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ called "
"**replica set UUID**, and each instance is identified by an **instance "
"UUID**."
msgstr ""
"Как описано в разделе :ref:`\"Архитектура механизма репликации\" "
"<replication-architecture>`, каждый набор реплик идентифицируется по "
"`Универсальному уникальному идентификатору (UUID) "
"<https://en.wikipedia.org/wiki/Universally_unique_identifier>`_, который "
"называется **UUID набора реплик**, и каждый экземпляр идентифицируется по"
" **UUID экземпляра**."

#: ../doc/reference/configuration/cfg_replication.rst:180
msgid ""
"Ordinarily it is sufficient to let the system generate and format the "
"UUID strings which will be permanently stored."
msgstr ""
"Как правило, достаточно позволить системе сгенерировать и форматировать "
"строки, содержащие UUID, которые будут храниться постоянно."

#: ../doc/reference/configuration/cfg_replication.rst:183
msgid ""
"However, some administrators may prefer to store Tarantool configuration "
"information in a central repository, for example `Apache ZooKeeper "
"<https://zookeeper.apache.org>`_. Such administrators can assign their "
"own UUID values for either -- or both -- instances (:ref:`instance_uuid "
"<cfg_replication-instance_uuid>`) and replica set (``replicaset_uuid``), "
"when starting up for the first time."
msgstr ""
"Однако, некоторые администраторы предпочитают сохранять конфигурацию "
"Tarantool'а в центральном репозитории, например, `Apache ZooKeeper "
"<https://zookeeper.apache.org>`_. Они могут самостоятельно присвоить "
"значения экземплярам (:ref:`instance_uuid <cfg_replication-"
"instance_uuid>`) и набору реплик (``replicaset_uuid``) при первом "
"запуске."

#: ../doc/reference/configuration/cfg_replication.rst:190
msgid "General rules:"
msgstr "Общие правила:"

#: ../doc/reference/configuration/cfg_replication.rst:192
msgid ""
"The values must be true unique identifiers, not shared by other instances"
" or replica sets within the common infrastructure."
msgstr ""
"Значения должны быть действительно уникальными; они не должны "
"одновременно принадлежать другим экземплярам или наборам реплик в той же "
"инфраструктуре."

#: ../doc/reference/configuration/cfg_replication.rst:195
msgid ""
"The values must be used consistently, not changed after initial setup "
"(the initial values are stored in :ref:`snapshot files <index-"
"box_persistence>` and are checked whenever the system is restarted)."
msgstr ""
"Значения должны использоваться постоянно, неизменно с первого запуска "
"(первоначальные значения хранятся в :ref:`файлах снимков <index-"
"box_persistence>` и проверяются при каждом перезапуске системы)."

#: ../doc/reference/configuration/cfg_replication.rst:199
msgid ""
"The values must comply with `RFC 4122 "
"<https://tools.ietf.org/html/rfc4122>`_. The `nil UUID "
"<https://tools.ietf.org/html/rfc4122#section-4.1.7>`_ is not allowed."
msgstr ""
"Значения должны соответствовать требованиям `RFC 4122 "
"<https://tools.ietf.org/html/rfc4122>`_. `Нулевой UUID "
"<https://tools.ietf.org/html/rfc4122#section-4.1.7>`_ не допускается."

#: ../doc/reference/configuration/cfg_replication.rst:203
msgid ""
"The UUID format includes sixteen octets represented as 32 hexadecimal "
"(base 16) digits, displayed in five groups separated by hyphens, in the "
"form ``8-4-4-4-12`` for a total of 36 characters (32 alphanumeric "
"characters and four hyphens)."
msgstr ""
"Формат UUID включает в себя шестнадцать октетов, представленных в виде 32"
" шестнадцатеричных чисел (с основанием 16) в пяти группах, разделенных "
"дефисами в форме ``8-4-4-4-12`` -- 36 символов (32 буквенно-цифровых "
"символа и четыре дефиса)."

#: ../doc/reference/configuration/cfg_replication.rst:210
msgid "box.cfg{replicaset_uuid='7b853d13-508b-4b8e-82e6-806f088ea6e9'}"
msgstr "box.cfg{replicaset_uuid='7b853d13-508b-4b8e-82e6-806f088ea6e9'}"

#: ../doc/reference/configuration/cfg_replication.rst:222
msgid ""
"For replication administration purposes, it is possible to set the "
"`universally unique identifiers "
"<https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ of the "
"instance (``instance_uuid``) and the replica set (``replicaset_uuid``), "
"instead of having the system generate the values."
msgstr ""
"Для целей администрирования репликации можно самостоятельно присвоить "
"`универсально уникальные идентификаторы "
"<https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ "
"экземпляру (``instance_uuid``) и набору реплик (``replicaset_uuid``) "
"вместо использования сгенерированных системой значений."

#: ../doc/reference/configuration/cfg_replication.rst:227
msgid ""
"See the description of :ref:`replicaset_uuid <cfg_replication-"
"replicaset_uuid>` parameter for details."
msgstr ""
"Для получения подробной информации см. описание параметра "
":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`."

#: ../doc/reference/configuration/cfg_replication.rst:232
msgid "box.cfg{instance_uuid='037fec43-18a9-4e12-a684-a42b716fcd02'}"
msgstr "box.cfg{instance_uuid='037fec43-18a9-4e12-a684-a42b716fcd02'}"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:1
msgid ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"
msgstr ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:2
msgid ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"
msgstr ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:3
#, fuzzy
msgid ""
":ref:`checkpoint_wal_threshold <cfg_checkpoint_daemon-"
"checkpoint_wal_threshold>`"
msgstr ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:5
msgid ""
"The checkpoint daemon is a fiber which is constantly running. At "
"intervals, it may make new :ref:`snapshot (.snap) files <index-"
"box_persistence>` and then may delete old snapshot files."
msgstr ""
"Демон создания контрольных точек -- это постоянно работающий файбер. "
"Периодически он может создавать :ref:`файлы снимка (.snap) <index-"
"box_persistence>`, а затем может удалять старые файлы снимка."

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:9
msgid ""
"The :ref:`checkpoint_interval <cfg_checkpoint_daemon-"
"checkpoint_interval>` and :ref:`checkpoint_count <cfg_checkpoint_daemon-"
"checkpoint_count>` configuration settings determine how long the "
"intervals are, and how many snapshots should exist before deletions "
"occur."
msgstr ""
"Настройки конфигурации :ref:`checkpoint_interval <cfg_checkpoint_daemon-"
"checkpoint_interval>` и :ref:`checkpoint_count <cfg_checkpoint_daemon-"
"checkpoint_count>` определяют длительность интервалов и количество "
"снимков, которое должно присутствовать до начала удалений."

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:16
msgid "**Tarantool garbage collector**"
msgstr "**Сборщик мусора Tarantool'а**"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:18
msgid ""
"The checkpoint daemon may activate the Tarantool garbage collector which "
"deletes old files. This garbage collector is distinct from the `Lua "
"garbage collector <https://www.lua.org/manual/5.1/manual.html#2.10>`_ "
"which is for Lua objects, and distinct from a Tarantool garbage collector"
" which specializes in :ref:`handling shard buckets <vshard-gc>`."
msgstr ""
"Демон создания контрольных точек может запустить сборщик мусора "
"Tarantool'а, который удаляет старые файлы. Такой сборщик мусора на "
"отличается от `сборщика мусора в Lua "
"<https://www.lua.org/manual/5.1/manual.html#2.10>`_, который предназначен"
" для Lua-объектов, и от сборщика мусора, который специализируется на "
":ref:`обработке блоков шарда <vshard-gc>`."

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:25
msgid ""
"If the checkpoint daemon deletes an old snapshot file, then the Tarantool"
" garbage collector will also delete any :ref:`write-ahead log (.xlog) "
"<internals-wal>` files which are older than the snapshot file and which "
"contain information that is present in the snapshot file. It will also "
"delete obsolete vinyl ``.run`` files."
msgstr ""
"Если демон создания контрольных точек удаляет старый файл снимка, сборщик"
" мусора Tarantool'а также удалит любые файлы :ref:`журнала упреждающей "
"записи (.xlog) <internals-wal>` старше файла снимка, содержащие "
"информацию, которая присутствует в файле снимка. Он также удаляет "
"устаревшие файлы ``.run`` в vinyl'е."

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:31
msgid ""
"The checkpoint daemon and the Tarantool garbage collector will not delete"
" a file if:"
msgstr ""
"Демон создания контрольных точек и сборщик мусора Tarantool'а **не "
"удалят** файл, если:"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:33
msgid ""
"a **backup** is ongoing and the file has not been backed up (see "
":ref:`\"Hot backup\" <admin-backups-hot_backup_vinyl_memtx>`), or"
msgstr ""
"идет **резервное копирование**, и файл еще не был скопирован (см. "
":ref:`\"Резервное копирование\" <admin-backups-hot_backup_vinyl_memtx>`),"
" или"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:36
msgid ""
"**replication** is ongoing and the file has not been relayed to a replica"
" (see :ref:`\"Replication architecture\" <replication-architecture>`),"
msgstr ""
"идет **репликация**, и файл еще не был передан на реплику (см. "
":ref:`\"Архитектуру механизма репликации\" <replication-architecture>`),"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:39
msgid "a replica is connecting, or"
msgstr "реплика подключается, или"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:41
msgid ""
"a replica has fallen behind. The progress of each replica is tracked; if "
"a replica's position is far from being up to date, then the server stops "
"to give it a chance to catch up. If an administrator concludes that a "
"replica is permanently down, then the correct procedure is to restart the"
" server, or (preferably) :ref:`remove the replica from the cluster "
"<replication-remove_instances>`."
msgstr ""
"реплика отстает. Ход выполнения на каждой реплике отслеживается. Если "
"реплика далеко не актуальна, сервер останавливается, чтобы она могла "
"обновиться. Если администратор делает вывод, что реплика окончательно "
"недоступна, необходимо перезагрузить сервер или же (предпочтительно) "
":ref:`удалить реплику из кластера <replication-remove_instances>`."

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:53
msgid ""
"The interval between actions by the checkpoint daemon, in seconds. If "
"``checkpoint_interval`` is set to a value greater than zero, and there is"
" activity which causes change to a database, then the checkpoint daemon "
"will call :ref:`box.snapshot <box-snapshot>` every "
"``checkpoint_interval`` seconds, creating a new snapshot file each time. "
"If ``checkpoint_interval`` is set to zero, then the checkpoint daemon is "
"disabled."
msgstr ""
"Промежуток времени между действиями демона создания контрольных точек в "
"секундах. Если значение параметра ``checkpoint_interval`` больше нуля, и "
"выполняется изменение базы данных, то демон создания контрольных точек "
"будет вызывать :ref:`box.snapshot <box-snapshot>` каждые "
"``checkpoint_interval`` секунд, каждый раз создавая новый файл снимка. "
"Если значение параметра ``checkpoint_interval`` равно нулю, то демон "
"создания контрольных точек отключен."

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:60
#: ../doc/reference/reference_lua/box_error.rst:70
#: ../doc/reference/reference_lua/digest.rst:235
#: ../doc/reference/reference_rock/dbms.rst:82
#: ../doc/reference/reference_rock/dbms.rst:435
#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:452
#: ../doc/reference/reference_sql/sql.rst:1125
#: ../doc/reference/reference_sql/sql.rst:2172
msgid "For example:"
msgstr "Пример:"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:62
msgid "box.cfg{checkpoint_interval=60}"
msgstr "box.cfg{checkpoint_interval=60}"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:66
msgid ""
"will cause the checkpoint daemon to create a new database snapshot once "
"per minute, if there is activity."
msgstr ""
"приведет к созданию нового снимка базы данных демоном создания "
"контрольных точек каждую минуту, если наблюдается активность в базе "
"данных."

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:70
msgid "Default: 3600 (one hour)"
msgstr "По умолчанию: 3600 (один час)"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:77
msgid ""
"The maximum number of snapshots that may exist on the :ref:`memtx_dir "
"<cfg_basic-memtx_dir>` directory before the checkpoint daemon will delete"
" old snapshots. If ``checkpoint_count`` equals zero, then the checkpoint "
"daemon does not delete old snapshots. For example:"
msgstr ""
"Максимальное количество снимков, которые могут находиться в директории "
":ref:`memtx_dir <cfg_basic-memtx_dir>` до того, как демон создания "
"контрольных точек будет удалять старые снимки. Если значение "
"``checkpoint_count`` равно нулю, то демон создания контрольных точек не "
"удаляет старые снимки. Например:"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:83
msgid ""
"box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"
msgstr ""
"box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:90
msgid ""
"will cause the checkpoint daemon to create a new snapshot each hour until"
" it has created ten snapshots. After that, it will delete the oldest "
"snapshot (and any associated write-ahead-log files) after creating a new "
"one."
msgstr ""
"заставит демон создания контрольных точек создавать снимок каждый час до "
"тех пор, пока не будет создано десять снимков. Затем самый старый снимок "
"удаляется (а также любые связанные с ним WAL-файлы) после создания нового"
" снимка."

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:94
msgid ""
"Remember that, as noted earlier, snapshots will not be deleted if "
"replication is ongoing and the file has not been relayed to a replica. "
"Therefore ``checkpoint_count`` has no effect unless all replicas are "
"alive."
msgstr ""
"Следует помнить, что как упоминалось выше, снимки не удаляются, если "
"выполняется репликация, и файл еще не был передан на реплику. Таким "
"образом, параметр ``checkpoint_count`` бесполезен, если какая-то реплика "
"неактивна."

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:106
msgid ""
"The threshold for the total size in bytes of all WAL files created since "
"the last checkpoint. Once the configured threshold is exceeded, the WAL "
"thread notifies the checkpoint daemon that it must make a new checkpoint "
"and delete old WAL files."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:111
msgid "Default: 10^18 (a large number so in effect there is no limit by default)"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:114
msgid ""
"This parameter was added in version 2.1. It enables administrators to "
"handle a problem that could occur with calculating how much disk space to"
" allocate for a partition containing WAL files. For example, suppose "
":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>` = "
"2 and :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>` = "
"5 and the average amount that Tarantool writes between each checkpoint "
"interval = 1 GB. Then one could calculate that the necessary amount is "
"(2*5*1) 10GB. But this calculation would be wrong if, instead of writing "
"1 GB during one checkpoint interval, Tarantool encounters an unusual "
"spike and tries to write 11 GB, causing an operating-system ENOSPC (\"no "
"space\") error. By setting checkpoint_wal_threshold to a lower value, say"
" 9 GB, an administrator could prevent the error."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:1
msgid ":ref:`memtx_memory <cfg_storage-memtx_memory>`"
msgstr ":ref:`memtx_memory <cfg_storage-memtx_memory>`"

#: ../doc/reference/configuration/cfg_storage.rst:2
msgid ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
msgstr ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"

#: ../doc/reference/configuration/cfg_storage.rst:3
msgid ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"
msgstr ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"

#: ../doc/reference/configuration/cfg_storage.rst:4
msgid ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"
msgstr ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"

#: ../doc/reference/configuration/cfg_storage.rst:5
msgid ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"
msgstr ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"

#: ../doc/reference/configuration/cfg_storage.rst:6
msgid ":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`"
msgstr ":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`"

#: ../doc/reference/configuration/cfg_storage.rst:7
msgid ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"
msgstr ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"

#: ../doc/reference/configuration/cfg_storage.rst:8
msgid ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"
msgstr ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"

#: ../doc/reference/configuration/cfg_storage.rst:9
msgid ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"
msgstr ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"

#: ../doc/reference/configuration/cfg_storage.rst:10
msgid ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"
msgstr ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"

#: ../doc/reference/configuration/cfg_storage.rst:11
msgid ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"
msgstr ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"

#: ../doc/reference/configuration/cfg_storage.rst:12
msgid ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"
msgstr ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"

#: ../doc/reference/configuration/cfg_storage.rst:13
msgid ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"
msgstr ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"

#: ../doc/reference/configuration/cfg_storage.rst:19
msgid ""
"How much memory Tarantool allocates to actually store tuples, in bytes. "
"When the limit is reached, :ref:`INSERT <box_space-insert>` or "
":ref:`UPDATE <box_space-insert>` requests begin failing with error "
":errcode:`ER_MEMORY_ISSUE`. The server does not go beyond the "
"``memtx_memory`` limit to allocate tuples, but there is additional memory"
" used to store indexes and connection information. Depending on actual "
"configuration and workload, Tarantool can consume up to 20% more than the"
" ``memtx_memory`` limit."
msgstr ""
"Количество памяти, которое Tarantool выделяет для фактического хранения "
"кортежей, **в гигабайтах**. При достижении предельного значения запросы "
"вставки INSERT или обновления UPDATE выполняться не будут, выдавая ошибку"
" :errcode:`ER_MEMORY_ISSUE`. Сервер не выходит за установленный предел "
"памяти ``memtx_memory`` при распределении кортежей, но есть "
"дополнительная память, которая используется для хранения индексов и "
"информации о подключении. В зависимости от рабочей конфигурации и "
"загрузки, Tarantool может потреблять на 20% больше установленного "
"предела."

#: ../doc/reference/configuration/cfg_storage.rst:29
#, fuzzy
msgid "Default: 256 * 1024 * 1024 = 268435456"
msgstr "По умолчанию: 268435456 (256 * 1024 * 1024)"

#: ../doc/reference/configuration/cfg_storage.rst:30
#: ../doc/reference/configuration/cfg_storage.rst:103
msgid "Dynamic: **yes** but it cannot be decreased"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:36
msgid ""
"Size of the largest allocation unit, in bytes, for the memtx storage "
"engine. It can be increased if it is necessary to store large tuples. See"
" also: :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:42
#: ../doc/reference/configuration/cfg_storage.rst:92
msgid "Default: 1024 * 1024 = 1048576"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:49
msgid ""
"Size of the smallest allocation unit, in bytes. It can be decreased if "
"most of the tuples are very small. The value must be between 8 and "
"1048280 inclusive."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:54
#, fuzzy
msgid "Default: 16"
msgstr "По умолчанию: 1"

#: ../doc/reference/configuration/cfg_storage.rst:61
msgid ""
"Bloom filter false positive rate -- the suitable probability of the "
"`bloom filter <https://en.wikipedia.org/wiki/Bloom_filter>`_ to give a "
"wrong result. The ``vinyl_bloom_fpr`` setting is a default value for one "
"of the options in the :ref:`Options for space_object:create_index() "
"<box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:68
#, fuzzy
msgid "Default = 0.05"
msgstr "По умолчанию: 0.5"

#: ../doc/reference/configuration/cfg_storage.rst:75
msgid ""
"The cache size for the vinyl storage engine, in bytes. The cache can be "
"resized dynamically."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:79
#: ../doc/reference/configuration/cfg_storage.rst:102
msgid "Default = 128 * 1024 * 1024 = 134217728"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:86
msgid ""
"Size of the largest allocation unit, in bytes, for the vinyl storage "
"engine. It can be increased if it is necessary to store large tuples. See"
" also: :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:99
#, fuzzy
msgid "The maximum number of in-memory bytes that vinyl uses."
msgstr "максимальное количество показываемых сегментов"

#: ../doc/reference/configuration/cfg_storage.rst:109
msgid ""
"Page size, in bytes. Page is a read/write unit for vinyl disk operations."
" The ``vinyl_page_size`` setting is a default value for one of the "
"options in the :ref:`Options for space_object:create_index() <box_space-"
"create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:114
#, fuzzy
msgid "Default = 8 * 1024 = 8192"
msgstr "По умолчанию: 268435456 (256 * 1024 * 1024)"

#: ../doc/reference/configuration/cfg_storage.rst:121
msgid ""
"The default maximum range size for a vinyl index, in bytes. The maximum "
"range size affects the decision whether to :ref:`split <engines-"
"vinyl_split>` a range."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:125
#, fuzzy
msgid ""
"If ``vinyl_range_size`` is not nil and not 0, then it is used as the "
"default value for the ``range_size`` option in the :ref:`Options for "
"space_object:create_index() <box_space-create_index>` chart."
msgstr ""
"Если ``vinyl_range_size`` содержит не нулевое значение nil и не 0, это "
"значение используется в качестве значения по умолчанию для параметра "
"``range_size`` в таблице :ref:`Параметры space_object:create_index() "
"<box_space-create_index>`."

#: ../doc/reference/configuration/cfg_storage.rst:130
msgid ""
"If ``vinyl_range_size`` is nil or 0, and ``range_size`` is not specified "
"when the index is created, then Tarantool sets a value later depending on"
" performance considerations. To see the actual value, use "
":ref:`index_object:stat().range_size <box_index-stat>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:135
msgid ""
"In Tarantool versions prior to 1.10.2, ``vinyl_range_size`` default value"
" was 1073741824."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:138
#, fuzzy
msgid "Default = nil"
msgstr "По умолчанию: null"

#: ../doc/reference/configuration/cfg_storage.rst:145
msgid ""
"The maximal number of runs per level in vinyl LSM tree. If this number is"
" exceeded, a new level is created. The ``vinyl_run_count_per_level`` "
"setting is a default value for one of the options in the :ref:`Options "
"for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:151
#: ../doc/reference/configuration/cfg_storage.rst:185
#, fuzzy
msgid "Default = 2"
msgstr "По умолчанию: 2"

#: ../doc/reference/configuration/cfg_storage.rst:158
msgid ""
"Ratio between the sizes of different levels in the LSM tree. The "
"``vinyl_run_size_ratio`` setting is a default value for one of the "
"options in the :ref:`Options for space_object:create_index() <box_space-"
"create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:163
#, fuzzy
msgid "Default = 3.5"
msgstr "По умолчанию: 0.5"

#: ../doc/reference/configuration/cfg_storage.rst:170
#, fuzzy
msgid ""
"The maximum number of read threads that vinyl can use for some concurrent"
" operations, such as I/O and compression."
msgstr ""
"Максимальное количество потоков записи, которые vinyl может использовать "
"в одновременных операциях, такие как ввод-вывод и компрессия."

#: ../doc/reference/configuration/cfg_storage.rst:174
#, fuzzy
msgid "Default = 1"
msgstr "По умолчанию: 1"

#: ../doc/reference/configuration/cfg_storage.rst:181
msgid ""
"The maximum number of write threads that vinyl can use for some "
"concurrent operations, such as I/O and compression."
msgstr ""
"Максимальное количество потоков записи, которые vinyl может использовать "
"в одновременных операциях, такие как ввод-вывод и компрессия."

#: ../doc/reference/configuration/index.rst:5
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:5
msgid "Configuration reference"
msgstr "Справочник по настройке"

#: ../doc/reference/configuration/index.rst:7
msgid ""
"This reference covers all options and parameters which can be set for "
"Tarantool on the command line or in an :ref:`initialization file <index-"
"init_label>`."
msgstr ""
"В данном справочнике рассматриваются все опции и параметры, которые можно"
" использовать в командной строке или в :ref:`файле инициализации <index-"
"init_label>`."

#: ../doc/reference/configuration/index.rst:10
msgid "Tarantool is started by entering either of the following command:"
msgstr "Tarantool можно запустить путем ввода одной из следующих команд:"

#: ../doc/reference/configuration/index.rst:49
msgid ""
"$ **tarantool**\n"
"\n"
"$ **tarantool** *options*\n"
"\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""
"$ **tarantool**\n"
"\n"
"$ **tarantool** *options*\n"
"\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"

#: ../doc/reference/configuration/index.rst:23
msgid "Command options"
msgstr "Опции командной строки"

#: ../doc/reference/configuration/index.rst:27
msgid "Print an annotated list of all available options and exit."
msgstr "Вывод аннотированного списка всех доступных опций и выход."

#: ../doc/reference/configuration/index.rst:33
msgid "Print product name and version, for example:"
msgstr "Вывод названия и версии продукта, например:"

#: ../doc/reference/configuration/index.rst:35
msgid ""
"$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""
"$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."

#: ../doc/reference/configuration/index.rst:42
#: ../doc/reference/reference_sql/sql.rst:2282
msgid "In this example:"
msgstr "В данном примере:"

#: ../doc/reference/configuration/index.rst:44
msgid ""
"“Tarantool” is the name of the reusable asynchronous networking "
"programming framework."
msgstr ""
"“Tarantool” -- это название многократно используемого асинхронного "
"сетевого фреймворка."

#: ../doc/reference/configuration/index.rst:47
msgid ""
"The 3-number version follows the standard ``<major>-<minor>-<patch>`` "
"scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` "
"is incremented for each new milestone and indicates possible incompatible"
" changes, and ``<patch>`` stands for the number of bug fix releases made "
"after the start of the milestone. For non-released versions only, there "
"may be a commit number and commit SHA1 to indicate how much this "
"particular build has diverged from the last release."
msgstr ""
"Версия из 3 чисел создается по стандартной схеме "
"``<мажорная>-<минорная>-<патч-версия>``, где ``<мажорная>`` версия "
"изменяется редко, ``<минорная>`` последовательно увеличивается с каждым "
"новым выпущенным стабильным релизом и указывает на возможные "
"несовместимые изменения, а ``<патч-версия>`` означает количество версий с"
" исправленными ошибками с момента выхода стабильного релиза. Еще не "
"вышедшие версии могут также содержать номер коммита и коммит SHA1, чтобы "
"показать, насколько данная сборка отходит от последнего релиза."

#: ../doc/reference/configuration/index.rst:55
msgid ""
"“Target” is the platform tarantool was built on. Some platform-specific "
"details may follow this line."
msgstr ""
"“Target” -- это платформа, на которой собран Tarantool. Некоторые "
"платформенно-зависимые детали могут следовать за этой строкой."

#: ../doc/reference/configuration/index.rst:60
msgid ""
"Tarantool uses `git describe "
"<http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_ to "
"produce its version id, and this id can be used at any time to check out "
"the corresponding source from our `git repository "
"<http://github.com/tarantool/tarantool.git>`_."
msgstr ""
"При выставлении номера версии Tarantool'а применяется `git describe "
"<http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_, и "
"этот номер версии можно в любое время использовать для проверки "
"соответствующего исходного кода в `репозитории git "
"<http://github.com/tarantool/tarantool.git>`_."

#: ../doc/reference/configuration/index.rst:70
msgid "URI"
msgstr "Унифицированный идентификатор ресурса (URI)"

#: ../doc/reference/configuration/index.rst:72
msgid ""
"Some configuration parameters and some functions depend on a URI, or "
"\"Universal Resource Identifier\". The URI string format is similar to "
"the `generic syntax for a URI schema "
"<http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So it may "
"contain (in order) a user name for login, a password, a host name or host"
" IP address, and a port number. Only the port number is always mandatory."
" The password is mandatory if the user name is specified, unless the user"
" name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or "
"``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or "
"'[::]' is assumed, meaning respectively any IPv4 address or any IPv6 "
"address, on the local machine. If username:password is omitted, then "
"'guest' is assumed. Some examples:"
msgstr ""
"Некоторые конфигурационные параметры и некоторые функции зависимы от URI "
"(унифицированного идентификатора ресурса). Формат URI-строки похож на "
"`общий синтаксис URI-схемы "
"<http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. Он может "
"содержать следующие данные (указаны по порядку): имя пользователя для "
"входа в систему, пароль, имя хоста или IP-адрес хоста и номер порта. "
"Обязательным параметром является только номер порта. Пароль является "
"обязательным, только если указано имя пользователя -- за исключением "
"случаев, когда пользователем будет 'guest'. Формально URI-синтаксис "
"представляет собой ``[хост:]порт`` или "
"``[имя-пользователя:пароль@]хост:порт``. Если хост не указан, то "
"предполагается хост '0.0.0.0' или '[::]', что означает любой IPv4-адрес "
"или IPv6-адрес на локальной машине соответственно. Если не указать "
"имя-пользователя:пароль, предполагается, что пользователем будет 'guest'."
" Некоторые примеры:"

#: ../doc/reference/configuration/index.rst:91
msgid "URI fragment"
msgstr "Фрагмент URI"

#: ../doc/reference/configuration/index.rst:91
#: ../doc/reference/reference_lua/digest.rst:361
#: ../doc/reference/reference_lua/fiber.rst:748
#: ../doc/reference/reference_lua/fiber.rst:945
#: ../doc/reference/reference_lua/fiber.rst:1074
#: ../doc/reference/reference_lua/log.rst:144
#: ../doc/reference/reference_lua/msgpack.rst:172
#: ../doc/reference/reference_lua/net_box.rst:636
#: ../doc/reference/reference_lua/tap.rst:348
#: ../doc/reference/reference_lua/uuid.rst:132
#: ../doc/reference/reference_lua/yaml.rst:68
#: ../doc/reference/reference_rock/dbms.rst:249
#: ../doc/reference/reference_rock/dbms.rst:590
msgid "Example"
msgstr "Пример"

#: ../doc/reference/configuration/index.rst:93
msgid "port"
msgstr "порт"

#: ../doc/reference/configuration/index.rst:93
msgid "3301"
msgstr "3301"

#: ../doc/reference/configuration/index.rst:95
msgid "host:port"
msgstr "хост:порт"

#: ../doc/reference/configuration/index.rst:95
msgid "127.0.0.1:3301"
msgstr "127.0.0.1:3301"

#: ../doc/reference/configuration/index.rst:97
msgid "username:password@host:port"
msgstr "имя-пользователя:пароль@хост:порт"

#: ../doc/reference/configuration/index.rst:97
msgid "notguest:sesame@mail.ru:3301"
msgstr "notguest:sesame@mail.ru:3301"

#: ../doc/reference/configuration/index.rst:100
msgid ""
"In certain circumstances a Unix domain socket may be used where a URI is "
"expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply "
"\"/tmp/unix_domain_socket.sock\"."
msgstr ""
"В определенных обстоятельствах можно использовать доменный сокет Unix, "
"когда ожидается URI, например, ``unix/:/tmp/unix_domain_socket.sock`` или"
" просто ``/tmp/unix_domain_socket.sock``."

#: ../doc/reference/configuration/index.rst:104
msgid "A method for parsing URIs is illustrated in :ref:`Module uri <uri-parse>`."
msgstr ""
"Метод разбора URI проиллюстрирован в справочнике по :ref:`модулю uri "
"<uri-parse>`."

#: ../doc/reference/configuration/index.rst:110
msgid "Initialization file"
msgstr "Файл инициализации"

#: ../doc/reference/configuration/index.rst:112
msgid ""
"If the command to start Tarantool includes :codeitalic:`lua-"
"initialization-file`, then Tarantool begins by invoking the Lua program "
"in the file, which by convention may have the name \"``script.lua``\". "
"The Lua program may get further arguments from the command line or may "
"use operating-system functions, such as ``getenv()``. The Lua program "
"almost always begins by invoking ``box.cfg()``, if the database server "
"will be used or if ports need to be opened. For example, suppose "
"``script.lua`` contains the lines"
msgstr ""
"Если команда запуска Tarantool'а включает в себя :codeitalic:`файл "
"инициализации`, то Tarantool запустится посредством вызова Lua-программы "
"из этого файла, который обычно называется \"``script.lua``\". В "
"Lua-программу можно добавить дополнительные аргументы из командной строки"
" или функции операционной системы, такие как ``getenv()``. Lua-программа "
"практически всегда запускается посредством вызова ``box.cfg()``, если "
"будет использоваться сервер базы данных или же необходимо открыть порты. "
"Например, предположим, что файл ``script.lua`` содержит строки:"

#: ../doc/reference/configuration/index.rst:120
msgid ""
"#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    memtx_memory        = 100000,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""
"#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"   listen              = os.getenv(\"LISTEN_URI\"),\n"
"   memtx_memory        = 100000,\n"
"   pid_file            = \"tarantool.pid\",\n"
"   rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"

#: ../doc/reference/configuration/index.rst:131
msgid ""
"and suppose the environment variable LISTEN_URI contains 3301, and "
"suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``."
" Then the screen might look like this:"
msgstr ""
"и предположим, что переменная окружения LISTEN_URI содержит значение "
"3301, а также предположим, что в командной строке "
"``~/tarantool/src/tarantool script.lua ARG``. Тогда вывод на экране может"
" выглядеть следующим образом:"

#: ../doc/reference/configuration/index.rst:135
msgid ""
"$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""
"$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared "
"arena...... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from "
"'./00000000000000000000.snap'... main/101/script.lua I> primary: bound to"
" 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"

#: ../doc/reference/configuration/index.rst:149
msgid ""
"If you wish to start an interactive session on the same terminal after "
"initialization is complete, you can use :ref:`console.start() <console-"
"start>`."
msgstr ""
"Если необходимо начать интерактивную сессию на том же терминале по "
"окончании инициализации, можно использовать :ref:`console.start() "
"<console-start>`."

#: ../doc/reference/configuration/index.rst:165
msgid "Configuration parameters"
msgstr "Конфигурационные параметры"

#: ../doc/reference/configuration/index.rst:167
msgid "Configuration parameters have the form:"
msgstr "Конфигурационные параметры выглядят так:"

#: ../doc/reference/configuration/index.rst:169
msgid ":extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""
":extsamp:`{**{box.cfg}**}{[{*{ключ = значение}*} [, {*{ключ = значение "
"...}*}]]}`"

#: ../doc/reference/configuration/index.rst:171
msgid ""
"Since ``box.cfg`` may contain many configuration parameters and since "
"some of the parameters (such as directory addresses) are semi-permanent, "
"it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is "
"the initialization file which is specified on the tarantool command line."
msgstr ""
"Поскольку в ``box.cfg`` может быть множество конфигурационных параметров,"
" а некоторые параметры (такие как адреса директорий) являются "
"полупостоянными, лучше всего хранить ``box.cfg`` в Lua-файле. Как "
"правило, такой Lua-файл представляет собой файл инициализации, который "
"указан в командной строке Tarantool'а."

#: ../doc/reference/configuration/index.rst:176
msgid ""
"Most configuration parameters are for allocating resources, opening "
"ports, and specifying database behavior. All parameters are optional. A "
"few parameters are dynamic, that is, they can be changed at runtime by "
"calling ``box.cfg{}`` a second time."
msgstr ""
"Большинство конфигурационных параметров предназначены для распределения "
"ресурсов, открытия портом и указания поведения базы данных. Все параметры"
" необязательны. Некоторые параметры динамичны, то есть могут изменяться "
"во время исполнения кода посредством повторного вызова ``box.cfg{}``."

#: ../doc/reference/configuration/index.rst:181
msgid ""
"To see all the non-null parameters, say ``box.cfg`` (no parentheses). To "
"see a particular parameter, for example the listen address, say "
"``box.cfg.listen``."
msgstr ""
"Чтобы увидеть все ненулевые параметры, выполните ``box.cfg`` (без круглых"
" скобок). Чтобы увидеть определенный параметр, например, адрес для "
"прослушивания, выполните команду ``box.cfg.listen``."

#: ../doc/reference/configuration/index.rst:184
msgid ""
"The following sections describe all parameters for basic operation, for "
"storage, for binary logging and snapshots, for replication, for "
"networking, for logging, and for feedback."
msgstr ""
"В последующих разделах описаны все параметры для основных возможностей, "
"для хранения, для записи в бинарный журнал и создания снимков, для "
"репликации, для работы по сети, для журналирования и для обратной связи."

#: ../doc/reference/configuration/index.rst:190
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:11
msgid "Basic parameters"
msgstr "Базовые параметры"

#: ../doc/reference/configuration/index.rst:196
msgid "Configuring the storage"
msgstr "Настройка хранения"

#: ../doc/reference/configuration/index.rst:204
msgid "Checkpoint daemon"
msgstr "Демон создания контрольных точек"

#: ../doc/reference/configuration/index.rst:210
msgid "Binary logging and snapshots"
msgstr "Записи в бинарный журнал и создание снимков"

#: ../doc/reference/configuration/index.rst:218
msgid "Hot standby"
msgstr "Горячее резервирование"

#: ../doc/reference/configuration/index.rst:224
msgid "Replication"
msgstr "Репликация"

#: ../doc/reference/configuration/index.rst:230
msgid "Networking"
msgstr "Работа с сетями"

#: ../doc/reference/configuration/index.rst:236
msgid "Logging"
msgstr "Запись в журнал"

#: ../doc/reference/configuration/index.rst:242
msgid "Deprecated parameters"
msgstr "Устаревшие параметры"

#: ../doc/reference/index.rst:5
msgid "Reference"
msgstr "Справочники"

#: ../doc/reference/interactive_console.rst:5
#, fuzzy
msgid "Interactive console"
msgstr "Запуск консоли"

#: ../doc/reference/interactive_console.rst:7
msgid ""
"The \"interactive console\" is Tarantool's basic \"command-line "
"interface\" for entering requests and seeing results. It is what users "
"see when they start the server without an :ref:`instance file <admin-"
"instance_file>`, or start :ref:`tarantoolctl <tarantoolctl>` with "
"``enter``. It is often called the Lua console to distinguish it from the "
"administrative console, but in fact it can handle both Lua and SQL input."
" The majority of examples in this manual show what users see with the "
"interactive console, including the prompt (which can be \"tarantool> \"),"
" the instruction (which can be a Lua request or an SQL statement), and "
"the response (which can be a display in either YAML format or Lua "
"format)."
msgstr ""

#: ../doc/reference/interactive_console.rst:18
msgid ""
"-- Typical interactive console example with Lua input and YAML output\n"
"tarantool> box.info().replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: a5d22f66-2d28-4a35-b78f-5bf73baf6c8a\n"
"    lsn: 0\n"
"..."
msgstr ""

#: ../doc/reference/interactive_console.rst:29
msgid ""
"The **input language** can be changed to SQL with ``\\set language sql`` "
"or changed to Lua (the default) with ``\\set language lua``."
msgstr ""

#: ../doc/reference/interactive_console.rst:32
msgid ""
"The **delimiter** can be changed to any character with :samp:`\\set "
"delimiter <character>`. The default is nothing, which means input does "
"not need to end with a delimiter. But a common recommendation is to say "
"``set delimiter ;`` especially if input is SQL."
msgstr ""

#: ../doc/reference/interactive_console.rst:38
msgid ""
"The **output format** can be changed to Lua with ``\\set output lua`` or "
"changed to YAML (the default) with ``\\set output yaml``."
msgstr ""

#: ../doc/reference/interactive_console.rst:41
msgid ""
"Ordinarily. output from the console has `YAML format "
"<http://yaml.org/spec>`_. That means that there is a line for document-"
"start ``\"---\"``, and each item begins on a separate line starting with "
"``\"- \"``, and each sub-item in a nested structure is indented, and "
"there is a line for document-end ``\"...\"``."
msgstr ""

#: ../doc/reference/interactive_console.rst:47
msgid ""
"Optionally, output from the console can have Lua format. That means that "
"there are no lines for document-start or document-end, and items are not "
"on separate lines (they are only separated by commas), and each sub-item "
"in a nested structure is placed inside \"``{}``\" braces. So, when input "
"is a Lua object description, output will equal input."
msgstr ""

#: ../doc/reference/interactive_console.rst:53
msgid ""
"YAML is good for readability. Lua is good for re-using results as "
"requests. A third format, MsgPack, is good for database storage. "
"Currently the default output format is YAML but it may be Lua in a future"
" version, and it may be Lua if the last :ref:`set_default_output "
"<console-set_default_output>` call was "
"``console.set_default_output('lua')``."
msgstr ""

#: ../doc/reference/interactive_console.rst:69
#: ../doc/reference/reference_sql/sql.rst:426
#, fuzzy
msgid "Type"
msgstr "тип возвращаемого значения"

#: ../doc/reference/interactive_console.rst:69
msgid "Lua input"
msgstr ""

#: ../doc/reference/interactive_console.rst:69
#, fuzzy
msgid "Lua output"
msgstr "Lua-объект."

#: ../doc/reference/interactive_console.rst:69
msgid "YAML output"
msgstr ""

#: ../doc/reference/interactive_console.rst:69
msgid "MsgPack storage"
msgstr ""

#: ../doc/reference/interactive_console.rst:71
#: ../doc/reference/reference_sql/sql.rst:255
msgid "scalar"
msgstr ""

#: ../doc/reference/interactive_console.rst:71
#, fuzzy
msgid ":code:`1`"
msgstr ":codebold:`q`"

#: ../doc/reference/interactive_console.rst:71
msgid ":code:`---` |br| :code:`- 1` |br| :code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:71
#, fuzzy
msgid ":code:`\\x01`"
msgstr ":codebold:`q`"

#: ../doc/reference/interactive_console.rst:75
msgid "scalar sequence"
msgstr ""

#: ../doc/reference/interactive_console.rst:75
#, fuzzy
msgid ":code:`1,2,3`"
msgstr ":codebold:`q`"

#: ../doc/reference/interactive_console.rst:75
msgid ""
":code:`---` |br| :code:`- 1` |br| :code:`- 2` |br| :code:`- 3` |br| "
":code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:75
msgid ":code:`\\x01 \\x02 \\x03`"
msgstr ""

#: ../doc/reference/interactive_console.rst:81
msgid "2-element table"
msgstr ""

#: ../doc/reference/interactive_console.rst:81
#, fuzzy
msgid ":code:`{1,2}`"
msgstr ":codebold:`q`"

#: ../doc/reference/interactive_console.rst:81
msgid ":code:`---` |br| :code:`- - 1` |br| :code:`- - 2` |br| :code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:81
msgid ":code:`0x92 0x01 0x02`"
msgstr ""

#: ../doc/reference/interactive_console.rst:86
msgid "map"
msgstr ""

#: ../doc/reference/interactive_console.rst:86
#, fuzzy
msgid ":code:`{key=1}`"
msgstr ":codebold:`e`"

#: ../doc/reference/interactive_console.rst:86
msgid ":code:`---` |br| :code:`- key: 1` |br| :code:`...`"
msgstr ""

#: ../doc/reference/interactive_console.rst:86
msgid ":code:`\\x81 \\xa3 \\x6b \\x65 \\x79 \\x01`"
msgstr ""

#: ../doc/reference/lua_tips.rst:5
msgid "Tips on Lua syntax"
msgstr "Рекомендации по Lua-синтаксису"

#: ../doc/reference/lua_tips.rst:7
msgid ""
"The Lua syntax for :ref:`data-manipulation functions <index-box_data-"
"operations>` can vary. Here are examples of the variations with "
"``select()`` requests. The same rules exist for the other data-"
"manipulation functions."
msgstr ""
"В :ref:`функциях управления данными <index-box_data-operations>` "
"Lua-синтаксис может различаться. Далее приводятся варианты таких различий"
" на примере запросов ``select()``. Аналогичные правила существуют и для "
"остальных функций."

#: ../doc/reference/lua_tips.rst:11
msgid ""
"Every one of the examples does the same thing: select a tuple set from a "
"space named 'tester' where the primary-key field value equals 1. For "
"these examples, we assume that the numeric id of 'tester' is 512, which "
"happens to be the case in our sandbox example only."
msgstr ""
"В каждом из приведенных примеров выполняются следующие действия: "
"производится выборка по набору кортежей из спейса с именем 'tester', где "
"значение поля, которое соответствует ключу в первичном индексе, равно 1. "
"Также во всех примерах мы принимаем, что числовой идентификатор спейса "
"'tester' равен 512, но это верно только для нашей тестовой базы."

#: ../doc/reference/lua_tips.rst:20
msgid "Object reference variations"
msgstr "Способы ссылки на объект"

#: ../doc/reference/lua_tips.rst:22
msgid "First, there are three **object reference variations**:"
msgstr "Во-первых, есть три *способа ссылки на объект*:"

#: ../doc/reference/lua_tips.rst:24
msgid ""
"-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""
"-- #1 модуль.подмодуль.имя\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 заменить имя буквенной константой в квадратных скобках\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 использовать переменную для всей ссылки на объект\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"

#: ../doc/reference/lua_tips.rst:34
msgid ""
"Examples in this manual usually have the \":samp:`box.space.{tester}:`\" "
"form (#1). However, this is a matter of user preference and all the "
"variations exist in the wild."
msgstr ""
"Для примеров в документации, как правило, используется вариант синтаксиса"
" №1, например \":samp:`box.space.{tester}:`\". Но вы можете с тем же "
"успехом пользоваться любым из трех описанных выше вариантов."

#: ../doc/reference/lua_tips.rst:38
msgid ""
"Also, descriptions in this manual use the syntax \"``space_object:``\" "
"for references to objects which are spaces, and \"``index_object:``\" for"
" references to objects which are indexes (for example "
":samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""
"Также описания в руководстве используют синтаксис типа  "
"\"``space_object:``\" для ссылки на спейсы и \"``index_object:``\" для "
"ссылки на индексы (например, "
":samp:`box.space.{tester}.index.{primary}:`)."

#: ../doc/reference/lua_tips.rst:47
msgid "Parameter variations"
msgstr "Способы задания параметров"

#: ../doc/reference/lua_tips.rst:49
msgid "Then, there are seven **parameter variations**:"
msgstr "Затем есть семь *способов задания параметров*:"

#: ../doc/reference/lua_tips.rst:51
msgid ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"

#: ../doc/reference/lua_tips.rst:70
msgid ""
"Lua allows to omit parentheses ``()`` when invoking a function if its "
"only argument is a Lua table, and we use it sometimes in our examples. "
"This is why ``select{1}`` is equivalent to ``select({1})``. Literal "
"values such as ``1`` (a scalar value) or ``{1}`` (a Lua table value) may "
"be replaced by variable names, as in examples #6 and #7."
msgstr ""
"В Lua допускается пропуск круглых скобок ``()`` при вызове функции, если "
"единственным аргументом является Lua-таблица, и иногда мы этим пользуемся"
" в примерах. Вот почему ``select{1}`` аналогично ``select({1})``. "
"Литеральные значения, такие как ``1`` (скалярное значение) или ``{1}`` "
"(значение Lua-таблицы), можно заменить именами переменных, ка в примерах "
"6 и 7."

#: ../doc/reference/lua_tips.rst:76
msgid ""
"Although there are special cases where braces can be omitted, they are "
"preferable because they signal \"Lua table\". Examples and descriptions "
"in this manual have the ``{1}`` form. However, this too is a matter of "
"user preference and all the variations exist in the wild."
msgstr ""
"Хотя есть особые случаи, когда фигурные скобки можно опустить, "
"рекомендуется использовать их, потому что они означают Lua-таблицу. В "
"примерах и описаниях данного руководства применяется форма ``{1}``. "
"Однако это тоже вопрос предпочтений пользователя, и на практике применимы"
" все варианты."

#: ../doc/reference/lua_tips.rst:85
msgid "Rules for object names"
msgstr "Правила именования объектов"

#: ../doc/reference/lua_tips.rst:87
msgid ""
"Database objects have loose **rules for names**: the maximum length is "
"65000 bytes (not characters), and almost any legal Unicode character is "
"allowed, including spaces, ideograms and punctuation."
msgstr ""
"**Правила именования** объектов базы данных не слишком ограничены: "
"максимальная длина составляет 65000 байтов (не символов), допускается "
"практически любой символ Юникода, включая пробелы, идеограммы и знаки "
"пунктуации."

#: ../doc/reference/lua_tips.rst:92
msgid ""
"In those cases, to prevent confusion with Lua operators and separators, "
"object references should have the literal-in-square-brackets form (#2), "
"or the variable form (#3). For example:"
msgstr ""
"В таких случаях во избежание путаницы с операторами и разделителями в Lua"
" ссылки на объекты должны иметь форму типа литерал в квадратных скобках "
"(2) или форму переменной (3). Например:"

#: ../doc/reference/lua_tips.rst:96
msgid ""
"tarantool> box.space['1*A']:select{1}\n"
"tarantool> s = box.space['1*A !@$%^&*()_+12345678901234567890']\n"
"tarantool> s:select{1}"
msgstr ""
"tarantool> box.space['1*A']:select{1}\n"
"tarantool> s = box.space['1*A !@$%^&*()_+12345678901234567890']\n"
"tarantool> s:select{1}"

#: ../doc/reference/lua_tips.rst:102
msgid "Disallowed:"
msgstr "Не разрешаются:"

#: ../doc/reference/lua_tips.rst:104
msgid "characters which are unassigned code points,"
msgstr "символы, которые представляют собой неназначенные кодовые точки,"

#: ../doc/reference/lua_tips.rst:105
msgid "line and paragraph separators,"
msgstr "разделители строки и абзаца,"

#: ../doc/reference/lua_tips.rst:106
msgid "control characters,"
msgstr "управляющие символы,"

#: ../doc/reference/lua_tips.rst:107
msgid "the replacement character (U+FFFD)."
msgstr "символ замены (U+FFFD)."

#: ../doc/reference/lua_tips.rst:109
msgid "Not recommended: characters which cannot be displayed."
msgstr "Не рекомендуются: символы, которые не отображаются."

#: ../doc/reference/lua_tips.rst:111
msgid "Names are \"case sensitive\", so 'A' and 'a' are not the same."
msgstr "Имена зависимы от регистра, поэтому 'A' и 'a' -- это не одно и то же."

#: ../doc/reference/reference_lua/box.rst:5
msgid "Module `box`"
msgstr "Модуль `box`"

#: ../doc/reference/reference_lua/box.rst:7
msgid ""
"As well as executing Lua chunks or defining your own functions, you can "
"exploit Tarantool's storage functionality with the ``box`` module and its"
" submodules."
msgstr ""
"Помимо выполнения фрагментов кода на Lua или определения собственных "
"функций, с помощью модуля ``box`` и вложенных модулей можно использовать "
"функции хранилища Tarantool'а."

#: ../doc/reference/reference_lua/box.rst:10
msgid ""
"Every submodule contains one or more Lua functions. A few submodules "
"contain members as well as functions. The functions allow data definition"
" (create alter drop), data manipulation (insert delete update upsert "
"select replace), and introspection (inspecting contents of spaces, "
"accessing server configuration)."
msgstr ""
"Каждый вложенный модуль включает в себя одну или более Lua-функций. "
"Несколько вложенных модулей включают в себя элементы класса, а также "
"функции. Функции обеспечивают определение данных (create alter drop), "
"управление данными (insert delete update upsert select replace) и "
"просмотр состояния (просмотр содержимого спейсов, получение доступа к "
"конфигурации сервера)."

#: ../doc/reference/reference_lua/box.rst:15
msgid ""
"To catch errors that functions in ``box`` submodules may throw, use "
":ref:`pcall <error_handling>`."
msgstr ""
"Чтобы найти ошибки, которые могут выдать вложенные модули ``box``, "
"используйте :ref:`pcall <error_handling>`."

#: ../doc/reference/reference_lua/box.rst:17
msgid ""
"The contents of the ``box`` module can be inspected at runtime with "
"``box``, with no arguments. The ``box`` module contains:"
msgstr ""
"Содержимое модуля ``box`` можно просмотреть во время исполнения кода с "
"помощью команды ``box`` без аргументов. Модуль ``box`` включает в себя "
"следующее:"

#: ../doc/reference/reference_lua/box_backup.rst:3
msgid "Submodule box.backup"
msgstr "Вложенный модуль `box.backup`"

#: ../doc/reference/reference_lua/box_backup.rst:5
msgid ""
"The box.backup submodule contains two functions that are helpful for "
":ref:`backup <admin-backups>` in certain situations."
msgstr ""
"Модуль ``box.backup`` содержит две функции, которые помогают при работе с"
" :ref:`резервированным копированием <admin-backups>`."

#: ../doc/reference/reference_lua/box_backup.rst:12
msgid ""
"Informs the server that activities related to the removal of outdated "
"backups must be suspended."
msgstr ""
"Оповещает сервер о том, что следует приостановить все активности, "
"связанные с удалением устаревших резервных копий."

#: ../doc/reference/reference_lua/box_backup.rst:15
msgid ""
"To guarantee an opportunity to copy these files, Tarantool will not "
"delete them. But there will be no read-only mode and checkpoints will "
"continue by schedule as usual."
msgstr ""
"Чтобы гарантировать возможность скопировать эти файлы, Tarantool не "
"станет их удалять. При этом он не переходит в режим read-only, и создание"
" контрольных точек делается по расписанию, как обычно."

#: ../doc/reference/reference_lua/box_backup.rst
#: ../doc/reference/reference_lua/box_error.rst
#: ../doc/reference/reference_lua/box_once.rst
#: ../doc/reference/reference_lua/clock.rst
#: ../doc/reference/reference_lua/console.rst
#: ../doc/reference/reference_lua/csv.rst
#: ../doc/reference/reference_lua/debug_facilities.rst
#: ../doc/reference/reference_lua/errno.rst
#: ../doc/reference/reference_lua/fiber.rst
#: ../doc/reference/reference_lua/fio.rst
#: ../doc/reference/reference_lua/http.rst
#: ../doc/reference/reference_lua/iconv.rst
#: ../doc/reference/reference_lua/json.rst
#: ../doc/reference/reference_lua/key_def.rst
#: ../doc/reference/reference_lua/log.rst
#: ../doc/reference/reference_lua/merger.rst
#: ../doc/reference/reference_lua/msgpack.rst
#: ../doc/reference/reference_lua/net_box.rst
#: ../doc/reference/reference_lua/osmodule.rst
#: ../doc/reference/reference_lua/other.rst
#: ../doc/reference/reference_lua/pickle.rst
#: ../doc/reference/reference_lua/socket.rst
#: ../doc/reference/reference_lua/string.rst
#: ../doc/reference/reference_lua/swim.rst
#: ../doc/reference/reference_lua/table.rst
#: ../doc/reference/reference_lua/tap.rst
#: ../doc/reference/reference_lua/uri.rst
#: ../doc/reference/reference_lua/utf8.rst
#: ../doc/reference/reference_lua/uuid.rst
#: ../doc/reference/reference_lua/yaml.rst
#: ../doc/reference/reference_rock/membership.rst
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst
msgid "Parameters"
msgstr "Параметры"

#: ../doc/reference/reference_lua/box_backup.rst:19
msgid ""
"optional argument starting with Tarantool 1.10.1 that indicates the "
"checkpoint to use relative to the latest checkpoint. For example ``n = "
"0`` means “backup will be based on the latest checkpoint”, ``n = 1`` "
"means \"backup will be based on the first checkpoint before the latest "
"checkpoint (counting backwards)\", and so on. The default value for n is "
"zero."
msgstr ""
"необязательный аргумент, начиная с Tarantool 1.10.1, который указывает "
"нужную контрольную точку относительно самой свежей точки. Например, ``n ="
" 0`` означает “резервная копия будет создана на основе самой свежей "
"контрольной точки”, ``n = 1`` означает \"резервная копия будет создана на"
" основе контрольной точки, которая была создана перед самой свежей "
"точкой\", и т.д. По умолчанию n = 0."

#: ../doc/reference/reference_lua/box_backup.rst:26
msgid ""
"**Return:**  a table with the names of snapshot and vinyl files that "
"should be copied"
msgstr ""
"**Возвращает:** таблицу с именами снапшотов и файлов vinyl, которые нужно"
" скопировать"

#: ../doc/reference/reference_lua/box_backup.rst:29
#: ../doc/reference/reference_lua/box_error.rst:80
#: ../doc/reference/reference_lua/box_error.rst:120
#: ../doc/reference/reference_lua/box_error.rst:160
#: ../doc/reference/reference_lua/box_snapshot.rst:49
#: ../doc/reference/reference_lua/buffer.rst:23
#: ../doc/reference/reference_lua/clock.rst:78
#: ../doc/reference/reference_lua/clock.rst:103
#: ../doc/reference/reference_lua/clock.rst:124
#: ../doc/reference/reference_lua/clock.rst:145
#: ../doc/reference/reference_lua/clock.rst:167
#: ../doc/reference/reference_lua/console.rst:86
#: ../doc/reference/reference_lua/console.rst:117
#: ../doc/reference/reference_lua/console.rst:142
#: ../doc/reference/reference_lua/console.rst:181
#: ../doc/reference/reference_lua/crypto.rst:71
#: ../doc/reference/reference_lua/crypto.rst:103
#: ../doc/reference/reference_lua/crypto.rst:132
#: ../doc/reference/reference_lua/csv.rst:77
#: ../doc/reference/reference_lua/csv.rst:159
#: ../doc/reference/reference_lua/csv.rst:204
#: ../doc/reference/reference_lua/errno.rst:60
#: ../doc/reference/reference_lua/fiber.rst:201
#: ../doc/reference/reference_lua/fiber.rst:240
#: ../doc/reference/reference_lua/fiber.rst:263
#: ../doc/reference/reference_lua/fiber.rst:283
#: ../doc/reference/reference_lua/fiber.rst:303
#: ../doc/reference/reference_lua/fiber.rst:318
#: ../doc/reference/reference_lua/fiber.rst:337
#: ../doc/reference/reference_lua/fiber.rst:356
#: ../doc/reference/reference_lua/fiber.rst:383
#: ../doc/reference/reference_lua/fiber.rst:409
#: ../doc/reference/reference_lua/fiber.rst:433
#: ../doc/reference/reference_lua/fiber.rst:458
#: ../doc/reference/reference_lua/fiber.rst:485
#: ../doc/reference/reference_lua/fiber.rst:508
#: ../doc/reference/reference_lua/fiber.rst:535
#: ../doc/reference/reference_lua/fiber.rst:566
#: ../doc/reference/reference_lua/fiber.rst:634
#: ../doc/reference/reference_lua/fiber.rst:684
#: ../doc/reference/reference_lua/fiber.rst:717
#: ../doc/reference/reference_lua/fiber.rst:736
#: ../doc/reference/reference_lua/fio.rst:184
#: ../doc/reference/reference_lua/fio.rst:206
#: ../doc/reference/reference_lua/fio.rst:226
#: ../doc/reference/reference_lua/fio.rst:245
#: ../doc/reference/reference_lua/fio.rst:321
#: ../doc/reference/reference_lua/fio.rst:357
#: ../doc/reference/reference_lua/fio.rst:396
#: ../doc/reference/reference_lua/fio.rst:416
#: ../doc/reference/reference_lua/fio.rst:437
#: ../doc/reference/reference_lua/fio.rst:460
#: ../doc/reference/reference_lua/fio.rst:477
#: ../doc/reference/reference_lua/fio.rst:492
#: ../doc/reference/reference_lua/fio.rst:516
#: ../doc/reference/reference_lua/fio.rst:538
#: ../doc/reference/reference_lua/fio.rst:561
#: ../doc/reference/reference_lua/fio.rst:587
#: ../doc/reference/reference_lua/fio.rst:613
#: ../doc/reference/reference_lua/fio.rst:637
#: ../doc/reference/reference_lua/fio.rst:660
#: ../doc/reference/reference_lua/fio.rst:682
#: ../doc/reference/reference_lua/fio.rst:708
#: ../doc/reference/reference_lua/fio.rst:726
#: ../doc/reference/reference_lua/fio.rst:827
#: ../doc/reference/reference_lua/fio.rst:858
#: ../doc/reference/reference_lua/fio.rst:978
#: ../doc/reference/reference_lua/fio.rst:998
#: ../doc/reference/reference_lua/fio.rst:1023
#: ../doc/reference/reference_lua/fio.rst:1044
#: ../doc/reference/reference_lua/fio.rst:1077
#: ../doc/reference/reference_lua/fio.rst:1099
#: ../doc/reference/reference_lua/http.rst:83
#: ../doc/reference/reference_lua/iconv.rst:57
#: ../doc/reference/reference_lua/iconv.rst:78
#: ../doc/reference/reference_lua/jit.rst:66
#: ../doc/reference/reference_lua/jit.rst:106
#: ../doc/reference/reference_lua/jit.rst:132
#: ../doc/reference/reference_lua/jit.rst:160
#: ../doc/reference/reference_lua/jit.rst:228
#: ../doc/reference/reference_lua/json.rst:56
#: ../doc/reference/reference_lua/json.rst:95
#: ../doc/reference/reference_lua/json.rst:126
#: ../doc/reference/reference_lua/key_def.rst:138
#: ../doc/reference/reference_lua/key_def.rst:164
#: ../doc/reference/reference_lua/key_def.rst:187
#: ../doc/reference/reference_lua/key_def.rst:212
#: ../doc/reference/reference_lua/net_box.rst:240
#: ../doc/reference/reference_lua/net_box.rst:256
#: ../doc/reference/reference_lua/net_box.rst:271
#: ../doc/reference/reference_lua/net_box.rst:312
#: ../doc/reference/reference_lua/net_box.rst:326
#: ../doc/reference/reference_lua/net_box.rst:348
#: ../doc/reference/reference_lua/net_box.rst:362
#: ../doc/reference/reference_lua/net_box.rst:376
#: ../doc/reference/reference_lua/net_box.rst:390
#: ../doc/reference/reference_lua/net_box.rst:488
#: ../doc/reference/reference_lua/net_box.rst:540
#: ../doc/reference/reference_lua/osmodule.rst:88
#: ../doc/reference/reference_lua/osmodule.rst:111
#: ../doc/reference/reference_lua/osmodule.rst:130
#: ../doc/reference/reference_lua/osmodule.rst:147
#: ../doc/reference/reference_lua/osmodule.rst:165
#: ../doc/reference/reference_lua/osmodule.rst:180
#: ../doc/reference/reference_lua/osmodule.rst:193
#: ../doc/reference/reference_lua/osmodule.rst:208
#: ../doc/reference/reference_lua/osmodule.rst:223
#: ../doc/reference/reference_lua/osmodule.rst:238
#: ../doc/reference/reference_lua/osmodule.rst:253
#: ../doc/reference/reference_lua/osmodule.rst:269
#: ../doc/reference/reference_lua/osmodule.rst:284
#: ../doc/reference/reference_lua/other.rst:52
#: ../doc/reference/reference_lua/other.rst:92
#: ../doc/reference/reference_lua/pickle.rst:91
#: ../doc/reference/reference_lua/pickle.rst:138
#: ../doc/reference/reference_lua/socket.rst:138
#: ../doc/reference/reference_lua/socket.rst:156
#: ../doc/reference/reference_lua/socket.rst:175
#: ../doc/reference/reference_lua/socket.rst:257
#: ../doc/reference/reference_lua/socket.rst:416
#: ../doc/reference/reference_lua/strict.rst:18
#: ../doc/reference/reference_lua/string.rst:78
#: ../doc/reference/reference_lua/string.rst:103
#: ../doc/reference/reference_lua/string.rst:126
#: ../doc/reference/reference_lua/string.rst:151
#: ../doc/reference/reference_lua/string.rst:181
#: ../doc/reference/reference_lua/string.rst:211
#: ../doc/reference/reference_lua/string.rst:237
#: ../doc/reference/reference_lua/string.rst:263
#: ../doc/reference/reference_lua/string.rst:293
#: ../doc/reference/reference_lua/string.rst:321
#: ../doc/reference/reference_lua/swim.rst:396
#: ../doc/reference/reference_lua/table.rst:44
#: ../doc/reference/reference_lua/tap.rst:180
#: ../doc/reference/reference_lua/tap.rst:226
#: ../doc/reference/reference_lua/tarantool.rst:20
#: ../doc/reference/reference_lua/uri.rst:65
#: ../doc/reference/reference_lua/uri.rst:92
#: ../doc/reference/reference_lua/utf8.rst:72
#: ../doc/reference/reference_lua/utf8.rst:101
#: ../doc/reference/reference_lua/utf8.rst:130
#: ../doc/reference/reference_lua/utf8.rst:154
#: ../doc/reference/reference_lua/utf8.rst:176
#: ../doc/reference/reference_lua/utf8.rst:198
#: ../doc/reference/reference_lua/utf8.rst:220
#: ../doc/reference/reference_lua/utf8.rst:252
#: ../doc/reference/reference_lua/utf8.rst:276
#: ../doc/reference/reference_lua/utf8.rst:297
#: ../doc/reference/reference_lua/utf8.rst:335
#: ../doc/reference/reference_lua/utf8.rst:357
#: ../doc/reference/reference_lua/xlog.rst:27
#: ../doc/reference/reference_rock/dbms.rst:188
#: ../doc/reference/reference_rock/dbms.rst:212
#: ../doc/reference/reference_rock/dbms.rst:236
#: ../doc/reference/reference_rock/dbms.rst:530
#: ../doc/reference/reference_rock/dbms.rst:554
#: ../doc/reference/reference_rock/dbms.rst:577
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:64
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:135
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:456
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:471
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:488
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:549
msgid "**Example:**"
msgstr "**Пример:**"

#: ../doc/reference/reference_lua/box_backup.rst:31
msgid ""
"tarantool> box.backup.start()\n"
"---\n"
"- - ./00000000000000000015.snap\n"
"  - ./00000000000000000000.vylog\n"
"  - ./513/0/00000000000000000002.index\n"
"  - ./513/0/00000000000000000002.run\n"
"..."
msgstr ""
"tarantool> box.backup.start()\n"
"---\n"
"- - ./00000000000000000015.snap\n"
"  - ./00000000000000000000.vylog\n"
"  - ./513/0/00000000000000000002.index\n"
"  - ./513/0/00000000000000000002.run\n"
"..."

#: ../doc/reference/reference_lua/box_backup.rst:45
msgid "informs the server that normal operations may resume."
msgstr "оповещает сервер о том, что можно вернуться к работе в обычном режиме."

#: ../doc/reference/reference_lua/box_error.rst:3
msgid "Submodule `box.error`"
msgstr "Вложенный модуль `box.error`"

#: ../doc/reference/reference_lua/box_error.rst:9
#: ../doc/reference/reference_lua/clock.rst:9
#: ../doc/reference/reference_lua/console.rst:9
#: ../doc/reference/reference_lua/crypto.rst:11
#: ../doc/reference/reference_lua/csv.rst:9
#: ../doc/reference/reference_lua/debug_facilities.rst:9
#: ../doc/reference/reference_lua/digest.rst:11
#: ../doc/reference/reference_lua/errno.rst:11
#: ../doc/reference/reference_lua/fiber.rst:9
#: ../doc/reference/reference_lua/fio.rst:11
#: ../doc/reference/reference_lua/http.rst:11
#: ../doc/reference/reference_lua/iconv.rst:11
#: ../doc/reference/reference_lua/jit.rst:11
#: ../doc/reference/reference_lua/json.rst:9
#: ../doc/reference/reference_lua/log.rst:11
#: ../doc/reference/reference_lua/merger.rst:9
#: ../doc/reference/reference_lua/msgpack.rst:9
#: ../doc/reference/reference_lua/net_box.rst:9
#: ../doc/reference/reference_lua/osmodule.rst:11
#: ../doc/reference/reference_lua/socket.rst:9
#: ../doc/reference/reference_lua/string.rst:9
#: ../doc/reference/reference_lua/swim.rst:9
#: ../doc/reference/reference_lua/tap.rst:7
#: ../doc/reference/reference_lua/uri.rst:7
#: ../doc/reference/reference_lua/utf8.rst:9
#: ../doc/reference/reference_lua/uuid.rst:7
#: ../doc/reference/reference_lua/yaml.rst:9
#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:11
msgid "Overview"
msgstr "Общие сведения"

#: ../doc/reference/reference_lua/box_error.rst:11
msgid ""
"The ``box.error`` function is for raising an error. The difference "
"between this function and Lua's built-in `error "
"<https://www.lua.org/pil/8.3.html>`_ function is that when the error "
"reaches the client, its error code is preserved. In contrast, a Lua error"
" would always be presented to the client as :errcode:`ER_PROC_LUA`."
msgstr ""
"Функция ``box.error`` предназначена для вызова ошибки. Разница между этой"
" функцией и встроенной Lua-функцией `error "
"<https://www.lua.org/pil/8.3.html>`_ в том, что когда клиент получает "
"ошибку, код ошибки сохраняется. В отличие от этого, ошибки в Lua всегда "
"передаются на клиент в виде :errcode:`ER_PROC_LUA`."

#: ../doc/reference/reference_lua/box_error.rst:19
#: ../doc/reference/reference_lua/clock.rst:18
#: ../doc/reference/reference_lua/console.rst:17
#: ../doc/reference/reference_lua/crypto.rst:22
#: ../doc/reference/reference_lua/csv.rst:41
#: ../doc/reference/reference_lua/debug_facilities.rst:33
#: ../doc/reference/reference_lua/digest.rst:22
#: ../doc/reference/reference_lua/errno.rst:19
#: ../doc/reference/reference_lua/fiber.rst:22
#: ../doc/reference/reference_lua/fio.rst:27
#: ../doc/reference/reference_lua/http.rst:19
#: ../doc/reference/reference_lua/iconv.rst:24
#: ../doc/reference/reference_lua/jit.rst:20
#: ../doc/reference/reference_lua/json.rst:18
#: ../doc/reference/reference_lua/log.rst:46
#: ../doc/reference/reference_lua/merger.rst:16
#: ../doc/reference/reference_lua/msgpack.rst:18
#: ../doc/reference/reference_lua/net_box.rst:71
#: ../doc/reference/reference_lua/osmodule.rst:28
#: ../doc/reference/reference_lua/pickle.rst:7
#: ../doc/reference/reference_lua/socket.rst:28
#: ../doc/reference/reference_lua/string.rst:22
#: ../doc/reference/reference_lua/tap.rst:17
#: ../doc/reference/reference_lua/uri.rst:35
#: ../doc/reference/reference_lua/uuid.rst:17
#: ../doc/reference/reference_lua/yaml.rst:16
msgid "Index"
msgstr "Указатель"

#: ../doc/reference/reference_lua/box_error.rst:21
msgid "Below is a list of all ``box.error`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``box.error``."

#: ../doc/reference/reference_lua/box_error.rst:29
#: ../doc/reference/reference_lua/clock.rst:28
#: ../doc/reference/reference_lua/console.rst:27
#: ../doc/reference/reference_lua/crypto.rst:32
#: ../doc/reference/reference_lua/csv.rst:51
#: ../doc/reference/reference_lua/debug_facilities.rst:43
#: ../doc/reference/reference_lua/digest.rst:32
#: ../doc/reference/reference_lua/errno.rst:29
#: ../doc/reference/reference_lua/fiber.rst:32
#: ../doc/reference/reference_lua/fio.rst:39
#: ../doc/reference/reference_lua/http.rst:29
#: ../doc/reference/reference_lua/iconv.rst:34
#: ../doc/reference/reference_lua/jit.rst:38
#: ../doc/reference/reference_lua/json.rst:28
#: ../doc/reference/reference_lua/log.rst:56
#: ../doc/reference/reference_lua/msgpack.rst:28
#: ../doc/reference/reference_lua/net_box.rst:81
#: ../doc/reference/reference_lua/osmodule.rst:38
#: ../doc/reference/reference_lua/other.rst:15
#: ../doc/reference/reference_lua/pickle.rst:17
#: ../doc/reference/reference_lua/socket.rst:38
#: ../doc/reference/reference_lua/string.rst:32
#: ../doc/reference/reference_lua/tap.rst:25
#: ../doc/reference/reference_lua/uri.rst:45
#: ../doc/reference/reference_lua/utf8.rst:27
#: ../doc/reference/reference_lua/uuid.rst:27
#: ../doc/reference/reference_lua/yaml.rst:26
#: ../doc/reference/reference_rock/membership.rst:78
msgid "Name"
msgstr "Имя"

#: ../doc/reference/reference_lua/box_error.rst:29
#: ../doc/reference/reference_lua/clock.rst:28
#: ../doc/reference/reference_lua/console.rst:27
#: ../doc/reference/reference_lua/crypto.rst:32
#: ../doc/reference/reference_lua/csv.rst:51
#: ../doc/reference/reference_lua/debug_facilities.rst:43
#: ../doc/reference/reference_lua/digest.rst:32
#: ../doc/reference/reference_lua/errno.rst:29
#: ../doc/reference/reference_lua/fiber.rst:32
#: ../doc/reference/reference_lua/fio.rst:39
#: ../doc/reference/reference_lua/http.rst:29
#: ../doc/reference/reference_lua/iconv.rst:34
#: ../doc/reference/reference_lua/jit.rst:38
#: ../doc/reference/reference_lua/json.rst:28
#: ../doc/reference/reference_lua/log.rst:56
#: ../doc/reference/reference_lua/msgpack.rst:28
#: ../doc/reference/reference_lua/net_box.rst:81
#: ../doc/reference/reference_lua/osmodule.rst:38
#: ../doc/reference/reference_lua/other.rst:15
#: ../doc/reference/reference_lua/pickle.rst:17
#: ../doc/reference/reference_lua/socket.rst:38
#: ../doc/reference/reference_lua/string.rst:32
#: ../doc/reference/reference_lua/tap.rst:25
#: ../doc/reference/reference_lua/uri.rst:45
#: ../doc/reference/reference_lua/utf8.rst:27
#: ../doc/reference/reference_lua/uuid.rst:27
#: ../doc/reference/reference_lua/yaml.rst:26
#: ../doc/reference/reference_rock/membership.rst:78
msgid "Use"
msgstr "Назначение"

#: ../doc/reference/reference_lua/box_error.rst:31
msgid ":ref:`box.error() <box_error-error>`"
msgstr ":ref:`box.error() <box_error-error>`"

#: ../doc/reference/reference_lua/box_error.rst:31
msgid "Throw an error"
msgstr "Вызов ошибки"

#: ../doc/reference/reference_lua/box_error.rst:34
msgid ":ref:`box.error.last() <box_error-last>`"
msgstr ":ref:`box.error.last() <box_error-last>`"

#: ../doc/reference/reference_lua/box_error.rst:34
msgid "Get a description of the last error"
msgstr "Получение описания последней ошибки"

#: ../doc/reference/reference_lua/box_error.rst:37
msgid ":ref:`box.error.clear() <box_error-clear>`"
msgstr ":ref:`box.error.clear() <box_error-clear>`"

#: ../doc/reference/reference_lua/box_error.rst:37
msgid "Clear the record of errors"
msgstr "Очистка записи об ошибках"

#: ../doc/reference/reference_lua/box_error.rst:40
msgid ":ref:`box.error.new() <box_error-new>`"
msgstr ":ref:`box.error.new() <box_error-new>`"

#: ../doc/reference/reference_lua/box_error.rst:40
msgid "Create an error but do not throw"
msgstr "Создание ошибки без выдачи"

#: ../doc/reference/reference_lua/box_error.rst:46
msgid ""
"When called with a Lua-table argument, the code and reason have any user-"
"desired values. The result will be those values."
msgstr ""
"При вызове с аргументом из Lua-таблицы значения параметров code и reason "
"будут любыми по желанию пользователя. Результатом будут эти значения."

#: ../doc/reference/reference_lua/box_error.rst:49
msgid "description of an error, defined by user"
msgstr "(строка) описание ошибки, задается пользователем"

#: ../doc/reference/reference_lua/box_error.rst:50
msgid "numeric code for this error, defined by user"
msgstr "(целое число) числовой код ошибки, задается пользователем"

#: ../doc/reference/reference_lua/box_error.rst:54
msgid ""
"When called without arguments, ``box.error()`` re-throws whatever the "
"last error was."
msgstr ""
"При вызове без аргументов ``box.error()`` повторно вызывает последнюю "
"ошибку."

#: ../doc/reference/reference_lua/box_error.rst:61
msgid ""
"Emulate a request error, with text based on one of the pre-defined "
"Tarantool errors defined in the file `errcode.h "
"<https://github.com/tarantool/tarantool/blob/2.1/src/box/errcode.h>`_ in "
"the source tree. Lua constants which correspond to those Tarantool errors"
" are defined as members of ``box.error``, for example "
"``box.error.NO_SUCH_USER == 45``."
msgstr ""
"Моделирование ошибки запроса с текстом на основе одной из ошибок "
"Tarantool'а, заданных в файле `errcode.h "
"<https://github.com/tarantool/tarantool/blob/2.1/src/box/errcode.h>`_ в "
"исходном дереве. Lua-постоянные, которые соответствуют этим ошибкам в "
"Tarantool'е, определяются как элементы ``box.error``, например "
"``box.error.NO_SUCH_USER == 45``."

#: ../doc/reference/reference_lua/box_error.rst:67
#: ../doc/reference/reference_lua/box_error.rst:157
msgid "number of a pre-defined error"
msgstr "номер предварительно заданной ошибки"

#: ../doc/reference/reference_lua/box_error.rst:68
#: ../doc/reference/reference_lua/box_error.rst:158
msgid "part of the message which will accompany the error"
msgstr "часть сообщения, которое сопровождает ошибку"

#: ../doc/reference/reference_lua/box_error.rst:72
#, python-format
msgid ""
"the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it "
"includes one \"``%s``\" component which will be replaced with errtext. "
"Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or "
"``box.error(45, 'joe')`` will result in an error with the accompanying "
"message \"``User 'joe' is not found``\"."
msgstr ""
"сообщение ``NO_SUCH_USER`` = \"``User '%s' is not found``\" (пользователь"
" не найден) -- оно включает в себя компонент \"``%s``\", который будет "
"заменен значением параметра errtext. Таким образом, вызов "
"``box.error(box.error.NO_SUCH_USER, 'joe')`` или ``box.error(45, 'joe')``"
" приведет к ошибке с сообщением \"``User 'joe' is not found``\" "
"(пользователь 'joe' не найден)."

#: ../doc/reference/reference_lua/box_error.rst
msgid "except"
msgstr "Исключение:"

#: ../doc/reference/reference_lua/box_error.rst:78
msgid "whatever is specified in errcode-number."
msgstr "то, что указано в номере errcode."

#: ../doc/reference/reference_lua/box_error.rst:82
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."

#: ../doc/reference/reference_lua/box_error.rst:101
msgid ""
"Returns a description of the last error, as a Lua table with five "
"members: \"line\" (number) Tarantool source file line number, \"code\" "
"(number) error's number, \"type\", (string) error's C++ class, "
"\"message\" (string) error's message, \"file\" (string) Tarantool source "
"file. Additionally, if the error is a system error (for example due to a "
"failure in socket or file io), there may be a sixth member: \"errno\" "
"(number) C standard error number."
msgstr ""
"Возвращает описание последней ошибки в виде Lua-таблицы с 5 элементами: "
"\"line\" (число) -- номер строки в исходном файле Tarantool'а, \"code\" "
"(число) -- номер ошибки, \"type\" (строка) -- C++ класс ошибки, "
"\"message\" (строка) -- сообщение об ошибке, \"file\" (строка) -- "
"исходный файл Tarantool'а. Кроме того, если ошибка является системной "
"(например, по причине ошибки в сокете или файловом вводы-выводе), может "
"быть дополнительный шестой элемент: \"errno\" (число) стандартный номер "
"ошибки на языке C."

#: ../doc/reference/reference_lua/box_error.rst:111
msgid "rtype: table"
msgstr "Тип возвращаемого значения: таблица"

#: ../doc/reference/reference_lua/box_error.rst:117
msgid ""
"Clears the record of errors, so functions like `box.error()` or "
"`box.error.last()` will have no effect."
msgstr ""
"Очистка записи об ошибках, то есть функции `box.error()` или "
"`box.error.last()` не сработают."

#: ../doc/reference/reference_lua/box_error.rst:122
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"  file: "
"/tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"  file: "
"/tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."

#: ../doc/reference/reference_lua/box_error.rst:152
msgid ""
"Create an error object, but do not throw. This is useful when error "
"information should be saved for later retrieval. The parameters are the "
"same as for :ref:`box.error() <box_error-error>`, see the description "
"there."
msgstr ""
"Создание ошибки без выдачи. Используется, когда необходимо сохранить "
"информацию об ошибке для последующей выборки. Используются такие же "
"параметры, как в :ref:`box.error() <box_error-error>`, см. описание по "
"ссылке."

#: ../doc/reference/reference_lua/box_error.rst:162
msgid ""
"tarantool> e = box.error.new{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"...\n"
"tarantool> e:unpack()\n"
"---\n"
"- type: ClientError\n"
"  code: 555\n"
"  message: Arbitrary message\n"
"  trace:\n"
"  - file: '[string \"e = box.error.new{code = 555, reason = "
"''Arbit...\"]'\n"
"    line: 1\n"
"..."
msgstr ""
"tarantool> e = box.error.new{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"...\n"
"tarantool> e:unpack()\n"
"---\n"
"- type: ClientError\n"
"  code: 555\n"
"  message: Arbitrary message\n"
"  trace:\n"
"  - file: '[string \"e = box.error.new{code = 555, reason = "
"''Arbit...\"]'\n"
"    line: 1\n"
"..."

#: ../doc/reference/reference_lua/box_once.rst:5
msgid "Function `box.once`"
msgstr "Функция `box.once`"

#: ../doc/reference/reference_lua/box_once.rst:9
msgid ""
"Execute a function, provided it has not been executed before. A passed "
"value is checked to see whether the function has already been executed. "
"If it has been executed before, nothing happens. If it has not been "
"executed before, the function is invoked."
msgstr ""
"Выполнение функции при условии, что она раньше не выполнялась. "
"Передаваемое значение проверяется на предмет того, выполнялась ли "
"функция. Если она выполнялась, ничего не происходит. В противном случае "
"вызывается функция."

#: ../doc/reference/reference_lua/box_once.rst:14
msgid ""
"See an example of using ``box.once()`` while :ref:`bootstrapping a "
"replica set <replication-bootstrap>`."
msgstr ""
"См. пример использования ``box.once()`` во время :ref:`настройки набора "
"реплик <replication-bootstrap>`."

#: ../doc/reference/reference_lua/box_once.rst:17
msgid ""
"If an error occurs inside ``box.once()`` when initializing a database, "
"you can re-execute the failed ``box.once()`` block without stopping the "
"database. The solution is to delete the ``once`` object from the system "
"space :ref:`_schema <box_space-schema>`. Say "
"``box.space._schema:select{}``, find your ``once`` object there and "
"delete it. For example, re-executing a block with ``key='hello'`` :"
msgstr ""
"Если в ``box.once()`` возникает ошибка во время инициализации базы "
"данных, можно повторно запустить невыполненный блок ``box.once()``, не "
"останавливая базу данных. Для этого удалите объект ``once`` из системного"
" спейса :ref:`_schema <box_space-schema>`. Введите команду "
"``box.space._schema:select{}``, найдите объект ``once`` и удалите его. "
"Например, повторное выполнение блока ``key='hello'`` :"

#: ../doc/reference/reference_lua/box_once.rst:24
msgid ""
"When ``box.once()`` is used for initialization, it may be useful to wait "
"until the database is in an appropriate state (read-only or read-write). "
"In that case, see the functions in the :ref:`box.ctl submodule "
"<box_ctl>`."
msgstr ""
"Когда ``box.once()`` используется для инициализации, следует подождать, "
"пока база данных не будет в нужном состоянии (только для чтения или для "
"чтения и записи). Для этого см. функции во :ref:`вложенном модуле box.ctl"
" <box_ctl>`."

#: ../doc/reference/reference_lua/box_once.rst:28
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/box_once.rst:48
msgid "a value that will be checked"
msgstr "значение для проверки"

#: ../doc/reference/reference_lua/box_once.rst:49
msgid "a function"
msgstr "функция"

#: ../doc/reference/reference_lua/box_once.rst:50
msgid "arguments that must be passed to function"
msgstr "аргументы, которые следует передать в функцию"

#: ../doc/reference/reference_lua/box_snapshot.rst:5
msgid "Function `box.snapshot`"
msgstr "Функция `box.snapshot`"

#: ../doc/reference/reference_lua/box_snapshot.rst:9
msgid ""
"Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool "
"first enters the delayed garbage collection mode for all data. In this "
"mode, the :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-"
"garbage-collector>` will not remove files which were created before the "
"snapshot started, it will not remove them until the snapshot has "
"finished. To preserve consistency of the primary key, used to iterate "
"over tuples, a copy-on-write technique is employed. If the master process"
" changes part of a primary key, the corresponding process page is split, "
"and the snapshot process obtains an old copy of the page. In effect, the "
"snapshot process uses multi-version concurrency control in order to avoid"
" copying changes which are superseded while it is running."
msgstr ""
"Создает снимок всех данных и сохраняет его в :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`:samp:`/{<latest-lsn>}.snap`. Чтобы сделать снимок, сначала "
"Tarantool входит в режим сборки мусора по всем данным. В этом режиме "
":ref:`сборщик мусора Tarantool'а <cfg_checkpoint_daemon-garbage-"
"collector>` не будет удалять файлы, созданные до начала создания снимка, "
"до тех пор, пока не будет завершено создание снимка. Чтобы сохранить "
"консистентность первичного ключа, используемого для итерации по кортежам,"
" применяется технология копирования при записи. Если главный процесс "
"изменяет часть первичного ключа, страница соответствующего процесса "
"разделяется, и процесс создания снимка получает старую копию страницы. В "
"результате, процесс создания снимка использует многоверсионную "
"параллельную обработку данных, чтобы не скопировать изменения, замененные"
" одновременно с ходом процесса."

#: ../doc/reference/reference_lua/box_snapshot.rst:23
msgid ""
"Since a snapshot is written sequentially, one can expect a very high "
"write performance (averaging to 80MB/second on modern disks), which means"
" an average database instance gets saved in a matter of minutes. Users "
"may restrict the speed by changing :ref:`snap_io_rate_limit "
"<cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""
"Поскольку снимок создается последовательно, можно ожидать высокую "
"скорость записи (в среднем до 80 МБ/секунду на современных дисках), что "
"означает сохранение данных усредненного экземпляра базы данных за "
"несколько минут. Пользователи могут ограничить скорость записи, изменив "
"значение :ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-"
"snap_io_rate_limit>`."

#: ../doc/reference/reference_lua/box_snapshot.rst:31
#, python-format
msgid ""
"As long as there are any changes to the parent index memory through "
"concurrent updates, there are going to be page splits, and therefore you "
"need to have some extra free memory to run this command. 10% of "
":ref:`memtx_memory <cfg_storage-memtx_memory>` is, on average, "
"sufficient. This statement waits until a snapshot is taken and returns "
"operation result."
msgstr ""
"При условии, что происходят изменения в родительском индексе в ходе "
"многопоточного обновления данных, будет происходить и расщепление "
"страниц, поэтому возникнет необходимость в наличии дополнительной "
"свободной памяти для выполнения этой команды. В среднем, будет достаточно"
" 10% от :ref:`memtx_memory <cfg_storage-memtx_memory>`. Оператор подождет"
" окончания создания снимка и вернет результат операции."

#: ../doc/reference/reference_lua/box_snapshot.rst:39
msgid ""
"**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process"
" caused a fork, which could cause occasional latency spikes. Starting "
"with Tarantool version 1.6.6, the snapshot process creates a consistent "
"read view and this view is written to the snapshot file by a separate "
"thread (the \"Write Ahead Log\" thread)."
msgstr ""
"**Обновление:** До версии 1.6.6 Tarantool'а процесс создания снимка "
"вызывал создание ответвления, что могло привести к скачкам задержки "
"отклика. Начиная с версии 1.6.6 Tarantool'а, процесс создания снимка "
"создает вид постоянного просмотра, который и записывается в файл снимка с"
" помощью отдельного потока (поток упреждающей записи в журнал)."

#: ../doc/reference/reference_lua/box_snapshot.rst:45
msgid ""
"Although ``box.snapshot()`` does not cause a fork, there is a separate "
"fiber which may produce snapshots at regular intervals -- see the "
"discussion of the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""
"Хотя ``box.snapshot()`` не создает ответвление, есть отдельный файбер, "
"который может создавать снимки на регулярной основе -- см. обсуждение "
":ref:`демона создания контрольных точек <book_cfg_checkpoint_daemon>`."

#: ../doc/reference/reference_lua/box_snapshot.rst:51
msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."

#: ../doc/reference/reference_lua/box_snapshot.rst:66
msgid ""
"Taking a snapshot does not cause the server to start a new write-ahead "
"log. Once a snapshot is taken, old WALs can be deleted as long as all "
"replicated data is up to date. But the WAL which was current at the time "
"``box.snapshot()`` started must be kept for recovery, since it still "
"contains log records written after the start of ``box.snapshot()``."
msgstr ""
"Создание снимка не приводит к записи нового журнала упреждающей записи на"
" сервере. После создания снимка старые WAL-файлы можно удалить, если все "
"реплицируемые данные актуальны. Но WAL-файл на момент начала работы "
"``box.snapshot()`` следует сохранить на случай восстановления, поскольку "
"он содержит записи журнала после начала работы ``box.snapshot()``."

#: ../doc/reference/reference_lua/box_snapshot.rst:72
msgid ""
"An alternative way to save a snapshot is to send a SIGUSR1 signal to the "
"instance. While this approach could be handy, it is not recommended for "
"use in automation: a signal provides no way to find out whether the "
"snapshot was taken successfully or not."
msgstr ""
"Другим способом сохранения снимка будет отправка сигнала SIGUSR1 на "
"экземпляр. Хотя это может быть удобно, не рекомендуется использовать "
"такой метод в автоматическом процессе: сигнал не дает возможность "
"проверить, был ли корректно сделан снимок."

#: ../doc/reference/reference_lua/buffer.rst:5
msgid "Module `buffer`"
msgstr "Модуль `buffer`"

#: ../doc/reference/reference_lua/buffer.rst:7
msgid ""
"The ``buffer`` module returns a dynamically resizable buffer which is "
"solely for use as an option for methods of the :ref:`net.box module "
"<net_box-module>`."
msgstr ""
"Модуль ``buffer`` возвращает буфер, допускающий динамическое изменение "
"размера, который используется только в качестве опции для методов "
":ref:`модуля net.box <net_box-module>`."

#: ../doc/reference/reference_lua/buffer.rst:10
msgid ""
"Ordinarily the ``net.box`` methods return a Lua table. If a ``buffer`` "
"option is used, then the ``net.box`` methods return a raw MsgPack_ "
"string. This saves time on the server, if the client application has its "
"own routine for decoding MsgPack strings."
msgstr ""
"Как правило, модуль ``net.box`` возвращает Lua-таблицу. Если используется"
" опция ``buffer``, то методы модуля ``net.box`` возвращают "
"неформатированную строку MsgPack_. Это экономит время работы на сервере, "
"если в клиентском приложении есть собственная процедура декодирования "
"MsgPack-строк."

#: ../doc/reference/reference_lua/buffer.rst
#: ../doc/reference/reference_lua/clock.rst
#: ../doc/reference/reference_lua/console.rst
#: ../doc/reference/reference_lua/csv.rst
#: ../doc/reference/reference_lua/debug_facilities.rst
#: ../doc/reference/reference_lua/fiber.rst
#: ../doc/reference/reference_lua/fio.rst
#: ../doc/reference/reference_lua/http.rst
#: ../doc/reference/reference_lua/iconv.rst
#: ../doc/reference/reference_lua/json.rst
#: ../doc/reference/reference_lua/key_def.rst
#: ../doc/reference/reference_lua/log.rst
#: ../doc/reference/reference_lua/merger.rst
#: ../doc/reference/reference_lua/msgpack.rst
#: ../doc/reference/reference_lua/net_box.rst
#: ../doc/reference/reference_lua/other.rst
#: ../doc/reference/reference_lua/pickle.rst
#: ../doc/reference/reference_lua/socket.rst
#: ../doc/reference/reference_lua/swim.rst
#: ../doc/reference/reference_lua/tap.rst
#: ../doc/reference/reference_lua/uri.rst
#: ../doc/reference/reference_lua/utf8.rst
#: ../doc/reference/reference_lua/uuid.rst
#: ../doc/reference/reference_lua/yaml.rst
#: ../doc/reference/reference_rock/membership.rst
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst
msgid "return"
msgstr "возвращает"

#: ../doc/reference/reference_lua/buffer.rst:20
msgid "a descriptor of a buffer."
msgstr "дескриптор буфера."

#: ../doc/reference/reference_lua/buffer.rst
#: ../doc/reference/reference_lua/clock.rst
#: ../doc/reference/reference_lua/csv.rst
#: ../doc/reference/reference_lua/errno.rst
#: ../doc/reference/reference_lua/fiber.rst
#: ../doc/reference/reference_lua/fio.rst
#: ../doc/reference/reference_lua/http.rst
#: ../doc/reference/reference_lua/iconv.rst
#: ../doc/reference/reference_lua/json.rst
#: ../doc/reference/reference_lua/msgpack.rst
#: ../doc/reference/reference_lua/net_box.rst
#: ../doc/reference/reference_lua/pickle.rst
#: ../doc/reference/reference_lua/socket.rst
#: ../doc/reference/reference_lua/tap.rst
#: ../doc/reference/reference_lua/uri.rst
#: ../doc/reference/reference_lua/utf8.rst
#: ../doc/reference/reference_lua/uuid.rst
#: ../doc/reference/reference_lua/xlog.rst
#: ../doc/reference/reference_lua/yaml.rst
#: ../doc/reference/reference_rock/membership.rst
msgid "rtype"
msgstr "тип возвращаемого значения"

#: ../doc/reference/reference_lua/buffer.rst:21
#: ../doc/reference/reference_lua/uuid.rst:61
#: ../doc/reference/reference_lua/uuid.rst:83
#: ../doc/reference/reference_lua/uuid.rst:91
msgid "cdata"
msgstr "cdata."

#: ../doc/reference/reference_lua/buffer.rst:25
msgid ""
"Assume a Tarantool server is listening on farhost:3301. Assume it has a "
"space ``T`` with one tuple: ``'ABCDE', 12345``. In this example we start "
"up a server on localhost:3302 and then use ``net.box`` routines to "
"connect to farhost. Then we create a buffer, and use it as an option for "
"a ``conn.space...select()`` call. The result will be in MsgPack_ format. "
"To show this, we will use :ref:`msgpack.decode_unchecked() <msgpack-"
"decode_unchecked>` on ``ibuf.rpos`` (the \"read position\" of the "
"buffer). Thus we do not decode on the remote server, but we do decode on "
"the local server."
msgstr ""
"Предположим, что Tarantool-сервер настроен на прослушивание на "
"farhost:3301. Предположим, что на нем есть спейс ``T`` с одним кортежем: "
"``'ABCDE', 12345``. В данном примере запустим сервер на localhost:3302, а"
" затем используем процедуры ``net.box`` для подключения к farhost. Затем "
"создадим буфер и используем его как опцию для вызова "
"``conn.space...select()``. Результат получим в формате MsgPack_. Чтобы "
"показать это, используем :ref:`msgpack.decode_unchecked() <msgpack-"
"decode_unchecked>` на ``ibuf.rpos`` (\"позиция для чтения\" в буфере). "
"Таким образом, мы проведем декодирование не на удаленном сервере, а на "
"локальном."

#: ../doc/reference/reference_lua/buffer.rst:38
msgid ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"

#: ../doc/reference/reference_lua/buffer.rst:50
#: ../doc/reference/reference_lua/buffer.rst:110
msgid "The result of the final request looks like this:"
msgstr "Результат последнего запроса выглядит следующим образом:"

#: ../doc/reference/reference_lua/buffer.rst:52
#: ../doc/reference/reference_lua/buffer.rst:73
msgid ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."
msgstr ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."

#: ../doc/reference/reference_lua/buffer.rst:62
msgid ""
"Before Tarantool version 1.7.7, the function to use for this case is "
"``msgpack.ibuf_decode(ibuf.rpos)``. Starting with Tarantool version "
"1.7.7, ``ibuf_decode`` is deprecated."
msgstr ""
"До версии 1.7.7 Tarantool'а в данном случае следует использовать функцию "
"``msgpack.ibuf_decode(ibuf.rpos)``. Начиная с версии  1.7.7 Tarantool'а ,"
" ``ibuf_decode`` объявлена устаревшей."

#: ../doc/reference/reference_lua/buffer.rst:69
msgid "**Module buffer and skip-header**"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:71
msgid "The example in the previous section"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:81
msgid ""
"showed that, ordinarily, the response from net.box includes a header -- "
"48 (hexadecimal 30) is the :ref:`key <internals-"
"unified_packet_structure>` for IPROTO_DATA. But in some situations, for "
"example when passing the buffer to a C function that expects a MsgPack "
"byte array without a header, the header can be skipped. This is done by "
"specifying ``skip-header=true`` as an option to :ref:`conn.space.space-"
"name:select{...} <conn-select>` or :ref:`conn.space.space-"
"name:insert{...} <conn-insert>` or :ref:`conn.space.space-"
"name:replace{...} <conn-replace>` or :ref:`conn.space.space-"
"name:update{...} <conn-update>` or :ref:`conn.space.space-"
"name:upsert{...} <conn-upsert>` or :ref:`conn.space.space-"
"name:delete{...} <conn-delete>`. The default is ``skip-header=false``."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:96
msgid "Now here is the same example, except that ``skip_header=true`` is used."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:98
#, fuzzy
msgid ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf, skip_header=true})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"

#: ../doc/reference/reference_lua/buffer.rst:112
#, fuzzy
msgid ""
"tarantool>         msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- [['ABCDE', 12345]]\n"
"- 'cdata<char *>: 0x7f8fd102803f'\n"
"..."
msgstr ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."

#: ../doc/reference/reference_lua/buffer.rst:120
msgid "Notice that the IPROTO_DATA header (48) is gone."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:122
msgid ""
"The result is still inside an array, as is clear from the fact that it is"
" shown inside square brackets. It is possible to skip the array header "
"too, with :ref:`msgpack.decode_array_header() <msgpack-"
"decode_array_header>`."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:5
msgid "Module `clock`"
msgstr "Модуль `clock`"

#: ../doc/reference/reference_lua/clock.rst:11
msgid ""
"The ``clock`` module returns time values derived from the Posix / C "
"CLOCK_GETTIME_ function or equivalent. Most functions in the module "
"return a number of seconds; functions whose names end in \"64\" return a "
"64-bit number of nanoseconds."
msgstr ""
"Модуль ``clock`` возвращает значения времени, полученных из функции Posix"
" / C CLOCK_GETTIME_ или аналогичной. Большинство функций модуля "
"возвращают число секунд; функции, названия которых заканчиваются на "
"\"64\", возвращают 64-разрадяное число наносекунд."

#: ../doc/reference/reference_lua/clock.rst:20
msgid "Below is a list of all ``clock`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``clock``."

#: ../doc/reference/reference_lua/clock.rst:30
msgid ":ref:`clock.time() <clock-time>` |br| :ref:`clock.realtime() <clock-time>`"
msgstr ":ref:`clock.time() <clock-time>` |br| :ref:`clock.realtime() <clock-time>`"

#: ../doc/reference/reference_lua/clock.rst:31
msgid "Get the wall clock time in seconds"
msgstr "Получение физического времени в секундах"

#: ../doc/reference/reference_lua/clock.rst:35
msgid ""
":ref:`clock.time64() <clock-time>` |br| :ref:`clock.realtime64() <clock-"
"time>`"
msgstr ""
":ref:`clock.time64() <clock-time>` |br| :ref:`clock.realtime64() <clock-"
"time>`"

#: ../doc/reference/reference_lua/clock.rst:36
msgid "Get the wall clock time in nanoseconds"
msgstr "Получение физического времени в наносекундах"

#: ../doc/reference/reference_lua/clock.rst:40
msgid ":ref:`clock.monotonic() <clock-monotonic>`"
msgstr ":ref:`clock.monotonic() <clock-monotonic>`"

#: ../doc/reference/reference_lua/clock.rst:40
msgid "Get the monotonic time in seconds"
msgstr "Получение монотонного времени в секундах"

#: ../doc/reference/reference_lua/clock.rst:43
msgid ":ref:`clock.monotonic64() <clock-monotonic>`"
msgstr ":ref:`clock.monotonic64() <clock-monotonic>`"

#: ../doc/reference/reference_lua/clock.rst:43
msgid "Get the monotonic time in nanoseconds"
msgstr "Получение монотонного времени в наносекундах"

#: ../doc/reference/reference_lua/clock.rst:46
msgid ":ref:`clock.proc() <clock-proc>`"
msgstr ":ref:`clock.proc() <clock-proc>`"

#: ../doc/reference/reference_lua/clock.rst:46
msgid "Get the processor time in seconds"
msgstr "Получение времени процессора в секундах"

#: ../doc/reference/reference_lua/clock.rst:49
msgid ":ref:`clock.proc64() <clock-proc>`"
msgstr ":ref:`clock.proc64() <clock-proc>`"

#: ../doc/reference/reference_lua/clock.rst:49
msgid "Get the processor time in nanoseconds"
msgstr "Получение времени процессора в наносекундах"

#: ../doc/reference/reference_lua/clock.rst:52
msgid ":ref:`clock.thread() <clock-thread>`"
msgstr ":ref:`clock.thread() <clock-thread>`"

#: ../doc/reference/reference_lua/clock.rst:52
msgid "Get the thread time in seconds"
msgstr "Получение рабочего времени потока в секундах"

#: ../doc/reference/reference_lua/clock.rst:55
msgid ":ref:`clock.thread64() <clock-thread>`"
msgstr ":ref:`clock.thread64() <clock-thread>`"

#: ../doc/reference/reference_lua/clock.rst:55
msgid "Get the thread time in nanoseconds"
msgstr "Получение рабочего времени потока в наносекундах"

#: ../doc/reference/reference_lua/clock.rst:58
msgid ":ref:`clock.bench() <clock-bench>`"
msgstr ":ref:`clock.bench() <clock-bench>`"

#: ../doc/reference/reference_lua/clock.rst:58
msgid "Measure the time a function takes within a processor"
msgstr "Измерение времени, которое функция проводит в процессоре"

#: ../doc/reference/reference_lua/clock.rst:71
msgid ""
"The wall clock time. Derived from C function "
"clock_gettime(CLOCK_REALTIME). This is the best function for knowing what"
" the official time is, as determined by the system administrator."
msgstr ""
"Физическое время в секундах. Получено из C-функции "
"clock_gettime(CLOCK_REALTIME). Использование этой функции лучше всего "
"подходит для выяснения официального времени, как установлено системным "
"администратором."

#: ../doc/reference/reference_lua/clock.rst:75
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""
"секунды или наносекунды с начала отсчета (1970-01-01 00:00:00), значение "
"корректируется."

#: ../doc/reference/reference_lua/clock.rst:76
#: ../doc/reference/reference_lua/clock.rst:101
#: ../doc/reference/reference_lua/clock.rst:122
#: ../doc/reference/reference_lua/clock.rst:143
msgid "number or number64"
msgstr "число или 64-разрядное число"

#: ../doc/reference/reference_lua/clock.rst:80
msgid ""
"-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""
"-- Результатом будет примерное число лет с 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"

#: ../doc/reference/reference_lua/clock.rst:86
msgid ""
"See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function"
" `os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""
"См. также :ref:`fiber.time64 <fiber-time64>` и стандартную Lua-функцию "
"`os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."

#: ../doc/reference/reference_lua/clock.rst:94
msgid ""
"The monotonic time. Derived from C function "
"clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock "
"time but is not affected by changes to or from daylight saving time, or "
"by changes done by a user. This is the best function to use with "
"benchmarks that need to calculate elapsed time."
msgstr ""
"Монотонное время. Получено из C-функции clock_gettime(CLOCK_MONOTONIC). "
"Монотонное время похоже на физическое время, но на него не влияют "
"изменения для перехода на летнее время или изменения, сделанные "
"пользователем. Такую функцию лучше всего использовать для эталонного "
"тестирования, где необходимо рассчитать затраченное время."

#: ../doc/reference/reference_lua/clock.rst:100
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr "секунды или наносекунды с момента последней загрузки компьютера."

#: ../doc/reference/reference_lua/clock.rst:105
msgid ""
"-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""
"-- Результатом будет число наносекунд с запуска.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"

#: ../doc/reference/reference_lua/clock.rst:116
msgid ""
"The processor time. Derived from C function "
"``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. This is the best function to"
" use with benchmarks that need to calculate how much time has been spent "
"within a CPU."
msgstr ""
"Время процессора. Получено из C-функции "
"``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. Такую функцию лучше всего "
"использовать для эталонного тестирования, где необходимо рассчитать "
"время, затраченное на процессоре."

#: ../doc/reference/reference_lua/clock.rst:121
msgid "seconds or nanoseconds since processor start."
msgstr "секунды или наносекунды с момента начала работы процессора."

#: ../doc/reference/reference_lua/clock.rst:126
msgid ""
"-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""
"-- Результатом будет число наносекунд с запуска процессора.\n"
"clock = require('clock')\n"
"print(clock.proc64())"

#: ../doc/reference/reference_lua/clock.rst:137
msgid ""
"The thread time. Derived from C function "
"``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. This is the best function to "
"use with benchmarks that need to calculate how much time has been spent "
"within a thread within a CPU."
msgstr ""
"Рабочее время потока. Получено из C-функции "
"``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. Такую функцию лучше всего "
"использовать для эталонного тестирования, где необходимо рассчитать "
"время, затраченное потоком на процессоре."

#: ../doc/reference/reference_lua/clock.rst:142
msgid "seconds or nanoseconds since the transaction processor thread started."
msgstr ""
"секунды или наносекунды с момента начала работы потока процессора "
"транзакций."

#: ../doc/reference/reference_lua/clock.rst:147
msgid ""
"-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""
"-- Результатом будет число секунд с момента начала работы потока.\n"
"clock = require('clock')\n"
"print(clock.thread64())"

#: ../doc/reference/reference_lua/clock.rst:157
msgid ""
"The time that a function takes within a processor. This function uses "
"``clock.proc()``, therefore it calculates elapsed CPU time. Therefore it "
"is not useful for showing actual elapsed time."
msgstr ""
"Время, которое функция проводит в процессоре. Данная функция использует "
"``clock.proc()``, то есть рассчитывает затраченное процессором время. "
"Таким образом, она не используется для отображения фактически "
"затраченного времени."

#: ../doc/reference/reference_lua/clock.rst:161
msgid "function or function reference"
msgstr "функция или ссылка на функцию"

#: ../doc/reference/reference_lua/clock.rst:162
msgid "whatever values are required by the function."
msgstr "значения, которые необходимы для функции."

#: ../doc/reference/reference_lua/clock.rst:164
msgid ""
"**table**. first element - seconds of CPU time, second element - whatever"
" the function returns."
msgstr ""
"**таблица**. Первый элемент -- время работы процессора в секундах, второй"
" элемент -- то, что возвращает функция."

#: ../doc/reference/reference_lua/clock.rst:169
msgid ""
"-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"
msgstr ""
"-- Эталонное тестирование функции, которая находится в спящем режиме в "
"течение 10 секунд.\n"
"-- NB: bench() не будет рассчитывать время сна.\n"
"-- Поэтому вернется значение, которое будет {число менее 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"

#: ../doc/reference/reference_lua/console.rst:5
msgid "Module `console`"
msgstr "Модуль `console`"

#: ../doc/reference/reference_lua/console.rst:11
msgid ""
"The console module allows one Tarantool instance to access another "
"Tarantool instance, and allows one Tarantool instance to start listening "
"on an :ref:`admin port <admin-security>`."
msgstr ""
"Модуль `console` позволяет одному экземпляру Tarantool'а получать доступ "
"к другому экземпляру Tarantool'а и позволяет одному экземпляру "
"Tarantool'а начать прослушивание по :ref:`порту администрирования <admin-"
"security>`."

#: ../doc/reference/reference_lua/console.rst:19
msgid "Below is a list of all ``console`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``console``."

#: ../doc/reference/reference_lua/console.rst:29
msgid ":ref:`console.connect() <console-connect>`"
msgstr ":ref:`console.connect() <console-connect>`"

#: ../doc/reference/reference_lua/console.rst:29
msgid "Connect to an instance"
msgstr "Подключение к экземпляру"

#: ../doc/reference/reference_lua/console.rst:32
msgid ":ref:`console.listen() <console-listen>`"
msgstr ":ref:`console.listen() <console-listen>`"

#: ../doc/reference/reference_lua/console.rst:32
msgid "Listen for incoming requests"
msgstr "Прослушивание входящих запросов"

#: ../doc/reference/reference_lua/console.rst:35
msgid ":ref:`console.start() <console-start>`"
msgstr ":ref:`console.start() <console-start>`"

#: ../doc/reference/reference_lua/console.rst:35
msgid "Start the console"
msgstr "Запуск консоли"

#: ../doc/reference/reference_lua/console.rst:38
msgid ":ref:`console.ac() <console-ac>`"
msgstr ":ref:`console.ac() <console-ac>`"

#: ../doc/reference/reference_lua/console.rst:38
msgid "Set the auto-completion flag"
msgstr "Установка флага автодополнения ввода"

#: ../doc/reference/reference_lua/console.rst:41
msgid ":ref:`console.delimiter() <console-delimiter>`"
msgstr ":ref:`console.delimiter() <console-delimiter>`"

#: ../doc/reference/reference_lua/console.rst:41
msgid "Set a delimiter"
msgstr "Настройка разделителя"

#: ../doc/reference/reference_lua/console.rst:44
#, fuzzy
msgid ":ref:`console.get_default_output() <console-get_default_output>`"
msgstr ":ref:`console.start() <console-start>`"

#: ../doc/reference/reference_lua/console.rst:44
msgid "Get default output format"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:47
#, fuzzy
msgid ":ref:`console.set_default_output() <console-set_default_output>`"
msgstr ":ref:`console.start() <console-start>`"

#: ../doc/reference/reference_lua/console.rst:47
msgid "Set default output format"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:58
msgid ""
"Connect to the instance at :ref:`URI <index-uri>`, change the prompt from"
" '``tarantool>``' to ':samp:`{uri}>`', and act henceforth as a client "
"until the user ends the session or types ``control-D``."
msgstr ""
"Подключение к экземпляру по :ref:`URI <index-uri>`, смена командной "
"строки с '``tarantool>``' на ':samp:`{uri}>`' и дальнейшая работа в "
"качестве клиента до окончания сессии пользователя или ввода команды "
"``control-D``."

#: ../doc/reference/reference_lua/console.rst:62
msgid ""
"The console.connect function allows one Tarantool instance, in "
"interactive mode, to access another Tarantool instance. Subsequent "
"requests will appear to be handled locally, but in reality the requests "
"are being sent to the remote instance and the local instance is acting as"
" a client. Once connection is successful, the prompt will change and "
"subsequent requests are sent to, and executed on, the remote instance. "
"Results are displayed on the local instance. To return to local mode, "
"enter ``control-D``."
msgstr ""
"Функция console.connect позволяет одному экземпляру Tarantool'а в "
"интерактивном режиме получать доступ к другому экземпляру Tarantool'а. "
"Последующие запросы на первый взгляд будут обрабатываться локально, но в "
"действительности запросы отправляются на удаленный экземпляр, а локальный"
" экземпляр выступает в виде клиента. После успешного подключения "
"командная строка сменится, и последующие запросы отправляются и "
"выполняются на удаленном экземпляре. Результат выводится на локальный "
"экземпляр. Чтобы вернуться к работе на локальном экземпляре, введите "
"команду ``control-D``."

#: ../doc/reference/reference_lua/console.rst:70
msgid ""
"If the Tarantool instance at :samp:`uri` requires authentication, the "
"connection might look something like: "
"``console.connect('admin:secretpassword@distanthost.com:3301')``."
msgstr ""
"Если экземпляр Tarantool'а по :samp:`URI` запрашивает авторизацию, "
"подключение может выглядеть следующим образом: "
"``console.connect('admin:secretpassword@distanthost.com:3301')``."

#: ../doc/reference/reference_lua/console.rst:74
msgid ""
"There are no restrictions on the types of requests that can be entered, "
"except those which are due to privilege restrictions -- by default the "
"login to the remote instance is done with user name = 'guest'. The remote"
" instance could allow for this by granting at least one privilege: "
"``box.schema.user.grant('guest','execute','universe')``."
msgstr ""
"Нет ограничений по типу вводимых запросов, кроме ограничений по правам на"
" выполняемые запросы -- по умолчанию, вход в систему на удаленном "
"экземпляре выполняется от имени пользователя 'guest'. Можно разрешить "
"работу на удаленном экземпляре, выдав права: "
"``box.schema.user.grant('guest','execute','universe')``."

#: ../doc/reference/reference_lua/console.rst:80
msgid "the URI of the remote instance"
msgstr "URI удаленного экземпляра"

#: ../doc/reference/reference_lua/console.rst:81
#: ../doc/reference/reference_lua/fiber.rst:483
#: ../doc/reference/reference_lua/fiber.rst:531
#: ../doc/reference/reference_lua/fiber.rst:632
#: ../doc/reference/reference_lua/fiber.rst:1062
#: ../doc/reference/reference_lua/fiber.rst:1070
#: ../doc/reference/reference_lua/log.rst:115
#: ../doc/reference/reference_lua/log.rst:140
#: ../doc/reference/reference_lua/msgpack.rst:281
#: ../doc/reference/reference_lua/tap.rst:130
#: ../doc/reference/reference_lua/tap.rst:164
#: ../doc/reference/reference_lua/tap.rst:224
msgid "nil"
msgstr "nil"

#: ../doc/reference/reference_lua/console.rst:83
msgid ""
"Possible errors: the connection will fail if the target Tarantool "
"instance was not initiated with ``box.cfg{listen=...}``."
msgstr ""
"Возможные ошибки: подключение не будет установлено, если целевой "
"экземпляр Tarantool'а не был инициирован с помощью "
"``box.cfg{listen=...}``."

#: ../doc/reference/reference_lua/console.rst:88
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that instance is remote"
msgstr ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- командная строка показывает, что работа идет с "
"удаленным экземпляром"

#: ../doc/reference/reference_lua/console.rst:102
msgid ""
"Listen on :ref:`URI <index-uri>`. The primary way of listening for "
"incoming requests is via the connection-information string, or URI, "
"specified in ``box.cfg{listen=...}``. The alternative way of listening is"
" via the URI specified in ``console.listen(...)``. This alternative way "
"is called \"administrative\" or simply :ref:`\"admin port\" <admin-"
"security>`. The listening is usually over a local host with a Unix domain"
" socket."
msgstr ""
"Прослушивание по :ref:`URI <index-uri>`. Основной способ прослушивания на"
" предмет входящих запросов -- по строке информации о подключении, или "
"URI, указанному в ``box.cfg{listen=...}``. Другой способ прослушивания --"
" по URI, указанному в ``console.listen(...)``. Этот другой способ "
"называется \"административным\" или просто :ref:`\"по порту "
"администрирования\" <admin-security>`. Такое прослушивание обычно "
"осуществляется по локальному хосту с доменным Unix-сокетом."

#: ../doc/reference/reference_lua/console.rst:109
msgid "the URI of the local instance"
msgstr "URI локального экземпляра"

#: ../doc/reference/reference_lua/console.rst:111
msgid ""
"The \"admin\" address is the URI to listen on. It has no default value, "
"so it must be specified if connections will occur via an admin port. The "
"parameter is expressed with URI = Universal Resource Identifier format, "
"for example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. "
"Connections are often made with telnet. A typical port value is 3313."
msgstr ""
"\"Административный\" адрес -- это URI для прослушивания. У него нет "
"значения по умолчанию, поэтому следует указать, будет ли подключение "
"производиться по порту администрирования. Параметр выражен URI = "
"Универсальным идентификатором ресурса, например "
"\"/tmpdir/unix_domain_socket.sock\", или числовым идентификатором "
"TCP-порта. Подключения часто выполняются по telnet. Типичное значение "
"порта: 3313."

#: ../doc/reference/reference_lua/console.rst:119
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."

#: ../doc/reference/reference_lua/console.rst:140
msgid "Start the console on the current interactive terminal."
msgstr "Запуск консоли на текущем интерактивном терминале."

#: ../doc/reference/reference_lua/console.rst:144
msgid ""
"A special use of ``console.start()`` is with :ref:`initialization files "
"<index-init_label>`. Normally, if one starts the Tarantool instance with "
":samp:`tarantool {initialization file}` there is no console. This can be "
"remedied by adding these lines at the end of the initialization file:"
msgstr ""
"``console.start()`` специально используется с :ref:`файлами инициализации"
" <index-init_label>`. Как правило, при запуске экземпляра Tarantool'а с "
"помощью команды :samp:`tarantool {initialization file}`, консоль не "
"поддерживается. Эту проблему можно решить путем добавления следующих "
"строк в конце файла инициализации:"

#: ../doc/reference/reference_lua/console.rst:149
msgid ""
"local console = require('console')\n"
"console.start()"
msgstr ""
"local console = require('console')\n"
"console.start()"

#: ../doc/reference/reference_lua/console.rst:158
msgid ""
"Set the auto-completion flag. If auto-completion is `true`, and the user "
"is using Tarantool as a client or the user is using Tarantool via "
"``console.connect()``, then hitting the TAB key may cause tarantool to "
"complete a word automatically. The default auto-completion value is "
"`true`."
msgstr ""
"Установка флага автодополнения ввода. Если значение автодополнения = "
"`true` (правда), и пользователь использует Tarantool в качестве клиента "
"или подключен к Tarantool'у по ``console.connect()``, то при нажатии "
"клавиши TAB Tarantool будет автоматически дополнять текст по введенной "
"части. По умолчанию, задано значение `true`."

#: ../doc/reference/reference_lua/console.rst:167
msgid "Set a custom end-of-request marker for Tarantool console."
msgstr "Настройка специального маркера окончания запроса для консоли Tarantool'а."

#: ../doc/reference/reference_lua/console.rst:169
msgid ""
"The default end-of-request marker is a newline (line feed). Custom "
"markers are not necessary because Tarantool can tell when a multi-line "
"request has not ended (for example, if it sees that a function "
"declaration does not have an end keyword). Nonetheless for special needs,"
" or for entering multi-line requests in older Tarantool versions, you can"
" change the end-of-request marker. As a result, newline alone is not "
"treated as end of request."
msgstr ""
"По умолчанию, маркер окончания запроса представляет собой символ разрыва "
"строки (перевод строки). Нет необходимости в специальных маркерах, "
"поскольку Tarantool может определить, если многостроковый запрос не "
"завершен (например, если видно, что при объявлении функции еще не задано "
"конечное ключевое слово). Тем не менее, в особых случаях или при вводе "
"многостроковых запросов в более ранних версиях Tarantool'а, можно "
"изменить маркер окончания запроса. В результате символ разрыва строки не "
"будет означать окончание запроса."

#: ../doc/reference/reference_lua/console.rst:177
msgid "To go back to normal mode, say: ``console.delimiter('')<marker>``"
msgstr ""
"Чтобы вернуться в нормальный режим, введите команду: "
"``console.delimiter('')<marker>``"

#: ../doc/reference/reference_lua/console.rst:179
msgid "a custom end-of-request marker for Tarantool console"
msgstr "специальный маркер окончания запроса для консоли Tarantool'а"

#: ../doc/reference/reference_lua/console.rst:183
msgid ""
"tarantool> console = require('console'); console.delimiter('!')\n"
"---\n"
"...\n"
"tarantool> function f ()\n"
"         > statement_1 = 'a'\n"
"         > statement_2 = 'b'\n"
"         > end!\n"
"---\n"
"...\n"
"tarantool> console.delimiter('')!\n"
"---\n"
"..."
msgstr ""
"tarantool> console = require('console'); console.delimiter('!')\n"
"---\n"
"...\n"
"tarantool> function f ()\n"
"         > statement_1 = 'a'\n"
"         > statement_2 = 'b'\n"
"         > end!\n"
"---\n"
"...\n"
"tarantool> console.delimiter('')!\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/console.rst:202
msgid ""
"Return the current default output format. The result will be "
"``fmt=\"yaml\"``, or it will be ``fmt=\"lua\"`` if the last "
":ref:`set_default_output <console-set_default_output>` call was "
"``console.set_default_output('lua')``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:211
msgid ""
"Set the default output format. The possible values are 'yaml' (the "
"default default) or 'lua'. The output format can be changed within a "
"session by executing :samp:`console.eval('\\\\\\\\set output "
"{yaml}|{lua}')`; see the description of output format in the "
":ref:`Interactive console <interactive_console_output>` section."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:5
msgid "Module `crypto`"
msgstr "Модуль `crypto`"

#: ../doc/reference/reference_lua/crypto.rst:13
msgid ""
"\"Crypto\" is short for \"Cryptography\", which generally refers to the "
"production of a digest value from a function (usually a `Cryptographic "
"hash function`_), applied against a string. Tarantool's ``crypto`` module"
" supports ten types of cryptographic hash functions (AES_, DES_, DSS_, "
"MD4_, MD5_, MDC2_, RIPEMD_, SHA-1_, SHA-2_). Some of the crypto "
"functionality is also present in the :ref:`digest` module."
msgstr ""
"\"Crypto\" -- это сокращенно \"криптография\", что обычно означает "
"производство значения дайджеста из функции (как правило, "
"криптографической хеш-функции -- `Cryptographic hash function`_), "
"примененной к строке. Модуль ``crypto`` Tarantool'а поддерживает десять "
"типов криптографических хеш-функций (AES_, DES_, DSS_, MD4_, MD5_, MDC2_,"
" RIPEMD_, SHA-1_, SHA-2_). В модуле :ref:`digest` также есть некоторые "
"криптографические функции."

#: ../doc/reference/reference_lua/crypto.rst:24
msgid "Below is a list of all ``crypto`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``crypto``."

#: ../doc/reference/reference_lua/crypto.rst:34
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.encrypt() <crypto-cipher>`"
msgstr ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.encrypt() <crypto-cipher>`"

#: ../doc/reference/reference_lua/crypto.rst:34
msgid "Encrypt a string"
msgstr "Шифрование строки"

#: ../doc/reference/reference_lua/crypto.rst:37
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.decrypt() <crypto-cipher>`"
msgstr ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.decrypt() <crypto-cipher>`"

#: ../doc/reference/reference_lua/crypto.rst:37
msgid "Decrypt a string"
msgstr "Расшифрование строки"

#: ../doc/reference/reference_lua/crypto.rst:40
msgid ":ref:`crypto.digest.{algorithm}() <crypto-digest>`"
msgstr ":ref:`crypto.digest.{algorithm}() <crypto-digest>`"

#: ../doc/reference/reference_lua/crypto.rst:40
msgid "Get a digest"
msgstr "Получение дайджеста"

#: ../doc/reference/reference_lua/crypto.rst:43
msgid ":ref:`crypto.hmac.{algorithm}() <crypto-hmac>`"
msgstr ":ref:`crypto.hmac.{algorithm}() <crypto-hmac>`"

#: ../doc/reference/reference_lua/crypto.rst:43
msgid "Get a hash key"
msgstr "Получение хеш-ключа"

#: ../doc/reference/reference_lua/crypto.rst:53
msgid ""
"Pass or return a cipher derived from the string, key, and (optionally, "
"sometimes) initialization vector. The four choices of algorithms:"
msgstr ""
"Передача или возврат шифрованного сообщения, полученного из строки, ключа"
" и (необязательно) вектора инициализации. Четыре алгоритма на выбор:"

#: ../doc/reference/reference_lua/crypto.rst:56
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr "aes128 - aes-128 (128-битные двоичные строки с использованием AES)"

#: ../doc/reference/reference_lua/crypto.rst:57
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr "aes192 - aes-192 (192-битные двоичные строки с использованием AES)"

#: ../doc/reference/reference_lua/crypto.rst:58
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr "aes256 - aes-256 (256-битные двоичные строки с использованием AES)"

#: ../doc/reference/reference_lua/crypto.rst:59
msgid ""
"des    - des (with 56-bit binary strings using DES, though DES is not "
"recommended)"
msgstr ""
"des    - des (56-битные двоичные строки с использованием DES, хотя "
"использование DES не рекомендуется)"

#: ../doc/reference/reference_lua/crypto.rst:62
msgid "Four choices of block cipher modes are also available:"
msgstr "Также доступны четыре режима блочного шифрования на выбор:"

#: ../doc/reference/reference_lua/crypto.rst:64
msgid "cbc - Cipher Block Chaining"
msgstr "cbc - Сцепление блоков шифротекста "

#: ../doc/reference/reference_lua/crypto.rst:65
msgid "cfb - Cipher Feedback"
msgstr "cfb - Обратная связь по шифротексту"

#: ../doc/reference/reference_lua/crypto.rst:66
msgid "ecb - Electronic Codebook"
msgstr "ecb - Электронная кодовая книга"

#: ../doc/reference/reference_lua/crypto.rst:67
msgid "ofb - Output Feedback"
msgstr "ofb - Обратная связь по выходу"

#: ../doc/reference/reference_lua/crypto.rst:69
msgid "For more information, read the article about `Encryption Modes`_"
msgstr ""
"Для получения дополнительной информации, см. статью о режимах шифрования "
"`Encryption Modes`_"

#: ../doc/reference/reference_lua/crypto.rst:73
msgid ""
"_16byte_iv='1234567890123456'\n"
"_16byte_pass='1234567890123456'\n"
"e=crypto.cipher.aes128.cbc.encrypt('string', _16byte_pass, _16byte_iv)\n"
"crypto.cipher.aes128.cbc.decrypt(e,  _16byte_pass, _16byte_iv)"
msgstr ""
"_16byte_iv='1234567890123456'\n"
"_16byte_pass='1234567890123456'\n"
"e=crypto.cipher.aes128.cbc.encrypt('string', _16byte_pass, _16byte_iv)\n"
"crypto.cipher.aes128.cbc.decrypt(e,  _16byte_pass, _16byte_iv)"

#: ../doc/reference/reference_lua/crypto.rst:88
msgid ""
"Pass or return a digest derived from the string. The eleven algorithm "
"choices:"
msgstr "Передача или возврат дайджеста из строки. Выбор из одиннадцати алгоритмов:"

#: ../doc/reference/reference_lua/crypto.rst:91
msgid "dss - dss (using DSS)"
msgstr "dss - dss (с использованием DSS)"

#: ../doc/reference/reference_lua/crypto.rst:92
msgid "dss1 - dss (using DSS-1)"
msgstr "dss1 - dss (с использованием DSS-1)"

#: ../doc/reference/reference_lua/crypto.rst:93
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr "md4 - md4 (128-битные двоичные строки с использованием MD4)"

#: ../doc/reference/reference_lua/crypto.rst:94
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr "md5 - md5 (128-битные двоичные строки с использованием MD5)"

#: ../doc/reference/reference_lua/crypto.rst:95
msgid "mdc2 - mdc2 (using MDC2)"
msgstr "mdc2 - mdc2 (с использованием MDC2)"

#: ../doc/reference/reference_lua/crypto.rst:96
msgid "ripemd160 - ripemd (with 160-bit binary strings using RIPEMD-160)"
msgstr ""
"ripemd160 - ripemd (160-битные двоичные строки с использованием "
"RIPEMD-160)"

#: ../doc/reference/reference_lua/crypto.rst:97
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr "sha1 - sha-1 (160-битные двоичные строки с использованием SHA-1)"

#: ../doc/reference/reference_lua/crypto.rst:98
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr "sha224 - sha-224 (224-битные двоичные строки с использованием SHA-2)"

#: ../doc/reference/reference_lua/crypto.rst:99
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr "sha256 - sha-256 (256-битные двоичные строки с использованием SHA-2)"

#: ../doc/reference/reference_lua/crypto.rst:100
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr "sha384 - sha-384 (384-битные двоичные строки с использованием SHA-2)"

#: ../doc/reference/reference_lua/crypto.rst:101
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr "sha512 - sha-512(512-битные двоичные строки с использованием SHA-2)."

#: ../doc/reference/reference_lua/crypto.rst:105
msgid ""
"crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""
"crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"

#: ../doc/reference/reference_lua/crypto.rst:118
msgid ""
"Pass a key and a string. The result is an `HMAC "
"<https://en.wikipedia.org/wiki/HMAC>`_ message authentication code. The "
"eight algorithm choices:"
msgstr ""
"Передача ключа и строки. Результатом будет код аутентификации сообщения "
"`HMAC <https://ru.wikipedia.org/wiki/HMAC>`_. 8 алгоритмов на выбор:"

#: ../doc/reference/reference_lua/crypto.rst:123
msgid "md4 or md4_hex - md4 (with 128-bit binary strings using MD4)"
msgstr "md4 или md4_hex - md4 (128-битные двоичные строки с использованием MD4)"

#: ../doc/reference/reference_lua/crypto.rst:124
msgid "md5 or md5_hex - md5 (with 128-bit binary strings using MD5)"
msgstr "md5 или md5_hex - md5 (128-битные двоичные строки с использованием MD5)"

#: ../doc/reference/reference_lua/crypto.rst:125
msgid ""
"ripemd160 or ripemd160_hex - ripemd (with 160-bit binary strings using "
"RIPEMD-160)"
msgstr ""
"ripemd160 или ripemd160_hex - ripemd (160-битные двоичные строки с "
"использованием RIPEMD-160)"

#: ../doc/reference/reference_lua/crypto.rst:126
msgid "sha1 or sha1_hex - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""
"sha1 или sha1_hex - sha-1 (160-битные двоичные строки с использованием "
"SHA-1)"

#: ../doc/reference/reference_lua/crypto.rst:127
msgid "sha224 or sha224_hex - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""
"sha224 или sha224_hex - sha-224 (224-битные двоичные строки с "
"использованием SHA-2)"

#: ../doc/reference/reference_lua/crypto.rst:128
msgid "sha256 or sha256_hex - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""
"sha256 или sha256_hex - sha-256 (256-битные двоичные строки с "
"использованием SHA-2)"

#: ../doc/reference/reference_lua/crypto.rst:129
msgid "sha384 or sha384_hex - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""
"sha384 или sha384_hex - sha-384 (384-битные двоичные строки с "
"использованием SHA-2)"

#: ../doc/reference/reference_lua/crypto.rst:130
msgid "sha512 or sha512_hex - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""
"sha512 или sha512_hex - sha-512(512-битные двоичные строки с "
"использованием SHA-2)."

#: ../doc/reference/reference_lua/crypto.rst:134
msgid ""
"crypto.hmac.md4('key', 'string')\n"
"crypto.hmac.md4_hex('key', 'string')"
msgstr ""
"crypto.hmac.md4('key', 'string')\n"
"crypto.hmac.md4_hex('key', 'string')"

#: ../doc/reference/reference_lua/crypto.rst:141
msgid "Incremental methods in the crypto module"
msgstr "Инкрементальные методы в модуле ``crypto``"

#: ../doc/reference/reference_lua/crypto.rst:143
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports for all crypto functions."
msgstr ""
"Предположим, что вычислен дайджест для строки 'A', затем часть 'B' "
"добавляется в строку, необходим новый дайджест. Новый дайджест можно "
"пересчитать для всей строки 'AB', но быстрее будет взять вычисленный "
"дайджест для 'A' и внести изменения на основании добавленной части 'B'. "
"Это называется многошаговым процессом или \"инкрементным\" "
"хеш-суммированием, которое поддерживает Tarantool поддерживает для всех "
"криптографических функций."

#: ../doc/reference/reference_lua/crypto.rst:149
msgid ""
"crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"key = 'key/key/key/key/key/key/'\n"
"iv =  'iviviviviviviviv'\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', key, iv))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new(key)\n"
"c:init(nil, iv)\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""
"crypto = require('crypto')\n"
"\n"
"-- вывести дайджест 'AB' по aes-192 пошагово, затем с инкрементом\n"
"key = 'key/key/key/key/key/key/'\n"
"iv =  'iviviviviviviviv'\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', key, iv))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new(key)\n"
"c:init(nil, iv)\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- вывести дайджест 'AB' по sha-256 пошагово, затем с инкрементом\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"

#: ../doc/reference/reference_lua/crypto.rst:175
msgid "Getting the same results from digest and crypto modules"
msgstr "Получение одинаковых результатов из модулей digest и crypto"

#: ../doc/reference/reference_lua/crypto.rst:177
msgid ""
"The following functions are equivalent. For example, the ``digest`` "
"function and the ``crypto`` function will both produce the same result."
msgstr ""
"Следующие функции равноценны. Например, функция ``digest`` и функция "
"``crypto`` приведут к одному результату."

#: ../doc/reference/reference_lua/crypto.rst:180
msgid ""
"crypto.cipher.aes256.cbc.encrypt('x',b32,b16)==digest.aes256cbc.encrypt('x',b32,b16)"
"\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""
"crypto.cipher.aes256.cbc.encrypt('x',b32,b16)==digest.aes256cbc.encrypt('x',b32,b16)"
"\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"

#: ../doc/reference/reference_lua/csv.rst:3
msgid "Module `csv`"
msgstr "Модуль `csv`"

#: ../doc/reference/reference_lua/csv.rst:11
msgid ""
"The ``csv`` module handles records formatted according to Comma-"
"Separated-Values (CSV) rules."
msgstr ""
"Модуль ``csv`` обрабатывает записи, форматированные в соответствии с "
"правилами CSV (значения, разделенные запятыми)."

#: ../doc/reference/reference_lua/csv.rst:14
msgid "The default formatting rules are:"
msgstr "По умолчанию, используются следующие правила форматирования:"

#: ../doc/reference/reference_lua/csv.rst:16
msgid ""
"Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings "
"but not within files,"
msgstr ""
"Escape-последовательности `escape sequences`_ в Lua, такие как \\\\n или "
"\\\\10, можно использовать в строках, но не в файлах,"

#: ../doc/reference/reference_lua/csv.rst:18
msgid "Commas designate end-of-field,"
msgstr "Запятые обозначают конец поля,"

#: ../doc/reference/reference_lua/csv.rst:19
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""
"Символы перевода строки или перевода строки плюс возврата каретки "
"означают конец записи,"

#: ../doc/reference/reference_lua/csv.rst:20
msgid "Leading or trailing spaces are ignored,"
msgstr "Начальные и конечные пробелы игнорируются,"

#: ../doc/reference/reference_lua/csv.rst:21
msgid "Quote marks may enclose fields or parts of fields,"
msgstr "Кавычками могут обрамляться поля или компоненты полей,"

#: ../doc/reference/reference_lua/csv.rst:22
msgid ""
"When enclosed by quote marks, commas and line feeds and spaces are "
"treated as ordinary characters, and a pair of quote marks \"\" is treated"
" as a single quote mark."
msgstr ""
"При обрамлении кавычками запятые, символы перевода строки и пробелы "
"считаются обычными символами, а двойные кавычки \"\" считаются "
"одинарными."

#: ../doc/reference/reference_lua/csv.rst:28
msgid "The possible options which can be passed to csv functions are:"
msgstr "Параметры, которые можно передать в функции модуля ``csv``:"

#: ../doc/reference/reference_lua/csv.rst:30
msgid ""
":samp:`delimiter = {string}` (default: comma) -- single-byte character to"
" designate end-of-field"
msgstr ""
":samp:`delimiter = {строка}` (по умолчанию: запятая) -- однобайтовый "
"символ для обозначения конца поля"

#: ../doc/reference/reference_lua/csv.rst:32
msgid ""
":samp:`quote_char = {string}` (default: quote mark) -- single-byte "
"character to designate encloser of string"
msgstr ""
":samp:`quote_char = {строка}` (по умолчанию: кавычка) -- однобайтовый "
"символ для обозначения закрытия строки"

#: ../doc/reference/reference_lua/csv.rst:34
msgid ""
":samp:`chunk_size = {number}` (default: 4096) -- number of characters to "
"read at once (usually for file-IO efficiency)"
msgstr ""
":samp:`chunk_size = {число}` (по умолчанию: 4096) -- число символов для "
"одновременного чтения (обычно для эффективности файлового ввода-вывода)"

#: ../doc/reference/reference_lua/csv.rst:36
msgid ""
":samp:`skip_head_lines = {number}` (default: 0) -- number of lines to "
"skip at the start (usually for a header)"
msgstr ""
":samp:`skip_head_lines = {число}` (по умолчанию: 0) -- число строк, "
"которые пропускаются в начале (обычно для заголовка)"

#: ../doc/reference/reference_lua/csv.rst:43
msgid "Below is a list of all ``csv`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``csv``."

#: ../doc/reference/reference_lua/csv.rst:53
msgid ":ref:`csv.load() <csv-load>`"
msgstr ":ref:`csv.load() <csv-load>`"

#: ../doc/reference/reference_lua/csv.rst:53
msgid "Load a CSV file"
msgstr "Загрузка CSV-файла"

#: ../doc/reference/reference_lua/csv.rst:56
msgid ":ref:`csv.dump() <csv-dump>`"
msgstr ":ref:`csv.dump() <csv-dump>`"

#: ../doc/reference/reference_lua/csv.rst:56
msgid "Transform input into a CSV-formatted string"
msgstr "Преобразование входного значения в строку формата CSV"

#: ../doc/reference/reference_lua/csv.rst:59
msgid ":ref:`csv.iterate() <csv-iterate>`"
msgstr ":ref:`csv.iterate() <csv-iterate>`"

#: ../doc/reference/reference_lua/csv.rst:59
msgid "Iterate over CSV records"
msgstr "Итерация по записям в формате CSV"

#: ../doc/reference/reference_lua/csv.rst:67
msgid ""
"Get CSV-formatted input from ``readable`` and return a table as output. "
"Usually ``readable`` is either a string or a file opened for reading. "
"Usually :samp:`{options}` is not specified."
msgstr ""
"Получение входного значения в формате CSV из ``readable`` и возврат "
"таблицы в качестве выходного значения. Обычно ``readable`` представляет "
"собой либо строку, либо открытый для чтения файл. Как правило, параметры "
":samp:`{options}` не указываются."

#: ../doc/reference/reference_lua/csv.rst:71
msgid ""
"a string, or any object which has a read() method, formatted according to"
" the CSV rules"
msgstr "строка или любой объект с методом read(), форматированный по правилам CSV "

#: ../doc/reference/reference_lua/csv.rst:73
#: ../doc/reference/reference_lua/csv.rst:199
msgid "see :ref:`above <csv-options>`"
msgstr "см. :ref:`выше <csv-options>`"

#: ../doc/reference/reference_lua/csv.rst:74
msgid "loaded_value"
msgstr "загруженное значение"

#: ../doc/reference/reference_lua/csv.rst:75
#: ../doc/reference/reference_lua/fiber.rst:354
#: ../doc/reference/reference_lua/fio.rst:435
#: ../doc/reference/reference_lua/fio.rst:456
#: ../doc/reference/reference_lua/fio.rst:1042
#: ../doc/reference/reference_lua/http.rst:170
#: ../doc/reference/reference_lua/json.rst:93
#: ../doc/reference/reference_lua/key_def.rst:210
#: ../doc/reference/reference_lua/pickle.rst:136
#: ../doc/reference/reference_lua/socket.rst:173
#: ../doc/reference/reference_lua/socket.rst:561
#: ../doc/reference/reference_lua/socket.rst:573
#: ../doc/reference/reference_lua/string.rst:291
#: ../doc/reference/reference_lua/table.rst:42
#: ../doc/reference/reference_lua/utf8.rst:292
#: ../doc/reference/reference_lua/yaml.rst:58
#: ../doc/reference/reference_rock/membership.rst:181
#: ../doc/reference/reference_rock/membership.rst:190
#: ../doc/reference/reference_rock/membership.rst:203
msgid "table"
msgstr "таблица"

#: ../doc/reference/reference_lua/csv.rst:79
msgid ""
"Readable string has 3 fields, field#2 has comma and space so use quote "
"marks:"
msgstr ""
"В читаемой строке 3 поля, поле №2 содержит запятую и пробел, поэтому "
"следует использовать кавычки:"

#: ../doc/reference/reference_lua/csv.rst:82
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."

#: ../doc/reference/reference_lua/csv.rst:94
msgid ""
"Readable string contains 2-byte character = Cyrillic Letter Palochka: "
"(This displays a palochka if and only if character set = UTF-8.)"
msgstr ""
"В читаемой строке 2-байтный символ = Палочка в кириллице: (Отобразит "
"палочку только в том случае, если кодировка = UTF-8.)"

#: ../doc/reference/reference_lua/csv.rst:97
msgid ""
"tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""
"tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."

#: ../doc/reference/reference_lua/csv.rst:104
msgid "Semicolon instead of comma for the delimiter:"
msgstr "Точка с запятой вместо запятой в виде символа разделителя:"

#: ../doc/reference/reference_lua/csv.rst:106
msgid ""
"tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""
"tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."

#: ../doc/reference/reference_lua/csv.rst:114
msgid ""
"Readable file :file:`./file.csv` contains two CSV records. Explanation of"
" ``fio`` is in section :ref:`fio <fio-section>`. Source CSV file and "
"example respectively:"
msgstr ""
"Читаемый файл :file:`./file.csv` содержит две записи в формате CSV. "
"Объяснение блока ``fio`` дается в разделе :ref:`fio <fio-section>`. "
"Исходный CSV-файл и пример соответственно:"

#: ../doc/reference/reference_lua/csv.rst:118
msgid ""
"tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> -- входное значение в файле file.csv:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/csv.rst:145
msgid ""
"Get table input from ``csv-table`` and return a CSV-formatted string as "
"output. Or, get table input from ``csv-table`` and put the output in "
"``writable``. Usually :samp:`{options}` is not specified. Usually "
"``writable``, if specified, is a file opened for writing. "
":ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-"
"load>`."
msgstr ""
"Получение входного значения из таблицы ``csv-table`` и возврат строки в "
"формате CSV в качестве выходного значения. Или получение входного "
"значения из таблицы ``csv-table`` и размещение выходного значения в "
"``writable``. Обычно параметры :samp:`{options}` не указываются. Как "
"правило, если указан ``writable``, то это открытый для чтения файл. "
":ref:`csv.dump() <csv-dump>` -- это операция, обратная :ref:`csv.load() "
"<csv-load>`."

#: ../doc/reference/reference_lua/csv.rst:151
#: ../doc/reference/reference_lua/csv.rst:197
msgid "a table which can be formatted according to the CSV rules."
msgstr "таблица, которую можно форматировать в соответствии с правилами CSV"

#: ../doc/reference/reference_lua/csv.rst:153
msgid "optional. see :ref:`above <csv-options>`"
msgstr "необязательно. См. :ref:`выше <csv-options>`"

#: ../doc/reference/reference_lua/csv.rst:154
msgid "any object which has a ``write()`` method"
msgstr "любой объект с методом ``write()``"

#: ../doc/reference/reference_lua/csv.rst:156
msgid "dumped_value"
msgstr "записанное значение"

#: ../doc/reference/reference_lua/csv.rst:157
msgid "string, which is written to ``writable`` if specified"
msgstr "строка, которая записывается в объект ``writable``, если указан"

#: ../doc/reference/reference_lua/csv.rst:161
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""
"В таблице формата CSV 3 поля, поле №2 содержит \",\" поэтому результат "
"включает в себя кавычки"

#: ../doc/reference/reference_lua/csv.rst:163
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."

#: ../doc/reference/reference_lua/csv.rst:175
msgid "Round Trip: from string to table and back to string"
msgstr "Круговое преобразование: из строки в таблицу и обратно в строку"

#: ../doc/reference/reference_lua/csv.rst:177
msgid ""
"tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""
"tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."

#: ../doc/reference/reference_lua/csv.rst:193
msgid ""
"Form a Lua iterator function for going through CSV records one field at a"
" time. Use of an iterator is strongly recommended if the amount of data "
"is large (ten or more megabytes)."
msgstr ""
"Создание Lua-функции с итератором для прохода по записям в формате CSV по"
" одному полю за раз. Настоятельно рекомендуется использовать итератор для"
" большого объема данных (10 мегабайт и более)."

#: ../doc/reference/reference_lua/csv.rst:201
msgid "Lua iterator function"
msgstr "Lua-функция с итератором"

#: ../doc/reference/reference_lua/csv.rst:202
msgid "iterator function"
msgstr "функция с итератором"

#: ../doc/reference/reference_lua/csv.rst:206
msgid ""
":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() "
"<csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is"
" a function which is the same as the :ref:`csv.load() <csv-load>` "
"function, as seen in `the Tarantool source code`_."
msgstr ""
":ref:`csv.iterate() <csv-iterate>` -- это :ref:`csv.load() <csv-load>` и "
":ref:`csv.dump() <csv-dump>` низкого уровня. Чтобы это доказать, "
"используем функцию, которая совпадает с функцией  :ref:`csv.load() <csv-"
"load>`, как можно увидеть в исходном коде Tarantool'а (`the Tarantool "
"source code`_)."

#: ../doc/reference/reference_lua/csv.rst:211
msgid ""
"tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""
"tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."

#: ../doc/reference/reference_lua/debug_facilities.rst:5
msgid "Debug facilities"
msgstr "Средства отладки"

#: ../doc/reference/reference_lua/debug_facilities.rst:11
msgid ""
"Tarantool users can benefit from built-in debug facilities that are part "
"of:"
msgstr ""
"Пользователи Tarantool'а могут воспользоваться преимуществами встроенных "
"средств отладки, которые составляют часть:"

#: ../doc/reference/reference_lua/debug_facilities.rst:13
msgid ""
"Lua (`debug <https://www.lua.org/manual/5.1/manual.html#5.9>`_ library, "
"see details below) and"
msgstr ""
"Lua (библиотека `отладки "
"<https://www.lua.org/manual/5.1/manual.html#5.9>`_, см. подробное "
"описание ниже) и"

#: ../doc/reference/reference_lua/debug_facilities.rst:15
msgid "LuaJit (`debug.* <http://luajit.org/extensions.html>`_ functions)."
msgstr "LuaJit (функции отладки `debug.* <http://luajit.org/extensions.html>`_)."

#: ../doc/reference/reference_lua/debug_facilities.rst:19
msgid ""
"The ``debug`` library provides an interface for debugging Lua programs. "
"All functions in this library reside in the ``debug`` table. Those "
"functions that operate on a thread have an optional first parameter that "
"specifies the thread to operate on. The default is always the current "
"thread."
msgstr ""
"Библиотека ``debug`` предоставляет интерфейс для отладки Lua-программ. "
"Все функции этой библиотеки содержатся в таблице ``debug``. В функциях "
"для работы с потоками есть дополнительный первый параметр, в котором "
"указывается необходимый поток. По умолчанию, это всегда текущий поток."

#: ../doc/reference/reference_lua/debug_facilities.rst:26
msgid ""
"This library should be used only for debugging and profiling and not as a"
" regular programming tool, as the functions provided here can take too "
"long to run. Besides, several of these functions can compromise otherwise"
" secure code."
msgstr ""
"Библиотеку следует использовать только для отладки и профилирования, а не"
" в качестве программного средства, поскольку данные функции выполняются "
"слишком долго. Кроме того, некоторые из этих функций могут привести к "
"нарушению работы безопасного в других отношениях кода."

#: ../doc/reference/reference_lua/debug_facilities.rst:35
msgid "Below is a list of all ``debug`` functions."
msgstr "Ниже приведен перечень всех функций библиотеки ``debug``."

#: ../doc/reference/reference_lua/debug_facilities.rst:45
msgid ":ref:`debug.debug() <debug-debug>`"
msgstr ":ref:`debug.debug() <debug-debug>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:45
msgid "Enter an interactive mode"
msgstr "Вход в интерактивный режим"

#: ../doc/reference/reference_lua/debug_facilities.rst:48
msgid ":ref:`debug.getfenv() <debug-getfenv>`"
msgstr ":ref:`debug.getfenv() <debug-getfenv>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:48
msgid "Get an object's environment"
msgstr "Получение среды объекта"

#: ../doc/reference/reference_lua/debug_facilities.rst:51
msgid ":ref:`debug.gethook() <debug-gethook>`"
msgstr ":ref:`debug.gethook() <debug-gethook>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:51
msgid "Get a thread's current hook settings"
msgstr "Получение текущих настроек ловушки потока"

#: ../doc/reference/reference_lua/debug_facilities.rst:54
msgid ":ref:`debug.getinfo() <debug-getinfo>`"
msgstr ":ref:`debug.getinfo() <debug-getinfo>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:54
msgid "Get information about a function"
msgstr "Получение информации о функции"

#: ../doc/reference/reference_lua/debug_facilities.rst:57
msgid ":ref:`debug.getlocal() <debug-getlocal>`"
msgstr ":ref:`debug.getlocal() <debug-getlocal>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:57
msgid "Get a local variable's name and value"
msgstr "Получение имени и значения локальной переменной"

#: ../doc/reference/reference_lua/debug_facilities.rst:60
msgid ":ref:`debug.getmetatable() <debug-getmetatable>`"
msgstr ":ref:`debug.getmetatable() <debug-getmetatable>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:60
msgid "Get an object's metatable"
msgstr "Получение метатаблицы объекта"

#: ../doc/reference/reference_lua/debug_facilities.rst:63
msgid ":ref:`debug.getregistry() <debug-getregistry>`"
msgstr ":ref:`debug.getregistry() <debug-getregistry>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:63
msgid "Get the registry table"
msgstr "Получение таблицы реестра"

#: ../doc/reference/reference_lua/debug_facilities.rst:66
msgid ":ref:`debug.getupvalue() <debug-getupvalue>`"
msgstr ":ref:`debug.getupvalue() <debug-getupvalue>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:66
msgid "Get an upvalue's name and value"
msgstr "Получение имени и значения сопоставляющего значения"

#: ../doc/reference/reference_lua/debug_facilities.rst:69
msgid ":ref:`debug.setfenv() <debug-setfenv>`"
msgstr ":ref:`debug.setfenv() <debug-setfenv>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:69
msgid "Set an object's environment"
msgstr "Определение среды объекта"

#: ../doc/reference/reference_lua/debug_facilities.rst:72
msgid ":ref:`debug.sethook() <debug-sethook>`"
msgstr ":ref:`debug.sethook() <debug-sethook>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:72
msgid "Set a given function as a hook"
msgstr "Определение данной функции в качестве ловушки"

#: ../doc/reference/reference_lua/debug_facilities.rst:75
msgid ":ref:`debug.setlocal() <debug-setlocal>`"
msgstr ":ref:`debug.setlocal() <debug-setlocal>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:75
msgid "Assign a value to a local variable"
msgstr "Присваивание значения локальной переменной"

#: ../doc/reference/reference_lua/debug_facilities.rst:78
msgid ":ref:`debug.setmetatable() <debug-setmetatable>`"
msgstr ":ref:`debug.setmetatable() <debug-setmetatable>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:78
msgid "Set an object's metatable"
msgstr "Определение метатаблицы объекта"

#: ../doc/reference/reference_lua/debug_facilities.rst:81
msgid ":ref:`debug.setupvalue() <debug-setupvalue>`"
msgstr ":ref:`debug.setupvalue() <debug-setupvalue>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:81
msgid "Assign a value to an upvalue"
msgstr "Присваивание значения сопоставляющему значению"

#: ../doc/reference/reference_lua/debug_facilities.rst:84
#, fuzzy
msgid ":ref:`debug.sourcedir() <debug-sourcedir>`"
msgstr ":ref:`debug.traceback() <debug-traceback>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:84
#, fuzzy
msgid "Get the source directory name"
msgstr "Получение имени директории"

#: ../doc/reference/reference_lua/debug_facilities.rst:87
#, fuzzy
msgid ":ref:`debug.sourcefile() <debug-sourcefile>`"
msgstr ":ref:`debug.setfenv() <debug-setfenv>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:87
#, fuzzy
msgid "Get the source file name"
msgstr "Получение имени файла"

#: ../doc/reference/reference_lua/debug_facilities.rst:90
msgid ":ref:`debug.traceback() <debug-traceback>`"
msgstr ":ref:`debug.traceback() <debug-traceback>`"

#: ../doc/reference/reference_lua/debug_facilities.rst:90
msgid "Get a traceback of the call stack"
msgstr "Получение обратной трассировки стека вызовов"

#: ../doc/reference/reference_lua/debug_facilities.rst:99
msgid ""
"Enters an interactive mode and runs each string that the user types in. "
"The user can, among other things, inspect global and local variables, "
"change their values and evaluate expressions."
msgstr ""
"Вход в интерактивный режим и выполнение каждой строки, которую печатает "
"пользователь. Пользователь может, в частности, проверять глобальные и "
"локальные переменные, изменять их значения и вычислять выражения."

#: ../doc/reference/reference_lua/debug_facilities.rst:103
msgid ""
"Enter ``cont`` to exit this function, so that the caller can continue its"
" execution."
msgstr ""
"Введите ``cont`` для выхода из данной функции, чтобы вызывающий клиент "
"мог продолжить выполнение."

#: ../doc/reference/reference_lua/debug_facilities.rst:108
msgid ""
"Commands for ``debug.debug()`` are not lexically nested within any "
"function and so have no direct access to local variables."
msgstr ""
"Команды для ``debug.debug()`` не вложены лексически в какую-либо функцию,"
" поэтому у них нет прямого доступа к локальным переменным."

#: ../doc/reference/reference_lua/debug_facilities.rst:115
msgid "object to get the environment of"
msgstr "объект, для которого будет получена среда"

#: ../doc/reference/reference_lua/debug_facilities.rst:118
msgid "the environment of the ``object``"
msgstr "среда объекта ``object``"

#: ../doc/reference/reference_lua/debug_facilities.rst:124
msgid "the current hook settings of the ``thread`` as three values:"
msgstr "текущие настройки ловушки потока ``thread`` в виде трех значений:"

#: ../doc/reference/reference_lua/debug_facilities.rst:126
msgid "the current hook function"
msgstr "текущая функция-ловушка"

#: ../doc/reference/reference_lua/debug_facilities.rst:127
msgid "the current hook mask"
msgstr "текущая маска ловушки"

#: ../doc/reference/reference_lua/debug_facilities.rst:128
msgid "the current hook count as set by the ``debug.sethook()`` function"
msgstr "текущий счетчик ловушки, как определяет функция  ``debug.sethook()``"

#: ../doc/reference/reference_lua/debug_facilities.rst:134
msgid "function to get information on"
msgstr "функция, по которой будет получена информация"

#: ../doc/reference/reference_lua/debug_facilities.rst:136
msgid "what information on the ``function`` to return"
msgstr "какую информацию о функции ``function`` вернуть"

#: ../doc/reference/reference_lua/debug_facilities.rst:138
msgid "a table with information about the ``function``"
msgstr "таблица с информацией о функции ``function``"

#: ../doc/reference/reference_lua/debug_facilities.rst:140
msgid ""
"You can pass in a ``function`` directly, or you can give a number that "
"specifies a function running at level ``function`` of the call stack of "
"the given ``thread``: level 0 is the current function (``getinfo()`` "
"itself), level 1 is the function that called ``getinfo()``, and so on. If"
" ``function`` is a number larger than the number of active functions, "
"``getinfo()`` returns ``nil``."
msgstr ""
"Можно передать функцию ``function`` напрямую или же передать число, "
"которое указывает на функцию, выполняемую на уровне ``function`` стека "
"вызовов данного потока ``thread``: уровень 0 -- это текущая функция (сама"
" функция ``getinfo()``), уровень 1 -- это функция, которая вызвала "
"``getinfo()``, и т.д. Если для функции ``function`` указано число больше "
"числа активных функций, ``getinfo()`` вернет ``nil``."

#: ../doc/reference/reference_lua/debug_facilities.rst:147
msgid ""
"The default for ``what`` is to get all information available, except the "
"table of valid lines. If present, the option ``f`` adds a field named "
"``func`` with the function itself. If present, the option ``L`` adds a "
"field named ``activelines`` with the table of valid lines."
msgstr ""
"По умолчанию, ``what`` -- это вся доступная информация, кроме таблицы "
"допустимых строк. Если задать опцию ``f``, добавится поле под названием "
"``func`` с самой функцией. Если задать опцию ``L``, добавится поле под "
"названием ``activelines`` с таблицей доступных строк."

#: ../doc/reference/reference_lua/debug_facilities.rst:156
#: ../doc/reference/reference_lua/debug_facilities.rst:233
msgid "level of the stack"
msgstr "уровень стека"

#: ../doc/reference/reference_lua/debug_facilities.rst:157
#: ../doc/reference/reference_lua/debug_facilities.rst:234
msgid "index of the local variable"
msgstr "индекс локальной переменной"

#: ../doc/reference/reference_lua/debug_facilities.rst:159
msgid ""
"the name and the value of the local variable with the index ``local`` of "
"the function at level ``level`` of the stack or ``nil`` if there is no "
"local variable with the given index; raises an error if ``level`` is out "
"of range"
msgstr ""
"имя и значение локальной переменной с индексом ``local`` функции на "
"уровне ``level`` стека или ``nil``, если нет локальной переменной с "
"указанным индексом; появится ошибка, если уровень ``level`` вне диапазона"

#: ../doc/reference/reference_lua/debug_facilities.rst:166
#: ../doc/reference/reference_lua/debug_facilities.rst:244
msgid "You can call ``debug.getinfo()`` to check whether the level is valid."
msgstr "Можно вызвать ``debug.getinfo()`` для проверки доступности уровня."

#: ../doc/reference/reference_lua/debug_facilities.rst:172
msgid "object to get the metatable of"
msgstr "объект, для которого будет получена метатаблица"

#: ../doc/reference/reference_lua/debug_facilities.rst:175
msgid "a metatable of the ``object`` or ``nil`` if it does not have a metatable"
msgstr "метатаблица объекта ``object`` или ``nil``, если метатаблица отсутствует"

#: ../doc/reference/reference_lua/debug_facilities.rst:182
msgid "the registry table"
msgstr "таблица реестра"

#: ../doc/reference/reference_lua/debug_facilities.rst:188
msgid "function to get the upvalue of"
msgstr "функция, для которой будет получено сопоставляющее значение"

#: ../doc/reference/reference_lua/debug_facilities.rst:189
#: ../doc/reference/reference_lua/debug_facilities.rst:264
msgid "index of the function upvalue"
msgstr "индекс сопоставляющего значения функции"

#: ../doc/reference/reference_lua/debug_facilities.rst:191
msgid ""
"the name and the value of the upvalue with the index ``up`` of the "
"function ``func`` or ``nil`` if there is no upvalue with the given index"
msgstr ""
"имя и значение сопоставляющего значения с индексом ``up`` функции "
"``func`` или ``nil``, если нет сопоставляющего значения в пределах "
"заданного индекса"

#: ../doc/reference/reference_lua/debug_facilities.rst:199
msgid "Sets the environment of the ``object`` to the ``table``."
msgstr "Определение среды объекта ``object`` для таблицы ``table``."

#: ../doc/reference/reference_lua/debug_facilities.rst:201
msgid "object to change the environment of"
msgstr "объект, среда которого будет изменена"

#: ../doc/reference/reference_lua/debug_facilities.rst:203
msgid "table to set the object environment to"
msgstr "таблица для определения среды объекта"

#: ../doc/reference/reference_lua/debug_facilities.rst:205
msgid "the ``object``"
msgstr "объект ``object``"

#: ../doc/reference/reference_lua/debug_facilities.rst:211
msgid ""
"Sets the given function as a hook.  When called without arguments, turns "
"the hook off."
msgstr ""
"Определение данной функции в качестве ловушки. При вызове без аргументов "
"ловушка отключается."

#: ../doc/reference/reference_lua/debug_facilities.rst:214
msgid "function to set as a hook"
msgstr "функция, которая будет определена в качестве ловушки"

#: ../doc/reference/reference_lua/debug_facilities.rst:215
msgid ""
"describes when the ``hook`` will be called; may have the following "
"values:  * ``c`` - the ``hook`` is called every time Lua calls a function"
" * ``r`` - the ``hook`` is called every time Lua returns from a function "
"* ``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""
"описание того, когда будет вызвана ловушка ``hook``; может принимать "
"следующие значения:  * ``c`` -- ловушка``hook`` вызывается каждый раз, "
"когда Lua вызывает функцию * ``r`` -- ловушка ``hook`` вызывается каждый "
"раз, когда Lua возвращается из функции * ``l`` -- ловушка ``hook`` "
"вызывается каждый раз, когда Lua переходит на новую строку кода"

#: ../doc/reference/reference_lua/debug_facilities.rst:215
msgid "describes when the ``hook`` will be called; may have the following values:"
msgstr ""
"описание того, когда будет вызвана ловушка ``hook``; может принимать "
"следующие значения:"

#: ../doc/reference/reference_lua/debug_facilities.rst:218
msgid "``c`` - the ``hook`` is called every time Lua calls a function"
msgstr "``c`` -- ловушка``hook`` вызывается каждый раз, когда Lua вызывает функцию"

#: ../doc/reference/reference_lua/debug_facilities.rst:219
msgid "``r`` - the ``hook`` is called every time Lua returns from a function"
msgstr ""
"``r`` -- ловушка ``hook`` вызывается каждый раз, когда Lua возвращается "
"из функции"

#: ../doc/reference/reference_lua/debug_facilities.rst:220
msgid "``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""
"``l`` -- ловушка ``hook`` вызывается каждый раз, когда Lua переходит на "
"новую строку кода"

#: ../doc/reference/reference_lua/debug_facilities.rst:222
msgid ""
"describes when the ``hook`` will be called; when different from zero, the"
" ``hook`` is called after every ``count`` instructions."
msgstr ""
"описание того, когда будет вызвана ловушка ``hook``; если отличается от "
"нуля, ловушка ``hook`` вызывается после каждой инструкции ``count``."

#: ../doc/reference/reference_lua/debug_facilities.rst:230
msgid ""
"Assigns the value ``value`` to the local variable with the index "
"``local`` of the function at level ``level`` of the stack."
msgstr ""
"Присвоение значения ``value`` локальной переменной с индексом ``local`` "
"функции на уровне ``level`` стека"

#: ../doc/reference/reference_lua/debug_facilities.rst:235
msgid "value to assign to the local variable"
msgstr "значение, присваиваемое локальной переменной"

#: ../doc/reference/reference_lua/debug_facilities.rst:238
msgid ""
"the name of the local variable or ``nil`` if there is no local variable "
"with the given index; raises an error if ``level`` is out of range"
msgstr ""
"имя локальной переменной или ``nil``, если локальная переменная с "
"заданным индексом отсутствует; возникает ошибка, если уровень ``level`` "
"вне диапазона"

#: ../doc/reference/reference_lua/debug_facilities.rst:250
msgid "Sets the metatable of the ``object`` to the ``table``."
msgstr "Определение метатаблицы объекта ``object`` для таблицы ``table``."

#: ../doc/reference/reference_lua/debug_facilities.rst:252
msgid "object to change the metatable of"
msgstr "объект, метатаблица которого будет изменена"

#: ../doc/reference/reference_lua/debug_facilities.rst:254
msgid "table to set the object metatable to"
msgstr "таблица для определения метатаблицы объекта"

#: ../doc/reference/reference_lua/debug_facilities.rst:260
msgid ""
"Assigns the value ``value`` to the upvalue with the index ``up`` of the "
"function ``func``."
msgstr ""
"Присвоение значения ``value`` сопоставляющему значению с индексом ``up`` "
"функции ``func``."

#: ../doc/reference/reference_lua/debug_facilities.rst:263
msgid "function to set the upvalue of"
msgstr "функция, для которой будет определено сопоставляющее значение"

#: ../doc/reference/reference_lua/debug_facilities.rst:265
msgid "value to assign to the function upvalue"
msgstr "значение, присваиваемое сопоставляющему значению функции"

#: ../doc/reference/reference_lua/debug_facilities.rst:268
msgid ""
"the name of the upvalue or ``nil`` if there is no upvalue with the given "
"index"
msgstr ""
"имя сопоставляющего значения или ``nil``, если сопоставляющее значение с "
"данным индексом отсутствует"

#: ../doc/reference/reference_lua/debug_facilities.rst:275
#: ../doc/reference/reference_lua/debug_facilities.rst:294
msgid "the level of the call stack which should contain the path (default is 2)"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:278
msgid "a string with the relative path to the source file directory"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:280
msgid ""
"Instead of ``debug.sourcedir()`` one can say ``debug.__dir__`` which "
"means the same thing."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:282
msgid ""
"Determining the real path to a directory is only possible if the function"
" was defined in a Lua file (this restriction may not apply for "
"`loadstring() <https://www.lua.org/pil/8.html>`_ since Lua will store the"
" entire string in debug info)."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:287
msgid ""
"If ``debug.sourcedir()`` is part of a ``return`` argument, then it should"
" be inside parentheses: ``return (debug.sourcedir())``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:297
msgid "a string with the relative path to the source file"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:299
msgid ""
"Instead of ``debug.sourcefile()`` one can say ``debug.__file__`` which "
"means the same thing."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:301
msgid ""
"Determining the real path to a file is only possible if the function was "
"defined in a Lua file (this restriction may not apply to ``loadstring()``"
" since Lua will store the entire string in debug info)."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:306
msgid ""
"If ``debug.sourcefile()`` is part of a ``return`` argument, then it "
"should be inside parentheses: ``return (debug.sourcefile())``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:313
msgid "an optional message prepended to the traceback"
msgstr "необязательное сообщение, добавленное к началу обратной трассировки"

#: ../doc/reference/reference_lua/debug_facilities.rst:314
msgid "specifies at which level to start the traceback (default is 1)"
msgstr "указывает на каком уровне начинать обратную трассировку (по умолчанию, 1)"

#: ../doc/reference/reference_lua/debug_facilities.rst:317
msgid "a string with a traceback of the call stack"
msgstr "строка с обратной трассировкой стека вызовов"

#: ../doc/reference/reference_lua/debug_facilities.rst:319
#, fuzzy
msgid "**Debug example:**"
msgstr "**Пример:**"

#: ../doc/reference/reference_lua/debug_facilities.rst:321
msgid "Make a file in the /tmp directory named example.lua, containing:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:323
msgid ""
"function w()\n"
"  print(debug.sourcedir())\n"
"  print(debug.sourcefile())\n"
"  print(debug.traceback())\n"
"  print(debug.getinfo(1)['currentline'])\n"
"end\n"
"w()"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:333
msgid "Execute ``tarantool /tmp/example.lua``. Expect to see this:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:335
msgid ""
"/tmp\n"
"/tmp/example.lua\n"
"stack traceback:\n"
"    /tmp/example.lua:4: in function 'w'\n"
"    /tmp/example.lua:7: in main chunk\n"
"5"
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:5
#, fuzzy
msgid "Module `decimal`"
msgstr "Модуль `yaml`"

#: ../doc/reference/reference_lua/decimal.rst:9
msgid ""
"The ``decimal`` module has functions for working with exact numbers. This"
" is important when numbers are large or even the slighest inaccuracy is "
"unacceptable. For example Lua calculates ``0.16666666666667 * 6`` with "
"floating-point so the result is 1. But with the decimal module (using "
"``decimal.new`` to convert the number to decimal type) "
"``decimal.new('0.16666666666667') * 6`` is 1.00000000000002."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:18
msgid ""
"To construct a decimal number, bring in the module with "
"``require('decimal')`` and then use ``decimal.new(n)`` or any function in"
" the decimal module: :ref:`abs(n) <decimal-abs>` :ref:`exp(n) <decimal-"
"exp>` :ref:`ln(n) <decimal-ln>` :ref:`log10(n) <decimal-log10>` "
":ref:`new(n) <decimal-new>` :ref:`precision(n) <decimal-precision>` "
":ref:`rescale(decimal-number, new-scale) <decimal-rescale>` "
":ref:`scale(n) <decimal-scale>` :ref:`sqrt(n) <decimal-sqrt>` :ref:`trim"
"(decimal-number) <decimal-trim>`, where n can be a string or a non-"
"decimal number or a decimal number. If it is a string or a non-decimal "
"number, Tarantool converts it to a decimal number before working with it."
" It is best to construct from strings, and to convert back to strings "
"after calculations, because Lua numbers have only 15 digits of precision."
" Decimal numbers have 38 digits of precision, that is, the total number "
"of digits before and after the decimal point can be 38. Tarantool "
"supports the usual arithmetic and comparison operators + - * / % ^ < > <="
" >= ~= ==. If an operation has both decimal and non-decimal operands, "
"then the non-decimal operand is converted to decimal before the operation"
" happens."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:46
msgid "Use ``tostring(decimal-number)`` to convert back to a string."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:48
msgid ""
"A decimal operation will fail if overflow happens (when a number is "
"greater than 10^38 - 1 or less than -10^38 - 1). A decimal operation will"
" fail if arithmetic is impossible (such as division by zero or square "
"root of minus 1). A decimal operation will not fail if rounding of post-"
"decimal digits is necessary to get 38-digit precision."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:59
msgid ""
"Returns absolute value of a decimal number. For example if a is -1 then "
"``decimal.abs(a)`` returns 1."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:66
msgid ""
"Returns *e* raised to the power of a decimal number. For example if a is "
"1 then ``decimal.exp(a)`` returns "
"2.7182818284590452353602874713526624978. Compare ``math.exp(1)`` from the"
" `Lua math library <https://www.lua.org/pil/18.html>`_, which returns "
"2.718281828459."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:77
msgid ""
"Returns natural logarithm of a decimal number. For example if a is 1 then"
" ``decimal.ln(a)`` returns 0."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:84
msgid ""
"Returns base-10 logarithm of a decimal number. For example if a is 100 "
"then ``decimal.log10(a)`` returns 2."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:91
msgid ""
"Returns the value of the input as a decimal number. For example if a is "
"1E-1 then ``decimal.new(a)`` returns 0.1."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:99
msgid ""
"Returns the number of digits in a decimal number. For example if a is "
"123.4560 then ``decimal.precision(a)`` returns 7."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:106
msgid ""
"Returns the number after possible rounding or padding. If the number of "
"post-decimal digits is greater than new-scale, then rounding occurs. The "
"rounding rule is: round half away from zero. If the number of post-"
"decimal digits is less than new-scale, then padding of zeros occurs. For "
"example if a is -123.4550 then ``decimal.rescale(a, 2)`` returns -123.46,"
" and ``decimal.rescale(a, 5)`` returns -123.45500."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:118
msgid ""
"Returns the number of post-decimal digits in a decimal number. For "
"example if a is 123.4560 then ``decimal.scale(a)`` returns 4."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:125
msgid ""
"Returns the square root of a decimal number. For example if a is 2 then "
"``decimal.sqrt(a)`` returns 1.4142135623730950488016887242096980786."
msgstr ""

#: ../doc/reference/reference_lua/decimal.rst:133
msgid ""
"Returns a decimal number after possible removing of trailing post-decimal"
" zeros. For example if a is 2.20200 then ``decimal.trim(a)`` returns "
"2.202."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:5
msgid "Module `digest`"
msgstr "Модуль `digest`"

#: ../doc/reference/reference_lua/digest.rst:13
msgid ""
"A \"digest\" is a value which is returned by a function (usually a "
"`Cryptographic hash function`_), applied against a string. Tarantool's "
"``digest`` module supports several types of cryptographic hash functions "
"(AES_, MD4_, MD5_, SHA-1_, SHA-2_, PBKDF2_) as well as a checksum "
"function (CRC32_), two functions for base64_, and two non-cryptographic "
"hash functions (guava_, murmur_). Some of the digest functionality is "
"also present in the :ref:`crypto <crypto>`."
msgstr ""
"\"Дайджест\" -- это значение, которое возвращает функция (как правило, "
"криптографическая хеш-функция -- `Cryptographic hash function`_), "
"примененная к строке. Модуль``digest`` Tarantool'а поддерживает несколько"
" типов криптографических хеш-функций  (AES_, MD4_, MD5_, SHA-1_, SHA-2_, "
"PBKDF2_), а также функцию контрольного суммирования (CRC32_), две функции"
" для base64_ и две некриптографические хеш-функции (guava_, murmur_). "
"Часть функций модуля digest также включена в модуль :ref:`crypto "
"<crypto>`."

#: ../doc/reference/reference_lua/digest.rst:24
msgid "Below is a list of all ``digest`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``digest``."

#: ../doc/reference/reference_lua/digest.rst:34
msgid ":ref:`digest.aes256cbc.encrypt() <digest-aes>`"
msgstr ":ref:`digest.aes256cbc.encrypt() <digest-aes>`"

#: ../doc/reference/reference_lua/digest.rst:34
msgid "Encrypt a string using AES"
msgstr "Шифрование строки с использованием AES"

#: ../doc/reference/reference_lua/digest.rst:37
msgid ":ref:`digest.aes256cbc.decrypt() <digest-aes>`"
msgstr ":ref:`digest.aes256cbc.decrypt() <digest-aes>`"

#: ../doc/reference/reference_lua/digest.rst:37
msgid "Decrypt a string using AES"
msgstr "Расшифрование строки с использованием AES"

#: ../doc/reference/reference_lua/digest.rst:40
msgid ":ref:`digest.md4() <digest-md4>`"
msgstr ":ref:`digest.md4() <digest-md4>`"

#: ../doc/reference/reference_lua/digest.rst:40
msgid "Get a digest made with MD4"
msgstr "Получение дайджеста с помощью MD4"

#: ../doc/reference/reference_lua/digest.rst:43
msgid ":ref:`digest.md4_hex() <digest-md4_hex>`"
msgstr ":ref:`digest.md4_hex() <digest-md4_hex>`"

#: ../doc/reference/reference_lua/digest.rst:43
msgid "Get a hexadecimal digest made with MD4"
msgstr "Получение шестнадцатеричного дайджеста с помощью MD4"

#: ../doc/reference/reference_lua/digest.rst:46
msgid ":ref:`digest.md5() <digest-md5>`"
msgstr ":ref:`digest.md5() <digest-md5>`"

#: ../doc/reference/reference_lua/digest.rst:46
msgid "Get a digest made with MD5"
msgstr "Получение дайджеста с помощью MD5"

#: ../doc/reference/reference_lua/digest.rst:49
msgid ":ref:`digest.md5_hex() <digest-md5_hex>`"
msgstr ":ref:`digest.md5_hex() <digest-md5_hex>`"

#: ../doc/reference/reference_lua/digest.rst:49
msgid "Get a hexadecimal digest made with MD5"
msgstr "Получение шестнадцатеричного дайджеста с помощью MD5"

#: ../doc/reference/reference_lua/digest.rst:52
msgid ":ref:`digest.pbkdf2() <digest-pbkdf2>`"
msgstr ":ref:`digest.pbkdf2() <digest-pbkdf2>`"

#: ../doc/reference/reference_lua/digest.rst:52
msgid "Get a digest made with PBKDF2"
msgstr "Получение дайджеста с помощью PBKDF2"

#: ../doc/reference/reference_lua/digest.rst:55
msgid ":ref:`digest.sha1() <digest-sha1>`"
msgstr ":ref:`digest.sha1() <digest-sha1>`"

#: ../doc/reference/reference_lua/digest.rst:55
msgid "Get a digest made with SHA-1"
msgstr "Получение дайджеста с помощью SHA-1"

#: ../doc/reference/reference_lua/digest.rst:58
msgid ":ref:`digest.sha1_hex() <digest-sha1_hex>`"
msgstr ":ref:`digest.sha1_hex() <digest-sha1_hex>`"

#: ../doc/reference/reference_lua/digest.rst:58
msgid "Get a hexadecimal digest made with SHA-1"
msgstr "Получение шестнадцатеричного дайджеста с помощью SHA-1"

#: ../doc/reference/reference_lua/digest.rst:61
msgid ":ref:`digest.sha224() <digest-sha224>`"
msgstr ":ref:`digest.sha224() <digest-sha224>`"

#: ../doc/reference/reference_lua/digest.rst:61
msgid "Get a 224-bit digest made with SHA-2"
msgstr "Получение 224-битного дайджеста с помощью SHA-2"

#: ../doc/reference/reference_lua/digest.rst:64
msgid ":ref:`digest.sha224_hex() <digest-sha224_hex>`"
msgstr ":ref:`digest.sha224_hex() <digest-sha224_hex>`"

#: ../doc/reference/reference_lua/digest.rst:64
msgid "Get a 56-byte hexadecimal digest made with SHA-2"
msgstr "Получение 56-байтного шестнадцатеричного дайджеста с помощью SHA-2"

#: ../doc/reference/reference_lua/digest.rst:67
msgid ":ref:`digest.sha256() <digest-sha256>`"
msgstr ":ref:`digest.sha256() <digest-sha256>`"

#: ../doc/reference/reference_lua/digest.rst:67
msgid "Get a 256-bit digest made with SHA-2"
msgstr "Получение 256-битного дайджеста с помощью SHA-2"

#: ../doc/reference/reference_lua/digest.rst:70
msgid ":ref:`digest.sha256_hex() <digest-sha256_hex>`"
msgstr ":ref:`digest.sha256_hex() <digest-sha256_hex>`"

#: ../doc/reference/reference_lua/digest.rst:70
msgid "Get a 64-byte hexadecimal digest made with SHA-2"
msgstr "Получение 64-байтного шестнадцатеричного дайджеста с помощью SHA-2"

#: ../doc/reference/reference_lua/digest.rst:73
msgid ":ref:`digest.sha384() <digest-sha384>`"
msgstr ":ref:`digest.sha384() <digest-sha384>`"

#: ../doc/reference/reference_lua/digest.rst:73
msgid "Get a 384-bit digest made with SHA-2"
msgstr "Получение 384-битного дайджеста с помощью SHA-2"

#: ../doc/reference/reference_lua/digest.rst:76
msgid ":ref:`digest.sha384_hex() <digest-sha384_hex>`"
msgstr ":ref:`digest.sha384_hex() <digest-sha384_hex>`"

#: ../doc/reference/reference_lua/digest.rst:76
msgid "Get a 96-byte hexadecimal digest made with SHA-2"
msgstr "Получение 96-байтного шестнадцатеричного дайджеста с помощью SHA-2"

#: ../doc/reference/reference_lua/digest.rst:79
msgid ":ref:`digest.sha512() <digest-sha512>`"
msgstr ":ref:`digest.sha512() <digest-sha512>`"

#: ../doc/reference/reference_lua/digest.rst:79
msgid "Get a 512-bit digest made with SHA-2"
msgstr "Получение 512-битного дайджеста с помощью SHA-2"

#: ../doc/reference/reference_lua/digest.rst:82
msgid ":ref:`digest.sha512_hex() <digest-sha512_hex>`"
msgstr ":ref:`digest.sha512_hex() <digest-sha512_hex>`"

#: ../doc/reference/reference_lua/digest.rst:82
msgid "Get a 128-byte hexadecimal digest made with SHA-2"
msgstr "Получение 128-байтного шестнадцатеричного дайджеста с помощью SHA-2"

#: ../doc/reference/reference_lua/digest.rst:85
msgid ":ref:`digest.base64_encode() <digest-base64_encode>`"
msgstr ":ref:`digest.base64_encode() <digest-base64_encode>`"

#: ../doc/reference/reference_lua/digest.rst:85
msgid "Encode a string to Base64"
msgstr "Кодирование строки по стандарту Base64"

#: ../doc/reference/reference_lua/digest.rst:88
msgid ":ref:`digest.base64_decode() <digest-base64_decode>`"
msgstr ":ref:`digest.base64_decode() <digest-base64_decode>`"

#: ../doc/reference/reference_lua/digest.rst:88
msgid "Decode a Base64-encoded string"
msgstr "Декодирование строки по стандарту Base64"

#: ../doc/reference/reference_lua/digest.rst:91
msgid ":ref:`digest.urandom() <digest-urandom>`"
msgstr ":ref:`digest.urandom() <digest-urandom>`"

#: ../doc/reference/reference_lua/digest.rst:91
msgid "Get an array of random bytes"
msgstr "Получение массива случайных байтов"

#: ../doc/reference/reference_lua/digest.rst:94
msgid ":ref:`digest.crc32() <digest-crc32>`"
msgstr ":ref:`digest.crc32() <digest-crc32>`"

#: ../doc/reference/reference_lua/digest.rst:94
msgid "Get a 32-bit checksum made with CRC32"
msgstr "Получение 32-битной контрольной суммы с помощью CRC32"

#: ../doc/reference/reference_lua/digest.rst:97
msgid ":ref:`digest.crc32.new() <digest-crc32_new>`"
msgstr ":ref:`digest.crc32.new() <digest-crc32_new>`"

#: ../doc/reference/reference_lua/digest.rst:97
msgid "Initiate incremental CRC32"
msgstr "Запуск инкрементного вычисления CRC32"

#: ../doc/reference/reference_lua/digest.rst:100
msgid ":ref:`digest.guava() <digest-guava>`"
msgstr ":ref:`digest.guava() <digest-guava>`"

#: ../doc/reference/reference_lua/digest.rst:100
msgid "Get a number made with a consistent hash"
msgstr "Получение числа с помощью консистентного хеширования"

#: ../doc/reference/reference_lua/digest.rst:103
msgid ":ref:`digest.murmur() <digest-murmur>`"
msgstr ":ref:`digest.murmur() <digest-murmur>`"

#: ../doc/reference/reference_lua/digest.rst:103
msgid "Get a digest made with MurmurHash"
msgstr "Получение дайджеста с помощью MurmurHash"

#: ../doc/reference/reference_lua/digest.rst:106
msgid ":ref:`digest.murmur.new() <digest-murmur_new>`"
msgstr ":ref:`digest.murmur.new() <digest-murmur_new>`"

#: ../doc/reference/reference_lua/digest.rst:106
msgid "Initiate incremental MurmurHash"
msgstr "Запуск инкрементного вычисления с помощью MurmurHash"

#: ../doc/reference/reference_lua/digest.rst:115
msgid "Returns 256-bit binary string = digest made with AES."
msgstr "Возврат 256-битной двоичной строки = дайджест, полученный с помощью AES."

#: ../doc/reference/reference_lua/digest.rst:121
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr "Возврат 128-битной двоичной строки = дайджест, полученный с помощью MD4."

#: ../doc/reference/reference_lua/digest.rst:127
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""
"Возврат 32-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью MD4."

#: ../doc/reference/reference_lua/digest.rst:133
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr "Возврат 128-битной двоичной строки = дайджест, полученный с помощью MD5."

#: ../doc/reference/reference_lua/digest.rst:139
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""
"Возврат 32-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью MD5."

#: ../doc/reference/reference_lua/digest.rst:145
msgid ""
"Returns binary string = digest made with PBKDF2. |br| For effective "
"encryption the ``iterations`` value should be at least several thousand. "
"The ``digest-length`` value determines the length of the resulting binary"
" string."
msgstr ""
"Возврат двоичной строки = дайджест, полученный с помощью PBKDF2. |br| Для"
" эффективности шифрования значение параметра количества итераций "
"``iterations`` должно быть как минимум несколько тысяч. Значение "
"параметра ``digest-length`` определяет длину полученной двоичной строки."

#: ../doc/reference/reference_lua/digest.rst:152
msgid ""
"``digest.pbkdf2()`` yields and should not be used in a transaction "
"(between ``box.begin()`` and ``box.commit()``/``box.rollback()``). PBKDF2"
" is a time-consuming hash algorithm. It runs in a separate coio thread. "
"While calculations are performed, the fiber that calls "
"``digest.pbkdf2()`` yields and another fiber continues working in the tx "
"thread."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:162
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr "Возврат 160-битной двоичной строки = дайджест, полученный с помощью SHA-1."

#: ../doc/reference/reference_lua/digest.rst:168
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""
"Возврат 40-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью SHA-1."

#: ../doc/reference/reference_lua/digest.rst:174
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr "Возврат 224-битной двоичной строки = дайджест, полученный с помощью SHA-2."

#: ../doc/reference/reference_lua/digest.rst:180
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""
"Возврат 56-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью SHA-224."

#: ../doc/reference/reference_lua/digest.rst:186
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr "Возврат 256-битной двоичной строки = дайджест, полученный с помощью SHA-2."

#: ../doc/reference/reference_lua/digest.rst:192
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""
"Возврат 64-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью SHA-256."

#: ../doc/reference/reference_lua/digest.rst:198
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr "Возврат 384-битной двоичной строки = дайджест, полученный с помощью SHA-2."

#: ../doc/reference/reference_lua/digest.rst:204
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""
"Возврат 96-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью SHA-384."

#: ../doc/reference/reference_lua/digest.rst:210
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr "Возврат 512-битной двоичной строки = дайджест, полученный с помощью SHA-2."

#: ../doc/reference/reference_lua/digest.rst:216
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""
"Возврат 128-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью SHA-512."

#: ../doc/reference/reference_lua/digest.rst:222
msgid "Returns base64 encoding from a regular string."
msgstr "Возврат кодированного по base64 значения обычной строки."

#: ../doc/reference/reference_lua/digest.rst:224
msgid "The possible options are:"
msgstr "Возможные опции:"

#: ../doc/reference/reference_lua/digest.rst:226
msgid "``nopad`` -- result must not include '=' for padding at the end,"
msgstr ""
"``nopad`` -- результат не должен включать в себя '=' для заполнения "
"символами в конце,"

#: ../doc/reference/reference_lua/digest.rst:227
msgid ""
"``nowrap`` -- result must not include line feed for splitting lines after"
" 72 characters,"
msgstr ""
"``nowrap`` -- результат не должен включать в себя символ переноса строки "
"для разделения строк после 72 символов,"

#: ../doc/reference/reference_lua/digest.rst:229
msgid ""
"``urlsafe`` -- result must not include '=' or line feed, and may contain "
"'-' or '_' instead of '+' or '/' for positions 62 and 63 in the index "
"table."
msgstr ""
"``urlsafe`` -- результат не должен включать в себя '=' или символ "
"переноса строки и может содержать '-' или '_' взамен '+' или '/' в "
"качестве 62 и 63 символа в схеме."

#: ../doc/reference/reference_lua/digest.rst:233
msgid "Options may be ``true`` or ``false``, the default value is ``false``."
msgstr ""
"Значения параметров могут быть ``true`` (правда) или ``false`` (ложь), по"
" умолчанию используется ``false``."

#: ../doc/reference/reference_lua/digest.rst:237
msgid "digest.base64_encode(string_variable,{nopad=true})"
msgstr "digest.base64_encode(string_variable,{nopad=true})"

#: ../doc/reference/reference_lua/digest.rst:245
msgid "Returns a regular string from a base64 encoding."
msgstr "Возврат обычной строки из кодированного по base64 значения."

#: ../doc/reference/reference_lua/digest.rst:251
msgid "Returns array of random bytes with length = integer."
msgstr "Возврат массива случайных байтов с длиной = целому числу."

#: ../doc/reference/reference_lua/digest.rst:257
msgid "Returns 32-bit checksum made with CRC32."
msgstr "Возврат 32-битной контрольной суммы с помощью CRC32."

#: ../doc/reference/reference_lua/digest.rst:259
msgid ""
"The ``crc32`` and ``crc32_update`` functions use the `Cyclic Redundancy "
"Check`_ polynomial value: ``0x1EDC6F41`` / ``4812730177``. (Other "
"settings are: input = reflected, output = reflected, initial value = "
"0xFFFFFFFF, final xor value = 0x0.) If it is necessary to be compatible "
"with other checksum functions in other programming languages, ensure that"
" the other functions use the same polynomial value."
msgstr ""
"Функции ``crc32`` и ``crc32_update`` используют значение многочлена "
"`Cyclic Redundancy Check`_ : ``0x1EDC6F41`` / ``4812730177``. (Другие "
"используемые значения: ввод = отраженное значение, вывод = отраженное "
"значение, начальное значение = 0xFFFFFFFF, финальное xor-значение = 0x0.)"
" Если необходима совместимость с другими функциями контрольной суммы на "
"другом языке программирования, убедитесь, что другие функции используют "
"то же значение многочлена."

#: ../doc/reference/reference_lua/digest.rst:266
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr "Например, в Python установите пакет ``crcmod`` и введите команду:"

#: ../doc/reference/reference_lua/digest.rst:268
msgid ""
">>> import crcmod\n"
">>> fun = crcmod.mkCrcFun('4812730177')\n"
">>> fun('string')\n"
"3304160206L"
msgstr ""
">>> import crcmod\n"
">>> fun = crcmod.mkCrcFun('4812730177')\n"
">>> fun('string')\n"
"3304160206L"

#: ../doc/reference/reference_lua/digest.rst:275
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr "В Perl установите модуль ``Digest::CRC`` и выполните следующий код:"

#: ../doc/reference/reference_lua/digest.rst:277
msgid ""
"use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => "
"0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""
"use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => "
"0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"

#: ../doc/reference/reference_lua/digest.rst:284
msgid "(the expected output is 3304160206)."
msgstr "(ожидается выходное значение: 3304160206)."

#: ../doc/reference/reference_lua/digest.rst:290
msgid ""
"Initiates incremental crc32. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""
"Запуск инкрементного вычисления CRC32. См. примечания по "
":ref:`инкрементным методам <digest-incremental_digests>`."

#: ../doc/reference/reference_lua/digest.rst:297
msgid "Returns a number made with consistent hash."
msgstr "Возврат числа с помощью консистентного хеширования."

#: ../doc/reference/reference_lua/digest.rst:299
msgid ""
"The guava function uses the `Consistent Hashing`_ algorithm of the Google"
" guava library. The first parameter should be a hash code; the second "
"parameter should be the number of buckets; the returned value will be an "
"integer between 0 and the number of buckets. For example,"
msgstr ""
"Функция guava использует алгоритм консистентного хеширование (`Consistent"
" Hashing`_) из библиотеки guava от Google. Первым параметром должен быть "
"хеш-код; вторым параметром должно быть число слотов; возвращается "
"значение в виде целого числа в диапазоне от 0 до указанного числа слотов."
" Например,"

#: ../doc/reference/reference_lua/digest.rst:304
msgid ""
"tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""
"tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."

#: ../doc/reference/reference_lua/digest.rst:315
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""
"Возврат 32-битной двоичной строки = дайджест, полученный с помощью "
"MurmurHash."

#: ../doc/reference/reference_lua/digest.rst:321
msgid ""
"Initiates incremental MurmurHash. See :ref:`incremental methods <digest-"
"incremental_digests>` notes. For example:"
msgstr ""
"Запуск инкрементного вычисления с помощью MurmurHash. См. примечания по "
":ref:`инкрементным методам <digest-incremental_digests>`. Например:"

#: ../doc/reference/reference_lua/digest.rst:325
msgid "murmur.new({seed=0})"
msgstr "murmur.new({seed=0})"

#: ../doc/reference/reference_lua/digest.rst:333
msgid "Incremental methods in the ``digest`` module"
msgstr "Инкрементальные методы в модуле ``digest``"

#: ../doc/reference/reference_lua/digest.rst:335
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports with crc32 and with murmur..."
msgstr ""
"Предположим, что вычислен дайджест для строки 'A', затем часть 'B' "
"добавляется в строку, необходим новый дайджест. Новый дайджест можно "
"пересчитать для всей строки 'AB', но быстрее будет взять вычисленный "
"дайджест для 'A' и внести изменения на основании добавленной части 'B'. "
"Это называется многошаговым процессом или \"инкрементным\" "
"хеш-суммированием, которое поддерживает Tarantool поддерживает для crc32 "
"и murmur..."

#: ../doc/reference/reference_lua/digest.rst:341
msgid ""
"digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""
"digest = require('digest')\n"
"\n"
"-- вывести дайджест 'AB' по crc32 пошагово, затем с инкрементом\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- вывести дайджест 'AB' по murmur hash пошагово, затем с инкрементом\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"

#: ../doc/reference/reference_lua/digest.rst:363
msgid ""
"In the following example, the user creates two functions, "
"``password_insert()`` which inserts a SHA-1_ digest of the word "
"\"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` "
"which requires input of a password."
msgstr ""
"В следующем примере пользователь создает две функции: функцию "
"``password_insert()``, которая вставляет дайджест слова \"**^S^e^c^ret "
"Wordpass**\" по SHA-1_ в набор кортежей, и функцию ``password_check()``, "
"которая требует ввод пароля."

#: ../doc/reference/reference_lua/digest.rst:367
msgid ""
"tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret "
"Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""
"tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret "
"Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."

#: ../doc/reference/reference_lua/digest.rst:393
msgid ""
"If a later user calls the ``password_check()`` function and enters the "
"wrong password, the result is an error."
msgstr ""
"Если затем пользователь вызовет функцию ``password_check()`` и вводит "
"неверный пароль, результатом будет ошибка."

#: ../doc/reference/reference_lua/digest.rst:396
msgid ""
"tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""
"tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."

#: ../doc/reference/reference_lua/errcodes.rst:5
msgid "Database error codes"
msgstr "Коды ошибок базы данных"

#: ../doc/reference/reference_lua/errcodes.rst:7
msgid ""
"In the current version of the binary protocol, error messages, which are "
"normally more descriptive than error codes, are not present in server "
"responses. The actual message may contain a file name, a detailed reason "
"or operating system error code. All such messages, however, are logged in"
" the error log. Below are general descriptions of some popular codes. A "
"complete list of errors can be found in file `errcode.h`_ in the source "
"tree."
msgstr ""
"В текущей версии бинарного протокола в ответы сервера не включены "
"сообщения об ошибках, которые как правило, содержат больше информации, "
"чем коды ошибок. Само сообщение может содержать имя файла, подробное "
"описание причины или код ошибки операционной системы. Однако все такие "
"сообщения регистрируются в журнале ошибок. Ниже приведены общие описания "
"некоторых распространенных кодов. Полный список ошибок можно найти в "
"файле `errcode.h`_ в исходном дереве."

#: ../doc/reference/reference_lua/errcodes.rst:18
msgid "**List of error codes**"
msgstr "**Список кодов ошибок**"

#: ../doc/reference/reference_lua/errcodes.rst:26
msgid "ER_NONMASTER"
msgstr "ER_NONMASTER"

#: ../doc/reference/reference_lua/errcodes.rst:26
msgid ""
"(In replication) A server instance cannot modify data unless it is a "
"master."
msgstr ""
"(Репликация) Экземпляр сервера не может вносить изменения в данные, если "
"он не является мастером."

#: ../doc/reference/reference_lua/errcodes.rst:29
msgid "ER_ILLEGAL_PARAMS"
msgstr "ER_ILLEGAL_PARAMS"

#: ../doc/reference/reference_lua/errcodes.rst:29
msgid "Illegal parameters. Malformed protocol message."
msgstr "Недопустимые параметры. Некорректное протокольное сообщение."

#: ../doc/reference/reference_lua/errcodes.rst:32
msgid "ER_MEMORY_ISSUE"
msgstr "ER_MEMORY_ISSUE"

#: ../doc/reference/reference_lua/errcodes.rst:32
msgid ""
"Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has "
"been reached."
msgstr ""
"Нехватка оперативной памяти: достижение предела памяти :ref:`memtx_memory"
" <cfg_storage-memtx_memory>`."

#: ../doc/reference/reference_lua/errcodes.rst:36
msgid "ER_WAL_IO"
msgstr "ER_WAL_IO"

#: ../doc/reference/reference_lua/errcodes.rst:36
msgid ""
"Failed to write to disk. May mean: failed to record a change in the "
"write-ahead log. Some sort of disk error."
msgstr ""
"Запись на диск не удалась. Может означать, что не удалось записать "
"изменение в журнале упреждающей записи. Некоторая ошибка на диске."

#: ../doc/reference/reference_lua/errcodes.rst:40
msgid "ER_KEY_PART_COUNT"
msgstr "ER_KEY_PART_COUNT"

#: ../doc/reference/reference_lua/errcodes.rst:40
msgid "Key part count is not the same as index part count"
msgstr "Количество частей ключа не совпадает с количеством частей индекса"

#: ../doc/reference/reference_lua/errcodes.rst:43
msgid "ER_NO_SUCH_SPACE"
msgstr "ER_NO_SUCH_SPACE"

#: ../doc/reference/reference_lua/errcodes.rst:43
msgid "The specified space does not exist."
msgstr "Указанный спейс отсутствует."

#: ../doc/reference/reference_lua/errcodes.rst:46
msgid "ER_NO_SUCH_INDEX"
msgstr "ER_NO_SUCH_INDEX"

#: ../doc/reference/reference_lua/errcodes.rst:46
msgid "The specified index in the specified space does not exist."
msgstr "Указанного индекса нет в указанном спейсе."

#: ../doc/reference/reference_lua/errcodes.rst:49
msgid "ER_PROC_LUA"
msgstr "ER_PROC_LUA"

#: ../doc/reference/reference_lua/errcodes.rst:49
msgid "An error occurred inside a Lua procedure."
msgstr "Возникла ошибке в Lua-процедуре."

#: ../doc/reference/reference_lua/errcodes.rst:52
msgid "ER_FIBER_STACK"
msgstr "ER_FIBER_STACK"

#: ../doc/reference/reference_lua/errcodes.rst:52
msgid ""
"The recursion limit was reached when creating a new fiber. This usually "
"indicates that a stored procedure is recursively invoking itself too "
"often."
msgstr ""
"При создании нового файбера был достигнут предел рекурсии. Обычно это "
"указывает на то, что хранимая процедура слишком часто рекурсивно вызывает"
" себя."

#: ../doc/reference/reference_lua/errcodes.rst:57
msgid "ER_UPDATE_FIELD"
msgstr "ER_UPDATE_FIELD"

#: ../doc/reference/reference_lua/errcodes.rst:57
msgid "An error occurred during update of a field."
msgstr "Возникла ошибка во время обновления поля."

#: ../doc/reference/reference_lua/errcodes.rst:60
msgid "ER_TUPLE_FOUND"
msgstr "ER_TUPLE_FOUND"

#: ../doc/reference/reference_lua/errcodes.rst:60
msgid "A duplicate key exists in a unique index."
msgstr "В уникальном индексе есть повторяющийся ключ."

#: ../doc/reference/reference_lua/errcodes.rst:68
msgid "Handling errors"
msgstr "Обработка ошибок"

#: ../doc/reference/reference_lua/errcodes.rst:70
msgid ""
"Here are some procedures that can make Lua functions more robust when "
"there are errors, particularly database errors."
msgstr ""
"Ниже представлены несколько процедур для более надежного вызова "
"Lua-функций в случае ошибок, в частности, ошибок базы данных."

#: ../doc/reference/reference_lua/errcodes.rst:73
msgid "Invoke with pcall."
msgstr "Вызов с помощью pcall."

#: ../doc/reference/reference_lua/errcodes.rst
msgid ""
"Take advantage of Lua's mechanisms for `\"Error handling and exceptions\""
" <http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, "
"instead of simply invoking with"
msgstr ""
"Используйте механизмы Lua для `\"Обработки ошибок и исключений\" "
"<http://www.lua.org/pil/8.4.html>`_, в частности ``pcall``. То есть "
"вместо простого вызова функции с помощью"

#: ../doc/reference/reference_lua/errcodes.rst
msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ":samp:`box.space.{имя-спейса}:{имя-функции}()`"

#: ../doc/reference/reference_lua/errcodes.rst
msgid "say"
msgstr "выполните"

#: ../doc/reference/reference_lua/errcodes.rst
msgid ""
":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-"
"name}) ...`"
msgstr ""
":samp:`if pcall(box.space.{имя-спейса}.{имя-функции}, "
"box.space.{имя-спейса}) ...`"

#: ../doc/reference/reference_lua/errcodes.rst
msgid ""
"For some Tarantool box functions, pcall also returns error details "
"including a file-name and line-number within Tarantool's source code. "
"This can be seen by unpacking. For example:"
msgstr ""
"Для некоторых функций модуля box в Tarantool'е pcall также вернет "
"описание ошибки, включая имя файла и номер строки в исходном коде "
"Tarantool'а. Например:"

#: ../doc/reference/reference_lua/errcodes.rst
msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr "``x, y = pcall(function() box.schema.space.create('') end)``"

#: ../doc/reference/reference_lua/errcodes.rst
msgid "``y:unpack()``"
msgstr "``y:unpack()``"

#: ../doc/reference/reference_lua/errcodes.rst:88
msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""
"Чтобы увидеть применение pcall в приложении, см. практическое задание "
":ref:`Подсчет суммы по JSON-полям во всех кортежах <c_lua_tutorial-"
"sum_a_json_field>`."

#: ../doc/reference/reference_lua/errcodes.rst:91
msgid "Examine and raise with box.error."
msgstr "Проверка и вызов ошибки с помощью box.error."

#: ../doc/reference/reference_lua/errcodes.rst:93
msgid ""
"To make a new error and pass it on, the box.error module provides "
":ref:`box.error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""
"В модуле box.error предусмотрена функция :ref:`box.error(code, errtext [,"
" errtext ...]) <box_error-error>`, чтобы создать ошибку и передать ее."

#: ../doc/reference/reference_lua/errcodes.rst:96
msgid ""
"To find the last error, the box.error module provides "
":ref:`box.error.last() <box_error-last>`. (There is also a way to find "
"the text of the last operating-system error for certain functions -- "
":ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""
"Чтобы найти последнюю ошибку, в модуле box.error предусмотрена функция "
":ref:`box.error.last() <box_error-last>`. (Также можно найти текст "
"последней ошибки операционной системы для определенной функции -- "
":ref:`errno.strerror([code]) <errno-strerror>`.)"

#: ../doc/reference/reference_lua/errcodes.rst:101
msgid "Log."
msgstr "Запись в журнал."

#: ../doc/reference/reference_lua/errcodes.rst:103
msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr "Записывайте сообщения в журнал с помощью :ref:`модуля log <log-module>`."

#: ../doc/reference/reference_lua/errcodes.rst:105
msgid ""
"And filter messages that are automatically generated, with the :ref:`log "
"<cfg_logging-log>` configuration parameter."
msgstr ""
"И отфильтровывайте автоматически созданные сообщения с помощью "
"конфигурационного параметра :ref:`log <cfg_logging-log>`."

#: ../doc/reference/reference_lua/errcodes.rst:109
msgid ""
"Generally, for Tarantool built-in functions which are designed to return "
"objects: the result will be an object, or nil, or `a Lua error "
"<https://www.lua.org/pil/8.3.html>`_. For example consider the "
":ref:`fio_read.lua <cookbook-fio_read>` program in our cookbook:"
msgstr ""
"Как правило, встроенные функции Tarantool'а, которые предназначены для "
"возврата объектов, вернут либо объект, либо нулевое значение nil, либо "
"`Lua-ошибку <https://www.lua.org/pil/8.3.html>`_. Например, рассмотрим "
"программу :ref:`fio_read.lua <cookbook-fio_read>` из рекомендаций по "
"разработке:"

#: ../doc/reference/reference_lua/errcodes.rst:113
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"

#: ../doc/reference/reference_lua/errcodes.rst:127
msgid ""
"After a function call that might fail, like fio.open() above, it is "
"common to see syntax like ``if not f then ...`` or ``if f == nil then "
"...``, which check for common failures. But if there had been a syntax "
"error, for example fio.opex instead of fio.open, then there would have "
"been a Lua error and f would not have been changed. If checking for such "
"an obvious error had been a concern, the programmer would probably have "
"used pcall()."
msgstr ""
"После вызова функции, который может не сработать, как fio.open() выше, "
"обычно можно увидеть такой синтаксис, как ``if not f then ...`` или ``if "
"f == nil then ...``, который проверяет на типичные отказы. Но если есть "
"ошибка синтаксиса, например, fio.opex вместо fio.open, то появится "
"Lua-ошибка, и f не изменится. Если речь идет о проверке таких очевидных "
"ошибок, программист вероятно будет использовать pcall()."

#: ../doc/reference/reference_lua/errcodes.rst:137
msgid ""
"All functions in Tarantool modules should work this way, unless the "
"manual explicitly says otherwise."
msgstr ""
"Все функции в модулях Tarantool'а должны работать таким образом, если в "
"руководстве явно не говорится об обратном."

#: ../doc/reference/reference_lua/errno.rst:5
msgid "Module `errno`"
msgstr "Модуль `errno`"

#: ../doc/reference/reference_lua/errno.rst:13
msgid ""
"The ``errno`` module is typically used within a function or within a Lua "
"program, in association with a module whose functions can return "
"operating-system errors, such as :ref:`fio <fio-module>`."
msgstr ""
"Модуль ``errno``, как правило, используется внутри функции или в рамках "
"Lua-программы совместно с модулем, функции которого могут возвращать "
"ошибки ОС, например :ref:`fio <fio-module>`."

#: ../doc/reference/reference_lua/errno.rst:21
msgid "Below is a list of all ``errno`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``errno``."

#: ../doc/reference/reference_lua/errno.rst:31
msgid ":ref:`errno() <errno-errno>`"
msgstr ":ref:`errno() <errno-errno>`"

#: ../doc/reference/reference_lua/errno.rst:31
msgid "Get an error number for the last OS-related function"
msgstr "Получение номера ошибки для последней функции, связанной с ОС"

#: ../doc/reference/reference_lua/errno.rst:34
msgid ":ref:`errno.strerror() <errno-strerror>`"
msgstr ":ref:`errno.strerror() <errno-strerror>`"

#: ../doc/reference/reference_lua/errno.rst:34
msgid "Get an error message for the corresponding error number"
msgstr "Получение сообщения об ошибке для соответствующего номера ошибки"

#: ../doc/reference/reference_lua/errno.rst:42
msgid ""
"Return an error number for the last operating-system-related function, or"
" 0. To invoke it, simply say ``errno()``, without the module name."
msgstr ""
"Возврат номера ошибки для последней функции, связанной с операционной "
"системой, или 0. Чтобы вызвать функцию, просто введите команду "
"``errno()`` без названия модуля."

#: ../doc/reference/reference_lua/errno.rst:45
#: ../doc/reference/reference_sql/sql.rst:244
msgid "integer"
msgstr "целое число"

#: ../doc/reference/reference_lua/errno.rst:51
msgid ""
"Return a string, given an error number. The string will contain the text "
"of the conventional error message for the current operating system. If "
"``code`` is not supplied, the error message will be for the last "
"operating-system-related function, or 0."
msgstr ""
"Возврат строки в ответ на номер ошибки. Строка будет содержать текст "
"традиционного сообщения об ошибке для текущей операционной системы. Если "
"не указан код ``code``, то будет выведено сообщение об ошибке для "
"последней функции, связанной с операционной системой, или 0."

#: ../doc/reference/reference_lua/errno.rst:56
msgid "number of an operating-system error"
msgstr "номер ошибки в операционной системе"

#: ../doc/reference/reference_lua/errno.rst:58
#: ../doc/reference/reference_lua/fiber.rst:335
#: ../doc/reference/reference_lua/fiber.rst:454
#: ../doc/reference/reference_lua/fiber.rst:504
#: ../doc/reference/reference_lua/fio.rst:182
#: ../doc/reference/reference_lua/fio.rst:204
#: ../doc/reference/reference_lua/fio.rst:224
#: ../doc/reference/reference_lua/fio.rst:243
#: ../doc/reference/reference_lua/json.rst:54
#: ../doc/reference/reference_lua/msgpack.rst:62
#: ../doc/reference/reference_lua/pickle.rst:83
#: ../doc/reference/reference_lua/socket.rst:294
#: ../doc/reference/reference_lua/socket.rst:328
#: ../doc/reference/reference_lua/socket.rst:344
#: ../doc/reference/reference_lua/string.rst:76
#: ../doc/reference/reference_lua/string.rst:101
#: ../doc/reference/reference_lua/string.rst:124
#: ../doc/reference/reference_lua/string.rst:149
#: ../doc/reference/reference_lua/string.rst:235
#: ../doc/reference/reference_lua/string.rst:261
#: ../doc/reference/reference_lua/string.rst:319
#: ../doc/reference/reference_lua/uri.rst:90
#: ../doc/reference/reference_lua/utf8.rst:88
#: ../doc/reference/reference_lua/utf8.rst:274
#: ../doc/reference/reference_lua/utf8.rst:326
#: ../doc/reference/reference_lua/utf8.rst:350
#: ../doc/reference/reference_lua/yaml.rst:48
#: ../doc/reference/reference_rock/membership.rst:314
#: ../doc/reference/reference_sql/sql.rst:250
msgid "string"
msgstr "строка"

#: ../doc/reference/reference_lua/errno.rst:62
msgid ""
"This function displays the result of a call to :ref:`fio.open() <fio-"
"open>` which causes error 2 (``errno.ENOENT``). The display includes the "
"error number, the associated error string, and the error name."
msgstr ""
"Данная функция отображает результат вызова :ref:`fio.open() <fio-open>`, "
"который вызывает ошибку 2 (``errno.ENOENT``). В результат включен номер "
"ошибки, связанная с ним строка сообщения об ошибке и название ошибки."

#: ../doc/reference/reference_lua/errno.rst:66
msgid ""
"tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."
msgstr ""
"tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/errno.rst:91
msgid ""
"To see all possible error names stored in the ``errno`` metatable, say "
"``getmetatable(errno)`` (output abridged):"
msgstr ""
"Чтобы увидеть все возможные названия ошибок, которые хранятся в "
"метатаблице ``errno``, введите команду ``getmetatable(errno)`` (выводятся"
" сокращенно):"

#: ../doc/reference/reference_lua/errno.rst:94
msgid ""
"tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  <...>\n"
"..."
msgstr ""
"tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  <...>\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:5
msgid "Module `fiber`"
msgstr "Модуль `fiber`"

#: ../doc/reference/reference_lua/fiber.rst:11
msgid "With the ``fiber`` module, you can:"
msgstr "С помощью модуля ``fiber`` можно:"

#: ../doc/reference/reference_lua/fiber.rst:13
msgid "create, run and manage :ref:`fibers <fiber-fibers>`,"
msgstr "создавать, запускать и управлять :ref:`файберами <fiber-fibers>`,"

#: ../doc/reference/reference_lua/fiber.rst:14
msgid ""
"send and receive messages between different processes (i.e. different "
"connections, sessions, or fibers) via :ref:`channels <fiber_ipc-"
"channel>`, and"
msgstr ""
"отправлять и получать сообщения для различных процессов (например, разные"
" соединения, сессии или файберы) по :ref:`каналам <fiber_ipc-channel>`, а"
" также"

#: ../doc/reference/reference_lua/fiber.rst:16
msgid ""
"use a :ref:`synchronization mechanism <fiber_ipc-cond_var>` for fibers, "
"similar to \"condition variables\" and similar to operating-system "
"functions such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
msgstr ""
"использовать :ref:`механизм синхронизации <fiber_ipc-cond_var>` для "
"файберов, аналогично работе \"условных переменных\" и функций "
"операционных систем, таких как ``pthread_cond_wait()`` плюс "
"``pthread_cond_signal()``."

#: ../doc/reference/reference_lua/fiber.rst:24
msgid "Below is a list of all ``fiber`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``fiber``."

#: ../doc/reference/reference_lua/fiber.rst:34
msgid ":ref:`fiber.create() <fiber-create>`"
msgstr ":ref:`fiber.create() <fiber-create>`"

#: ../doc/reference/reference_lua/fiber.rst:34
msgid "Create and start a fiber"
msgstr "Создание и запуск файбера"

#: ../doc/reference/reference_lua/fiber.rst:37
msgid ":ref:`fiber.new() <fiber-new>`"
msgstr ":ref:`fiber.new() <fiber-new>`"

#: ../doc/reference/reference_lua/fiber.rst:37
msgid "Create but do not start a fiber"
msgstr "Создание файбера без запуска"

#: ../doc/reference/reference_lua/fiber.rst:40
msgid ":ref:`fiber.self() <fiber-self>`"
msgstr ":ref:`fiber.self() <fiber-self>`"

#: ../doc/reference/reference_lua/fiber.rst:40
msgid "Get a fiber object"
msgstr "Получение объекта файбера"

#: ../doc/reference/reference_lua/fiber.rst:43
msgid ":ref:`fiber.find() <fiber-find>`"
msgstr ":ref:`fiber.find() <fiber-find>`"

#: ../doc/reference/reference_lua/fiber.rst:43
msgid "Get a fiber object by ID"
msgstr "Получение объекта файбера по ID"

#: ../doc/reference/reference_lua/fiber.rst:46
msgid ":ref:`fiber.sleep() <fiber-sleep>`"
msgstr ":ref:`fiber.sleep() <fiber-sleep>`"

#: ../doc/reference/reference_lua/fiber.rst:46
msgid "Make a fiber go to sleep"
msgstr "Перевод файбера в режим ожидания"

#: ../doc/reference/reference_lua/fiber.rst:49
msgid ":ref:`fiber.yield() <fiber-yield>`"
msgstr ":ref:`fiber.yield() <fiber-yield>`"

#: ../doc/reference/reference_lua/fiber.rst:49
msgid "Yield control"
msgstr "Передача управления"

#: ../doc/reference/reference_lua/fiber.rst:52
msgid ":ref:`fiber.status() <fiber-status>`"
msgstr ":ref:`fiber.status() <fiber-status>`"

#: ../doc/reference/reference_lua/fiber.rst:52
msgid "Get the current fiber's status"
msgstr "Получение статуса активного файбера"

#: ../doc/reference/reference_lua/fiber.rst:55
msgid ":ref:`fiber.info() <fiber-info>`"
msgstr ":ref:`fiber.info() <fiber-info>`"

#: ../doc/reference/reference_lua/fiber.rst:55
msgid "Get information about all fibers"
msgstr "Получение информации о всех файберах"

#: ../doc/reference/reference_lua/fiber.rst:58
msgid ":ref:`fiber.kill() <fiber-kill>`"
msgstr ":ref:`fiber.kill() <fiber-kill>`"

#: ../doc/reference/reference_lua/fiber.rst:58
#: ../doc/reference/reference_lua/fiber.rst:76
msgid "Cancel a fiber"
msgstr "Отмена файбера"

#: ../doc/reference/reference_lua/fiber.rst:61
msgid ":ref:`fiber.testcancel() <fiber-testcancel>`"
msgstr ":ref:`fiber.testcancel() <fiber-testcancel>`"

#: ../doc/reference/reference_lua/fiber.rst:61
msgid "Check if the current fiber has been cancelled"
msgstr "Проверка отмены действующего файбера"

#: ../doc/reference/reference_lua/fiber.rst:64
msgid ":ref:`fiber_object:id() <fiber_object-id>`"
msgstr ":ref:`fiber_object:id() <fiber_object-id>`"

#: ../doc/reference/reference_lua/fiber.rst:64
msgid "Get a fiber's ID"
msgstr "Получение ID файбера"

#: ../doc/reference/reference_lua/fiber.rst:67
msgid ":ref:`fiber_object:name() <fiber_object-name_get>`"
msgstr ":ref:`fiber_object:name() <fiber_object-name_get>`"

#: ../doc/reference/reference_lua/fiber.rst:67
msgid "Get a fiber's name"
msgstr "Получение имени файбера"

#: ../doc/reference/reference_lua/fiber.rst:70
msgid ":ref:`fiber_object:name(name) <fiber_object-name_set>`"
msgstr ":ref:`fiber_object:name(name) <fiber_object-name_set>`"

#: ../doc/reference/reference_lua/fiber.rst:70
msgid "Set a fiber's name"
msgstr "Назначение имени файбера"

#: ../doc/reference/reference_lua/fiber.rst:73
msgid ":ref:`fiber_object:status() <fiber_object-status>`"
msgstr ":ref:`fiber_object:status() <fiber_object-status>`"

#: ../doc/reference/reference_lua/fiber.rst:73
msgid "Get a fiber's status"
msgstr "Получение статуса файбера"

#: ../doc/reference/reference_lua/fiber.rst:76
msgid ":ref:`fiber_object:cancel() <fiber_object-cancel>`"
msgstr ":ref:`fiber_object:cancel() <fiber_object-cancel>`"

#: ../doc/reference/reference_lua/fiber.rst:79
msgid ":ref:`fiber_object.storage <fiber_object-storage>`"
msgstr ":ref:`fiber_object.storage <fiber_object-storage>`"

#: ../doc/reference/reference_lua/fiber.rst:79
msgid "Local storage within the fiber"
msgstr "Локальное хранилище в пределах файбера"

#: ../doc/reference/reference_lua/fiber.rst:82
msgid ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"
msgstr ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"

#: ../doc/reference/reference_lua/fiber.rst:82
msgid "Make it possible for a new fiber to join"
msgstr "Создание возможности подключения нового файбера"

#: ../doc/reference/reference_lua/fiber.rst:85
msgid ":ref:`fiber_object:join() <fiber_object-join>`"
msgstr ":ref:`fiber_object:join() <fiber_object-join>`"

#: ../doc/reference/reference_lua/fiber.rst:85
msgid "Wait for a fiber's state to become 'dead'"
msgstr "Ожидание статуса 'dead' (недоступен) для файбера"

#: ../doc/reference/reference_lua/fiber.rst:88
msgid ":ref:`fiber.time() <fiber-time>`"
msgstr ":ref:`fiber.time() <fiber-time>`"

#: ../doc/reference/reference_lua/fiber.rst:88
msgid "Get the system time in seconds"
msgstr "Получение системного времени в секундах"

#: ../doc/reference/reference_lua/fiber.rst:91
msgid ":ref:`fiber.time64() <fiber-time64>`"
msgstr ":ref:`fiber.time64() <fiber-time64>`"

#: ../doc/reference/reference_lua/fiber.rst:91
msgid "Get the system time in microseconds"
msgstr "Получение системного времени в микросекундах"

#: ../doc/reference/reference_lua/fiber.rst:94
msgid ":ref:`fiber.channel() <fiber-channel>`"
msgstr ":ref:`fiber.channel() <fiber-channel>`"

#: ../doc/reference/reference_lua/fiber.rst:94
msgid "Create a communication channel"
msgstr "Создание канала связи"

#: ../doc/reference/reference_lua/fiber.rst:97
msgid ":ref:`channel_object:put() <channel_object-put>`"
msgstr ":ref:`channel_object:put() <channel_object-put>`"

#: ../doc/reference/reference_lua/fiber.rst:97
msgid "Send a message via a channel"
msgstr "Отправка сообщения по каналу связи"

#: ../doc/reference/reference_lua/fiber.rst:100
msgid ":ref:`channel_object:close() <channel_object-close>`"
msgstr ":ref:`channel_object:close() <channel_object-close>`"

#: ../doc/reference/reference_lua/fiber.rst:100
msgid "Close a channel"
msgstr "Закрытие канала"

#: ../doc/reference/reference_lua/fiber.rst:103
msgid ":ref:`channel_object:get() <channel_object-get>`"
msgstr ":ref:`channel_object:get() <channel_object-get>`"

#: ../doc/reference/reference_lua/fiber.rst:103
msgid "Fetch a message from a channel"
msgstr "Перехват сообщения из канала"

#: ../doc/reference/reference_lua/fiber.rst:106
msgid ":ref:`channel_object:is_empty() <channel_object-is_empty>`"
msgstr ":ref:`channel_object:is_empty() <channel_object-is_empty>`"

#: ../doc/reference/reference_lua/fiber.rst:106
msgid "Check if a channel is empty"
msgstr "Проверка пустоты канала"

#: ../doc/reference/reference_lua/fiber.rst:109
msgid ":ref:`channel_object:count() <channel_object-count>`"
msgstr ":ref:`channel_object:count() <channel_object-count>`"

#: ../doc/reference/reference_lua/fiber.rst:109
msgid "Count messages in a channel"
msgstr "Подсчет сообщений в канале"

#: ../doc/reference/reference_lua/fiber.rst:112
msgid ":ref:`channel_object:is_full() <channel_object-is_full>`"
msgstr ":ref:`channel_object:is_full() <channel_object-is_full>`"

#: ../doc/reference/reference_lua/fiber.rst:112
msgid "Check if a channel is full"
msgstr "Проверка заполненности канала"

#: ../doc/reference/reference_lua/fiber.rst:115
msgid ":ref:`channel_object:has_readers() <channel_object-has_readers>`"
msgstr ":ref:`channel_object:has_readers() <channel_object-has_readers>`"

#: ../doc/reference/reference_lua/fiber.rst:115
msgid "Check if an empty channel has any readers waiting"
msgstr "Проверка пустого канала на наличие читателей в состоянии ожидания"

#: ../doc/reference/reference_lua/fiber.rst:118
msgid ":ref:`channel_object:has_writers() <channel_object-has_writers>`"
msgstr ":ref:`channel_object:has_writers() <channel_object-has_writers>`"

#: ../doc/reference/reference_lua/fiber.rst:118
msgid "Check if a full channel has any writers waiting"
msgstr "Проверка полного канала на наличие писателей в состоянии ожидания"

#: ../doc/reference/reference_lua/fiber.rst:121
msgid ":ref:`channel_object:is_closed() <channel_object-is_closed>`"
msgstr ":ref:`channel_object:is_closed() <channel_object-is_closed>`"

#: ../doc/reference/reference_lua/fiber.rst:121
msgid "Check if a channel is closed"
msgstr "Проверка закрытия канала"

#: ../doc/reference/reference_lua/fiber.rst:124
msgid ":ref:`fiber.cond() <fiber-cond>`"
msgstr ":ref:`fiber.cond() <fiber-cond>`"

#: ../doc/reference/reference_lua/fiber.rst:124
msgid "Create a condition variable"
msgstr "Создание условной переменной"

#: ../doc/reference/reference_lua/fiber.rst:127
msgid ":ref:`cond_object:wait() <cond_object-wait>`"
msgstr ":ref:`cond_object:wait() <cond_object-wait>`"

#: ../doc/reference/reference_lua/fiber.rst:127
msgid "Make a fiber go to sleep until woken by another fiber"
msgstr "Перевод файбера в режим ожидания до пробуждения другим файбером"

#: ../doc/reference/reference_lua/fiber.rst:130
msgid ":ref:`cond_object:signal() <cond_object-signal>`"
msgstr ":ref:`cond_object:signal() <cond_object-signal>`"

#: ../doc/reference/reference_lua/fiber.rst:130
msgid "Wake up a single fiber"
msgstr "Пробуждение отдельного файбера"

#: ../doc/reference/reference_lua/fiber.rst:133
msgid ":ref:`cond_object:broadcast() <cond_object-broadcast>`"
msgstr ":ref:`cond_object:broadcast() <cond_object-broadcast>`"

#: ../doc/reference/reference_lua/fiber.rst:133
msgid "Wake up all fibers"
msgstr "Пробуждение всех файберов"

#: ../doc/reference/reference_lua/fiber.rst:142
#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:575
msgid "Fibers"
msgstr "Файберы"

#: ../doc/reference/reference_lua/fiber.rst:144
msgid ""
"A **fiber** is a set of instructions which are executed with cooperative "
"multitasking. Fibers managed by the fiber module are associated with a "
"user-supplied function called the *fiber function*."
msgstr ""
"**Файбер** -- это набор инструкций, которые выполняются по принципу "
"кооперативной многозадачности. Файберы, управление которых происходит с "
"помощью модуля fiber, связаны с функцией под названием *функция для "
"файбера*, которую задает пользователь."

#: ../doc/reference/reference_lua/fiber.rst:148
msgid ""
"A fiber has three possible states: **running**, **suspended** or "
"**dead**. When a fiber is created with :ref:`fiber.create() <fiber-"
"create>`, it is running. When a fiber is created with :ref:`fiber.new() "
"<fiber-new>` or yields control with :ref:`fiber.sleep() <fiber-sleep>`, "
"it is suspended. When a fiber ends (because the fiber function ends), it "
"is dead."
msgstr ""
"Существуют три возможных состояния файбера: **running** (активен), "
"**suspended** (приостановлен) или **dead** (недоступен). После создания "
"файбера с помощью :ref:`fiber.create() <fiber-create>` он сразу активен. "
"После создания файбера с помощью :ref:`fiber.new() <fiber-new>` или "
"передачи управления с помощью :ref:`fiber.sleep() <fiber-sleep>` файбер "
"будет приостановлен. По окончании работы (по причине окончания работы "
"соответствующей функции) файбер становится недоступен."

#: ../doc/reference/reference_lua/fiber.rst:154
msgid ""
"All fibers are part of the fiber registry. This registry can be searched "
"with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a "
"numeric identifier."
msgstr ""
"Все файберы составляют часть реестра файберов. Можно производить поиск по"
" реестру с помощью :ref:`fiber.find() <fiber-find>` по ID файбера (fid), "
"который представляет собой числовой идентификатор."

#: ../doc/reference/reference_lua/fiber.rst:158
msgid ""
"A runaway fiber can be stopped with :ref:`fiber_object.cancel "
"<fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-"
"cancel>` is advisory — it works only if the runaway fiber calls "
":ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*``"
" functions, such as :ref:`box.space...delete() <box_space-delete>` or "
":ref:`box.space...update() <box_space-update>`, do call "
":ref:`fiber.testcancel() <fiber-testcancel>` but "
":ref:`box.space...select{} <box_space-select>` does not. In practice, a "
"runaway fiber can only become unresponsive if it does many computations "
"and does not check whether it has been cancelled."
msgstr ""
"Неконтролируемый файбер можно остановить с помощью "
":ref:`fiber_object.cancel <fiber_object-cancel>`. Однако, функция "
":ref:`fiber_object.cancel <fiber_object-cancel>` консультативна, то есть "
"сработает только в том случае, если неконтролируемый файбер случайно "
"вызовет :ref:`fiber.testcancel() <fiber-testcancel>`. Большинство функций"
" типа ``box.*``, например :ref:`box.space...delete() <box_space-delete>` "
"или :ref:`box.space...update() <box_space-update>`, действительно "
"вызывают :ref:`fiber.testcancel() <fiber-testcancel>`, а "
":ref:`box.space...select{} <box_space-select>` не вызовет. В "
"действительности неконтролируемый файбер может перестать отвечать, если "
"он производит большое количество вычислений и не проверяет вероятность "
"отмены."

#: ../doc/reference/reference_lua/fiber.rst:169
msgid ""
"The other potential problem comes from fibers which never get scheduled, "
"because they are not subscribed to any events, or because no relevant "
"events occur. Such morphing fibers can be killed with :ref:`fiber.kill() "
"<fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends "
"an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() "
"<fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""
"Другой потенциальной проблемой могут стать файберы, которые не включаются"
" в расписание, поскольку они не подписаны ни на какие события, или потому"
" что соответствующие события не происходят. Такие файберы можно в любое "
"принудительно остановить с помощью :ref:`fiber.kill() <fiber-kill>`, "
"потому что функция :ref:`fiber.kill() <fiber-kill>` отправляет "
"асинхронное событие пробуждения на файбер, а :ref:`fiber.testcancel() "
"<fiber-testcancel>` проверяет наступление такого события пробуждения."

#: ../doc/reference/reference_lua/fiber.rst:176
msgid ""
"Like all Lua objects, dead fibers are garbage collected. The Lua garbage "
"collector frees pool allocator memory owned by the fiber, resets all "
"fiber data, and returns the fiber (now called a fiber carcass) to the "
"fiber pool. The carcass can be reused when another fiber is created."
msgstr ""
"Сборщик мусора собирает недоступные файберы так же, как и все "
"Lua-объекты: сборщик мусора в Lua освобождает память выделенного для "
"файбера пула, сбрасывает все данные файбера и возвращает файбер (который "
"теперь называется каркасом файбера) в пул файберов. Каркас можно "
"использовать повторно при создании другого файбера."

#: ../doc/reference/reference_lua/fiber.rst:181
msgid ""
"A fiber has all the features of a Lua coroutine_ and all the programming "
"concepts that apply for Lua coroutines will apply for fibers as well. "
"However, Tarantool has made some enhancements for fibers and has used "
"fibers internally. So, although use of coroutines is possible and "
"supported, use of fibers is recommended."
msgstr ""
"У файбера есть все возможности сопрограммы (coroutine_) на языке Lua, и "
"все принципы программирования, которые применяются к сопрограммам на Lua,"
" применимы и к файберам. Однако Tarantool расширил возможности файберов "
"для внутреннего использования. Поэтому, несмотря на возможность и "
"поддержку использования сопрограмм, рекомендуется использовать файберы."

#: ../doc/reference/reference_lua/fiber.rst:193
msgid ""
"Create and start a fiber. The fiber is created and begins to run "
"immediately."
msgstr ""
"Создание и запуск файбера. Происходит создание файбера, который "
"незамедлительно начинает работу."

#: ../doc/reference/reference_lua/fiber.rst:195
#: ../doc/reference/reference_lua/fiber.rst:234
msgid "the function to be associated with the fiber"
msgstr "функция, которая будет связана с файбером"

#: ../doc/reference/reference_lua/fiber.rst:196
#: ../doc/reference/reference_lua/fiber.rst:235
msgid "what will be passed to function"
msgstr "что передается в функцию"

#: ../doc/reference/reference_lua/fiber.rst
#: ../doc/reference/reference_lua/string.rst
#: ../doc/reference/reference_lua/table.rst
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst
msgid "Return"
msgstr "Возвращается"

#: ../doc/reference/reference_lua/fiber.rst:198
#: ../doc/reference/reference_lua/fiber.rst:237
msgid "created fiber object"
msgstr "созданный объект файбера"

#: ../doc/reference/reference_lua/fiber.rst
#: ../doc/reference/reference_lua/string.rst
#: ../doc/reference/reference_lua/table.rst
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst
msgid "Rtype"
msgstr "Тип возвращаемого значения"

#: ../doc/reference/reference_lua/fiber.rst:199
#: ../doc/reference/reference_lua/fiber.rst:238
#: ../doc/reference/reference_lua/fiber.rst:261
#: ../doc/reference/reference_lua/fiber.rst:281
#: ../doc/reference/reference_lua/fio.rst:786
#: ../doc/reference/reference_lua/http.rst:81
#: ../doc/reference/reference_lua/iconv.rst:53
#: ../doc/reference/reference_lua/net_box.rst:218
#: ../doc/reference/reference_lua/socket.rst:136
#: ../doc/reference/reference_lua/socket.rst:154
#: ../doc/reference/reference_lua/socket.rst:385
#: ../doc/reference/reference_lua/tap.rst:99
msgid "userdata"
msgstr "пользовательские данные"

#: ../doc/reference/reference_lua/fiber.rst:203
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:221
msgid ""
"Create but do not start a fiber: the fiber is created but does not begin "
"to run immediately -- it starts after the fiber creator (that is, the job"
" that is calling ``fiber.new()``) yields, under :ref:`transaction control"
" <atomic-atomic_execution>`. The initial fiber state is 'suspended'. Thus"
" ``fiber.new()`` differs slightly from :ref:`fiber.create() <fiber-"
"create>`."
msgstr ""
"Создание файбера без запуска: файбер создается, но не запускается сразу "
"же, а ожидает, пока создатель файбера (то есть задача, которая вызывает "
"``fiber.new()``) не передаст управление согласно правилам :ref:`контроля "
"транзакций <atomic-atomic_execution>`. Файбер создается со статусом "
"'suspended' (приостановлен). Таким образом, логика ``fiber.new()`` слегка"
" отличается от :ref:`fiber.create() <fiber-create>`."

#: ../doc/reference/reference_lua/fiber.rst:229
msgid ""
"Ordinarily ``fiber.new()`` is used in conjunction with "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` and "
":ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""
"Как правило, ``fiber.new()`` используется вместе с "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` и "
":ref:`fiber_object:join() <fiber_object-join>`."

#: ../doc/reference/reference_lua/fiber.rst:242
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name)\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name)\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:260
msgid "fiber object for the currently scheduled fiber."
msgstr "объект файбера для запланированного на данный момент файбера."

#: ../doc/reference/reference_lua/fiber.rst:265
msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:278
msgid "numeric identifier of the fiber."
msgstr "числовой идентификатор файбера."

#: ../doc/reference/reference_lua/fiber.rst:280
msgid "fiber object for the specified fiber."
msgstr "объект файбера для указанного файбера."

#: ../doc/reference/reference_lua/fiber.rst:285
msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:298
msgid ""
"Yield control to the scheduler and sleep for the specified number of "
"seconds. Only the current fiber can be made to sleep."
msgstr ""
"Передача управления планировщику и переход в режим ожидания на указанное "
"количество секунд. Только текущий файбер можно перевести в режим "
"ожидания."

#: ../doc/reference/reference_lua/fiber.rst:301
msgid "number of seconds to sleep."
msgstr "количество секунд в режиме ожидания."

#: ../doc/reference/reference_lua/fiber.rst:305
msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:315
msgid ""
"Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) "
"<fiber-sleep>`, except that `fiber.sleep(0)` depends on a timer, "
"`fiber.yield()` does not."
msgstr ""
"Передача управления планировщику. Работает аналогично "
":ref:`fiber.sleep(0) <fiber-sleep>`, только `fiber.sleep(0)` зависит от "
"таймера, `fiber.yield()` -- нет."

#: ../doc/reference/reference_lua/fiber.rst:320
msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.yield()\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:330
msgid ""
"Return the status of the current fiber. Or, if optional fiber_object is "
"passed, return the status of the specified fiber."
msgstr ""
"Возврат статуса текущего файбера. Или же, если передается необязательный "
"параметр fiber_object, возврат статуса указанного файбера."

#: ../doc/reference/reference_lua/fiber.rst:334
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""
"статус файбера: “dead” (недоступен), “suspended” (приостановлен) или "
"“running” (активен)."

#: ../doc/reference/reference_lua/fiber.rst:339
msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:350
msgid "Return information about all fibers."
msgstr "Возврат информации о всех файберах."

#: ../doc/reference/reference_lua/fiber.rst:352
msgid ""
"number of context switches, backtrace, id, total memory, used memory, "
"name for each fiber."
msgstr ""
"количество переключений контекста, обратная трассировка, ID, общий объем "
"памяти, объем используемой памяти, имя каждого файбера."

#: ../doc/reference/reference_lua/fiber.rst:358
msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:376
msgid ""
"Locate a fiber by its numeric id and cancel it. In other words, "
":ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-"
"find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""
"Поиск файбера по числовому идентификатору и его отмена. Другими словами, "
":ref:`fiber.kill() <fiber-kill>` объединяет в себе :ref:`fiber.find() "
"<fiber-find>` и :ref:`fiber_object:cancel() <fiber_object-cancel>`."

#: ../doc/reference/reference_lua/fiber.rst:380
msgid "the id of the fiber to be cancelled."
msgstr "ID файбера для отмены."

#: ../doc/reference/reference_lua/fiber.rst
msgid "Exception"
msgstr "Исключение"

#: ../doc/reference/reference_lua/fiber.rst:381
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr "указанный файбер отсутствует, или отмена невозможна."

#: ../doc/reference/reference_lua/fiber.rst:385
msgid ""
"tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""
"tarantool> fiber.kill(fiber.id()) -- функция с self может вызвать "
"окончание программы\n"
"---\n"
"- error: fiber is cancelled\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:397
msgid ""
"Check if the current fiber has been cancelled and throw an exception if "
"this is the case."
msgstr ""
"Проверка отмены действующего файбера и выдача исключения, если файбер "
"отменен."

#: ../doc/reference/reference_lua/fiber.rst:402
msgid ""
"Even if you catch the exception, the fiber will remain cancelled. Most "
"types of calls will check ``fiber.testcancel()``. However, some functions"
" (``id``, ``status``, ``join`` etc.) will return no error. We recommend "
"application developers to implement occasional checks with "
":ref:`fiber.testcancel() <fiber-testcancel>` and to end fiber's execution"
" as soon as possible in case it has been cancelled."
msgstr ""
"Даже при исключении файбер будет отменен. Большинство вызовов проверяют "
"``fiber.testcancel()``. Однако некоторые функции (``id``, ``status``, "
"``join`` и т.д.) не вернут ошибку. Мы рекомендуем разработчикам "
"приложений реализовать случайные проверки :ref:`fiber.testcancel() "
"<fiber-testcancel>` и максимально быстро завершить выполнение файбера, "
"если он был отменен."

#: ../doc/reference/reference_lua/fiber.rst:411
msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:424
#: ../doc/reference/reference_lua/fiber.rst:449
#: ../doc/reference/reference_lua/fiber.rst:477
#: ../doc/reference/reference_lua/fiber.rst:499
#: ../doc/reference/reference_lua/fiber.rst:527
msgid ""
"generally this is an object referenced in the return from "
":ref:`fiber.create <fiber-create>` or :ref:`fiber.self <fiber-self>` or "
":ref:`fiber.find <fiber-find>`"
msgstr ""
"как правило, это объект, полученный в результате вызова "
":ref:`fiber.create <fiber-create>`, :ref:`fiber.self <fiber-self>` или "
":ref:`fiber.find <fiber-find>`"

#: ../doc/reference/reference_lua/fiber.rst:428
msgid "id of the fiber."
msgstr "ID файбера."

#: ../doc/reference/reference_lua/fiber.rst:429
#: ../doc/reference/reference_lua/fiber.rst:902
#: ../doc/reference/reference_lua/fio.rst:319
#: ../doc/reference/reference_lua/fio.rst:1019
#: ../doc/reference/reference_lua/socket.rst:274
#: ../doc/reference/reference_lua/socket.rst:400
#: ../doc/reference/reference_lua/utf8.rst:55
#: ../doc/reference/reference_lua/utf8.rst:116
#: ../doc/reference/reference_lua/utf8.rst:239
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:486
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:501
#: ../doc/reference/reference_sql/sql.rst:248
msgid "number"
msgstr "число"

#: ../doc/reference/reference_lua/fiber.rst:431
msgid "``fiber.self():id()`` can also be expressed as ``fiber.id()``."
msgstr "``fiber.self():id()`` может также быть выражен как ``fiber.id()``."

#: ../doc/reference/reference_lua/fiber.rst:435
msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:453
msgid "name of the fiber."
msgstr "имя файбера."

#: ../doc/reference/reference_lua/fiber.rst:456
msgid "``fiber.self():name()`` can also be expressed as ``fiber.name()``."
msgstr "``fiber.self():name()`` может также быть выражен как ``fiber.name()``."

#: ../doc/reference/reference_lua/fiber.rst:460
msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:471
msgid ""
"Change the fiber name. By default a Tarantool server's interactive-mode "
"fiber is named 'interactive' and new fibers created due to "
":ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers "
"distinct names makes it easier to distinguish them when using "
":ref:`fiber.info <fiber-info>`."
msgstr ""
"Изменение имени файбера. По умолчанию, файбер в интерактивном режиме "
"экземпляра Tarantool'а называется 'interactive', а новые файберы, "
"созданные с помощью :ref:`fiber.create <fiber-create>`, называются 'lua'."
" Переименование файберов позволяет легче различать их при использовании "
":ref:`fiber.info <fiber-info>`."

#: ../doc/reference/reference_lua/fiber.rst:481
msgid "the new name of the fiber."
msgstr "новое имя файбера."

#: ../doc/reference/reference_lua/fiber.rst:487
msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:497
msgid "Return the status of the specified fiber."
msgstr "Возврат статуса указанного файбера."

#: ../doc/reference/reference_lua/fiber.rst:503
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""
"статус файбера: “dead” (недоступен), “suspended” (приостановлен) или "
"“running” (активен)."

#: ../doc/reference/reference_lua/fiber.rst:506
msgid "``fiber.self():status(`` can also be expressed as ``fiber.status()``."
msgstr "``fiber.self():status(`` может также быть выражен как ``fiber.status()``."

#: ../doc/reference/reference_lua/fiber.rst:510
msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:521
#, fuzzy
msgid ""
"Cancel a fiber. Running and suspended fibers can be cancelled. After a "
"fiber has been cancelled, attempts to operate on it will cause errors, "
"for example :ref:`fiber_object:name() <fiber_object-name_get>` will cause"
" ``error: the fiber is dead``. But a dead fiber can still report its id "
"and status."
msgstr ""
"Отмена файбера. Активные и приостановленные файберы можно отменить. После"
" отмены файбера попытки работать с ним вызовут ошибку, например, вызов "
":ref:`fiber_object:name() <fiber_object-name_get>` вызовет ошибку с "
"указанием недоступности файбера ``error: the fiber is dead``."

#: ../doc/reference/reference_lua/fiber.rst:533
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr "Возможные ошибки: нельзя отменить указанный объект файбера."

#: ../doc/reference/reference_lua/fiber.rst:537
msgid ""
"tarantool> fiber.self():cancel() -- kill self, may make program end\n"
"---\n"
"...\n"
"tarantool> fiber.self():cancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"...\n"
"tarantool> fiber.self:id()\n"
"---\n"
"- 163\n"
"...\n"
"tarantool> fiber.self:status()\n"
"---\n"
"- dead\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:559
msgid ""
"Local storage within the fiber. The storage can contain any number of "
"named values, subject to memory limitations. Naming may be done with "
":samp:`{fiber_object}.storage.{name}` or "
":samp:`{fiber_object}.storage['{name}'].` or with a number "
":samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or"
" strings. The Lua garbage collector will mark or free the local storage "
"when :samp:`{fiber_object}:cancel()` happens."
msgstr ""
"Локальное хранилище в пределах файбера. Хранилище может содержать любое "
"количество именованных значений при соблюдении ограничений памяти. "
"Правила именования: :samp:`{объект_файбера}.storage.{имя}`, либо "
":samp:`{объект_файбера}.storage['{имя}'].`, либо с числом "
":samp:`{объект_файбера}.storage[{число}]`. Значения могут быть числовыми "
"или строковыми. Сборщик мусора в Lua отметит или освободит локальное "
"хранилище при вызове :samp:`{fiber_object}:cancel()`."

#: ../doc/reference/reference_lua/fiber.rst:568
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the "
"fiber is dead'\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the "
"fiber is dead'\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:594
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr "См. также :ref:`box.session.storage <box_session-storage>`."

#: ../doc/reference/reference_lua/fiber.rst:600
msgid ""
"``fiber_object:set_joinable(true)`` makes a fiber joinable; "
"``fiber_object:set_joinable(false)`` makes a fiber not joinable; the "
"default is false."
msgstr ""
"``fiber_object:set_joinable(true)`` делает файбер доступным для "
"присоединения; ``fiber_object:set_joinable(false)`` делает файбер "
"недоступным для присоединения; по умолчанию, false."

#: ../doc/reference/reference_lua/fiber.rst:604
msgid ""
"A joinable fiber can be waited for, with :ref:`fiber_object:join() "
"<fiber_object-join>`."
msgstr ""
"Присоединяемый файбер можно ожидать с помощью :ref:`fiber_object:join() "
"<fiber_object-join>`."

#: ../doc/reference/reference_lua/fiber.rst:607
msgid ""
"Best practice is to call ``fiber_object:set_joinable()`` before the fiber"
" function begins to execute, because otherwise the fiber could become "
"'dead' before ``fiber_object:set_joinable()`` takes effect. The usual "
"sequence could be:"
msgstr ""
"Лучше всего вызвать ``fiber_object:set_joinable()`` до начала выполнения "
"функции с файбером, поскольку в противном случае файбер может стать "
"недоступен до того, как сработает ``fiber_object:set_joinable()``. "
"Правильная последовательность может быть такой:"

#: ../doc/reference/reference_lua/fiber.rst:612
msgid ""
"Call ``fiber.new()`` instead of ``fiber.create()`` to create a new "
"fiber_object."
msgstr ""
"Вызов ``fiber.new()`` вместо ``fiber.create()`` для создания нового "
"объекта файбера fiber_object."

#: ../doc/reference/reference_lua/fiber.rst:615
msgid ""
"Do not yield at this point, because that will cause the fiber function to"
" begin."
msgstr ""
"Не передавать управление, поскольку это приведет к началу работы функции "
"с файбером."

#: ../doc/reference/reference_lua/fiber.rst:618
msgid ""
"Call ``fiber_object:set_joinable(true)`` to make the new fiber_object "
"joinable."
msgstr ""
"Вызов ``fiber_object:set_joinable(true)``, чтобы сделать новый объект "
"файбера fiber_object присоединяемым."

#: ../doc/reference/reference_lua/fiber.rst:621
msgid "Now it is safe to yield."
msgstr "Сейчас можно передать управление."

#: ../doc/reference/reference_lua/fiber.rst:623
msgid "Call ``fiber_object:join()``."
msgstr "Вызов ``fiber_object:join()``."

#: ../doc/reference/reference_lua/fiber.rst:625
msgid ""
"Usually ``fiber_object:join()`` should be called, otherwise the fiber's "
"status may become 'suspended' when the fiber function ends, instead of "
"'dead'."
msgstr ""
"Как правило, следует вызвать ``fiber_object:join()``, в противном случае,"
" статус файбера может перейти в 'suspended' (приостановлен) после "
"выполнения функции, а не 'dead' (недоступен)."

#: ../doc/reference/reference_lua/fiber.rst:629
msgid "the boolean value that changes the ``set_joinable`` flag"
msgstr "логическое значение, которое изменяет флаг ``set_joinable``"

#: ../doc/reference/reference_lua/fiber.rst:636
#: ../doc/reference/reference_lua/fiber.rst:686
msgid "The result of the following sequence of requests is:"
msgstr "Результат следующего ряда запросов:"

#: ../doc/reference/reference_lua/fiber.rst:638
msgid ""
"the global variable ``d`` will be 6 (which proves that the function was "
"not executed until after ``d`` was set to 1, when ``fiber.sleep(1)`` "
"caused a yield);"
msgstr ""
"глобальная переменная ``d`` получит значение 6 (что доказывает, что "
"функция не выполнялась до тех пор, пока значение ``d`` не стало 1, когда "
"``fiber.sleep(1)`` вызвал передачу управления);"

#: ../doc/reference/reference_lua/fiber.rst:641
msgid ""
"``fiber.status(fi2)`` will be 'suspended' (which proves that after the "
"function was executed the fiber status did not change to 'dead')."
msgstr ""
"``fiber.status(fi2)`` будет приостановлен 'suspended' (что доказывает, "
"что после выполнения функции статус файбера не изменился на недоступный "
"'dead')."

#: ../doc/reference/reference_lua/fiber.rst:644
msgid ""
"fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"
msgstr ""
"fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"

#: ../doc/reference/reference_lua/fiber.rst:657
msgid ""
"\"Join\" a joinable fiber. That is, let the fiber's function run and wait"
" until the fiber's status is 'dead' (normally a status becomes 'dead' "
"when the function execution finishes). Joining will cause a yield, "
"therefore, if the fiber is currently in a suspended state, execution of "
"its fiber function will resume."
msgstr ""
"\"Присоединение\" присоединяемого файбера. То есть возможность запуска "
"функции с файбером и ожидание перехода файбера в статус недоступности "
"'dead' (как правило, статус переходит в 'dead', когда заканчивается "
"выполнение функции). Присоединение вызовет передачу управления, таким "
"образом, если файбер находится в приостановленном состоянии, выполнение "
"функции файбера возобновится."

#: ../doc/reference/reference_lua/fiber.rst:665
msgid ""
"This kind of waiting is more convenient than going into a loop and "
"periodically checking the status; however, it works only if the fiber was"
" created with :ref:`fiber.new() <fiber-new>` and was made joinable with "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."
msgstr ""
"Такое ожидание более удобно, чем переход в цикл с периодической проверкой"
" статуса; тем не менее, это работает, только если файбер был создан с "
"помощью :ref:`fiber.new() <fiber-new>` и стал доступным для присоединения"
" путем :ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."

#: ../doc/reference/reference_lua/fiber.rst:672
msgid ""
"two values. The first value is boolean. If the first value is true, then "
"the join succeeded because the fiber's function ended normally and the "
"second result has the return value from the fiber's function. If the "
"first value is false, then the join succeeded because the fiber's "
"function ended abnormally and the second result has the details about the"
" error, which one can unpack in the same way that one unpacks :ref:`a "
"pcall result <error_handling>`."
msgstr ""
"два значения. Первое значение логическое. Если первое значение = true "
"(правда), значит присоединение прошло успешно, поскольку функция файбера "
"была выполнена нормально, а второй результат -- это возвращаемое значение"
" функции файбера. Если же первое значение = false (ложь), значит "
"присоединение не было осуществлено, поскольку выполнение функции файбера "
"было прервано, а второй результат содержит подробную информацию об "
"ошибке, которую можно распаковать так же, как :ref:`результат вызова "
"pcall <error_handling>`."

#: ../doc/reference/reference_lua/fiber.rst:682
msgid "boolean +result type, or boolean + struct error"
msgstr ""
"логическое значение +тип результата, или логическое значение + ошибка "
"структуры"

#: ../doc/reference/reference_lua/fiber.rst:688
msgid "the first ``fiber.status()`` call returns 'suspended',"
msgstr "первый вызов ``fiber.status()`` возвращает 'suspended' (приостановлен),"

#: ../doc/reference/reference_lua/fiber.rst:689
msgid "the ``join()`` call returns true,"
msgstr "вызов ``join()`` возвращает true (правда),"

#: ../doc/reference/reference_lua/fiber.rst:690
msgid "the elapsed time is usually 5 seconds, and"
msgstr "как правило, проходит 5 секунд, и"

#: ../doc/reference/reference_lua/fiber.rst:691
msgid "the second ``fiber.status()`` call returns 'dead'."
msgstr "второй вызов ``fiber.status()`` возвращает 'dead' (недоступен)."

#: ../doc/reference/reference_lua/fiber.rst:693
msgid ""
"This proves that the ``join()`` does not return until the function -- "
"which sleeps 5 seconds -- is 'dead'."
msgstr ""
"Это доказывает, что ``join()`` не возвращает результат, пока функция, "
"которая находится в режиме ожидания в течение 5 секунд, недоступна "
"('dead')."

#: ../doc/reference/reference_lua/fiber.rst:696
msgid ""
"fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"
msgstr ""
"fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"

#: ../doc/reference/reference_lua/fiber.rst:711
msgid ""
"current system time (in seconds since the epoch) as a Lua number. The "
"time is taken from the event loop clock, which makes this call very "
"cheap, but still useful for constructing artificial tuple keys."
msgstr ""
"текущее системное время (в секундах с начала отсчета) в виде Lua-числа. "
"Время берется из часов событийного цикла, поэтому вызов полезен лишь для "
"создания искусственных ключей кортежа."

#: ../doc/reference/reference_lua/fiber.rst:715
#: ../doc/reference/reference_lua/fiber.rst:734
msgid "num"
msgstr "num"

#: ../doc/reference/reference_lua/fiber.rst:719
msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:731
msgid ""
"current system time (in microseconds since the epoch) as a 64-bit "
"integer. The time is taken from the event loop clock."
msgstr ""
"текущее системное время (в микросекундах с начала отсчета) в виде "
"64-битного целого числа. Время берется из часов событийного цикла."

#: ../doc/reference/reference_lua/fiber.rst:738
msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:750
msgid ""
"Make the function which will be associated with the fiber. This function "
"contains an infinite loop. Each iteration of the loop adds 1 to a global "
"variable named gvar, then goes to sleep for 2 seconds. The sleep causes "
"an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""
"Создание функции, которая будет связана с файбером. Такая функция "
"содержит бесконечный цикл. Каждая итерация цикла прибавляет 1 к "
"глобальной переменной под названием ``gvar``, а затем уходит в режим "
"ожидания на 2 секунды. Ожидание вызывает неявную передачу управления "
":ref:`fiber.yield() <fiber-yield>`."

#: ../doc/reference/reference_lua/fiber.rst:755
msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:768
msgid ""
"Make a fiber, associate function_x with the fiber, and start function_x. "
"It will immediately \"detach\" so it will be running independently of the"
" caller."
msgstr ""
"Создание файбера, ассоциация функции function_x с файбером и запуск "
"function_x. Она сразу же \"отсоединится\", то есть будет работать "
"отдельно от вызывающего метода."

#: ../doc/reference/reference_lua/fiber.rst:771
msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:779
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr "Получение ID файбера (fid) для последующего вывода."

#: ../doc/reference/reference_lua/fiber.rst:781
msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:787
msgid ""
"Pause for a while, while the detached function runs. Then ... Display the"
" fiber id, the fiber status, and gvar (gvar will have gone up a bit "
"depending how long the pause lasted). The status is suspended because the"
" fiber spends almost all its time sleeping or yielding."
msgstr ""
"Небольшая остановка, пока работает отсоединенная функция. Затем ... "
"Отображение идентификатора файбера, статуса файбера и переменной gvar "
"(значение gvar немного увеличится в зависимости от длительности паузы). "
"Статус будет \"suspended\" (приостановлен), потому что файбер практически"
" всё время проводит в режиме ожидания или передачи управления."

#: ../doc/reference/reference_lua/fiber.rst:792
msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:799
msgid ""
"Pause for a while, while the detached function runs. Then ... Cancel the "
"fiber. Then, once again ... Display the fiber id, the fiber status, and "
"gvar (gvar will have gone up a bit more depending how long the pause "
"lasted). This time the status is dead because the cancel worked."
msgstr ""
"Небольшая остановка, пока работает отсоединенная функция. Затем ... "
"Отмена файбера. Затем снова отображение идентификатора файбера, статуса "
"файбера и переменной gvar (значение gvar немного увеличится в зависимости"
" от длительности паузы). На этот раз статус будет \"dead\" (недоступен), "
"потому что произошла отмена."

#: ../doc/reference/reference_lua/fiber.rst:804
msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/fiber.rst:820
msgid "Channels"
msgstr "Каналы"

#: ../doc/reference/reference_lua/fiber.rst:822
msgid ""
"Call ``fiber.channel()`` to allocate space and get a channel object, "
"which will be called channel for examples in this section."
msgstr ""
"Вызов ``fiber.channel()`` для выделения спейса и получение объекта "
"канала, который будет называться \"channel\" в примерах данного раздела."

#: ../doc/reference/reference_lua/fiber.rst:825
msgid ""
"Call the other routines, via channel, to send messages, receive messages,"
" or check channel status."
msgstr ""
"Вызов других процедур по каналу для отправки сообщений, получения "
"сообщений или проверки статуса канала."

#: ../doc/reference/reference_lua/fiber.rst:828
msgid ""
"Message exchange is synchronous. The Lua garbage collector will mark or "
"free the channel when no one is using it, as with any other Lua object. "
"Use object-oriented syntax, for example ``channel:put(message)`` rather "
"than ``fiber.channel.put(message)``."
msgstr ""
"Обмен сообщения происходит синхронно. Сборщик мусора в Lua отмечает или "
"освобождает канал, когда его никто не использует, как и любой другой "
"Lua-объект. Используйте объектно-ориентированный синтаксис, например "
"``channel:put(message)``, а не ``fiber.channel.put(message)``."

#: ../doc/reference/reference_lua/fiber.rst:837
msgid "Create a new communication channel."
msgstr "Создание нового канала связи."

#: ../doc/reference/reference_lua/fiber.rst:839
msgid ""
"the maximum number of slots (spaces for ``channel:put`` messages) that "
"can be in use at once. The default is 0."
msgstr ""
"максимальное количество слотов (спейсы для сообщений ``channel:put``), "
"которые можно использовать одновременно. По умолчанию, 0."

#: ../doc/reference/reference_lua/fiber.rst:843
msgid "new channel."
msgstr "новый канал."

#: ../doc/reference/reference_lua/fiber.rst:844
msgid "userdata, possibly including the string \"channel ...\"."
msgstr "пользовательские данные, возможно включая строку \"channel ...\"."

#: ../doc/reference/reference_lua/fiber.rst:852
msgid ""
"Send a message using a channel. If the channel is full, ``channel:put()``"
" waits until there is a free slot in the channel."
msgstr ""
"Отправка сообщения по каналу связи. Если канал заполнен, "
"``channel:put()`` ожидает, пока не освободится слот в канале."

#: ../doc/reference/reference_lua/fiber.rst:855
msgid "what will be sent, usually a string or number or table"
msgstr "то, что отправляется, как правило, строка, число или таблица"

#: ../doc/reference/reference_lua/fiber.rst:856
msgid "maximum number of seconds to wait for a slot to become free"
msgstr "максимальное количество секунд ожидания, чтобы слот освободился"

#: ../doc/reference/reference_lua/fiber.rst:857
msgid ""
"If timeout is specified, and there is no free slot in the channel for the"
" duration of the timeout, then the return value is ``false``. If the "
"channel is closed, then the return value is ``false``. Otherwise, the "
"return value is ``true``, indicating success."
msgstr ""
"Если указан параметр времени ожидания timeout, и в канале нет свободного "
"слота в течение указанного времени, возвращается значение ``false`` "
"(ложь). Если канал закрыт, возвращается значение ``false``. В остальных "
"случаях возвращается значение ``true`` (правда), которое указывает на "
"успешную отправку."

#: ../doc/reference/reference_lua/fiber.rst:861
#: ../doc/reference/reference_lua/fiber.rst:893
#: ../doc/reference/reference_lua/fiber.rst:913
#: ../doc/reference/reference_lua/fiber.rst:923
#: ../doc/reference/reference_lua/fiber.rst:933
#: ../doc/reference/reference_lua/fiber.rst:941
#: ../doc/reference/reference_lua/fiber.rst:1053
#: ../doc/reference/reference_lua/fio.rst:270
#: ../doc/reference/reference_lua/fio.rst:278
#: ../doc/reference/reference_lua/fio.rst:286
#: ../doc/reference/reference_lua/fio.rst:294
#: ../doc/reference/reference_lua/fio.rst:302
#: ../doc/reference/reference_lua/fio.rst:394
#: ../doc/reference/reference_lua/fio.rst:414
#: ../doc/reference/reference_lua/fio.rst:514
#: ../doc/reference/reference_lua/fio.rst:536
#: ../doc/reference/reference_lua/fio.rst:559
#: ../doc/reference/reference_lua/fio.rst:611
#: ../doc/reference/reference_lua/fio.rst:635
#: ../doc/reference/reference_lua/fio.rst:658
#: ../doc/reference/reference_lua/fio.rst:706
#: ../doc/reference/reference_lua/fio.rst:724
#: ../doc/reference/reference_lua/fio.rst:825
#: ../doc/reference/reference_lua/fio.rst:884
#: ../doc/reference/reference_lua/fio.rst:969
#: ../doc/reference/reference_lua/fio.rst:996
#: ../doc/reference/reference_lua/net_box.rst:238
#: ../doc/reference/reference_lua/net_box.rst:254
#: ../doc/reference/reference_lua/net_box.rst:269
#: ../doc/reference/reference_lua/net_box.rst:286
#: ../doc/reference/reference_lua/socket.rst:255
#: ../doc/reference/reference_lua/socket.rst:361
#: ../doc/reference/reference_lua/socket.rst:437
#: ../doc/reference/reference_lua/socket.rst:449
#: ../doc/reference/reference_lua/string.rst:176
#: ../doc/reference/reference_lua/string.rst:206
#: ../doc/reference/reference_lua/tap.rst:155
#: ../doc/reference/reference_lua/tap.rst:178
#: ../doc/reference/reference_lua/tap.rst:212
#: ../doc/reference/reference_lua/tap.rst:247
#: ../doc/reference/reference_lua/tap.rst:260
#: ../doc/reference/reference_lua/tap.rst:270
#: ../doc/reference/reference_lua/tap.rst:285
#: ../doc/reference/reference_lua/tap.rst:306
#: ../doc/reference/reference_lua/tap.rst:325
#: ../doc/reference/reference_lua/utf8.rst:147
#: ../doc/reference/reference_lua/utf8.rst:172
#: ../doc/reference/reference_lua/utf8.rst:194
#: ../doc/reference/reference_lua/utf8.rst:216
#: ../doc/reference/reference_rock/membership.rst:172
#: ../doc/reference/reference_rock/membership.rst:232
#: ../doc/reference/reference_rock/membership.rst:244
#: ../doc/reference/reference_rock/membership.rst:255
#: ../doc/reference/reference_rock/membership.rst:268
#: ../doc/reference/reference_rock/membership.rst:278
#: ../doc/reference/reference_rock/membership.rst:285
#: ../doc/reference/reference_sql/sql.rst:242
msgid "boolean"
msgstr "boolean (логический)"

#: ../doc/reference/reference_lua/fiber.rst:867
msgid ""
"Close the channel. All waiters in the channel will stop waiting. All "
"following ``channel:get()`` operations will return ``nil``, and all "
"following ``channel:put()`` operations will return ``false``."
msgstr ""
"Закрытие канала. Все, кто находится в режиме ожидания в канале, "
"отключаются. Все последующие операции ``channel:get()`` вернут нулевое "
"значение ``nil``, а все последующие операции ``channel:put()`` вернут "
"``false`` (ложь)."

#: ../doc/reference/reference_lua/fiber.rst:875
msgid ""
"Fetch and remove a message from a channel. If the channel is empty, "
"``channel:get()`` waits for a message."
msgstr ""
"Перехват и удаление сообщения из канала. Если канал пуст, "
"``channel:get()`` будет ожидать сообщения."

#: ../doc/reference/reference_lua/fiber.rst:878
msgid "maximum number of seconds to wait for a message"
msgstr "максимальное количество секунд ожидания сообщения"

#: ../doc/reference/reference_lua/fiber.rst:879
msgid ""
"If timeout is specified, and there is no message in the channel for the "
"duration of the timeout, then the return value is ``nil``. If the channel"
" is closed, then the return value is ``nil``. Otherwise, the return value"
" is the message placed on the channel by ``channel:put()``."
msgstr ""
"Если указан параметр времени ожидания timeout, и в канале нет сообщения в"
" течение указанного времени, возвращается нулевое значение ``nil``. Если "
"канал закрыт, возвращается значение ``nil``. В остальных случаях "
"возвращается сообщение, отправленное на канал с помощью "
"``channel:put()``."

#: ../doc/reference/reference_lua/fiber.rst:884
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr "как правило, строка, число или таблица, как определяет ``channel:put()``"

#: ../doc/reference/reference_lua/fiber.rst:890
msgid "Check whether the channel is empty (has no messages)."
msgstr "Проверка пустоты канала (отсутствие сообщений)."

#: ../doc/reference/reference_lua/fiber.rst:892
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr "``true`` (правда), если канал пуст. В противном случае, ``false`` (ложь)."

#: ../doc/reference/reference_lua/fiber.rst:899
msgid "Find out how many messages are in the channel."
msgstr "Определение количества сообщений в канале."

#: ../doc/reference/reference_lua/fiber.rst:901
msgid "the number of messages."
msgstr "количество сообщений."

#: ../doc/reference/reference_lua/fiber.rst:908
msgid "Check whether the channel is full."
msgstr "Проверка заполненности канала."

#: ../doc/reference/reference_lua/fiber.rst:910
msgid ""
"``true`` if the channel is full (the number of messages in the channel "
"equals the number of slots so there is no room for a new message). "
"Otherwise ``false``."
msgstr ""
"``true`` (правда), если канал заполнен (количество сообщений в канале "
"равно количеству слотов, то есть нет места для новых сообщений). В "
"противном случае, ``false`` (ложь)."

#: ../doc/reference/reference_lua/fiber.rst:919
msgid ""
"Check whether readers are waiting for a message because they have issued "
"``channel:get()`` and the channel is empty."
msgstr ""
"Проверка пустого канала на наличие читателей в состоянии ожидания "
"сообщения после отправки запросов ``channel:get()``."

#: ../doc/reference/reference_lua/fiber.rst:922
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""
"``true`` (правда), если на канале есть читатели в ожидании сообщения. В "
"противном случае, ``false`` (ложь)."

#: ../doc/reference/reference_lua/fiber.rst:929
msgid ""
"Check whether writers are waiting because they have issued "
"``channel:put()`` and the channel is full."
msgstr ""
"Проверка полного канала на наличие писателей в состоянии ожидания после "
"отправки запросов ``channel:put()``."

#: ../doc/reference/reference_lua/fiber.rst:932
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""
"``true`` (правда), если на канале есть писатели в состоянии ожидании. В "
"противном случае, ``false`` (ложь)."

#: ../doc/reference/reference_lua/fiber.rst:939
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""
"``true`` (правда), если канал уже закрыт. В противном случае, ``false`` "
"(ложь)."

#: ../doc/reference/reference_lua/fiber.rst:947
msgid ""
"This example should give a rough idea of what some functions for fibers "
"should look like. It's assumed that the functions would be referenced in "
":ref:`fiber.create() <fiber-create>`."
msgstr ""
"В данном примере дается примерное представление о том, как должны "
"выглядеть функции для файберов. Предполагается, что на функции ссылается "
":ref:`fiber.create() <fiber-create>`."

#: ../doc/reference/reference_lua/fiber.rst:951
msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""
"fiber = require('fiber')\n"
" channel = fiber.channel(10)\n"
" function consumer_fiber()\n"
"     while true do\n"
"         local task = channel:get()\n"
"         ...\n"
"     end\n"
" end\n"
" \n"
" function consumer2_fiber()\n"
"     while true do\n"
"         -- 10 секунд\n"
"         local task = channel:get(10)\n"
"         if task ~= nil then\n"
"             ...\n"
"         else\n"
"             -- время ожидания\n"
"         end\n"
"     end\n"
" end\n"
" \n"
" function producer_fiber()\n"
"     while true do\n"
"         task = box.space...:select{...}\n"
"         ...\n"
"         if channel:is_empty() then\n"
"             -- канал пуст\n"
"         end\n"
" \n"
"         if channel:is_full() then\n"
"             -- канал полон\n"
"         end\n"
" \n"
"         ...\n"
"         if channel:has_readers() then\n"
"             -- есть файберы\n"
"             -- которые ожидают данные\n"
"         end\n"
"         ...\n"
" \n"
"         if channel:has_writers() then\n"
"             -- есть файберы\n"
"             -- которые ожидают читателей\n"
"         end\n"
"         channel:put(task)\n"
"     end\n"
" end\n"
" \n"
" function producer2_fiber()\n"
"     while true do\n"
"         task = box.space...select{...}\n"
"         -- 10 секунд\n"
"         if channel:put(task, 10) then\n"
"             ...\n"
"         else\n"
"             -- время ожидания\n"
"         end\n"
"     end\n"
" end"

#: ../doc/reference/reference_lua/fiber.rst:1017
msgid "Condition variables"
msgstr "Условные переменные"

#: ../doc/reference/reference_lua/fiber.rst:1019
msgid ""
"Call ``fiber.cond()`` to create a named condition variable, which will be"
" called 'cond' for examples in this section."
msgstr ""
"Вызов ``fiber.cond()`` используется для создания именованной условной "
"переменной, которая будет называться 'cond' для примеров данного раздела."

#: ../doc/reference/reference_lua/fiber.rst:1022
msgid ""
"Call ``cond:wait()`` to make a fiber wait for a signal via a condition "
"variable."
msgstr ""
"Вызов ``cond:wait()`` используется, чтобы заставить файбер ожидать "
"сигнал, с помощью условной переменной."

#: ../doc/reference/reference_lua/fiber.rst:1024
msgid ""
"Call ``cond:signal()`` to send a signal to wake up a single fiber that "
"has executed ``cond:wait()``."
msgstr ""
"Вызов ``cond:signal()`` используется, чтобы отправить сигнал для "
"пробуждения отдельного файбера, который выполнил запрос ``cond:wait()``."

#: ../doc/reference/reference_lua/fiber.rst:1027
msgid ""
"Call ``cond:broadcast()`` to send a signal to all fibers that have "
"executed ``cond:wait()``."
msgstr ""
"Вызов ``cond:broadcast()`` используется для отправки сигнала всем "
"файберам, которые выполнили ``cond:wait()``."

#: ../doc/reference/reference_lua/fiber.rst:1034
msgid "Create a new condition variable."
msgstr "Создание новой условной переменной."

#: ../doc/reference/reference_lua/fiber.rst:1036
msgid "new condition variable."
msgstr "новая условная переменная."

#: ../doc/reference/reference_lua/fiber.rst:1037
msgid "Lua object"
msgstr "Lua-объект"

#: ../doc/reference/reference_lua/fiber.rst:1045
msgid ""
"Make the current fiber go to sleep, waiting until another fiber invokes "
"the ``signal()`` or ``broadcast()`` method on the cond object. The sleep "
"causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""
"Перевод файбера в режим ожидания до пробуждения другим файбером с помощью"
" метода ``signal()`` или ``broadcast()``. Переход в режим ожидания "
"вызывает неявную передачу управления :ref:`fiber.yield() <fiber-yield>`."

#: ../doc/reference/reference_lua/fiber.rst:1049
msgid "number of seconds to wait, default = forever."
msgstr "количество секунд ожидания, по умолчанию = всегда."

#: ../doc/reference/reference_lua/fiber.rst:1050
msgid ""
"If timeout is provided, and a signal doesn't happen for the duration of "
"the timeout, ``wait()`` returns false. If a signal or broadcast happens, "
"``wait()`` returns true."
msgstr ""
"Если указан параметр времени ожидания timeout, и сигнал не передается в "
"течение указанного времени, ``wait()`` вернет значение false (ложь). Если"
" передается ``signal()`` или ``broadcast()``, ``wait()`` вернет true "
"(правда)."

#: ../doc/reference/reference_lua/fiber.rst:1059
msgid "Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""
"Пробуждение отдельного файбера, который выполнил ``wait()`` для той же "
"переменной."

#: ../doc/reference/reference_lua/fiber.rst:1068
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""
"Пробуждение всех файберов, которые выполнили ``wait()`` для той же "
"переменной."

#: ../doc/reference/reference_lua/fiber.rst:1076
msgid ""
"Assume that a tarantool instance is running and listening for connections"
" on localhost port 3301. Assume that guest users have privileges to "
"connect. We will use the tarantoolctl utility to start two clients."
msgstr ""
"Предположим, что запущен экземпляр Tarantool'а на прослушивание на "
"localhost по порту 3301. Предположим, что у пользователя guest есть права"
" на подключение. Используем утилиту tarantoolctl для запуска двух "
"клиентов."

#: ../doc/reference/reference_lua/fiber.rst:1080
msgid "On terminal #1, say"
msgstr "В первом терминале введите:"

#: ../doc/reference/reference_lua/fiber.rst:1082
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"

#: ../doc/reference/reference_lua/fiber.rst:1089
msgid ""
"The job will hang because ``cond:wait()`` -- without an optional timeout "
"argument -- will go to sleep until the condition variable changes."
msgstr ""
"Задача повиснет, поскольку ``cond:wait()`` -- без дополнительного "
"аргумента времени ожидания timeout -- уйдет в режим ожидания до изменения"
" условной переменной."

#: ../doc/reference/reference_lua/fiber.rst:1092
msgid "On terminal #2, say"
msgstr "Во втором терминале введите:"

#: ../doc/reference/reference_lua/fiber.rst:1094
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"

#: ../doc/reference/reference_lua/fiber.rst:1099
msgid ""
"Now look again at terminal #1. It will show that the waiting stopped, and"
" the ``cond:wait()`` function returned ``true``."
msgstr ""
"Теперь снова взгляните на терминал №1. Он покажет, что ожидание "
"прекратилось, и функция ``cond:wait()`` вернула значение ``true``."

#: ../doc/reference/reference_lua/fiber.rst:1102
msgid ""
"This example depended on the use of a global conditional variable with "
"the arbitrary name ``cond``. In real life, programmers would make sure to"
" use different conditional variable names for different applications."
msgstr ""
"В данном примере показана зависимость от использования глобальной "
"условной переменной с произвольным именем ``cond``. В реальной жизни "
"разработчики следят за использованием различных имен для условных "
"переменных в разных приложениях."

#: ../doc/reference/reference_lua/fio.rst:5
msgid "Module `fio`"
msgstr "Модуль `fio`"

#: ../doc/reference/reference_lua/fio.rst:13
msgid ""
"Tarantool supports file input/output with an API that is similar to POSIX"
" syscalls. All operations are performed asynchronously. Multiple fibers "
"can access the same file simultaneously."
msgstr ""
"Tarantool поддерживает файловый ввод-вывод с помощью API, который "
"аналогичен системным вызовам POSIX. Все операции проводятся асинхронно. "
"Несколько файберов могут получать доступ к одному файлу одновременно."

#: ../doc/reference/reference_lua/fio.rst:17
msgid "The ``fio`` module contains:"
msgstr "Модуль ``fio`` включает в себя:"

#: ../doc/reference/reference_lua/fio.rst:19
msgid "functions for :ref:`common pathname manipulations <fio-pathname>`,"
msgstr "функции для :ref:`стандартных действий с путем к файлу <fio-pathname>`,"

#: ../doc/reference/reference_lua/fio.rst:20
msgid ""
"functions for :ref:`directory or file existence and type checks<fio-"
"checks>`,"
msgstr ""
"функции для :ref:`проверки наличия и типа директории или файла <fio-"
"checks>`,"

#: ../doc/reference/reference_lua/fio.rst:21
msgid "functions for :ref:`common file manipulations <fio-file>`, and"
msgstr "функции для :ref:`стандартных действий с файлами <fio-file>`, а также"

#: ../doc/reference/reference_lua/fio.rst:22
msgid ""
":ref:`constants <fio-c>` which are the same as POSIX flag values (for "
"example ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."
msgstr ""
":ref:`постоянные <fio-c>`., которые совпадают с флаговыми значениями "
"POSIX (например, ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."

#: ../doc/reference/reference_lua/fio.rst:29
msgid "Below is a list of all ``fio`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``fio``."

#: ../doc/reference/reference_lua/fio.rst:41
msgid ":ref:`fio.pathjoin() <fio-pathjoin>`"
msgstr ":ref:`fio.pathjoin() <fio-pathjoin>`"

#: ../doc/reference/reference_lua/fio.rst:41
msgid "Form a path name from one or more partial strings"
msgstr "Формирование пути к файлу из одной или более частей строки"

#: ../doc/reference/reference_lua/fio.rst:44
msgid ":ref:`fio.basename() <fio-basename>`"
msgstr ":ref:`fio.basename() <fio-basename>`"

#: ../doc/reference/reference_lua/fio.rst:44
msgid "Get a file name"
msgstr "Получение имени файла"

#: ../doc/reference/reference_lua/fio.rst:47
msgid ":ref:`fio.dirname() <fio-dirname>`"
msgstr ":ref:`fio.dirname() <fio-dirname>`"

#: ../doc/reference/reference_lua/fio.rst:47
msgid "Get a directory name"
msgstr "Получение имени директории"

#: ../doc/reference/reference_lua/fio.rst:50
msgid ":ref:`fio.abspath() <fio-abspath>`"
msgstr ":ref:`fio.abspath() <fio-abspath>`"

#: ../doc/reference/reference_lua/fio.rst:50
msgid "Get a directory and file name"
msgstr "Получение имен директории и файла"

#: ../doc/reference/reference_lua/fio.rst:53
msgid ":ref:`fio.path.exists() <fio-path_exists>`"
msgstr ":ref:`fio.path.exists() <fio-path_exists>`"

#: ../doc/reference/reference_lua/fio.rst:53
#: ../doc/reference/reference_lua/fio.rst:65
msgid "Check if file or directory exists"
msgstr "Проверка наличия файла или директории"

#: ../doc/reference/reference_lua/fio.rst:56
msgid ":ref:`fio.path.is_dir() <fio-path_is_dir>`"
msgstr ":ref:`fio.path.is_dir() <fio-path_is_dir>`"

#: ../doc/reference/reference_lua/fio.rst:56
msgid "Check if file or directory is a directory"
msgstr "Проверка, является ли файл или директория директорией"

#: ../doc/reference/reference_lua/fio.rst:59
msgid ":ref:`fio.path.is_file() <fio-path_is_file>`"
msgstr ":ref:`fio.path.is_file() <fio-path_is_file>`"

#: ../doc/reference/reference_lua/fio.rst:59
msgid "Check if file or directory is a file"
msgstr "Проверка, является ли файл или директория файлом"

#: ../doc/reference/reference_lua/fio.rst:62
msgid ":ref:`fio.path.is_link() <fio-path_is_link>`"
msgstr ":ref:`fio.path.is_link() <fio-path_is_link>`"

#: ../doc/reference/reference_lua/fio.rst:62
msgid "Check if file or directory is a link"
msgstr "Проверка, является ли файл или директория ссылкой"

#: ../doc/reference/reference_lua/fio.rst:65
msgid ":ref:`fio.path.lexists() <fio-path_lexists>`"
msgstr ":ref:`fio.path.lexists() <fio-path_lexists>`"

#: ../doc/reference/reference_lua/fio.rst:68
msgid ":ref:`fio.umask() <fio-umask>`"
msgstr ":ref:`fio.umask() <fio-umask>`"

#: ../doc/reference/reference_lua/fio.rst:68
msgid "Set mask bits"
msgstr "Определение битов маски"

#: ../doc/reference/reference_lua/fio.rst:71
msgid ":ref:`fio.lstat() <fio-stat>` |br| :ref:`fio.stat() <fio-stat>`"
msgstr ":ref:`fio.lstat() <fio-stat>` |br| :ref:`fio.stat() <fio-stat>`"

#: ../doc/reference/reference_lua/fio.rst:72
msgid "Get information about a file object"
msgstr "Получение информации об объекте файла"

#: ../doc/reference/reference_lua/fio.rst:76
msgid ":ref:`fio.mkdir() <fio-mkdir>` |br| :ref:`fio.rmdir() <fio-mkdir>`"
msgstr ":ref:`fio.mkdir() <fio-mkdir>` |br| :ref:`fio.rmdir() <fio-mkdir>`"

#: ../doc/reference/reference_lua/fio.rst:77
msgid "Create or delete a directory"
msgstr "Создание или удаление директории"

#: ../doc/reference/reference_lua/fio.rst:81
msgid ":ref:`fio.chdir() <fio-chdir>`"
msgstr ":ref:`fio.chdir() <fio-chdir>`"

#: ../doc/reference/reference_lua/fio.rst:81
msgid "Change working directory"
msgstr "Изменение рабочей директории"

#: ../doc/reference/reference_lua/fio.rst:84
msgid ":ref:`fio.listdir() <fio-listdir>`"
msgstr ":ref:`fio.listdir() <fio-listdir>`"

#: ../doc/reference/reference_lua/fio.rst:84
msgid "List files in a directory"
msgstr "Вывод списка файлов в директории"

#: ../doc/reference/reference_lua/fio.rst:87
msgid ":ref:`fio.glob() <fio-glob>`"
msgstr ":ref:`fio.glob() <fio-glob>`"

#: ../doc/reference/reference_lua/fio.rst:87
msgid "Get files whose names match a given string"
msgstr "Получение файлов, имена которых совпадают с заданной строкой"

#: ../doc/reference/reference_lua/fio.rst:90
msgid ":ref:`fio.tempdir() <fio-tempdir>`"
msgstr ":ref:`fio.tempdir() <fio-tempdir>`"

#: ../doc/reference/reference_lua/fio.rst:90
msgid "Get the name of a directory for storing temporary files"
msgstr "Получение имени директории для хранения временных файлов"

#: ../doc/reference/reference_lua/fio.rst:93
msgid ":ref:`fio.cwd() <fio-cwd>`"
msgstr ":ref:`fio.cwd() <fio-cwd>`"

#: ../doc/reference/reference_lua/fio.rst:93
msgid "Get the name of the current working directory"
msgstr "Получение имени текущей рабочей директории"

#: ../doc/reference/reference_lua/fio.rst:96
msgid ""
":ref:`fio.copytree() <fio-copytree>` |br| :ref:`fio.mktree() <fio-"
"mktree>` |br| :ref:`fio.rmtree() <fio-rmtree>`"
msgstr ""
":ref:`fio.copytree() <fio-copytree>` |br| :ref:`fio.mktree() <fio-"
"mktree>` |br| :ref:`fio.rmtree() <fio-rmtree>`"

#: ../doc/reference/reference_lua/fio.rst:99
msgid "Create and delete directories"
msgstr "Создание и удаление директорий"

#: ../doc/reference/reference_lua/fio.rst:103
msgid ""
":ref:`fio.link() <fio-link>` |br| :ref:`fio.symlink() <fio-link>` |br| "
":ref:`fio.readlink() <fio-link>` |br| :ref:`fio.unlink() <fio-link>`"
msgstr ""
":ref:`fio.link() <fio-link>` |br| :ref:`fio.symlink() <fio-link>` |br| "
":ref:`fio.readlink() <fio-link>` |br| :ref:`fio.unlink() <fio-link>`"

#: ../doc/reference/reference_lua/fio.rst:106
msgid "Create and delete links"
msgstr "Создание и удаление ссылок"

#: ../doc/reference/reference_lua/fio.rst:112
msgid ":ref:`fio.rename() <fio-rename>`"
msgstr ":ref:`fio.rename() <fio-rename>`"

#: ../doc/reference/reference_lua/fio.rst:112
#: ../doc/reference/reference_lua/osmodule.rst:43
msgid "Rename a file or directory"
msgstr "Переименование файла или директории"

#: ../doc/reference/reference_lua/fio.rst:115
#, fuzzy
msgid ":ref:`fio.utime() <fio-utime>`"
msgstr ":ref:`os.time() <os-time>`"

#: ../doc/reference/reference_lua/fio.rst:115
msgid "Change file update time"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:118
msgid ":ref:`fio.copyfile() <fio-copyfile>`"
msgstr ":ref:`fio.copyfile() <fio-copyfile>`"

#: ../doc/reference/reference_lua/fio.rst:118
msgid "Copy a file"
msgstr "Копирование файла"

#: ../doc/reference/reference_lua/fio.rst:121
msgid ":ref:`fio.chown() <fio-chown>` |br| :ref:`fio.chmod() <fio-chown>`"
msgstr ":ref:`fio.chown() <fio-chown>` |br| :ref:`fio.chmod() <fio-chown>`"

#: ../doc/reference/reference_lua/fio.rst:122
msgid "Manage rights to and ownership of file objects"
msgstr "Управление правами на использование и правами владения объектами файла"

#: ../doc/reference/reference_lua/fio.rst:126
msgid ":ref:`fio.truncate() <fio-truncate>`"
msgstr ":ref:`fio.truncate() <fio-truncate>`"

#: ../doc/reference/reference_lua/fio.rst:126
msgid "Reduce the file size"
msgstr "Уменьшение размера файла"

#: ../doc/reference/reference_lua/fio.rst:129
msgid ":ref:`fio.sync() <fio-sync>`"
msgstr ":ref:`fio.sync() <fio-sync>`"

#: ../doc/reference/reference_lua/fio.rst:129
msgid "Ensure that changes are written to disk"
msgstr "Проверка записи изменений на диск"

#: ../doc/reference/reference_lua/fio.rst:132
msgid ":ref:`fio.open() <fio-open>`"
msgstr ":ref:`fio.open() <fio-open>`"

#: ../doc/reference/reference_lua/fio.rst:132
msgid "Open a file"
msgstr "Открытие файла"

#: ../doc/reference/reference_lua/fio.rst:135
msgid ":ref:`file-handle:close() <file_handle-close>`"
msgstr ":ref:`file-handle:close() <file_handle-close>`"

#: ../doc/reference/reference_lua/fio.rst:135
msgid "Close a file"
msgstr "Закрытие файла"

#: ../doc/reference/reference_lua/fio.rst:138
msgid ""
":ref:`file-handle:pread() <file_handle-pread>` |br| :ref:`file-"
"handle:pwrite() <file_handle-pwrite>`"
msgstr ""
":ref:`file-handle:pread() <file_handle-pread>` |br| :ref:`file-"
"handle:pwrite() <file_handle-pwrite>`"

#: ../doc/reference/reference_lua/fio.rst:139
msgid "Perform random-access read or write on a file"
msgstr "Чтение или запись в файл с произвольным доступом"

#: ../doc/reference/reference_lua/fio.rst:143
msgid ""
":ref:`file-handle:read() <file_handle-read>` |br| :ref:`file-"
"handle:write() <file_handle-write>`"
msgstr ""
":ref:`file-handle:read() <file_handle-read>` |br| :ref:`file-"
"handle:write() <file_handle-write>`"

#: ../doc/reference/reference_lua/fio.rst:144
msgid "Perform non-random-access read or write on a file"
msgstr "Чтение или запись в файл не с произвольным доступом"

#: ../doc/reference/reference_lua/fio.rst:148
msgid ":ref:`file-handle:truncate() <file_handle-truncate>`"
msgstr ":ref:`file-handle:truncate() <file_handle-truncate>`"

#: ../doc/reference/reference_lua/fio.rst:148
msgid "Change the size of an open file"
msgstr "Изменение размера открытого файла"

#: ../doc/reference/reference_lua/fio.rst:151
msgid ":ref:`file-handle:seek() <file_handle-seek>`"
msgstr ":ref:`file-handle:seek() <file_handle-seek>`"

#: ../doc/reference/reference_lua/fio.rst:151
msgid "Change position in a file"
msgstr "Изменение позиции в файле"

#: ../doc/reference/reference_lua/fio.rst:154
msgid ":ref:`file-handle:stat() <file_handle-stat>`"
msgstr ":ref:`file-handle:stat() <file_handle-stat>`"

#: ../doc/reference/reference_lua/fio.rst:154
msgid "Get statistics about an open file"
msgstr "Получение статистики об открытом файле"

#: ../doc/reference/reference_lua/fio.rst:157
msgid ""
":ref:`file-handle:fsync() <file_handle-fsync>` |br| :ref:`file-"
"handle:fdatasync() <file_handle-fsync>`"
msgstr ""
":ref:`file-handle:fsync() <file_handle-fsync>` |br| :ref:`file-"
"handle:fdatasync() <file_handle-fsync>`"

#: ../doc/reference/reference_lua/fio.rst:158
msgid "Ensure that changes made to an open file are written to disk"
msgstr "Проверка записи изменений в открытом файле на диск"

#: ../doc/reference/reference_lua/fio.rst:162
msgid ":ref:`fio.c <fio-c_table>`"
msgstr ":ref:`fio.c <fio-c_table>`"

#: ../doc/reference/reference_lua/fio.rst:162
msgid "Table of constants similar to POSIX flag values"
msgstr "Таблица переменных, аналогичных флаговым значениям POSIX"

#: ../doc/reference/reference_lua/fio.rst:172
msgid "Common pathname manipulations"
msgstr "Стандартные действия с путем к файлу"

#: ../doc/reference/reference_lua/fio.rst:178
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr "Конкатенация частей строки, разделенных '/' для формирования пути к файлу."

#: ../doc/reference/reference_lua/fio.rst:180
msgid "one or more strings to be concatenated."
msgstr "одна или более строк для конкатенации."

#: ../doc/reference/reference_lua/fio.rst:181
#: ../doc/reference/reference_lua/fio.rst:200
#: ../doc/reference/reference_lua/fio.rst:221
msgid "path name"
msgstr "путь к файлу"

#: ../doc/reference/reference_lua/fio.rst:186
msgid ""
"tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""
"tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:197
msgid ""
"Given a full path name, remove all but the final part (the file name). "
"Also remove the suffix, if it is passed."
msgstr ""
"Удаление из полного пути к файлу всего, за исключением последней части "
"(имени файла). Также удаление суффикса, если он передается."

#: ../doc/reference/reference_lua/fio.rst:201
msgid "suffix"
msgstr "суффикс"

#: ../doc/reference/reference_lua/fio.rst:203
#: ../doc/reference/reference_lua/fio.rst:240
msgid "file name"
msgstr "имя файла"

#: ../doc/reference/reference_lua/fio.rst:208
msgid ""
"tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""
"tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:219
msgid "Given a full path name, remove the final part (the file name)."
msgstr "Удаление последней части (имени файла) из полного пути к файлу."

#: ../doc/reference/reference_lua/fio.rst:223
msgid "directory name, that is, path name except for file name."
msgstr "имя директории, то есть путь к файлу без имени файла."

#: ../doc/reference/reference_lua/fio.rst:228
msgid ""
"tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'"
msgstr ""
"tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'"

#: ../doc/reference/reference_lua/fio.rst:238
msgid "Given a final part (the file name), return the full path name."
msgstr "Возврат полного пути к файлу на основании последней части (имени файла)."

#: ../doc/reference/reference_lua/fio.rst:242
msgid "directory name, that is, path name including file name."
msgstr "имя директории, то есть путь к файлу с именем файла."

#: ../doc/reference/reference_lua/fio.rst:247
msgid ""
"tarantool> fio.abspath('my.lua')\n"
"---\n"
"- 'path/to/my.lua'\n"
"..."
msgstr ""
"tarantool> fio.abspath('my.lua')\n"
"---\n"
"- 'path/to/my.lua'\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:258
msgid "Directory or file existence and type checks"
msgstr "Проверка наличия и типа директории или файла"

#: ../doc/reference/reference_lua/fio.rst:260
msgid ""
"Functions in this section are similar to some `Python os.path "
"<https://docs.python.org/2/library/os.path.htmll>`_ functions."
msgstr ""
"Функции в данном разделе подобны некоторым функциям `Python os.path "
"<https://docs.python.org/2/library/os.path.htmll>`_."

#: ../doc/reference/reference_lua/fio.rst:268
#: ../doc/reference/reference_lua/fio.rst:276
#: ../doc/reference/reference_lua/fio.rst:284
#: ../doc/reference/reference_lua/fio.rst:292
#: ../doc/reference/reference_lua/fio.rst:300
msgid "path to directory or file."
msgstr "путь к директории или файлу."

#: ../doc/reference/reference_lua/fio.rst:269
msgid ""
"true if path-name refers to a directory or file that exists and is not a "
"broken symbolic link; otherwise false"
msgstr ""
"true (правда), если путь к файлу ссылается на директорию или файл, "
"которые присутствуют в системе, и не представляет собой нерабочую "
"символьную ссылку; в противном случае, false (ложь)"

#: ../doc/reference/reference_lua/fio.rst:277
msgid "true if path-name refers to a directory; otherwise false"
msgstr ""
"true (правда), если путь к файлу ссылается на директорию; в противном "
"случае, false (ложь)"

#: ../doc/reference/reference_lua/fio.rst:285
msgid "true if path-name refers to a file; otherwise false"
msgstr ""
"true (правда), если путь к файлу ссылается на файл; в противном случае, "
"false (ложь)"

#: ../doc/reference/reference_lua/fio.rst:293
msgid "true if path-name refers to a symbolic link; otherwise false"
msgstr ""
"true (правда), если путь к файлу ссылается на символьную ссылку; в "
"противном случае, false (ложь)"

#: ../doc/reference/reference_lua/fio.rst:301
msgid ""
"true if path-name refers to a directory or file that exists or is a "
"broken symbolic link; otherwise false"
msgstr ""
"true (правда), если путь к файлу ссылается на директорию или файл, "
"которые присутствуют в системе, и представляет собой нерабочую символьную"
" ссылку; в противном случае, false (ложь)"

#: ../doc/reference/reference_lua/fio.rst:308
msgid "Common file manipulations"
msgstr "Стандартные действия с файлом"

#: ../doc/reference/reference_lua/fio.rst:314
msgid ""
"Set the mask bits used when creating files or directories. For a detailed"
" description type ``man 2 umask``."
msgstr ""
"Определение битов маски при создании файлов или директорий. Для получения"
" более подробного описания введите ``man 2 umask``."

#: ../doc/reference/reference_lua/fio.rst:317
msgid "mask bits."
msgstr "биты маски."

#: ../doc/reference/reference_lua/fio.rst:318
msgid "previous mask bits."
msgstr "предыдущие биты маски."

#: ../doc/reference/reference_lua/fio.rst:323
msgid ""
"tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""
"tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:335
msgid ""
"Returns information about a file object. For details type ``man 2 lstat``"
" or ``man 2 stat``."
msgstr ""
"Возврат информации об объекте файла. Для получения более подробной "
"информации введите ``man 2 lstat`` или ``man 2 stat``."

#: ../doc/reference/reference_lua/fio.rst:338
msgid "path name of file."
msgstr "путь к файлу."

#: ../doc/reference/reference_lua/fio.rst:339
msgid ""
"(If no error) table of fields which describe the file's block size, "
"creation time, size, and other attributes. |br| (If error) two return "
"values: null, error message."
msgstr ""
"(Если ошибки нет) таблица с полями, которые описывают размер блока файла,"
" время создания, размер и прочие атрибуты. |br| (В случае ошибки) "
"возвращаются два значения: null, сообщение об ошибке."

#: ../doc/reference/reference_lua/fio.rst:342
msgid "table."
msgstr "таблица."

#: ../doc/reference/reference_lua/fio.rst:344
msgid ""
"Additionally, the result of ``fio.stat('file-name')`` will include "
"methods equivalent to POSIX macros:"
msgstr ""
"Кроме того, результат ``fio.stat('имя-файла')`` будет включать в себя "
"методы, которые аналогичны макросам в POSIX:"

#: ../doc/reference/reference_lua/fio.rst:347
msgid "``is_blk()`` = POSIX macro S_ISBLK,"
msgstr "``is_blk()`` = макрос S_ISBLK в POSIX,"

#: ../doc/reference/reference_lua/fio.rst:348
msgid "``is_chr()`` = POSIX macro S_ISCHR,"
msgstr "``is_chr()`` = макрос S_ISCHR в POSIX"

#: ../doc/reference/reference_lua/fio.rst:349
msgid "``is_dir()`` = POSIX macro S_ISDIR,"
msgstr "``is_dir()`` = макрос S_ISDIR в POSIX,"

#: ../doc/reference/reference_lua/fio.rst:350
msgid "``is_fifo()`` = POSIX macro S_ISFIFO,"
msgstr "``is_fifo()`` = макрос S_ISFIFO в POSIX,"

#: ../doc/reference/reference_lua/fio.rst:351
msgid "``is_link()`` = POSIX macro S_ISLINK,"
msgstr "``is_link()`` = макрос S_ISLINK в POSIX,"

#: ../doc/reference/reference_lua/fio.rst:352
msgid "``is_reg()`` = POSIX macro S_ISREG,"
msgstr "``is_reg()`` = макрос S_ISREG в POSIX,"

#: ../doc/reference/reference_lua/fio.rst:353
msgid "``is_sock()`` = POSIX macro S_ISSOCK."
msgstr "``is_sock()`` = макрос S_ISSOCK в POSIX."

#: ../doc/reference/reference_lua/fio.rst:355
msgid "For example, ``fio.stat('/'):is_dir()`` will return true."
msgstr "Например, ``fio.stat('/'):is_dir()`` вернет true."

#: ../doc/reference/reference_lua/fio.rst:359
msgid ""
"tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""
"tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:385
msgid ""
"Create or delete a directory. For details type ``man 2 mkdir`` or ``man 2"
" rmdir``."
msgstr ""
"Создание или удаление директории. Для получения подробной информации "
"введите ``man 2 mkdir`` или ``man 2 rmdir``."

#: ../doc/reference/reference_lua/fio.rst:388
#: ../doc/reference/reference_lua/fio.rst:412
#: ../doc/reference/reference_lua/fio.rst:432
msgid "path of directory."
msgstr "путь к директории."

#: ../doc/reference/reference_lua/fio.rst:389
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"``S_IWUSR``. Mode bits can be combined by enclosing them in braces."
msgstr ""
"Биты режима работы можно передать в виде числа или строковых постоянных, "
"например ``S_IWUSR``. Биты режима работы можно комбинировать путем "
"обрамления их в фигурные скобки."

#: ../doc/reference/reference_lua/fio.rst:392
#: ../doc/reference/reference_lua/fio.rst:512
#: ../doc/reference/reference_lua/fio.rst:534
#: ../doc/reference/reference_lua/fio.rst:609
#: ../doc/reference/reference_lua/fio.rst:633
#: ../doc/reference/reference_lua/fio.rst:656
#: ../doc/reference/reference_lua/fio.rst:704
msgid ""
"(If no error) true. |br| (If error) two return values: false, error "
"message."
msgstr ""
"(Если ошибки нет) true. |br| (В случае ошибки) возвращаются два значения:"
" false, сообщение об ошибке."

#: ../doc/reference/reference_lua/fio.rst:398
msgid ""
"tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""
"tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:409
msgid "Change working directory. For details type ``man 2 chdir``."
msgstr ""
"Изменение рабочей директории. Для получения более подробной информации "
"введите ``man 2 chdir``."

#: ../doc/reference/reference_lua/fio.rst:413
msgid "(If success) true. (If failure) false."
msgstr "(Если выполнено) true. (Если не выполнено) false."

#: ../doc/reference/reference_lua/fio.rst:418
msgid ""
"tarantool> fio.chdir('/etc')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.chdir('/etc')\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:429
msgid ""
"List files in directory. The result is similar to the result from the "
"``ls`` command."
msgstr ""
"Вывод списка файлов в директории. Результат похож на результат команды "
"``ls``."

#: ../doc/reference/reference_lua/fio.rst:433
msgid ""
"(If no error) a list of files. |br| (If error) two return values: null, "
"error message."
msgstr ""
"(Если ошибки нет) список файлов. |br| (В случае ошибки) возвращаются два "
"значения: null, сообщение об ошибке."

#: ../doc/reference/reference_lua/fio.rst:439
msgid ""
"tarantool> fio.listdir('/usr/lib/tarantool')\n"
"---\n"
"- - mysql\n"
"..."
msgstr ""
"tarantool> fio.listdir('/usr/lib/tarantool')\n"
"---\n"
"- - mysql\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:450
msgid ""
"Return a list of files that match an input string. The list is "
"constructed with a single flag that controls the behavior of the "
"function: ``GLOB_NOESCAPE``. For details type ``man 3 glob``."
msgstr ""
"Возврат списка файлов, имена которых совпадают с введенной строкой. "
"Список составляется с одним флагом, который контролирует поведение "
"функции: ``GLOB_NOESCAPE``. Для получения подробной информации введите "
"``man 3 glob``."

#: ../doc/reference/reference_lua/fio.rst:454
msgid "path-name, which may contain wildcard characters."
msgstr "путь к файлу, который может содержать специальные символы."

#: ../doc/reference/reference_lua/fio.rst:455
msgid "list of files whose names match the input string"
msgstr "список файлов, имена которых совпадают с введенной строкой."

#: ../doc/reference/reference_lua/fio.rst:458
#: ../doc/reference/reference_lua/fio.rst:788
#: ../doc/reference/reference_lua/fio.rst:1021
msgid "**Possible errors:** nil."
msgstr "**Возможные ошибки:** nil."

#: ../doc/reference/reference_lua/fio.rst:462
msgid ""
"tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""
"tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:475
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""
"Возврат имени директории, которую можно использовать для хранения "
"временных файлов."

#: ../doc/reference/reference_lua/fio.rst:479
msgid ""
"tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""
"tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:490
msgid "Return the name of the current working directory."
msgstr "Возврат имени текущей рабочей директории."

#: ../doc/reference/reference_lua/fio.rst:494
msgid ""
"tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""
"tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:505
msgid ""
"Copy everything in the from-path, including subdirectory contents, to the"
" to-path. The result is similar to the result that one gets from the ``cp"
" -r`` command. The to-path should be empty."
msgstr ""
"Копирование всего из директории from-path, включая поддиректории, в to-"
"path. Результат аналогичен результату введения команды ``cp -r``. "
"Директория to-path должна быть пустой."

#: ../doc/reference/reference_lua/fio.rst:510
#: ../doc/reference/reference_lua/fio.rst:511
#: ../doc/reference/reference_lua/fio.rst:533
#: ../doc/reference/reference_lua/fio.rst:556
msgid "path-name."
msgstr "путь."

#: ../doc/reference/reference_lua/fio.rst:518
msgid ""
"tarantool> fio.copytree('/home/original','/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.copytree('/home/original','/home/archives')\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:529
msgid ""
"Create the path, including subdirectories, but without file contents. The"
" result is similar to the result that one gets from the ``mkdir`` "
"command."
msgstr ""
"Создание пути, включая поддиректории, но без содержимого файла. Результат"
" аналогичен результату введения команды ``mkdir``."

#: ../doc/reference/reference_lua/fio.rst:540
msgid ""
"tarantool> fio.mktree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.mktree('/home/archives')\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:551
msgid ""
"Remove the directory indicated by path-name, including subdirectories. "
"The result is similar to the result that one gets from the ``rmdir`` "
"command, recursively. The directory must be empty."
msgstr ""
"Удаление указанной директории, включая поддиректории. Результат "
"аналогичен результату введения команды ``rmdir``. Директория должна быть "
"пустой."

#: ../doc/reference/reference_lua/fio.rst:557
msgid ""
"(If no error) true. |br| (If error) two return values: null, error "
"message."
msgstr ""
"(Если ошибки нет) true. |br| (В случае ошибки) возвращаются два значения:"
" null, сообщение об ошибке."

#: ../doc/reference/reference_lua/fio.rst:563
msgid ""
"tarantool> fio.rmtree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.rmtree('/home/archives')\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:577
msgid ""
"Functions to create and delete links. For details type ``man readlink``, "
"``man 2 link``, ``man 2 symlink``, ``man 2 unlink``."
msgstr ""
"Функции для создания и удаления ссылок. Для получения  подробной "
"информации введите ``man readlink``, ``man 2 link``, ``man 2 symlink``, "
"``man 2 unlink``."

#: ../doc/reference/reference_lua/fio.rst:580
msgid "existing file name."
msgstr "имя существующего файла."

#: ../doc/reference/reference_lua/fio.rst:581
msgid "linked name."
msgstr "связанное имя."

#: ../doc/reference/reference_lua/fio.rst:583
msgid ""
"(If no error) ``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return "
"true, ``fio.readlink`` returns the link value. |br| (If error) two return"
" values: false|null, error message."
msgstr ""
"(Если ошибки нет) ``fio.link``, ``fio.symlink`` и ``fio.unlink`` "
"возвращают true (правда), ``fio.readlink`` возвращает ссылку. |br| (В "
"случае ошибки) возвращаются два значения: false|null, сообщение об "
"ошибке."

#: ../doc/reference/reference_lua/fio.rst:589
msgid ""
"tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:604
msgid "Rename a file or directory. For details type ``man 2 rename``."
msgstr ""
"Переименование файла или директории. Для получения подробной информации "
"введите ``man 2 rename``."

#: ../doc/reference/reference_lua/fio.rst:606
msgid "original name."
msgstr "первоначальное имя."

#: ../doc/reference/reference_lua/fio.rst:607
msgid "new name."
msgstr "новое имя."

#: ../doc/reference/reference_lua/fio.rst:615
msgid ""
"tarantool> fio.rename('/home/username/tmp.txt', "
"'/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.rename('/home/username/tmp.txt', "
"'/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:626
msgid ""
"Change the access time and possibly also change the update time of a "
"file. For details type ``man 2 utime``. Times should be expressed as "
"number of seconds since the epoch."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:629
#, fuzzy
msgid "name."
msgstr "новое имя."

#: ../doc/reference/reference_lua/fio.rst:630
msgid "time of last access. default current time."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:631
msgid "time of last update. default = access time."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:639
#, fuzzy
msgid ""
"tarantool> fio.utime('/home/username/tmp.txt')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:650
msgid ""
"Copy a file. The effect is similar to the effect that one gets with the "
"``cp`` command."
msgstr ""
"Копирование файла. Результат аналогичен результату введения команды "
"``cp``. "

#: ../doc/reference/reference_lua/fio.rst:653
msgid "path to original file."
msgstr "путь к первоначальному файлу."

#: ../doc/reference/reference_lua/fio.rst:654
msgid "path to new file."
msgstr "путь к новому файлу."

#: ../doc/reference/reference_lua/fio.rst:662
msgid ""
"tarantool> fio.copyfile('/home/user/tmp.txt', '/home/usern/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.copyfile('/home/user/tmp.txt', '/home/usern/tmp.txt2')\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:674
msgid ""
"Manage the rights to file objects, or ownership of file objects. For "
"details type ``man 2 chown`` or ``man 2 chmod``."
msgstr ""
"Управление правами на использование и правами владения объектами файла. "
"Для получения подробной информации введите ``man 2 chown`` или ``man 2 "
"chmod``."

#: ../doc/reference/reference_lua/fio.rst:677
msgid "new user uid."
msgstr "новый UID пользователя."

#: ../doc/reference/reference_lua/fio.rst:678
msgid "new group uid."
msgstr "новый UID группы."

#: ../doc/reference/reference_lua/fio.rst:679
msgid "new permissions"
msgstr "новые права"

#: ../doc/reference/reference_lua/fio.rst:680
msgid "null"
msgstr "null"

#: ../doc/reference/reference_lua/fio.rst:684
msgid ""
"tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:699
msgid ""
"Reduce file size to a specified value. For details type ``man 2 "
"truncate``."
msgstr ""
"Уменьшение размера файла до указанного значения. Для получения подробной "
"информации введите ``man 2 truncate``."

#: ../doc/reference/reference_lua/fio.rst:710
msgid ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:721
msgid "Ensure that changes are written to disk. For details type ``man 2 sync``."
msgstr ""
"Проверка записи изменений на диск. Для получения подробной информации "
"введите ``man 2 sync``."

#: ../doc/reference/reference_lua/fio.rst:723
#: ../doc/reference/reference_lua/fio.rst:824
#: ../doc/reference/reference_lua/fio.rst:883
#: ../doc/reference/reference_lua/fio.rst:968
#: ../doc/reference/reference_lua/fio.rst:995
#: ../doc/reference/reference_lua/fio.rst:1075
msgid "true if success, false if failure."
msgstr "true -- если выполнено, false -- если не выполнено."

#: ../doc/reference/reference_lua/fio.rst:728
msgid ""
"tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:743
msgid "Open a file in preparation for reading or writing or seeking."
msgstr "Открытие файла в процессе подготовки к чтению, записи или поиску."

#: ../doc/reference/reference_lua/fio.rst:745
msgid "Full path to the file to open."
msgstr "Полный путь к открываемому файлу."

#: ../doc/reference/reference_lua/fio.rst:746
msgid ""
"Flags can be passed as a number or as string constants, for example "
"'``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by "
"enclosing them in braces. On Linux the full set of flags as described on "
"the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ "
"is:  * O_APPEND (start at end of file), * O_ASYNC (signal when IO is "
"possible), * O_CLOEXEC (enable a flag related to closing), * O_CREAT "
"(create file if it doesn't exist), * O_DIRECT (do less caching or no "
"caching), * O_DIRECTORY (fail if it's not a directory), * O_EXCL (fail if"
" file cannot be created), * O_LARGEFILE (allow 64-bit file offsets), * "
"O_NOATIME (no access-time updating), * O_NOCTTY (no console tty), * "
"O_NOFOLLOW (no following symbolic links), * O_NONBLOCK (no blocking), * "
"O_PATH (get a path for low-level use), * O_SYNC (force writing if it's "
"possible), * O_TMPFILE (the file will be temporary and nameless), * "
"O_TRUNC (truncate)  ... and, always, one of:  * O_RDONLY (read only), * "
"O_WRONLY (write only), or * O_RDWR (either read or write)."
msgstr ""
"Флаги могут передаваться в виде числа или в виде строковых постоянных, "
"например '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Флаги можно "
"комбинировать путем обрамления их в фигурные скобки. Все флаги в Linux, "
"как описано на странице `руководства по Linux <http://man7.org/linux/man-"
"pages/man2/open.2.html>`_, представлены ниже:  * O_APPEND (открывать файл"
" в режиме добавления), * O_ASYNC (включать ввод-вывод, управляемый "
"сигналом), * O_CLOEXEC (устанавливать флаг, связанный с закрытием), * "
"O_CREAT (создать файл, если он не существует), * O_DIRECT (минимизировать"
" или отключать кэширование), * O_DIRECTORY (завершать вызов с ошибкой, "
"если путь не является директорией), * O_EXCL (завершать вызов с ошибкой, "
"если файл не может быть создан), * O_LARGEFILE (открывать 64-битные "
"файлы), * O_NOATIME (не обновлять время последнего доступа к файлу), * "
"O_NOCTTY (не делать терминальное устройство управляющим терминалом tty), "
"* O_NOFOLLOW (не открывать символьные ссылки), * O_NONBLOCK (открывать в "
"неблокирующем режиме), * O_PATH (получить путь для низкоуровневого "
"использования), * O_SYNC (включить принудительную запись, если возможно),"
" * O_TMPFILE (создать безымянный временный файл), * O_TRUNC (урезать)  "
"... и всегда используется один из флагов:  * O_RDONLY (только для "
"чтения), * O_WRONLY (только для записи) или * O_RDWR (для чтения и "
"записи)."

#: ../doc/reference/reference_lua/fio.rst:746
msgid ""
"Flags can be passed as a number or as string constants, for example "
"'``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by "
"enclosing them in braces. On Linux the full set of flags as described on "
"the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ "
"is:"
msgstr ""
"Флаги могут передаваться в виде числа или в виде строковых постоянных, "
"например '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Флаги можно "
"комбинировать путем обрамления их в фигурные скобки. Все флаги в Linux, "
"как описано на странице `руководства по Linux  <http://man7.org/linux"
"/man-pages/man2/open.2.html>`_, представлены ниже:"

#: ../doc/reference/reference_lua/fio.rst:755
msgid "O_APPEND (start at end of file),"
msgstr "O_APPEND (открывать файл в режиме добавления),"

#: ../doc/reference/reference_lua/fio.rst:756
msgid "O_ASYNC (signal when IO is possible),"
msgstr "O_ASYNC (включать ввод-вывод, управляемый сигналом),"

#: ../doc/reference/reference_lua/fio.rst:757
msgid "O_CLOEXEC (enable a flag related to closing),"
msgstr "O_CLOEXEC (устанавливать флаг, связанный с закрытием),"

#: ../doc/reference/reference_lua/fio.rst:758
msgid "O_CREAT (create file if it doesn't exist),"
msgstr "O_CREAT (создать файл, если он не существует),"

#: ../doc/reference/reference_lua/fio.rst:759
msgid "O_DIRECT (do less caching or no caching),"
msgstr "O_DIRECT (минимизировать или отключать кэширование),"

#: ../doc/reference/reference_lua/fio.rst:760
msgid "O_DIRECTORY (fail if it's not a directory),"
msgstr ""
"O_DIRECTORY (завершать вызов с ошибкой, если путь не является "
"директорией),"

#: ../doc/reference/reference_lua/fio.rst:761
msgid "O_EXCL (fail if file cannot be created),"
msgstr "O_EXCL (завершать вызов с ошибкой, если файл не может быть создан),"

#: ../doc/reference/reference_lua/fio.rst:762
msgid "O_LARGEFILE (allow 64-bit file offsets),"
msgstr "O_LARGEFILE (открывать 64-битные файлы),"

#: ../doc/reference/reference_lua/fio.rst:763
msgid "O_NOATIME (no access-time updating),"
msgstr "O_NOATIME (не обновлять время последнего доступа к файлу),"

#: ../doc/reference/reference_lua/fio.rst:764
msgid "O_NOCTTY (no console tty),"
msgstr "O_NOCTTY (не делать терминальное устройство управляющим терминалом tty),"

#: ../doc/reference/reference_lua/fio.rst:765
msgid "O_NOFOLLOW (no following symbolic links),"
msgstr "O_NOFOLLOW (не открывать символьные ссылки),"

#: ../doc/reference/reference_lua/fio.rst:766
msgid "O_NONBLOCK (no blocking),"
msgstr "O_NONBLOCK (открывать в неблокирующем режиме),"

#: ../doc/reference/reference_lua/fio.rst:767
msgid "O_PATH (get a path for low-level use),"
msgstr "O_PATH (получить путь для низкоуровневого использования),"

#: ../doc/reference/reference_lua/fio.rst:768
msgid "O_SYNC (force writing if it's possible),"
msgstr "O_SYNC (включить принудительную запись, если возможно),"

#: ../doc/reference/reference_lua/fio.rst:769
msgid "O_TMPFILE (the file will be temporary and nameless),"
msgstr "O_TMPFILE (создать безымянный временный файл),"

#: ../doc/reference/reference_lua/fio.rst:770
msgid "O_TRUNC (truncate)"
msgstr "O_TRUNC (урезать)"

#: ../doc/reference/reference_lua/fio.rst:772
msgid "... and, always, one of:"
msgstr "... и всегда используется один из флагов:"

#: ../doc/reference/reference_lua/fio.rst:774
msgid "O_RDONLY (read only),"
msgstr "O_RDONLY (только для чтения),"

#: ../doc/reference/reference_lua/fio.rst:775
msgid "O_WRONLY (write only), or"
msgstr "O_WRONLY (только для записи) или"

#: ../doc/reference/reference_lua/fio.rst:776
msgid "O_RDWR (either read or write)."
msgstr "O_RDWR (для чтения и записи)."

#: ../doc/reference/reference_lua/fio.rst:778
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"``S_IWUSR``. Mode bits are significant if flags include ``O_CREAT`` or "
"``O_TMPFILE``. Mode bits can be combined by enclosing them in braces."
msgstr ""
"Биты режима работы можно передать в виде числа или строковых постоянных, "
"например ``S_IWUSR``. Биты режима работы имеют значение, если указаны "
"флаги ``O_CREAT`` или ``O_TMPFILE``. Биты режима работы можно "
"комбинировать путем обрамления их в фигурные скобки."

#: ../doc/reference/reference_lua/fio.rst:783
msgid ""
"(If no error) file handle (abbreviated as 'fh' in later description). "
"|br| (If error) two return values: null, error message."
msgstr ""
"(Если ошибки нет) дескриптор файла (далее сокращенно 'fh'). |br| (В "
"случае ошибки) возвращаются два значения: null, сообщение об ошибке."

#: ../doc/reference/reference_lua/fio.rst:790
#: ../doc/reference/reference_lua/http.rst:218
msgid "**Example 1:**"
msgstr "**Пример 1:**"

#: ../doc/reference/reference_lua/fio.rst:792
msgid ""
"tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', "
"'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""
"tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', "
"'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- отображение дескриптора файла, который возвращает "
"fio.open\n"
"---\n"
"- fh: 11\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:802
#: ../doc/reference/reference_lua/http.rst:247
msgid "**Example 2:**"
msgstr "**Пример 2:**"

#: ../doc/reference/reference_lua/fio.rst:804
msgid ""
"Using ``fio.open()`` with ``tonumber('N', 8)`` to set permissions as an "
"octal number:"
msgstr ""
"Using ``fio.open()`` with ``tonumber('N', 8)`` to set permissions as an "
"octal number:"

#: ../doc/reference/reference_lua/fio.rst:807
msgid ""
"tarantool> fio.open('x.txt', {'O_WRONLY', 'O_CREAT'}, tonumber('644',8))\n"
"---\n"
"- fh: 12\n"
"..."
msgstr ""
"tarantool> fio.open('x.txt', {'O_WRONLY', 'O_CREAT'}, tonumber('644',8))\n"
" ---\n"
" - fh: 12\n"
" ..."

#: ../doc/reference/reference_lua/fio.rst:820
msgid ""
"Close a file that was opened with ``fio.open``. For details type ``man 2 "
"close``."
msgstr ""
"Закрытие файла, который был открыт с помощью ``fio.open``. Для получения "
"подробной информации введите ``man 2 close``."

#: ../doc/reference/reference_lua/fio.rst:823
#: ../doc/reference/reference_lua/fio.rst:845
#: ../doc/reference/reference_lua/fio.rst:878
#: ../doc/reference/reference_lua/fio.rst:919
#: ../doc/reference/reference_lua/fio.rst:964
#: ../doc/reference/reference_lua/fio.rst:994
#: ../doc/reference/reference_lua/fio.rst:1014
#: ../doc/reference/reference_lua/fio.rst:1040
#: ../doc/reference/reference_lua/fio.rst:1074
msgid "file-handle as returned by ``fio.open()``."
msgstr "дескриптор файла, который возвращает ``fio.open()``."

#: ../doc/reference/reference_lua/fio.rst:829
msgid ""
"tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fh:close() -- где fh = дескриптор файла\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:841
msgid ""
"Perform random-access read operation on a file, without affecting the "
"current seek position of the file. For details type ``man 2 pread``."
msgstr ""
"Чтение файла с произвольным доступом независимо от текущего положения в "
"поиске. Для получения подробной информации введите ``man 2 pread``."

#: ../doc/reference/reference_lua/fio.rst:846
msgid "where to read into (if the format is ``pread(buffer, count, offset)``)"
msgstr "откуда читать (если формат -- ``pread(buffer, count, offset)``)"

#: ../doc/reference/reference_lua/fio.rst:848
#: ../doc/reference/reference_lua/fio.rst:922
msgid "number of bytes to read"
msgstr "количество байтов для чтения"

#: ../doc/reference/reference_lua/fio.rst:849
msgid "offset within file where reading begins"
msgstr "смещение в файле -- где начинается чтение"

#: ../doc/reference/reference_lua/fio.rst:851
msgid ""
"If the format is ``pread(count, offset)`` then return a string containing"
" the data that was read from the file, or nil if failure."
msgstr ""
"Если формат -- ``pread(count, offset)``, возвращается строка с данными, "
"прочитанными из файла, либо нулевое значение nil, если не выполнено."

#: ../doc/reference/reference_lua/fio.rst:854
msgid ""
"If the format is ``pread(buffer, count, offset)`` then return the data to"
" the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-"
"module>`.)"
msgstr ""
"Если формат -- ``pread(buffer, count, offset)``, возвращаются данные в "
"буфер. (Буферы можно ввести с помощью :ref:`buffer.ibuf <buffer-"
"module>`.)"

#: ../doc/reference/reference_lua/fio.rst:860
msgid ""
"tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""
"tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:874
msgid ""
"Perform random-access write operation on a file, without affecting the "
"current seek position of the file. For details type ``man 2 pwrite``."
msgstr ""
"Запись в файл с произвольным доступом независимо от текущего положения в "
"поиске. Для получения подробной информации введите ``man 2 pwrite``."

#: ../doc/reference/reference_lua/fio.rst:879
#: ../doc/reference/reference_lua/fio.rst:965
msgid "value to write"
msgstr "записываемое значение"

#: ../doc/reference/reference_lua/fio.rst:880
msgid ""
"number of bytes to write (if the format is ``pwrite(buffer, count, "
"offset)``)"
msgstr ""
"количество записываемых байтов (если формат -- ``pwrite(buffer, count, "
"offset)``)"

#: ../doc/reference/reference_lua/fio.rst:882
msgid "offset within file where writing begins"
msgstr "смещение в файле -- где начинается запись"

#: ../doc/reference/reference_lua/fio.rst:886
msgid ""
"If the format is ``pwrite(new-string, offset)`` then the returned string "
"is written to the file, as far as the end of the string."
msgstr ""
"Если формат --``pwrite(new-string, offset)``, строка записывается в файл "
"до конца строки."

#: ../doc/reference/reference_lua/fio.rst:889
msgid ""
"If the format is ``pwrite(buffer, count, offset)`` then the buffer "
"contents are written to the file, for ``count`` bytes. (Buffers can be "
"acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""
"Если формат -- ``pwrite(buffer, count, offset)``, содержимое буфера "
"записывается в файл в объеме, указанном в ``count``. (Буферы можно ввести"
" с помощью :ref:`buffer.ibuf <buffer-module>`.)"

#: ../doc/reference/reference_lua/fio.rst:893
msgid ""
"ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:pwrite(ibuf, 1, 0)\n"
"---\n"
"- true\n"
"..."
msgstr ""
"ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:pwrite(ibuf, 1, 0)\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:909
msgid ""
"Perform non-random-access read on a file. For details type ``man 2 read``"
" or ``man 2 write``."
msgstr ""
"Чтение файла не с произвольным доступом. Для получения подробной "
"информации введите ``man 2 read`` или ``man 2 write``."

#: ../doc/reference/reference_lua/fio.rst:914
#: ../doc/reference/reference_lua/fio.rst:959
msgid ""
"``fh:read`` and ``fh:write`` affect the seek position within the file, "
"and this must be taken into account when working on the same file from "
"multiple fibers. It is possible to limit or prevent file access from "
"other fibers with ``fiber.ipc``."
msgstr ""
"``fh:read`` и ``fh:write`` влияют на положение поиска по файлу, и это "
"следует учитывать при работе нескольких файберов над одним файлом. "
"Существует возможность ограничения или запрета на доступ к файлу с "
"помощью ``fiber.ipc``."

#: ../doc/reference/reference_lua/fio.rst:920
msgid "where to read into (if the format is ``read(buffer, count)``)"
msgstr "откуда читать (если формат -- ``read(buffer, count)``)"

#: ../doc/reference/reference_lua/fio.rst:924
msgid ""
"If the format is ``read()`` -- omitting ``count`` -- then read all bytes "
"in the file."
msgstr ""
"Если формат -- ``read()`` -- без ``count`` -- считываются все байты в "
"файле."

#: ../doc/reference/reference_lua/fio.rst:927
msgid ""
"If the format is ``read()``  or ``read([count])`` then return a string "
"containing the data that was read from the file, or nil if failure."
msgstr ""
"Если формат -- ``read()``  или ``read([count])``, возвращается строка с "
"данными, прочитанными из файла, либо нулевое значение nil, если не "
"выполнено."

#: ../doc/reference/reference_lua/fio.rst:930
msgid ""
"If the format is ``read(buffer, count)`` then return the data to the "
"buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-"
"module>`.)"
msgstr ""
"Если формат -- ``read(buffer, count)``, возвращаются данные в буфер. "
"(Буферы можно ввести с помощью :ref:`buffer.ibuf <buffer-module>`.)"

#: ../doc/reference/reference_lua/fio.rst:934
msgid ""
"ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:read(ibuf:reserve(5), 5)\n"
"---\n"
"- 5\n"
"...\n"
"\n"
"tarantool> require('ffi').string(ibuf:alloc(5),5)\n"
"---\n"
"- abcde"
msgstr ""
"ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:read(ibuf:reserve(5), 5)\n"
"---\n"
"- 5\n"
"...\n"
"\n"
"tarantool> require('ffi').string(ibuf:alloc(5),5)\n"
"---\n"
"- abcde"

#: ../doc/reference/reference_lua/fio.rst:954
msgid ""
"Perform non-random-access write on a file. For details type ``man 2 "
"write``."
msgstr ""
"Запись в файл не с произвольным доступом. Для получения подробной "
"информации введите ``man 2 write``."

#: ../doc/reference/reference_lua/fio.rst:966
msgid "number of bytes to write (if the format is ``write(buffer, count)``)"
msgstr "количество записываемых байтов (если формат -- ``write(buffer, count)``)"

#: ../doc/reference/reference_lua/fio.rst:971
msgid ""
"If the format is ``write(new-string)`` then the returned string is "
"written to the file, as far as the end of the string."
msgstr ""
"Если формат -- ``write(new-string)``, строка записывается в файл до конца"
" строки."

#: ../doc/reference/reference_lua/fio.rst:974
msgid ""
"If the format is ``write(buffer, count)`` then the buffer contents are "
"written to the file, for ``count`` bytes. (Buffers can be acquired with "
":ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""
"Если формат -- ``write(buffer, count)``, содержимое буфера записывается в"
" файл в объеме, указанном в ``count``. (Буферы можно ввести с помощью "
":ref:`buffer.ibuf <buffer-module>`.)"

#: ../doc/reference/reference_lua/fio.rst:980
msgid ""
"tarantool> fh:write(\"new data\")\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fh:write(\"new data\")\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:991
msgid ""
"Change the size of an open file. Differs from ``fio.truncate``, which "
"changes the size of a closed file."
msgstr ""
"Изменение размера открытого файла. Отличается от функции "
"``fio.truncate``, которая изменяет размер закрытого файла."

#: ../doc/reference/reference_lua/fio.rst:1000
msgid ""
"tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:1011
msgid ""
"Shift position in the file to the specified position. For details type "
"``man 2 seek``."
msgstr ""
"Изменение положения в файле на указанное. Для получения подробной "
"информации введите ``man 2 seek``."

#: ../doc/reference/reference_lua/fio.rst:1015
msgid "position to seek to"
msgstr "искомое положение"

#: ../doc/reference/reference_lua/fio.rst:1016
msgid ""
"'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, "
"'``SEEK_SET``' = start of file."
msgstr ""
"'``SEEK_END``' = конец файла, '``SEEK_CUR``' = текущее положение, "
"'``SEEK_SET``' = начало файла."

#: ../doc/reference/reference_lua/fio.rst:1018
msgid "the new position if success"
msgstr "новое положение, если выполнено"

#: ../doc/reference/reference_lua/fio.rst:1025
msgid ""
"tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""
"tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:1036
msgid ""
"Return statistics about an open file. This differs from ``fio.stat`` "
"which return statistics about a closed file. For details type ``man 2 "
"stat``."
msgstr ""
"Возврат статистики об открытом файле. Отличается от функции ``fio.stat``,"
" которая возвращает статистику о закрытом файле. Для получения подробной "
"информации введите ``man 2 stat``."

#: ../doc/reference/reference_lua/fio.rst:1041
msgid "details about the file."
msgstr "подробная информация о файле."

#: ../doc/reference/reference_lua/fio.rst:1046
msgid ""
"tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""
"tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:1070
msgid ""
"Ensure that file changes are written to disk, for an open file. Compare "
"``fio.sync``, which is for all files. For details type ``man 2 fsync`` or"
" ``man 2 fdatasync``."
msgstr ""
"Проверка записи изменений в открытом файле на диск. Ср. с ``fio.sync`` "
"для всех файлов. Для получения подробной информации введите ``man 2 "
"fsync`` or ``man 2 fdatasync``."

#: ../doc/reference/reference_lua/fio.rst:1079
msgid ""
"tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/fio.rst:1090
msgid "FIO constants"
msgstr "Постоянные для файлового ввода-вывода"

#: ../doc/reference/reference_lua/fio.rst:1096
msgid ""
"Table with constants which are the same as POSIX flag values on the "
"target platform (see ``man 2 stat``)."
msgstr ""
"Таблица с постоянными, которые совпадают с флаговыми значениями в POSIX "
"на целевой платформе (см. ``man 2 stat``)."

#: ../doc/reference/reference_lua/fio.rst:1101
msgid ""
"tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."
msgstr ""
"tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."

#: ../doc/reference/reference_lua/fun.rst:5
msgid "Module `fun`"
msgstr "Модуль `fun`"

#: ../doc/reference/reference_lua/fun.rst:7
msgid ""
"Luafun, also known as the Lua Functional Library, takes advantage of the "
"features of LuaJIT to help users create complex functions. Inside the "
"module are \"sequence processors\" such as ``map``, ``filter``, "
"``reduce``, ``zip`` -- they take a user-written function as an argument "
"and run it against every element in a sequence, which can be faster or "
"more convenient than a user-written loop. Inside the module are "
"\"generators\" such as ``range``, ``tabulate``, and ``rands`` -- they "
"return a bounded or boundless series of values. Within the module are "
"\"reducers\", \"filters\", \"composers\" ... or, in short, all the "
"important features found in languages like Standard ML, Haskell, or "
"Erlang."
msgstr ""
"Luafun, также известная как библиотека для функционального "
"программирования в Lua, пользуется преимуществами LuaJIT, чтобы помочь "
"пользователям создавать сложные функции. Модуль включает в себя "
"\"последовательные процессоры\", такие как ``map``, ``filter``, "
"``reduce``, ``zip`` -- они берут написанную пользователем функцию в "
"качестве аргумента и применяют ее к каждому элементу в "
"последовательности, что может работать быстрее или более удобно, чем "
"написанный пользователем цикл. Модуль включает в себя \"генераторы\", "
"такие как ``range``, ``tabulate`` и ``rands`` -- они возвращают "
"ограниченный или неограниченный ряд значений. Модуль включает в себя "
"\"преобразователи\", \"фильтры\", \"компоновщики\" ... или, коротко "
"говоря, все важные функции из таких языков, как Standard ML, Haskell или "
"Erlang."

#: ../doc/reference/reference_lua/fun.rst:17
msgid ""
"The full documentation is `On the luafun section of github`_. However, "
"the first chapter can be skipped because installation is already done, "
"it's inside Tarantool. All that is needed is the usual ``require`` "
"request. After that, all the operations described in the Lua fun manual "
"will work, provided they are preceded by the name returned by the "
"``require`` request. For example:"
msgstr ""
"Вся документация находится по ссылке `On the luafun section of github`_. "
"Однако, первую главу можно пропустить, поскольку установка уже выполнена "
"в пределах Tarantool'а. Единственное, что нужно сделать, -- выполнить "
"обычный запрос ``require``. После этого сработают все операции, описанные"
" в руководстве по работе с библиотекой для функционального "
"программирования в Lua,  при условии, что перед ними указывается имя, "
"возвращенное запросом ``require``. Например:"

#: ../doc/reference/reference_lua/fun.rst:23
msgid ""
"tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""
"tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/http.rst:5
msgid "Module `http`"
msgstr "Модуль `http`"

#: ../doc/reference/reference_lua/http.rst:13
msgid ""
"The ``http`` module, specifically the ``http.client`` submodule, provides"
" the functionality of an HTTP client with support for HTTPS and "
"keepalive. It uses routines in the `libcurl "
"<https://curl.haxx.se/libcurl/>`_ library."
msgstr ""
"Модуль ``http``, в частности вложенный модуль ``http.client`` , "
"обеспечивать функциональные возможности HTTP-клиента с поддержкой HTTPS и"
" механизма поддержания в активном состоянии keepalive. Модуль использует "
"процедуры из библиотеки `libcurl <https://curl.haxx.se/libcurl/>`_."

#: ../doc/reference/reference_lua/http.rst:21
msgid "Below is a list of all ``http`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``http``."

#: ../doc/reference/reference_lua/http.rst:31
msgid ":ref:`http.client.new() <http-new>`"
msgstr ":ref:`http.client.new() <http-new>`"

#: ../doc/reference/reference_lua/http.rst:31
msgid "Create an HTTP client instance"
msgstr "Создание экземпляра HTTP-клиента"

#: ../doc/reference/reference_lua/http.rst:34
msgid ":ref:`client_object:request() <client_object-request>`"
msgstr ":ref:`client_object:request() <client_object-request>`"

#: ../doc/reference/reference_lua/http.rst:34
msgid "Perform an HTTP request"
msgstr "Выполнение HTTP-запроса"

#: ../doc/reference/reference_lua/http.rst:37
msgid ":ref:`client_object:stat() <client_object-stat>`"
msgstr ":ref:`client_object:stat() <client_object-stat>`"

#: ../doc/reference/reference_lua/http.rst:37
msgid "Get a table with statistics"
msgstr "Получение таблицы со статистикой"

#: ../doc/reference/reference_lua/http.rst:45
msgid "Construct a new HTTP client instance."
msgstr "Создание нового экземпляра HTTP-клиента."

#: ../doc/reference/reference_lua/http.rst:47
msgid "integer settings which are passed to libcurl."
msgstr "настройки целочисленных значений, которые передаются в libcurl."

#: ../doc/reference/reference_lua/http.rst:49
msgid ""
"The two possible options are ``max_connections`` and "
"``max_total_connections``."
msgstr "Доступны два параметра: ``max_connections`` и ``max_total_connections``."

#: ../doc/reference/reference_lua/http.rst:51
msgid ""
"``max_connections`` is the maximum number of entries in the cache. It "
"affects libcurl `CURLMOPT_MAXCONNECTS "
"<https://curl.haxx.se/libcurl/c/CURLMOPT_MAXCONNECTS.html>`_. The default"
" is -1."
msgstr ""
"``max_connections`` -- это максимальное количество записей в кэше, "
"которое влияет на `CURLMOPT_MAXCONNECTS "
"<https://curl.haxx.se/libcurl/c/CURLMOPT_MAXCONNECTS.html>`_ в libcurl. "
"По умолчанию -1."

#: ../doc/reference/reference_lua/http.rst:55
#, fuzzy
msgid ""
"``max_total_connections`` is the maximum number of active connections. It"
" affects libcurl  `CURLMOPT_MAX_TOTAL_CONNECTIONS "
"<https://curl.haxx.se/libcurl/c/CURLMOPT_MAX_TOTAL_CONNECTIONS.html>`_. "
"It is ignored if the curl version is less than 7.30. The default is 0, "
"which allows libcurl to scale accordingly to easy handle the count."
msgstr ""
"``max_total_connections`` -- это максимальное число активных соединений, "
"которое влияет на `CURLMOPT_MAX_TOTAL_CONNECTIONS "
"<https://curl.haxx.se/libcurl/c/CURLMOPT_MAX_TOTAL_CONNECTIONS.html>`_ в "
"libcurl. Значение не учитывается, если версия curl ниже 7.30. По "
"умолчанию 0, что позволяет libcurl масштабироваться в зависимости от "
"количества обработчиков."

#: ../doc/reference/reference_lua/http.rst:60
msgid ""
"The default option values are usually good enough but in rare cases it "
"might be good to set them. In that case here are two tips."
msgstr ""
"Обычно значений параметров по умолчанию будет достаточно, но в редких "
"случаях может понадобиться их настройка. На этот случай два совета."

#: ../doc/reference/reference_lua/http.rst:63
msgid ""
"You may want to control the maximum number of sockets that a particular "
"HTTP client uses simultaneously. If a system passes many requests to "
"distinct hosts, then libcurl cannot reuse sockets. In this case setting "
"``max_total_connections`` may be useful, since it causes curl to avoid "
"creating too many sockets which would not be used anyway."
msgstr ""
"1. Возможно, вы захотите регулировать максимальное количество сокетов, "
"которые конкретный http-клиент использует одновременно. Если система "
"передает много запросов различным хостам, то libcurl не может повторно "
"использовать сокеты. В этом случае важен "
"параметр``max_total_connections``, поскольку он запретит curl создавать "
"слишком большое количество сокетов, которые все равно не будут "
"использоваться."

#: ../doc/reference/reference_lua/http.rst:68
#, fuzzy
msgid ""
"Do not set ``max_connections`` less than ``max_total_connections`` unless"
" you are confident about your actions. When ``max_connections`` is less "
"then ``max_total_connections``, in some cases libcurl will not reuse "
"sockets for requests that are going to the same host. If the limit is "
"reached and a new request occurs, then libcurl will first create a new "
"socket, send the request, wait for the first connection to be free, and "
"close it, in order to avoid exceeding the ``max_connections`` cache size."
" In the worst case, libcurl will create a new socket for every request, "
"even if all requests are going to the same host. See `this Tarantool "
"issue on github <https://github.com/tarantool/tarantool/issues/3945>`_ "
"for details."
msgstr ""
"2. Не задавайте значение ``max_connections`` меньше "
"``max_total_connections``, если только вы не абсолютно уверены в своих "
"действиях. Когда значение ``max_connections`` меньше "
"``max_total_connections``, в некоторых случаях libcurl не будет повторно "
"использовать сокеты для запросов, отправляемых на тот же хост. Если же "
"предел достигнут и приходит новый запрос, то libcurl сначала создаст "
"новый сокет, отправит запрос, дождется освобождения первого соединения и "
"закроет его во избежание превышения размера кэша ``max_connections``. В "
"худшем случае, libcurl создаст новый сокет для каждого запроса, даже если"
" все запросы будут отправляться на один и тот же хост. Дополнительную "
"информацию см. в `этой проблеме Tarantool'а на github "
"<https://github.com/tarantool/tarantool/issues/3945>`_."

#: ../doc/reference/reference_lua/http.rst:80
msgid "a new HTTP client instance"
msgstr "новый экземпляр HTTP-клиента"

#: ../doc/reference/reference_lua/http.rst:85
msgid ""
"tarantool> http_client = require('http.client').new({max_connections = "
"5})\n"
"---\n"
"..."
msgstr ""
"tarantool> http_client = require('http.client').new({max_connections = "
"5})\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/http.rst:97
msgid ""
"If ``http_client`` is an HTTP client instance, ``http_client:request()`` "
"will perform an HTTP request and, if there is a successful connection, "
"will return a table with connection information."
msgstr ""
"Если ``http_client`` -- это экземпляр HTTP-клиента, "
"``http_client:request()`` выполнит HTTP-запрос, и в случае успешного "
"подключения вернет таблицу с информацией о подключении."

#: ../doc/reference/reference_lua/http.rst:101
msgid "HTTP method, for example 'GET' or 'POST' or 'PUT'"
msgstr "HTTP-метод, например 'GET', 'POST' или 'PUT'"

#: ../doc/reference/reference_lua/http.rst:102
msgid "location, for example 'https://tarantool.org/doc'"
msgstr "расположение, например 'https://tarantool.org/doc'"

#: ../doc/reference/reference_lua/http.rst:103
msgid "optional initial message, for example 'My text string!'"
msgstr "необязательное начальное сообщение, например 'My text string!'"

#: ../doc/reference/reference_lua/http.rst:104
#, fuzzy
msgid ""
"table of connection options, with any of these components:   * "
"``timeout`` - number of seconds to wait for a curl API read request    "
"before timing out  * ``ca_path`` - path to a directory holding one or "
"more certificates to    verify the peer with  * ``ca_file`` - path to an "
"SSL certificate file to verify the peer with  * ``verify_host`` - set "
"on/off verification of the certificate's name    (CN) against host. See "
"also    `CURLOPT_SSL_VERIFYHOST "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_  * "
"``verify_peer`` - set on/off verification of the peer's SSL    "
"certificate. See also    `CURLOPT_SSL_VERIFYPEER "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_  * "
"``ssl_key`` - path to a private key file for a TLS and SSL client    "
"certificate. See also    `CURLOPT_SSLKEY "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_  * ``ssl_cert`` - "
"path to a SSL client certificate file. See also    `CURLOPT_SSLCERT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_  * ``headers`` - "
"table of HTTP headers  * ``keepalive_idle`` - delay, in seconds, that the"
" operating system    will wait while the connection is idle before "
"sending keepalive    probes. See also    `CURLOPT_TCP_KEEPIDLE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_    and the "
"note below about keepalive_interval.  * ``keepalive_interval`` - the "
"interval, in seconds, that the operating    system will wait between "
"sending keepalive probes. See also    `CURLOPT_TCP_KEEPINTVL "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_.    If both"
" keepalive_idle and keepalive_interval are set, then    Tarantool will "
"also set HTTP keepalive headers: Connection:Keep-Alive    and Keep-"
"Alive:timeout=<keepalive_idle>.    Otherwise Tarantool will send "
"Connection:close  * ``low_speed_time`` - set the \"low speed time\" -- "
"the time that the    transfer speed should be below the \"low speed "
"limit\" for the library    to consider it too slow and abort. See also"
"    `CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * "
"``low_speed_limit`` - set the \"low speed limit\" -- the average    "
"transfer speed in bytes per second that the transfer should be below    "
"during \"low speed time\" seconds for the library to consider it to be"
"    too slow and abort. See also    `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * "
"``verbose`` - set on/off verbose mode  * ``unix_socket`` - a socket name "
"to use instead of an Internet address,    for a local connection. The "
"Tarantool server must be built with    ``libcurl`` 7.40 or later. See the"
" :ref:`second example <http-example2>`    later in this section.  * "
"``max_header_name_len`` - the maximal length of a header name. If a "
"header    name is bigger than this value, it is truncated to this length."
"    The default value is '32'.  * ``follow_location`` - when the option "
"is set to ``true`` (default)    and the response has a 3xx code, the HTTP"
" client will automatically issue    another request to a location that a "
"server sends in the ``Location``    header. If the new response is 3xx "
"again, the HTTP client will    issue still another request and so on in a"
" loop until a non-3xx response    will be received. This last response "
"will be returned as a result.    Setting this option to ``false`` allows "
"to disable this behavior.    In this case, the HTTP client will return a "
"3xx response itself."
msgstr ""
"таблица с параметрами подключения, которые могут содержать любые из "
"следующих компонентов:   * ``timeout`` -- количество секунд ожидания "
"API-запроса curl на чтение до превышения времени ожидания  * ``ca_path`` "
"-- путь к директории, где хранятся один или более сертификатов для "
"проверки подключенного узла  * ``ca_file`` -- путь к SSL-сертификату для "
"проверки подключенного узла  * ``verify_host`` -- включение/отключение "
"проверки имени сертификата (CN) для хоста. См. также    "
"`CURLOPT_SSL_VERIFYHOST "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_  * "
"``verify_peer`` --  включение/отключение проверки SSL-сертификата "
"подключенного узла. См. также    `CURLOPT_SSL_VERIFYPEER "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_  * "
"``ssl_key`` -- путь к файлу закрытого ключа для клиентского "
"TSL-сертификата и SSL-сертификата. См. также    `CURLOPT_SSLKEY "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_  * ``ssl_cert`` --"
" путь к файлу клиентского SSL-сертификата. См. также    `CURLOPT_SSLCERT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_  * ``headers`` --"
" таблица HTTP-заголовков  * ``keepalive_idle`` -- время задержки в "
"секундах, в течение которого операционная система находится в режиме "
"ожидания подключения до отправки сообщений для поддержания в активном "
"состоянии keepalive. См. также    `CURLOPT_TCP_KEEPALIVE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_  * "
"``keepalive_interval`` -- время интервала в секундах, в течение которого "
"операционная система находится в режиме ожидания между отправкой "
"сообщений keepalive. См. также    `CURLOPT_TCP_KEEPIDLE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_    и "
"примечание ниже к keepalive_interval.  * ``keepalive_interval`` -- период"
" времени в секундах между отправками сообщений keepalive в операционной "
"системе. См. также    `CURLOPT_TCP_KEEPINTVL "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_.    Если "
"заданы оба параметр keepalive_idle и keepalive_interval, то    Tarantool "
"отобразит HTTP-заголовки для keepalive: Connection:Keep-Alive    и Keep-"
"Alive:timeout=<keepalive_idle>.    В противном случае, Tarantool отправит"
" Connection:close  * ``low_speed_time``  -- установка \"времени работы с "
"низкой скоростью\" -- времени, в течение которого скорость передачи "
"должна быть ниже \"предела низкой скорости\", чтобы библиотека посчитала "
"работу слишком медленной и завершила ее. См. также    "
"`CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * "
"``low_speed_limit`` -- установка \"предела низкой скорости\" -- средней "
"скорости передачи в байтах в секунду, ниже которой должна быть скорость "
"передачи, чтобы библиотека посчитала работу слишком медленной и завершила"
" ее. См. также    `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * "
"``verbose`` -- включение/отключение режима отображения подробной "
"информации  * ``unix_socket`` -- имя сокета, которое используется вместо "
"адреса в сети Интернет,    для локального соединения. Сборка сервера "
"Tarantool'а должна осуществляться с помощью ``libcurl`` 7.40 или более "
"поздней версии. См. :ref:`второй пример <http-example2>` далее в разделе."
"  * ``max_header_name_len`` -- максимальная длина имени заголовка. Если "
"имя заголовка больше данного значения, оно усекается до такой длины. По "
"умолчанию, '32'."

#: ../doc/reference/reference_lua/http.rst:104
msgid "table of connection options, with any of these components:"
msgstr ""
"таблица с параметрами подключения, которые могут содержать любые из "
"следующих компонентов:"

#: ../doc/reference/reference_lua/http.rst:107
msgid ""
"``timeout`` - number of seconds to wait for a curl API read request "
"before timing out"
msgstr ""
"``timeout`` -- количество секунд ожидания API-запроса curl на чтение до "
"превышения времени ожидания"

#: ../doc/reference/reference_lua/http.rst:109
msgid ""
"``ca_path`` - path to a directory holding one or more certificates to "
"verify the peer with"
msgstr ""
"``ca_path`` -- путь к директории, где хранятся один или более "
"сертификатов для проверки подключенного узла"

#: ../doc/reference/reference_lua/http.rst:111
msgid "``ca_file`` - path to an SSL certificate file to verify the peer with"
msgstr "``ca_file`` -- путь к SSL-сертификату для проверки подключенного узла"

#: ../doc/reference/reference_lua/http.rst:112
msgid ""
"``verify_host`` - set on/off verification of the certificate's name (CN) "
"against host. See also `CURLOPT_SSL_VERIFYHOST "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_"
msgstr ""
"``verify_host`` -- включение/отключение проверки имени сертификата (CN) "
"для хоста. См. также    `CURLOPT_SSL_VERIFYHOST "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_"

#: ../doc/reference/reference_lua/http.rst:115
msgid ""
"``verify_peer`` - set on/off verification of the peer's SSL certificate. "
"See also `CURLOPT_SSL_VERIFYPEER "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_"
msgstr ""
"``verify_peer`` --  включение/отключение проверки SSL-сертификата "
"подключенного узла. См. также `CURLOPT_SSL_VERIFYPEER "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_"

#: ../doc/reference/reference_lua/http.rst:118
msgid ""
"``ssl_key`` - path to a private key file for a TLS and SSL client "
"certificate. See also `CURLOPT_SSLKEY "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_"
msgstr ""
"``ssl_key`` -- путь к файлу закрытого ключа для клиентского "
"TSL-сертификата и SSL-сертификата. См. также `CURLOPT_SSLKEY "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_"

#: ../doc/reference/reference_lua/http.rst:121
msgid ""
"``ssl_cert`` - path to a SSL client certificate file. See also "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_"
msgstr ""
"``ssl_cert`` -- путь к файлу клиентского SSL-сертификата. См. также    "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_"

#: ../doc/reference/reference_lua/http.rst:123
msgid "``headers`` - table of HTTP headers"
msgstr "``headers`` -- таблица HTTP-заголовков"

#: ../doc/reference/reference_lua/http.rst:124
msgid ""
"``keepalive_idle`` - delay, in seconds, that the operating system will "
"wait while the connection is idle before sending keepalive probes. See "
"also `CURLOPT_TCP_KEEPIDLE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_ and the note"
" below about keepalive_interval."
msgstr ""
"``keepalive_idle`` -- время задержки в секундах, в течение которого "
"операционная система находится в режиме ожидания подключения до отправки "
"сообщений для поддержания в активном состоянии keepalive. См. также "
"`CURLOPT_TCP_KEEPIDLE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_ и примечание"
" ниже к keepalive_interval."

#: ../doc/reference/reference_lua/http.rst:129
msgid ""
"``keepalive_interval`` - the interval, in seconds, that the operating "
"system will wait between sending keepalive probes. See also "
"`CURLOPT_TCP_KEEPINTVL "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_. If both "
"keepalive_idle and keepalive_interval are set, then Tarantool will also "
"set HTTP keepalive headers: Connection:Keep-Alive and Keep-"
"Alive:timeout=<keepalive_idle>. Otherwise Tarantool will send "
"Connection:close"
msgstr ""
"``keepalive_interval`` -- период времени в секундах между отправками "
"сообщений keepalive в операционной системе. См. также "
"`CURLOPT_TCP_KEEPINTVL "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_. Если "
"заданы оба параметр keepalive_idle и keepalive_interval, то Tarantool "
"отобразит HTTP-заголовки для keepalive: Connection:Keep-Alive и Keep-"
"Alive:timeout=<keepalive_idle>. В противном случае, Tarantool отправит "
"Connection:close."

#: ../doc/reference/reference_lua/http.rst:136
msgid ""
"``low_speed_time`` - set the \"low speed time\" -- the time that the "
"transfer speed should be below the \"low speed limit\" for the library to"
" consider it too slow and abort. See also `CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"
msgstr ""
"``low_speed_time`` -- установка \"времени работы с низкой скоростью\" -- "
"времени, в течение которого скорость передачи должна быть ниже \"предела "
"низкой скорости\", чтобы библиотека посчитала работу слишком медленной и "
"завершила ее. См. также    `CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"

#: ../doc/reference/reference_lua/http.rst:140
msgid ""
"``low_speed_limit`` - set the \"low speed limit\" -- the average transfer"
" speed in bytes per second that the transfer should be below during \"low"
" speed time\" seconds for the library to consider it to be too slow and "
"abort. See also `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"
msgstr ""
"``low_speed_limit`` -- установка \"предела низкой скорости\" -- средней "
"скорости передачи в байтах в секунду, ниже которой должна быть скорость "
"передачи, чтобы библиотека посчитала работу слишком медленной и завершила"
" ее. См. также    `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"

#: ../doc/reference/reference_lua/http.rst:145
msgid "``verbose`` - set on/off verbose mode"
msgstr ""
"``verbose`` -- включение/отключение режима отображения подробной "
"информации"

#: ../doc/reference/reference_lua/http.rst:146
msgid ""
"``unix_socket`` - a socket name to use instead of an Internet address, "
"for a local connection. The Tarantool server must be built with "
"``libcurl`` 7.40 or later. See the :ref:`second example <http-example2>` "
"later in this section."
msgstr ""
"``unix_socket`` -- имя сокета, которое используется вместо адреса в сети "
"Интернет,    для локального соединения. Сборка сервера Tarantool'а должна"
" осуществляться с помощью ``libcurl`` 7.40 или более поздней версии. См. "
":ref:`второй пример <http-example2>` далее в разделе."

#: ../doc/reference/reference_lua/http.rst:150
msgid ""
"``max_header_name_len`` - the maximal length of a header name. If a "
"header name is bigger than this value, it is truncated to this length. "
"The default value is '32'."
msgstr ""
"``max_header_name_len`` -- максимальная длина имени заголовка. Если имя "
"заголовка больше данного значения, оно усекается до такой длины. По "
"умолчанию, '32'."

#: ../doc/reference/reference_lua/http.rst:153
msgid ""
"``follow_location`` - when the option is set to ``true`` (default) and "
"the response has a 3xx code, the HTTP client will automatically issue "
"another request to a location that a server sends in the ``Location`` "
"header. If the new response is 3xx again, the HTTP client will issue "
"still another request and so on in a loop until a non-3xx response will "
"be received. This last response will be returned as a result. Setting "
"this option to ``false`` allows to disable this behavior. In this case, "
"the HTTP client will return a 3xx response itself."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:162
msgid "connection information, with all of these components:"
msgstr "информация о подключении со всеми следующими компонентами:"

#: ../doc/reference/reference_lua/http.rst:164
msgid "``status`` - HTTP response status"
msgstr "``status`` -- статус HTTP-ответа"

#: ../doc/reference/reference_lua/http.rst:165
msgid "``reason`` - HTTP response status text"
msgstr "``reason`` -- текст статуса HTTP-ответа"

#: ../doc/reference/reference_lua/http.rst:166
msgid "``headers`` - a Lua table with normalized HTTP headers"
msgstr "``headers`` -- Lua-таблица с нормализованными HTTP-заголовками"

#: ../doc/reference/reference_lua/http.rst:167
msgid "``body`` - response body"
msgstr "``body`` -- тело сообщения-ответа"

#: ../doc/reference/reference_lua/http.rst:168
msgid "``proto`` - protocol version"
msgstr "``proto`` -- версия протокола"

#: ../doc/reference/reference_lua/http.rst:172
msgid "The following \"shortcuts\" exist for requests:"
msgstr "Для запросов существуют следующие ускоренные методы:"

#: ../doc/reference/reference_lua/http.rst:174
msgid ""
"``http_client:get(url, options)`` - shortcut for "
"``http_client:request(\"GET\", url, nil, opts)``"
msgstr ""
"``http_client:get(url, options)`` -- вспомогательный метод для "
"``http_client:request(\"GET\", url, nil, opts)``"

#: ../doc/reference/reference_lua/http.rst:176
msgid ""
"``http_client:post (url, body, options)`` - shortcut for "
"``http_client:request(\"POST\", url, body, opts)``"
msgstr ""
"``http_client:post (url, body, options)`` -- ускоренный метод для "
"``http_client:request(\"POST\", url, body, opts)``"

#: ../doc/reference/reference_lua/http.rst:178
msgid ""
"``http_client:put(url, body, options)`` - shortcut for "
"``http_client:request(\"PUT\", url, body, opts)``"
msgstr ""
"``http_client:put(url, body, options)`` -- ускоренный метод для "
"``http_client:request(\"PUT\", url, body, opts)``"

#: ../doc/reference/reference_lua/http.rst:180
msgid ""
"``http_client:patch(url, body, options)`` - shortcut for "
"``http_client:request(\"PATCH\", url, body, opts)``"
msgstr ""
"``http_client:patch(url, body, options)`` -- ускоренный метод для "
"``http_client:request(\"PATCH\", url, body, opts)``"

#: ../doc/reference/reference_lua/http.rst:182
msgid ""
"``http_client:options(url, options)`` - shortcut for "
"``http_client:request(\"OPTIONS\", url, nil, opts)``"
msgstr ""
"``http_client:options(url, options)`` -- ускоренный метод для "
"``http_client:request(\"OPTIONS\", url, nil, opts)``"

#: ../doc/reference/reference_lua/http.rst:184
msgid ""
"``http_client:head(url, options)`` - shortcut for "
"``http_client:request(\"HEAD\", url, nil, opts)``"
msgstr ""
"``http_client:head(url, options)`` -- ускоренный метод для "
"``http_client:request(\"HEAD\", url, nil, opts)``"

#: ../doc/reference/reference_lua/http.rst:186
msgid ""
"``http_client:delete(url, options)`` - shortcut for "
"``http_client:request(\"DELETE\", url, nil, opts)``"
msgstr ""
"``http_client:delete(url, options)`` -- ускоренный метод для "
"``http_client:request(\"DELETE\", url, nil, opts)``"

#: ../doc/reference/reference_lua/http.rst:188
msgid ""
"``http_client:trace(url, options)`` - shortcut for "
"``http_client:request(\"TRACE\", url, nil, opts)``"
msgstr ""
"``http_client:trace(url, options)`` -- ускоренный метод для "
"``http_client:request(\"TRACE\", url, nil, opts)``"

#: ../doc/reference/reference_lua/http.rst:190
msgid ""
"``http_client:connect:(url, options)`` - shortcut for "
"``http_client:request(\"CONNECT\", url, nil, opts)``"
msgstr ""
"``http_client:connect:(url, options)`` -- ускоренный метод для "
"``http_client:request(\"CONNECT\", url, nil, opts)``"

#: ../doc/reference/reference_lua/http.rst:193
msgid ""
"Requests may be influenced by environment variables, for example users "
"can set up an http proxy by setting :samp:`HTTP_PROXY={proxy}` before "
"initiating any requests. See the web page document `Environment variables"
" libcurl understands <https://curl.haxx.se/libcurl/c/libcurl-env.html>`_."
msgstr ""
"На запросы могут влиять переменные окружения, например, пользователи "
"могут задать прокси-сервер с HTTP, указав "
":samp:`HTTP_PROXY={прокси-сервер}` перед выполнением каких-либо запросов."
" См. веб-документ по переменным окружения `Environment variables libcurl "
"understands <https://curl.haxx.se/libcurl/c/libcurl-env.html>`_."

#: ../doc/reference/reference_lua/http.rst:203
msgid "The ``http_client:stat()`` function returns a table with statistics:"
msgstr ""
"Функция ``http_client:stat()`` возвращает таблицу со статистическими "
"данными:"

#: ../doc/reference/reference_lua/http.rst:205
msgid "``active_requests`` - number of currently executing requests"
msgstr "``active_requests`` -- количество активно выполняемых запросов"

#: ../doc/reference/reference_lua/http.rst:206
msgid "``sockets_added`` - total number of sockets added into an event loop"
msgstr ""
"``sockets_added`` -- общее количество сокетов, добавленных в событийный "
"цикл"

#: ../doc/reference/reference_lua/http.rst:207
msgid "``sockets_deleted`` - total number of sockets sockets from an event loop"
msgstr ""
"``sockets_deleted`` -- общее количество сокетов, удаленных из событийного"
" цикла"

#: ../doc/reference/reference_lua/http.rst:208
msgid "``total_requests`` - total number of requests"
msgstr "``total_requests`` -- общее количество запросов"

#: ../doc/reference/reference_lua/http.rst:209
msgid ""
"``http_200_responses`` - total number of requests which have returned "
"code HTTP 200"
msgstr ""
"``http_200_responses`` -- общее количество запросов, которые вернули код "
"состояния HTTP 200"

#: ../doc/reference/reference_lua/http.rst:211
msgid ""
"``http_other_responses`` - total number of requests which have not "
"returned code HTTP 200"
msgstr ""
"``http_other_responses`` -- общее количество запросов, которые не вернули"
" код состояния HTTP 200"

#: ../doc/reference/reference_lua/http.rst:213
msgid ""
"``failed_requests`` - total number of requests which have failed "
"including system errors, curl errors, and HTTP errors"
msgstr ""
"``failed_requests`` -- общее количество невыполненных запросов, включая "
"системные ошибки, ошибки curl и HTTP-ошибки"

#: ../doc/reference/reference_lua/http.rst:220
msgid ""
"Connect to an HTTP server, look at the size of the response for a 'GET' "
"request, and look at the statistics for the session."
msgstr ""
"Подключение к HTTP-серверу, просмотр размера ответа на 'GET'-запрос и "
"просмотр статистики по сессии."

#: ../doc/reference/reference_lua/http.rst:223
msgid ""
"tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"
msgstr ""
"tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"

#: ../doc/reference/reference_lua/http.rst:249
msgid "Start two Tarantool instances on the same computer."
msgstr "Запустите два экземпляра Tarantool'а на одном компьютере."

#: ../doc/reference/reference_lua/http.rst:251
msgid "On the first Tarantool instance, listen on a Unix socket:"
msgstr "В первом экземпляре Tarantool'а включите прослушивание Unix-сокета:"

#: ../doc/reference/reference_lua/http.rst:253
msgid "box.cfg{listen='/tmp/unix_domain_socket.sock'}"
msgstr "box.cfg{listen='/tmp/unix_domain_socket.sock'}"

#: ../doc/reference/reference_lua/http.rst:257
msgid "On the second Tarantool instance, send via ``http_client``:"
msgstr "На втором экземпляре Tarantool'а отправьте с помощью ``http_client``:"

#: ../doc/reference/reference_lua/http.rst:259
msgid ""
"box.cfg{}\n"
"http_client = require('http.client').new({5})\n"
"http_client:put('http://localhost/','body',{unix_socket = "
"'/tmp/unix_domain_socket.sock'})"
msgstr ""
"box.cfg{}\n"
"http_client = require('http.client').new({5})\n"
"http_client:put('http://localhost/','body',{unix_socket = "
"'/tmp/unix_domain_socket.sock'})"

#: ../doc/reference/reference_lua/http.rst:265
msgid ""
"Terminal #1 will show an error message: \"Invalid MsgPack\". This is not "
"useful but demonstrates the syntax and demonstrates that was sent was "
"received."
msgstr ""
"Терминал №1 покажет сообщение об ошибке: \"Invalid MsgPack\". Данный "
"пример бесполезен, но наглядно демонстрирует синтаксис и получение "
"отправленного сообщения."

#: ../doc/reference/reference_lua/iconv.rst:5
msgid "Module `iconv`"
msgstr "Модуль `iconv`"

#: ../doc/reference/reference_lua/iconv.rst:13
msgid ""
"The ``iconv`` module provides a way to convert a string with one encoding"
" to a string with another encoding, for example from ASCII to UTF-8. It "
"is based on the POSIX iconv routines."
msgstr ""
"Модуль ``iconv`` предоставляет метод конвертации строки с одним типом "
"кодировки в строку с другим типом кодировки, например из ASCII в UTF-8. "
"Он основывается на процедурах с iconv в POSIX."

#: ../doc/reference/reference_lua/iconv.rst:17
msgid ""
"An exact list of the available encodings may depend on environment. "
"Typically the list includes ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS, "
"and about 100 others. For a complete list, type ``iconv --list`` on a "
"terminal."
msgstr ""
"Точный список доступных кодировок зависит от окружения. Как правило, в "
"список входят ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS и около 100 "
"других. Чтобы увидеть общий список, введите команду ``iconv --list`` в "
"терминале."

#: ../doc/reference/reference_lua/iconv.rst:26
msgid "Below is a list of all ``iconv`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``iconv``."

#: ../doc/reference/reference_lua/iconv.rst:36
msgid ":ref:`iconv.new() <iconv-new>`"
msgstr ":ref:`iconv.new() <iconv-new>`"

#: ../doc/reference/reference_lua/iconv.rst:36
msgid "Create an iconv instance"
msgstr "Создание экземпляра iconv"

#: ../doc/reference/reference_lua/iconv.rst:39
msgid ":ref:`iconv.converter() <iconv-converter>`"
msgstr ":ref:`iconv.converter() <iconv-converter>`"

#: ../doc/reference/reference_lua/iconv.rst:39
msgid "Perform conversion on a string"
msgstr "Преобразование строки"

#: ../doc/reference/reference_lua/iconv.rst:47
msgid "Construct a new iconv instance."
msgstr "Создание нового iconv-экземпляра."

#: ../doc/reference/reference_lua/iconv.rst:49
msgid "the name of the encoding that we will convert to."
msgstr "название будущей кодировки."

#: ../doc/reference/reference_lua/iconv.rst:50
msgid "the name of the encoding that we will convert from."
msgstr "название используемой кодировки."

#: ../doc/reference/reference_lua/iconv.rst:52
msgid "a new iconv instance -- in effect, a callable function"
msgstr "новый экземпляр iconv -- на самом деле, вызываемая функция"

#: ../doc/reference/reference_lua/iconv.rst:55
msgid "If either parameter is not a valid name, there will be an error message."
msgstr ""
"Если значение одного из параметров представляет собой недопустимое имя, "
"появится сообщение об ошибке."

#: ../doc/reference/reference_lua/iconv.rst:59
msgid ""
"tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."
msgstr ""
"tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/iconv.rst:69
msgid "Convert."
msgstr "Преобразование."

#: ../doc/reference/reference_lua/iconv.rst
msgid "param string input-string"
msgstr "param string input-string"

#: ../doc/reference/reference_lua/iconv.rst:71
msgid "the string to be converted (the \"from\" string)"
msgstr "строка для преобразования (\"из\")"

#: ../doc/reference/reference_lua/iconv.rst:73
msgid "the string that results from the conversion (the \"to\" string)"
msgstr "строка, получаемая в результате преобразования (\"в\")"

#: ../doc/reference/reference_lua/iconv.rst:75
msgid ""
"If anything in input-string cannot be converted, there will be an error "
"message and the result string will be unchanged."
msgstr ""
"Если что-либо в строке input-string нельзя преобразовать, появится "
"сообщение об ошибке, строка останется неизменной."

#: ../doc/reference/reference_lua/iconv.rst:80
msgid ""
"We know that the Unicode code point for \"Д\" (CYRILLIC CAPITAL LETTER "
"DE) is hexadecimal 0414 according to the character database of Unicode_. "
"Therefore that is what it will look like in UTF-16. We know that "
"Tarantool typically uses the UTF-8 character set. So make a from-UTF-8"
"-to-UTF-16 converter, use string.hex('Д') to show what Д's encoding looks"
" like in the UTF-8 source, and use string.hex('Д'-after-conversion) to "
"show what it looks like in the UTF-16 target. Since the result is 0414, "
"we see that iconv conversion works. (Different iconv implementations "
"might use different names, for example UTF-16BE instead of UTF16BE.)"
msgstr ""
"Мы знаем, что кодовая точка для заглавной буквы \"Д\" в Unicode "
"представляет собой шестнадцатеричное число 0414 в соответствии с таблицей"
" символов Unicode_. Таким образом, так она будет выглядеть в UTF-16. Мы "
"знаем, что как правило, Tarantool использует набор символов UTF-8. "
"Поэтому для создания конвертора из UTF-8 в UTF-16 используем "
"string.hex('Д'), чтобы показать, как выглядит кодировка Д в исходном "
"наборе символов UTF-8, а затем используем string.hex('Д'-after-"
"conversion), чтобы показать, как она будет выглядеть в целевом наборе "
"символов UTF-16. Поскольку результатом будет 0414, видим, что "
"преобразование с помощью iconv сработало. (В разных реализациях iconv "
"могут использоваться разные имена, например UTF-16BE вместо UTF16BE.)"

#: ../doc/reference/reference_lua/iconv.rst:90
msgid ""
"tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."
msgstr ""
"tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."

#: ../doc/reference/reference_lua/index.rst:3
msgid "Built-in modules reference"
msgstr "Справочник по встроенным модулям"

#: ../doc/reference/reference_lua/index.rst:7
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr "В данном справочнике рассматриваются встроенные Lua-модули Tarantool'а."

#: ../doc/reference/reference_lua/index.rst:11
msgid ""
"Some functions in these modules are analogs to functions from `standard "
"Lua libraries <http://www.lua.org/manual/>`_. For better results, we "
"recommend using functions from Tarantool's built-in modules."
msgstr ""
"Некоторые функции в данных модулях представляют собой аналоги функций из "
"`стандартных Lua-библиотек <http://www.lua.org/manual/>`_. Для достижения"
" наилучшего результата мы рекомендуем использовать функции из встроенных "
"модулей Tarantool'а."

#: ../doc/reference/reference_lua/index.rst:15
msgid "List of Lua modules"
msgstr "Перечень Lua-модулей"

#: ../doc/reference/reference_lua/jit.rst:5
#, fuzzy
msgid "Module `jit`"
msgstr "Модуль `uri`"

#: ../doc/reference/reference_lua/jit.rst:13
msgid ""
"The ``jit`` module has functions for tracing the `LuaJIT "
"<http://luajit.org>`_ Just-In-Time compiler's progress, showing the byte-"
"code or assembler output that the compiler produces, and in general "
"providing information about what LuaJIT does with Lua code."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:22
#, fuzzy
msgid "Below is a list of all ``jit`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``uri``."

#: ../doc/reference/reference_lua/jit.rst:28
msgid "In this document, we will use:"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:27
msgid "``jit_dis_x64`` for ``require('jit.dis_x64')``,"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:28
msgid "``jit_v`` for ``require('jit.v')``,"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:29
msgid "``jit_dump`` for ``require('jit.dump')``."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:40
#, fuzzy
msgid ":ref:`jit_bc.dump() <jit-bc-dump>`"
msgstr ":ref:`csv.dump() <csv-dump>`"

#: ../doc/reference/reference_lua/jit.rst:40
msgid "Print the byte code of a function"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:43
msgid ":ref:`jit_dis_x86.disass() <jit-dis-x86-disass>`"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:43
msgid "Print the i386 assembler code of a string of bytes"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:46
msgid ":ref:`jit_dis_x64.disass() <jit-dis-x64-disass>`"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:46
msgid "Print the x86-64 assembler code of a string of bytes"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:49
msgid ":ref:`jit_dump.on() <jit-dump-on>`, :ref:`jit_dump.off() <jit-dump-off>`"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:49
msgid "Print the intermediate or machine code of the following Lua code"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:54
msgid ":ref:`jit_v.on() <jit-v-on>`, :ref:`jit_v.off() <jit-v-off>`"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:54
msgid "Print a trace of LuaJIT's progress compiling and interpreting code"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:64
msgid "Prints the byte code of a function."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:68
msgid ""
"tarantool> jit_bc = require('jit.bc')\n"
"---\n"
"...\n"
"\n"
"tarantool> function f()\n"
"         > print(\"D\")\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> jit_bc.dump(f)\n"
"-- BYTECODE -- 0x01113163c8:1-3\n"
"0001    GGET     0   0      ; \"print\"\n"
"0002    KSTR     2   1      ; \"D\"\n"
"0003    CALL     0   1   2\n"
"0004    RET0     0   1\n"
"\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:90
msgid ""
"function f()\n"
"  print(\"D\")\n"
"end\n"
"require('jit.bc').dump(f)"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:97
msgid ""
"For a list of available options, read `the source code of bc.lua "
"<https://github.com/tarantool/luajit/tree/tarantool-1.7/src/jit/bc.lua>`_."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:104
msgid "Prints the i386 assembler code of a string of bytes."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:108
msgid ""
"tarantool> -- Disassemble hexadecimal 97 which is the x86 code for xchg "
"eax, edi\n"
"---\n"
"...\n"
"\n"
"tarantool> jit_dis_x86 = require('jit.dis_x86')\n"
"---\n"
"...\n"
"\n"
"tarantool> jit_dis_86.disass('\\x97')\n"
"00000000  97                xchg eax, edi\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:123
msgid ""
"For a list of available options, read `the source code of dis_x86.lua "
"<https://github.com/tarantool/luajit/tree/tarantool-1.7/src/jit/dis_x86.lua>`_."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:130
msgid "Prints the x86-64 assembler code of a string of bytes."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:134
msgid ""
"tarantool> -- Disassemble hexadecimal 97 which is the x86-64 code for "
"xchg eax, edi\n"
"---\n"
"...\n"
"\n"
"tarantool> jit_dis_x64 = require('jit.dis_x64')\n"
"---\n"
"...\n"
"\n"
"tarantool> jit_dis_64.disass('\\x97')\n"
"00000000  97                xchg eax, edi\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:149
msgid ""
"For a list of available options, read `the source code of dis_x64.lua "
"<https://github.com/tarantool/luajit/tree/tarantool-1.7/src/jit/dis_x64.lua>`_."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:158
msgid "Prints the intermediate or machine code of the following Lua code."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:162
msgid ""
"tarantool> -- Show the machine code of a Lua \"for\" loop\n"
"tarantool> jit_dump = require('jit.dump')\n"
"tarantool> jit_dump.on('m')\n"
"tarantool> x = 0;\n"
"tarantool> for i = 1, 1e6 do\n"
"         > x = x + i\n"
"         > end\n"
"---- TRACE 1 start 0x01047fbc38:1\n"
"---- TRACE 1 mcode 148\n"
"104c29f6b  mov dword [r14-0xed0], 0x1\n"
"104c29f76  cvttsd2si ebp, [rdx]\n"
"104c29f7a  rorx rbx, [rdx-0x10], 0x2f\n"
"104c29f81  shr rbx, 0x11\n"
"104c29f85  mov rdx, [rbx+0x10]\n"
"104c29f89  cmp dword [rdx+0x34], +0x3f\n"
"104c29f8d  jnz 0x104c1a010  ->0\n"
"104c29f93  mov rcx, [rdx+0x28]\n"
"104c29f97  mov rdi, 0xfffd8001046b3d58\n"
"104c29fa1  cmp rdi, [rcx+0x320]\n"
"104c29fa8  jnz 0x104c1a010  ->0\n"
"104c29fae  lea rax, [rcx+0x318]\n"
"104c29fb5  cmp dword [rax+0x4], 0xfff90000\n"
"104c29fbc  jnb 0x104c1a010  ->0\n"
"104c29fc2  xorps xmm7, xmm7\n"
"104c29fc5  cvtsi2sd xmm7, ebp\n"
"104c29fc9  addsd xmm7, [rax]\n"
"104c29fcd  movsd [rax], xmm7\n"
"104c29fd1  add ebp, +0x01\n"
"104c29fd4  cmp ebp, 0x000f4240\n"
"104c29fda  jg 0x104c1a014   ->1\n"
"->LOOP:\n"
"104c29fe0  xorps xmm6, xmm6\n"
"104c29fe3  cvtsi2sd xmm6, ebp\n"
"104c29fe7  addsd xmm7, xmm6\n"
"104c29feb  movsd [rax], xmm7\n"
"104c29fef  add ebp, +0x01\n"
"104c29ff2  cmp ebp, 0x000f4240\n"
"104c29ff8  jle 0x104c29fe0  ->LOOP\n"
"104c29ffa  jmp 0x104c1a01c  ->3\n"
"---- TRACE 1 stop -> loop\n"
"\n"
"---\n"
"...\n"
"\n"
"tarantool> print(x)\n"
"500000500000\n"
"---\n"
"...\n"
"\n"
"tarantool> jit_dump.off()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:217
msgid ""
"For a list of available options, read `the source code of dump.lua "
"<https://github.com/tarantool/luajit/tree/tarantool-1.7/src/jit/dump.lua>`_."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:226
msgid "Prints a trace of LuaJIT's progress compiling and interpreting code."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:230
msgid ""
"tarantool> -- Show what LuaJIT is doing for a Lua \"for\" loop\n"
"tarantool> jit_v = require('jit.v')\n"
"tarantool> jit_v.on()\n"
"tarantool> l = 0\n"
"tarantool> for i = 1, 1e6 do\n"
"         >     l = l + i\n"
"         > end\n"
"[TRACE   3 \"for i = 1, 1e6 do\n"
"    l = l + i\n"
"end\":1 loop]\n"
"---\n"
"...\n"
"\n"
"tarantool> print(l)\n"
"500000500000\n"
"---\n"
"...\n"
"\n"
"tarantool> jit_v.off()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:254
msgid ""
"For a list of available options, read `the source code of v.lua "
"<https://github.com/tarantool/luajit/tree/tarantool-1.7/src/jit/v.lua>`_."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:5
msgid "Module `json`"
msgstr "Модуль `json`"

#: ../doc/reference/reference_lua/json.rst:11
msgid ""
"The ``json`` module provides JSON manipulation routines. It is based on "
"the `Lua-CJSON module by Mark Pulford "
"<http://www.kyne.com.au/~mark/software/lua-cjson.php>`_. For a complete "
"manual on Lua-CJSON please read `the official documentation "
"<http://www.kyne.com.au/~mark/software/lua-cjson-manual.html>`_."
msgstr ""
"Модуль ``json`` определяет процедуры работы с форматом JSON. Он создан на"
" основе `модуля Lua-CJSON от Mark Pulford "
"<http://www.kyne.com.au/~mark/software/lua-cjson.php>`_. Полное "
"руководство по Lua-CJSON включено в `официальную документацию "
"<http://www.kyne.com.au/~mark/software/lua-cjson-manual.html>`_."

#: ../doc/reference/reference_lua/json.rst:20
msgid "Below is a list of all ``json`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``json``."

#: ../doc/reference/reference_lua/json.rst:30
msgid ":ref:`json.encode() <json-encode>`"
msgstr ":ref:`json.encode() <json-encode>`"

#: ../doc/reference/reference_lua/json.rst:30
msgid "Convert a Lua object to a JSON string"
msgstr "Конвертация Lua-объекта в JSON-строку"

#: ../doc/reference/reference_lua/json.rst:33
msgid ":ref:`json.decode() <json-decode>`"
msgstr ":ref:`json.decode() <json-decode>`"

#: ../doc/reference/reference_lua/json.rst:33
msgid "Convert a JSON string to a Lua object"
msgstr "Конвертация JSON-строки в Lua-объект"

#: ../doc/reference/reference_lua/json.rst:36
msgid ":ref:`json.NULL <json-null>`"
msgstr ":ref:`json.NULL <json-null>`"

#: ../doc/reference/reference_lua/json.rst:36
#: ../doc/reference/reference_lua/msgpack.rst:39
#: ../doc/reference/reference_lua/yaml.rst:34
msgid "Analog of Lua's \"nil\""
msgstr "Аналог \"nil\" в языке Lua "

#: ../doc/reference/reference_lua/json.rst:39
msgid ":ref:`json.cfg() <json-module_cfg>`"
msgstr ":ref:`json.cfg() <json-module_cfg>`"

#: ../doc/reference/reference_lua/json.rst:39
msgid "Set global flags"
msgstr "Определение глобальных флагов"

#: ../doc/reference/reference_lua/json.rst:49
msgid "Convert a Lua object to a JSON string."
msgstr "Конвертация Lua-объекта в JSON-строку."

#: ../doc/reference/reference_lua/json.rst:51
#: ../doc/reference/reference_lua/msgpack.rst:60
#: ../doc/reference/reference_lua/yaml.rst:46
msgid "either a scalar value or a Lua table value."
msgstr "скалярное значение или значение из Lua-таблицы."

#: ../doc/reference/reference_lua/json.rst:52
#: ../doc/reference/reference_lua/json.rst:91
msgid "see :ref:`json.cfg <json-module_cfg>`"
msgstr "see :ref:`json.cfg <json-module_cfg>`"

#: ../doc/reference/reference_lua/json.rst:53
msgid "the original value reformatted as a JSON string."
msgstr "оригинальное значение, преобразованное в JSON-строку."

#: ../doc/reference/reference_lua/json.rst:58
msgid ""
"tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""
"tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."

#: ../doc/reference/reference_lua/json.rst:88
msgid "Convert a JSON string to a Lua object."
msgstr "Конвертация JSON-строки в Lua-объект."

#: ../doc/reference/reference_lua/json.rst:90
msgid "a string formatted as JSON."
msgstr "строка в формате JSON."

#: ../doc/reference/reference_lua/json.rst:92
#: ../doc/reference/reference_lua/yaml.rst:57
msgid "the original contents formatted as a Lua table."
msgstr "оригинальное содержание в формате Lua-таблицы."

#: ../doc/reference/reference_lua/json.rst:97
msgid ""
"tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""
"tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."

#: ../doc/reference/reference_lua/json.rst:115
msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how ``json.decode()`` can fit in an "
"application."
msgstr ""
"Чтобы увидеть применение ``json.decode()`` в приложении, см. практическое"
" задание :ref:`Подсчет суммы по JSON-полям во всех кортежах "
"<c_lua_tutorial-sum_a_json_field>`."

#: ../doc/reference/reference_lua/json.rst:123
#: ../doc/reference/reference_lua/msgpack.rst:111
#: ../doc/reference/reference_lua/yaml.rst:64
msgid ""
"A value comparable to Lua \"nil\" which may be useful as a placeholder in"
" a tuple."
msgstr ""
"Значение, сопоставимое с нулевым значением \"nil\" в языке Lua, которое "
"можно использовать в качестве объекта-заполнителя в кортеже."

#: ../doc/reference/reference_lua/json.rst:128
msgid ""
"-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is "
"json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""
"-- Когда полю Lua-таблицы присваивается nil, это поле -- null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- Когда полю Lua-таблицы присваивается json.NULL, это поле --  json.NULL"
"\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- Когда JSON-полю присваивается json.NULL, это поле -- null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."

#: ../doc/reference/reference_lua/json.rst:150
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr "Структуру JSON-вывода можно указать с помощью ``__serialize``:"

#: ../doc/reference/reference_lua/json.rst:152
msgid "``__serialize=\"seq\"`` for an array"
msgstr "``__serialize=\"seq\"`` для массива"

#: ../doc/reference/reference_lua/json.rst:153
msgid "``__serialize=\"map\"`` for a map"
msgstr "``__serialize=\"map\"`` для ассоциативного массива"

#: ../doc/reference/reference_lua/json.rst:155
#: ../doc/reference/reference_lua/yaml.rst:101
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results:"
msgstr ""
"Сериализация 'A' и' B' различными значениями ``__serialize`` приводит к "
"различным результатам:"

#: ../doc/reference/reference_lua/json.rst:158
msgid ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."

#: ../doc/reference/reference_lua/json.rst:181
msgid ""
"Set values affecting behavior of :ref:`json.encode <json-encode>` and "
":ref:`json.decode <json-decode>`."
msgstr ""
"Определяет значения, которые влияют на поведение :ref:`json.encode <json-"
"encode>` и :ref:`json.decode <json-decode>`."

#: ../doc/reference/reference_lua/json.rst:184
msgid "The values are all either integers or boolean ``true``/``false`` values."
msgstr ""
"Задаются либо все целочисленные значения, либо все логические значения "
"``true``/``false`` (правда/ложь)."

#: ../doc/reference/reference_lua/json.rst:186
msgid ""
"``cfg.encode_deep_as_nil`` (default is false) -- see :ref:`below <json-"
"module.cfg_encode_deep_as_nil>`"
msgstr ""
"``cfg.encode_deep_as_nil`` ((по умолчанию, false) -- см. :ref:`ниже "
"<json-module.cfg_encode_deep_as_nil>`"

#: ../doc/reference/reference_lua/json.rst:187
msgid ""
"``cfg.encode_invalid_as_nil`` (default is false) -- use ``null`` for all "
"unrecognizable types"
msgstr ""
"``cfg.encode_invalid_as_nil`` (по умолчанию, false) -- использовать "
"``null`` для всех нераспознаваемых типов"

#: ../doc/reference/reference_lua/json.rst:189
msgid "``cfg.encode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr "``cfg.encode_invalid_numbers`` (по умолчанию, true) -- разрешить nan и inf"

#: ../doc/reference/reference_lua/json.rst:190
msgid "``cfg.encode_load_metatables`` (default is false) -- load metatables"
msgstr ""
"``cfg.encode_load_metatables`` (по умолчанию, false) -- загрузить "
"метатаблицы"

#: ../doc/reference/reference_lua/json.rst:191
msgid ""
"``cfg.encode_max_depth`` (default is 32) -- maximum nesting depth in a "
"structure"
msgstr ""
"``cfg.encode_max_depth`` (по умолчанию, 32) -- максимальная глубина "
"вложенности в структуре"

#: ../doc/reference/reference_lua/json.rst:192
msgid ""
"``cfg.encode_number_precision`` (default is 14) -- maximum post-decimal "
"digits"
msgstr ""
"``cfg.encode_number_precision`` (по умолчанию, 14) -- максимальное "
"количество цифр в дробной части"

#: ../doc/reference/reference_lua/json.rst:193
msgid ""
"``cfg.encode_sparse_convert`` (default is true) -- handle excessively "
"sparse arrays as maps"
msgstr ""
"``cfg.encode_sparse_convert`` (по умолчанию, true) -- обрабатывать "
"излишне разреженные массивы как ассоциативные массивы"

#: ../doc/reference/reference_lua/json.rst:194
msgid "``cfg.encode_sparse_ratio`` (default is 2) -- how sparse an array can be"
msgstr ""
"``cfg.encode_sparse_ratio`` (по умолчанию, 2) -- допустимая разреженность"
" массива"

#: ../doc/reference/reference_lua/json.rst:195
msgid ""
"``cfg.encode_sparse_safe`` (default is 10) -- how much can safely be "
"sparse"
msgstr ""
"``cfg.encode_sparse_safe`` (по умолчанию, 10) -- безопасная разреженность"
" массивы"

#: ../doc/reference/reference_lua/json.rst:196
msgid ""
"``cfg.encode_use_tostring`` (default is false) -- use ``tostring`` for "
"unrecognizable types"
msgstr ""
"``cfg.encode_use_tostring`` (по умолчанию, false) -- использовать "
"``tostring`` для нераспознаваемых типов"

#: ../doc/reference/reference_lua/json.rst:198
msgid "``cfg.decode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr "``cfg.decode_invalid_numbers`` (по умолчанию, true) -- разрешить nan и inf"

#: ../doc/reference/reference_lua/json.rst:199
#, fuzzy
msgid "``cfg.decode_load_metatables`` (default is false) -- load metatables"
msgstr ""
"``cfg.encode_load_metatables`` (по умолчанию, false) -- загрузить "
"метатаблицы"

#: ../doc/reference/reference_lua/json.rst:200
msgid ""
"``cfg.decode_max_depth`` (default is 32) -- maximum nesting depth in a "
"structure"
msgstr ""
"``cfg.decode_max_depth`` (по умолчанию, 32) -- максимальная глубина "
"вложенности в структуре"

#: ../doc/reference/reference_lua/json.rst:201
msgid ""
"``cfg.decode_save_metatables`` (default is true) -- like "
"``encode_load_metatables``"
msgstr ""
"``cfg.decode_save_metatables`` (по умолчанию, true) -- как "
"``encode_load_metatables``"

#: ../doc/reference/reference_lua/json.rst:202
#, fuzzy
msgid ""
"``cfg.decode_sparse_convert`` (default is true) -- like "
"``encode_sparse_convert``"
msgstr ""
"``cfg.decode_save_metatables`` (по умолчанию, true) -- как "
"``encode_load_metatables``"

#: ../doc/reference/reference_lua/json.rst:203
#, fuzzy
msgid ""
"``cfg.decode_use_tostring`` (default is false) -- use ``tostring`` for "
"unrecognizable types"
msgstr ""
"``cfg.encode_use_tostring`` (по умолчанию, false) -- использовать "
"``tostring`` для нераспознаваемых типов"

#: ../doc/reference/reference_lua/json.rst:206
msgid ""
"For example, the following code will encode 0/0 as nan (\"not a number\")"
" and 1/0 as inf (\"infinity\"), rather than returning nil or an error "
"message:"
msgstr ""
"Например, следующий код интерпретирует 0/0 как nan (\"не является "
"числом\"), а 1/0 -- как inf (\"бесконечность\"), вместо того, чтобы "
"вернуть nil или ошибку:"

#: ../doc/reference/reference_lua/json.rst:209
msgid ""
"json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""
"json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"

#: ../doc/reference/reference_lua/json.rst:217
msgid "The result of the ``json.encode()`` request will look like this:"
msgstr "Результат запроса ``json.encode()`` будет следующим:"

#: ../doc/reference/reference_lua/json.rst:219
msgid ""
"tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""
"tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."

#: ../doc/reference/reference_lua/json.rst:226
msgid ""
"To achieve the same effect for only one call to ``json.encode()`` without"
" changing the configuration persistently, one could say ``json.encode({1,"
" x, y, 2}, {encode_invalid_numbers = true})``."
msgstr ""
"Чтобы получить такой же эффект для одиночного вызова ``json.encode()`` "
"без постоянного изменения конфигурации, можно вызвать ``json.encode({1, "
"x, y, 2}, {encode_invalid_numbers = true})``."

#: ../doc/reference/reference_lua/json.rst:230
msgid ""
"The same configuration settings exist for json, for :ref:`MsgPack "
"<msgpack-module>`, and for :ref:`YAML <yaml-module>`."
msgstr ""
"Такие параметры конфигурации применяются для формата JSON, для "
":ref:`MsgPack <msgpack-module>` и для :ref:`YAML <yaml-module>`."

#: ../doc/reference/reference_lua/json.rst:237
msgid ""
"**Behavior change:** Before Tarantool version 1.10.4, if a nested "
"structure was deeper than ``cfg.encode_max_depth``, the deeper levels "
"were cropped (encoded as nil)."
msgstr ""
"**Поведение изменилось:** До версии 1.10.4 Tarantool'а, если глубина "
"вложения структуры была больше, чем ``cfg.encode_max_depth``, более "
"глубокие уровни обрезаются (кодируются как nil)."

#: ../doc/reference/reference_lua/json.rst:241
msgid ""
"Now, the result is an error suggesting that ``cfg.encode_max_depth`` is "
"not deep enough. To return to the old behavior, say "
"``cfg.encode_deep_as_nil = true``."
msgstr ""
"Теперь результатом станет ошибка с указанием недостаточной глубины "
"``cfg.encode_max_depth``. Чтобы вернуть старое поведение системы, "
"выполните ``cfg.encode_deep_as_nil = true``."

#: ../doc/reference/reference_lua/json.rst:245
msgid "This option is ignored for ``YAML``."
msgstr "Этот параметр не учитывается для ``YAML``."

#: ../doc/reference/reference_lua/key_def.rst:5
#, fuzzy
msgid "Module `key_def`"
msgstr "Модуль `socket`"

#: ../doc/reference/reference_lua/key_def.rst:9
msgid ""
"The `key_def` module has a function for making a definition of the field "
"numbers and types of a tuple. The definition is usually used in "
"conjunction with an index definition to extract or compare the index key "
"values."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:18
#, fuzzy
msgid "Create a new key_def instance."
msgstr "Создание экземпляра iconv"

#: ../doc/reference/reference_lua/key_def.rst:20
msgid ""
"field numbers and types. There must be at least one part and it must have"
" at least fieldno and type."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst
#: ../doc/reference/reference_lua/xlog.rst
msgid "returns"
msgstr "возвращает"

#: ../doc/reference/reference_lua/key_def.rst:24
msgid "key_def-object :ref:`a key_def object <key_def-object>`"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:26
#, fuzzy
msgid ""
"The parts table has components which are the same as the ``parts`` option"
" in :ref:`Options for space_object:create_index() <box_space-"
"create_index-options>`."
msgstr ""
"Если ``vinyl_range_size`` содержит не нулевое значение nil и не 0, это "
"значение используется в качестве значения по умолчанию для параметра "
"``range_size`` в таблице :ref:`Параметры space_object:create_index() "
"<box_space-create_index>`."

#: ../doc/reference/reference_lua/key_def.rst:30
msgid "fieldno (integer) for example fieldno=1"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:32
msgid "type (string) for example type='string'"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:34
msgid "Other components are optional."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:36
msgid "Example: ``key_def.new({{type = 'unsigned', fieldno = 1}})``"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:42
msgid ""
"A key_def object is an object returned by :ref:`key_def.new() <key_def-"
"new>`. It has methods :ref:`extract_key() <key_def-extract_key>`, "
":ref:`compare() <key_def-compare>`, :ref:`compare_with_key() <key_def-"
"compare_with_key>`, :ref:`merge() <key_def-merge>`, :ref:`totable() "
"<key_def-totable>`."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:54
msgid "Return a tuple containing only the fields of the key_def object."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:56
#: ../doc/reference/reference_lua/key_def.rst:131
#: ../doc/reference/reference_lua/key_def.rst:132
#: ../doc/reference/reference_lua/key_def.rst:157
#: ../doc/reference/reference_lua/key_def.rst:158
#: ../doc/reference/reference_lua/merger.rst:160
msgid "tuple or Lua table with field contents"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:58
msgid "the fields that were defined for the key_def object"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:60
#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:244
#, fuzzy
msgid "**Example #1:**"
msgstr "**Пример 1:**"

#: ../doc/reference/reference_lua/key_def.rst:62
msgid ""
"-- Suppose that an item has five fields\n"
"-- 1, 99.5, 'X', nil, 99.5\n"
"-- and the fields that we care about are\n"
"-- #3 (a string) and #1 (an integer).\n"
"-- We can define those fields with k = key_def.new\n"
"-- and extract the values with k:extract_key.\n"
"\n"
"tarantool> key_def = require('key_def')\n"
"---\n"
"...\n"
"\n"
"tarantool> k = key_def.new({{type = 'string', fieldno = 3},\n"
">                           {type = 'unsigned', fieldno =1 }})\n"
"---\n"
"...\n"
"\n"
"tarantool> k:extract_key({1, 99.5, 'X', nil, 99.5})\n"
"---\n"
"- ['X', 1]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:85
#, fuzzy
msgid "**Example #2**"
msgstr "**Пример 2:**"

#: ../doc/reference/reference_lua/key_def.rst:87
msgid ""
"-- Now suppose that the item is a tuple in a space which\n"
"-- has an index on field #3 plus field #1.\n"
"-- We can use key_def.new with the index definition\n"
"-- instead of filling it out as we did with Example #1.\n"
"-- The result will be the same.\n"
"key_def = require('key_def')\n"
"box.schema.space.create('T')\n"
"i = box.space.T:create_index('I',{parts={3,'string',1,'unsigned'}})\n"
"box.space.T:insert{1, 99.5, 'X', nil, 99.5}\n"
"k = key_def.new(i.parts)\n"
"k:extract_key(box.space.T:get({'X', 1}))"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:101
#, fuzzy
msgid "**Example #3**"
msgstr "**Пример 2:**"

#: ../doc/reference/reference_lua/key_def.rst:103
msgid ""
"-- Iterate through the tuples in a secondary non-unique index.\n"
"-- extracting the tuples' primary-key values so they can be deleted\n"
"-- using a unique index. This code should be part of a Lua function.\n"
"local key_def_lib = require('key_def')\n"
"local s = box.schema.space.create('test')\n"
"local pk = s:create_index('pk')\n"
"local sk = s:create_index('test', {unique = false, parts = {\n"
"    {2, 'number', path = 'a'}, {2, 'number', path = 'b'}}})\n"
"s:insert{1, {a = 1, b = 1}}\n"
"s:insert{2, {a = 1, b = 2}}\n"
"local key_def = key_def_lib.new(pk.parts)\n"
"for _, tuple in sk:pairs({1})) do\n"
"    local key = key_def:extract_key(tuple)\n"
"    pk:delete(key)\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:125
msgid ""
"Compare the key fields of tuple_1 to the key fields of tuple_2. This is a"
" tuple-by-tuple comparison so users do not have to write code which "
"compares a field at a time. Each field's type and collation wll be taken "
"into account. In effect it is a comparison of extract_key(tuple_1) with "
"extract_key(tuple_2)."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:134
msgid ""
"> 0 if tuple_1 key fields > tuple_2 key fields, = 0 if tuple_1 key fields"
" = tuple_2 key fields, < 0 if tuple_1 key fields < tuple_2 key fields"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:140
msgid ""
"-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare({1, 99.5, 'X', nil, 99.5}, {1, 99.5, 'x', nil, 99.5})"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:152
msgid ""
"Compare the key fields of tuple_1 to all the fields of tuple_2. This is "
"the same as :ref:`key_def_object:compare() <key_def-compare>` except that"
" tuple_2 contains only the key fields. In effect it is a comparison of "
"extract_key(tuple_1) with tuple_2."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:160
msgid ""
"> 0 if tuple_1 key fields > tuple_2 fields, = 0 if tuple_1 key fields = "
"tuple_2 fields, < 0 if tuple_1 key fields < tuple_2 fields"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:166
msgid ""
"-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare_with_key({1, 99.5, 'X', nil, 99.5}, {'x', 1})"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:178
msgid ""
"Combine the main key_def_object with other_key_def_object. The return "
"value is a new key_def_object containing all the fields of the main "
"key_def_object, then all the fields of other_key_def_object which are not"
" in the main key_def_object."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:183
msgid "definition of fields to add"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:185
#, fuzzy
msgid "key_def_object"
msgstr "объект"

#: ../doc/reference/reference_lua/key_def.rst:189
msgid ""
"-- This will return a key definition with fieldno=3 and fieldno=1.\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k2= key_def.new({{type = 'unsigned', fieldno = 1},\n"
"                 {type = 'string', fieldno = 3}})\n"
"k:merge(k2)"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:202
msgid ""
"Return a table containing what is in the key_def_object. This is the "
"reverse of ``key_def.new()``:"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:205
msgid "``key_def.new()`` takes a table and returns a key_def object,"
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:206
msgid "``key_def_object:totable()`` takes a key_def object and returns a table."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:208
msgid "This is useful for input to ``_serialize`` methods."
msgstr ""

#: ../doc/reference/reference_lua/key_def.rst:214
msgid ""
"-- This will return a table with type='string', fieldno=3\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k:totable()"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:5
msgid "Module `log`"
msgstr "Модуль `log`"

#: ../doc/reference/reference_lua/log.rst:13
msgid ""
"The Tarantool server puts all diagnostic messages in a log file specified"
" by the :ref:`log <cfg_logging-log>` configuration parameter. Diagnostic "
"messages may be either system-generated by the server's internal code, or"
" user-generated with the :samp:`log.{log_level_function_name}` function."
msgstr ""
"Сервер Tarantool'а сохраняет все сообщения об ошибке в файл журнала, "
"указанный в конфигурационном параметре :ref:`log <cfg_logging-log>`. "
"Сообщения об ошибке могут быть созданы либо системой с помощью "
"внутреннего кода сервера, либо пользователем с помощью функции "
":samp:`log.{log_level_function_name}`."

#: ../doc/reference/reference_lua/log.rst:18
msgid ""
"As explained in the description of :ref:`log_format <cfg_logging-"
"log_format>` configuration setting, there are two possible formats for "
"log entries:"
msgstr ""
"Как сказано в описании параметра :ref:`log_format <cfg_logging-"
"log_format>`, записи в журнале могут сохраняться в одном из двух "
"форматов:"

#: ../doc/reference/reference_lua/log.rst:48
msgid "Below is a list of all ``log`` functions."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``log``."

#: ../doc/reference/reference_lua/log.rst:58
msgid ""
":ref:`log.error() <log-ug_message>` |br| :ref:`log.warn() <log-"
"ug_message>` |br| :ref:`log.info() <log-ug_message>` |br| "
":ref:`log.verbose() <log-ug_message>` |br| :ref:`log.debug() <log-"
"ug_message>`"
msgstr ""
":ref:`log.error() <log-ug_message>` |br| :ref:`log.warn() <log-"
"ug_message>` |br| :ref:`log.info() <log-ug_message>` |br| "
":ref:`log.verbose() <log-ug_message>` |br| :ref:`log.debug() <log-"
"ug_message>`"

#: ../doc/reference/reference_lua/log.rst:62
msgid "Write a user-generated message to a log file"
msgstr "Запись сгенерированного пользователем сообщения в файл журнала"

#: ../doc/reference/reference_lua/log.rst:69
msgid ":ref:`log.logger_pid() <log-logger_pid>`"
msgstr ":ref:`log.logger_pid() <log-logger_pid>`"

#: ../doc/reference/reference_lua/log.rst:69
msgid "Get the PID of a logger"
msgstr "Получение PID регистратора записи в журнале"

#: ../doc/reference/reference_lua/log.rst:72
msgid ":ref:`log.rotate() <log-rotate>`"
msgstr ":ref:`log.rotate() <log-rotate>`"

#: ../doc/reference/reference_lua/log.rst:72
msgid "Rotate a log file"
msgstr "Ротация файла журнала"

#: ../doc/reference/reference_lua/log.rst:84
msgid ""
"Output a user-generated message to the :ref:`log file <cfg_logging-log>`,"
" given log_level_function_name = ``error`` or ``warn`` or ``info`` or "
"``verbose`` or ``debug``."
msgstr ""
"Запись созданного пользователем сообщения в :ref:`файл журнала "
"<cfg_logging-log>` при условии, что log_level_function_name = ``error`` "
"или ``warn``, или ``info``, или ``verbose``, или ``debug``."

#: ../doc/reference/reference_lua/log.rst:88
msgid ""
"As explained in the description of the configuration setting for "
":ref:`log_level <cfg_logging-log_level>`, there are seven levels of "
"detail:"
msgstr ""
"Как поясняется в описании настроек конфигурации :ref:`log_level "
"<cfg_logging-log_level>`, есть семь уровней детализации:"

#: ../doc/reference/reference_lua/log.rst:92
msgid "2 – ``ERROR`` -- this corresponds to ``log.error(...)``"
msgstr "2 – ``ERROR`` -- соответствует ``log.error(...)``"

#: ../doc/reference/reference_lua/log.rst:94
msgid "4 – ``WARNING``  -- this corresponds to ``log.warn(...)``"
msgstr "4 – ``WARNING``  -- соответствует ``log.warn(...)``"

#: ../doc/reference/reference_lua/log.rst:95
msgid "5 – ``INFO`` -- this corresponds to ``log.info(...)``"
msgstr "5 – ``INFO`` -- соответствует ``log.info(...)``"

#: ../doc/reference/reference_lua/log.rst:96
msgid "6 – ``VERBOSE``  -- this corresponds to ``log.verbose(...)``"
msgstr "6 – ``VERBOSE``  -- соответствует ``log.verbose(...)``"

#: ../doc/reference/reference_lua/log.rst:97
msgid "7 – ``DEBUG`` -- this corresponds to ``log.debug(...)``"
msgstr "7 – ``DEBUG`` -- соответствует ``log.debug(...)``"

#: ../doc/reference/reference_lua/log.rst:99
msgid ""
"For example, if ``box.cfg.log_level`` is currently 5 (the default value),"
" then ``log.error(...)``, ``log.warn(...)`` and ``log.info(...)`` "
"messages will go to the log file. However, ``log.verbose(...)`` and "
"``log.debug(...)`` messages will not go to the log file, because they "
"correspond to higher levels of detail."
msgstr ""
"Например, если уровень ``box.cfg.log_level`` в данный момент -- 5 (по "
"умолчанию), то сообщения ``log.error(...)``, ``log.warn(...)`` и "
"``log.info(...)`` будут записываться в файл журнала. Однако, сообщения "
"``log.verbose(...)`` и ``log.debug(...)`` не будут записываться в файл "
"журнала, поскольку они соответствуют более высоким уровням детализации."

#: ../doc/reference/reference_lua/log.rst:105
#, python-format
msgid ""
"Usually a string.  Messages may contain C-style format specifiers %d or "
"%s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a "
"number and ``y`` is a string.  Less commonly, messages may be other "
"scalar data types, or even tables. So :code:`log.error({'x',18.7,true})` "
"will work."
msgstr ""
"Как правило, строка.  Сообщения могут содержать спецификаторы формата в "
"стиле C: %d или %s, то есть :samp:`log.error('...%d...%s', {x}, {y})` "
"сработает, если ``x`` -- это число, а ``y`` -- это строка.  В редких "
"случаях сообщения могут представлять собой другие скалярные типы данных "
"или даже таблицы. Поэтому :code:`log.error({'x',18.7,true})` сработает."

#: ../doc/reference/reference_lua/log.rst:105
msgid "Usually a string."
msgstr "Как правило, строка."

#: ../doc/reference/reference_lua/log.rst:107
#, python-format
msgid ""
"Messages may contain C-style format specifiers %d or %s, so "
":samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number "
"and ``y`` is a string."
msgstr ""
"Сообщения могут содержать спецификаторы формата в стиле C: %d или %s, то "
"есть :samp:`log.error('...%d...%s', {x}, {y})` сработает, если ``x`` -- "
"это число, а ``y`` -- это строка."

#: ../doc/reference/reference_lua/log.rst:111
msgid ""
"Less commonly, messages may be other scalar data types, or even tables. "
"So :code:`log.error({'x',18.7,true})` will work."
msgstr ""
"В редких случаях сообщения могут представлять собой другие скалярные типы"
" данных или даже таблицы. Поэтому :code:`log.error({'x',18.7,true})` "
"сработает."

#: ../doc/reference/reference_lua/log.rst:117
msgid "The actual output will be a line in the log, containing:"
msgstr ""
"Выходное значение будет представлять собой строку в журнале, которая "
"содержит следующее:"

#: ../doc/reference/reference_lua/log.rst:119
msgid "the current timestamp,"
msgstr "текущая временная отметка,"

#: ../doc/reference/reference_lua/log.rst:120
msgid "a module name,"
msgstr "название модуля,"

#: ../doc/reference/reference_lua/log.rst:121
msgid "'E', 'W', 'I', 'V' or 'D' depending on ``log_level_function_name``, and"
msgstr ", 'W', 'I', 'V' или 'D' в зависимости от ``log_level_function_name`` и"

#: ../doc/reference/reference_lua/log.rst:122
msgid "``message``."
msgstr "``сообщение``."

#: ../doc/reference/reference_lua/log.rst:124
msgid ""
"Output will not occur if ``log_level_function_name`` is for a type "
"greater than :ref:`log_level <cfg_logging-log_level>`."
msgstr ""
"Вывода не будет, если ``log_level_function_name`` соответствует типу "
"больше, чем :ref:`log_level <cfg_logging-log_level>`."

#: ../doc/reference/reference_lua/log.rst:132
msgid "PID of a logger"
msgstr "PID регистратора записи в журнале"

#: ../doc/reference/reference_lua/log.rst:138
msgid "Rotate the log."
msgstr "Ротация журнала."

#: ../doc/reference/reference_lua/log.rst:146
#, python-format
msgid ""
"$ tarantool\n"
"tarantool> box.cfg{log_level=3, log='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"
msgstr ""
"$ tarantool\n"
"tarantool> box.cfg{log_level=3, log='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"

#: ../doc/reference/reference_lua/log.rst:155
msgid ""
"$ less tarantool.txt\n"
"2017-09-20 ... [68617] main/101/interactive C> version "
"1.7.5-31-ge939c6ea6\n"
"2017-09-20 ... [68617] main/101/interactive C> log level 3\n"
"2017-09-20 ... [68617] main/101/interactive [C]:-1 E> Error"
msgstr ""
"$ less tarantool.txt\n"
"2017-09-20 ... [68617] main/101/interactive C> version "
"1.7.5-31-ge939c6ea6\n"
"2017-09-20 ... [68617] main/101/interactive C> log level 3\n"
"2017-09-20 ... [68617] main/101/interactive [C]:-1 E> Error"

#: ../doc/reference/reference_lua/log.rst:162
msgid "The 'Error' line is visible in ``tarantool.txt`` preceded by the letter E."
msgstr "Строке 'Error' в файле ``tarantool.txt`` предшествует буква \"E\"."

#: ../doc/reference/reference_lua/log.rst:164
msgid "The 'Info' line is not present because the ``log_level`` is 3."
msgstr "Строка 'Info' отсутствует, потому что ``log_level`` -- 3."

#: ../doc/reference/reference_lua/merger.rst:5
#, fuzzy
msgid "Module `merger`"
msgstr "Модуль `errno`"

#: ../doc/reference/reference_lua/merger.rst:11
msgid ""
"The ``merger`` module takes a stream of tuples and provides access to "
"them as tables."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:18
msgid "The four functions for creating a merger object instance are:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:20
#, fuzzy
msgid ":ref:`merger.new_tuple_source() <merger-new_tuple_source>`,"
msgstr ":ref:`debug.setupvalue() <debug-setupvalue>`"

#: ../doc/reference/reference_lua/merger.rst:21
msgid ":ref:`merger.new_buffer_source() <merger-new_buffer_source>`,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:22
msgid ":ref:`merger.new_table_source <merger-new_table_source>`,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:23
#: ../doc/reference/reference_lua/merger.rst:111
msgid ":ref:`merger.new(merger_source...) <merger-new_merger_source>`."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:25
msgid "The methods for using a merger object are:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:27
#, fuzzy
msgid ":ref:`merger_object:select() <merger-select>`,"
msgstr ":ref:`socket_object:sendto() <socket-sendto>`"

#: ../doc/reference/reference_lua/merger.rst:28
#: ../doc/reference/reference_lua/merger.rst:116
#, fuzzy
msgid ":ref:`merger_object:pairs() <merger-pairs>`."
msgstr ":ref:`pairs() <membership-pairs>`"

#: ../doc/reference/reference_lua/merger.rst:36
msgid "Create a new merger instance from a tuple source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:38
msgid "A tuple source just returns one tuple."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:40
msgid ""
"The generator function ``gen()`` allows creation of multiple tuples via "
"an iterator."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:43
#, fuzzy
msgid "The ``gen()`` function should return:"
msgstr "вызов ``join()`` возвращает true (правда),"

#: ../doc/reference/reference_lua/merger.rst:45
msgid "state, tuple each time it is called and a new tuple is available,"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:46
msgid "nil when no more tuples are available."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:48
msgid "function for iteratively returning tuples"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:49
msgid "parameter for the gen function"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:51
#: ../doc/reference/reference_lua/merger.rst:95
msgid "merger-object :ref:`a merger object <merger-object>`"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:53
#: ../doc/reference/reference_lua/merger.rst:100
msgid "Example: see :ref:`merger_object:pairs() <merger-pairs>` method."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:59
msgid "Create a new merger instance from a buffer source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:61
#: ../doc/reference/reference_lua/merger.rst:73
msgid ""
"Parameters and return: same as for :ref:`merger.new_tuple_source <merger-"
"new_tuple_source>`."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:64
#, fuzzy
msgid ""
"To set up a buffer, or a series of buffers, use :ref:`the buffer module "
"<buffer-module>`."
msgstr "``{buffer=...}``. Например, см. :ref:`модуль buffer <buffer-module>`."

#: ../doc/reference/reference_lua/merger.rst:71
msgid "Create a new merger instance from a table source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:76
msgid "Example: see :ref:`merger_object:select() <merger-select>` method."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:82
msgid "Create a new merger instance from a merger source."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:84
msgid ""
"A merger source is created from a :ref:`key_def <key_def-module>` object "
"and a set of (tuple or buffer or table or merger) sources. It performs a "
"kind of merge sort. It chooses a source with a minimal / maximal tuple on"
" each step, consumes a tuple from this source, and repeats."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:91
msgid "object created with ``key_def``"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:92
msgid "parameter for the ``gen()`` function"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:93
msgid "``reverse=true`` if descending, false or nil if ascending"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:97
msgid ""
"A ``key_def`` can be cached across requests with the same ordering rules "
"(typically these would be requests accessing the same space)."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:106
msgid "A merger object is an object returned by:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:108
#, fuzzy
msgid ":ref:`merger.new_tuple_source() <merger-new_tuple_source>` or"
msgstr ":ref:`debug.setupvalue() <debug-setupvalue>`"

#: ../doc/reference/reference_lua/merger.rst:109
msgid ":ref:`merger.new_buffer_source() <merger-new_buffer_source>` or"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:110
msgid ":ref:`merger.new_table_source <merger-new_table_source>` or"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:113
msgid "It has methods:"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:115
#, fuzzy
msgid ":ref:`merger_object:select() <merger-select>` or"
msgstr ":ref:`socket_object:sendto() <socket-sendto>`"

#: ../doc/reference/reference_lua/merger.rst:122
msgid "Access the contents of a merger object with familiar ``select`` syntax."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:124
#: ../doc/reference/reference_lua/merger.rst:125
msgid "as in ``net.box`` client :ref:`conn:select <conn-select>` method"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:127
msgid "a table of tuples, similar to what ``select`` would return"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:129
msgid "**Example with new_table_source():**"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:131
msgid ""
"-- Source via new_table_source, simple generator function\n"
"-- tarantool> s:select()\n"
"-- ---\n"
"-- - - [100]\n"
"--   - [200]\n"
"-- ...\n"
"merger=require('merger')\n"
"k=0\n"
"function merger_function(param)\n"
"  k = k + 1\n"
"  if param[k] == nil then return nil end\n"
"  return box.NULL, param[k]\n"
"  end\n"
"chunks={}\n"
"chunks[1] = {{100}} chunks[2] = {{200}} chunks[3] = nil\n"
"s = merger.new_table_source(merger_function, chunks)\n"
"s:select()"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:155
msgid ""
"The ``pairs()`` method (or the equivalent ``ipairs() alias`` method) "
"returns a luafun iterator. It is a Lua iterator, but also provides a set "
"of handy methods to operate in functional style."
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:162
msgid "the tuples that can be found with a standard ``pairs()`` function"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:164
msgid "**Example with new_tuple_source():**"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:166
msgid ""
"-- Source via new_tuple_source, from a space of tables\n"
"-- The result will look like this:\n"
"-- tarantool> so:pairs():totable()\n"
"-- ---\n"
"-- - - [100]\n"
"--   - [200]\n"
"-- ...\n"
"merger = require('merger')\n"
"box.schema.space.create('s')\n"
"box.space.s:create_index('i')\n"
"box.space.s:insert({100})\n"
"box.space.s:insert({200})\n"
"so = merger.new_tuple_source(box.space.s:pairs())\n"
"so:pairs():totable()"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:183
msgid "**Example with two mergers:**"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:185
msgid ""
"-- Source via key_def, and table data\n"
"\n"
"-- Create the key_def object\n"
"merger = require('merger')\n"
"key_def_lib = require('key_def')\n"
"key_def = key_def_lib.new({{\n"
"    fieldno = 1,\n"
"    type = 'string',\n"
"}})\n"
"-- Create the table source\n"
"data = {{'a'}, {'b'}, {'c'}}\n"
"source = merger.new_source_fromtable(data)\n"
"i1 = merger.new(key_def, {source}):pairs()\n"
"i2 = merger.new(key_def, {source}):pairs()\n"
"-- t1 will be 'a' (tuple 1 from merger 1)\n"
"t1 = i1:head():totable()\n"
"-- t3 will be 'c' (tuple 3 from merger 2)\n"
"t3 = i2:head():totable()\n"
"-- t2 will be 'b' (tuple 2 from merger 1)\n"
"t2 = i1:head():totable()\n"
"-- i1:is_null() will be true (merger 1 ends)\n"
"i1:is_null()\n"
"-- i2:is_null() will be true (merger 2 ends)\n"
"i2:is_null()"
msgstr ""

#: ../doc/reference/reference_lua/merger.rst:212
#, fuzzy
msgid "**More examples:**"
msgstr "**Примеры:**"

#: ../doc/reference/reference_lua/merger.rst:214
msgid ""
"See `https://github.com/Totktonada/tarantool-merger-examples "
"<https://github.com/Totktonada/tarantool-merger-examples>`_ which, in "
"addition to discussing the merger API in detail, shows Lua code for "
"handling many more situations than are in this manual's brief examples."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:5
msgid "Module `msgpack`"
msgstr "Модуль `msgpack`"

#: ../doc/reference/reference_lua/msgpack.rst:11
msgid ""
"The ``msgpack`` module takes strings in MsgPack_ format and decodes them,"
" or takes a series of non-MsgPack values and encodes them. Tarantool "
"makes heavy internal use of MsgPack because tuples in Tarantool are "
":ref:`stored <index-box_lua-vs-msgpack>` as MsgPack arrays."
msgstr ""
"Модуль ``msgpack`` берет строки в формате MsgPack_ и декодирует их или "
"берет ряд значений в ином формате и кодирует их в формат MsgPack. MsgPack"
" интенсивно используется в Tarantool'е, поскольку кортежи :ref:`хранятся "
"<index-box_lua-vs-msgpack>` в виде массивов в формате MsgPack."

#: ../doc/reference/reference_lua/msgpack.rst:20
msgid "Below is a list of all ``msgpack`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``msgpack``."

#: ../doc/reference/reference_lua/msgpack.rst:30
msgid ":ref:`msgpack.encode() <msgpack-encode>`"
msgstr ":ref:`msgpack.encode() <msgpack-encode>`"

#: ../doc/reference/reference_lua/msgpack.rst:30
msgid "Convert a Lua object to an MsgPack string"
msgstr "Конвертация Lua-объекта в MsgPack-строку"

#: ../doc/reference/reference_lua/msgpack.rst:33
msgid ":ref:`msgpack.decode() <msgpack-decode>`"
msgstr ":ref:`msgpack.decode() <msgpack-decode>`"

#: ../doc/reference/reference_lua/msgpack.rst:33
#: ../doc/reference/reference_lua/msgpack.rst:36
msgid "Convert a MsgPack string to a Lua object"
msgstr "Конвертация MsgPack-строки в Lua-объект"

#: ../doc/reference/reference_lua/msgpack.rst:36
msgid ":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>`"
msgstr ":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>`"

#: ../doc/reference/reference_lua/msgpack.rst:39
msgid ":ref:`msgpack.NULL <msgpack-null>`"
msgstr ":ref:`msgpack.NULL <msgpack-null>`"

#: ../doc/reference/reference_lua/msgpack.rst:42
msgid ":ref:`msgpack.decode_array_header <msgpack-decode_array_header>`"
msgstr ":ref:`msgpack.decode_array_header <msgpack-decode_array_header>`"

#: ../doc/reference/reference_lua/msgpack.rst:42
msgid "Skip array header in a MsgPack string"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:45
#, fuzzy
msgid ":ref:`msgpack.decode_map_header <msgpack-decode_map_header>`"
msgstr ":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>`"

#: ../doc/reference/reference_lua/msgpack.rst:45
msgid "Skip map header in a MsgPack string"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:48
msgid ":ref:`msgpack.cfg <msgpack-cfg>`"
msgstr ":ref:`msgpack.cfg <msgpack-cfg>`"

#: ../doc/reference/reference_lua/msgpack.rst:48
msgid "Change configuration"
msgstr "Изменение конфигурации"

#: ../doc/reference/reference_lua/msgpack.rst:58
msgid "Convert a Lua object to a MsgPack string."
msgstr "Конвертация Lua-объекта в MsgPack-строку."

#: ../doc/reference/reference_lua/msgpack.rst:61
msgid "the original value reformatted as a MsgPack string."
msgstr "оригинальное значение, преобразованное в MsgPack-строку."

#: ../doc/reference/reference_lua/msgpack.rst:68
msgid "Convert a MsgPack string to a Lua object."
msgstr "Конвертация MsgPack-строки в Lua-объект."

#: ../doc/reference/reference_lua/msgpack.rst:70
#: ../doc/reference/reference_lua/msgpack.rst:98
msgid "a string formatted as MsgPack."
msgstr "строка в формате MsgPack."

#: ../doc/reference/reference_lua/msgpack.rst:71
msgid "where to start, minimum = 1, maximum = string length, default = 1."
msgstr ""
"откуда начинать, минимальное значение = 1, максимальное = длина строки, "
"по умолчанию = 1."

#: ../doc/reference/reference_lua/msgpack.rst:76
msgid ""
"(if ``msgpack_string`` is in valid MsgPack format) the original contents "
"of ``msgpack_string``, formatted as a Lua table, (otherwise) a scalar "
"value, such as a string or a number;"
msgstr ""
"(если ``msgpack_string`` в правильном MsgPack-формате) содержимое "
"``msgpack_string`` в формате Lua-таблицы, (в противном случае) скалярное "
"значение, строка или число;"

#: ../doc/reference/reference_lua/msgpack.rst:79
msgid ""
"\"next_start_position\". If ``decode`` stops after parsing as far as byte"
" N in ``msgpack_string``, then \"next_start_position\" will equal N + 1, "
"and ``decode(msgpack_string, next_start_position)`` will continue parsing"
" from where the previous ``decode`` stopped, plus 1. Normally ``decode`` "
"parses all of ``msgpack_string``, so \"next_start_position\" will equal "
"``string.len(msgpack_string)`` + 1."
msgstr ""
"\"next_start_position\". Если расшифровка ``decode`` останавливается "
"после разбора байта N в ``msgpack_string``, то \"next_start_position\" = "
"N + 1, а ``decode(msgpack_string, next_start_position)`` продолжит разбор"
" с места остановки предыдущего ``decode`` плюс 1. Как правило, ``decode``"
" разбирает всю строку ``msgpack_string``, поэтому \"next_start_position\""
" будет равняться ``string.len(msgpack_string)`` + 1."

#: ../doc/reference/reference_lua/msgpack.rst:86
msgid "table and number"
msgstr "таблица и число"

#: ../doc/reference/reference_lua/msgpack.rst:92
msgid ""
"Convert a MsgPack string to a Lua object. Because checking is skipped, "
"``decode_unchecked()`` can operate with string pointers to buffers which "
"``decode()`` cannot handle. For an example see the :ref:`buffer <buffer-"
"module>` module."
msgstr ""
"Конвертация MsgPack-строки в Lua-объект. Поскольку проверка не "
"проводится, ``decode_unchecked()`` может работать с указателями строки в "
"буфере в отличие от ``decode()``. Пример см. в модуле :ref:`buffer "
"<buffer-module>`."

#: ../doc/reference/reference_lua/msgpack.rst:102
msgid "the original contents formatted as a Lua table;"
msgstr "оригинальное содержание в формате Lua-таблицы;"

#: ../doc/reference/reference_lua/msgpack.rst:103
msgid "the number of bytes that were decoded."
msgstr "количество декодированных байтов."

#: ../doc/reference/reference_lua/msgpack.rst:105
msgid "lua object"
msgstr "Lua-объект."

#: ../doc/reference/reference_lua/msgpack.rst:118
msgid ""
"Call the mp_decode_array function in the `MsgPuck "
"<http://rtsisyk.github.io/msgpuck/>`_ library and return the array size "
"and a pointer to the first array component. A subsequent call to "
"``msgpack_decode`` can decode the component instead of the whole array."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:122
#: ../doc/reference/reference_lua/msgpack.rst:150
#, fuzzy
msgid "a pointer to a byte array formatted as MsgPack."
msgstr "строка в формате MsgPack."

#: ../doc/reference/reference_lua/msgpack.rst:123
msgid "a number greater than or equal to the string's length"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:127
#, fuzzy
msgid "the size of the array;"
msgstr "позиция последнего символа"

#: ../doc/reference/reference_lua/msgpack.rst:128
msgid "a pointer to after the array header."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:130
msgid ""
"-- Example of decode_array_header\n"
"-- Suppose we have the raw data '\\x93\\x01\\x02\\x03'.\n"
"-- \\x93 is MsgPack encoding for a header of a three-item array.\n"
"-- We want to skip it and decode the next three items.\n"
"msgpack=require('msgpack'); ffi=require('ffi')\n"
"x,y=msgpack.decode_array_header(ffi.cast('char*','\\x93\\x01\\x02\\x03'),4)"
"\n"
"a=msgpack.decode(y,1);b=msgpack.decode(y+1,1);c=msgpack.decode(y+2,1);\n"
"a,b,c\n"
"-- The result will be: 1,2,3."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:146
msgid ""
"Call the mp_decode_map function in the `MsgPuck "
"<http://rtsisyk.github.io/msgpuck/>`_ library and return the map size and"
" a pointer to the first map component. A subsequent call to "
"``msgpack_decode`` can decode the component instead of the whole map."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:151
msgid "a number greater than or equal to the byte array's length"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:155
#, fuzzy
msgid "the size of the map;"
msgstr "копия таблицы"

#: ../doc/reference/reference_lua/msgpack.rst:156
msgid "a pointer to after the map header."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:158
msgid ""
"-- Example of decode_map_header\n"
"-- Suppose we have the raw data '\\x81\\xa2\\x41\\x41\\xc3'.\n"
"-- \\x81 is MsgPack encoding for a header of a one-item map.\n"
"-- We want to skip it and decode the next map item.\n"
"msgpack=require('msgpack'); ffi=require('ffi')\n"
"x,y=msgpack.decode_map_header(ffi.cast('char*','\\x81\\xa2\\x41\\x41\\xc3'),5)"
"\n"
"a=msgpack.decode(y,3);b=msgpack.decode(y+3,1)\n"
"x,a,b\n"
"-- The result will be: 1,\"AA\", true."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:174
msgid ""
"tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""
"tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."

#: ../doc/reference/reference_lua/msgpack.rst:199
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr "Структуру MsgPack-вывода можно указать с помощью ``__serialize``:"

#: ../doc/reference/reference_lua/msgpack.rst:201
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr "``__serialize = \"seq\" или \"sequence\"`` для массива"

#: ../doc/reference/reference_lua/msgpack.rst:202
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr "``__serialize = \"map\" или \"mapping\"`` для ассоциативного массива"

#: ../doc/reference/reference_lua/msgpack.rst:204
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results. To show this, here is a routine which encodes "
"`{'A','B'}` both as an array and as a map, then displays each result in "
"hexadecimal."
msgstr ""
"Сериализация 'A' и' B' различными значениями ``__serialize`` приводит к "
"различным результатам. Чтобы показать различия, ниже приведена процедура "
"кодирования `{'A','B'}` в массив и в ассоциативный массив с выводом "
"каждого результата в виде шестнадцатеричного числа."

#: ../doc/reference/reference_lua/msgpack.rst:208
#, python-format
msgid ""
"function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) "
".. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""
"function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) "
".. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"

#: ../doc/reference/reference_lua/msgpack.rst:228
msgid "**Result:**"
msgstr "**Результат:**"

#: ../doc/reference/reference_lua/msgpack.rst:267
msgid ""
"**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""
"**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"

#: ../doc/reference/reference_lua/msgpack.rst:236
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""
"На странице спецификации MsgPack по ссылке Specification_ объясняется, "
"что значение первого результата кодирования:"

#: ../doc/reference/reference_lua/msgpack.rst:275
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""

#: ../doc/reference/reference_lua/msgpack.rst:243
msgid "and the second encoding means:"
msgstr "а значение второго результата кодирования:"

#: ../doc/reference/reference_lua/msgpack.rst:282
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\""
msgstr "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\""

#: ../doc/reference/reference_lua/msgpack.rst:250
msgid ""
"Here are examples for all the common types, with the Lua-table "
"representation on the left, with the MsgPack format name and encoding on "
"the right."
msgstr ""
"Ниже приведены примеры всех стандартных типов: слева отображение в "
"Lua-таблице, а справа -- имя и кодировка в формате MsgPack."

#: ../doc/reference/reference_lua/msgpack.rst:258
msgid "**Common Types and MsgPack Encodings**"
msgstr "**Стандартные типы в MsgPack-кодировке**"

#: ../doc/reference/reference_lua/msgpack.rst:266
msgid "{}"
msgstr "{}"

#: ../doc/reference/reference_lua/msgpack.rst:266
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""
"'fixmap' = 80, если метатаблица -- ассоциативный массив 'map', в "
"противном случае, 'fixarray' = 90"

#: ../doc/reference/reference_lua/msgpack.rst:269
msgid "'a'"
msgstr "'a'"

#: ../doc/reference/reference_lua/msgpack.rst:269
msgid "'fixstr' = a1 61"
msgstr "'fixstr' = a1 61"

#: ../doc/reference/reference_lua/msgpack.rst:271
msgid "false"
msgstr "false"

#: ../doc/reference/reference_lua/msgpack.rst:271
msgid "'false' = c2"
msgstr "'false' = c2"

#: ../doc/reference/reference_lua/msgpack.rst:273
msgid "true"
msgstr "true"

#: ../doc/reference/reference_lua/msgpack.rst:273
msgid "'true' = c3"
msgstr "'true' = c3"

#: ../doc/reference/reference_lua/msgpack.rst:275
msgid "127"
msgstr "127"

#: ../doc/reference/reference_lua/msgpack.rst:275
msgid "'positive fixint' = 7f"
msgstr "'positive fixint' = 7f"

#: ../doc/reference/reference_lua/msgpack.rst:277
msgid "65535"
msgstr "65535"

#: ../doc/reference/reference_lua/msgpack.rst:277
msgid "'uint 16' = cd ff ff"
msgstr "'uint 16' = cd ff ff"

#: ../doc/reference/reference_lua/msgpack.rst:279
msgid "4294967295"
msgstr "4294967295"

#: ../doc/reference/reference_lua/msgpack.rst:279
msgid "'uint 32' = ce ff ff ff ff"
msgstr "'uint 32' = ce ff ff ff ff"

#: ../doc/reference/reference_lua/msgpack.rst:281
msgid "'nil' = c0"
msgstr "'nil' = c0"

#: ../doc/reference/reference_lua/msgpack.rst:283
msgid "msgpack.NULL"
msgstr "msgpack.NULL"

#: ../doc/reference/reference_lua/msgpack.rst:283
msgid "same as nil"
msgstr "то же, что и nil"

#: ../doc/reference/reference_lua/msgpack.rst:285
msgid "[0] = 5"
msgstr "[0] = 5"

#: ../doc/reference/reference_lua/msgpack.rst:285
msgid ""
"'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for "
"the value) = 81 00 05"
msgstr ""
"'fixmap(1)' + 'positive fixint' (для ключа) + 'positive fixint' (для "
"значения) = 81 00 05"

#: ../doc/reference/reference_lua/msgpack.rst:288
msgid "[0] = nil"
msgstr "[0] = nil"

#: ../doc/reference/reference_lua/msgpack.rst:288
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""
"'fixmap(0)' = 80 -- nil не хранится, если это отсутствующее значение "
"ассоциативного массива"

#: ../doc/reference/reference_lua/msgpack.rst:291
msgid "1.5"
msgstr "1,5"

#: ../doc/reference/reference_lua/msgpack.rst:291
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr "'float 64' = cb 3f f8 00 00 00 00 00 00"

#: ../doc/reference/reference_lua/msgpack.rst:298
msgid ""
"Some MsgPack configuration settings can be changed, in the same way that "
"they can be changed for json. See :ref:`Module JSON <json-module_cfg>` "
"for a list of some configuration settings. (The same configuration "
"settings exist for json, for MsgPack, and for  :ref:`YAML <yaml-"
"module>`.)"
msgstr ""
"Некоторые параметры конфигурации MsgPack для кодировки можно изменить так"
" же, как и для JSON. Список некоторых настроек см. в :ref:`Модуле JSON "
"<json-module_cfg>`. (Такие параметры конфигурации применяются для формата"
" JSON, для :ref:`MsgPack <msgpack-module>` и для :ref:`YAML <yaml-"
"module>`.)"

#: ../doc/reference/reference_lua/msgpack.rst:303
msgid ""
"For example, if ``msgpack.cfg.encode_invalid_numbers = true`` (the "
"default), then nan and inf are legal values. If that is not desirable, "
"then ensure that ``msgpack.encode()`` will not accept them, by saying "
"``msgpack.cfg{encode_invalid_numbers = false}``, thus:"
msgstr ""
"Например, если ``msgpack.cfg.encode_invalid_numbers = true`` (по "
"умолчанию), то допускаются значения nan и inf. Если это нежелательно, "
"следует убедиться, что ``msgpack.encode()`` не примет такие значения, "
"выполнив ``msgpack.cfg{encode_invalid_numbers = false}``. Таким образом:"

#: ../doc/reference/reference_lua/msgpack.rst:308
msgid ""
" tarantool> msgpack = require('msgpack'); "
"msgpack.cfg{encode_invalid_numbers = true}\n"
" ---\n"
" ...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - [1, -nan, inf, false]\n"
" - 22\n"
" ...\n"
" tarantool> msgpack.cfg{encode_invalid_numbers = false}\n"
"---\n"
"...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - error: ... number must not be NaN or Inf'\n"
"..."
msgstr ""
" tarantool> msgpack = require('msgpack'); "
"msgpack.cfg{encode_invalid_numbers = true}\n"
" ---\n"
" ...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - [1, -nan, inf, false]\n"
" - 22\n"
" ...\n"
" tarantool> msgpack.cfg{encode_invalid_numbers = false}\n"
"---\n"
"...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - error: ... number must not be NaN or Inf'\n"
"..."

#: ../doc/reference/reference_lua/net_box.rst:5
msgid "Module `net.box`"
msgstr "Модуль `net.box`"

#: ../doc/reference/reference_lua/net_box.rst:11
msgid ""
"The ``net.box`` module contains connectors to remote database systems. "
"One variant, to be discussed later, is for connecting to MySQL or MariaDB"
" or PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). "
"The other variant, which is discussed in this section, is for connecting "
"to Tarantool server instances via a network."
msgstr ""
"Модуль ``net.box`` включает в себя коннекторы для удаленных систем с "
"базами данных. Одним из вариантов, который рассматривается позднее, "
"является подключение к MySQL, MariaDB или PostgreSQL (см. справочник по "
":ref:`Модулям  СУБД SQL <dbms_modules>`). Другим вариантом, который "
"рассматривается в данном разделе, является подключение к экземплярам "
"Tarantool-сервера по сети."

#: ../doc/reference/reference_lua/net_box.rst:17
msgid "You can call the following methods:"
msgstr "Можно вызвать следующие методы:"

#: ../doc/reference/reference_lua/net_box.rst:19
msgid ""
"``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for"
" examples in this section),"
msgstr ""
"``require('net.box')`` для получения объекта ``net.box`` (который "
"называется ``net_box`` для примеров в данном разделе),"

#: ../doc/reference/reference_lua/net_box.rst:21
msgid ""
"``net_box.connect()`` to connect and get a connection object (named "
"``conn`` for examples in this section),"
msgstr ""
"``net_box.connect()`` для подключения и получения объекта подключения "
"(который называется ``conn`` для примеров в данном разделе),"

#: ../doc/reference/reference_lua/net_box.rst:23
msgid ""
"other ``net.box()`` routines, passing ``conn:``, to execute requests on "
"the remote database system,"
msgstr ""
"другие процедуры ``net.box()``, передающие ``conn:`` для выполнения "
"запросов в удаленной системе базы данных,"

#: ../doc/reference/reference_lua/net_box.rst:25
msgid "``conn:close`` to disconnect."
msgstr "``conn:close`` для отключения."

#: ../doc/reference/reference_lua/net_box.rst:27
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and "
"use the same connection object across multiple concurrent fibers. In fact"
" that is perhaps the best programming practice with Tarantool. When "
"multiple fibers use the same connection, all requests are pipelined "
"through the same network socket, but each fiber gets back a correct "
"response. Reducing the number of active sockets lowers the overhead of "
"system calls and increases the overall server performance. However for "
"some cases a single connection is not enough —- for example, when it is "
"necessary to prioritize requests or to use different authentication IDs."
msgstr ""
"Все методы ``net.box`` безопасны для файберов, то есть можно безопасно "
"обмениваться и использовать один и тот же объект подключения в нескольких"
" файберах одновременно. Фактически так лучше всего работать в "
"Tarantool'е. Когда несколько файберов используют одно соединение, все "
"запросы передаются по одному сетевому сокету, но каждый файбер получает "
"правильный ответ. Уменьшение количества активных сокетов снижает затрату "
"ресурсов на системные вызовы и увеличивает общую производительность "
"сервера. Однако, в некоторых случаях отдельного соединения недостаточно "
"-- например, когда необходимо отдавать приоритет разным запросам или "
"использовать различные идентификаторы при аутентификации."

#: ../doc/reference/reference_lua/net_box.rst:36
msgid ""
"Most ``net.box`` methods allow a final ``{options}`` argument, which can "
"be:"
msgstr ""
"В большинстве методов ``net.box`` можно использовать заключительный "
"аргумент ``{options}``, который может быть:"

#: ../doc/reference/reference_lua/net_box.rst:38
msgid ""
"``{timeout=...}``. For example, a method whose final argument is "
"``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although"
" this does not guarantee that execution will stop on the remote server "
"node."
msgstr ""
"``{timeout=...}``. Например, метод с заключительным аргументом "
"``{timeout=1.5}`` остановится через 1,5 секунды на локальном узле, хотя "
"это не гарантирует, что выполнение остановится на удаленном сервере."

#: ../doc/reference/reference_lua/net_box.rst:41
msgid "``{buffer=...}``. For an example see :ref:`buffer module <buffer-module>`."
msgstr "``{buffer=...}``. Например, см. :ref:`модуль buffer <buffer-module>`."

#: ../doc/reference/reference_lua/net_box.rst:42
msgid ""
"``{is_async=...}``. For example, a method whose final argument is "
"``{is_async=true}`` will not wait for the result of a request. See the "
":ref:`is_async <net_box-is_async>` description."
msgstr ""
"``{is_async=...}``. Например, метод с заключительным аргументом "
"``{is_async=true}`` не будет ждать результата выполнения запроса. См. "
"описание :ref:`is_async <net_box-is_async>`."

#: ../doc/reference/reference_lua/net_box.rst:45
msgid ""
"``{on_push=... on_push_ctx=...}``. For receiving out-of-band messages. "
"See the :ref:`box.session.push <box_session-push>` description."
msgstr ""
"``{on_push=... on_push_ctx=...}``. Для получения внеполосных сообщений. "
"См. описание :ref:`box.session.push <box_session-push>`."

#: ../doc/reference/reference_lua/net_box.rst:48
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""
"На диаграмме ниже представлены возможные состояния и варианты перехода из"
" одного состояния в другое:"

#: ../doc/reference/reference_lua/net_box.rst:56
msgid "On this diagram:"
msgstr "На этой диаграмме:"

#: ../doc/reference/reference_lua/net_box.rst:58
msgid "The state machine starts in the 'initial' state."
msgstr "Работа начинается с начального состояния 'initial'."

#: ../doc/reference/reference_lua/net_box.rst:60
msgid ""
"``net_box.connect()`` method changes the state to 'connecting' and spawns"
" a worker fiber."
msgstr ""
"Выполнение метода ``net_box.connect()`` переводит состояние в "
"'connecting', создается рабочий файбер."

#: ../doc/reference/reference_lua/net_box.rst:62
msgid ""
"If authentication and schema upload are required, it's possible later on "
"to re-enter the 'fetch_schema' state from 'active' if a request fails due"
" to a schema version mismatch error, so schema reload is triggered."
msgstr ""
"Если требуются аутентификация и загрузка схемы, можно позднее повторно "
"войти в состояние загрузки схемы 'fetch_schema' из активного 'active', "
"если запрос не будет выполнен из-за ошибки несовпадения версий схемы, то "
"есть будет вызвана перезагрузка схемы."

#: ../doc/reference/reference_lua/net_box.rst:66
msgid ""
"``conn.close()`` method sets the state to 'closed' and kills the worker. "
"If the transport is already in the 'error' state, ``close()`` does "
"nothing."
msgstr ""
"Метод ``conn.close()`` изменяет состояние на закрытое 'closed' и "
"отключает рабочий процесс. Если транспорт уже находится в состоянии "
"ошибки 'error', ``close()`` не делает ничего."

#: ../doc/reference/reference_lua/net_box.rst:73
msgid "Below is a list of all ``net.box`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``net.box``."

#: ../doc/reference/reference_lua/net_box.rst:83
msgid ""
":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() "
"<net_box-new>`"
msgstr ""
":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() "
"<net_box-new>`"

#: ../doc/reference/reference_lua/net_box.rst:84
msgid "Create a connection"
msgstr "Создание подключения"

#: ../doc/reference/reference_lua/net_box.rst:88
msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ":ref:`conn:ping() <conn-ping>`"

#: ../doc/reference/reference_lua/net_box.rst:88
msgid "Execute a PING command"
msgstr "Выполнение команды проверки состояния PING"

#: ../doc/reference/reference_lua/net_box.rst:91
msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ":ref:`conn:wait_connected() <conn-wait_connected>`"

#: ../doc/reference/reference_lua/net_box.rst:91
msgid "Wait for a connection to be active or closed"
msgstr "Ожидание активности или закрытия подключения"

#: ../doc/reference/reference_lua/net_box.rst:94
msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ":ref:`conn:is_connected() <conn-is_connected>`"

#: ../doc/reference/reference_lua/net_box.rst:94
msgid "Check if a connection is active or closed"
msgstr "Проверка активности или закрытия подключения"

#: ../doc/reference/reference_lua/net_box.rst:97
msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ":ref:`conn:wait_state() <conn-wait_state>`"

#: ../doc/reference/reference_lua/net_box.rst:97
msgid "Wait for a target state"
msgstr "Ожидание нужного состояния"

#: ../doc/reference/reference_lua/net_box.rst:100
msgid ":ref:`conn:close() <conn-close>`"
msgstr ":ref:`conn:close() <conn-close>`"

#: ../doc/reference/reference_lua/net_box.rst:100
msgid "Close a connection"
msgstr "Закрытие подключения"

#: ../doc/reference/reference_lua/net_box.rst:103
msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ":ref:`conn.space.space-name:select{field-value} <conn-select>`"

#: ../doc/reference/reference_lua/net_box.rst:103
msgid "Select one or more tuples"
msgstr "Выбор одного или нескольких кортежей"

#: ../doc/reference/reference_lua/net_box.rst:106
msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ":ref:`conn.space.space-name:get{field-value} <conn-get>`"

#: ../doc/reference/reference_lua/net_box.rst:106
msgid "Select a tuple"
msgstr "Выбор кортежа"

#: ../doc/reference/reference_lua/net_box.rst:109
msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"

#: ../doc/reference/reference_lua/net_box.rst:109
msgid "Insert a tuple"
msgstr "Вставка кортежа"

#: ../doc/reference/reference_lua/net_box.rst:112
msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"

#: ../doc/reference/reference_lua/net_box.rst:112
msgid "Insert or replace a tuple"
msgstr "Вставка или замена кортежа"

#: ../doc/reference/reference_lua/net_box.rst:115
msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ":ref:`conn.space.space-name:update{field-value} <conn-update>`"

#: ../doc/reference/reference_lua/net_box.rst:115
#: ../doc/reference/reference_lua/net_box.rst:118
msgid "Update a tuple"
msgstr "Обновление кортежа"

#: ../doc/reference/reference_lua/net_box.rst:118
msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"

#: ../doc/reference/reference_lua/net_box.rst:121
msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"

#: ../doc/reference/reference_lua/net_box.rst:121
msgid "Delete a tuple"
msgstr "Удаление кортежа"

#: ../doc/reference/reference_lua/net_box.rst:124
msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ":ref:`conn:eval() <net_box-eval>`"

#: ../doc/reference/reference_lua/net_box.rst:124
msgid "Evaluate and execute the expression in a string"
msgstr "Оценка и выполнение выражения в строке"

#: ../doc/reference/reference_lua/net_box.rst:127
msgid ":ref:`conn:call() <net_box-call>`"
msgstr ":ref:`conn:call() <net_box-call>`"

#: ../doc/reference/reference_lua/net_box.rst:127
msgid "Call a stored procedure"
msgstr "Вызов хранимой процедуры"

#: ../doc/reference/reference_lua/net_box.rst:130
msgid ":ref:`conn:timeout() <conn-timeout>`"
msgstr ":ref:`conn:timeout() <conn-timeout>`"

#: ../doc/reference/reference_lua/net_box.rst:130
msgid "Set a timeout"
msgstr "Установка времени ожидания"

#: ../doc/reference/reference_lua/net_box.rst:133
#, fuzzy
msgid ":ref:`net_box.on_connect() <net_box-on_connect>`"
msgstr ":ref:`socket.tcp_connect() <socket-tcp_connect>`"

#: ../doc/reference/reference_lua/net_box.rst:133
#, fuzzy
msgid "Define a connect trigger"
msgstr "Создание подключения"

#: ../doc/reference/reference_lua/net_box.rst:136
#, fuzzy
msgid ":ref:`net_box.on_disconnect() <net_box-on_disconnect>`"
msgstr ":ref:`conn:is_connected() <conn-is_connected>`"

#: ../doc/reference/reference_lua/net_box.rst:136
msgid "Define a disconnect trigger"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:139
#, fuzzy
msgid ":ref:`net_box.on_schema_reload() <net_box-on_schema_reload>`"
msgstr ":ref:`conn:eval() <net_box-eval>`"

#: ../doc/reference/reference_lua/net_box.rst:139
msgid "Define a trigger when schema is modified"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:154
msgid ""
"The names ``connect()`` and ``new()`` are synonyms: ``connect()`` is "
"preferred; ``new()`` is retained for backward compatibility."
msgstr ""
"Имена ``connect()`` и ``new()`` являются синонимами: предпочтительным "
"будет ``connect()``, а ``new()`` обеспечивает поддержку обратной "
"совместимости."

#: ../doc/reference/reference_lua/net_box.rst:157
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It can be re-established automatically after a"
" disconnect (see ``reconnect_after`` option below). The returned ``conn``"
" object supports methods for making remote requests, such as select, "
"update or delete."
msgstr ""
"Создание нового подключения. Подключение устанавливается по требованию во"
" время первого запроса. Можно повторно установить подключение "
"автоматически после отключения (см. ниже опцию ``reconnect_after``). "
"Возвращается объект ``conn``, который поддерживает методы создание "
"удаленных запросов, таких как select, update или delete."

#: ../doc/reference/reference_lua/net_box.rst:163
msgid ""
"For a local Tarantool server, there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`. However, there is an important difference between the "
"embedded connection and a remote one. With the embedded connection, "
"requests which do not modify data do not yield. When using a remote "
"connection, due to :ref:`the implicit rules <atomic-implicit-yields>` any"
" request can yield, and database state may have changed by the time it "
"regains control."
msgstr ""
"Для локального Tarantool-сервера есть заданный объект всегда "
"установленного подключения под названием :samp:`{net_box}.self`. Он "
"создан с целью облегчить полиморфное использование API модуля "
"``net_box``. Таким образом, :samp:`conn = "
"{net_box}.connect('localhost:3301')` можно заменить на :samp:`conn = "
"{net_box}.self`. Однако, есть важно отличие встроенного подключения от "
"удаленного. При встроенном подключении запросы без изменения данных не "
"передают управление. При использовании удаленного подключения любой "
"запрос может передавать управление исходя из :ref:`правил неявной "
"передачи управления <atomic-implicit-yields>`, и состояние базы данных "
"может измениться к тому времени, как управление вернется."

#: ../doc/reference/reference_lua/net_box.rst:175
msgid "Possible options:"
msgstr "Возможные опции:"

#: ../doc/reference/reference_lua/net_box.rst:177
msgid ""
"`wait_connected`: by default, connection creation is blocked until the "
"connection is established, but passing ``wait_connected=false`` makes it "
"return immediately. Also, passing a timeout makes it wait before "
"returning (e.g. ``wait_connected=1.5`` makes it wait at most 1.5 "
"seconds)."
msgstr ""
"`wait_connected`: по умолчанию, создание подключения блокируется до тех "
"пор, пока подключение не будет установлено, но передача "
"``wait_connected=false`` заставит метод сразу же вернуться. Передача "
"времени ожидания заставит метод ждать до возвращения (например, "
"``wait_connected=1.5`` заставит ожидать подключения максимум 1,5 "
"секунды)."

#: ../doc/reference/reference_lua/net_box.rst:183
msgid ""
"In the presence of ``reconnect_after``, ``wait_connected`` ignores "
"transient failures. The wait completes once the connection is established"
" or is closed explicitly."
msgstr ""
"Если присутствует ``reconnect_after``, ``wait_connected`` проигнорирует "
"неустойчивые отказы. Ожидание заканчивается, когда подключение "
"установлено или явным образом закрыто."

#: ../doc/reference/reference_lua/net_box.rst:186
msgid ""
"`reconnect_after`: a ``net.box`` instance automatically reconnects any "
"time the connection is broken or if a connection attempt fails. This "
"makes transient network failures become transparent to the application. "
"Reconnect happens automatically in the background, so queries/requests "
"that suffered due to connectivity loss are transparently retried. The "
"number of retries is unlimited, connection attempts are done over the "
"specified timeout (e.g. ``reconnect_after=5`` for 5 secs). Once a "
"connection is explicitly closed, or once the Lua garbage collector "
"removes it, reconnects stop."
msgstr ""
"`reconnect_after`: ``net.box`` автоматически подключается повторно в "
"случае разрыва соединения или провала попытки подключения. В таком случае"
" неустойчивые сетевые отказы становятся очевидными. Повторное подключение"
" выполняется автоматически в фоновом режиме, поэтому запросы/обращения, "
"не выполненные по причине потери соединения, явным образом выполняются "
"повторно. Количество повторов не ограничено, попытки подключения "
"выполняются в течение указанного времени ожидания (например, "
"``reconnect_after=5`` -- 5 секунд). После явного закрытия подключения или"
" удаления сборщиком мусора в Lua попытки соединения повторно не "
"выполняются."

#: ../doc/reference/reference_lua/net_box.rst:196
msgid ""
"`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with "
"a new binary protocol command for CALL, which is not backward compatible "
"with previous versions. The new CALL no longer restricts a function to "
"returning an array of tuples and allows returning an arbitrary "
"MsgPack/JSON result, including scalars, nil and void (nothing). The old "
"CALL is left intact for backward compatibility. It will be removed in the"
" next major release. All programming language drivers will be gradually "
"changed to use the new CALL. To connect to a Tarantool instance that uses"
" the old CALL, specify ``call_16=true``."
msgstr ""
"`call_16`: [с 1.7.2] по умолчанию, подключения ``net.box`` соответствуют "
"команде CALL нового бинарного протокола, который не поддерживает обратную"
" совместимость с предыдущими версиями. Команда нового бинарного протокола"
" для вызова CALL больше не ограничивает функцию в возврате массива "
"кортежей и позволяет возвращать произвольный результат в формате "
"MsgPack/JSON, включая scalar (скалярные значения), nil (нулевые значения)"
" и void (пусто). Старый метод CALL оставлен нетронутым для обратной "
"совместимости. В следующей основной версии он будет удален. Все драйверы "
"для языков программирования будут постепенно переведены на использование "
"нового метода CALL. Для подключения к экземпляру Tarantool'а, в котором "
"используется старый метод CALL, укажите ``call_16=true``."

#: ../doc/reference/reference_lua/net_box.rst:205
msgid ""
"`console`: depending on the option's value, the connection supports "
"different methods (as if instances of different classes were returned). "
"With ``console = true``, you can use ``conn`` methods ``close()``, "
"``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both "
"binary and Lua console network protocols are supported). With ``console ="
" false`` (default), you can also use ``conn`` database methods (in this "
"case, only the binary protocol is supported). Deprecation notice: "
"``console = true`` is deprecated, users should use "
":ref:`console.connect() <console-connect>` instead."
msgstr ""
"`console`: в зависимости от значения параметра поддерживаются различные "
"методы (как если бы возвращались экземпляры разных классов). Если "
"``console = true``, можно использовать методы ``conn``: ``close()``, "
"``is_connected()``, ``wait_state()``, ``eval()`` (в этом случае "
"поддерживаются и бинарный сетевой протокол, и протокол Lua-консоли). Если"
" ``console = false`` (по умолчанию), также можно использовать методы "
"``conn`` для работы с базой данных (в этом случае поддерживается только "
"бинарный протокол). Устарел: ``console = true`` объявлен устаревшим, "
"вместо него следует использовать :ref:`console.connect() <console-"
"connect>`."

#: ../doc/reference/reference_lua/net_box.rst:213
msgid ""
"`connect_timeout`: number of seconds to wait before returning \"error: "
"Connection timed out\"."
msgstr ""
"`connect_timeout`: количество секунд ожидания до возврата ошибки \"error:"
" Connection timed out\"."

#: ../doc/reference/reference_lua/net_box.rst:215
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ":ref:`URI <index-uri>` объекта подключения"

#: ../doc/reference/reference_lua/net_box.rst:216
msgid ""
"possible options are `wait_connected`, `reconnect_after`, `call_16` and "
"`console`"
msgstr ""
"возможные опции: `wait_connected`, `reconnect_after`, `call_16` и "
"`console`"

#: ../doc/reference/reference_lua/net_box.rst:217
msgid "conn object"
msgstr "объект подключения"

#: ../doc/reference/reference_lua/net_box.rst:220
#: ../doc/reference/reference_lua/net_box.rst:288
#: ../doc/reference/reference_lua/net_box.rst:425
#: ../doc/reference/reference_lua/net_box.rst:459
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:324
msgid "**Examples:**"
msgstr "**Примеры:**"

#: ../doc/reference/reference_lua/net_box.rst:222
msgid ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = "
"true})"
msgstr ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = "
"true})"

#: ../doc/reference/reference_lua/net_box.rst:234
msgid "Execute a PING command."
msgstr "Выполнение команды проверки состояния PING."

#: ../doc/reference/reference_lua/net_box.rst:236
msgid "the supported option is :samp:`timeout={seconds}`"
msgstr "поддерживается опция :samp:`timeout={секунды}`"

#: ../doc/reference/reference_lua/net_box.rst:237
msgid "true on success, false on error"
msgstr "true (правда), если выполнено, false (ложь) в случае ошибки"

#: ../doc/reference/reference_lua/net_box.rst:242
msgid "net_box.self:ping({timeout = 0.5})"
msgstr "net_box.self:ping({timeout = 0.5})"

#: ../doc/reference/reference_lua/net_box.rst:250
msgid "Wait for connection to be active or closed."
msgstr "Ожидание активности или закрытия подключения."

#: ../doc/reference/reference_lua/net_box.rst:252
#: ../doc/reference/reference_lua/net_box.rst:284
msgid "in seconds"
msgstr "в секундах"

#: ../doc/reference/reference_lua/net_box.rst:253
msgid "true when connected, false on failure."
msgstr "true (правда) при подключении, false (ложь), если не выполнено."

#: ../doc/reference/reference_lua/net_box.rst:258
msgid "net_box.self:wait_connected()"
msgstr "net_box.self:wait_connected()"

#: ../doc/reference/reference_lua/net_box.rst:266
msgid "Show whether connection is active or closed."
msgstr "Проверка активности или закрытия подключения."

#: ../doc/reference/reference_lua/net_box.rst:268
msgid "true if connected, false on failure."
msgstr "true (правда) при подключении, false (ложь), если не выполнено."

#: ../doc/reference/reference_lua/net_box.rst:273
msgid "net_box.self:is_connected()"
msgstr "net_box.self:is_connected()"

#: ../doc/reference/reference_lua/net_box.rst:281
msgid "[since 1.7.2] Wait for a target state."
msgstr "[с 1.7.2] Ожидание нужного состояния."

#: ../doc/reference/reference_lua/net_box.rst:283
msgid "target states"
msgstr "необходимое состояние"

#: ../doc/reference/reference_lua/net_box.rst:285
msgid ""
"true when a target state is reached, false on timeout or connection "
"closure"
msgstr ""
"true (правда) при подключении, false (ложь) при окончании времени "
"ожидания или закрытии подключения"

#: ../doc/reference/reference_lua/net_box.rst:290
msgid ""
"-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""
"-- бесконечное ожидание состояния 'active':\n"
"conn:wait_state('active')\n"
"\n"
"-- ожидание в течение максимум 1,5 секунд:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- бесконечное ожидание состояния `active` или `fetch_schema`:\n"
"conn:wait_state({active=true, fetch_schema=true})"

#: ../doc/reference/reference_lua/net_box.rst:305
msgid "Close a connection."
msgstr "Закрытие подключения."

#: ../doc/reference/reference_lua/net_box.rst:307
msgid ""
"Connection objects are destroyed by the Lua garbage collector, just like "
"any other objects in Lua, so an explicit destruction is not mandatory. "
"However, since close() is a system call, it is good programming practice "
"to close a connection explicitly when it is no longer needed, to avoid "
"lengthy stalls of the garbage collector."
msgstr ""
"Объекты подключения удаляются сборщиком мусора в Lua, как и любой другой "
"Lua-объект, поэтому удалять их явным образом необязательно. Однако, "
"поскольку close() представляет собой системный вызов, лучше всего закрыть"
" соединение явным образом, когда оно больше не используется, с целью "
"ускорения работы сборщика мусора."

#: ../doc/reference/reference_lua/net_box.rst:314
msgid "conn:close()"
msgstr "conn:close()"

#: ../doc/reference/reference_lua/net_box.rst:322
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-"
"name}:select`:code:`{...}`. For an additional option see :ref:`Module "
"buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:select`:code:`({...})` -- это удаленный "
"вызов, аналогичный локальному вызову "
":samp:`box.space.{имя-спейса}:select`:code:`{...}`."

#: ../doc/reference/reference_lua/net_box.rst:328
msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr "conn.space.testspace:select({1,'B'}, {timeout=1})"

#: ../doc/reference/reference_lua/net_box.rst:334
msgid ""
"Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local "
":samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does "
"yield, so global variables or database tuples data may change when a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""
"Исходя из :ref:`правил неявной передачи управления <atomic-implicit-"
"yields>`, локальный запрос "
":samp:`box.space.{имя-спейса}:select`:code:`{...}` не передает "
"управление, а удаленный "
":samp:`conn.space.{имя-спейса}:select`:code:`{...}` передаст, поэтому "
"глобальные переменные или кортежи в базе данных могут измениться во время"
" удаленного :samp:`conn.space.{имя-спейса}:select`:code:`{...}`."

#: ../doc/reference/reference_lua/net_box.rst:345
msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""
":samp:`conn.space.{имя-спейса}:get(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:get(...)`."

#: ../doc/reference/reference_lua/net_box.rst:350
msgid "conn.space.testspace:get({1})"
msgstr "conn.space.testspace:get({1})"

#: ../doc/reference/reference_lua/net_box.rst:358
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:insert(...)`. For an "
"additional option see :ref:`Module buffer and skip-header <buffer-"
"module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:insert(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:insert(...)`."

#: ../doc/reference/reference_lua/net_box.rst:364
msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"

#: ../doc/reference/reference_lua/net_box.rst:372
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-name}:replace(...)`."
" For an additional option see :ref:`Module buffer and skip-header "
"<buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:replace(...)` -- это удаленный вызов, "
"аналогичный локальному вызову "
":samp:`box.space.{имя-спейса}:replace(...)`."

#: ../doc/reference/reference_lua/net_box.rst:378
msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr "conn.space.testspace:replace({5,6,7,8})"

#: ../doc/reference/reference_lua/net_box.rst:386
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:update(...)`. For an "
"additional option see :ref:`Module buffer and skip-header <buffer-"
"module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:update(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:update(...)`."

#: ../doc/reference/reference_lua/net_box.rst:392
msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"

#: ../doc/reference/reference_lua/net_box.rst:400
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:upsert(...)`. For an "
"additional option see :ref:`Module buffer and skip-header <buffer-"
"module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:upsert(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:upsert(...)`."

#: ../doc/reference/reference_lua/net_box.rst:408
#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:delete(...)`. For an "
"additional option see :ref:`Module buffer and skip-header <buffer-"
"module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:delete(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:delete(...)`."

#: ../doc/reference/reference_lua/net_box.rst:416
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in "
"Lua-string, which may be any statement or series of statements. An "
":ref:`execute privilege <authentication-owners_privileges>` is required; "
"if the user does not have it, an administrator may grant it with "
":samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""
":samp:`conn:eval({Lua-строка})` оценивает и выполняет выражение в "
"Lua-строке, которое может представлять собой любое выражение или "
"несколько выражений. Требуются :ref:`права на выполнение <authentication-"
"owners_privileges>`; если у пользователя таких прав нет, администратор "
"может их выдать с помощью "
":samp:`box.schema.user.grant({имя-пользователя}, 'execute', 'universe')`."

#: ../doc/reference/reference_lua/net_box.rst:422
msgid ""
"To ensure that the return from ``conn:eval`` is whatever the Lua "
"expression returns, begin the Lua-string with the word \"return\"."
msgstr ""
"Чтобы гарантировать, что ``conn:eval`` вернет то, что возвращает "
"выражение на Lua, начните Lua-строку со слова \"return\" (вернуть)."

#: ../doc/reference/reference_lua/net_box.rst:427
msgid ""
"tarantool> --Lua-string\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-string, {arguments}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-string, {arguments}, {options}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."
msgstr ""
"tarantool> --Lua-строка\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-строка, {аргументы}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-строка, {аргументы}, {парметры}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."

#: ../doc/reference/reference_lua/net_box.rst:451
msgid ""
"``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of "
"``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-"
"procedure call. The return from ``conn:call`` is whatever the function "
"returns."
msgstr ""
"``conn:call('func', {'1', '2', '3'})`` -- это удаленный вызов, "
"аналогичный ``func('1', '2', '3')``. Таким образом, ``conn:call`` "
"представляет собой удаленный вызов хранимой процедуры. ``conn:call`` "
"возвращает то, что возвращает функция."

#: ../doc/reference/reference_lua/net_box.rst:455
msgid ""
"Limitation: the called function cannot return a function, for example if "
"``func2`` is defined as ``function func2 () return func end`` then "
"``conn:call(func2)`` will return \"error: unsupported Lua type "
"'function'\"."
msgstr ""
"Ограничение: вызванная функция не может вернуть функцию, например, если "
"``func2`` определяется как ``function func2 () return func end``, то "
"``conn:call(func2)`` вернет ошибку \"error: unsupported Lua type "
"'function'\"."

#: ../doc/reference/reference_lua/net_box.rst:461
msgid ""
"tarantool> -- create 2 functions with conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- call first function with no parameters and no options\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- call second function with two parameters and one option\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."
msgstr ""
"tarantool> -- создание 2 функций с conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- вызов первой функции без параметров и опций\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- вызов второй функции с двумя параметрами и одной опцией\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."

#: ../doc/reference/reference_lua/net_box.rst:484
msgid ""
"``timeout(...)`` is a wrapper which sets a timeout for the request that "
"follows it. Since version 1.7.4 this method is deprecated -- it is better"
" to pass a timeout value for a method's ``{options}`` parameter."
msgstr ""
"``timeout(...)`` -- это надстройка, которая определяет время ожидания для"
" запроса. С версии 1.7.4 этот метод объявлен устаревшим -- лучше передать"
" значение времени ожидания с помощью параметра ``{options}``."

#: ../doc/reference/reference_lua/net_box.rst:490
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"

#: ../doc/reference/reference_lua/net_box.rst:494
msgid ""
"Although ``timeout(...)`` is deprecated, all remote calls support its "
"use. Using a wrapper object makes the remote connection API compatible "
"with the local one, removing the need for a separate ``timeout`` "
"argument, which the local version would ignore. Once a request is sent, "
"it cannot be revoked from the remote server even if a timeout expires: "
"the timeout expiration only aborts the wait for the remote server "
"response, not the request itself."
msgstr ""
"Хотя ``timeout(...)`` объявлен устаревшим, все удаленные вызовы "
"поддерживают его. Использование надстройки обеспечивает совместимость API"
" удаленного соединения с локальным, поэтому отпадает необходимость в "
"отдельном аргументе ``timeout``, который проигнорирует локальная версия. "
"После отправки запроса его нельзя отменить с удаленного сервера даже по "
"истечении времени задержки: окончание времени задержки прерывает только "
"ожидание ответа от удаленного сервера, а не сам запрос."

#: ../doc/reference/reference_lua/net_box.rst:506
msgid ""
"``{is_async=true|false}`` is an option which is applicable for all "
"``net_box`` requests including ``conn:call``, ``conn:eval``, and the "
"``conn.space.space-name`` requests."
msgstr ""
"``{is_async=true|false}`` -- это опция, которую можно применить во всех "
"запросах ``net_box``, включая ``conn:call``, ``conn:eval`` и запросы "
"``conn.space.space-name``."

#: ../doc/reference/reference_lua/net_box.rst:510
msgid ""
"The default is ``is_async=false``, meaning requests are synchronous for "
"the fiber. The fiber is blocked, waiting until there is a reply to the "
"request or until timeout expires. Before Tarantool version 1.10, the only"
" way to make asynchronous requests was to put them in separate fibers."
msgstr ""
"По умолчанию, ``is_async=false``, что означает, что запросы будут "
"синхронными для файбера. Файбер блокируется в ожидании ответа на запрос "
"или до истечения времени ожидания. До версии Tarantool'а 1.10 "
"единственным способом выполнения асинхронных запросов было использование "
"отдельных файберов."

#: ../doc/reference/reference_lua/net_box.rst:516
msgid ""
"The non-default is ``is_async=true``, meaning requests are asynchronous "
"for the fiber. The request causes a yield but there is no waiting. The "
"immediate return is not the result of the request, instead it is an "
"object that the calling program can use later to get the result of the "
"request."
msgstr ""
"``is_async=true`` означает, что запросы будут асинхронными для файбера. "
"Запрос вызывает передачу управления, но файбер не входит в режим "
"ожидания. Сразу же возвращается результат, но это будет не результат "
"запроса, а объект, который может использовать вызывающая программа для "
"получения результат запроса."

#: ../doc/reference/reference_lua/net_box.rst:522
msgid ""
"This immediately-returned object, which we'll call \"future\", has its "
"own methods:"
msgstr ""
"У такого сразу же возвращаемого объекта, который мы называем \"future\" "
"(будущий), есть собственные методы:"

#: ../doc/reference/reference_lua/net_box.rst:525
msgid ""
"``future:is_ready()`` which will return true when the result of the "
"request is available,"
msgstr ""
"``future:is_ready()`` вернет true (правда), если доступен результат "
"запроса,"

#: ../doc/reference/reference_lua/net_box.rst:527
msgid ""
"``future:result()`` to get the result of the request (returns the "
"response or **nil** in case it's not ready yet or there has been an "
"error),"
msgstr ""
"``future:result()`` используется для получения результата запроса "
"(возвращает ответ на запрос или **nil** в случае, если ответ еще не готов"
" или произошла какая-либо ошибка),"

#: ../doc/reference/reference_lua/net_box.rst:529
msgid ""
"``future:wait_result(timeout)`` to wait until the result of the request "
"is available and then get it,"
msgstr ""
"``future:wait_result(timeout)`` будет ждать, когда результат запроса "
"будет доступен, а затем получит его."

#: ../doc/reference/reference_lua/net_box.rst:531
msgid "``future:discard()`` to abandon the object."
msgstr "``future:discard()`` откажется от объекта."

#: ../doc/reference/reference_lua/net_box.rst:533
msgid ""
"Typically a user would say ``future=request-name(...{is_async=true})``, "
"then either loop checking ``future:is_ready()`` until it is true and then"
" say ``request_result=future:result()``, or say "
"``request_result=future:wait_result(...)``. Alternatively the client "
"could check for \"out-of-band\" messages from the server by calling "
"``pairs()`` in a loop -- see :ref:`box.session.push() <box_session-"
"push>`."
msgstr ""
"В обычной ситуации пользователь введет команду "
"``future=имя-запроса(...{is_async=true})``, а затем либо цикл с проверкой"
" ``future:is_ready()`` до тех пор, пока он не вернет true, и получением "
"результата с помощью  ``request_result=future:result()``, либо же команду"
" ``request_result=future:wait_result(...)``. Возможен вариант, когда "
"клиент проверяет наличие внеполосных сообщений от сервера, вызывая в "
"цикле ``pairs()`` -- см. :ref:`box.session.push() <box_session-push>`."

#: ../doc/reference/reference_lua/net_box.rst:542
msgid ""
"tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."
msgstr ""
"tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."

#: ../doc/reference/reference_lua/net_box.rst:564
msgid ""
"Typically ``{is_async=true}`` is used only if the load is large (more "
"than 100,000 requests per second) and latency is large (more than 1 "
"second), or when it is necessary to send multiple requests in parallel "
"then collect responses (sometimes called a \"map-reduce\" scenario)."
msgstr ""
"Как правило, ``{is_async=true}`` используется только при большой загрузке"
" (более 100 000 запросов в секунду) и большой задержке чтения (более 1 "
"секунды), или же при необходимости отправки нескольких одновременных "
"запросов, которые собирают ответы (что иногда называется "
"\"отображение-свертка\")."

#: ../doc/reference/reference_lua/net_box.rst:572
msgid ""
"Although the final result of an async request is the same as the result "
"of a sync request, it is structured differently: as a table, instead of "
"as the unpacked values."
msgstr ""
"Хотя окончательный результат асинхронного запроса не отличается от "
"результата синхронного запроса, у него другая структура: таблица, а не "
"неупакованные значения."

#: ../doc/reference/reference_lua/net_box.rst:580
msgid "Triggers"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:582
msgid ""
"With the ``net.box`` module, you can use the following :ref:`triggers "
"<triggers-box_triggers>`:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:589
msgid ""
"Define a trigger for execution when a new connection is created due to an"
" event such as ``net_box.connect``. The trigger function will be the "
"first thing executed after a new connection is created. If the trigger "
"execution fails and raises an error, the error is sent to the client and "
"the connection is closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:594
#: ../doc/reference/reference_lua/net_box.rst:607
#: ../doc/reference/reference_lua/net_box.rst:619
msgid "function which will become the trigger function"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:595
#: ../doc/reference/reference_lua/net_box.rst:608
#: ../doc/reference/reference_lua/net_box.rst:620
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:596
#: ../doc/reference/reference_lua/net_box.rst:609
#: ../doc/reference/reference_lua/net_box.rst:621
#, fuzzy
msgid "nil or function pointer"
msgstr "функция или ссылка на функцию"

#: ../doc/reference/reference_lua/net_box.rst:602
msgid ""
"Define a trigger for execution after a connection is closed. If the "
"trigger function causes an error, the error is logged but otherwise is "
"ignored. Execution stops after a connection is explicitly closed, or once"
" the Lua garbage collector removes it."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:615
msgid ""
"Define a trigger executed when some operation has been performed on the "
"remote server after schema has been updated. So, if a server request "
"fails due to a schema version mismatch error, schema reload is triggered."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:625
msgid ""
"If the parameters are ``(nil, old-trigger-function)``, then the old "
"trigger is deleted."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:628
msgid ""
"If both parameters are omitted, then the response is a list of existing "
"trigger functions."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:631
msgid ""
"Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:638
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr "Ниже приводится пример использования большинства методов ``net.box``."

#: ../doc/reference/reference_lua/net_box.rst:640
msgid "The sandbox configuration for this example assumes that:"
msgstr "Данный пример сработает на конфигурации из песочницы, предполагается, что:"

#: ../doc/reference/reference_lua/net_box.rst:642
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr "экземпляр Tarantool'а запущен на ``localhost 127.0.0.1:3301``,"

#: ../doc/reference/reference_lua/net_box.rst:643
msgid ""
"there is a space named ``tester`` with a numeric primary key and with a "
"tuple that contains a key value = 800,"
msgstr ""
"создан спейс под названием ``tester`` с первичным числовым ключом и "
"кортежем, в котором есть ключ со значением= 800,"

#: ../doc/reference/reference_lua/net_box.rst:645
msgid "the current user has read, write and execute privileges."
msgstr "у текущего пользователя есть права на чтение, запись и выполнение."

#: ../doc/reference/reference_lua/net_box.rst:647
msgid "Here are commands for a quick sandbox setup:"
msgstr "Ниже приведены команды для быстрой настройки песочницы:"

#: ../doc/reference/reference_lua/net_box.rst:649
msgid ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"

#: ../doc/reference/reference_lua/net_box.rst:657
msgid "And here starts the example:"
msgstr "А здесь приведен пример:"

#: ../doc/reference/reference_lua/net_box.rst:659
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:5
msgid "Module `os`"
msgstr "Модуль `os`"

#: ../doc/reference/reference_lua/osmodule.rst:13
msgid ""
"The ``os`` module contains the functions :ref:`execute() <os-execute>`, "
":ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() "
"<os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, "
":ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-"
"tmpname>`, :ref:`environ() <os-environ>`, :ref:`setenv() <os-setenv>`, "
":ref:`setlocale() <os-setlocale>`, :ref:`difftime() <os-difftime>`. Most "
"of these functions are described in the Lua manual Chapter 22 `The "
"Operating System Library <https://www.lua.org/pil/contents.html#22>`_."
msgstr ""
"Модуль ``os`` включает в себя следующие функции: :ref:`execute() <os-"
"execute>`, :ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, "
":ref:`remove() <os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-"
"exit>`, :ref:`time() <os-time>`, :ref:`clock() <os-clock>`, "
":ref:`tmpname() <os-tmpname>`, :ref:`environ() <os-environ>`, "
":ref:`setenv() <os-setenv>`, :ref:`setlocale() <os-setlocale>`, "
":ref:`difftime() <os-difftime>`. Большинство этих функций описаны в Главе"
" 22 руководства по языку Lua `Библиотека функций операционной системы "
"<https://www.lua.org/pil/contents.html#22>`_."

#: ../doc/reference/reference_lua/osmodule.rst:30
msgid "Below is a list of all ``os`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``os``."

#: ../doc/reference/reference_lua/osmodule.rst:40
msgid ":ref:`os.execute() <os-execute>`"
msgstr ":ref:`os.execute() <os-execute>`"

#: ../doc/reference/reference_lua/osmodule.rst:40
msgid "Execute by passing to the shell"
msgstr "Выполнение путем передачи в ОС"

#: ../doc/reference/reference_lua/osmodule.rst:43
msgid ":ref:`os.rename() <os-rename>`"
msgstr ":ref:`os.rename() <os-rename>`"

#: ../doc/reference/reference_lua/osmodule.rst:46
msgid ":ref:`os.getenv() <os-getenv>`"
msgstr ":ref:`os.getenv() <os-getenv>`"

#: ../doc/reference/reference_lua/osmodule.rst:46
msgid "Get an environment variable"
msgstr "Получение переменной окружения"

#: ../doc/reference/reference_lua/osmodule.rst:49
msgid ":ref:`os.remove() <os-remove>`"
msgstr ":ref:`os.remove() <os-remove>`"

#: ../doc/reference/reference_lua/osmodule.rst:49
msgid "Remove a file or directory"
msgstr "Удаление файла или директории"

#: ../doc/reference/reference_lua/osmodule.rst:52
msgid ":ref:`os.date() <os-date>`"
msgstr ":ref:`os.date() <os-date>`"

#: ../doc/reference/reference_lua/osmodule.rst:52
msgid "Get a formatted date"
msgstr "Получение даты в формате"

#: ../doc/reference/reference_lua/osmodule.rst:55
msgid ":ref:`os.exit() <os-exit>`"
msgstr ":ref:`os.exit() <os-exit>`"

#: ../doc/reference/reference_lua/osmodule.rst:55
msgid "Exit the program"
msgstr "Выход из программы"

#: ../doc/reference/reference_lua/osmodule.rst:58
msgid ":ref:`os.time() <os-time>`"
msgstr ":ref:`os.time() <os-time>`"

#: ../doc/reference/reference_lua/osmodule.rst:58
msgid "Get the number of seconds since the epoch"
msgstr "Получение числа секунд с начала отсчета"

#: ../doc/reference/reference_lua/osmodule.rst:61
msgid ":ref:`os.clock() <os-clock>`"
msgstr ":ref:`os.clock() <os-clock>`"

#: ../doc/reference/reference_lua/osmodule.rst:61
msgid "Get the number of CPU seconds since the program start"
msgstr "Получение числа времени ЦП в секундах с момента начала программы"

#: ../doc/reference/reference_lua/osmodule.rst:64
msgid ":ref:`os.tmpname() <os-tmpname>`"
msgstr ":ref:`os.tmpname() <os-tmpname>`"

#: ../doc/reference/reference_lua/osmodule.rst:64
msgid "Get the name of a temporary file"
msgstr "Получение имени временного файла"

#: ../doc/reference/reference_lua/osmodule.rst:67
msgid ":ref:`os.environ() <os-environ>`"
msgstr ":ref:`os.environ() <os-environ>`"

#: ../doc/reference/reference_lua/osmodule.rst:67
msgid "Get a table with all environment variables"
msgstr "Получение таблицы со всеми переменными окружения"

#: ../doc/reference/reference_lua/osmodule.rst:70
msgid ":ref:`os.setenv() <os-setenv>`"
msgstr ":ref:`os.setenv() <os-setenv>`"

#: ../doc/reference/reference_lua/osmodule.rst:70
msgid "Set an environment variable"
msgstr "Определение переменной окружения"

#: ../doc/reference/reference_lua/osmodule.rst:73
msgid ":ref:`os.setlocale() <os-setlocale>`"
msgstr ":ref:`os.setlocale() <os-setlocale>`"

#: ../doc/reference/reference_lua/osmodule.rst:73
msgid "Change the locale"
msgstr "Изменение локали"

#: ../doc/reference/reference_lua/osmodule.rst:76
msgid ":ref:`os.difftime() <os-difftime>`"
msgstr ":ref:`os.difftime() <os-difftime>`"

#: ../doc/reference/reference_lua/osmodule.rst:76
msgid "Get the number of seconds between two times"
msgstr "Получение числа секунд между двумя значениями времени"

#: ../doc/reference/reference_lua/osmodule.rst:84
msgid "Execute by passing to the shell."
msgstr "Выполнение путем передачи в ОС."

#: ../doc/reference/reference_lua/osmodule.rst:86
msgid "what to execute."
msgstr "что выполнить."

#: ../doc/reference/reference_lua/osmodule.rst:90
msgid ""
"tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""
"tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:106
msgid "Rename a file or directory."
msgstr "Переименование файла или директории."

#: ../doc/reference/reference_lua/osmodule.rst:108
msgid "name of existing file or directory,"
msgstr "имя существующего файла или директории,"

#: ../doc/reference/reference_lua/osmodule.rst:109
msgid "changed name of file or directory."
msgstr "измененное имя файла или директории."

#: ../doc/reference/reference_lua/osmodule.rst:113
msgid ""
"tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""
"tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:126
msgid "Get environment variable."
msgstr "Получение переменной окружения."

#: ../doc/reference/reference_lua/osmodule.rst:128
msgid "Parameters: (string) variable-name = environment variable name."
msgstr "Параметры: (string) variable-name = имя переменной окружения."

#: ../doc/reference/reference_lua/osmodule.rst:132
msgid ""
"tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""
"tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:143
msgid "Remove file or directory."
msgstr "Удаление файла или директории."

#: ../doc/reference/reference_lua/osmodule.rst:145
msgid ""
"Parameters: (string) name = name of file or directory which will be "
"removed."
msgstr ""
"Parameters: (string) name = имя файла или директории, которые будут "
"удалены."

#: ../doc/reference/reference_lua/osmodule.rst:149
msgid ""
"tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:160
msgid "Return a formatted date."
msgstr "Возврат даты в формате."

#: ../doc/reference/reference_lua/osmodule.rst:162
msgid ""
"Parameters: (string) format-string = instructions; (string) time-since-"
"epoch = number of seconds since 1970-01-01. If time-since-epoch is "
"omitted, it is assumed to be the current time."
msgstr ""
"Parameters: (string) format-string = инструкции; (string) time-since-"
"epoch = число секунд с 1970-01-01. Если не указать time-since-epoch, "
"предполагается использование текущего времени."

#: ../doc/reference/reference_lua/osmodule.rst:167
#, python-format
msgid ""
"tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""
"tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:178
msgid ""
"Exit the program. If this is done on a server instance, then the instance"
" stops."
msgstr ""
"Выход из программы. Если выполняется на экземпляре сервера, "
"останавливается работа экземпляра."

#: ../doc/reference/reference_lua/osmodule.rst:182
msgid ""
"tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""
"tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"

#: ../doc/reference/reference_lua/osmodule.rst:191
msgid "Return the number of seconds since the epoch."
msgstr "Возврат числа секунд с начала отсчета."

#: ../doc/reference/reference_lua/osmodule.rst:195
msgid ""
"tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""
"tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:206
msgid "Return the number of CPU seconds since the program start."
msgstr "Возврат числа времени ЦП в секундах с момента начала программы."

#: ../doc/reference/reference_lua/osmodule.rst:210
msgid ""
"tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""
"tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:221
msgid "Return a name for a temporary file."
msgstr "Возврат имени временного файла."

#: ../doc/reference/reference_lua/osmodule.rst:225
msgid ""
"tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""
"tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:236
msgid "Return a table containing all environment variables."
msgstr "Возврат таблицы со всеми переменными окружения."

#: ../doc/reference/reference_lua/osmodule.rst:240
msgid ""
"tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."
msgstr ""
"tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:251
msgid "Set an environment variable."
msgstr "Определение переменной окружения."

#: ../doc/reference/reference_lua/osmodule.rst:255
msgid ""
"tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."
msgstr ""
"tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:266
msgid ""
"Change the locale. If new-locale-string is not specified, return the "
"current locale."
msgstr ""
"Изменение локали. Если не указать new-locale-string, вернется текущая "
"локаль."

#: ../doc/reference/reference_lua/osmodule.rst:271
msgid ""
"tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."
msgstr ""
"tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."

#: ../doc/reference/reference_lua/osmodule.rst:282
msgid "Return the number of seconds between two times."
msgstr "Возврат числа секунд между двумя значениями времени."

#: ../doc/reference/reference_lua/osmodule.rst:286
msgid ""
"tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."
msgstr ""
"tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."

#: ../doc/reference/reference_lua/other.rst:3
#, fuzzy
msgid "Other package components"
msgstr "Получение таблицы URI-компонентов"

#: ../doc/reference/reference_lua/other.rst:5
msgid ""
"All the Tarantool modules are, at some level, inside a package which, "
"appropriately, is named ``package``. There are also miscellaneous "
"functions and variables which are outside all modules."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:17
msgid ":ref:`tonumber64() <other-tonumber64>`"
msgstr ":ref:`tonumber64() <other-tonumber64>`"

#: ../doc/reference/reference_lua/other.rst:17
msgid "Convert a string or a Lua number to a 64-bit integer"
msgstr "Конвертация строки или Lua-числа в 64-битное целое число"

#: ../doc/reference/reference_lua/other.rst:20
msgid ":ref:`dostring() <other-dostring>`"
msgstr ":ref:`dostring() <other-dostring>`"

#: ../doc/reference/reference_lua/other.rst:20
msgid "Parse and execute an arbitrary chunk of Lua code"
msgstr "Анализ и выполнение произвольного Lua-кода"

#: ../doc/reference/reference_lua/other.rst:23
#, fuzzy
msgid ":ref:`package.path <other-package_path>`"
msgstr ":ref:`pickle.pack() <pickle-pack>`"

#: ../doc/reference/reference_lua/other.rst:23
msgid "Where Tarantool looks for Lua additions"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:26
msgid ":ref:`package.cpath <other-package_cpath>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:26
msgid "Where Tarantool looks for C additions"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:29
#, fuzzy
msgid ":ref:`package.loaded <other-package_loaded>`"
msgstr ":ref:`msgpack.encode() <msgpack-encode>`"

#: ../doc/reference/reference_lua/other.rst:29
msgid "What Tarantool has already looked for and found"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:32
msgid ":ref:`package.setsearchroot <other-package_setsearchroot>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:32
msgid "Set the root path for a directory search"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:35
msgid ":ref:`package.searchroot <other-package_searchroot>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:35
msgid "Get the root path for a directory search"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:44
msgid ""
"Convert a string or a Lua number to a 64-bit integer. The input value can"
" be expressed in decimal, binary (for example 0b1010), or hexadecimal "
"(for example -0xffff). The result can be used in arithmetic, and the "
"arithmetic will be 64-bit integer arithmetic rather than floating-point "
"arithmetic. (Operations on an unconverted Lua number use floating-point "
"arithmetic.) The ``tonumber64()`` function is added by Tarantool; the "
"name is global."
msgstr ""
"Конвертация строки или Lua-числа в 64-битное целое число. Входное "
"значение может быть выражено десятичным, двоичным (например, 0b1010) или "
"шестнадцатеричным (например, -0xffff) числом. Результат может "
"использоваться в арифметике, причем скорее в 64-битной целочисленной "
"арифметике, а не в арифметике в системе с плавающей запятой. (Операции с "
"неконвертированными Lua-числами выполняются в арифметике в системе с "
"плавающей запятой.) Функция ``tonumber64()`` в Tarantool'е является "
"глобальной."

#: ../doc/reference/reference_lua/other.rst:54
msgid ""
"tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""
"tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."

#: ../doc/reference/reference_lua/other.rst:79
msgid ""
"Parse and execute an arbitrary chunk of Lua code. This function is mainly"
" useful to define and run Lua code without having to introduce changes to"
" the global Lua environment."
msgstr ""
"Анализ и выполнение произвольного Lua-кода. Данная функция используется "
"преимущественно для определения и выполнения Lua-кода без необходимости "
"внесения изменений в глобальное Lua-окружение."

#: ../doc/reference/reference_lua/other.rst:83
msgid "Lua code"
msgstr "Lua-код"

#: ../doc/reference/reference_lua/other.rst:84
msgid ""
"zero or more scalar values which will be appended to, or substitute for, "
"items in the Lua chunk."
msgstr ""
"ноль или другие скалярные значения, которые заменяются или к которым "
"прибавляются значения."

#: ../doc/reference/reference_lua/other.rst:87
msgid "whatever is returned by the Lua code chunk."
msgstr "то, что возвращает Lua-код."

#: ../doc/reference/reference_lua/other.rst:89
msgid ""
"Possible errors: If there is a compilation error, it is raised as a Lua "
"error."
msgstr "Возможные ошибки: Ошибка компиляции появляется как Lua-ошибка."

#: ../doc/reference/reference_lua/other.rst:94
msgid ""
"tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""
"tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."

#: ../doc/reference/reference_lua/other.rst:127
msgid ""
"This is a string that Tarantool uses to search for Lua modules, "
"especially imporant for ``require()``. See :ref:`Modules, rocks and "
"applications <app_server-modules>`."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:135
msgid ""
"This is a string that Tarantool uses to search for C modules, especially "
"imporant for ``require()``. See :ref:`Modules, rocks and applications "
"<app_server-modules>`."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:143
msgid ""
"This is a string that shows what Lua or C modules Tarantool has loaded, "
"so that their functions and members are available. Initially it has all "
"the pre-loaded modules, which don't need ``require()``."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:152
msgid ""
"Set the search root. The search root is the root directory from which "
"dependencies are loaded."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:155
#, fuzzy
msgid "the path. Default = current directory."
msgstr "Получение имени текущей рабочей директории"

#: ../doc/reference/reference_lua/other.rst:157
msgid ""
"The search-root string must contain a relative or absolute path. If it is"
" a relative path, then it will be expanded to an absolute path. If "
"search-root is omitted, or is box.NULL, then the search root is reset to "
"the current directory, which is found with debug.sourcedir()."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:165
msgid ""
"Suppose that a Lua file ``myapp/init.lua`` is the project root. |br| "
"Suppose the current path is ``/home/tara``. |br| Add this as the first "
"line of ``myapp/init.lua``: |br| :code:`package.setsearchroot()` |br| "
"Start the project with |br| :code:`$ tarantool myapp/init.lua` |br| The "
"search root will be the default, made absolute: ``/home/tara/myapp``. "
"Within the Lua application all dependencies will be searched relative to "
"``/home/tara/myapp``."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:179
msgid ""
"Return a string with the current search root. After "
"``package.setsearchroot('/home')`` the returned string will be "
"``/home'``."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:3
msgid "Module `pickle`"
msgstr "Модуль `pickle`"

#: ../doc/reference/reference_lua/pickle.rst:9
msgid "Below is a list of all ``pickle`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``pickle``."

#: ../doc/reference/reference_lua/pickle.rst:19
msgid ":ref:`pickle.pack() <pickle-pack>`"
msgstr ":ref:`pickle.pack() <pickle-pack>`"

#: ../doc/reference/reference_lua/pickle.rst:19
msgid "Convert Lua variables to binary format"
msgstr "Конвертация Lua-переменных в двоичный формат"

#: ../doc/reference/reference_lua/pickle.rst:22
msgid ":ref:`pickle.unpack() <pickle-unpack>`"
msgstr ":ref:`pickle.unpack() <pickle-unpack>`"

#: ../doc/reference/reference_lua/pickle.rst:22
msgid "Convert Lua variables back from binary format"
msgstr "Конвертация Lua-переменных в двоичный формат"

#: ../doc/reference/reference_lua/pickle.rst:32
msgid ""
"To use Tarantool binary protocol primitives from Lua, it's necessary to "
"convert Lua variables to binary format. The ``pickle.pack()`` helper "
"function is prototyped after Perl 'pack_'."
msgstr ""
"Чтобы использовать примитивы бинарного протокола Tarantool'а из Lua, "
"необходимо конвертировать Lua-переменные в двоичный формат. Прототипом "
"вспомогательной функции ``pickle.pack()`` выступила функция 'pack_' из "
"Perl."

#: ../doc/reference/reference_lua/pickle.rst:38
msgid "**Format specifiers**"
msgstr "**Спецификаторы формата**"

#: ../doc/reference/reference_lua/pickle.rst:43
msgid "b, B"
msgstr "b, B"

#: ../doc/reference/reference_lua/pickle.rst:43
msgid ""
"converts Lua scalar value to a 1-byte integer, and stores the integer in "
"the resulting string"
msgstr ""
"конвертирует скалярное Lua-значение в 1-байтное целое число и хранит "
"целое число в полученной строке"

#: ../doc/reference/reference_lua/pickle.rst:46
msgid "s, S"
msgstr "s, S"

#: ../doc/reference/reference_lua/pickle.rst:46
msgid ""
"converts Lua scalar value to a 2-byte integer, and stores the integer in "
"the resulting string, low byte first"
msgstr ""
"конвертирует скалярное Lua-значение в 2-байтное целое число и хранит "
"целое число в полученной строке, сначала младший байт"

#: ../doc/reference/reference_lua/pickle.rst:50
msgid "i, I"
msgstr "i, I"

#: ../doc/reference/reference_lua/pickle.rst:50
msgid ""
"converts Lua scalar value to a 4-byte integer, and stores the integer in "
"the resulting string, low byte first"
msgstr ""
"конвертирует скалярное Lua-значение в 4-байтное целое число и хранит "
"целое число в полученной строке, сначала младший байт"

#: ../doc/reference/reference_lua/pickle.rst:54
msgid "l, L"
msgstr "l, L"

#: ../doc/reference/reference_lua/pickle.rst:54
msgid ""
"converts Lua scalar value to an 8-byte integer, and stores the integer in"
" the resulting string, low byte first"
msgstr ""
"конвертирует скалярное Lua-значение в 8-байтное целое число и хранит "
"целое число в полученной строке, сначала младший байт"

#: ../doc/reference/reference_lua/pickle.rst:58
msgid "n"
msgstr "n"

#: ../doc/reference/reference_lua/pickle.rst:58
msgid ""
"converts Lua scalar value to a 2-byte integer, and stores the integer in "
"the resulting string, big endian,"
msgstr ""
"конвертирует скалярное Lua-значение в 2-байтное целое число и хранит "
"целое число в полученной строке, порядок от старшего к младшему,"

#: ../doc/reference/reference_lua/pickle.rst:62
msgid "N"
msgstr "N"

#: ../doc/reference/reference_lua/pickle.rst:62
msgid ""
"converts Lua scalar value to a 4-byte integer, and stores the integer in "
"the resulting string, big"
msgstr ""
"конвертирует скалярное Lua-значение в 4-байтное целое число и хранит "
"целое число в полученной строке, порядок от старшего к младшему,"

#: ../doc/reference/reference_lua/pickle.rst:65
msgid "q, Q"
msgstr "q, Q"

#: ../doc/reference/reference_lua/pickle.rst:65
msgid ""
"converts Lua scalar value to an 8-byte integer, and stores the integer in"
" the resulting string, big endian,"
msgstr ""
"конвертирует скалярное Lua-значение в 8-байтное целое число и хранит "
"целое число в полученной строке, порядок от старшего к младшему,"

#: ../doc/reference/reference_lua/pickle.rst:69
msgid "f"
msgstr "f"

#: ../doc/reference/reference_lua/pickle.rst:69
msgid ""
"converts Lua scalar value to a 4-byte float, and stores the float in the "
"resulting string"
msgstr ""
"конвертирует скалярное Lua-значение в 4-байтное число с плавающей запятой"
" и хранит число с плавающей запятой в полученной строке"

#: ../doc/reference/reference_lua/pickle.rst:72
msgid "d"
msgstr "d"

#: ../doc/reference/reference_lua/pickle.rst:72
msgid ""
"converts Lua scalar value to a 8-byte double, and stores the double in "
"the resulting string"
msgstr ""
"конвертирует скалярное Lua-значение в 8-байтное число двойной точности и "
"хранит число двойной точности в полученной строке"

#: ../doc/reference/reference_lua/pickle.rst:75
msgid "a, A"
msgstr "a, A"

#: ../doc/reference/reference_lua/pickle.rst:75
msgid ""
"converts Lua scalar value to a sequence of bytes, and stores the sequence"
" in the resulting string"
msgstr ""
"конвертирует скалярное Lua-значение в последовательность байтов и хранит "
"последовательность в полученной строке"

#: ../doc/reference/reference_lua/pickle.rst:79
msgid "string containing format specifiers"
msgstr "строка со спецификаторами формата"

#: ../doc/reference/reference_lua/pickle.rst:80
msgid "scalar values to be formatted"
msgstr "скалярные значения к форматированию"

#: ../doc/reference/reference_lua/pickle.rst:81
msgid ""
"a binary string containing all arguments, packed according to the format "
"specifiers."
msgstr ""
"бинарная строка, которая содержит все аргументы, упакованные в "
"соответствии со спецификаторами формата."

#: ../doc/reference/reference_lua/pickle.rst:85
msgid ""
"A scalar value can be either a variable or a literal. Remember that large"
" integers should be entered with :ref:`tonumber64() or LL or ULL suffixes"
" <index-box_number>`."
msgstr ""
"Скалярное значение может быть либо переменной, либо литеральным "
"значением. Следует помнить, что большие целые числа нужно вводить с "
":ref:`tonumber64() или суффиксами LL или ULL <index-box_number>`."

#: ../doc/reference/reference_lua/pickle.rst:89
msgid "Possible errors: unknown format specifier."
msgstr "Возможные ошибки: неизвестный спецификатор формата."

#: ../doc/reference/reference_lua/pickle.rst:93
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."

#: ../doc/reference/reference_lua/pickle.rst:129
msgid ""
"Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is "
"used, it must be the last item."
msgstr ""
"Противоположность ``pickle.pack()``. Внимание: если используется "
"спецификатор формата 'A', он должен идти последним."

#: ../doc/reference/reference_lua/pickle.rst:135
msgid "A list of strings or numbers."
msgstr "Список строк или чисел."

#: ../doc/reference/reference_lua/pickle.rst:140
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, "
"4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', "
"tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,"
"\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, "
"4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', "
"tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,"
"\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/socket.rst:5
msgid "Module `socket`"
msgstr "Модуль `socket`"

#: ../doc/reference/reference_lua/socket.rst:11
msgid ""
"The ``socket`` module allows exchanging data via BSD sockets with a local"
" or remote host in connection-oriented (TCP) or datagram-oriented (UDP) "
"mode. Semantics of the calls in the ``socket`` API closely follow "
"semantics of the corresponding POSIX calls. Function names and signatures"
" are mostly compatible with `luasocket`_."
msgstr ""
"Модуль ``socket`` позволяет обмениваться данными с локальным или "
"удаленным хостом по BSD-сокетам в режиме с установлением соединений (TCP)"
" или на основе датаграмм (UDP). Семантика вызовов в API модуля ``socket``"
" точно соответствует семантике соответствующих вызовов в POSIX. Имена и "
"сигнатуры функций по большей части совместимы с `luasocket`_."

#: ../doc/reference/reference_lua/socket.rst:17
msgid ""
"The functions for setting up and connecting are ``socket``, "
"``sysconnect``, ``tcp_connect``. The functions for sending data are "
"``send``, ``sendto``, ``write``, ``syswrite``. The functions for "
"receiving data are ``recv``, ``recvfrom``, ``read``. The functions for "
"waiting before sending/receiving data are ``wait``, ``readable``, "
"``writable``. The functions for setting flags are ``nonblock``, "
"``setsockopt``. The functions for stopping and disconnecting are "
"``shutdown``, ``close``. The functions for error checking are ``errno``, "
"``error``."
msgstr ""
"Функции для настройки и подключения: ``socket``, ``sysconnect``, "
"``tcp_connect``. Функции для отправки данных: ``send``, ``sendto``, "
"``write``, ``syswrite``. Функции для получения данных: ``recv``, "
"``recvfrom``, ``read``. Функции для ожидания отправки/получения данных: "
"``wait``, ``readable``, ``writable``. Функции для установки флагов: "
"``nonblock``, ``setsockopt``. Функции для остановки и отключения: "
"``shutdown``, ``close``. Функции для проверки ошибок: ``errno``, "
"``error``."

#: ../doc/reference/reference_lua/socket.rst:30
msgid "Below is a list of all ``socket`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``socket``."

#: ../doc/reference/reference_lua/socket.rst:40
msgid ":ref:`socket() <socket-socket>`"
msgstr ":ref:`socket() <socket-socket>`"

#: ../doc/reference/reference_lua/socket.rst:40
msgid "Create a socket"
msgstr "Создание сокета"

#: ../doc/reference/reference_lua/socket.rst:42
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ":ref:`socket.tcp_connect() <socket-tcp_connect>`"

#: ../doc/reference/reference_lua/socket.rst:42
#: ../doc/reference/reference_lua/socket.rst:51
msgid "Connect a socket to a remote host"
msgstr "Подключение к удаленному хосту с помощью сокета"

#: ../doc/reference/reference_lua/socket.rst:45
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"

#: ../doc/reference/reference_lua/socket.rst:45
msgid "Get information about a remote site"
msgstr "Получение информации об удаленном узле"

#: ../doc/reference/reference_lua/socket.rst:48
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ":ref:`socket.tcp_server() <socket-tcp_server>`"

#: ../doc/reference/reference_lua/socket.rst:48
msgid "Make Tarantool act as a TCP server"
msgstr "Использование Tarantool'а в качестве TCP-сервера"

#: ../doc/reference/reference_lua/socket.rst:51
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ":ref:`socket_object:sysconnect() <socket-sysconnect>`"

#: ../doc/reference/reference_lua/socket.rst:54
msgid ""
":ref:`socket_object:send() <socket-send>` |br| "
":ref:`socket_object:write() <socket-send>`"
msgstr ""
":ref:`socket_object:send() <socket-send>` |br| "
":ref:`socket_object:write() <socket-send>`"

#: ../doc/reference/reference_lua/socket.rst:54
msgid "Send data over a connected socket"
msgstr "Отправка данных по подключенному сокету"

#: ../doc/reference/reference_lua/socket.rst:57
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ":ref:`socket_object:syswrite() <socket-syswrite>`"

#: ../doc/reference/reference_lua/socket.rst:57
msgid "Write data to the socket buffer if non-blocking"
msgstr "Запись данных в буфер сокета без блокировки"

#: ../doc/reference/reference_lua/socket.rst:60
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ":ref:`socket_object:recv() <socket-recv>`"

#: ../doc/reference/reference_lua/socket.rst:60
msgid "Read from a connected socket"
msgstr "Чтение с подключенного сокета"

#: ../doc/reference/reference_lua/socket.rst:62
msgid ":ref:`socket_object:sysread() <socket-sysread>`"
msgstr ":ref:`socket_object:sysread() <socket-sysread>`"

#: ../doc/reference/reference_lua/socket.rst:62
msgid "Read data from the socket buffer if non-blocking"
msgstr "Чтение данных из буфера сокета без блокировки"

#: ../doc/reference/reference_lua/socket.rst:65
msgid ":ref:`socket_object:bind() <socket-bind>`"
msgstr ":ref:`socket_object:bind() <socket-bind>`"

#: ../doc/reference/reference_lua/socket.rst:65
msgid "Bind a socket to the given host/port"
msgstr "Привязка сокета к данному хосту/порту"

#: ../doc/reference/reference_lua/socket.rst:68
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ":ref:`socket_object:listen() <socket-listen>`"

#: ../doc/reference/reference_lua/socket.rst:68
msgid "Start listening for incoming connections"
msgstr "Начало прослушивания входящих соединений"

#: ../doc/reference/reference_lua/socket.rst:71
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ":ref:`socket_object:accept() <socket-accept>`"

#: ../doc/reference/reference_lua/socket.rst:71
msgid "Accept a client connection + create a connected socket"
msgstr "Принятие запроса клиента на соединение + создание подключенного сокета"

#: ../doc/reference/reference_lua/socket.rst:74
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ":ref:`socket_object:sendto() <socket-sendto>`"

#: ../doc/reference/reference_lua/socket.rst:74
msgid "Send a message on a UDP socket to a specified host"
msgstr "Отправка сообщения по UDP-сокету на указанный хост"

#: ../doc/reference/reference_lua/socket.rst:77
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ":ref:`socket_object:recvfrom() <socket-recvfrom>`"

#: ../doc/reference/reference_lua/socket.rst:77
msgid "Receive a message on a UDP socket"
msgstr "Получение сообщения по UDP-сокету"

#: ../doc/reference/reference_lua/socket.rst:80
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ":ref:`socket_object:shutdown() <socket-shutdown>`"

#: ../doc/reference/reference_lua/socket.rst:80
msgid "Shut down a reading end, a writing end, or both"
msgstr "Отключение передачи данных на чтение, на запись или в обоих направлениях"

#: ../doc/reference/reference_lua/socket.rst:83
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ":ref:`socket_object:close() <socket-close>`"

#: ../doc/reference/reference_lua/socket.rst:83
msgid "Close a socket"
msgstr "Закрытие сокета"

#: ../doc/reference/reference_lua/socket.rst:85
msgid ""
":ref:`socket_object:error() <socket-error>` |br| "
":ref:`socket_object:errno() <socket-error>`"
msgstr ""
":ref:`socket_object:error() <socket-error>` |br| "
":ref:`socket_object:errno() <socket-error>`"

#: ../doc/reference/reference_lua/socket.rst:85
msgid "Get information about the last error on a socket"
msgstr "Получение информации о последней ошибке на сокете"

#: ../doc/reference/reference_lua/socket.rst:88
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ":ref:`socket_object:setsockopt() <socket-setsockopt>`"

#: ../doc/reference/reference_lua/socket.rst:88
msgid "Set socket flags"
msgstr "Определение флагов сокета"

#: ../doc/reference/reference_lua/socket.rst:90
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ":ref:`socket_object:getsockopt() <socket-getsockopt>`"

#: ../doc/reference/reference_lua/socket.rst:90
msgid "Get socket flags"
msgstr "Получение флагов сокета"

#: ../doc/reference/reference_lua/socket.rst:92
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ":ref:`socket_object:linger() <socket-linger>`"

#: ../doc/reference/reference_lua/socket.rst:92
msgid "Set/clear the SO_LINGER flag"
msgstr "Установить/убрать флаг SO_LINGER"

#: ../doc/reference/reference_lua/socket.rst:94
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ":ref:`socket_object:nonblock() <socket-nonblock>`"

#: ../doc/reference/reference_lua/socket.rst:94
msgid "Set/get the flag value"
msgstr "Определить/получить значение флага"

#: ../doc/reference/reference_lua/socket.rst:96
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ":ref:`socket_object:readable() <socket-readable>`"

#: ../doc/reference/reference_lua/socket.rst:96
msgid "Wait until something is readable"
msgstr "Ожидание доступности чего-либо для чтения"

#: ../doc/reference/reference_lua/socket.rst:99
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ":ref:`socket_object:writable() <socket-writable>`"

#: ../doc/reference/reference_lua/socket.rst:99
msgid "Wait until something is writable"
msgstr "Ожидание доступности чего-либо для записи"

#: ../doc/reference/reference_lua/socket.rst:102
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ":ref:`socket_object:wait() <socket-wait>`"

#: ../doc/reference/reference_lua/socket.rst:102
msgid "Wait until something is either readable or writable"
msgstr "Ожидание доступности чего-либо для чтения или записи"

#: ../doc/reference/reference_lua/socket.rst:105
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ":ref:`socket_object:name() <socket-name>`"

#: ../doc/reference/reference_lua/socket.rst:105
msgid "Get information about the connection's near side"
msgstr "Получение информации о ближней стороне соединения"

#: ../doc/reference/reference_lua/socket.rst:108
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ":ref:`socket_object:peer() <socket-peer>`"

#: ../doc/reference/reference_lua/socket.rst:108
msgid "Get information about the connection's far side"
msgstr "Получение информации о дальней стороне соединения"

#: ../doc/reference/reference_lua/socket.rst:111
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ":ref:`socket.iowait() <socket-iowait>`"

#: ../doc/reference/reference_lua/socket.rst:111
msgid "Wait for read/write activity"
msgstr "Ожидание активности чтения/записи"

#: ../doc/reference/reference_lua/socket.rst:114
msgid ""
"Typically a socket session will begin with the setup functions, will set "
"one or more flags, will have a loop with sending and receiving functions,"
" will end with the teardown functions -- as an example at the end of this"
" section will show. Throughout, there may be error-checking and waiting "
"functions for synchronization. To prevent a fiber containing socket "
"functions from \"blocking\" other fibers, the :ref:`implicit yield rules "
"<atomic-implicit-yields>` will cause a yield so that other processes may "
"take over, as is the norm for :ref:`cooperative multitasking <atomic-"
"cooperative_multitasking>`."
msgstr ""
"Как правило, сессия сокета начинается с функций настройки, определяет "
"один или более флагов, запустит цикл с функциями отправки и получения и "
"закончится функциями завершения -- как в примере в конце данного раздела."
" В течение сессии может быть проверка на ошибки и ожидание синхронизации "
"функции. Чтобы файбер с сокетом не блокировал другие файберы, "
":ref:`правила неявной передачи управления <atomic-implicit-yields>` "
"заставят его передать управление другим процессам в рамках "
":ref:`кооперативной многозадачности <atomic-cooperative_multitasking>`."

#: ../doc/reference/reference_lua/socket.rst:123
msgid ""
"For all examples in this section the socket name will be sock and the "
"function invocations will look like ``sock:function_name(...)``."
msgstr ""
"Для всех примеров в данном разделе имя сокета будет sock, а вызов функции"
" будет выглядеть как ``sock:имя_функции(...)``."

#: ../doc/reference/reference_lua/socket.rst:132
msgid ""
"Create a new TCP or UDP socket. The argument values are the same as in "
"the `Linux socket(2) man page <http://man7.org/linux/man-"
"pages/man2/socket.2.html>`_."
msgstr ""
"Создание нового TCP-сокета или UDP-сокета. Значения аргумента остаются "
"теми же, что и на `странице socket(2) руководства по Linux "
"<http://man7.org/linux/man-pages/man2/socket.2.html>`_."

#: ../doc/reference/reference_lua/socket.rst:135
msgid "an unconnected socket, or nil."
msgstr "неподключенный сокет или nil."

#: ../doc/reference/reference_lua/socket.rst:140
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr "socket('AF_INET', 'SOCK_STREAM', 'tcp')"

#: ../doc/reference/reference_lua/socket.rst:148
msgid "Connect a socket to a remote host."
msgstr "Подключение к удаленному хосту с помощью сокета."

#: ../doc/reference/reference_lua/socket.rst:150
#: ../doc/reference/reference_lua/socket.rst:355
#: ../doc/reference/reference_lua/socket.rst:395
msgid "URL or IP address"
msgstr "URL или IP-адрес"

#: ../doc/reference/reference_lua/socket.rst:151
#: ../doc/reference/reference_lua/socket.rst:356
#: ../doc/reference/reference_lua/socket.rst:396
msgid "port number"
msgstr "номер порта"

#: ../doc/reference/reference_lua/socket.rst:152
msgid "timeout"
msgstr "время ожидания"

#: ../doc/reference/reference_lua/socket.rst:153
msgid "a connected socket, if no error."
msgstr "подключенный сокет, если нет ошибки."

#: ../doc/reference/reference_lua/socket.rst:158
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr "socket.tcp_connect('127.0.0.1', 3301)"

#: ../doc/reference/reference_lua/socket.rst:166
msgid ""
"The ``socket.getaddrinfo()`` function is useful for finding information "
"about a remote site so that the correct arguments for "
"``sock:sysconnect()`` can be passed. This function may use the "
":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>` configuration "
"parameter."
msgstr ""
"Функция ``socket.getaddrinfo()`` используется для поиска информации об "
"удаленном узле, чтобы можно было передать правильные аргументы для "
"``sock:sysconnect()``. Эта функция может использовать конфигурационный "
"параметр :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`."

#: ../doc/reference/reference_lua/socket.rst:172
#: ../doc/reference/reference_lua/socket.rst:560
#: ../doc/reference/reference_lua/socket.rst:572
msgid ""
"A table containing these fields: \"host\", \"family\", \"type\", "
"\"protocol\", \"port\"."
msgstr ""
"Таблица со следующими полями: \"host\", \"family\", \"type\", "
"\"protocol\", \"port\"."

#: ../doc/reference/reference_lua/socket.rst:177
msgid ""
"tarantool> socket.getaddrinfo('tarantool.org', 'http')\n"
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""
"tarantool> socket.getaddrinfo('tarantool.org', 'http')\n"
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."

#: ../doc/reference/reference_lua/socket.rst:197
msgid ""
"The ``socket.tcp_server()`` function makes Tarantool act as a server that"
" can accept connections. Usually the same objective is accomplished with "
":ref:`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""
"Функция ``socket.tcp_server()`` заставляет Tarantool выступать в качестве"
" сервера для принятия подключений. Обычно для этой же цели используется "
":ref:`box.cfg{listen=...} <cfg_basic-listen>`."

#: ../doc/reference/reference_lua/socket.rst:201
msgid "host name or IP"
msgstr "имя или IP хоста"

#: ../doc/reference/reference_lua/socket.rst:202
msgid "host port, may be 0"
msgstr "порт хоста, может быть 0"

#: ../doc/reference/reference_lua/socket.rst:203
msgid "what to execute when a connection occurs"
msgstr "что выполнить после подключения"

#: ../doc/reference/reference_lua/socket.rst:205
msgid "number of seconds to wait before timing out"
msgstr "количество секунд ожидания"

#: ../doc/reference/reference_lua/socket.rst:208
msgid ""
"The handler-function-or-table parameter may be simply a function name / "
"function declaration: :code:`handler_function`. Or it may be a table: "
":code:`{handler =` :samp:`{handler_function} [, prepare = "
"{prepare_function}] [, name = {name}]` :code:`}`. ``handler_function`` is"
" mandatory; it may have a single parameter = the socket; it is for "
"continuous operation after the connection is made. ``prepare_function`` "
"is optional; it is executed once before any connection is made. Examples:"
msgstr ""
"Параметр handler-function-or-table может представлять собой просто имя "
"функции или объявление функции: :code:`handler_function`. Или же может "
"быть таблицей: :code:`{handler =` :samp:`{handler_function} [, prepare = "
"{prepare_function}] [, name = {name}]` :code:`}`. Функция "
"``handler_function`` является обязательной, в ней может быть только один "
"параметр = сокет (используется для непрерывной работы после установки "
"соединения). Функция ``prepare_function`` необязательна; она выполняется "
"однократно перед установкой соединения. Например:"

#: ../doc/reference/reference_lua/socket.rst:220
msgid ""
"socket.tcp_server('localhost', 3302, function (s) loop_loop() end)\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, name='name'})\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, prepare=pfunc})"
msgstr ""
"socket.tcp_server('localhost', 3302, function (s) loop_loop() end)\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, name='name'})\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, prepare=pfunc})"

#: ../doc/reference/reference_lua/socket.rst:226
msgid ""
"For a fuller example see :ref:`Use tcp_server to accept file contents "
"sent with socat <socket_socat>`."
msgstr ""
"Более полный пример см. в разделе :ref:`Использование tcp_server для "
"получения содержимого файла, отправленного по socat <socket_socat>`."

#: ../doc/reference/reference_lua/socket.rst:235
msgid ""
"Connect an existing socket to a remote host. The argument values are the "
"same as in :ref:`tcp_connect() <socket-tcp_connect>`. The host must be an"
" IP address."
msgstr ""
"Подключение к удаленному хосту с помощью существующего сокета. Значения "
"аргументов будут такие же, как в :ref:`tcp_connect() <socket-"
"tcp_connect>`. Хост должен представлять собой IP-адрес."

#: ../doc/reference/reference_lua/socket.rst:252
msgid "Parameters:"
msgstr "Параметры:"

#: ../doc/reference/reference_lua/socket.rst:242
msgid "Either:"
msgstr "Либо:"

#: ../doc/reference/reference_lua/socket.rst:241
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr "host -- строковое представление IPv4 адреса или IPv6 адреса;"

#: ../doc/reference/reference_lua/socket.rst:243
msgid "port - a number."
msgstr "port -- число."

#: ../doc/reference/reference_lua/socket.rst:245
#: ../doc/reference/reference_lua/socket.rst:252
msgid "Or:"
msgstr "Либо:"

#: ../doc/reference/reference_lua/socket.rst:245
msgid "host - a string containing \"unix/\";"
msgstr "host -- строка, которая содержит \"unix/\";"

#: ../doc/reference/reference_lua/socket.rst:246
msgid "port - a string containing a path to a unix socket."
msgstr "port -- строка, которая содержит путь к Unix-сокету."

#: ../doc/reference/reference_lua/socket.rst:248
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr "host -- число, 0 (ноль), что означает \"все локальные интерфейсы\";"

#: ../doc/reference/reference_lua/socket.rst:250
msgid ""
"port - a number. If a port number is 0 (zero), the socket will be bound "
"to a random local port."
msgstr ""
"port -- число. Если номер порта -- 0 (ноль), сокет будет привязан к "
"случайному локальному порту."

#: ../doc/reference/reference_lua/socket.rst:254
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""
"значение объекта сокета может изменяться, если будет выполнена функция "
"sysconnect()."

#: ../doc/reference/reference_lua/socket.rst:259
msgid ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"

#: ../doc/reference/reference_lua/socket.rst:270
msgid "Send data over a connected socket."
msgstr "Отправка данных по подключенному сокету."

#: ../doc/reference/reference_lua/socket.rst:272
#: ../doc/reference/reference_lua/socket.rst:397
msgid "what is to be sent"
msgstr "что отправляется"

#: ../doc/reference/reference_lua/socket.rst:273
#: ../doc/reference/reference_lua/socket.rst:399
msgid "the number of bytes sent."
msgstr "количество отправляемых байтов."

#: ../doc/reference/reference_lua/socket.rst:276
msgid "Possible errors: nil on error."
msgstr "Возможные ошибки: nil в случае ошибки."

#: ../doc/reference/reference_lua/socket.rst:282
msgid ""
"Write as much data as possible to the socket buffer if non-blocking. "
"Rarely used. For details see `this description`_."
msgstr ""
"Запись максимально возможного количества данных в буфер сокета без "
"блокировки. Используется редко. Для получения подробной информации см. "
"описание по ссылке `this description`_."

#: ../doc/reference/reference_lua/socket.rst:289
msgid ""
"Read ``size`` bytes from a connected socket. An internal read-ahead "
"buffer is used to reduce the cost of this call."
msgstr ""
"Чтение количества байтов, определенного в ``size``, из подключенного "
"сокета. Внутренний буфер опережающего считывания используется для "
"уменьшения использования ресурсов на вызов."

#: ../doc/reference/reference_lua/socket.rst:292
#: ../doc/reference/reference_lua/socket.rst:410
msgid ""
"maximum number of bytes to receive. See :ref:`Recommended size <socket-"
"recommended>`."
msgstr ""
"максимальное количество получаемых байтов. См. :ref:`Рекомендованный "
"размер <socket-recommended>`."

#: ../doc/reference/reference_lua/socket.rst:293
msgid "a string of the requested length on success."
msgstr "строка запрошенной длины, если выполнено."

#: ../doc/reference/reference_lua/socket.rst:296
msgid ""
"Possible errors: On error, returns an empty string, followed by status, "
"errno, errstr. In case the writing side has closed its end, returns the "
"remainder read from the socket (possibly an empty string), followed by "
"\"eof\" status."
msgstr ""
"Возможные ошибки: В случае ошибки возвращается пустая строка, после чего "
"статус, errno, errstr. Если передача данных на запись закрыта с другой "
"стороны, возвращаются оставшиеся для чтения данные из сокета (возможно, "
"пустая строка), после чего идет статус \"eof\" (конец файла)."

#: ../doc/reference/reference_lua/socket.rst:307
msgid ""
"Read from a connected socket until some condition is true, and return the"
" bytes that were read. Reading goes on until ``limit`` bytes have been "
"read, or a delimiter has been read, or a timeout has expired. Unlike "
"``socket_object:recv`` (which uses an internal read-ahead buffer), "
"``socket_object:read`` depends on the socket's buffer."
msgstr ""
"Чтение данных из подключенного сокета до выполнения какого-либо условия и"
" возврат прочтенных байтов. Производится чтения количества байтов, "
"которое указано в параметре ``limit``, либо до символа-разделителя, либо "
"до истечения времени ожидания. В отличие от ``socket_object:recv`` (где "
"используется внутренний буфер опережающего считывания), "
"``socket_object:read`` зависит от буфера сокета."

#: ../doc/reference/reference_lua/socket.rst:314
#: ../doc/reference/reference_lua/socket.rst:339
msgid ""
"maximum number of bytes to read, for example 50 means \"stop after 50 "
"bytes\""
msgstr ""
"максимальное количество байтов для чтения, например, 50 означает "
"\"остановиться на 50 байтах\""

#: ../doc/reference/reference_lua/socket.rst:316
msgid "separator for example '?' means \"stop after a question mark\""
msgstr "разделитель, например, '?' означает \"остановиться после знака вопроса\""

#: ../doc/reference/reference_lua/socket.rst:318
msgid ""
"maximum number of seconds to wait, for example 50 means \"stop after 50 "
"seconds\"."
msgstr ""
"максимальное количество секунд ожидания, например, 50 означает "
"\"остановиться через 50 секунд\"."

#: ../doc/reference/reference_lua/socket.rst:320
msgid ""
":samp:`chunk={limit}` and/or :samp:`delimiter={delimiter}`, for example "
":code:`{chunk=5,delimiter='x'}`."
msgstr ""
":samp:`chunk={предел}` и/или :samp:`delimiter={разделитель}`, например, "
":code:`{chunk=5,delimiter='x'}`."

#: ../doc/reference/reference_lua/socket.rst:324
msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``limit`` bytes long, which may include the "
"bytes that matched the ``delimiter`` expression."
msgstr ""
"пустая строка, если нет данных для чтения, либо нулевое значение nil в "
"случае ошибки, либо строка, ограниченная количеством байтов в ``limit``, "
"которая может включать в себя байты, совпадающие с выражением "
"``delimiter``."

#: ../doc/reference/reference_lua/socket.rst:334
msgid ""
"Return data from the socket buffer if non-blocking. In case the socket is"
" blocking, ``sysread()`` can block the calling process. Rarely used. For "
"details, see also `this description "
"<https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."
msgstr ""
"Возврат данных из буфера сокета без блокировки.Если сокет с блокировкой, "
"``sysread()`` может блокировать процесс вызова. Используется редко. Для "
"получения подробной информации, см. `описание  "
"<https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."

#: ../doc/reference/reference_lua/socket.rst:342
msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``size`` bytes long."
msgstr ""
"пустая строка, если нет данных для чтения, либо нулевое значение nil в "
"случае ошибки, либо строка, ограниченная количеством байтов в ``size``."

#: ../doc/reference/reference_lua/socket.rst:350
msgid ""
"Bind a socket to the given host/port. A UDP socket after binding can be "
"used to receive data (see :ref:`socket_object.recvfrom <socket-"
"recvfrom>`). A TCP socket can be used to accept new connections, after it"
" has been put in listen mode."
msgstr ""
"Привязка сокета к данному хосту/порту. UDP-сокет после привязки может "
"использоваться для получения данных (см. :ref:`socket_object.recvfrom "
"<socket-recvfrom>`). TCP-сокет может использоваться для принятия новых "
"соединений после перевода в режим прослушивания."

#: ../doc/reference/reference_lua/socket.rst:358
msgid ""
"true for success, false for error. If return is false, use "
":ref:`socket_object:errno() <socket-error>` or "
":ref:`socket_object:error() <socket-error>` to see details."
msgstr ""
"true (правда), если выполнено, false (ложь) в случае ошибки. Если "
"возвращается false, используйте :ref:`socket_object:errno() <socket-"
"error>` или :ref:`socket_object:error() <socket-error>` для получения "
"подробной информации."

#: ../doc/reference/reference_lua/socket.rst:367
msgid "Start listening for incoming connections."
msgstr "Начало прослушивания входящих соединений."

#: ../doc/reference/reference_lua/socket.rst:369
msgid ""
"on Linux the listen ``backlog`` backlog may be from "
"``/proc/sys/net/core/somaxconn``, on BSD the backlog may be "
"``SOMAXCONN``."
msgstr ""
"в Linux очередь запросов ``backlog`` может быть в "
"``/proc/sys/net/core/somaxconn``, в BSD очередь запросов может "
"представлять собой ``SOMAXCONN``."

#: ../doc/reference/reference_lua/socket.rst:373
msgid "true for success, false for error."
msgstr "true (правда), если выполнено, false (ложь) в случае ошибки."

#: ../doc/reference/reference_lua/socket.rst:374
msgid "boolean."
msgstr "boolean (логический)."

#: ../doc/reference/reference_lua/socket.rst:380
msgid ""
"Accept a new client connection and create a new connected socket. It is "
"good practice to set the socket's blocking mode explicitly after "
"accepting."
msgstr ""
"Принятие нового клиентского соединения и создание нового подключенного "
"сокета. Установка блокирующего режима на сокете явным образом после "
"принятия соединения приведет к эффективной работе."

#: ../doc/reference/reference_lua/socket.rst:384
msgid "new socket if success."
msgstr "новый сокет, если выполнено."

#: ../doc/reference/reference_lua/socket.rst:387
msgid "Possible errors: nil."
msgstr "Возможные ошибки: nil."

#: ../doc/reference/reference_lua/socket.rst:393
msgid "Send a message on a UDP socket to a specified host."
msgstr "Отправка сообщения по UDP-сокету на указанный хост."

#: ../doc/reference/reference_lua/socket.rst:402
msgid ""
"Possible errors: on error, returns nil and may return status, errno, "
"errstr."
msgstr ""
"Возможные ошибки: в случае ошибки возвращает nil, а также может вернуть "
"статус, errno, errstr."

#: ../doc/reference/reference_lua/socket.rst:408
msgid "Receive a message on a UDP socket."
msgstr "Получение сообщения по UDP-сокету."

#: ../doc/reference/reference_lua/socket.rst:411
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr "сообщение, таблица с полями \"host\", \"family\" и \"port\"."

#: ../doc/reference/reference_lua/socket.rst:412
msgid "string, table"
msgstr "строка, таблица"

#: ../doc/reference/reference_lua/socket.rst:414
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr "Возможные ошибки: в случае ошибки возвращает nil, статус, errno, errstr."

#: ../doc/reference/reference_lua/socket.rst:418
msgid ""
"After ``message_content, message_sender = recvfrom(1)`` the value of "
"``message_content`` might be a string containing 'X' and the value of "
"``message_sender`` might be a table containing"
msgstr ""
"После ``message_content, message_sender = recvfrom(1)`` значением "
"``message_content`` может быть строка, которая содержит 'X', а значением "
"``message_sender`` может быть таблица, которая содержит"

#: ../doc/reference/reference_lua/socket.rst:422
msgid ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"

#: ../doc/reference/reference_lua/socket.rst:432
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr "Отключение передачи данных на чтение, на запись или в обоих направлениях."

#: ../doc/reference/reference_lua/socket.rst:434
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."

#: ../doc/reference/reference_lua/socket.rst:436
#: ../doc/reference/reference_lua/tap.rst:154
#: ../doc/reference/reference_lua/tap.rst:177
#: ../doc/reference/reference_lua/tap.rst:211
#: ../doc/reference/reference_lua/tap.rst:246
#: ../doc/reference/reference_lua/tap.rst:259
#: ../doc/reference/reference_lua/tap.rst:269
#: ../doc/reference/reference_lua/tap.rst:284
#: ../doc/reference/reference_lua/tap.rst:305
#: ../doc/reference/reference_lua/tap.rst:324
msgid "true or false."
msgstr "true (правда) или false (ложь)."

#: ../doc/reference/reference_lua/socket.rst:443
msgid ""
"Close (destroy) a socket. A closed socket should not be used any more. A "
"socket is closed automatically when the Lua garbage collector removes its"
" user data."
msgstr ""
"Закрытие (удаление) сокета. Закрытый сокет больше не должен "
"использоваться. Сокет будет закрыт автоматически, когда сборщик мусора "
"Lua удалит данные."

#: ../doc/reference/reference_lua/socket.rst:447
msgid ""
"true on success, false on error. For example, if sock is already closed, "
"sock:close() returns false."
msgstr ""
"true (правда), если выполнено, false (ложь) в случае ошибки. Например, "
"если сокет sock уже закрыт, sock:close() вернет false."

#: ../doc/reference/reference_lua/socket.rst:456
msgid ""
"Retrieve information about the last error that occurred on a socket, if "
"any. Errors do not cause throwing of exceptions so these functions are "
"usually necessary."
msgstr ""
"Получение информации о последней ошибке на сокете, если таковая была. "
"Ошибки не выдают исключения, поэтому данные функции необходимы."

#: ../doc/reference/reference_lua/socket.rst:459
msgid ""
"result for ``sock:errno()``, result for ``sock:error()``. If there is no "
"error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""
"результат ``sock:errno()``, результат ``sock:error()``. Если ошибки нет, "
"то ``sock:errno()`` вернет 0 и ``sock:error()``."

#: ../doc/reference/reference_lua/socket.rst:461
msgid "number, string"
msgstr "число, строка"

#: ../doc/reference/reference_lua/socket.rst:467
msgid ""
"Set socket flags. The argument values are the same as in the `Linux "
"getsockopt(2) man page <http://man7.org/linux/man-"
"pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""
"Определение флагов сокета. Значения аргумента будут такими же, что и на "
"`странице getsockopt(2) руководства по Linux <http://man7.org/linux/man-"
"pages/man2/setsockopt.2.html>`_. Tarantool принимает следующие:"

#: ../doc/reference/reference_lua/socket.rst:471
msgid "SO_ACCEPTCONN"
msgstr "SO_ACCEPTCONN"

#: ../doc/reference/reference_lua/socket.rst:472
msgid "SO_BINDTODEVICE"
msgstr "SO_BINDTODEVICE"

#: ../doc/reference/reference_lua/socket.rst:473
msgid "SO_BROADCAST"
msgstr "SO_BROADCAST"

#: ../doc/reference/reference_lua/socket.rst:474
msgid "SO_DEBUG"
msgstr "SO_DEBUG"

#: ../doc/reference/reference_lua/socket.rst:475
msgid "SO_DOMAIN"
msgstr "SO_DOMAIN"

#: ../doc/reference/reference_lua/socket.rst:476
msgid "SO_ERROR"
msgstr "SO_ERROR"

#: ../doc/reference/reference_lua/socket.rst:477
msgid "SO_DONTROUTE"
msgstr "SO_DONTROUTE"

#: ../doc/reference/reference_lua/socket.rst:478
msgid "SO_KEEPALIVE"
msgstr "SO_KEEPALIVE"

#: ../doc/reference/reference_lua/socket.rst:479
msgid "SO_MARK"
msgstr "SO_MARK"

#: ../doc/reference/reference_lua/socket.rst:480
msgid "SO_OOBINLINE"
msgstr "SO_OOBINLINE"

#: ../doc/reference/reference_lua/socket.rst:481
msgid "SO_PASSCRED"
msgstr "SO_PASSCRED"

#: ../doc/reference/reference_lua/socket.rst:482
msgid "SO_PEERCRED"
msgstr "SO_PEERCRED"

#: ../doc/reference/reference_lua/socket.rst:483
msgid "SO_PRIORITY"
msgstr "SO_PRIORITY"

#: ../doc/reference/reference_lua/socket.rst:484
msgid "SO_PROTOCOL"
msgstr "SO_PROTOCOL"

#: ../doc/reference/reference_lua/socket.rst:485
msgid "SO_RCVBUF"
msgstr "SO_RCVBUF"

#: ../doc/reference/reference_lua/socket.rst:486
msgid "SO_RCVBUFFORCE"
msgstr "SO_RCVBUFFORCE"

#: ../doc/reference/reference_lua/socket.rst:487
msgid "SO_RCVLOWAT"
msgstr "SO_RCVLOWAT"

#: ../doc/reference/reference_lua/socket.rst:488
msgid "SO_SNDLOWAT"
msgstr "SO_SNDLOWAT"

#: ../doc/reference/reference_lua/socket.rst:489
msgid "SO_RCVTIMEO"
msgstr "SO_RCVTIMEO"

#: ../doc/reference/reference_lua/socket.rst:490
msgid "SO_SNDTIMEO"
msgstr "SO_SNDTIMEO"

#: ../doc/reference/reference_lua/socket.rst:491
msgid "SO_REUSEADDR"
msgstr "SO_REUSEADDR"

#: ../doc/reference/reference_lua/socket.rst:492
msgid "SO_SNDBUF"
msgstr "SO_SNDBUF"

#: ../doc/reference/reference_lua/socket.rst:493
msgid "SO_SNDBUFFORCE"
msgstr "SO_SNDBUFFORCE"

#: ../doc/reference/reference_lua/socket.rst:494
msgid "SO_TIMESTAMP"
msgstr "SO_TIMESTAMP"

#: ../doc/reference/reference_lua/socket.rst:495
msgid "SO_TYPE"
msgstr "SO_TYPE"

#: ../doc/reference/reference_lua/socket.rst:497
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""
"Установка флага SO_LINGER осуществляется с помощью "
"``sock:linger(active)``."

#: ../doc/reference/reference_lua/socket.rst:503
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""
"Получение флагов сокета. Список возможных флагов см. с помощью "
"``sock:setsockopt()``."

#: ../doc/reference/reference_lua/socket.rst:509
msgid ""
"Set or clear the SO_LINGER flag. For a description of the flag, see the "
"`Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""
"Установить или убрать флаг SO_LINGER. Описание флага см. в `руководстве "
"по Linux <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."

#: ../doc/reference/reference_lua/socket.rst:514
msgid "new active and timeout values."
msgstr "новые значения active и timeout."

#: ../doc/reference/reference_lua/socket.rst:520
msgid "``sock:nonblock()`` returns the current flag value."
msgstr "``sock:nonblock()`` возвращает текущее значение флага."

#: ../doc/reference/reference_lua/socket.rst:521
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr "``sock:nonblock(false)`` устанавливает флаг на false и возвращает false."

#: ../doc/reference/reference_lua/socket.rst:522
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr "``sock:nonblock(true)`` устанавливает флаг на true и возвращает true."

#: ../doc/reference/reference_lua/socket.rst:524
msgid ""
"This function may be useful before invoking a function which might "
"otherwise block indefinitely."
msgstr ""
"Эту функцию можно использовать до вызова функции, которая в противном "
"случае будет блокировать бесконечно."

#: ../doc/reference/reference_lua/socket.rst:531
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""
"Ожидание доступности чего-либо для чтения или до истечения времени "
"ожидания."

#: ../doc/reference/reference_lua/socket.rst:533
msgid "true if the socket is now readable, false if timeout expired;"
msgstr "true, если сокет доступен для чтения, false, если истекло время ожидания;"

#: ../doc/reference/reference_lua/socket.rst:539
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""
"Ожидание доступности чего-либо для записи или до истечения времени "
"ожидания."

#: ../doc/reference/reference_lua/socket.rst:541
msgid "true if the socket is now writable, false if timeout expired;"
msgstr "true, если сокет доступен для записи, false, если истекло время ожидания;"

#: ../doc/reference/reference_lua/socket.rst:547
msgid ""
"Wait until something is either readable or writable, or until a timeout "
"value expires."
msgstr ""
"Ожидание доступности чего-либо для чтения или записи, или до истечения "
"времени ожидания."

#: ../doc/reference/reference_lua/socket.rst:549
msgid ""
"'R' if the socket is now readable, 'W' if the socket is now writable, "
"'RW' if the socket is now both readable and writable, '' (empty string) "
"if timeout expired;"
msgstr ""
"'R', если сокет доступен для чтения, 'W', если сокет доступен для записи,"
" 'RW', если сокет доступен и для чтения, и для записи, '' (пустая "
"строка), если истекло время ожидания;"

#: ../doc/reference/reference_lua/socket.rst:555
msgid ""
"The ``sock:name()`` function is used to get information about the near "
"side of the connection. If a socket was bound to ``xyz.com:45``, then "
"``sock:name`` will return information about ``[host:xyz.com, port:45]``. "
"The equivalent POSIX function is ``getsockname()``."
msgstr ""
"Функция ``sock:name()`` используется для получения информации о ближней "
"стороне соединения. Если сокет привязан к ``xyz.com:45``, то "
"``sock:name`` вернет информацию о ``[host:xyz.com, port:45]``. "
"Аналогичная функция в POSIX -- ``getsockname()``."

#: ../doc/reference/reference_lua/socket.rst:567
msgid ""
"The ``sock:peer()`` function is used to get information about the far "
"side of a connection. If a TCP connection has been made to a distant host"
" ``tarantool.org:80``, ``sock:peer()`` will return information about "
"``[host:tarantool.org, port:80]``. The equivalent POSIX function is "
"``getpeername()``."
msgstr ""
"Функция ``sock:peer()`` используется для получения информации о дальней "
"стороне соединения. Если TCP-соединение установлено с удаленным хостом "
"``tarantool.org:80``, то ``sock:peer()`` вернет информацию о "
"``[host:tarantool.org, port:80]``. Аналогичная функция в POSIX --  "
"``getpeername()``."

#: ../doc/reference/reference_lua/socket.rst:579
msgid ""
"The ``socket.iowait()`` function is used to wait until read-or-write "
"activity occurs for a file descriptor."
msgstr ""
"Функция ``socket.iowait()`` используется для ожидания, пока дескриптор "
"файла не будет активен для чтения или записи."

#: ../doc/reference/reference_lua/socket.rst:582
msgid "file descriptor"
msgstr "дескриптор файла"

#: ../doc/reference/reference_lua/socket.rst:583
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr "'R' или 1 = чтение, 'W' или 2 = запись, 'RW' или 3 = чтение|запись."

#: ../doc/reference/reference_lua/socket.rst:584
msgid "number of seconds to wait"
msgstr "количество секунд ожидания"

#: ../doc/reference/reference_lua/socket.rst:586
msgid ""
"If the fd parameter is nil, then there will be a sleep until the timeout."
" If the timeout parameter is nil or unspecified, then timeout is "
"infinite."
msgstr ""
"Если значение параметра fd -- nil, то будет режим ожидания до истечения "
"времени, указанного в параметре timeout. Если timeout -- nil или не "
"указан, время ожидания считается бесконечным."

#: ../doc/reference/reference_lua/socket.rst:589
msgid ""
"Ordinarily the return value is the activity that occurred ('R' or 'W' or "
"'RW' or 1 or 2 or 3). If the timeout period goes by without any reading "
"or writing, the return is an error = ETIMEDOUT."
msgstr ""
"Как правило, возвращается значение совершенного действия ('R' или 'W', "
"или 'RW', или 1, или 2, или 3). Если время ожидания в timeout проходит "
"без действий чтения или записи, возвращается ошибка = ETIMEDOUT."

#: ../doc/reference/reference_lua/socket.rst:593
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr "Пример: ``socket.iowait(sock:fd(), 'r', 1.11)``"

#: ../doc/reference/reference_lua/socket.rst:599
msgid "Recommended size"
msgstr "Рекомендованный размер"

#: ../doc/reference/reference_lua/socket.rst:601
msgid ""
"For ``recv`` and ``recvfrom``: use the optional ``size`` parameter to "
"limit the number of bytes to receive. A fixed size such as 512 is often "
"reasonable; a pre-calculated size that depends on context -- such as the "
"message format or the state of the network -- is often better. For "
"``recvfrom``, be aware that a size greater than the `Maximum Transmission"
" Unit <https://en.wikipedia.org/wiki/Maximum_transmission_unit>`_ can "
"cause inefficient transport. For Mac OS X, be aware that the size can be "
"tuned by changing ``sysctl net.inet.udp.maxdgram``."
msgstr ""
"Для ``recv`` и ``recvfrom``: используйте необязательный параметр "
"``size``, чтобы ограничить количество получаемых байтов. Часто "
"используется заданный размер, такой как 512; но во многих случаях лучше "
"использовать предварительно рассчитанный размер, который зависит от "
"контекста -- как формат сообщения или состояние сети. Что касается "
"``recvfrom``, следует помнить, что размер больше максимального размера "
"полезного блока данных одного пакета (`Maximum Transmission Unit "
"<https://en.wikipedia.org/wiki/Maximum_transmission_unit>`_) может "
"вызвать низкоэффективную передачу данных. Что касается Mac OS X, следует "
"отметить, что размер можно настроить с помощью ``sysctl "
"net.inet.udp.maxdgram``."

#: ../doc/reference/reference_lua/socket.rst:612
msgid ""
"If ``size`` is not stated: Tarantool will make an extra call to calculate"
" how many bytes are necessary. This extra call takes time, therefore not "
"stating ``size`` may be inefficient."
msgstr ""
"Если размер ``size`` не задан: Tarantool сделает дополнительный вызов для"
" расчет необходимого количества байтов. Такой дополнительный вызов "
"занимает время, поэтому во избежание низкой эффективности лучше указать "
"``size``."

#: ../doc/reference/reference_lua/socket.rst:616
msgid ""
"If ``size`` is stated: on a UDP socket, excess bytes are discarded. On a "
"TCP socket, excess bytes are not discarded and can be received by the "
"next call."
msgstr ""
"Если размер ``size`` задан: в UDP-сокете лишние байты отбрасываются; в "
"TCP-сокете лишние байты не отбрасываются, их можно получить при следующем"
" вызове."

#: ../doc/reference/reference_lua/socket.rst:622
msgid "Examples"
msgstr "Примеры"

#: ../doc/reference/reference_lua/socket.rst:626
msgid "Use of a TCP socket over the Internet"
msgstr "Использование TCP-сокета в интернете"

#: ../doc/reference/reference_lua/socket.rst:628
msgid ""
"In this example a connection is made over the internet between a "
"Tarantool instance and tarantool.org, then an HTTP \"head\" message is "
"sent, and a response is received: \"``HTTP/1.1 200 OK``\" or something "
"else if the site has moved. This is not a useful way to communicate with "
"this particular site, but shows that the system works."
msgstr ""
"В данном примере устанавливается соединение по интернету между "
"экземпляром Tarantool'а и tarantool.org, затем отправляется "
"HTTP-сообщение заголовка \"head\" и возвращается ответ: \"``HTTP/1.1 200 "
"OK``\" или что-то другое, если сайт перемещен. Так не слишком удобно "
"взаимодействовать с определенным сайтом, но пример показывает работу "
"системы."

#: ../doc/reference/reference_lua/socket.rst:634
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: "
"tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: "
"tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/socket.rst:665
msgid "Use of a UDP socket on localhost"
msgstr "Использование UDP-сокета на localhost"

#: ../doc/reference/reference_lua/socket.rst:667
msgid ""
"Here is an example with datagrams. Set up two connections on 127.0.0.1 "
"(localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message "
"to ``sock_1``. Using ``sock_1``, receive a message. Display the received "
"message. Close both connections. |br| This is not a useful way for a "
"computer to communicate with itself, but shows that the system works."
msgstr ""
"Ниже приведен пример с датаграммами. Устанавливается два соединения с "
"127.0.0.1 (localhost): ``sock_1`` и ``sock_2``. С помощью ``sock_2`` "
"отправляется сообщение на ``sock_1``. С помощью ``sock_1`` получается "
"сообщение. Отображается полученное сообщение. Оба соединения закрываются."
" |br| Компьютеру так не слишком удобно взаимодействовать с самим собой, "
"но пример показывает работу системы."

#: ../doc/reference/reference_lua/socket.rst:673
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> message = sock_1:recvfrom(512)\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> message = sock_1:recvfrom(512)\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/socket.rst:712
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""
"Использование tcp_server для получения содержимого файла, отправленного "
"по socat"

#: ../doc/reference/reference_lua/socket.rst:714
msgid ""
"Here is an example of the tcp_server function, reading strings from the "
"client and printing them. On the client side, the Linux socat utility "
"will be used to ship a whole file for the tcp_server function to read."
msgstr ""
"Ниже приведен пример функции ``tcp_server``, которая читает строки с "
"клиента и выводит результат. На клиентской стороне утилита ``socat`` в "
"Linux будет использоваться для отправки целого файла на чтение функции "
"``tcp_server``."

#: ../doc/reference/reference_lua/socket.rst:719
msgid ""
"Start two shells. The first shell will be a server instance. The second "
"shell will be the client."
msgstr ""
"Запустите две оболочки. Первая оболочка будет экземпляром сервера. Вторая"
" оболочка будет клиентом."

#: ../doc/reference/reference_lua/socket.rst:722
msgid "On the first shell, start Tarantool and say:"
msgstr "В первой оболочке запустите Tarantool и выполните:"

#: ../doc/reference/reference_lua/socket.rst:724
msgid ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302,\n"
"{\n"
"  handler = function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end,\n"
"  prepare = function()\n"
"    print('Initialized')\n"
"  end\n"
"}\n"
")"
msgstr ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302,\n"
"{\n"
"  handler = function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end,\n"
"  prepare = function()\n"
"    print('Initialized')\n"
"  end\n"
"}\n"
")"

#: ../doc/reference/reference_lua/socket.rst:746
msgid ""
"The above code means: use `tcp_server()` to wait for a connection from "
"any host on port 3302. When it happens, enter a loop that reads on the "
"socket and prints what it reads. The \"delimiter\" for the read function "
"is \"\\\\n\" so each `read()` will read a string as far as the next line "
"feed, including the line feed."
msgstr ""
"Вышеуказанный код означает: использовать `tcp_server()` для ожидания "
"подключения с любого хоста по порту 3302. Когда это произойдет, ввести "
"цикл, который читает по сокету и выводит результат чтения. Разделителем "
"для функции чтения будет \"\\\\n\", поэтому каждое выполнение `read()` "
"выполнит чтение строки до перевода строки, включая перевод строки."

#: ../doc/reference/reference_lua/socket.rst:753
msgid ""
"On the second shell, create a file that contains a few lines. The "
"contents don't matter. Suppose the first line contains A, the second line"
" contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""
"Во второй оболочке создайте файл, который содержит несколько строк. "
"Содержимое не имеет значения. Предположим, что первая строка содержит A, "
"вторая строка содержит B, третья строка содержит C. Назовите этот файл "
"\"tmp.txt\"."

#: ../doc/reference/reference_lua/socket.rst:758
msgid ""
"On the second shell, use the socat utility to ship the tmp.txt file to "
"the server instance's host and port:"
msgstr ""
"Во второй оболочке используйте утилиту socat для отправки файла tmp.txt "
"на экземпляр сервера по хосту и порту:"

#: ../doc/reference/reference_lua/socket.rst:761
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr "$ socat TCP:localhost:3302 ./tmp.txt"

#: ../doc/reference/reference_lua/socket.rst:765
msgid ""
"Now watch what happens on the first shell. The strings \"A\", \"B\", "
"\"C\" are printed."
msgstr ""
"Теперь смотрите, что происходит в первой оболочке. Выводятся строки "
"\"A\", \"B\", \"C\"."

#: ../doc/reference/reference_lua/strict.rst:5
msgid "Module `strict`"
msgstr "Модуль `strict`"

#: ../doc/reference/reference_lua/strict.rst:9
msgid ""
"The :code:`strict` module has functions for turning \"strict mode\" on or"
" off. When strict mode is on, an attempt to use an undeclared global "
"variable will cause an error. A global variable is considered "
"\"undeclared\" if it has never had a value assigned to it. Often this is "
"an indication of a programming error."
msgstr ""
"Модуль :code:`strict` включает в себя функции для включения или "
"отключения строгого режима \"strict mode\". Когда включен строгий режим, "
"попытка использовать необъявленную глобальную переменную приведет к "
"ошибке. Глобальная переменная считается необъявленной, если ей никогда не"
" было присвоено значение. Часто это указывает на ошибку программирования."

#: ../doc/reference/reference_lua/strict.rst:14
msgid ""
"By default strict mode is off, unless tarantool was built with the "
"``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build "
"options in section :ref:`building-from-source <building_from_source>`."
msgstr ""
"По умолчанию, строгий режим отключен, не считая случаев, когда сборка "
"Tarantool'а производилась с помощью ``-DCMAKE_BUILD_TYPE=Debug`` -- см. "
"варианты сборки в разделе :ref:`сборка из исходников "
"<building_from_source>`."

#: ../doc/reference/reference_lua/strict.rst:20
msgid ""
"tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""
"tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- строгий режим включен, поэтому появляется ошибка\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- строгий режим отключен, поэтому ошибки нет\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/string.rst:5
msgid "Module `string`"
msgstr "Модуль `string`"

#: ../doc/reference/reference_lua/string.rst:13
msgid ""
"The :code:`string` module has everything in the `standard Lua string "
"library <https://www.lua.org/pil/20.html>`_, and some Tarantool "
"extensions."
msgstr ""
"Модуль :code:`string` включает в себя всё из `стандартной библиотеки для "
"работы со строками в Lua <https://www.lua.org/pil/20.html>`_, а также "
"некоторые расширения специально для Tarantool'а."

#: ../doc/reference/reference_lua/string.rst:17
msgid ""
"In this section we only discuss the additional functions that the "
"Tarantool developers have added."
msgstr ""
"В данном разделе мы рассматриваем только дополнительные функции, "
"добавленные разработчиками Tarantool'а."

#: ../doc/reference/reference_lua/string.rst:24
msgid "Below is a list of all additional ``string`` functions."
msgstr "Ниже приведен перечень всех функций библиотеки ``string``."

#: ../doc/reference/reference_lua/string.rst:34
msgid ":ref:`string.ljust() <string-ljust>`"
msgstr ":ref:`string.ljust() <string-ljust>`"

#: ../doc/reference/reference_lua/string.rst:34
msgid "Left-justify a string"
msgstr "Выравнивание строки по левому полю"

#: ../doc/reference/reference_lua/string.rst:37
msgid ":ref:`string.rjust() <string-rjust>`"
msgstr ":ref:`string.rjust() <string-rjust>`"

#: ../doc/reference/reference_lua/string.rst:37
msgid "Right-justify a string"
msgstr "Выравнивание строки по правому полю"

#: ../doc/reference/reference_lua/string.rst:40
msgid ":ref:`string.hex() <string-hex>`"
msgstr ":ref:`string.hex() <string-hex>`"

#: ../doc/reference/reference_lua/string.rst:40
msgid "Given a string, return hexadecimal values"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:43
#, fuzzy
msgid ":ref:`string.fromhex() <string-fromhex>`"
msgstr ":ref:`string.hex() <string-hex>`"

#: ../doc/reference/reference_lua/string.rst:43
#, fuzzy
msgid "Given hexadecimal values, return a string"
msgstr "Получение шестнадцатеричного значения строки"

#: ../doc/reference/reference_lua/string.rst:46
msgid ":ref:`string.startswith() <string-startswith>`"
msgstr ":ref:`string.startswith() <string-startswith>`"

#: ../doc/reference/reference_lua/string.rst:46
msgid "Check if a string starts with a given substring"
msgstr "Проверка, начинается ли строка с заданной подстроки"

#: ../doc/reference/reference_lua/string.rst:49
msgid ":ref:`string.endswith() <string-endswith>`"
msgstr ":ref:`string.endswith() <string-endswith>`"

#: ../doc/reference/reference_lua/string.rst:49
msgid "Check if a string ends with a given substring"
msgstr "Проверка, заканчивается ли строка на заданную подстроку"

#: ../doc/reference/reference_lua/string.rst:52
msgid ":ref:`string.lstrip() <string-lstrip>`"
msgstr ":ref:`string.lstrip() <string-lstrip>`"

#: ../doc/reference/reference_lua/string.rst:52
#, fuzzy
msgid "Remove characters from the left of a string"
msgstr "Удаление пробелов слева от строки"

#: ../doc/reference/reference_lua/string.rst:55
msgid ":ref:`string.rstrip() <string-rstrip>`"
msgstr ":ref:`string.rstrip() <string-rstrip>`"

#: ../doc/reference/reference_lua/string.rst:55
#, fuzzy
msgid "Remove characters from the right of a string"
msgstr "Удаление пробелов справа от строки"

#: ../doc/reference/reference_lua/string.rst:58
msgid ":ref:`string.split() <string-split>`"
msgstr ":ref:`string.split() <string-split>`"

#: ../doc/reference/reference_lua/string.rst:58
msgid "Split a string into a table of strings"
msgstr "Разделение строки на таблицу со строками"

#: ../doc/reference/reference_lua/string.rst:61
msgid ":ref:`string.strip() <string-strip>`"
msgstr ":ref:`string.strip() <string-strip>`"

#: ../doc/reference/reference_lua/string.rst:61
msgid "Remove spaces on the left and right of a string"
msgstr "Удаление пробелов слева и справа от строки"

#: ../doc/reference/reference_lua/string.rst:69
msgid "Return the string left-justified in a string of length ``width``."
msgstr ""
"Возврат строки, выровненной по левому краю, шириной, указанной в "
"``width``."

#: ../doc/reference/reference_lua/string.rst:71
msgid "the string to left-justify"
msgstr "строка для выравнивания по левому краю"

#: ../doc/reference/reference_lua/string.rst:72
msgid "the width of the string after left-justifying"
msgstr "ширина строки после выравнивания по левому краю"

#: ../doc/reference/reference_lua/string.rst:73
#: ../doc/reference/reference_lua/string.rst:98
msgid "a single character, default = 1 space"
msgstr "отдельный символ, по умолчанию = 1 пробел"

#: ../doc/reference/reference_lua/string.rst:75
msgid "left-justified string (unchanged if width <= string length)"
msgstr ""
"выровненная по левому краю строка (не изменяется, если ширина <= длине "
"строки)"

#: ../doc/reference/reference_lua/string.rst:80
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.ljust(' A', 5)\n"
"---\n"
"- ' A   '\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.ljust(' A', 5)\n"
"---\n"
"- ' A   '\n"
"..."

#: ../doc/reference/reference_lua/string.rst:94
msgid "Return the string right-justified in a string of length ``width``."
msgstr ""
"Возврат строки, выровненной по правому краю, шириной, указанной в "
"``width``."

#: ../doc/reference/reference_lua/string.rst:96
msgid "the string to right-justify"
msgstr "строка для выравнивания по правому краю"

#: ../doc/reference/reference_lua/string.rst:97
msgid "the width of the string after right-justifying"
msgstr "ширина строки после выравнивания по правому краю"

#: ../doc/reference/reference_lua/string.rst:100
msgid "right-justified string (unchanged if width <= string length)"
msgstr ""
"выровненная по правому краю строка (не изменяется, если ширина <= длине "
"строки)"

#: ../doc/reference/reference_lua/string.rst:105
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rjust('', 5, 'X')\n"
"---\n"
"- 'XXXXX'\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rjust('', 5, 'X')\n"
"---\n"
"- 'XXXXX'\n"
"..."

#: ../doc/reference/reference_lua/string.rst:119
msgid "Return the hexadecimal value of the input string."
msgstr "Возврат шестнадцатеричного значения введенной строки."

#: ../doc/reference/reference_lua/string.rst:121
#: ../doc/reference/reference_lua/string.rst:231
#: ../doc/reference/reference_lua/string.rst:257
#: ../doc/reference/reference_lua/string.rst:315
msgid "the string to process"
msgstr "обрабатываемая строка"

#: ../doc/reference/reference_lua/string.rst:123
msgid "hexadecimal, 2 hex-digit characters for each input character"
msgstr ""
"шестнадцатеричное число, два символа шестнадцатеричных цифр для каждого "
"введенного символа"

#: ../doc/reference/reference_lua/string.rst:128
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.hex('ABC ')\n"
"---\n"
"- '41424320'\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.hex('ABC ')\n"
"---\n"
"- '41424320'\n"
"..."

#: ../doc/reference/reference_lua/string.rst:142
msgid ""
"Given a string containing pairs of hexadecimal digits, return a string "
"with one byte for each pair. This is the reverse of ``string.hex()``. The"
" hexadecimal-input-string must contain an even number of hexadecimal "
"digits."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:146
#, fuzzy
msgid "string with pairs of hexadecimal digits"
msgstr "строка с обратной трассировкой стека вызовов"

#: ../doc/reference/reference_lua/string.rst:148
msgid "string with one byte for each pair of hexadecimal digits"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:153
#, fuzzy
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.fromhex('41424320')\n"
"---\n"
"- 'ABC '\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.hex('ABC ')\n"
"---\n"
"- '41424320'\n"
"..."

#: ../doc/reference/reference_lua/string.rst:167
msgid ""
"Return True if ``input-string`` starts with ``start-string``, otherwise "
"return False."
msgstr ""
"Возврат true (правда), если ``input-string`` начинается со ``start-"
"string``, в противном случае, возврат false (ложь)."

#: ../doc/reference/reference_lua/string.rst:170
msgid "the string where ``start-string`` should be looked for"
msgstr "строка, где производится поиск данных из ``start-string``"

#: ../doc/reference/reference_lua/string.rst:171
#: ../doc/reference/reference_lua/string.rst:201
msgid "the string to look for"
msgstr "искомая строка"

#: ../doc/reference/reference_lua/string.rst:172
#: ../doc/reference/reference_lua/string.rst:202
msgid "position: where to start looking within ``input-string``"
msgstr "положение: где начинать искать в пределах ``input-string``"

#: ../doc/reference/reference_lua/string.rst:173
#: ../doc/reference/reference_lua/string.rst:203
msgid "position: where to end looking within ``input-string``"
msgstr "положение: где заканчивать искать в пределах ``input-string``"

#: ../doc/reference/reference_lua/string.rst:175
#: ../doc/reference/reference_lua/string.rst:205
#: ../doc/reference/reference_lua/utf8.rst:146
#: ../doc/reference/reference_lua/utf8.rst:171
#: ../doc/reference/reference_lua/utf8.rst:193
#: ../doc/reference/reference_lua/utf8.rst:215
msgid "true or false"
msgstr "true (правда) или false (ложь)"

#: ../doc/reference/reference_lua/string.rst:178
#: ../doc/reference/reference_lua/string.rst:208
msgid ""
"``start-pos`` and ``end-pos`` may be negative, meaning the position "
"should be calculated from the end of the string."
msgstr ""
"Значения ``start-pos`` и ``end-pos`` могут быть отрицательными, что "
"означает, что положение вычисляется с конца строки."

#: ../doc/reference/reference_lua/string.rst:183
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.startswith(' A', 'A', 2, 5)\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.startswith(' A', 'A', 2, 5)\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/string.rst:197
msgid ""
"Return True if ``input-string`` ends with ``end-string``, otherwise "
"return False."
msgstr ""
"Возврат true (правда), если ``input-string`` заканчивается на ``end-"
"string``, в противном случае, возврат false (ложь)."

#: ../doc/reference/reference_lua/string.rst:200
msgid "the string where ``end-string`` should be looked for"
msgstr "строка, где производится поиск данных из ``end-string``"

#: ../doc/reference/reference_lua/string.rst:213
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.endswith('Baa', 'aa')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.endswith('Baa', 'aa')\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/string.rst:227
msgid ""
"Return the value of the input string, after removing characters on the "
"left. The optional ``list-of-characters`` parameter is a set not a "
"sequence, so ``string.lstrip(...,'ABC')`` does not mean strip ``'ABC'``, "
"it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:232
#: ../doc/reference/reference_lua/string.rst:258
#: ../doc/reference/reference_lua/string.rst:316
#, fuzzy
msgid "what characters can be stripped. Default = space."
msgstr "отдельный символ, по умолчанию = 1 пробел"

#: ../doc/reference/reference_lua/string.rst:234
#: ../doc/reference/reference_lua/string.rst:260
#: ../doc/reference/reference_lua/string.rst:318
#, fuzzy
msgid "result after stripping characters from input string"
msgstr "результат после удаления пробелов из введенной строки"

#: ../doc/reference/reference_lua/string.rst:239
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.lstrip(' ABC ')\n"
"---\n"
"- 'ABC '\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.lstrip(' ABC ')\n"
"---\n"
"- 'ABC '\n"
"..."

#: ../doc/reference/reference_lua/string.rst:253
msgid ""
"Return the value of the input string, after removing characters on the "
"right. The optional ``list-of-characters`` parameter is a set not a "
"sequence, so ``string.rstrip(...,'ABC')`` does not mean strip ``'ABC'``, "
"it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:265
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rstrip(' ABC ')\n"
"---\n"
"- ' ABC'\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rstrip(' ABC ')\n"
"---\n"
"- ' ABC'\n"
"..."

#: ../doc/reference/reference_lua/string.rst:279
msgid ""
"Split ``input-string`` into one or more output strings in a table. The "
"places to split are the places where ``split-string`` occurs."
msgstr ""
"Разделение ``input-string`` на одну или более выводимых строк в таблице. "
"Места разделения указаны в ``split-string``."

#: ../doc/reference/reference_lua/string.rst:283
msgid "the string to split"
msgstr "строка для разделения"

#: ../doc/reference/reference_lua/string.rst:284
msgid "the string to find within ``input-string``. Default = space."
msgstr "искомая строка в пределах ``input-string``. По умолчанию = пробел."

#: ../doc/reference/reference_lua/string.rst:286
msgid ""
"maximum number of delimiters to process counting from the beginning of "
"the input string. Result will contain max + 1 parts maximum."
msgstr ""
"максимальное количество символов-разделителей от начала обрабатываемой "
"строки. Результат содержит не более max + 1 частей."

#: ../doc/reference/reference_lua/string.rst:290
msgid "table of strings that were split from ``input-string``"
msgstr "таблица строк, которые были разделены из ``input-string``"

#: ../doc/reference/reference_lua/string.rst:295
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.split(\"A:B C:D\", \":\", 2)\n"
"---\n"
"- - A\n"
"  - B\n"
"  - ' C:D'\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.split(\"A:B C:D\", \":\", 2)\n"
"---\n"
"- - A\n"
"  - B\n"
"  - ' C:D'\n"
"..."

#: ../doc/reference/reference_lua/string.rst:311
msgid ""
"Return the value of the input string, after removing characters on the "
"left and the right. The optional ``list-of-characters`` parameter is a "
"set not a sequence, so ``string.strip(...,'ABC')`` does not mean strip "
"``'ABC'``, it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:323
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.strip(' ABC ')\n"
"---\n"
"- ABC\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.strip(' ABC ')\n"
"---\n"
"- ABC\n"
"..."

#: ../doc/reference/reference_lua/swim.rst:5
#, fuzzy
msgid "Module `swim`"
msgstr "Модуль `os`"

#: ../doc/reference/reference_lua/swim.rst:11
msgid ""
"The ``swim`` module contains Tarantool's implementation of SWIM -- "
"Scalable Weakly-consistent Infection-style Process Group Membership "
"Protocol. It is recommended for any type of Tarantool cluster where the "
"number of nodes can be large. Its job is to discover and monitor the "
"other members in the cluster and keep their information in a \"member "
"table\". It works by sending and receiving, in a background event loop, "
"periodically, via UDP, messages."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:19
msgid "Each message has several parts, including:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:21
msgid "the ping such as \"I am checking whether you are alive\","
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:22
msgid "the event such as \"I am joining\","
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:23
msgid "the anti-entropy such as \"I know that another member exists\","
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:24
msgid ""
"the payload such as \"I or another member could have user-generated "
"data\"."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:26
msgid "The maximum message size is about 1500 bytes."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:28
msgid ""
"SWIM sends messages periodically to a random subset of the member table. "
"SWIM processes replies from those members asynchronously."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:31
#, fuzzy
msgid "Each entry in the member table has:"
msgstr "Подписка на обновления членов таблицы."

#: ../doc/reference/reference_lua/swim.rst:33
msgid "a UUID,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:34
msgid "a status (\"alive\", \"suspected\", \"dead\", or \"left\")."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:36
msgid ""
"When a member fails to acknowledge a certain number of pings, its status "
"is changed from \"alive\" to \"suspected\", that is, suspected of being "
"dead. But SWIM tries to **avoid false positives** (misidentifying members"
" as dead) which could happen when a member is overloaded and responds to "
"pings too slowly, or when there is network trouble and packets can not go"
" through some channels. When a member is suspected, SWIM randomly chooses"
" other members and sends requests to them: \"please ping this suspected "
"member\". This is called an **indirect ping**. Thus via different routes "
"and additional hops the suspected member gets additional chances to "
"reply, and thus \"refute\" the suspicion."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:47
msgid ""
"Because selection is random there is an **even network load** of about "
"one message per member per protocol step, regardless of the cluster size."
" This is a major feature of SWIM. Because the protocol depends on members"
" passing information on, also known as \"gossiping\", members do not need"
" to broadcast messages to every member, which would cause a network load "
"of N messages per member per protocol step, where N is the number of "
"members in the cluster. However, selection is not entirely random, there "
"is a preference for selecting least-recently-pinged members, like a "
"round-robin."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:56
msgid ""
"Regarding the **anti-entropy** part of a message: this is necessary for "
"maintaining the status in entries of the member table. Consider an "
"example where two members, #1 and #2, are both alive. No events happen so"
" only pings are being sent periodically. Then a third member, #3 appears."
" It knows about one of the existing members, #2. How can it discover the "
"other member? Certainly #1 could notify #2 and #2 could notify #3, but "
"messages go via UDP, so any notification event can be lost. However, "
"regular messages containing \"ping\" and/or \"event\" also can contain an"
" \"anti-entropy\" section, which is taken from a randomly-chosen part of "
"the member table. So for this example, #2 will eventually randomly add to"
" a regular message the anti-entropy note that #1 is alive, and thus #3 "
"will discover #1 even though it did not receive a direct \"I am alive\" "
"event message from #1."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:72
msgid ""
"Regarding the **UUID** part of an entry in the member table: this is "
"necessary for stable identification, because UUID changes more rarely "
"than URI (a combination of IP and port number). But if the UUID does "
"change, SWIM will include both the new and old UUID in messages, so all "
"other members will eventually learn about the new UUID and change the "
"member table accordingly."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:80
msgid ""
"Regarding the **payload** part of a message: this is not always "
"necessary, it is a feature which allows passing user-generated "
"information via SWIM instead of via node-to-node communication. The swim "
"module has methods for specifying a \"payload\", which is arbitrary user "
"data with a maximum size of about 1.2 KB. The payload can be anything, "
"and it will be eventually disseminated over the cluster and available at "
"other members. Each member can have its own payload."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:90
msgid ""
"Messages can be **encrypted**. Encryption may not be necessary in a "
"closed network but is necessary for safety if the cluster is on the "
"public Internet. Users can specify an encryption algorithm, an encryption"
" mode, and a private key. All parts of all messages (including ping, "
"acknowledgment, event, payload, URI, and UUID) will be encrypted with "
"that private key, as well as a random public key generated for each "
"message to prevent pattern attacks."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:98
msgid ""
"In theory the event dissemination speed (the number of hops to pass "
"information throughout the cluster) is ``O(log(cluster_size))``. For that"
" and other theoretical information see the Cornell University `paper "
"<https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf>`_ "
"which originally described SWIM."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:110
msgid ""
"Create a new SWIM instance. A SWIM instance maintains a member table and "
"interacts with other members. Multiple SWIM instances can be created in a"
" single Tarantool process."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:114
msgid ""
"an optional configuration parameter.  If ``cfg`` is not specified or is "
"nil, then the new SWIM instance is not bound to a socket and has nil "
"attributes, so it cannot interact with other members and only a few "
"methods are valid until :ref:`swim_object:cfg() <swim-object_cfg>` is "
"called.  If ``cfg`` is specified, then the effect is the same as calling "
"``s = swim.new() s:cfg()``, except for generation. For configuration "
"description see :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:114
#, fuzzy
msgid "an optional configuration parameter."
msgstr "Конфигурационные параметры"

#: ../doc/reference/reference_lua/swim.rst:116
msgid ""
"If ``cfg`` is not specified or is nil, then the new SWIM instance is not "
"bound to a socket and has nil attributes, so it cannot interact with "
"other members and only a few methods are valid until "
":ref:`swim_object:cfg() <swim-object_cfg>` is called."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:122
msgid ""
"If ``cfg`` is specified, then the effect is the same as calling ``s = "
"swim.new() s:cfg()``, except for generation. For configuration "
"description see :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:128
msgid ""
"The generation part of ``cfg`` can only be specified during ``new()``, it"
" cannot be specified later during ``cfg()``. Generation is part of "
":ref:`incarnation <swim-incarnation_description>`. Usually generation is "
"not specified because the default value (a timestamp) is sufficient, but "
"if there is reason to mistrust timestamps (because the time is changed or"
" because the instance is started on a different machine), then users may "
"say :samp:`swim.new({generation = {new-value}`. In that case the latest "
"value should be persisted somehow (for example in a file, or in a space, "
"or in a global service), and the new value must be greater than any "
"previous value of generation."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:140
msgid "swim-object :ref:`a swim object <swim-object>`"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:144
msgid ""
"swim_object = swim.new({uri = 3333, uuid = "
"'00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:152
msgid ""
"A swim object is an object returned by :ref:`swim.new() <swim-new>`. It "
"has methods: :ref:`cfg() <swim-object_cfg>`, :ref:`delete() <swim-"
"delete>`, :ref:`is_configured() <swim-is_configured>`, :ref:`size() "
"<swim-size>`, :ref:`quit() <swim-quit>`, :ref:`add_member() <swim-"
"add_member>`, :ref:`remove_member() <swim-remove_member>`, "
":ref:`probe_member() <swim-probe_member>`, :ref:`broadcast() <swim-"
"broadcast>`, :ref:`set_payload() <swim-set_payload>`, "
":ref:`set_payload_raw() <swim-set_payload_raw>`, :ref:`set_codec() <swim-"
"set_codec>`, :ref:`self() <swim-self>`, :ref:`member_by_uuid() <swim-"
"member_by_uuid>`, :ref:`pairs() <swim-pairs>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:174
msgid "Configure or reconfigure a SWIM instance."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:176
msgid "the options to describe instance behavior"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:178
msgid "The ``cfg`` table may have these components:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:180
msgid ""
"``heartbeat_rate`` (double) -- rate of sending round messages, in "
"seconds. Setting ``heartbeat_rate`` to X does not mean that every member "
"will be checked every X seconds, instead X is the protocol speed. "
"Protocol period depends on member count and heartbeat_rate. Default = 1."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:186
msgid ""
"``ack_timeout`` (double) -- time in seconds after which a ping is "
"considered to be unacknowledged. Default = 30."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:189
msgid "``gc_mode`` (enum) -- dead member collection mode."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:191
msgid ""
"If ``gc_mode == 'off'`` then SWIM never removes dead members from the "
"member table (though users may remove them with "
":ref:`swim_object:remove_member() <swim-remove_member>`), and SWIM will "
"continue to ping them as if they were alive."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:196
msgid ""
"If ``gc_mode == 'on'`` then SWIM removes dead members from the member "
"table after one round."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:199
#, fuzzy
msgid "Default = ``'on'``."
msgstr "По умолчанию = нулевое значение nil"

#: ../doc/reference/reference_lua/swim.rst:201
msgid ""
"``uri`` (string or number) -- either an ``'ip:port'`` address, or just a "
"port number (if ip is omitted then 127.0.0.1 is assumed). If ``port == "
"0``, then the kernel will select any free port for the IP address."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:206
msgid ""
"``uuid`` (string or cdata struct tt_uuid) -- a value which should be "
"unique among SWIM instances. Users may choose any value but the "
"recommendation is: use :ref:`box.cfg.instance_uuid <cfg_replication-"
"instance_uuid>`, the Tarantool instance's UUID."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:212
msgid ""
"All the ``cfg`` components are dynamic -- ``swim_object:cfg()`` may be "
"called more than once. If it is not being called for the first time and a"
" component is not specified, then the component retains its previous "
"value. If it is being called for the first time then uri and uuid are "
"mandatory, since a SWIM instance cannot operate without URI and UUID."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:219
msgid ""
"``swim_object:cfg()`` is atomic -- if there is an error, then nothing "
"changes."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:222
#, fuzzy
msgid "true if configuration succeeds"
msgstr "конфигурационная таблица"

#: ../doc/reference/reference_lua/swim.rst:223
#: ../doc/reference/reference_lua/swim.rst:334
#: ../doc/reference/reference_lua/swim.rst:515
#: ../doc/reference/reference_lua/swim.rst:547
msgid "nil, ``err`` if an error occurred. ``err`` is an error object"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:227
msgid "swim_object:cfg({heartbeat_rate = 0.5})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:231
msgid ""
"After ``swim_object:cfg()``, all other ``swim_object`` methods are "
"callable."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:235
msgid ""
"Expose all non-nil components of the read-only table which was set up or "
"changed by :ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:240
msgid ""
"tarantool> swim_object.cfg\n"
"---\n"
"- gc_mode: off\n"
"  uri: 3333\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:253
msgid ""
"Delete a SWIM instance immediately. Its memory is freed, its member table"
" entry is deleted, and it can no longer be used. Other members will treat"
" this member as 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:258
msgid ""
"After ``swim_object:delete()`` any attempt to use the deleted instance "
"will cause an exception to be thrown."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:261
msgid "none, this method does not fail"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:263
msgid "Example: ``swim_object:delete()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:269
msgid ""
"Return false if a SWIM instance was created via :ref:`swim.new() <swim-"
"new>` without an optional ``cfg`` argument, and was not configured with "
":ref:`swim_object:cfg() <swim-object_cfg>`. Otherwise return true."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:275
msgid "boolean result, true if configured, otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:277
msgid "Example: ``swim_object:is_configured()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:283
msgid ""
"Return the size of the member table. It will be at least 1 because the "
"\"self\" member is included."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:286
#, fuzzy
msgid "integer size"
msgstr "целое число"

#: ../doc/reference/reference_lua/swim.rst:288
#, fuzzy
msgid "Example: ``swim_object:size()``"
msgstr "Вызов ``fiber_object:join()``."

#: ../doc/reference/reference_lua/swim.rst:294
#, fuzzy
msgid "Leave the cluster."
msgstr "уровень стека"

#: ../doc/reference/reference_lua/swim.rst:296
msgid ""
"This is a graceful equivalent of :ref:`swim_object:delete() <swim-"
"delete>` -- the instance is deleted, but before deletion it sends to each"
" member in its member table a message, that this instance has left the "
"cluster, and should not be considered dead."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:302
msgid ""
"Other instances will mark such a member in their tables as 'left', and "
"drop it after one round of dissemination."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:306
msgid ""
"Consequences to the caller are the same as after ``swim_object:delete()``"
" -- the instance is no longer usable, and an error will be thrown if "
"there is an attempt to use it."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:310
msgid "none, the method does not fail"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:312
#, fuzzy
msgid "Example: ``swim_object:quit()``"
msgstr "Вызов ``fiber_object:join()``."

#: ../doc/reference/reference_lua/swim.rst:318
msgid "Explicitly add a member into the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:320
msgid ""
"This method is useful when a new member is joining the cluster and does "
"not yet know what members already exist. In that case it can start "
"interaction explicitly by adding the details about an already-existing "
"member into its member table. Subsequently SWIM will discover other "
"members automatically via messages from the already-existing member."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:328
#, fuzzy
msgid "description of the member"
msgstr "Получение описания последней ошибки"

#: ../doc/reference/reference_lua/swim.rst:330
msgid ""
"The ``cfg`` table has two mandatory components, ``uuid`` and ``uri``, "
"which have the same format as ``uuid`` and ``uri`` in the table for "
":ref:`swim_object:cfg() <swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:333
msgid "true if member is added"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:338
msgid "swim_member_object = swim_object:add_member({uuid = ..., uri = ...})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:346
msgid "Explicitly and immediately remove a member from the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:349
#: ../doc/reference/reference_lua/swim.rst:707
msgid "UUID"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:351
msgid "true if member is removed"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:352
#: ../doc/reference/reference_lua/swim.rst:374
#: ../doc/reference/reference_lua/swim.rst:394
msgid "nil, ``err`` if an error occurred. ``err`` is an error object."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:354
msgid "Example: ``swim_object:delete('00000000-0000-1000-8000-000000000001')``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:360
msgid ""
"Send a ping request to the specified ``uri`` address. If another member "
"is listening at that address, it will receive the ping, and respond with "
"an ACK (acknowledgment) message containing information such as UUID. That"
" information will be added to the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:366
msgid ""
"``swim_object:probe_member()`` is similar to "
":ref:`swim_object:add_member() <swim-add_member>`, but it does not "
"require UUID, and it is not reliable because it uses UDP."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:370
msgid ""
"URI. Format is the same as for ``uri`` in :ref:`swim_object:cfg() <swim-"
"object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:373
#, fuzzy
msgid "true if member is pinged"
msgstr "Проверка принадлежности члена к группе."

#: ../doc/reference/reference_lua/swim.rst:376
msgid "Example: ``swim_object:probe_member(3333)``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:382
msgid "Broadcast a ping request to all the network interfaces in the system."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:385
msgid ""
"``swim_object:broadcast()`` is like :ref:`swim_object:probe_member() "
"<swim-probe_member>` to many members at once."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:389
msgid ""
"All the sent ping requests have this port as destination port in their "
"UDP headers. By default a currently bound port is used."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:393
msgid "true if broadcast is sent"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:398
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 3333, uuid = "
"'00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 3334, uuid = "
"'00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = "
"s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s1:remove_member(s2:self():uuid()) "
"s2:remove_member(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"\n"
"tarantool> s1:probe_member(s2:self():uri())\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.1)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s1:remove_member(s2:self():uuid()) "
"s2:remove_member(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s1:broadcast(3334)\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.1)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:499
#, fuzzy
msgid "Set a payload, as formatted data."
msgstr "Получение даты в формате"

#: ../doc/reference/reference_lua/swim.rst:501
msgid ""
"Payload is arbitrary user defined data up to 1200 bytes in size and "
"disseminated over the cluster. So each cluster member will eventually "
"learn what is the payload of other members in the cluster, because it is "
"stored in the member table and can be queried with "
":ref:`swim_member_object:payload() <swim-payload>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:507
msgid "Different members may have different payloads."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:509
msgid ""
"Arbitrary Lua object to disseminate. Set to nil to remove the payload, in"
" which case it will be eventually removed on other instances. The object "
"is serialized in MessagePack."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:514
#: ../doc/reference/reference_lua/swim.rst:546
msgid "true if payload is set"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:519
msgid "swim_object:set_payload({field1 = 100, field2 = 200})"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:527
msgid "Set a payload, as raw data."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:529
msgid ""
"Sometimes a payload does not need to be a Lua object. For example, a user"
" may already have a well formatted MessagePack object and just wants to "
"set it as a payload. Or cdata needs to be exposed."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:534
msgid ""
"``set_payload_raw`` allows setting a payload as is, without MessagePack "
"serialization."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:537
msgid "any value"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:539
msgid ""
"Payload size in bytes. If ``payload`` is string then ``size`` is "
"optional, and if specified, then should not be larger than actual "
"``payload`` size. If ``size`` is less than actual ``payload`` size, then "
"only the first ``size`` bytes of ``payload`` are used. If ``payload`` is "
"cdata then ``size`` is mandatory."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:551
msgid ""
"tarantool> tarantool> ffi = require('ffi')\n"
"---\n"
"...\n"
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = "
"'00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 0, uuid = "
"'00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = "
"s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s1:set_payload({a = 100, b = 200})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s2:set_payload('any payload')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1_view = s2:member_by_uuid(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s2_view = s1:member_by_uuid(s2:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1_view:payload()\n"
"---\n"
"- {'a': 100, 'b': 200}\n"
"...\n"
"tarantool> s2_view:payload()\n"
"---\n"
"- any payload\n"
"...\n"
"tarantool> cdata = ffi.new('char[?]', 2)\n"
"---\n"
"...\n"
"tarantool> cdata[0] = 1\n"
"---\n"
"...\n"
"tarantool> cdata[1] = 2\n"
"---\n"
"...\n"
"tarantool> s1:set_payload_raw(cdata, 2)\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> cdata, size = s1_view:payload_cdata()\n"
"---\n"
"...\n"
"tarantool> cdata[0]\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> cdata[1]\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> size\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:633
msgid "Enable encryption for all following messages."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:635
msgid ""
"For a brief description of encryption algorithms see \"enum_crypto_algo\""
" and \"enum crypto_mode\" in the Tarantool source code file `crypto.h "
"<https://github.com/tarantool/tarantool/blob/master/src/lib/crypto/crypto.h>`_."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:640
msgid ""
"When encryption is enabled, all the messages are encrypted with a chosen "
"private key, and a randomly generated and updated public key."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:644
#, fuzzy
msgid "description of the encryption"
msgstr "Функции подписки"

#: ../doc/reference/reference_lua/swim.rst:646
msgid "The components of the ``codec_cfg`` table may be:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:648
msgid ""
"``algo`` (string) -- encryption algorithm name. All the names in "
":ref:`module crypto <crypto>` are supported: 'aes128', 'aes192', "
"'aes256', 'des'. Specify 'none' to disable encryption."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:653
msgid ""
"``mode`` (string) -- encryption algorithm mode. All the modes in module "
"``crypto`` are supported: 'ecb', 'cbc', 'cfb', 'ofb'. Default = 'cbc'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:657
msgid ""
"``key`` (cdata or string) -- a private secret key which is kept secret "
"and should never be stored hard-coded in source code."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:660
msgid "``key_size`` (integer) -- size of the key in bytes."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:662
msgid "``key_size`` is mandatory if key is cdata."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:664
msgid ""
"``key_size`` is optional if key is string, and if ``key_size`` is shorter"
" than than actual key size then the key is truncated."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:668
msgid ""
"All of ``algo``, ``mode``, ``key``, and ``key_size`` should be the same "
"for all SWIM instances, so that members can understand each others' "
"messages."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:672
#, fuzzy
msgid "Example;"
msgstr "Пример"

#: ../doc/reference/reference_lua/swim.rst:674
msgid ""
"tarantool> tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = "
"'00000000-0000-1000-8000-000000000001'})\n"
"---\n"
"...\n"
"tarantool> s1:set_codec({algo = 'aes128', mode = 'cbc', key = "
"'1234567812345678'})\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:691
msgid ""
"Return a :ref:`swim member object <swim-member_object>` (of self) from "
"the member table, or from a cache containing earlier results of "
"``swim_object:self()`` or ``swim_object:member_by_uuid()`` or "
"``swim_object:pairs()``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:695
msgid ""
":ref:`swim member object <swim-member_object>`, not nil because self() "
"will not fail"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:697
msgid "Example: ``swim_member_object = swim_object:self()``"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:703
msgid ""
"Return a :ref:`swim member object <swim-member_object>` (given UUID) from"
" the member table, or from a cache containing earlier results of "
"``swim_object:self()`` or ``swim_object:member_by_uuid()`` or "
"``swim_object:pairs()``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:709
msgid ":ref:`swim member object <swim-member_object>`, or nil if not found"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:713
msgid ""
"swim_member_object = "
"swim_object:member_by_uuid('00000000-0000-1000-8000-000000000001')"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:721
msgid ""
"Set up an iterator for returning :ref:`swim member objects <swim-"
"member_object>` from the member table, or from a cache containing earlier"
" results of ``swim_object:self()`` or ``swim_object:member_by_uuid()`` or"
" ``swim_object:pairs()``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:726
msgid ""
"``swim_object:pairs()`` should be in a 'for' loop, and there should only "
"be one iterator in operation at one time. (The iterator is implemented in"
" an extra light fashion so only one iterator object is available per SWIM"
" instance.)"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:731
msgid ""
"as for any Lua pairs() iterators. generator function, iterator object (a "
"swim member object), and initial key (a UUID)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:738
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = "
"'00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 0, uuid = "
"'00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = "
"s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1:self()\n"
"---\n"
"- uri: 127.0.0.1:55845\n"
"  status: alive\n"
"  incarnation: cdata {generation = 1569353431853325ULL, version = 1ULL}\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"  payload_size: 0\n"
"...\n"
"tarantool> s1:member_by_uuid(s1:self():uuid())\n"
"---\n"
"- uri: 127.0.0.1:55845\n"
"  status: alive\n"
"  incarnation: cdata {generation = 1569353431853325ULL, version = 1ULL}\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"  payload_size: 0\n"
"...\n"
"tarantool> s1:member_by_uuid(s2:self():uuid())\n"
"---\n"
"- uri: 127.0.0.1:53666\n"
"  status: alive\n"
"  incarnation: cdata {generation = 1569353431865138ULL, version = 1ULL}\n"
"  uuid: 00000000-0000-1000-8000-000000000002\n"
"  payload_size: 0\n"
"...\n"
"tarantool> t = {}\n"
"---\n"
"...\n"
"tarantool> for k, v in s1:pairs() do table.insert(t, {k, v}) end\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- - - 00000000-0000-1000-8000-000000000002\n"
"    - uri: 127.0.0.1:53666\n"
"      status: alive\n"
"      incarnation: cdata {generation = 1569353431865138ULL, version = "
"1ULL}\n"
"      uuid: 00000000-0000-1000-8000-000000000002\n"
"      payload_size: 0\n"
"  - - 00000000-0000-1000-8000-000000000001\n"
"    - uri: 127.0.0.1:55845\n"
"      status: alive\n"
"      incarnation: cdata {generation = 1569353431853325ULL, version = "
"1ULL}\n"
"      uuid: 00000000-0000-1000-8000-000000000001\n"
"      payload_size: 0\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:809
msgid ""
"Methods :ref:`swim_object:member_by_uuid() <swim-member_by_uuid>`, "
":ref:`swim_object:self() <swim-self>`, and :ref:`swim_object:pairs() "
"<swim-pairs>` return swim member objects."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:815
msgid ""
"A swim member object has methods for reading its attributes: "
":ref:`status() <swim-status>`, :ref:`uuid <swim-uuid>`, :ref:`uri() "
"<swim-uri>`, :ref:`incarnation() <swim-incarnation>`, :ref:`payload_cdata"
" <swim-payload_cdata>`, :ref:`payload_str() <swim-payload_str>`, "
":ref:`payload() <swim-payload>`, :ref:`is_dropped() <swim-is_dropped>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:830
msgid "Return the status, which may be 'alive', 'suspected', 'left', or 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:833
msgid "string 'alive' | 'suspected' | 'left' | dead'"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:839
msgid "Return the UUID as cdata struct tt_uuid."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:841
msgid "cdata-struct-tt-uuid UUID"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:847
msgid ""
"Return the URI as a string 'ip:port'. Via this method a user can learn a "
"real assigned port, if port = 0 was specified in :ref:`swim_object:cfg() "
"<swim-object_cfg>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:852
#, fuzzy
msgid "string ip:port"
msgstr "хост:порт"

#: ../doc/reference/reference_lua/swim.rst:858
msgid ""
"Return a cdata object with the :ref:`incarnation <swim-"
"incarnation_description>`. The cdata object has two attributes: "
"incarnation().generation and incarnation().version."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:862
msgid ""
"Incarnations can be compared to each other with any comparison operator "
"(==, <, >, <=, >=, ~=)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:865
msgid ""
"Incarnations, when printed, will appear as strings with both generation "
"and version."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:868
#, fuzzy
msgid "cdata incarnation"
msgstr "Увеличивает значение параметра ``incarnation``."

#: ../doc/reference/reference_lua/swim.rst:874
msgid "Return member's payload."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:876
msgid "pointer-to-cdata payload and size in bytes"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:882
msgid ""
"Return payload as a string object. Payload is not decoded. It is just "
"returned as a string instead of cdata. If payload was not specified by "
":ref:`swim_object:set_payload() <swim-set_payload>` or by "
":ref:`swim_object:set_payload_raw() <swim-set_payload_raw>`, then its "
"size is 0 and nil is returned."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:889
msgid "string-object payload, or nil if there is no payload"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:895
msgid ""
"Since the ``swim`` module is a Lua module, a user is likely to use Lua "
"objects as a payload -- tables, numbers, strings etc. And it is natural "
"to expect that :ref:`swim_member_object:payload() <swim-payload>` should "
"return the same object which was passed into "
":ref:`swim_object:set_payload() <swim-set_payload>` by another instance. "
"``swim_member_object:payload()`` tries to interpret payload as "
"MessagePack, and if that fails then it returns the payload as a string."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:906
msgid ""
"``swim_member_object:payload()`` caches its result. Therefore only the "
"first call actually decodes cdata payload. All following calls return a "
"pointer to the same result, unless payload is changed with a new "
"incarnation. If payload was not specified (its size is 0), then nil is "
"returned."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:916
msgid ""
"Returns true if this member object is a stray reference to a member which"
" has already been dropped from the member table."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:919
#, fuzzy
msgid "boolean true if member is dropped, otherwise false"
msgstr ""
"true (правда), если значение состоит из одних нулей, в противном случае "
"false (ложь)."

#: ../doc/reference/reference_lua/swim.rst:923
msgid ""
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s = swim.new({uri = 0, uuid = "
"'00000000-0000-1000-8000-000000000001'})\n"
"---\n"
"...\n"
"tarantool> self = s:self()\n"
"---\n"
"...\n"
"tarantool> self:status()\n"
"---\n"
"- alive\n"
"...\n"
"tarantool> self:uuid()\n"
"---\n"
"- 00000000-0000-1000-8000-000000000001\n"
"...\n"
"tarantool> self:uri()\n"
"---\n"
"- 127.0.0.1:56367\n"
"...\n"
"tarantool> self:incarnation()\n"
"---\n"
"- - cdata {generation = 1569354463981551ULL, version = 1ULL}\n"
"...\n"
"tarantool> self:is_dropped()\n"
"---\n"
"- false\n"
"...\n"
"tarantool> s:set_payload_raw('123')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> self:payload_cdata()\n"
"---\n"
"- 'cdata<const char *>: 0x0103500050'\n"
"- 3\n"
"...\n"
"tarantool> self:payload_str()\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> s:set_payload({a = 100})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> self:payload_cdata()\n"
"---\n"
"- 'cdata<const char *>: 0x0103500050'\n"
"- 4\n"
"...\n"
"tarantool> self:payload_str()\n"
"---\n"
"- !!binary gaFhZA==\n"
"...\n"
"tarantool> self:payload()\n"
"---\n"
"- {'a': 100}\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:989
msgid ""
"Create an \"on_member :ref:`trigger <triggers>`\". The ``trigger-"
"function`` will be executed when a member in the member table is updated."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:992
#, fuzzy
msgid "this will become the trigger function"
msgstr "что передается в функцию"

#: ../doc/reference/reference_lua/swim.rst:993
#, fuzzy
msgid "(optional) this will be passed to trigger-function"
msgstr "что передается в функцию"

#: ../doc/reference/reference_lua/swim.rst:995
#, fuzzy
msgid "nil or function pointer."
msgstr "функция или ссылка на функцию"

#: ../doc/reference/reference_lua/swim.rst:997
msgid ""
"The **trigger-function** should have three parameter declarations "
"(Tarantool will pass values for them when it invokes the function):"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1000
msgid "the member which is having the member event,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1001
#, fuzzy
msgid "the event object,"
msgstr "объект ``object``"

#: ../doc/reference/reference_lua/swim.rst:1002
msgid ""
"the ``ctx`` which will be the same value as what is passed to "
"``swim_object:on_member_event``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1005
msgid "A **member event** is any of:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1007
msgid "appearance of a new member,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1008
msgid "drop of an existing member, or"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1009
msgid "update of an existing member."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1011
msgid ""
"An **event object** is an object which the trigger-function can use for "
"determining what type of member event has happened. The object's methods "
"-- such as ``is_new_status()``, ``is_new_uri()``, "
"``is_new_incarnation()``, ``is_new_payload()``, ``is_drop()`` -- return "
"boolean values."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1017
msgid ""
"A member event may have more than one associated **trigger**. Triggers "
"are executed sequentially. Therefore if a trigger function causes yields "
"or sleeps, other triggers may be forced to wait. However, since trigger "
"execution is done in a separate fiber, SWIM itself is not forced to wait."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1024
msgid "Example of an on-member trigger function:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1026
msgid ""
"tarantool> swim = require('swim')\n"
"\n"
"local function on_event(member, event, ctx)\n"
"    if event:is_new() then\n"
"        ...\n"
"    elseif event:is_drop() then\n"
"        ...\n"
"    end\n"
"\n"
"    if event:is_update() then\n"
"        -- All next conditions can be\n"
"        -- true simultaneously.\n"
"        if event:is_new_status() then\n"
"...\n"
"        end\n"
"        if event:is_new_uri() then\n"
"...\n"
"        end\n"
"        if event:is_new_incarnation() then\n"
"...\n"
"        end\n"
"        if event:is_new_payload() then\n"
"...\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1055
msgid ""
"Notice in the above example that the function is ready for the "
"possibility that multiple events can happen simultaneously for a single "
"trigger activation. ``is_new()`` and ``is_drop()`` can not both be true, "
"but ``is_new()`` and ``is_update()`` can both be true, or ``is_drop()`` "
"and ``is_update()`` can both be true. Multiple simultaneous events are "
"especially likely if there are many events and trigger functions are slow"
" -- in that case, for example, a member might be added and then updated "
"after a while, and then after a while there will be a single trigger "
"activation."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1067
msgid ""
"Also: ``is_new()`` and ``is_new_payload()`` can both be true. This case "
"is not due to trigger functions that are slow. It occurs because "
"\"omitted payload\" and \"size-zero payload\" are not the same thing. For"
" example: when a ping is received, a new member might be added, but ping "
"messages do not include payload. The payload will appear later in a "
"different message. If that is important for the application, then the "
"function should not assume when ``is_new()`` is true that the member "
"already has a payload, and should not assume that payload size says "
"something about the payload's presence or absence."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1078
msgid ""
"Also: functions should not assume that ``is_new()`` and ``is_drop()`` "
"will always be seen. If a new member appears but then is dropped before "
"its appearance has caused a trigger activation, then there will be no "
"trigger activation."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1084
msgid ""
"``is_new_generation()`` will be true if the generation part of "
":ref:`incarnation <swim-incarnation_description>` changes. "
"``is_new_version()`` will be true if the version part of incarnation "
"changes. ``is_new_incarnation()`` will be true if either the generation "
"part or the version part of incarnation changes. For example a "
"combination of these methods can be used within a user-defined trigger to"
" check whether a process has restarted, or a member has changed ..."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1094
msgid ""
"swim = require('swim')\n"
"s = swim.new()\n"
"s:on_member_event(function(m, e)\n"
"...\n"
"    if e:is_new_incarnation() then\n"
"        if e:is_new_generation() then\n"
"            -- Process restart.\n"
"        end\n"
"        if e:is_new_version() then\n"
"            -- Process version update. It means\n"
"            -- the member is somehow changed.\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1113
#, fuzzy
msgid "Delete an on-member trigger."
msgstr "Создание подключения"

#: ../doc/reference/reference_lua/swim.rst:1115
msgid "old-trigger"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1117
#: ../doc/reference/reference_lua/swim.rst:1132
msgid ""
"The old-trigger value should be the value returned by ``on_member_event"
"(trigger-function[, ctx])``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1122
msgid "This is a variation of ``on_member_event(new-trigger, [, ctx])``."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1124
msgid ""
"The additional parameter is ``old-trigger``. Instead of adding the new-"
"trigger at the end of a list of triggers, this function will replace the "
"entry in the list of triggers that matches old-trigger. The position "
"within a list may be important because triggers are activated "
"sequentially starting with the first trigger in the list."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1137
msgid "Return the list of on-member triggers."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1141
msgid "SWIM internals"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1143
msgid ""
"The SWIM internals section is not necessary for programmers who wish to "
"use the SWIM module, it is for programmers who wish to change or replace "
"the SWIM module."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1146
msgid ""
"The SWIM wire protocol is open, will be backward compatible in case of "
"any changes, and can be implemented by users who wish to simulate their "
"own SWIM cluster members because they use another language than Lua, or "
"another environment unrelated to Tarantool. The protocol is encoded as "
"`MsgPack <https://en.wikipedia.org/wiki/MessagePack>`_."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1153
msgid ""
"SWIM packet structure:\n"
"\n"
"+-----------------Public data, not encrypted------------------+\n"
"|                                                             |\n"
"|      Initial vector, size depends on chosen algorithm.      |\n"
"|                   Next data is encrypted.                   |\n"
"|                                                             |\n"
"+----------Meta section, handled by transport level-----------+\n"
"| map {                                                       |\n"
"|     0 = SWIM_META_TARANTOOL_VERSION: uint, Tarantool        |\n"
"|                                      version ID,            |\n"
"|     1 = SWIM_META_SRC_ADDRESS: uint, ip,                    |\n"
"|     2 = SWIM_META_SRC_PORT: uint, port,                     |\n"
"|     3 = SWIM_META_ROUTING: map {                            |\n"
"|         0 = SWIM_ROUTE_SRC_ADDRESS: uint, ip,               |\n"
"|         1 = SWIM_ROUTE_SRC_PORT: uint, port,                |\n"
"|         2 = SWIM_ROUTE_DST_ADDRESS: uint, ip,               |\n"
"|         3 = SWIM_ROUTE_DST_PORT: uint, port                 |\n"
"|     }                                                       |\n"
"| }                                                           |\n"
"+-------------------Protocol logic section--------------------+\n"
"| map {                                                       |\n"
"|     0 = SWIM_SRC_UUID: 16 byte UUID,                        |\n"
"|                                                             |\n"
"|                 AND                                         |\n"
"|                                                             |\n"
"|     2 = SWIM_FAILURE_DETECTION: map {                       |\n"
"|         0 = SWIM_FD_MSG_TYPE: uint, enum swim_fd_msg_type,  |\n"
"|         1 = SWIM_FD_GENERATION: uint,                       |\n"
"|         2 = SWIM_FD_VERSION: uint                           |\n"
"|     },                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     3 = SWIM_DISSEMINATION: array [                         |\n"
"|         map {                                               |\n"
"|             0 = SWIM_MEMBER_STATUS: uint,                   |\n"
"|                                     enum member_status,     |\n"
"|             1 = SWIM_MEMBER_ADDRESS: uint, ip,              |\n"
"|             2 = SWIM_MEMBER_PORT: uint, port,               |\n"
"|             3 = SWIM_MEMBER_UUID: 16 byte UUID,             |\n"
"|             4 = SWIM_MEMBER_GENERATION: uint,               |\n"
"|             5 = SWIM_MEMBER_VERSION: uint,                  |\n"
"|             6 = SWIM_MEMBER_PAYLOAD: bin                    |\n"
"|         },                                                  |\n"
"|         ...                                                 |\n"
"|     ],                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     1 = SWIM_ANTI_ENTROPY: array [                          |\n"
"|         map {                                               |\n"
"|             0 = SWIM_MEMBER_STATUS: uint,                   |\n"
"|                                     enum member_status,     |\n"
"|             1 = SWIM_MEMBER_ADDRESS: uint, ip,              |\n"
"|             2 = SWIM_MEMBER_PORT: uint, port,               |\n"
"|             3 = SWIM_MEMBER_UUID: 16 byte UUID,             |\n"
"|             4 = SWIM_MEMBER_GENERATION: uint,               |\n"
"|             5 = SWIM_MEMBER_VERSION: uint,                  |\n"
"|             6 = SWIM_MEMBER_PAYLOAD: bin                    |\n"
"|         },                                                  |\n"
"|         ...                                                 |\n"
"|     ],                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     4 = SWIM_QUIT: map {                                    |\n"
"|         0 = SWIM_QUIT_GENERATION: uint,                     |\n"
"|         1 = SWIM_QUIT_VERSION: uint                         |\n"
"|     }                                                       |\n"
"| }                                                           |\n"
"+-------------------------------------------------------------+"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1228
msgid ""
"The **Initial vector section** appears only when encryption is enabled. "
"This section contains a public key. For example, for AES algorithms it is"
" a 16-byte initial vector stored as is. When no encryption is used, the "
"section size is 0."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1233
msgid ""
"The later sections (Meta and Protocol Logic) are encrypted as one big "
"data chunk if encryption is enabled."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1236
msgid ""
"The **Meta section** handles routing and protocol versions compatibility."
" It works at the 'transport' level of the SWIM protocol, and is always "
"present. Keys in the meta section are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1240
msgid ""
"SWIM_META_TARANTOOL_VERSION -- mandatory field. Tarantool sets here its "
"version as a 3 byte integer:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1243
msgid "1 byte for major,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1244
msgid "1 byte for minor,"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1245
msgid "1 byte for patch."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1247
msgid ""
"For example, Tarantool version 2.1.3 would be encoded like this: ``(((2 "
"<< 8) | 1) << 8) | 3;``. This field will be used to support multiple "
"versions of the protocol."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1251
msgid ""
"SWIM_META_SRC_ADDRESS and SWIM_META_SRC_PORT -- mandatory. source IP "
"address and port. IP is encoded as 4 bytes. \"xxx.xxx.xxx.xxx\" where "
"each 'xxx' is encoding of one byte. Port is encoded as an integer. "
"Example of how to encode \"127.0.0.1:3313\":"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1256
msgid ""
"struct in_addr addr;\n"
"inet_aton(\"127.0.0.1\", &addr);\n"
"pos = mp_encode_uint(pos, SWIM_META_SRC_ADDRESS);\n"
"pos = mp_encode_uint(pos, addr->s_addr);\n"
"pos = mp_encode_uint(pos, SWIM_META_SRC_PORT);\n"
"pos = mp_encode_uint(pos, 3313);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1265
msgid ""
"SWIM_META_ROUTING subsection -- not mandatory. Responsible for packet "
"forwarding. Used by SWIM suspicion mechanism. Read about suspicion in the"
" SWIM paper."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1269
msgid "If this subsection is present then the following fields are mandatory:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1272
msgid ""
"SWIM_ROUTE_SRC_ADDRESS and SWIM_ROUTE_SRC_PORT (source IP address and "
"port) (should be an address of the message originator (can differ from"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1275
msgid "SWIM_META_SRC_ADDRESS and from SWIM_META_SRC_ADDRESS_PORT);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1276
msgid ""
"SWIM_ROUTE_DST_ADDRESS and SWIM_ROUTE_DST_PORT (destination IP address "
"and port, for the the message's final destination)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1279
msgid ""
"If a message was sent indirectly with the help of SWIM_META_ROUTING, then"
" the reply should be sent back by the same route."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1282
msgid ""
"For an example of how SWIM uses routing for indirect pings ... Assume "
"there are 3 nodes: S1, S2, S3. S1 sends a message to S3 via S2. The "
"following steps are executed in order to deliver the message:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1287
msgid ""
"S1 -> S2\n"
"{ src: S1, routing: {src: S1, dst: S3}, body: ... }"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1292
msgid ""
"S2 receives the message and sees that routing.dst is not equal to S2, so "
"it is a foreign packet. S2 forwards the packet to S3 preserving all the "
"data including body and routing sections."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1296
msgid "S2 -> S3"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1300
msgid ""
"S3 receives the message and sees that routing.dst is equal to S3, so the "
"message is delivered. If S3 wants to answer, it sends a response via the "
"same proxy. It knows that the message was delivered from S2, so it sends "
"an answer via S2."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1305
msgid ""
"The **Protocol logic section** handles SWIM logical protocol steps and "
"actions."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1307
msgid ""
"SWIM_SRC_UUID -- mandatory field. SWIM uses UUID as a unique identifier "
"of a member, not IP/port. This field stores UUID of sender. Its type is "
"MP_BIN. Size is always 16 bytes. UUID is encoded in host byte order, no "
"bswaps are needed."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1312
msgid ""
"Following SWIM_SRC_UUID there are four possible subsections: "
"SWIM_FAILURE_DETECTION, SWIM_DISSEMINATION, SWIM_ANTI_ENTROPY, SWIM_QUIT."
" Any or all of these subsections may be present. A connector should be "
"ready to handle any combination."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1317
msgid ""
"SWIM_FAILURE_DETECTION subsection -- describes a ping or ACK. In the "
"SWIM_FAILURE_DETECTION subsection are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1320
msgid "SWIM_FD_MSG_TYPE (0 is ping, 1 is ack);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1321
msgid ""
"SWIM_FD_GENERATION + SWIM_FD_VERSION (the :ref:`incarnation <swim-"
"incarnation_description>`)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1323
msgid ""
"SWIM_DISSEMINATION subsection -- a list of changed cluster members. It "
"may include only a subset of changed cluster members if there are too "
"many changes to fit into one UDP packet."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1327
msgid "In the SWIM_DISSEMINATION subsection are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1329
msgid ""
"SWIM_MEMBER_STATUS (mandatory) (0 = alive, 1 = suspected, 2 = dead, 3 = "
"left);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1330
msgid "SWIM_MEMBER_ADDRESS and SWIM_MEMBER_PORT (mandatory) member IP and port;"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1331
msgid "SWIM_MEMBER_UUID (mandatory) (member UUID);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1332
msgid ""
"SWIM_MEMBER_GENERATION + SWIM_MEMBER_VERSION (mandatory) (the member "
":ref:`incarnation <swim-incarnation_description>`);"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1333
msgid ""
"SWIM_MEMBER_PAYLOAD (not mandatory) (member payload) (MessagePack type is"
" MP_BIN)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1336
msgid ""
"Note that absence of SWIM_MEMBER_PAYLOAD means nothing - it is not the "
"same as a payload with zero size."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1339
msgid ""
"SWIM_ANTI_ENTROPY subsection -- a helper for the dissemination. It "
"contains all the same fields as the dissemination sub, but all of them "
"are mandatory, including payload even when payload size is 0. Anti-"
"entropy eventually spreads changes which for any reason are not spread by"
" the dissemination."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1345
msgid ""
"SWIM_QUIT subsection -- statement that the sender has left the cluster "
"gracefully, for example via :ref:`swim_object:quit() <swim-quit>`, and "
"should not be considered dead. Sender status should be changed to 'left'."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1350
msgid "In the SWIM_QUIT subsection are:"
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1352
msgid ""
"SWIM_QUIT_GEMERATOPM + SWIM_QUIT_VERSION (the sender :ref:`incarnation "
"<swim-incarnation_description>`)."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1356
msgid ""
"The **incarnation** is a 128-bit cdata value which is part of each "
"member's configuration and is present in most messages. It has two parts:"
" generation and version."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1360
msgid ""
"Generation is persistent. By default it has the number of microseconds "
"since the epoch (compare the value returned by :ref:`clock_realtime64() "
"<clock-time>`). Optionally a user can set generation during :ref:`new() "
"<swim-new>`."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1365
msgid ""
"Version is volatile. It is initially 0. It is incremented automatically "
"every time that a change occurs."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1368
msgid ""
"The incarnation, or sometimes the version alone, is useful for deciding "
"to ignore obsolete messages, for updating a member's attributes on remote"
" nodes, and for refuting messages that say a member is dead."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1373
msgid ""
"If the member's incarnation is less than the locally stored incarnation, "
"then the message is obsolete. This can happen because UDP allows "
"reordering and duplication."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1377
msgid ""
"If the member's incarnation in a message is greater than the locally "
"stored incarnation, then most of its attributes  (IP, port, status) "
"should be updated with the values received in the message. However, the "
"payload attribute should not be updated unless it is present in the "
"message. Because of its relatively large size, payload is not always "
"included in every message."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1384
msgid ""
"Refutation usually happens when a false-positive failure detection has "
"happened. In such a case the member thought to be dead receives that "
"information from other members, increases its own incarnation, and "
"spreads a message saying the member is alive (a \"refutation\")."
msgstr ""

#: ../doc/reference/reference_lua/swim.rst:1390
msgid ""
"Note: in the original version of Tarantool SWIM, and in the original SWIM"
" specification, there is no generation and the incarnation consists of "
"only the version. Generation was added because it is useful for detecting"
" obsolete messages left over from a previous life of an instance that has"
" restarted."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:5
msgid "Module `table`"
msgstr "Модуль `table`"

#: ../doc/reference/reference_lua/table.rst:9
msgid ""
"The :code:`table` module has everything in the `standard Lua table "
"library <https://www.lua.org/pil/19.html>`_, and some Tarantool "
"extensions."
msgstr ""
"Модуль :code:`table` включает в себя всё из `стандартной библиотеки для "
"работы с таблицами в Lua <https://www.lua.org/pil/19.html>`_, а также "
"некоторые расширения специально для Tarantool'а."

#: ../doc/reference/reference_lua/table.rst:13
msgid ""
"You can see this by saying \"table\": you will see this list of "
"functions: ``clear`` (LuaJIT extension = erase all elements), `concat "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.concat>`_ "
"(concatenate), ``copy`` (make a copy of an array), ``deepcopy`` (see "
"description below), ``foreach``, ``foreach1``, `getn "
"<https://www.lua.org/pil/19.1.html>`_ (get the number of elements in an "
"array), `insert <https://www.lua.org/manual/5.1/manual.html#pdf-"
"table.insert>`_ (insert an element into an array), `maxn "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.maxn>`_ (get "
"largest index) `move <https://www.lua.org/manual/5.3/manual.html#pdf-"
"table.move>`_ (move elements between tables), ``new`` (LuaJIT extension ="
" return a new table with pre-allocated elements), `remove "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.remove>`_ (remove "
"an element from an array), `sort "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.sort>`_ (sort the "
"elements of an array)."
msgstr ""
"Чтобы убедиться в этом, выполните команду \"table\": вы увидите список "
"функций: ``clear`` (расширение LuaJIT = удаление всех элементов), `concat"
" <https://www.lua.org/manual/5.1/manual.html#pdf-table.concat>`_ "
"(конкатенация), ``copy`` (создание копии массива), ``deepcopy`` (см. "
"описание ниже), ``foreach``, ``foreach1``, `getn "
"<https://www.lua.org/pil/19.1.html>`_ (получение количества элементов в "
"массиве), `insert <https://www.lua.org/manual/5.1/manual.html#pdf-"
"table.insert>`_ (вставка элемента в массив), `maxn "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.maxn>`_ (получение "
"самого большого индекса) `move "
"<https://www.lua.org/manual/5.3/manual.html#pdf-table.move>`_ "
"(перемещение элементов между таблицами), ``new`` (расширение LuaJIT = "
"возврат новой таблицы с предварительно выделенными элементами), `remove "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.remove>`_ (удаление"
" элемента из массива), `sort <https://www.lua.org/manual/5.1/manual.html"
"#pdf-table.sort>`_ (сортировка элементов массива)."

#: ../doc/reference/reference_lua/table.rst:28
msgid ""
"In this section we only discuss the additional function that the "
"Tarantool developers have added: ``deepcopy``."
msgstr ""
"В данном разделе мы рассматриваем только дополнительную функцию, "
"добавленную разработчиками Tarantool'а: ``deepcopy``."

#: ../doc/reference/reference_lua/table.rst:35
msgid ""
"Return a \"deep\" copy of the table -- a copy which follows nested "
"structures to any depth and does not depend on pointers, it copies the "
"contents."
msgstr ""
"Возврат детальной копии таблицы -- копии, которая включает в себя "
"вложенные структуры любой глубины и не зависит от указателей, копируется "
"содержимое."

#: ../doc/reference/reference_lua/table.rst:39
msgid "(table) the table to copy"
msgstr "таблица для копирования"

#: ../doc/reference/reference_lua/table.rst:41
msgid "the copy of the table"
msgstr "копия таблицы"

#: ../doc/reference/reference_lua/table.rst:46
msgid ""
"tarantool> input_table = {1,{'a','b'}}\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table = table.deepcopy(input_table)\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table\n"
"---\n"
"- - 1\n"
"  - - a\n"
"    - b\n"
"..."
msgstr ""
"tarantool> input_table = {1,{'a','b'}}\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table = table.deepcopy(input_table)\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table\n"
"---\n"
"- - 1\n"
"  - - a\n"
"    - b\n"
"..."

#: ../doc/reference/reference_lua/table.rst:67
msgid "Put the input-table contents in sorted order."
msgstr "Размещение содержимого введенной таблицы в отсортированном порядке."

#: ../doc/reference/reference_lua/table.rst:69
msgid ""
"The `basic Lua table.sort <https://www.lua.org/manual/5.1/manual.html"
"#pdf-table.sort>`_ has a default comparison-function: :code:`function (a,"
" b) return a < b end`."
msgstr ""
"В базовой сортировке в Lua, `table.sort "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.sort>`_, есть "
"функция сравнения, которая используется по умолчанию: :code:`function (a,"
" b) return a < b end`."

#: ../doc/reference/reference_lua/table.rst:72
msgid ""
"That is efficient and standard. However, sometimes Tarantool users will "
"want an equivalent to ``table.sort`` which has any of these features:"
msgstr ""
"Эта стандартная функция эффективна. Однако иногда пользователям "
"Tarantool'а может понадобиться эквивалент ``table.sort`` со следующими "
"функциями:"

#: ../doc/reference/reference_lua/table.rst:75
msgid ""
"(1) If the table contains nils, except nils at the end, the results must "
"still be correct. That is not the case with the default tarantool_sort, "
"and it cannot be fixed by making a comparison that checks whether a and b"
" are nil. (Before trying certain Internet suggestions, test with {1, nil,"
" 2, -1, 44, 1e308, nil, 2, nil, nil, 0}."
msgstr ""
"(1) Если таблица содержит нулевые значения, за исключением нулей в конце,"
" результаты все равно должны быть правильными. Это не работает при "
"использовании стандартного tarantool_sort, и это нельзя исправить, "
"выполнив сравнение, которое проверяет, равны ли значения a и b нулю. "
"(Прежде чем пробовать определенные предложения в Интернете, проверьте {1,"
" nil, 2, -1, 44, 1e308, nil, 2, nil, nil, 0}."

#: ../doc/reference/reference_lua/table.rst:81
msgid ""
"(2) If strings are to be sorted in a language-aware way, there must be a "
"parameter for collation."
msgstr ""
"(2) Если строки должны быть отсортированы с учетом языка, должен быть "
"параметр для сравнения символов."

#: ../doc/reference/reference_lua/table.rst:84
msgid ""
"(3) If the table has a mix of types, then they must be sorted as "
"booleans, then numbers, then strings, then byte arrays."
msgstr ""
"(3) Если в таблица есть разные типы, то они должны быть отсортированы "
"так: логические, затем числа, затем строки, а затем байтовые массивы."

#: ../doc/reference/reference_lua/table.rst:87
msgid ""
"Since all those features are available in Tarantool spaces, the solution "
"for Tarantool is simple: make a temporary Tarantool space, put the table "
"contents into it, retrieve the tuples from it in order, and overwrite the"
" table."
msgstr ""
"Поскольку все эти функции доступны в спейсах Tarantool'а, решение "
"простое: создайте временный спейс в Tarantool'е, поместите в него "
"содержимое таблицы, извлеките из него кортежи по порядку и перезапишите "
"таблицу."

#: ../doc/reference/reference_lua/table.rst:92
msgid ""
"Here then is ``tarantool_sort()`` which does the same thing as "
"``table.sort`` but has those extra features. It is not fast and it "
"requires a database privilege, so it should only be used if the extra "
"features are necessary."
msgstr ""
"Тогда ``tarantool_sort()`` сделает то же самое, что и ``table.sort``, но "
"с этими дополнительными функциями. Это не быстрый способ, который требует"
" прав на базу данных, поэтому его следует использовать только при "
"необходимости дополнительных функций."

#: ../doc/reference/reference_lua/table.rst:97
msgid ""
"  function tarantool_sort(input_table, collation)\n"
"      local c = collation or 'binary'\n"
"      local tmp_name = 'Temporary_for_tarantool_sort'\n"
"      pcall(function() box.space[tmp_name]:drop() end)\n"
"      box.schema.space.create(tmp_name, {temporary = true})\n"
"      box.space[tmp_name]:create_index('I')\n"
"      box.space[tmp_name]:create_index('I2',\n"
"                                       {unique = false,\n"
"                                        type='tree',\n"
"                                        parts={{2, 'scalar',\n"
"                                                collation = c,\n"
"                                                is_nullable = true}}})\n"
"      for i = 1, table.maxn(input_table) do\n"
"          box.space[tmp_name]:insert{i, input_table[i]}\n"
"      end\n"
"      local t = box.space[tmp_name].index.I2:select()\n"
"      for i = 1, table.maxn(input_table) do\n"
"          input_table[i] = t[i][2]\n"
"      end\n"
"      box.space[tmp_name]:drop()\n"
"    end\n"
"\n"
"For example, suppose table t = {1, 'A', -88.3, nil, true, 'b', 'B', nil, "
"'À'}.\n"
"After tarantool_sort(t, 'unicode_ci') t contains {nil, nil, true, -88.3, "
"1, 'A', 'À', 'b', 'B'}."
msgstr ""
"function tarantool_sort(input_table, collation)\n"
"      local c = collation or 'binary'\n"
"      local tmp_name = 'Temporary_for_tarantool_sort'\n"
"      pcall(function() box.space[tmp_name]:drop() end)\n"
"      box.schema.space.create(tmp_name, {temporary = true})\n"
"      box.space[tmp_name]:create_index('I')\n"
"      box.space[tmp_name]:create_index('I2',\n"
"                                       {unique = false,\n"
"                                        type='tree',\n"
"                                        parts={{2, 'scalar',\n"
"                                                collation = c,\n"
"                                                is_nullable = true}}})\n"
"      for i = 1, table.maxn(input_table) do\n"
"          box.space[tmp_name]:insert{i, input_table[i]}\n"
"      end\n"
"      local t = box.space[tmp_name].index.I2:select()\n"
"      for i = 1, table.maxn(input_table) do\n"
"          input_table[i] = t[i][2]\n"
"      end\n"
"      box.space[tmp_name]:drop()\n"
"    end\n"
"\n"
"Например, предположим, что таблица t = {1, 'A', -88.3, nil, true, 'b', "
"'B', nil, 'À'}.\n"
"После tarantool_sort(t, 'unicode_ci') t содержит {nil, nil, true, -88.3, "
"1, 'A', 'À', 'b', 'B'}."

#: ../doc/reference/reference_lua/tap.rst:3
msgid "Module `tap`"
msgstr "Модуль `tap`"

#: ../doc/reference/reference_lua/tap.rst:9
msgid ""
"The ``tap`` module streamlines the testing of other modules. It allows "
"writing of tests in the `TAP protocol`_. The results from the tests can "
"be parsed by standard TAP-analyzers so they can be passed to utilities "
"such as `prove`_. Thus one can run tests and then use the results for "
"statistics, decision-making, and so on."
msgstr ""
"Модуль ``tap`` оптимизирует тестирование других модулей. Он позволяет "
"записывать тесты в TAP-протокол (`TAP protocol`_). Результаты тестов "
"могут подвергаться анализу стандартными TAP-анализаторами, поэтому их "
"можно передавать утилитам, например `prove`_. Таким образом, можно "
"выполнять тестирование, а затем использовать результаты для выведения "
"статистики, принятия решений и т.д."

#: ../doc/reference/reference_lua/tap.rst:27
msgid ":ref:`tap.test() <tap-test>`"
msgstr ":ref:`tap.test() <tap-test>`"

#: ../doc/reference/reference_lua/tap.rst:27
msgid "Initialize"
msgstr "Инициализация"

#: ../doc/reference/reference_lua/tap.rst:30
msgid ":ref:`taptest:test() <taptest-test>`"
msgstr ":ref:`taptest:test() <taptest-test>`"

#: ../doc/reference/reference_lua/tap.rst:30
msgid "Create a subtest and print the results"
msgstr "Создание подтеста и вывод результатов"

#: ../doc/reference/reference_lua/tap.rst:33
msgid ":ref:`taptest:plan() <taptest-plan>`"
msgstr ":ref:`taptest:plan() <taptest-plan>`"

#: ../doc/reference/reference_lua/tap.rst:33
msgid "Indicate how many tests to perform"
msgstr "Указание количества проводимых тестов"

#: ../doc/reference/reference_lua/tap.rst:36
msgid ":ref:`taptest:check() <taptest-check>`"
msgstr ":ref:`taptest:check() <taptest-check>`"

#: ../doc/reference/reference_lua/tap.rst:36
msgid "Check the number of tests performed"
msgstr "Проверка количества выполненных тестов"

#: ../doc/reference/reference_lua/tap.rst:39
msgid ":ref:`taptest:diag() <taptest-diag>`"
msgstr ":ref:`taptest:diag() <taptest-diag>`"

#: ../doc/reference/reference_lua/tap.rst:39
msgid "Display a diagnostic message"
msgstr "Отображение сообщения диагностики"

#: ../doc/reference/reference_lua/tap.rst:42
msgid ":ref:`taptest:ok() <taptest-ok>`"
msgstr ":ref:`taptest:ok() <taptest-ok>`"

#: ../doc/reference/reference_lua/tap.rst:42
#: ../doc/reference/reference_lua/tap.rst:45
#: ../doc/reference/reference_lua/tap.rst:48
msgid "Evaluate the condition and display the message"
msgstr "Оценка состояния и отображение сообщения"

#: ../doc/reference/reference_lua/tap.rst:45
msgid ":ref:`taptest:fail() <taptest-fail>`"
msgstr ":ref:`taptest:fail() <taptest-fail>`"

#: ../doc/reference/reference_lua/tap.rst:48
msgid ":ref:`taptest:skip() <taptest-skip>`"
msgstr ":ref:`taptest:skip() <taptest-skip>`"

#: ../doc/reference/reference_lua/tap.rst:51
msgid ":ref:`taptest:is() <taptest-is>`"
msgstr ":ref:`taptest:is() <taptest-is>`"

#: ../doc/reference/reference_lua/tap.rst:51
msgid "Check if the two arguments are equal"
msgstr "Проверка равенства двух аргументов"

#: ../doc/reference/reference_lua/tap.rst:54
msgid ":ref:`taptest:isnt() <taptest-isnt>`"
msgstr ":ref:`taptest:isnt() <taptest-isnt>`"

#: ../doc/reference/reference_lua/tap.rst:54
msgid "Check if the two arguments are different"
msgstr "Проверка отличий двух аргументов"

#: ../doc/reference/reference_lua/tap.rst:57
msgid ":ref:`taptest:is_deeply() <taptest-is_deeply>`"
msgstr ":ref:`taptest:is_deeply() <taptest-is_deeply>`"

#: ../doc/reference/reference_lua/tap.rst:57
msgid "Recursively check if the two arguments are equal"
msgstr "Рекурсивная проверка равенства двух аргументов"

#: ../doc/reference/reference_lua/tap.rst:60
msgid ":ref:`taptest:like() <taptest-like>`"
msgstr ":ref:`taptest:like() <taptest-like>`"

#: ../doc/reference/reference_lua/tap.rst:60
msgid "Check if the argument matches a pattern"
msgstr "Проверка соответствия аргумента шаблону"

#: ../doc/reference/reference_lua/tap.rst:63
msgid ":ref:`taptest:unlike() <taptest-unlike>`"
msgstr ":ref:`taptest:unlike() <taptest-unlike>`"

#: ../doc/reference/reference_lua/tap.rst:63
msgid "Check if the argument does not match a pattern"
msgstr "Проверка отличия аргумента от шаблона"

#: ../doc/reference/reference_lua/tap.rst:66
msgid ""
":ref:`taptest:isnil() <taptest-istype>` |br| :ref:`taptest:isstring() "
"<taptest-istype>` |br| :ref:`taptest:isnumber() <taptest-istype>` |br| "
":ref:`taptest:istable() <taptest-istype>` |br| :ref:`taptest:isboolean() "
"<taptest-istype>` |br| :ref:`taptest:isudata() <taptest-istype>` |br| "
":ref:`taptest:iscdata() <taptest-istype>`"
msgstr ""
":ref:`taptest:isnil() <taptest-istype>` |br| :ref:`taptest:isstring() "
"<taptest-istype>` |br| :ref:`taptest:isnumber() <taptest-istype>` |br| "
":ref:`taptest:istable() <taptest-istype>` |br| :ref:`taptest:isboolean() "
"<taptest-istype>` |br| :ref:`taptest:isudata() <taptest-istype>` |br| "
":ref:`taptest:iscdata() <taptest-istype>`"

#: ../doc/reference/reference_lua/tap.rst:72
msgid "Check if a value has a particular type"
msgstr "Проверка соответствия значения определенному типу"

#: ../doc/reference/reference_lua/tap.rst:81
#, fuzzy
msgid ":ref:`taptest.strict <taptest-strict>`"
msgstr ":ref:`taptest:test() <taptest-test>`"

#: ../doc/reference/reference_lua/tap.rst:81
msgid "Flag, true if comparisons with nil should be strict"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:91
msgid "Initialize."
msgstr "Инициализация."

#: ../doc/reference/reference_lua/tap.rst:93
msgid ""
"The result of ``tap.test`` is an object, which will be called taptest in "
"the rest of this discussion, which is necessary for ``taptest:plan()`` "
"and all the other methods."
msgstr ""
"Результатом ``tap.test`` является объект, который будет называться "
"taptest в ходе данного разбора, что необходимо для ``taptest:plan()`` и "
"всех остальных методов."

#: ../doc/reference/reference_lua/tap.rst:97
#: ../doc/reference/reference_lua/tap.rst:118
msgid "an arbitrary name to give for the test outputs."
msgstr "произвольное имя для результата теста."

#: ../doc/reference/reference_lua/tap.rst:98
#: ../doc/reference/reference_lua/tap.rst:120
msgid "taptest"
msgstr "taptest"

#: ../doc/reference/reference_lua/tap.rst:101
msgid ""
"tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""
"tap = require('tap')\n"
"taptest = tap.test('test-name')"

#: ../doc/reference/reference_lua/tap.rst:112
msgid ""
"Create a subtest (if no ``func`` argument specified), or (if all "
"arguments are specified) create a subtest, run the test function and "
"print the result."
msgstr ""
"Создание подтеста (если не указан аргумент ``func``) или (если указаны "
"все аргументы) создание подтеста, выполнение тестовой функции и вывод "
"результата."

#: ../doc/reference/reference_lua/tap.rst:116
msgid "See the :ref:`example <tap-example>`."
msgstr "См. :ref:`пример <tap-example>`."

#: ../doc/reference/reference_lua/tap.rst:119
msgid "the test logic to run."
msgstr "выполняемая тестовая логика."

#: ../doc/reference/reference_lua/tap.rst:121
msgid "userdata or string"
msgstr "userdata или строка"

#: ../doc/reference/reference_lua/tap.rst:127
msgid "Indicate how many tests will be performed."
msgstr "Указание количества проводимых тестов."

#: ../doc/reference/reference_lua/tap.rst:136
msgid "Checks the number of tests performed."
msgstr "Проверка количества выполненных тестов."

#: ../doc/reference/reference_lua/tap.rst:138
msgid ""
"The result will be a display saying ``# bad plan: ...`` if the number of "
"completed tests is not equal to the number of tests specified by "
"``taptest:plan(...)``. (This is a purely Tarantool feature: \"bad plan\" "
"messages are out of the TAP13 standard.)"
msgstr ""
"Выведенный результат будет включать в себя сообщение: ``# bad plan: "
"...``, если количество выполненных тестов не равно количеству тестов, "
"указанному в ``taptest:plan(...)``. (Это собственная функция Tarantool'а:"
" сообщения типа \"bad plan\" не входят в стандарт TAP13.)"

#: ../doc/reference/reference_lua/tap.rst:143
msgid ""
"This check should only be done after all planned tests are complete, so "
"ordinarily ``taptest:check()`` will only appear at the end of a script. "
"However, as a Tarantool extension, ``taptest:check()`` may appear at the "
"end of any subtest. Therefore there are three ways to cause the check:"
msgstr ""
"Такую проверку следует проводить только по завершении всех "
"запланированных тестов, поэтому как правило, ``taptest:check()`` появится"
" лишь в конце скрипта. Тем не менее, в качестве расширения Tarantool'а, "
"``taptest:check()`` может появиться в начале любого подтеста. Таким "
"образом, проверка появится в трех случаях:"

#: ../doc/reference/reference_lua/tap.rst:148
msgid "by calling ``taptest:check()`` at the end of a script,"
msgstr "при вызове ``taptest:check()`` в конце скрипта,"

#: ../doc/reference/reference_lua/tap.rst:149
msgid "by calling a function which ends with a call to ``taptest:check()``,"
msgstr "при вызове функции, которая заканчивается вызовом ``taptest:check()``,"

#: ../doc/reference/reference_lua/tap.rst:150
msgid ""
"or by calling taptest:test('...', subtest-function-name) where subtest-"
"function-name does not need to end with ``taptest:check()`` because it "
"can be called after the subtest is complete."
msgstr ""
"или при вызове taptest:test('...', имя-функции-подтеста), где функция "
"подтеста не обязана заканчиваться на ``taptest:check()``, поскольку ее "
"можно вызвать по окончании подтеста."

#: ../doc/reference/reference_lua/tap.rst:161
msgid "Display a diagnostic message."
msgstr "Отображение сообщения диагностики."

#: ../doc/reference/reference_lua/tap.rst:163
msgid "the message to be displayed."
msgstr "отображаемое сообщение."

#: ../doc/reference/reference_lua/tap.rst:170
msgid ""
"This is a basic function which is used by other functions. Depending on "
"the value of ``condition``, print 'ok' or 'not ok' along with debugging "
"information. Displays the message."
msgstr ""
"Это базовая функция, которая используется другими функциями. В "
"зависимости от условия ``condition``, выводится 'ok' или 'not ok' вместе "
"с отладочной информацией. Отображается сообщение."

#: ../doc/reference/reference_lua/tap.rst:174
msgid "an expression which is true or false"
msgstr "выражение, которое либо true (правда), либо false (ложь)"

#: ../doc/reference/reference_lua/tap.rst:175
#: ../doc/reference/reference_lua/tap.rst:209
#: ../doc/reference/reference_lua/tap.rst:222
#: ../doc/reference/reference_lua/tap.rst:245
#: ../doc/reference/reference_lua/tap.rst:257
#: ../doc/reference/reference_lua/tap.rst:274
#: ../doc/reference/reference_lua/tap.rst:289
#: ../doc/reference/reference_lua/tap.rst:303
#: ../doc/reference/reference_lua/tap.rst:322
msgid "name of the test"
msgstr "имя теста"

#: ../doc/reference/reference_lua/tap.rst:182
msgid ""
"tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/tap.rst:206
msgid ""
"``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. "
"Displays the message."
msgstr ""
"``taptest:fail('x')`` -- аналог ``taptest:ok(false, 'x')``. Отображается "
"сообщение."

#: ../doc/reference/reference_lua/tap.rst:218
msgid ""
"``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# "
"skip')``. Displays the message."
msgstr ""
"``taptest:skip('x')`` -- аналог ``taptest:ok(true, 'x' .. '# skip')``. "
"Отображается сообщение."

#: ../doc/reference/reference_lua/tap.rst:228
msgid ""
"tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/tap.rst:240
msgid ""
"Check whether the first argument equals the second argument. Displays "
"extensive message if the result is false."
msgstr ""
"Проверка равенства первого аргумента второму аргументу. Отображается "
"подробное сообщение, если результатом будет false (ложь)."

#: ../doc/reference/reference_lua/tap.rst:243
#: ../doc/reference/reference_lua/tap.rst:255
#: ../doc/reference/reference_lua/tap.rst:272
#: ../doc/reference/reference_lua/tap.rst:287
#: ../doc/reference/reference_lua/tap.rst:301
msgid "actual result"
msgstr "фактический результат"

#: ../doc/reference/reference_lua/tap.rst:244
#: ../doc/reference/reference_lua/tap.rst:256
#: ../doc/reference/reference_lua/tap.rst:273
msgid "expected result"
msgstr "ожидаемый результат"

#: ../doc/reference/reference_lua/tap.rst:253
msgid "This is the negation of :ref:`taptest:is() <taptest-is>`."
msgstr "Отрицание :ref:`taptest:is() <taptest-is>`."

#: ../doc/reference/reference_lua/tap.rst:266
msgid ""
"Recursive version of ``taptest:is(...)``, which can be be used to compare"
" tables as well as scalar values."
msgstr ""
"Рекурсивная версия ``taptest:is(...)``, которую можно использовать для "
"сопоставления таблиц, а также скалярных значений."

#: ../doc/reference/reference_lua/tap.rst:280
msgid ""
"Verify a string against a `pattern <http://lua-"
"users.org/wiki/PatternsTutorial>`_. Ok if match is found."
msgstr ""
"Проверка совпадения строки с `шаблоном <http://lua-"
"users.org/wiki/PatternsTutorial>`_. Ok, если найдено совпадение."

#: ../doc/reference/reference_lua/tap.rst:288
#: ../doc/reference/reference_lua/tap.rst:302
msgid "pattern"
msgstr "шаблон"

#: ../doc/reference/reference_lua/tap.rst:291
msgid "test:like(tarantool.version, '^[1-9]', \"version\")"
msgstr "test:like(tarantool.version, '^[1-9]', \"version\")"

#: ../doc/reference/reference_lua/tap.rst:299
msgid "This is the negation of :ref:`taptest:like() <taptest-like>`."
msgstr "Отрицание :ref:`taptest:like() <taptest-like>`."

#: ../doc/reference/reference_lua/tap.rst:318
msgid ""
"Test whether a value has a particular type. Displays a long message if "
"the value is not of the specified type."
msgstr ""
"Проверка соответствия значения определенному типу. Отображается длинное "
"сообщение, если значение не принадлежит указанному типу."

#: ../doc/reference/reference_lua/tap.rst:331
msgid ""
"Set ``taptest.strict=true`` if :ref:`taptest:is() <taptest-is>` and "
":ref:`taptest:isnt() <taptest-isnt>` and :ref:`taptest:is_deeply() "
"<taptest-is_deeply>` must be compared strictly with ``nil``. Set "
"``taptest.strict=false`` if ``nil`` and ``box.NULL`` both have the same "
"effect. The default is false. For example, if and only if "
"``taptest.strict=true`` has happened, then ``taptest:is_deeply({a = "
"box.NULL}, {})`` will return ``false``."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:350
msgid ""
"To run this example: put the script in a file named ./tap.lua, then make "
"tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using "
"Tarantool as a script processor by saying ./tap.lua."
msgstr ""
"Для выполнения данного примера поместите скрипт в файл под названием "
"./tap.lua, затем сделайте tap.lua выполняемым файлом с помощью команды "
"``chmod a+x ./tap.lua``, а затем выполните его, используя Tarantool в "
"качестве обработчика скриптов после выполнения команды ./tap.lua."

#: ../doc/reference/reference_lua/tap.rst:354
msgid ""
"#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""
"#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"

#: ../doc/reference/reference_lua/tap.rst:368
msgid "The output from the above script will look approximately like this:"
msgstr "Результатом вышеприведенного скрипта будет примерно следующее:"

#: ../doc/reference/reference_lua/tap.rst:370
msgid ""
"TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""
"TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"

#: ../doc/reference/reference_lua/tarantool.rst:5
msgid "Module `tarantool`"
msgstr "Модуль `tarantool`"

#: ../doc/reference/reference_lua/tarantool.rst:9
msgid ""
"By saying ``require('tarantool')``, one can answer some questions about "
"how the tarantool server was built, such as \"what flags were used\", or "
"\"what was the version of the compiler\"."
msgstr ""
"Выполнив команду ``require('tarantool')``, можно получить ответы на "
"вопросы о том, как был собран Tarantool-сервер, например, какие флаги "
"были использованы, или какая версия компилятора использовалась."

#: ../doc/reference/reference_lua/tarantool.rst:15
msgid ""
"Additionally one can see the uptime and the server version and the "
"process id. Those information items can also be accessed with "
":ref:`box.info() <box_introspection-box_info>` but use of the tarantool "
"module is recommended."
msgstr ""
"Кроме того, можно проверить время работы и версию сервера, а также "
"идентификатор процесса. Эту информацию также можно получить с помощью "
":ref:`box.info() <box_introspection-box_info>`, но рекомендуется "
"использовать модуль tarantool."

#: ../doc/reference/reference_lua/tarantool.rst:22
msgid ""
"tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- version: 2.3.0-3-g302bb3241\n"
"  build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/opt/tarantool-install\n"
"-DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fexceptions -funwind-tables -fno-omit-frame-pointer\n"
"-fno-stack-protector\n"
"      -fno-common -fopenmp -msse2 -std=c11 -Wall -Wextra\n"
"-Wno-strict-aliasing -Wno-char-subscripts\n"
"      -Wno-format-truncation -fno-gnu89-inline -Wno-cast-function-type'\n"
"    compiler: /usr/bin/cc /usr/bin/c++\n"
"  pid: 'function: 0x40016cd0'\n"
"  package: Tarantool\n"
"  uptime: 'function: 0x40016cb0'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:3
msgid "Module `uri`"
msgstr "Модуль `uri`"

#: ../doc/reference/reference_lua/uri.rst:9
msgid ""
"A \"URI\" is a \"Uniform Resource Identifier\". The `IETF standard "
"<https://www.ietf.org/rfc/rfc2396.txt>`_ says a URI string looks like "
"this:"
msgstr ""
"URI -- это Унифицированный идентификатор ресурса (Uniform Resource "
"Identifier). Согласно `стандарту IETF "
"<https://www.ietf.org/rfc/rfc2396.txt>`_, URI-строка выглядит следующим "
"образом:"

#: ../doc/reference/reference_lua/uri.rst:13
msgid "[scheme:]scheme-specific-part[#fragment]"
msgstr "[схема:]специальная-часть-схемы[#фрагмент]"

#: ../doc/reference/reference_lua/uri.rst:17
msgid "A common type, a hierarchical URI, looks like this:"
msgstr "Общий тип, иерархический URI, выглядит так:"

#: ../doc/reference/reference_lua/uri.rst:19
msgid "[scheme:][//authority][path][?query][#fragment]"
msgstr "[схема:][//адрес][путь][?запрос][#фрагмент]"

#: ../doc/reference/reference_lua/uri.rst:23
msgid ""
"For example the string ``'https://tarantool.org/x.html#y'`` has three "
"components:"
msgstr ""
"Например, строка ``'https://tarantool.org/x.html#y'`` содержит три "
"компонента:"

#: ../doc/reference/reference_lua/uri.rst:26
msgid "``https`` is the scheme,"
msgstr "``https`` -- схема,"

#: ../doc/reference/reference_lua/uri.rst:27
msgid "``tarantool.org/x.html`` is the path,"
msgstr "``tarantool.org/x.html`` -- путь,"

#: ../doc/reference/reference_lua/uri.rst:28
msgid "``y`` is the fragment."
msgstr "``y`` -- фрагмент."

#: ../doc/reference/reference_lua/uri.rst:30
msgid ""
"Tarantool's URI module provides routines which convert URI strings into "
"their components, or turn components into URI strings."
msgstr ""
"Модуль Tarantool'а URI включает в себя процедуры для разложения URI-строк"
" на компоненты или объединения компонентов в URI-строку."

#: ../doc/reference/reference_lua/uri.rst:37
msgid "Below is a list of all ``uri`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``uri``."

#: ../doc/reference/reference_lua/uri.rst:47
msgid ":ref:`uri.parse() <uri-parse>`"
msgstr ":ref:`uri.parse() <uri-parse>`"

#: ../doc/reference/reference_lua/uri.rst:47
msgid "Get a table of URI components"
msgstr "Получение таблицы URI-компонентов"

#: ../doc/reference/reference_lua/uri.rst:50
msgid ":ref:`uri.format() <uri-format>`"
msgstr ":ref:`uri.format() <uri-format>`"

#: ../doc/reference/reference_lua/uri.rst:50
msgid "Construct a URI from components"
msgstr "Создание URI из компонентов"

#: ../doc/reference/reference_lua/uri.rst:60
msgid "a Uniform Resource Identifier"
msgstr "Унифицированный идентификатор ресурса"

#: ../doc/reference/reference_lua/uri.rst:61
msgid ""
"URI-components-table. Possible components are fragment, host, login, "
"password, path, query, scheme, service."
msgstr ""
"таблица с компонентами URI. Доступные компоненты: fragment (фрагмент), "
"host (хост), login (имя для входа), password (пароль), path (путь), query"
" (запрос), scheme (схема), service (сервис)."

#: ../doc/reference/reference_lua/uri.rst:63
msgid "Table"
msgstr "Таблица"

#: ../doc/reference/reference_lua/uri.rst:67
msgid ""
"tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."
msgstr ""
"tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."

#: ../doc/reference/reference_lua/uri.rst:84
msgid "a series of name:value pairs, one for each component"
msgstr "ряд пар ключ-значение, одна для каждого компонента"

#: ../doc/reference/reference_lua/uri.rst:86
msgid ""
"boolean. If this is supplied and is ``true``, then the password component"
" is rendered in clear text, otherwise it is omitted."
msgstr ""
"логическое значение. Если указать значение ``true``, то компонент пароля "
"отображается открытым текстом, в остальных случаях не отображается."

#: ../doc/reference/reference_lua/uri.rst:89
msgid "URI-string. Thus uri.format() is the reverse of uri.parse()."
msgstr ""
"URI-строка. Таким образом, uri.format() -- это операция, обратная "
"uri.parse()."

#: ../doc/reference/reference_lua/uri.rst:94
msgid ""
"tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})"
"\n"
"---\n"
"- http://x.html#y\n"
"..."
msgstr ""
"tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})"
"\n"
"---\n"
"- http://x.html#y\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:5
msgid "Module `utf8`"
msgstr "Модуль `utf8`"

#: ../doc/reference/reference_lua/utf8.rst:11
msgid ""
"``utf8`` is Tarantool's module for handling UTF-8 strings. It includes "
"some functions which are compatible with ones in `Lua 5.3 "
"<https://www.lua.org/manual/5.3/manual.html#6.5>`_ but Tarantool has much"
" more. For example, because internally Tarantool contains a complete copy"
" of the \"International Components For Unicode\" library, there are "
"comparison functions which understand the default ordering for Cyrillic "
"(Capital Letter Zhe Ж = Small Letter Zhe ж) and Japanese (Hiragana A = "
"Katakana A)."
msgstr ""
"``utf8`` -- это модуль Tarantool'а для обработки строк в формате UTF-8. "
"Он содержит некоторые функции, которые совместимы с функциями `Lua 5.3 "
"<https://www.lua.org/manual/5.3/manual.html#6.5>`_, но возможности "
"Tarantool'а намного больше. Например, поскольку Tarantool включает в себя"
" полную копию библиотеки Международных компонентов для Юникода "
"(\"International Components For Unicode\"), доступны также функции "
"сравнения, которые понимают упорядочение символов в кириллице (заглавная "
"буква  Ж = строчная буква ж) и японском языке (A в хирагане = A в "
"катакане)."

#: ../doc/reference/reference_lua/utf8.rst:29
msgid ":ref:`casecmp <utf8-casecmp>` and |br| :ref:`cmp <utf8-cmp>`"
msgstr ":ref:`casecmp <utf8-casecmp>` and |br| :ref:`cmp <utf8-cmp>`"

#: ../doc/reference/reference_lua/utf8.rst:29
msgid "Comparisons"
msgstr "Сравнения"

#: ../doc/reference/reference_lua/utf8.rst:32
#, fuzzy
msgid ":ref:`lower <utf8-lower>` and |br| :ref:`upper <utf8-upper>`"
msgstr ":ref:`lower <utf8-islower>` and |br| :ref:`upper <utf8-isupper>`"

#: ../doc/reference/reference_lua/utf8.rst:32
msgid "Case conversions"
msgstr "Замена регистра"

#: ../doc/reference/reference_lua/utf8.rst:35
msgid ""
":ref:`isalpha <utf8-isalpha>`, |br| :ref:`isdigit <utf8-isdigit>`, |br| "
":ref:`islower <utf8-islower>` and |br| :ref:`isupper <utf8-isupper>`"
msgstr ""
":ref:`isalpha <utf8-isalpha>`, |br| :ref:`isdigit <utf8-isdigit>`, |br| "
":ref:`islower <utf8-islower>` and |br| :ref:`isupper <utf8-isupper>`"

#: ../doc/reference/reference_lua/utf8.rst:35
msgid "Determine character types"
msgstr "Определение типа символа"

#: ../doc/reference/reference_lua/utf8.rst:40
msgid ":ref:`sub <utf8-sub>`"
msgstr ":ref:`sub <utf8-sub>`"

#: ../doc/reference/reference_lua/utf8.rst:40
msgid "Substrings"
msgstr "Подстроки"

#: ../doc/reference/reference_lua/utf8.rst:42
#, fuzzy
msgid ":ref:`len <utf8-len>`"
msgstr ":ref:`length <utf8-length>`"

#: ../doc/reference/reference_lua/utf8.rst:42
msgid "Length in characters"
msgstr "Длина в символах"

#: ../doc/reference/reference_lua/utf8.rst:44
msgid ":ref:`next <utf8-next>`"
msgstr ":ref:`next <utf8-next>`"

#: ../doc/reference/reference_lua/utf8.rst:44
msgid "Character-at-a-time iterations"
msgstr "Посимвольная итерация"

#: ../doc/reference/reference_lua/utf8.rst:53
#: ../doc/reference/reference_lua/utf8.rst:114
#: ../doc/reference/reference_lua/utf8.rst:235
#: ../doc/reference/reference_lua/utf8.rst:272
#: ../doc/reference/reference_lua/utf8.rst:289
#: ../doc/reference/reference_lua/utf8.rst:348
msgid "a string encoded with UTF-8"
msgstr "строка в формате UTF-8"

#: ../doc/reference/reference_lua/utf8.rst:54
#: ../doc/reference/reference_lua/utf8.rst:115
msgid "-1 meaning \"less\", 0 meaning \"equal\", +1 meaning \"greater\""
msgstr "-1 означает \"меньше\", 0 означает \"равно\", +1 означает \"больше\""

#: ../doc/reference/reference_lua/utf8.rst:57
msgid ""
"Compare two strings with the Default Unicode Collation Element Table "
"(DUCET) for the `Unicode Collation Algorithm "
"<http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is "
"less than 'B', even though the code-point value of å (229) is greater "
"than the code-point value of B (66), because the algorithm depends on the"
" values in the Collation Element Table, not the code-point values."
msgstr ""
"Сравнение двух строк с Таблицей сортировки символов Юникода по умолчанию "
"(DUCET) для `Алгоритма сортировки по Юникоду (Unicode Collation "
"Algorithm) <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. В "
"результате 'å' меньше, чем 'B', хотя значение кодовой точки å (229) "
"больше значения кодовой точки B (66), поскольку алгоритм основывается на "
"значениях Таблица сортировки символов, а не на значениях кодовых точек."

#: ../doc/reference/reference_lua/utf8.rst:64
msgid ""
"The comparison is done with primary weights. Therefore the elements which"
" affect secondary or later weights (such as \"case\" in Latin or Cyrillic"
" alphabets, or \"kana differentiation\" in Japanese) are ignored. If "
"asked \"is this like a Microsoft case-insensitive accent-insensitive "
"collation\" we tend to answer \"yes\", though the Unicode Collation "
"Algorithm is far more sophisticated than those terms imply."
msgstr ""
"Сравнение осуществляется на основании основного веса. Таким образом, не "
"учитываются элементы, которые влияют на вторичный или последующий вес "
"(такие как \"регистр\" в латинице или кириллице, или \"отличия каны\" в "
"японском языке). Если спросить: \"Это похоже на сортировку без учета "
"регистра и ударения от компании Майкрософт?\" - ответом будет: \"Скорее "
"да\", хотя Алгоритм сортировки по Юникоду гораздо сложнее, чем это "
"описание."

#: ../doc/reference/reference_lua/utf8.rst:74
msgid ""
"tarantool> utf8.casecmp('é','e'),utf8.casecmp('E','e')\n"
"---\n"
"- 0\n"
"- 0\n"
"..."
msgstr ""
"tarantool> utf8.casecmp('é','e'),utf8.casecmp('E','e')\n"
"---\n"
"- 0\n"
"- 0\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:86
msgid "a Unicode code point value, repeatable"
msgstr "значение кодовой точки в Юникоде, повторяется"

#: ../doc/reference/reference_lua/utf8.rst:87
msgid "a UTF-8 string"
msgstr "строка в UTF-8"

#: ../doc/reference/reference_lua/utf8.rst:90
msgid ""
"The code-point number is the value that corresponds to a character in the"
" `Unicode Character Database "
"<http://www.unicode.org/Public/5.2.0/ucd/UnicodeData.txt>`_ This is not "
"the same as the byte values of the encoded character, because the UTF-8 "
"encoding scheme is more complex than a simple copy of the code-point "
"number."
msgstr ""
"Число кодовой точки -- это значение, которое соответствует символу в "
"`Базе данных символов Юникода "
"<http://www.unicode.org/Public/5.2.0/ucd/UnicodeData.txt>`_ This is not "
"the same as the byte values of the encoded character, because the UTF-8 "
"encoding scheme is more complex than a simple copy of the code-point "
"number."

#: ../doc/reference/reference_lua/utf8.rst:97
msgid ""
"Another way to construct a string with Unicode characters is with the "
"\\\\u{hex-digits} escape mechanism, for example '\\\\u{41}\\\\u{42}' and "
"``utf8.char(65,66)`` both produce the string 'AB'."
msgstr ""
"Другой способ создать строку с символами Юникода -- с помощью механизма "
"экранирования символов \\\\u{шестнадцатеричные-числа}, например, в "
"результате и '\\\\u{41}\\\\u{42}', и ``utf8.char(65,66)`` получим строку "
"'AB'."

#: ../doc/reference/reference_lua/utf8.rst:103
msgid ""
"tarantool> utf8.char(229)\n"
"---\n"
"- å\n"
"..."
msgstr ""
"tarantool> utf8.char(229)\n"
"---\n"
"- å\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:118
msgid ""
"Compare two strings with the Default Unicode Collation Element Table "
"(DUCET) for the `Unicode Collation Algorithm "
"<http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is "
"less than 'B', even though the code-point value of å (229) is greater "
"than the code-point value of B (66), because the algorithm depends on the"
" values in the Collation Element Table, not the code values."
msgstr ""
"Сравнение двух строк с Таблицей сортировки символов Юникода по умолчанию "
"(DUCET) для `Алгоритма сортировки по Юникоду (Unicode Collation "
"Algorithm) <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. В "
"результате 'å' меньше, чем 'B', хотя значение кодовой точки å (229) "
"больше значения кодовой точки B (66), поскольку алгоритм основывается на "
"значениях Таблица сортировки символов, а не на значениях кода."

#: ../doc/reference/reference_lua/utf8.rst:125
msgid ""
"The comparison is done with at least three weights. Therefore the "
"elements which affect secondary or later weights (such as \"case\" in "
"Latin or Cyrillic alphabets, or \"kana differentiation\" in Japanese) are"
" not ignored. and upper case comes after lower case."
msgstr ""
"Сравнение осуществляется на основании не менее трех значений веса. Таким "
"образом, не учитываются элементы, которые влияют на вторичный или "
"последующий вес (такие как \"регистр\" в латинице или кириллице, или "
"\"отличия каны\" в японском языке), а верхний регистр следует за нижним."

#: ../doc/reference/reference_lua/utf8.rst:132
msgid ""
"tarantool> utf8.cmp('é','e'),utf8.cmp('E','e')\n"
"---\n"
"- 1\n"
"- 1\n"
"..."
msgstr ""
"tarantool> utf8.cmp('é','e'),utf8.cmp('E','e')\n"
"---\n"
"- 1\n"
"- 1\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:144
#: ../doc/reference/reference_lua/utf8.rst:169
#: ../doc/reference/reference_lua/utf8.rst:191
#: ../doc/reference/reference_lua/utf8.rst:213
msgid ""
"a single UTF8 character, expressed as a one-byte string or a code point "
"value"
msgstr ""
"отдельный символ UTF8, выраженный в виде однобайтной строки или значения "
"кодовой точки"

#: ../doc/reference/reference_lua/utf8.rst:149
msgid ""
"Return true if the input character is an \"alphabetic-like\" character, "
"otherwise return false. Generally speaking a character will be considered"
" alphabetic-like provided it is typically used within a word, as opposed "
"to a digit or punctuation. It does not have to be a character in an "
"alphabet."
msgstr ""
"Возврат true (правда), если введенный символ является буквенным, в "
"остальных случаях -- false (ложь). В целом, символ считается буквенным, "
"если он используется в рамках слова, а не как число или знак пунктуации. "
"Такой символ необязательно должен быть буквой алфавита."

#: ../doc/reference/reference_lua/utf8.rst:156
msgid ""
"tarantool> utf8.isalpha('Ж'),utf8.isalpha('å'),utf8.isalpha('9')\n"
"---\n"
"- true\n"
"- true\n"
"- false\n"
"..."
msgstr ""
"tarantool> utf8.isalpha('Ж'),utf8.isalpha('å'),utf8.isalpha('9')\n"
"---\n"
"- true\n"
"- true\n"
"- false\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:174
msgid "Return true if the input character is a digit, otherwise return false."
msgstr ""
"Возврат true (правда), если введенный символ является цифрой, в остальных"
" случаях -- false (ложь)."

#: ../doc/reference/reference_lua/utf8.rst:178
msgid ""
"tarantool> utf8.isdigit('Ж'),utf8.isdigit('å'),utf8.isdigit('9')\n"
"---\n"
"- false\n"
"- false\n"
"- true\n"
"..."
msgstr ""
"tarantool> utf8.isdigit('Ж'),utf8.isdigit('å'),utf8.isdigit('9')\n"
"---\n"
"- false\n"
"- false\n"
"- true\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:196
msgid "Return true if the input character is lower case, otherwise return false."
msgstr ""
"Возврат true (правда), если введенный символ относится к нижнему "
"регистру, в остальных случаях -- false (ложь)."

#: ../doc/reference/reference_lua/utf8.rst:200
msgid ""
"tarantool> utf8.islower('Ж'),utf8.islower('å'),utf8.islower('9')\n"
"---\n"
"- false\n"
"- true\n"
"- false\n"
"..."
msgstr ""
"tarantool> utf8.islower('Ж'),utf8.islower('å'),utf8.islower('9')\n"
"---\n"
"- false\n"
"- true\n"
"- false\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:218
msgid "Return true if the input character is upper case, otherwise return false."
msgstr ""
"Возврат true (правда), если введенный символ относится к верхнему "
"регистру, в остальных случаях -- false (ложь)."

#: ../doc/reference/reference_lua/utf8.rst:222
msgid ""
"tarantool> utf8.isupper('Ж'),utf8.isupper('å'),utf8.isupper('9')\n"
"---\n"
"- true\n"
"- false\n"
"- false\n"
"..."
msgstr ""
"tarantool> utf8.isupper('Ж'),utf8.isupper('å'),utf8.isupper('9')\n"
"---\n"
"- true\n"
"- false\n"
"- false\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:236
msgid "byte position of the first character"
msgstr "позиция байта первого символа"

#: ../doc/reference/reference_lua/utf8.rst:237
msgid "byte position where to stop"
msgstr "позиция байта для остановки"

#: ../doc/reference/reference_lua/utf8.rst:238
msgid "the number of characters in the string, or between start and end"
msgstr "количество символов в строке или же от начала до конца"

#: ../doc/reference/reference_lua/utf8.rst:241
msgid ""
"Byte positions for start and end can be negative, which indicates "
"\"calculate from end of string\" rather than \"calculate from start of "
"string\"."
msgstr ""
"Позиции байта в начале и в конце могут быть отрицательными, что указывает"
" на отсчет с конца строки, а не с начала."

#: ../doc/reference/reference_lua/utf8.rst:244
msgid ""
"If the string contains a byte sequence which is not valid in UTF-8, each "
"byte in the invalid byte sequence will be counted as one character."
msgstr ""
"Если строка содержит последовательность байтов, которая неприменима для "
"UTF-8, каждый байт в неправильной последовательности будет считаться за "
"один символ."

#: ../doc/reference/reference_lua/utf8.rst:247
msgid ""
"UTF-8 is a variable-size encoding scheme. Typically a simple Latin letter"
" takes one byte, a Cyrillic letter takes two bytes, a Chinese/Japanese "
"character takes three bytes, and the maximum is four bytes."
msgstr ""
"UTF-8 представляет собой схему кодирования изменяемого размера. Как "
"правило, одна буква латиницы занимает один байт, буква кириллицы занимает"
" два байта, а символ из китайского или японского языка занимает три "
"байта, максимальный размер -- четыре байта."

#: ../doc/reference/reference_lua/utf8.rst:254
msgid ""
"tarantool> utf8.len('G'),utf8.len('ж')\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"\n"
"tarantool> string.len('G'),string.len('ж')\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""
"tarantool> utf8.len('G'),utf8.len('ж')\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"\n"
"tarantool> string.len('G'),string.len('ж')\n"
"---\n"
"- 1\n"
"- 2\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:273
msgid "the same string, lower case"
msgstr "та же строка в нижнем регистре"

#: ../doc/reference/reference_lua/utf8.rst:278
msgid ""
"tarantool> utf8.lower('ÅΓÞЖABCDEFG')\n"
"---\n"
"- åγþжabcdefg\n"
"..."
msgstr ""
"tarantool> utf8.lower('ÅΓÞЖABCDEFG')\n"
"---\n"
"- åγþжabcdefg\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:290
msgid "byte position where to start within the string, default is 1"
msgstr "позиция байта внутри строки, с которой начать выполнение, по умолчанию = 1"

#: ../doc/reference/reference_lua/utf8.rst:291
msgid ""
"byte position of the next character and the code point value of the next "
"character"
msgstr ""
"позиция байта следующего символа и значение кодовой точки следующего "
"символа "

#: ../doc/reference/reference_lua/utf8.rst:294
msgid ""
"The ``next`` function is often used in a loop to get one character at a "
"time from a UTF-8 string."
msgstr ""
"Функция ``next`` часто используется в цикле для получения символа за раз "
"из строки в формате UTF-8."

#: ../doc/reference/reference_lua/utf8.rst:299
msgid ""
"In the string 'åa' the first character is 'å', it starts at position 1, "
"it takes two bytes to store so the character after it will be at position"
" 3, its Unicode code point value is (decimal) 229."
msgstr ""
"В строке 'åa' первый символ -- 'å', он начинается в позиции 1, занимает "
"два байта, поэтому символ после него будет на позиции 3, значение кодовой"
" точки в Юникоде (десятичное) -- 229."

#: ../doc/reference/reference_lua/utf8.rst:304
msgid ""
"tarantool> -- show next-character position + first-character codepoint\n"
"tarantool> utf8.next('åa', 1)\n"
"---\n"
"- 3\n"
"- 229\n"
"...\n"
"tarantool> -- (loop) show codepoint of every character\n"
"tarantool> for position,codepoint in utf8.next,'åa' do print(codepoint) "
"end\n"
"229\n"
"97\n"
"..."
msgstr ""
"tarantool> -- показать позицию следующего символа + кодовую точку первого"
" символа\n"
"tarantool> utf8.next('åa', 1)\n"
"---\n"
"- 3\n"
"- 229\n"
"...\n"
"tarantool> -- (цикл) показать кодовую точку каждого символа\n"
"tarantool> for position,codepoint in utf8.next,'åa' do print(codepoint) "
"end\n"
"229\n"
"97\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:322
msgid "a string encoded as UTF-8"
msgstr "строка в формате UTF-8"

#: ../doc/reference/reference_lua/utf8.rst:323
msgid "the position of the first character"
msgstr "позиция первого символа"

#: ../doc/reference/reference_lua/utf8.rst:324
msgid "the position of the last character"
msgstr "позиция последнего символа"

#: ../doc/reference/reference_lua/utf8.rst:325
msgid "a UTF-8 string, the \"substring\" of the input value"
msgstr "строка в формате UTF-8, \"подстрока\" введенного значения"

#: ../doc/reference/reference_lua/utf8.rst:328
msgid ""
"Character positions for start and end can be negative, which indicates "
"\"calculate from end of string\" rather than \"calculate from start of "
"string\"."
msgstr ""
"Позиции символа в начале и в конце могут быть отрицательными, что "
"указывает на отсчет с конца строки, а не с начала."

#: ../doc/reference/reference_lua/utf8.rst:331
msgid ""
"The default value for end-character is the length of the input string. "
"Therefore, saying ``utf8.sub(1, 'abc')`` will return 'abc', the same as "
"the input string."
msgstr ""
"Значение end-character по умолчанию -- длина введенной строки. Таким "
"образом, выполнение ``utf8.sub(1, 'abc')`` вернет 'abc', т.е. введенную "
"строку."

#: ../doc/reference/reference_lua/utf8.rst:337
msgid ""
"tarantool> utf8.sub('åγþжabcdefg', 5, 8)\n"
"---\n"
"- abcd\n"
"..."
msgstr ""
"tarantool> utf8.sub('åγþжabcdefg', 5, 8)\n"
"---\n"
"- abcd\n"
"..."

#: ../doc/reference/reference_lua/utf8.rst:349
msgid "the same string, upper case"
msgstr "та же строка в верхнем регистре"

#: ../doc/reference/reference_lua/utf8.rst:354
msgid ""
"In rare cases the upper-case result may be longer than the lower-case "
"input, for example ``utf8.upper('ß')`` is 'SS'."
msgstr ""
"В редких случаях результат в верхнем регистре может быть длиннее "
"введенной строки в нижнем регистре, например, ``utf8.upper('ß')`` вернет "
"'SS'."

#: ../doc/reference/reference_lua/utf8.rst:359
msgid ""
"tarantool> utf8.upper('åγþжabcdefg')\n"
"---\n"
"- ÅΓÞЖABCDEFG\n"
"..."
msgstr ""
"tarantool> utf8.upper('åγþжabcdefg')\n"
"---\n"
"- ÅΓÞЖABCDEFG\n"
"..."

#: ../doc/reference/reference_lua/uuid.rst:3
msgid "Module `uuid`"
msgstr "Модуль `uuid`"

#: ../doc/reference/reference_lua/uuid.rst:9
msgid ""
"A \"UUID\" is a `Universally unique identifier`_. If an application "
"requires that a value be unique only within a single computer or on a "
"single database, then a simple counter is better than a UUID, because "
"getting a UUID is time-consuming (it requires a syscall_). For clusters "
"of computers, or widely distributed applications, UUIDs are better."
msgstr ""
"UUID -- это Универсальный уникальный идентификатор (`Universally unique "
"identifier`_). Если значение должно быть уникальным в пределах отдельного"
" компьютера или одной базы данных, лучше использовать простой счетчик "
"вместо UUID, поскольку получение UUID затратно по времени (требуется "
"syscall_). Что же касается кластеров компьютеров или широко "
"распространенных приложений, лучше использовать UUID."

#: ../doc/reference/reference_lua/uuid.rst:19
msgid "Below is list of all ``uuid`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``uuid``."

#: ../doc/reference/reference_lua/uuid.rst:29
msgid ":ref:`uuid.nil <uuid-nil>`"
msgstr ":ref:`uuid.nil <uuid-nil>`"

#: ../doc/reference/reference_lua/uuid.rst:29
#: ../doc/reference/reference_lua/uuid.rst:54
msgid "A nil object"
msgstr "Объект nil"

#: ../doc/reference/reference_lua/uuid.rst:31
msgid ""
":ref:`uuid() <uuid-__call>` |br| :ref:`uuid.bin() <uuid-bin>` |br| "
":ref:`uuid.str() <uuid-str>`"
msgstr ""
":ref:`uuid() <uuid-__call>` |br| :ref:`uuid.bin() <uuid-bin>` |br| "
":ref:`uuid.str() <uuid-str>`"

#: ../doc/reference/reference_lua/uuid.rst:32
msgid "Get a UUID"
msgstr "Получение UUID"

#: ../doc/reference/reference_lua/uuid.rst:35
msgid ""
":ref:`uuid.fromstr() <uuid-fromstr>` |br| :ref:`uuid.frombin() <uuid-"
"frombin>` |br| :ref:`uuid_object:bin() <uuid-object_bin>` |br| "
":ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""
":ref:`uuid.fromstr() <uuid-fromstr>` |br| :ref:`uuid.frombin() <uuid-"
"frombin>` |br| :ref:`uuid_object:bin() <uuid-object_bin>` |br| "
":ref:`uuid_object:str() <uuid-object_str>`"

#: ../doc/reference/reference_lua/uuid.rst:38
msgid "Get a converted UUID"
msgstr "Получение конвертированного UUID"

#: ../doc/reference/reference_lua/uuid.rst:44
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ":ref:`uuid_object:isnil() <uuid-isnil>`"

#: ../doc/reference/reference_lua/uuid.rst:44
msgid "Check if a UUID is an all-zero value"
msgstr "Проверка, состоит ли UUID из одних нулей"

#: ../doc/reference/reference_lua/uuid.rst:60
#: ../doc/reference/reference_lua/uuid.rst:67
#: ../doc/reference/reference_lua/uuid.rst:74
msgid "a UUID"
msgstr "UUID"

#: ../doc/reference/reference_lua/uuid.rst:68
msgid "16-byte string"
msgstr "16-байтная строка"

#: ../doc/reference/reference_lua/uuid.rst:75
msgid "36-byte binary string"
msgstr "36-байтная двоичная строка"

#: ../doc/reference/reference_lua/uuid.rst:81
msgid "UUID in 36-byte hexadecimal string"
msgstr "UUID в 36-байтной шестнадцатеричной строке"

#: ../doc/reference/reference_lua/uuid.rst:82
#: ../doc/reference/reference_lua/uuid.rst:90
msgid "converted UUID"
msgstr "конвертированный UUID"

#: ../doc/reference/reference_lua/uuid.rst:89
msgid "UUID in 16-byte binary string"
msgstr "UUID в 16-байтной двоичной строке"

#: ../doc/reference/reference_lua/uuid.rst:99
msgid "``byte-order`` can be one of next flags:"
msgstr "``byte-order`` может быть одним из следующих флагов:"

#: ../doc/reference/reference_lua/uuid.rst:101
msgid "'l' - little-endian,"
msgstr "'l' - порядок от младшего к старшему,"

#: ../doc/reference/reference_lua/uuid.rst:102
msgid "'b' - big-endian,"
msgstr "'b' - порядок от старшего к младшему,"

#: ../doc/reference/reference_lua/uuid.rst:103
msgid "'h' - endianness depends on host (default),"
msgstr "'h' - порядок зависит от хоста (по умолчанию),"

#: ../doc/reference/reference_lua/uuid.rst:104
msgid "'n' - endianness depends on network"
msgstr "'n' - порядок зависит от сети"

#: ../doc/reference/reference_lua/uuid.rst:106
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr "один из ``'l'``, ``'b'``, ``'h'`` или ``'n'``."

#: ../doc/reference/reference_lua/uuid.rst:108
#: ../doc/reference/reference_lua/uuid.rst:115
msgid "UUID converted from cdata input value."
msgstr "UUID, сконвертированный из введенного значения формата cdata."

#: ../doc/reference/reference_lua/uuid.rst:109
msgid "16-byte binary string"
msgstr "16-байтная двоичная строка"

#: ../doc/reference/reference_lua/uuid.rst:116
msgid "36-byte hexadecimal string"
msgstr "36-байтная шестнадцатеричная строка"

#: ../doc/reference/reference_lua/uuid.rst:122
msgid ""
"The all-zero UUID value can be expressed as uuid.NULL, or as "
"``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison "
"with an all-zero value can also be expressed as ``uuid_with_type_cdata =="
" uuid.NULL``."
msgstr ""
"Значение UUID из одних нулей может быть выражено как uuid.NULL или "
"``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. Сравнение со "
"значением из одних нулей также может быть выражено как "
"``uuid_with_type_cdata == uuid.NULL``."

#: ../doc/reference/reference_lua/uuid.rst:127
msgid "true if the value is all zero, otherwise false."
msgstr ""
"true (правда), если значение состоит из одних нулей, в противном случае "
"false (ложь)."

#: ../doc/reference/reference_lua/uuid.rst:128
msgid "bool"
msgstr "bool (логический)"

#: ../doc/reference/reference_lua/uuid.rst:134
msgid ""
"tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""
"tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."

#: ../doc/reference/reference_lua/xlog.rst:5
msgid "Module `xlog`"
msgstr "Модуль `xlog`"

#: ../doc/reference/reference_lua/xlog.rst:7
msgid ""
"The xlog module contains one function: ``pairs()``. It can be used to "
"read Tarantool's :ref:`snapshot files<index-box_persistence>` or :ref"
":`write-ahead-log (WAL) <internals-wal>` files. A description of the file"
" format is in section :ref:`Data persistence and the WAL file format "
"<internals-data_persistence>`."
msgstr ""
"Модуль xlog включает в себя одну функцию: ``pairs()``. Ее можно "
"использовать для чтения :ref:`файлов снимка <index-box_persistence>` или "
":ref:`файлов журнала упреждающей записи (WAL) <internals-wal>` в "
"Tarantool'е. Описание формата файла дается в разделе "
":ref:`Персистентность данных и формат WAL-файла <internals-"
"data_persistence>`."

#: ../doc/reference/reference_lua/xlog.rst:19
msgid "Open a file, and allow iterating over one file entry at a time."
msgstr "Открытие файла и итерация по одной записи файла за раз."

#: ../doc/reference/reference_lua/xlog.rst:21
msgid "iterator  which can be used in a for/end loop."
msgstr "итератор, который можно использовать в цикле for / end."

#: ../doc/reference/reference_lua/xlog.rst:22
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_"
msgstr "`итератор <https://www.lua.org/pil/7.1.html>`_"

#: ../doc/reference/reference_lua/xlog.rst:24
msgid ""
"Possible errors: File does not contain properly formatted snapshot or "
"write-ahead-log information."
msgstr ""
"Возможные ошибки: Файл не содержит снимок в правильном формате или "
"информацию журнала упреждающей записи."

#: ../doc/reference/reference_lua/xlog.rst:29
msgid ""
"This will read the first write-ahead-log (WAL) file that was created in "
"the :ref:`wal_dir <cfg_basic-wal_dir>` directory in our :ref:`\"Getting "
"started\" exercises <getting_started>`."
msgstr ""
"В данном примере производится чтение первого WAL-файла, который был "
"создан в директории :ref:`wal_dir <cfg_basic-wal_dir>` в рамках наших "
":ref:`упражнений в \"Руководстве для начинающих\" <getting_started>`."

#: ../doc/reference/reference_lua/xlog.rst:33
msgid ""
"Each result from ``pairs()`` is formatted with MsgPack so its structure "
"can be specified with :ref:`__serialize <msgpack-serialize>`."
msgstr ""
"Каждый результат из ``pairs()`` выводится в формате MsgPack, поэтому его "
"структуру можно указать с помощью :ref:`__serialize <msgpack-serialize>`."

#: ../doc/reference/reference_lua/xlog.rst:36
msgid ""
"xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"
msgstr ""
"xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"

#: ../doc/reference/reference_lua/xlog.rst:45
msgid "The first lines of the result will look like:"
msgstr "Первые строки результата будут выглядеть следующим образом:"

#: ../doc/reference/reference_lua/xlog.rst:47
msgid ""
"(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"
msgstr ""
"(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"

#: ../doc/reference/reference_lua/yaml.rst:5
msgid "Module `yaml`"
msgstr "Модуль `yaml`"

#: ../doc/reference/reference_lua/yaml.rst:11
msgid ""
"The ``yaml`` module takes strings in YAML_ format and decodes them, or "
"takes a series of non-YAML values and encodes them."
msgstr ""
"Модуль ``yaml`` берет строки в формате YAML_ и декодирует их или берет "
"ряд значений в ином формате и кодирует их в формат YAML."

#: ../doc/reference/reference_lua/yaml.rst:18
msgid "Below is a list of all ``yaml`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``yaml``."

#: ../doc/reference/reference_lua/yaml.rst:28
msgid ":ref:`yaml.encode() <yaml-encode>`"
msgstr ":ref:`yaml.encode() <yaml-encode>`"

#: ../doc/reference/reference_lua/yaml.rst:28
msgid "Convert a Lua object to a YAML string"
msgstr "Конвертация Lua-объекта в YAML-строку"

#: ../doc/reference/reference_lua/yaml.rst:31
msgid ":ref:`yaml.decode() <yaml-decode>`"
msgstr ":ref:`yaml.decode() <yaml-decode>`"

#: ../doc/reference/reference_lua/yaml.rst:31
msgid "Convert a YAML string to a Lua object"
msgstr "Конвертация YAML-строки в Lua-объект"

#: ../doc/reference/reference_lua/yaml.rst:34
msgid ":ref:`yaml.NULL <yaml-null>`"
msgstr ":ref:`yaml.NULL <yaml-null>`"

#: ../doc/reference/reference_lua/yaml.rst:44
msgid "Convert a Lua object to a YAML string."
msgstr "Конвертация Lua-объекта в YAML-строку."

#: ../doc/reference/reference_lua/yaml.rst:47
msgid "the original value reformatted as a YAML string."
msgstr "оригинальное значение, преобразованное в YAML-строку."

#: ../doc/reference/reference_lua/yaml.rst:54
msgid "Convert a YAML string to a Lua object."
msgstr "Конвертация YAML-строки в Lua-объект."

#: ../doc/reference/reference_lua/yaml.rst:56
msgid "a string formatted as YAML."
msgstr "строка в формате YAML."

#: ../doc/reference/reference_lua/yaml.rst:70
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."

#: ../doc/reference/reference_lua/yaml.rst:93
msgid ""
"The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be "
"specified with ``__serialize``:"
msgstr ""
"`Набор YAML-стилей <http://yaml.org/spec/1.1/#id930798>`_ можно указать с"
" помощью ``__serialize``:"

#: ../doc/reference/reference_lua/yaml.rst:96
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr "``__serialize=\"sequence\"`` для массива последовательности блоков,"

#: ../doc/reference/reference_lua/yaml.rst:97
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr "``__serialize=\"seq\"`` для массива последовательности потоков,"

#: ../doc/reference/reference_lua/yaml.rst:98
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""
"``__serialize=\"mapping\"`` для ассоциативного массива последовательности"
" блоков,"

#: ../doc/reference/reference_lua/yaml.rst:99
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""
"``__serialize=\"map\"`` для ассоциативного массива последовательности "
"потоков."

#: ../doc/reference/reference_lua/yaml.rst:104
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { "
"__serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { "
"__serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."

#: ../doc/reference/reference_lua/yaml.rst:140
msgid ""
"Also, some YAML configuration settings for encoding can be changed, in "
"the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""
"Кроме того, некоторые параметры конфигурации YAML для кодировки можно "
"изменить так же, как и для :ref:`JSON <json-module_cfg>`."

#: ../doc/reference/reference_rock/cartridge-cli.rst:2
msgid "Cartridge Command Line Interface"
msgstr "Интерфейс командной строки Cartridge"

#: ../doc/reference/reference_rock/cartridge-cli.rst:5
#: ../doc/reference/reference_rock/dbms.rst:53
#: ../doc/reference/reference_rock/dbms.rst:406
#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:11
msgid "Installation"
msgstr "Установка"

#: ../doc/reference/reference_rock/cartridge-cli.rst:10
msgid "tarantoolctl rocks install cartridge-cli"
msgstr "tarantoolctl rocks install cartridge-cli"

#: ../doc/reference/reference_rock/cartridge-cli.rst:11
msgid "Optionally you may add ``.rocks/bin`` to executable path:"
msgstr "При желании можно добавить ``.rocks/bin`` к путь к исполняемому файлу:"

#: ../doc/reference/reference_rock/cartridge-cli.rst:16
msgid "export PATH=$PWD/.rocks/bin/:$PATH"
msgstr "export PATH=$PWD/.rocks/bin/:$PATH"

#: ../doc/reference/reference_rock/cartridge-cli.rst:18
msgid "Usage"
msgstr "Использование"

#: ../doc/reference/reference_rock/cartridge-cli.rst:20
msgid "For more details, run"
msgstr "Чтобы получить более подробную информацию, выполните:"

#: ../doc/reference/reference_rock/cartridge-cli.rst:25
msgid "cartridge --help"
msgstr "cartridge --help"

#: ../doc/reference/reference_rock/cartridge-cli.rst:27
msgid "Applications lifecycle"
msgstr "Жизненный цикл приложений"

#: ../doc/reference/reference_rock/cartridge-cli.rst:29
msgid "Create an application from template:"
msgstr "Создайте приложение из шаблона:"

#: ../doc/reference/reference_rock/cartridge-cli.rst:34
msgid "cartridge create --name myapp"
msgstr "cartridge create --name myapp"

#: ../doc/reference/reference_rock/cartridge-cli.rst:35
msgid "Pack an application into distributable:"
msgstr "Упакуйте приложение:"

#: ../doc/reference/reference_rock/cartridge-cli.rst:40
msgid "cartridge pack rpm myapp"
msgstr "cartridge pack rpm myapp"

#: ../doc/reference/reference_rock/cartridge-cli.rst:42
msgid "Managing instances"
msgstr "Управление экземплярами"

#: ../doc/reference/reference_rock/cartridge-cli.rst:80
msgid ""
"cartridge start [APP_NAME[.INSTANCE_NAME]] [options]\n"
"\n"
"Options\n"
"    --script FILE       Application's entry point.\n"
"                        Default to TARANTOOL_SCRIPT,\n"
"                        or ./init.lua when running from app's directory,\n"
"                        or :apps_path/:app_name/init.lua in multi-app "
"env.\n"
"\n"
"    --apps_path PATH    Path to apps direcrory when running in multi-app "
"env.\n"
"                        Default to /usr/share/tarantool\n"
"\n"
"    --run_dir DIR       Directory with pid and sock files\n"
"                        Default to TARANTOOL_RUN_DIR or "
"/var/run/tarantool\n"
"\n"
"    --cfg FILE          Cartridge instances config file.\n"
"                        Default to TARANTOOL_CFG or ./instances.yml\n"
"\n"
"    --foreground        Do not daemonize"
msgstr ""
"cartridge start [ИМЯ_ПРИЛОЖЕНИЯ[.ИМЯ_ЭКЗЕМПЛЯРА]] [параметры]\n"
"\n"
"Параметры\n"
"    --script FILE       Точка входа в приложение.\n"
"                        По умолчанию TARANTOOL_SCRIPT,\n"
"                        или ./init.lua, если запуск идет из директории "
"приложения,\n"
"                        или :путь_к_приложениям/:имя_приложения/init.lua "
"в среде с несколькими приложениями.\n"
"\n"
"    --apps_path PATH    Путь к директории с приложениями при запуске из "
"среды с несколькими приложениями.\n"
"                        По умолчанию /usr/share/tarantool\n"
"\n"
"    --run_dir DIR       Директория с файлами pid и sock \n"
"                        По умолчанию TARANTOOL_RUN_DIR or "
"/var/run/tarantool\n"
"\n"
"    --cfg FILE          Конфигурационный файл для экземпляров Cartridge.\n"
"                        По умолчанию TARANTOOL_CFG или ./instances.yml\n"
"\n"
"    --foreground        Не в фоне"

#: ../doc/reference/reference_rock/cartridge-cli.rst:65
msgid ""
"It starts tarantool instance in background with enforced env-vars and "
"waits until app’s main script is finished."
msgstr ""
"Это запустит экземпляр Tarantool'а в фоновом режиме с принудительным "
"использованием переменных окружения и будет ожидать выполнения основного "
"скрипта приложения."

#: ../doc/reference/reference_rock/cartridge-cli.rst:104
#, python-format
msgid ""
"TARANTOOL_INSTANCE_NAME\n"
"TARANTOOL_CFG\n"
"TARANTOOL_PID_FILE - %run_dir%/%instance_name%.pid\n"
"TARANTOOL_CONSOLE_SOCK - %run_dir%/%instance_name%.pid"
msgstr ""
"TARANTOOL_INSTANCE_NAME\n"
"TARANTOOL_CFG\n"
"TARANTOOL_PID_FILE - %run_dir%/%instance_name%.pid\n"
"TARANTOOL_CONSOLE_SOCK - %run_dir%/%instance_name%.pid"

#: ../doc/reference/reference_rock/cartridge-cli.rst:75
msgid ""
"``cartridge.cfg()`` uses ``TARANTOOL_INSTANCE_NAME`` to read instance’s "
"config from file provided in ``TARANTOOL_CFG``."
msgstr ""
"``cartridge.cfg()`` использует ``ИМЯ_ЭКЗЕМПЛЯРА_TARANTOOL'А``, чтобы "
"считать настройки экземпляра из файла, который находится в "
"``TARANTOOL_CFG``."

#: ../doc/reference/reference_rock/cartridge-cli.rst:78
msgid ""
"Default options for ``cartridge`` command can be overriden in "
"``./.cartridge.yml`` or ``~/.cartridge.yml``:"
msgstr ""
"Параметры по умолчанию для ``cartridge`` можно изменить в файле "
"``./.cartridge.yml`` или ``~/.cartridge.yml``:"

#: ../doc/reference/reference_rock/cartridge-cli.rst:86
msgid ""
"run_dir: tmp/run\n"
"cfg: cartrifge.yml\n"
"apps_path: /usr/local/share/tarantool"
msgstr ""
"run_dir: tmp/run\n"
"cfg: cartrifge.yml\n"
"apps_path: /usr/local/share/tarantool"

#: ../doc/reference/reference_rock/cartridge-cli.rst:87
msgid ""
"When APP_NAME is not provided it is parsed from ``./*.rockspec`` "
"filename. When ``INSTANCE_NAME`` is not provided cartridge reads ``cfg`` "
"file and starts all defined instances:"
msgstr ""
"Если ``ИМЯ_ПРИЛОЖЕНИЯ`` не указано, оно выделяется из имени файла "
"``./*.rockspec``. Если ``ИМЯ_ЭКЗЕМПЛЯРА`` не указывается, cartridge "
"прочитает файл ``cfg`` и запустит все указанные экземпляры:"

#: ../doc/reference/reference_rock/cartridge-cli.rst:127
msgid ""
"# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # start single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start app_1 # starts all instances of app_1\n"
"cartridge start app_1.router_1 # start single instance"
msgstr ""
"# в директории приложения\n"
"cartridge start # запускает все экземпляры\n"
"cartridge start .router_1 # запускает отдельный экземпляр\n"
"\n"
"# в среде с несколькими приложениями\n"
"cartridge start app_1 # запускает все экземпляры app_1\n"
"cartridge start app_1.router_1 # запускает отдельный экземпляр"

#: ../doc/reference/reference_rock/cartridge-cli.rst:101
msgid "To stop one or more running instances use:"
msgstr "Чтобы остановить один или несколько работающих экземпляров, используйте:"

#: ../doc/reference/reference_rock/cartridge-cli.rst:139
msgid ""
"cartridge stop [APP_NAME[.INSTANCE_NAME]] [options]\n"
"\n"
"These options from `start` command are supported\n"
"    --run_dir DIR\n"
"    --cfg FILE"
msgstr ""
"cartridge stop [ИМЯ_ПРИЛОЖЕНИЯ[.ИМЯ_ЭКЗЕМПЛЯРА]] [параметры]\n"
"\n"
"Поддерживаются следующие параметры из команды `start`\n"
"    --run_dir DIR\n"
"    --cfg FILE"

#: ../doc/reference/reference_rock/cartridge-cli.rst:112
msgid "Misc"
msgstr "Разное"

#: ../doc/reference/reference_rock/cartridge-cli.rst:115
msgid "Running end-to-end tests"
msgstr "Выполнение сквозного тестирования"

#: ../doc/reference/reference_rock/cartridge-cli.rst:121
msgid ""
"vagrant up\n"
"vagrant ssh 1_10 < test/end-to-end.sh\n"
"vagrant halt"
msgstr ""
"vagrant up\n"
"vagrant ssh 1_10 < test/end-to-end.sh\n"
"vagrant halt"

#: ../doc/reference/reference_rock/dbms.rst:5
msgid "SQL DBMS Modules"
msgstr "Модули СУБД SQL"

#: ../doc/reference/reference_rock/dbms.rst:7
msgid ""
"The discussion here in the reference is about incorporating and using two"
" modules that have already been created: the \"SQL DBMS rocks\" for MySQL"
" and PostgreSQL."
msgstr ""
"В данном разделе справочника рассматривается внедрение и использование "
"двух уже созданных модулей: сторонние библиотеки СУБД SQL для MySQL и "
"PostgreSQL."

#: ../doc/reference/reference_rock/dbms.rst:11
msgid ""
"To call another DBMS from Tarantool, the essential requirements are: "
"another DBMS, and Tarantool. The module which connects Tarantool to "
"another DBMS may be called a \"connector\". Within the module there is a "
"shared library which may be called a \"driver\"."
msgstr ""
"Для вызова другой СУБД из Tarantool'а нужно: другая СУБД и Tarantool. "
"Модуль, который соединяет другую СУБД может называться коннектором. В "
"модуле есть библиотека общего пользования, которая может называться "
"драйвером."

#: ../doc/reference/reference_rock/dbms.rst:16
msgid ""
"Tarantool supplies DBMS connector modules with the module manager for "
"Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""
"Tarantool предоставляет модули-коннекторы для СУБД вместе с менеджером "
"модулей для Lua под названием LuaRocks."

#: ../doc/reference/reference_rock/dbms.rst:19
msgid ""
"The Tarantool rocks allow for connecting to SQL servers and executing SQL"
" statements the same way that a MySQL or PostgreSQL client does. The SQL "
"statements are visible as Lua methods. Thus Tarantool can serve as a "
"\"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be "
"useful even if that was all Tarantool could do. But of course Tarantool "
"is also a DBMS, so the module also is useful for any operations, such as "
"database copying and accelerating, which work best when the application "
"can work on both SQL and Tarantool inside the same Lua routine. The "
"methods for connect/select/insert/etc. are similar to the ones in the "
":ref:`net.box <net_box-module>` module."
msgstr ""
"Модули Tarantool'а позволяют подключаться к SQL-серверам и выполнять "
"SQL-запросы так же, как это делает клиент MySQL или PostgreSQL. Операторы"
" SQL доступны как Lua-методы. Таким образом, Tarantool может служить "
"Lua-коннектором для MySQL или Lua-коннектором для PostgreSQL, что было бы"
" полезно, даже если бы Tarantool больше ничего не умел. Но конечно же, "
"Tarantool также представляет собой СУБД, поэтому модуль используется для "
"любых операций, таких как копирование и ускорение базы данных, которые "
"максимально эффективно, если приложение может работать как с SQL, так и с"
" Tarantool в пределах одной Lua-процедуры. Методы подключения / выборки /"
" вставки / и т.д. аналогичны методам модуля :ref:`net.box <net_box-"
"module>`."

#: ../doc/reference/reference_rock/dbms.rst:30
msgid ""
"From a user's point of view the MySQL and PostgreSQL rocks are very "
"similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL "
"Example\" -- contain some redundancy."
msgstr ""
"С точки зрения пользователя, модули для MySQL и PostgreSQL очень похожи, "
"поэтому следующие разделы -- \"Пример для MySQL\" и \"Пример для "
"PostgreSQL\" -- слегка избыточны."

#: ../doc/reference/reference_rock/dbms.rst:38
msgid "MySQL Example"
msgstr "Пример для MySQL"

#: ../doc/reference/reference_rock/dbms.rst:40
msgid ""
"This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been "
"installed. Recent MariaDB versions will also work, the MariaDB C "
"connector is used. The package that matters most is the MySQL client "
"developer package, typically named something like libmysqlclient-dev. The"
" file that matters most from this package is libmysqlclient.so or a "
"similar name. One can use ``find`` or ``whereis`` to see what directories"
" these files are installed in."
msgstr ""
"В данном примере предполагается, что установлены MySQL 5.5, MySQL 5.6 или"
" MySQL 5.7. Последние версии MariaDB также подойдут, используется "
"коннектор к MariaDB для C. Самым важным пакетом будет пакет для "
"разработчиков клиента MySQL, который обычно называется libmysqlclient-"
"dev. Наиболее важным файлом из этого пакета будет файл libmysqlclient.so "
"или с похожим названием. Можно использовать `` find`` или `` whereis``, "
"чтобы узнать, в каких директориях установлены эти файлы."

#: ../doc/reference/reference_rock/dbms.rst:47
msgid ""
"It will be necessary to install Tarantool's MySQL driver shared library, "
"load it, and use it to connect to a MySQL server instance. After that, "
"one can pass any MySQL statement to the server instance and receive "
"results, including multiple result sets."
msgstr ""
"Также нужно будет установить библиотеку общего пользования Tarantool'а с "
"драйвером для MySQL, загрузить ее и использовать для подключения к "
"экземпляру MySQL-сервера. После этого можно передавать любой оператор "
"MySQL на экземпляр сервера и получать результаты, включая наборы "
"результатов."

#: ../doc/reference/reference_rock/dbms.rst:55
#: ../doc/reference/reference_rock/dbms.rst:408
msgid ""
"Check the instructions for `downloading and installing a binary package "
"<http://tarantool.org/download.html>`_ that apply for the environment "
"where Tarantool was installed. In addition to installing ``tarantool``, "
"install ``tarantool-dev``. For example, on Ubuntu, add the line:"
msgstr ""
"Проверьте инструкции по `загрузке и установке бинарного пакета "
"<http://tarantool.org/download.html>`_, которые применимы к среде, где "
"установлен Tarantool. Помимо установки ``tarantool``, установите "
"``tarantool-dev``. Например, в Ubuntu добавьте строку:"

#: ../doc/reference/reference_rock/dbms.rst:61
#: ../doc/reference/reference_rock/dbms.rst:414
msgid "$ sudo apt-get install tarantool-dev"
msgstr "$ sudo apt-get install tarantool-dev"

#: ../doc/reference/reference_rock/dbms.rst:65
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""
"Что касается библиотеки общего пользования с драйвером для MySQL, ее "
"можно установить двумя способами:"

#: ../doc/reference/reference_rock/dbms.rst:69
#: ../doc/reference/reference_rock/dbms.rst:422
msgid "With LuaRocks"
msgstr "Из LuaRocks"

#: ../doc/reference/reference_rock/dbms.rst:71
#: ../doc/reference/reference_rock/dbms.rst:424
msgid ""
"Begin by installing luarocks and making sure that tarantool is among the "
"upstream servers, as in the instructions on `rocks.tarantool.org`_, the "
"Tarantool luarocks page. Now execute this:"
msgstr ""
"Начните с установки luarocks. Убедитесь, что tarantool указан в серверах,"
" как описано на странице сторонних модулей Tarantool'а "
"`rocks.tarantool.org`_. Затем выполните:"

#: ../doc/reference/reference_rock/dbms.rst:112
msgid ""
"luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""
"luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"

#: ../doc/reference/reference_rock/dbms.rst:84
msgid "$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr "$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"

#: ../doc/reference/reference_rock/dbms.rst:90
#: ../doc/reference/reference_rock/dbms.rst:443
msgid "With GitHub"
msgstr "Из GitHub"

#: ../doc/reference/reference_rock/dbms.rst:92
msgid ""
"Go the site `github.com/tarantool/mysql`_. Follow the instructions there,"
" saying:"
msgstr ""
"Перейдите по ссылке `github.com/tarantool/mysql`_. Следуя инструкциям, "
"введите команду:"

#: ../doc/reference/reference_rock/dbms.rst:94
msgid ""
"$ git clone https://github.com/tarantool/mysql.git\n"
"$ cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone https://github.com/tarantool/mysql.git\n"
" $ cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
" $ make\n"
" $ make install"

#: ../doc/reference/reference_rock/dbms.rst:101
#: ../doc/reference/reference_rock/dbms.rst:454
msgid ""
"At this point it is a good idea to check that the installation produced a"
" file named ``driver.so``, and to check that this file is on a directory "
"that is searched by the ``require`` request."
msgstr ""
"На данном этапе желательно проверить, что после установки появился файл "
"под названием ``driver.so``, а также проверить, что этот файл находится в"
" директории, которую можно найти по запросу ``require``."

#: ../doc/reference/reference_rock/dbms.rst:107
#: ../doc/reference/reference_rock/dbms.rst:460
msgid "Connecting"
msgstr "Подключение"

#: ../doc/reference/reference_rock/dbms.rst:109
msgid ""
"Begin by making a ``require`` request for the mysql driver. We will "
"assume that the name is ``mysql`` in further examples."
msgstr ""
"Начните с выполнения запроса ``require`` для драйвера mysql. В дальнейших"
" примерах у него будет имя ``mysql``."

#: ../doc/reference/reference_rock/dbms.rst:112
msgid "mysql = require('mysql')"
msgstr "mysql = require('mysql')"

#: ../doc/reference/reference_rock/dbms.rst:116
#: ../doc/reference/reference_rock/dbms.rst:469
msgid "Now, say:"
msgstr "Теперь выполните:"

#: ../doc/reference/reference_rock/dbms.rst:155
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr "*имя_подключения* = mysql.connect(*параметры подключения*)"

#: ../doc/reference/reference_rock/dbms.rst:123
#: ../doc/reference/reference_rock/dbms.rst:476
msgid "The connection-options parameter is a table. Possible options are:"
msgstr "Параметры подключения включены в таблицу. Доступные параметры:"

#: ../doc/reference/reference_rock/dbms.rst:125
#: ../doc/reference/reference_rock/dbms.rst:478
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ":samp:`host = {имя-хоста}` -- строка, значение по умолчанию = 'localhost'"

#: ../doc/reference/reference_rock/dbms.rst:126
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ":samp:`port = {номер-порта}` -- число, значение по умолчанию = 3306"

#: ../doc/reference/reference_rock/dbms.rst:127
#: ../doc/reference/reference_rock/dbms.rst:480
msgid ""
":samp:`user = {user-name}` - string, default value is operating-system "
"user name"
msgstr ""
":samp:`user = {имя-пользователя}` -- строка, значение по умолчанию -- имя"
" пользователя в операционной системе"

#: ../doc/reference/reference_rock/dbms.rst:128
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ":samp:`password = {пароль}` -- строка, по умолчанию пустая"

#: ../doc/reference/reference_rock/dbms.rst:129
#: ../doc/reference/reference_rock/dbms.rst:482
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ":samp:`db = {имя-базы-данных}` -- строка, по умолчанию пустая"

#: ../doc/reference/reference_rock/dbms.rst:130
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""
":samp:`raise = {true|false}` -- логическое значение, по умолчанию, false "
"(ложь)"

#: ../doc/reference/reference_rock/dbms.rst:132
msgid ""
"The option names, except for `raise`, are similar to the names that "
"MySQL's mysql client uses, for details see the MySQL manual at "
"`dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option "
"should be set to :codenormal:`true` if errors should be raised when "
"encountered. To connect with a Unix socket rather than with TCP, specify "
"``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""
"Имена параметров, за исключением `raise`, похожи на имена, которые "
"используются в MySQL-клиенте mysql, для получения подробной информации "
"см. руководство по MySQL по ссылке "
"`dev.mysql.com/doc/refman/5.6/en/connecting.html`_. Значение параметра "
"`raise` следует указать как :codenormal:`true`, если ошибки должны "
"возникать при обнаружении. Чтобы подключиться по Unix-сокету, а не по "
"TCP, укажите ``host = 'unix/'`` и :samp:`port = {имя-сокета}`."

#: ../doc/reference/reference_rock/dbms.rst:139
#: ../doc/reference/reference_rock/dbms.rst:486
msgid "Example, using a table literal enclosed in {braces}:"
msgstr "Пример с использованием таблицы, заключенной в {фигурные скобки}:"

#: ../doc/reference/reference_rock/dbms.rst:141
msgid ""
"conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""
"conn = mysql.connect({\n"
"     host = '127.0.0.1',\n"
"     port = 3306,\n"
"     user = 'p',\n"
"     password = 'p',\n"
"     db = 'test',\n"
"     raise = true\n"
" })\n"
"-- ИЛИ\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"

#: ../doc/reference/reference_rock/dbms.rst:157
#: ../doc/reference/reference_rock/dbms.rst:498
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""
"Пример с созданием функции, которая определяет параметры в отдельных "
"строках:"

#: ../doc/reference/reference_rock/dbms.rst:159
msgid ""
"tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""
"tarantool> -- Функция подключения. Использование: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."

#: ../doc/reference/reference_rock/dbms.rst:175
#: ../doc/reference/reference_rock/dbms.rst:517
msgid "We will assume that the name is 'conn' in further examples."
msgstr "Предполагаем, что в дальнейших примерах будет использоваться имя 'conn'."

#: ../doc/reference/reference_rock/dbms.rst:179
#: ../doc/reference/reference_rock/dbms.rst:521
msgid "How to ping"
msgstr "Как проверить связь"

#: ../doc/reference/reference_rock/dbms.rst:181
#: ../doc/reference/reference_rock/dbms.rst:523
msgid "To ensure that a connection is working, the request is:"
msgstr "Чтобы убедиться, что подключение работает, следует использовать запрос:"

#: ../doc/reference/reference_rock/dbms.rst:220
#: ../doc/reference/reference_rock/dbms.rst:562
msgid "*connection-name*:ping()"
msgstr "*имя-соединение*:ping()"

#: ../doc/reference/reference_rock/dbms.rst:190
#: ../doc/reference/reference_rock/dbms.rst:532
msgid ""
"tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."

#: ../doc/reference/reference_rock/dbms.rst:199
#: ../doc/reference/reference_rock/dbms.rst:541
msgid "Executing a statement"
msgstr "Исполнение оператора"

#: ../doc/reference/reference_rock/dbms.rst:201
msgid "For all MySQL statements, the request is:"
msgstr "Для всех операторов MySQL запрос будет:"

#: ../doc/reference/reference_rock/dbms.rst:240
#: ../doc/reference/reference_rock/dbms.rst:582
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr "*имя-соединения*:execute(*sql-оператор* [, *параметры*])"

#: ../doc/reference/reference_rock/dbms.rst:208
msgid ""
"where ``sql-statement`` is a string, and the optional ``parameters`` are "
"extra values that can be plugged in to replace any question marks "
"(\"?\"s) in the SQL statement."
msgstr ""
"где ``sql-statement`` -- это строка, а необязательные параметры -- это "
"дополнительные значения, которыми можно заменить любые знаки вопроса "
"(\"?\") в SQL-операторе."

#: ../doc/reference/reference_rock/dbms.rst:214
msgid ""
"tarantool> conn:execute('select table_name from "
"information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""
"tarantool> conn:execute('select table_name from "
"information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."

#: ../doc/reference/reference_rock/dbms.rst:227
#: ../doc/reference/reference_rock/dbms.rst:568
msgid "Closing connection"
msgstr "Закрытие соединения"

#: ../doc/reference/reference_rock/dbms.rst:229
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""
"Чтобы закрыть сессию, которую открыли с помощью ``mysql.connect``, "
"используется следующий запрос:"

#: ../doc/reference/reference_rock/dbms.rst:268
#: ../doc/reference/reference_rock/dbms.rst:609
msgid "*connection-name*:close()"
msgstr "*имя-соединения*:close()"

#: ../doc/reference/reference_rock/dbms.rst:238
#: ../doc/reference/reference_rock/dbms.rst:579
msgid ""
"tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""
"tarantool> conn:close()\n"
"---\n"
"..."

#: ../doc/reference/reference_rock/dbms.rst:244
msgid ""
"For further information, including examples of rarely-used requests, see "
"the README.md file at `github.com/tarantool/mysql`_."
msgstr ""
"Для получения дополнительной информации, включая примеры редко "
"используемых запросов, см. файл README.md по ссылке "
"`github.com/tarantool/mysql`_."

#: ../doc/reference/reference_rock/dbms.rst:251
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where "
"tarantool had been installed in a /usr subdirectory, and a copy of MySQL "
"had been installed on ~/mysql-5.5. The mysqld server instance is already "
"running on the local host 127.0.0.1."
msgstr ""
"Пример выполняется на машине с ОС Ubuntu 12.04 (Precise Pangolin), где "
"Tarantool установлен в поддиректорию /usr, а копия MySQL установлена в "
"~/mysql-5.5. Экземпляр сервера mysqld уже запущен на localhost 127.0.0.1."

#: ../doc/reference/reference_rock/dbms.rst:255
#, fuzzy
msgid ""
"$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/2.1/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/2.1/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 2.1\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (2.1.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization "
"file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 2.1.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""
"$ export TMDIR=~/mysql-5.5\n"
"$ # Проверьте, что создана поддиректория include, путем поиска\n"
"$ # .../include/mysql.h. (Если нет, то можно проверить\n"
"$ # .../include/mysql/mysql.h.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Проверьте, что создана поддиректория library, а в ней\n"
"$ # необходимый файл .so.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Проверьте, что mysql-клиент может подключиться, с помощью настроек\n"
"$ # по умолчанию: порт = 3306, пользователь = 'root', пароль пользователя"
" = '',\n"
"$ # база данных = 'test'. Эти настройки можно изменить, используя\n"
"$ # измененные значения.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Вставьте строку в базу данных test и завершите работу.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Установите luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Настройте список сторонних модулей Tarantool'а в ~/.luarocks,\n"
"$ # следуя инструкциям по ссылке rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Убедитесь, что при следующей установке будут использованы файлы из "
"главного\n"
"$ # хранилища Tarantool'а. Получаем результат, нормальный для Ubuntu\n"
"$ # 12.04 Precise Pangolin\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Установите tarantool-dev. Строка на экране должна показать версию 1.6"
"\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Используйте luarocks для локальной установки, то есть в $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (здесь будет еще информация о сборке драйвера Tarantool/MySQL)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Убедитесь, что driver.so создан в месте,\n"
"$ # где Tarantool будет искать его\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Измените директорию на директорию, которую можно использовать для\n"
"$ # временного тестирования. В данном примере предполагаем, что имя\n"
"$ # этой директории будет /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Измените \"/home/pgulutzan\" на фактическую корневую директорию\n"
"$ # пользователя машины, используемой для тестирования.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Запустите экземпляр Tarantool-сервера. Не используйте файл "
"инициализации Lua.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"

#: ../doc/reference/reference_rock/dbms.rst:336
msgid ""
"Configure tarantool and load mysql module. Make sure that tarantool "
"doesn't reply \"error\" for the call to \"require()\"."
msgstr ""
"Настройте Tarantool и загрузите модуль mysql. Убедитесь, что Tarantool не"
" выбрасывает ошибку в ответ на вызов \"require()\"."

#: ../doc/reference/reference_rock/dbms.rst:339
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."

#: ../doc/reference/reference_rock/dbms.rst:347
msgid ""
"Create a Lua function that will connect to the MySQL server instance, "
"(using some factory default values for the port and user and password), "
"retrieve one row, and display the row. For explanations of the statement "
"types used here, read the Lua tutorial earlier in the Tarantool user "
"manual."
msgstr ""
"Создайте Lua-функцию, которая подключится к экземпляру MySQL-сервера "
"(используя значения по умолчанию для параметров порта, пользователя и "
"пароля), выберите одну строку и выведите ее на экран. Описание "
"используемых здесь типов операторов вы можете найти в практикуме по Lua в"
" руководстве пользователя Tarantool'а."

#: ../doc/reference/reference_rock/dbms.rst:352
msgid ""
"tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""
"tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."

#: ../doc/reference/reference_rock/dbms.rst:376
msgid ""
"Observe the result. It contains \"MySQL row\". So this is the row that "
"was inserted into the MySQL database. And now it's been selected with the"
" Tarantool client."
msgstr ""
"Просмотрите результат. В нем есть строка \"MySQL row\". Это и есть "
"строка, которая была вставлена в базу данных MySQL. А сейчас она выделена"
" с помощью Tarantool-клиента."

#: ../doc/reference/reference_rock/dbms.rst:383
msgid "PostgreSQL Example"
msgstr "Пример для PostgreSQL "

#: ../doc/reference/reference_rock/dbms.rst:385
msgid ""
"This example assumes that PostgreSQL 8 or PostgreSQL 9 has been "
"installed. More recent versions should also work. The package that "
"matters most is the PostgreSQL developer package, typically named "
"something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""
"В данном примере предполагается, что установлены PostgreSQL 8 или "
"PostgreSQL 9. Более поздние версии  также должны сработать. Самым важным "
"пакетом будет пакет для разработчиков клиента PostgreSQL, который обычно "
"называется libpq-dev. На Ubuntu его можно установить следующим образом:"

#: ../doc/reference/reference_rock/dbms.rst:390
msgid "$ sudo apt-get install libpq-dev"
msgstr "$ sudo apt-get install libpq-dev"

#: ../doc/reference/reference_rock/dbms.rst:394
msgid ""
"However, because not all platforms are alike, for this example the "
"assumption is that the user must check that the appropriate PostgreSQL "
"files are present and must explicitly state where they are when building "
"the Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to "
"see what directories PostgreSQL files are installed in."
msgstr ""
"Однако, не все платформы одинаковы, поэтому в данном примере "
"предполагается, что пользователь должен проверить наличие нужных "
"PostgreSQL-файлов, а также явным образом прописать, где они находятся, "
"для сборки драйвера Tarantool/PostgreSQL. Для поиска директорий, где "
"установлены PostgreSQL-файлы, можно воспользоваться командами ``find`` "
"или ``whereis``."

#: ../doc/reference/reference_rock/dbms.rst:400
msgid ""
"It will be necessary to install Tarantool's PostgreSQL driver shared "
"library, load it, and use it to connect to a PostgreSQL server instance. "
"After that, one can pass any PostgreSQL statement to the server instance "
"and receive results."
msgstr ""
"Также нужно будет установить библиотеку общего пользования Tarantool'а с "
"драйвером для PostgreSQL, загрузить ее и использовать для подключения к "
"экземпляру PostgreSQL-сервера. После этого можно передавать любой "
"оператор PostgreSQL на экземпляр сервера и получать результаты."

#: ../doc/reference/reference_rock/dbms.rst:418
msgid ""
"Now, for the PostgreSQL driver shared library, there are two ways to "
"install:"
msgstr ""
"Что касается библиотеки общего пользования с драйвером для PostgreSQL, ее"
" можно установить двумя способами:"

#: ../doc/reference/reference_rock/dbms.rst:465
msgid ""
"luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""
"luarocks install pg [POSTGRESQL_LIBDIR = *путь*]\n"
"                    [POSTGRESQL_INCDIR = *путь*]\n"
"                    [--local]"

#: ../doc/reference/reference_rock/dbms.rst:437
msgid "$ luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr "$ luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"

#: ../doc/reference/reference_rock/dbms.rst:445
msgid ""
"Go the site `github.com/tarantool/pg`_. Follow the instructions there, "
"saying:"
msgstr ""
"Перейдите по ссылке `github.com/tarantool/pg`_. Следуя инструкциям, "
"введите команду:"

#: ../doc/reference/reference_rock/dbms.rst:447
msgid ""
"$ git clone https://github.com/tarantool/pg.git\n"
"$ cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone https://github.com/tarantool/pg.git\n"
"$ cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"

#: ../doc/reference/reference_rock/dbms.rst:462
msgid ""
"Begin by making a ``require`` request for the pg driver. We will assume "
"that the name is ``pg`` in further examples."
msgstr ""
"Начните с выполнения запроса ``require`` для драйвера pg. В дальнейших "
"примерах у него будет имя ``pg``."

#: ../doc/reference/reference_rock/dbms.rst:465
msgid "pg = require('pg')"
msgstr "pg = require('pg')"

#: ../doc/reference/reference_rock/dbms.rst:508
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr "*имя_подключения* = pg.connect(*параметры подключения*)"

#: ../doc/reference/reference_rock/dbms.rst:479
msgid ":samp:`port = {port-number}` - number, default value = 5432"
msgstr ":samp:`port = {номер-порта}` -- число, значение по умолчанию = 5432"

#: ../doc/reference/reference_rock/dbms.rst:481
msgid ""
":samp:`pass = {password}` or :samp:`password = {password}` - string, "
"default value is blank"
msgstr ""
":samp:`pass = {пароль}` или :samp:`password = {пароль}` -- строка, по "
"умолчанию пустая"

#: ../doc/reference/reference_rock/dbms.rst:484
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr "Имена параметров похожи на имена, которые используются в PostgreSQL."

#: ../doc/reference/reference_rock/dbms.rst:488
msgid ""
"conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""
"conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"

#: ../doc/reference/reference_rock/dbms.rst:500
msgid ""
"tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""
"tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."

#: ../doc/reference/reference_rock/dbms.rst:543
msgid "For all PostgreSQL statements, the request is:"
msgstr "Для всех операторов PostgreSQL запрос будет:"

#: ../doc/reference/reference_rock/dbms.rst:550
msgid ""
"where ``sql-statement`` is a string, and the optional ``parameters`` are "
"extra values that can be plugged in to replace any placeholders ($1 $2 $3"
" etc.) in the SQL statement."
msgstr ""
"где ``sql-statement`` -- это строка, а необязательные параметры -- это "
"дополнительные значения, которыми можно заменить любые местозаполнители "
"($1 $2 $3 и т.д.) в SQL-операторе."

#: ../doc/reference/reference_rock/dbms.rst:556
msgid ""
"tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""
"tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."

#: ../doc/reference/reference_rock/dbms.rst:570
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""
"Чтобы закрыть сессию, которую открыли с помощью ``pg.connect``, "
"используется следующий запрос:"

#: ../doc/reference/reference_rock/dbms.rst:585
msgid ""
"For further information, including examples of rarely-used requests, see "
"the README.md file at `github.com/tarantool/pg`_."
msgstr ""
"Для получения дополнительной информации, включая примеры редко "
"используемых запросов, см. файл README.md по ссылке "
"`github.com/tarantool/pg`_."

#: ../doc/reference/reference_rock/dbms.rst:592
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where "
"tarantool had been installed in a /usr subdirectory, and a copy of "
"PostgreSQL had been installed on /usr. The PostgreSQL server instance is "
"already running on the local host 127.0.0.1."
msgstr ""
"Пример выполняется на машине с ОС Ubuntu 12.04 (Precise Pangolin), где "
"Tarantool установлен в поддиректорию /usr, а копия PostgreSQL установлена"
" в /usr. Экземпляр сервера PostgreSQL уже запущен на localhost 127.0.0.1."

#: ../doc/reference/reference_rock/dbms.rst:596
#, fuzzy
msgid ""
"$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so "
"file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master"
"\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/2.0/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/2.0/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 2.0\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (2.0.4.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local"
"\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears "
"here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization "
"file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 2.0.4-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""
"$ # Проверьте, что создана поддиректория include, путем поиска\n"
"$ # /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Проверьте, что создана поддиректория library, а в ней необходимый "
"файл .so.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Проверьте, что psql-клиент может подключиться, с помощью настроек по "
"умолчанию:\n"
"$ # порт = 5432, пользователь = 'postgres', пароль пользователя = "
"'postgres',\n"
"$ # база данных = 'postgres'. Эти настройки можно изменить, используя\n"
"$ # измененные значения. Вставьте строку в базу данных postgres и "
"завершите работу.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Установите luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Настройте список сторонних модулей Tarantool'а в ~/.luarocks,\n"
"$ # следуя инструкциям по ссылке rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Убедитесь, что при следующей установке будут использованы файлы из "
"главного\n"
"$ # хранилища Tarantool'а. Получаем результат, нормальный для Ubuntu "
"12.04 Precise Pangolin\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Установите tarantool-dev. Строка на экране должна показать версию 1.7"
"\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Используйте luarocks для локальной установки, то есть в $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local"
"\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (здесь будет еще информация о сборке драйвера Tarantool/PostgreSQL)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Убедитесь, что driver.so создан в месте,\n"
"$ # где Tarantool будет искать его\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Измените директорию на директорию, которую можно использовать для\n"
"$ # временного тестирования. В данном примере предполагаем, что имя\n"
"$ # name этой директории будет $HOME/tarantool_sandbox.\n"
"$ # (Измените \"$HOME\" на фактическую корневую директорию\n"
"$ # машины, используемой для тестирования.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Запустите экземпляр Tarantool-сервера. Не используйте файл "
"инициализации Lua.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"

#: ../doc/reference/reference_rock/dbms.rst:670
msgid ""
"Configure tarantool and load pg module. Make sure that tarantool doesn't "
"reply \"error\" for the call to \"require()\"."
msgstr ""
"Настройте Tarantool и загрузите модуль pg. Убедитесь, что Tarantool не "
"выбрасывает ошибку в ответ на вызов \"require()\"."

#: ../doc/reference/reference_rock/dbms.rst:673
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."

#: ../doc/reference/reference_rock/dbms.rst:681
msgid ""
"Create a Lua function that will connect to a PostgreSQL server, (using "
"some factory default values for the port and user and password), retrieve"
" one row, and display the row. For explanations of the statement types "
"used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""
"Создайте Lua-функцию, которая подключится к PostgreSQL-серверу (используя"
" значения по умолчанию для параметров порта, пользователя и пароля), "
"выберите одну строку и выведите ее на экран. Описание используемых здесь "
"типов операторов вы можете найти в практикуме по Lua в руководстве "
"пользователя Tarantool'а."

#: ../doc/reference/reference_rock/dbms.rst:686
msgid ""
"tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""
"tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."

#: ../doc/reference/reference_rock/dbms.rst:711
msgid ""
"Observe the result. It contains \"PostgreSQL row\". So this is the row "
"that was inserted into the PostgreSQL database. And now it's been "
"selected with the Tarantool client."
msgstr ""
"Просмотрите результат. В нем есть строка \"PostgreSQL row\". Это и есть "
"строка, которая была вставлена в базу данных PostgreSQL. А сейчас она "
"выделена с помощью Tarantool-клиента."

#: ../doc/reference/reference_rock/expirationd.rst:5
msgid "Module `expirationd`"
msgstr "Модуль `expirationd`"

#: ../doc/reference/reference_rock/expirationd.rst:7
msgid ""
"For a commercial-grade example of a Lua rock that works with Tarantool, "
"let us look at the source code of ``expirationd``, which Tarantool "
"supplies on GitHub_ with an Artistic license. The ``expirationd.lua`` "
"program is lengthy (about 500 lines), so here we will only highlight the "
"matters that will be enhanced by studying the full source later."
msgstr ""
"Рассмотрим исходный код ``expirationd`` -- пример Lua-модуля для "
"промышленной эксплуатации, который работает с Tarantool'ом -- Tarantool "
"предоставляет его с лицензией Artistic на GitHub_. Программа "
"``expirationd.lua`` довольно объемная (около 500 строк), поэтому здесь мы"
" остановимся на пунктах, знания о которых можно расширить, позднее изучив"
" программу полностью."

#: ../doc/reference/reference_rock/expirationd.rst:13
msgid ""
"task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""
"task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."

#: ../doc/reference/reference_rock/expirationd.rst:21
msgid ""
"Whenever one hears \"daemon\" in Tarantool, one should suspect it's being"
" done with a :doc:`fiber<../reference_lua/fiber>`. The program is making "
"a fiber and turning control over to it so it runs occasionally, goes to "
"sleep, then comes back for more."
msgstr ""
"Если в Tarantool'е упоминается \"демон\", то речь идет об использовании "
":doc:`файбера <../reference_lua/fiber>`. Программа создает файбер и "
"передает управление так, что он периодически запускается, уходит в режим "
"ожидания, а затем повторяет эти действия."

#: ../doc/reference/reference_rock/expirationd.rst:26
msgid ""
"for _, tuple in scan_space.index[0]:pairs(nil, {iterator = "
"box.index.ALL}) do\n"
"...\n"
"    expiration_process(task, tuple)\n"
"...\n"
"    /* expiration_process() contains:\n"
"    if task.is_tuple_expired(task.args, tuple) then\n"
"    task.expired_tuples_count = task.expired_tuples_count + 1\n"
"    task.process_expired_tuple(task.space_id, task.args, tuple) */"
msgstr ""
"for _, tuple in scan_space.index[0]:pairs(nil, {iterator = "
"box.index.ALL}) do\n"
"...\n"
"    expiration_process(task, tuple)\n"
"...\n"
"    /* expiration_process() contains:\n"
"    if task.is_tuple_expired(task.args, tuple) then\n"
"    task.expired_tuples_count = task.expired_tuples_count + 1\n"
"    task.process_expired_tuple(task.space_id, task.args, tuple) */"

#: ../doc/reference/reference_rock/expirationd.rst:37
msgid ""
"The \"for\" instruction can be translated as \"iterate through the index "
"of the space that is being scanned\", and within it, if the tuple is "
"\"expired\" (for example, if the tuple has a timestamp field which is "
"less than the current time), process the tuple as an expired tuple."
msgstr ""
"Команду \"for\" можно перевести как \"выполнить итерацию по индексу "
"сканируемого спейса\", а внутри -- если кортеж \"неактуален\" (например, "
"если в кортеже есть поле метки времени, которое меньше текущего времени),"
" то обработать кортеж как неактуальный кортеж."

#: ../doc/reference/reference_rock/expirationd.rst:42
msgid ""
"-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    box.space[space_id]:delete(construct_key(space_id, tuple))\n"
"end\n"
"    /* construct_key() contains:\n"
"    local function construct_key(space_id, tuple)\n"
"        return fun.map(\n"
"            function(x) return tuple[x.fieldno] end,\n"
"           box.space[space_id].index[0].parts\n"
"        ):totable()\n"
"    end */"
msgstr ""
"-- функция обработки неактуального кортежа по умолчанию\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    box.space[space_id]:delete(construct_key(space_id, tuple))\n"
"end\n"
"    /* construct_key() contains:\n"
"    local function construct_key(space_id, tuple)\n"
"        return fun.map(\n"
"            function(x) return tuple[x.fieldno] end,\n"
"           box.space[space_id].index[0].parts\n"
"        ):totable()\n"
"    end */"

#: ../doc/reference/reference_rock/expirationd.rst:56
msgid ""
"Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` "
"which does a \"delete\" of a tuple from its original space. First the fun"
" :ref:`fun <fun-module>` module is used, specifically fun.map_. "
"Remembering that :codenormal:`index[0]` is always the space's primary "
"key, and "
":codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is "
"always the field number for key part :codeitalic:`N`, fun.map() is "
"creating a table from the primary-key values of the tuple. The result of "
"fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""
"В конечном итоге, обработка неактуального кортежа приводит к "
"``default_tuple_drop()``, что приводит к удалению кортежа из "
"первоначального спейса. Сначала используется модуль :ref:`fun <fun-"
"module>`, в частности fun.map_. Учитывая, что :codenormal:`index[0]` "
"всегда является первичным ключом спейса, а "
":codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` "
"всегда является номером поля для компонента ключа :codeitalic:`N`, "
"функция fun.map() создает таблицу из первичных значений кортежа. "
"Результат fun.map() передается в :ref:`space_object:delete() <box_space-"
"delete>`."

#: ../doc/reference/reference_rock/expirationd.rst:66
msgid ""
"local function expirationd_run_task(name, space_id, is_tuple_expired, "
"options)\n"
"..."
msgstr ""
"local function expirationd_run_task(name, space_id, is_tuple_expired, "
"options)\n"
"..."

#: ../doc/reference/reference_rock/expirationd.rst:71
msgid ""
"At this point, if the above explanation is worthwhile, it is clear that "
"``expirationd.lua`` starts a background routine (fiber) which iterates "
"through all the tuples in a space, sleeps cooperatively so that other "
"fibers can operate at the same time, and -- whenever it finds a tuple "
"that has expired -- deletes it from this space. Now the "
"\"``expirationd_run_task()``\" function can be used in a test which "
"creates sample data, lets the daemon run for a while, and prints results."
msgstr ""
"На этом этапе ясно, что ``expirationd.lua`` запускает фоновый процесс "
"(файбер), который выполняет итерацию по всем кортежам в спейсе, в рамках "
"кооперативной многозадачности уходит в режим ожидания, чтобы другие "
"файберы могли работать одновременно с ним, а когда находит неактуальный "
"кортеж, удаляет его из спейса. Теперь функцию "
"\"``expirationd_run_task()``\" можно использовать в тестировании, где "
"создаются образцы данных, некоторое время работает демон, и выводятся "
"результаты."

#: ../doc/reference/reference_rock/expirationd.rst:80
msgid ""
"For those who like to see things run, here are the exact steps to get "
"``expirationd`` through the test."
msgstr ""
"Если вы хотите увидеть, как все работает, обратите внимание на "
"нижеприведенные шаги по включению ``expirationd`` в тестирование."

#: ../doc/reference/reference_rock/expirationd.rst:83
msgid ""
"Get ``expirationd.lua``. There are standard ways -- it is after all part "
"of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_ "
"-- but for this purpose just copy the contents of ``expirationd.lua`` to "
"a directory on the Lua path (type ``print(package.path)`` to see the Lua "
"path)."
msgstr ""
"Найдите ``expirationd.lua``. Можно воспользоваться стандартным способом, "
"поскольку модуль включен в общий список `модулей "
"<https://luarocks.org/modules/rtsisyk/expirationd>`_, но для этой цели "
"просто скопируйте содержимое ``expirationd.lua`` в директорию в Lua-пути "
"(введите ``print(package.path)``, чтобы увидеть Lua-путь)."

#: ../doc/reference/reference_rock/expirationd.rst:88
msgid "Start the Tarantool server as described before."
msgstr "Запустите Tarantool-сервер, как описано выше."

#: ../doc/reference/reference_rock/expirationd.rst:89
msgid "Execute these requests:"
msgstr "Выполните следующие запросы:"

#: ../doc/reference/reference_rock/expirationd.rst:91
msgid ""
"fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""
"fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"

#: ../doc/reference/reference_rock/expirationd.rst:114
msgid ""
"The database-specific requests (``cfg``, :ref:`space.create <box_schema-"
"space_create>`, :ref:`create_index <box_space-create_index>`) should "
"already be familiar."
msgstr ""
"Запросы в работе с базой данных (``cfg``, :ref:`space.create <box_schema-"
"space_create>`, :ref:`create_index <box_space-create_index>`) уже должны "
"быть вам знакомы."

#: ../doc/reference/reference_rock/expirationd.rst:119
msgid ""
"The function which will be supplied to ``expirationd`` is "
":codenormal:`is_tuple_expired`, which is saying \"if the second field of "
"the tuple is less than the :ref:`current time <fiber-time>`  , then "
"return true, otherwise return false\"."
msgstr ""
"В ``expirationd`` передается функция :codenormal:`is_tuple_expired`, "
"которая задает следующее условие: если второе поле кортежа меньше "
":ref:`текущего времени <fiber-time>`  , вернуть true (правда), в "
"противном случае, вернуть false (ложь)."

#: ../doc/reference/reference_rock/expirationd.rst:124
msgid ""
"The key for getting the rock rolling is ``expd = "
"require('expirationd')``. The require_ function is what reads in the "
"program; it will appear in many later examples in this manual, when it's "
"necessary to get a module that's not part of the Tarantool kernel, but is"
" on the Lua path (``package.path``) or the C path (``package.cpath``). "
"After the Lua variable expd has been assigned the value of the "
"``expirationd`` module, it's possible to invoke the module's "
"``run_task()`` function."
msgstr ""
"Ключ к запуску модуля -- ``expd = require('expirationd')``. Функция "
"require_ -- это именно то, что выполняет чтение в программе. Она появится"
" и в дальнейших примерах в данном руководстве, когда будет необходимо "
"запустить модуль, который не входит в ядро Tarantool'а, но находится в "
"Lua-пути (``package.path``) или же C-пути (``package.cpath``). После "
"того, как Lua-переменной expd присваивается значение модуля "
"``expirationd``, можно вызвать функцию модуля ``run_task()``."

#: ../doc/reference/reference_rock/expirationd.rst:133
msgid ""
"After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has "
"had time to do its iterations through the spaces, ``expd.task_stats()`` "
"will print out a report showing how many tuples have expired -- "
"\"expired_count: 0\"."
msgstr ""
"После ухода :ref:`в режим ожидания <fiber-sleep>` на две секунды, когда "
"проводится итерация по спейсам, ``expd.task_stats()`` выведет отчет о "
"количестве неактуальных кортежей -- \"expired_count: 0\"."

#: ../doc/reference/reference_rock/expirationd.rst:138
msgid ""
"After sleeping for two more seconds, ``expd.task_stats()`` will print out"
" a report showing how many tuples have expired -- \"expired_count: 1\". "
"This shows that the ``is_tuple_expired()`` function eventually returned "
"\"true\" for one of the tuples, because its timestamp field was more than"
" three seconds old."
msgstr ""
"После ожидания в течение еще двух секунд ``expd.task_stats()`` выведет "
"отчет о количестве неактуальных кортежей -- \"expired_count: 1\". Это "
"показывает, что функция ``is_tuple_expired()`` с течением времени вернула"
" \"true\" для одного из кортежей, поскольку поле метки времени было "
"дольше трех секунд."

#: ../doc/reference/reference_rock/expirationd.rst:145
msgid ""
"Of course, ``expirationd`` can be customized to do different things by "
"passing different parameters, which will be evident after looking in more"
" detail at the source code. Particularly important are ``{options}`` "
"which can be added as a final parameter in ``expirationd.run_task``:"
msgstr ""
"Конечно, ``expirationd`` можно настроить на выполнение различных задач с "
"помощью разных параметров, что будет очевидно после более детального "
"изучения исходного кода. В частности, важны опции ``{options}``, которые "
"можно добавить в качестве последнего параметра в "
"``expirationd.run_task``:"

#: ../doc/reference/reference_rock/expirationd.rst:150
msgid ""
"``force`` (boolean) -- run task even on replica. Default: ``force=false``"
" so ordinarily ``expirationd`` ignores replicas."
msgstr ""
"``force`` (логическое значение) -- выполнение задачи даже на реплике. По "
"умолчанию: ``force=false``, поэтому, как правило, ``expirationd`` не "
"учитывает реплики."

#: ../doc/reference/reference_rock/expirationd.rst:152
msgid ""
"``tuples_per_iteration`` (integer) -- number of tuples that will be "
"checked by one iteration Default: ``tuples_per_iteration=1024``."
msgstr ""
"``tuples_per_iteration`` (целое число) -- количество кортежей, которые "
"проверяются за одну итерацию. По умолчанию: "
"``tuples_per_iteration=1024``."

#: ../doc/reference/reference_rock/expirationd.rst:155
msgid ""
"``full_scan_time`` (number) -- number of seconds required for full index "
"scan Default: ``full_scan_time=3600``."
msgstr ""
"``full_scan_time`` (число) -- число секунд на полное сканирование диска. "
"По умолчанию: ``full_scan_time=3600``."

#: ../doc/reference/reference_rock/expirationd.rst:157
msgid ""
"``vinyl_assumed_space_len`` (integer) -- assumed size of vinyl space, for"
" the first iteration only. Default: ``vinyl_assumed_space_len=10000000``."
msgstr ""
"``vinyl_assumed_space_len`` (целое число) -- предполагаемый размер спейса"
" vinyl'а, используется только для первой итерации. По умолчанию: "
"``vinyl_assumed_space_len=10000000``."

#: ../doc/reference/reference_rock/expirationd.rst:160
msgid ""
"``vinyl_assumed_space_len_factor`` (integer) -- factor for recalculation "
"of size of vinyl space. Default: ``vinyl_assumed_space_len_factor=2``. "
"(The size of a vinyl space cannot be easily calculated, so on the first "
"iteration it will be the \"assumed\" size, on the second iteration it "
"will be \"assumed\" times \"factor\", on the third iteration it will be "
"\"assumed\" times \"factor\" times factor\", and so on.)"
msgstr ""
"``vinyl_assumed_space_len_factor`` (целое число) -- коэффициент "
"перерасчета размера спейса vinyl'а. По умолчанию: "
"``vinyl_assumed_space_len_factor=2``. (Размер спейса vinyl'а не так легко"
" рассчитать, поэтому для первой итерации используется \"предполагаемый\" "
"размер, на второй итерации -- \"предполагаемый\" размер, помноженный на "
"\"коэффициент\", на третьей итерации -- \"предполагаемый\" размер, дважды"
" помноженный на \"коэффициент\" и так далее.)"

#: ../doc/reference/reference_rock/index.rst:3
msgid "Rocks reference"
msgstr "Справочник по сторонним библиотекам"

#: ../doc/reference/reference_rock/index.rst:5
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr "В данном справочнике описаны сторонние Lua-модули для Tarantool'а."

#: ../doc/reference/reference_rock/membership.rst:5
msgid "Module `membership`"
msgstr "Модуль `membership`"

#: ../doc/reference/reference_rock/membership.rst:7
msgid ""
"This module is a ``membership`` library for Tarantool based on a gossip "
"protocol."
msgstr ""
"Этот модуль представляет собой библиотеку ``membership`` для Tarantool'а "
"на основе протокола gossip."

#: ../doc/reference/reference_rock/membership.rst:9
msgid ""
"This library builds a mesh from multiple Tarantool instances. The mesh "
"monitors itself, helps members discover everyone else in the group and "
"get notified about their status changes with low latency. It is built "
"upon the ideas from Consul or, more precisely, the SWIM algorithm."
msgstr ""
"Эта библиотека создает сеть из нескольких экземпляров Tarantool. Сеть "
"сама контролирует себя, помогает участникам обнаружить всех остальных в "
"группе и получать уведомления об изменениях своего статуса с низкой "
"задержкой. Модуль основан на концепциях из Consul или, точнее, алгоритма "
"SWIM."

#: ../doc/reference/reference_rock/membership.rst:14
msgid ""
"The ``membership`` module works over UDP protocol and can operate even "
"before the ``box.cfg`` initialization."
msgstr ""
"Модуль ``membership`` работает по протоколу UDP и может производить "
"операции даже до инициализации box.cfg."

#: ../doc/reference/reference_rock/membership.rst:21
msgid "Member data structure"
msgstr "Структура членов данных"

#: ../doc/reference/reference_rock/membership.rst:23
msgid "A member is represented by the table with the following fields:"
msgstr "Члены-данные представлены в виде таблиц со следующими полями:"

#: ../doc/reference/reference_rock/membership.rst:25
msgid "``uri`` (string) is a Uniform Resource Identifier."
msgstr "``uri`` (строка) -- это унифицированный идентификатор ресурса."

#: ../doc/reference/reference_rock/membership.rst:26
msgid "``status`` (string) is a string that takes one of the values below."
msgstr ""
"``status`` (строка) -- это строка, которая принимает одно из следующих "
"значений."

#: ../doc/reference/reference_rock/membership.rst:28
msgid "``alive``: a member that replies to ping-messages is ``alive`` and well."
msgstr ""
"``alive``: член группы, который отвечает на сообщения проверки связи, "
"работоспособен в статусе ``alive``."

#: ../doc/reference/reference_rock/membership.rst:29
msgid ""
"``suspect``: if any member in the group cannot get a reply from any other"
" member, the first member asks three other ``alive`` members to send a "
"ping-message to the member in question. If there is no response, the "
"latter becomes a ``suspect``."
msgstr ""
"``suspect``: если какой-либо член группы не может получить ответ от "
"какого-либо другого участника, первый член группы просит трех других "
"активных членов группы в статусе ``alive`` отправить сообщение проверки "
"связи соответствующему участнику. Если ответа нет, последний получает "
"статус сомнительного, то есть ``suspect``."

#: ../doc/reference/reference_rock/membership.rst:33
msgid "``dead``: a ``suspect`` becomes ``dead`` after a timeout."
msgstr ""
"``dead``: член группы в статусе ``suspect`` получает статус вышедшего из "
"строя ``dead`` по истечении времени ожидания."

#: ../doc/reference/reference_rock/membership.rst:34
msgid ""
"``left``: a member gets the ``left`` status after executing the "
":ref:`leave() <membership-leave>` function."
msgstr ""
"``left``: член группы получает статус выбывшего ``left`` после выполнения"
" функции :ref:`leave() <membership-leave>`."

#: ../doc/reference/reference_rock/membership.rst:37
msgid ""
"The gossip protocol guarantees that every member in the group becomes "
"aware of any status change in two communication cycles."
msgstr ""
"Протокол gossip гарантирует, что каждый член группы узнает о любом "
"изменении статуса в двух циклах связи."

#: ../doc/reference/reference_rock/membership.rst:40
msgid ""
"``incarnation`` (number) is a value incremented every time the instance "
"is becomes a ``suspect``, ``dead``, or updates its payload."
msgstr ""
"``incarnation`` (число) -- это значение, которое увеличивается каждый "
"раз, когда экземпляр получает статус ``suspect``, ``dead`` или обновляет "
"полезную нагрузку."

#: ../doc/reference/reference_rock/membership.rst:42
msgid "``payload`` (table) is auxiliary data that can be used by various modules."
msgstr ""
"``payload`` (таблица) -- это вспомогательные данные, которыми могут "
"воспользоваться различные модули."

#: ../doc/reference/reference_rock/membership.rst:43
msgid "``timestamp`` (number) is a value of ``fiber.time64()`` which:"
msgstr "``timestamp`` (число) -- это значение ``fiber.time64()``, которое:"

#: ../doc/reference/reference_rock/membership.rst:45
msgid "corresponds to the last update of ``status`` or ``incarnation``;"
msgstr ""
"соответствует последнему обновлению параметра ``status`` или "
"``incarnation``;"

#: ../doc/reference/reference_rock/membership.rst:46
msgid "is always local;"
msgstr "всегда локально;"

#: ../doc/reference/reference_rock/membership.rst:47
msgid "does not depend on other members' clock setting."
msgstr "не зависит от настроек часов других членов группы."

#: ../doc/reference/reference_rock/membership.rst:49
msgid "Below is an example of the table:"
msgstr "Ниже приведен пример таблицы:"

#: ../doc/reference/reference_rock/membership.rst:51
msgid ""
"tarantool> membership.myself()\n"
"---\n"
"uri: localhost:33001\n"
"status: alive\n"
"incarnation: 1\n"
"payload:\n"
"    uuid: 2d00c500-2570-4019-bfcc-ab25e5096b73\n"
"timestamp: 1522427330993752\n"
"..."
msgstr ""
"tarantool> membership.myself()\n"
"---\n"
"uri: localhost:33001\n"
"status: alive\n"
"incarnation: 1\n"
"payload:\n"
"    uuid: 2d00c500-2570-4019-bfcc-ab25e5096b73\n"
"timestamp: 1522427330993752\n"
"..."

#: ../doc/reference/reference_rock/membership.rst:67
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:196
msgid "API reference"
msgstr "Справочник по API"

#: ../doc/reference/reference_rock/membership.rst:69
msgid ""
"Below is a list of ``membership``'s common, encryption, subscription "
"functions, and options."
msgstr ""
"Ниже приведен список простых функций, функций шифрования, подписки и "
"параметры модуля ``membership``."

#: ../doc/reference/reference_rock/membership.rst:80
msgid "Common functions"
msgstr "Простые функции"

#: ../doc/reference/reference_rock/membership.rst:82
msgid ":ref:`init(advertise_host, port) <membership-init>`"
msgstr ":ref:`init(advertise_host, port) <membership-init>`"

#: ../doc/reference/reference_rock/membership.rst:82
msgid "Initialize the ``membership`` module."
msgstr "Инициализация модуля ``membership``."

#: ../doc/reference/reference_rock/membership.rst:85
msgid ":ref:`myself() <membership-myself>`"
msgstr ":ref:`myself() <membership-myself>`"

#: ../doc/reference/reference_rock/membership.rst:85
msgid "Get the member data structure of the current instance."
msgstr "Получение структуры данных текущего экземпляра."

#: ../doc/reference/reference_rock/membership.rst:88
msgid ":ref:`get_member(uri) <membership-get-member>`"
msgstr ":ref:`get_member(uri) <membership-get-member>`"

#: ../doc/reference/reference_rock/membership.rst:88
msgid "Get the member data structure for a given URI."
msgstr "Получение структуры данных для указанного URI."

#: ../doc/reference/reference_rock/membership.rst:91
msgid ":ref:`members() <membership-members>`"
msgstr ":ref:`members() <membership-members>`"

#: ../doc/reference/reference_rock/membership.rst:91
msgid "Obtain a table with all members known to the current instance."
msgstr "Получение таблицы со всеми членами группы, известными текущему экземпляру."

#: ../doc/reference/reference_rock/membership.rst:94
msgid ":ref:`pairs() <membership-pairs>`"
msgstr ":ref:`pairs() <membership-pairs>`"

#: ../doc/reference/reference_rock/membership.rst:94
msgid "Shorthand for ``pairs(membership.members())``."
msgstr "Сокращение для ``pairs(membership.members())``."

#: ../doc/reference/reference_rock/membership.rst:97
msgid ":ref:`add_member(uri) <membership-add-member>`"
msgstr ":ref:`add_member(uri) <membership-add-member>`"

#: ../doc/reference/reference_rock/membership.rst:97
msgid "Add a member to the group."
msgstr "Добавление члена в группу."

#: ../doc/reference/reference_rock/membership.rst:100
msgid ":ref:`probe_uri(uri) <membership-probe-uri>`"
msgstr ":ref:`probe_uri(uri) <membership-probe-uri>`"

#: ../doc/reference/reference_rock/membership.rst:100
msgid "Check if the member is in the group."
msgstr "Проверка принадлежности члена к группе."

#: ../doc/reference/reference_rock/membership.rst:103
msgid ":ref:`broadcast() <membership-broadcast>`"
msgstr ":ref:`broadcast() <membership-broadcast>`"

#: ../doc/reference/reference_rock/membership.rst:103
msgid "Discover members in LAN by sending a UDP broadcast message."
msgstr ""
"Обнаружение участников в локальной сети путем отправки широковещательного"
" сообщения UDP."

#: ../doc/reference/reference_rock/membership.rst:106
msgid ":ref:`set_payload(key, value) <membership-set-payload>`"
msgstr ":ref:`set_payload(key, value) <membership-set-payload>`"

#: ../doc/reference/reference_rock/membership.rst:106
msgid "Update ``myself().payload`` and disseminate it."
msgstr "Обновление ``myself().payload`` и распространение информации."

#: ../doc/reference/reference_rock/membership.rst:109
msgid ":ref:`leave() <membership-leave>`"
msgstr ":ref:`leave() <membership-leave>`"

#: ../doc/reference/reference_rock/membership.rst:109
msgid "Gracefully leave the group."
msgstr "Корректное исключение из группы."

#: ../doc/reference/reference_rock/membership.rst:112
msgid ":ref:`is_encrypted() <membership-is-encrypted>`"
msgstr ":ref:`is_encrypted() <membership-is-encrypted>`"

#: ../doc/reference/reference_rock/membership.rst:112
msgid "Check if encryption is enabled."
msgstr "Проверка, включено ли шифрование."

#: ../doc/reference/reference_rock/membership.rst:115
msgid "Encryption functions"
msgstr "Функции шифрования"

#: ../doc/reference/reference_rock/membership.rst:117
msgid ":ref:`set_encryption_key(key) <membership-set-enc-key>`"
msgstr ":ref:`set_encryption_key(key) <membership-set-enc-key>`"

#: ../doc/reference/reference_rock/membership.rst:117
msgid "Set the key for low-level message encryption."
msgstr "Установка ключа для низкоуровневого шифрования сообщений."

#: ../doc/reference/reference_rock/membership.rst:120
msgid ":ref:`get_encryption_key() <membership-get-enc-key>`"
msgstr ":ref:`get_encryption_key() <membership-get-enc-key>`"

#: ../doc/reference/reference_rock/membership.rst:120
msgid "Retrieve the encryption key in use."
msgstr "Получение используемого ключа шифрования."

#: ../doc/reference/reference_rock/membership.rst:123
msgid "Subscription functions"
msgstr "Функции подписки"

#: ../doc/reference/reference_rock/membership.rst:125
msgid ":ref:`subscribe() <membership-subscribe>`"
msgstr ":ref:`subscribe() <membership-subscribe>`"

#: ../doc/reference/reference_rock/membership.rst:125
msgid "Subscribe for the members table updates."
msgstr "Подписка на обновления членов таблицы."

#: ../doc/reference/reference_rock/membership.rst:128
msgid ":ref:`unsubscribe() <membership-unsubscribe>`"
msgstr ":ref:`unsubscribe() <membership-unsubscribe>`"

#: ../doc/reference/reference_rock/membership.rst:128
msgid "Remove the subscription."
msgstr "Удаление подписки."

#: ../doc/reference/reference_rock/membership.rst:131
msgid "Options"
msgstr "Параметры"

#: ../doc/reference/reference_rock/membership.rst:133
msgid ":ref:`PROTOCOL_PERIOD_SECONDS <membership-protocol_period_seconds>`"
msgstr ":ref:`PROTOCOL_PERIOD_SECONDS <membership-protocol_period_seconds>`"

#: ../doc/reference/reference_rock/membership.rst:133
msgid "Direct ping period."
msgstr "Время отправки сообщений проверки связи напрямую."

#: ../doc/reference/reference_rock/membership.rst:136
msgid ":ref:`ACK_TIMEOUT_SECONDS <membership-ack_timeout_seconds>`"
msgstr ":ref:`ACK_TIMEOUT_SECONDS <membership-ack_timeout_seconds>`"

#: ../doc/reference/reference_rock/membership.rst:136
msgid "ACK message wait time."
msgstr "Время ожидания сообщения подтверждения."

#: ../doc/reference/reference_rock/membership.rst:139
msgid ":ref:`ANTI_ENTROPY_PERIOD_SECONDS <member-anti_entropy_period_seconds>`"
msgstr ":ref:`ANTI_ENTROPY_PERIOD_SECONDS <member-anti_entropy_period_seconds>`"

#: ../doc/reference/reference_rock/membership.rst:139
msgid "Anti-entropy synchronization period."
msgstr "Период синхронизации во избежание энтропии."

#: ../doc/reference/reference_rock/membership.rst:142
msgid ":ref:`SUSPECT_TIMEOUT_SECONDS <membership-suspect_timeout_seconds>`"
msgstr ":ref:`SUSPECT_TIMEOUT_SECONDS <membership-suspect_timeout_seconds>`"

#: ../doc/reference/reference_rock/membership.rst:142
msgid "Timeout to mark a ``suspect`` ``dead``."
msgstr ""
"Время ожидания, чтобы перевести члена группы из статуса ``suspect`` в "
"``dead``."

#: ../doc/reference/reference_rock/membership.rst:145
msgid ":ref:`NUM_FAILURE_DETECTION_SUBGROUPS <membership-num_fail_detect_subgr>`"
msgstr ":ref:`NUM_FAILURE_DETECTION_SUBGROUPS <membership-num_fail_detect_subgr>`"

#: ../doc/reference/reference_rock/membership.rst:145
msgid "Number of members to ping a ``suspect`` indirectly."
msgstr ""
"Число членов группы, которые отправляют сообщения проверки связи члену "
"группы в статусе ``suspect``."

#: ../doc/reference/reference_rock/membership.rst:152
msgid "Common functions:"
msgstr "Простые функции:"

#: ../doc/reference/reference_rock/membership.rst:158
msgid ""
"Initialize the ``membership`` module. This binds a UDP socket to "
"``0.0.0.0:<port>``, sets the ``advertise_uri`` parameter to "
"``<advertise_host>:<port>``, and ``incarnation`` to ``1``."
msgstr ""
"Инициализация модуля ``membership``. Привязывает UDP-сокет к "
"``0.0.0.0:<port>``, задает значение параметра ``advertise_uri`` = "
"``<advertise_host>:<port>`` (передаваемый хост, порт) и значение "
"параметра ``incarnation`` = ``1``."

#: ../doc/reference/reference_rock/membership.rst:162
msgid ""
"The ``init()`` function can be called several times, the old socket will "
"be closed and a new one opened."
msgstr ""
"Функцию ``init()`` можно вызвать несколько раз, старый сокет будет "
"закрыт, откроется новый сокет."

#: ../doc/reference/reference_rock/membership.rst:165
msgid ""
"If the ``advertise_uri`` changes during the next ``init()``, the old URI "
"is considered ``DEAD``. In order to leave the group gracefully, use the "
":ref:`leave() <membership-leave>` function."
msgstr ""
"Если значение параметра ``advertise_uri`` изменится во время очередного "
"выполнения ``init()``, старый URI считается недоступным со статусом "
"``DEAD``. Чтобы корректно исключить члена из группы, используйте функцию "
":ref:`leave() <membership-leave>`."

#: ../doc/reference/reference_rock/membership.rst:169
msgid "a hostname or IP address to advertise to other members"
msgstr "имя хоста или IP-адрес, передаваемый другим членам группы"

#: ../doc/reference/reference_rock/membership.rst:170
msgid "a UDP port to bind"
msgstr "привязываемый UDP-порт"

#: ../doc/reference/reference_rock/membership.rst:171
#: ../doc/reference/reference_rock/membership.rst:267
#: ../doc/reference/reference_rock/membership.rst:277
msgid "``true``"
msgstr "``true`` (правда)"

#: ../doc/reference/reference_rock/membership.rst
msgid "raises"
msgstr "вызывает"

#: ../doc/reference/reference_rock/membership.rst:173
msgid "socket bind error"
msgstr "подключенный сокет, если нет ошибки"

#: ../doc/reference/reference_rock/membership.rst:179
msgid ""
"the :ref:`member data structure <membership-datastruct>` of the current "
"instance."
msgstr ""
":ref:`структура данных члена группы <membership-datastruct>` для текущего"
" экземпляра."

#: ../doc/reference/reference_rock/membership.rst:187
msgid "the given member's ``advertise_uri``"
msgstr "``advertise_uri`` для указанного члена группы"

#: ../doc/reference/reference_rock/membership.rst:188
msgid ""
"the :ref:`member data structure <membership-datastruct>` of the instance "
"with the given URI."
msgstr ""
":ref:`структура данных <membership-datastruct>` экземпляра с указанным "
"URI."

#: ../doc/reference/reference_rock/membership.rst:196
msgid "Obtain all members known to the current instance."
msgstr "Получение всех членов группы, известных текущему экземпляру."

#: ../doc/reference/reference_rock/membership.rst:198
msgid "Editing this table has no effect."
msgstr "Редактирование этой таблицы ни на что не вляет."

#: ../doc/reference/reference_rock/membership.rst:200
msgid ""
"a table with URIs as keys and corresponding :ref:`member data structures "
"<membership-datastruct>` as values."
msgstr ""
"таблица с URI в качестве ключей и :ref:`структурой данных члена группы "
"<membership-datastruct>` в качестве значений."

#: ../doc/reference/reference_rock/membership.rst:209
msgid "A shorthand for ``pairs(membership.members())``."
msgstr "Сокращение для ``pairs(membership.members())``."

#: ../doc/reference/reference_rock/membership.rst:211
msgid "Lua iterator"
msgstr "Lua-итератор"

#: ../doc/reference/reference_rock/membership.rst:213
msgid "It can be used in the following way:"
msgstr "Можно использовать следующим образом:"

#: ../doc/reference/reference_rock/membership.rst:215
msgid ""
"for uri, member in memberhip.pairs()\n"
"  -- do something\n"
"end"
msgstr ""
"for uri, member in memberhip.pairs()\n"
"  -- что-то сделать\n"
"end"

#: ../doc/reference/reference_rock/membership.rst:225
msgid ""
"Add a member with the given URI to the group and propagate this event to "
"other members. Adding a member to a single instance is enough as "
"everybody else in the group will receive the update with time. It does "
"not matter who adds whom."
msgstr ""
"Добавление в группу члена с указанным URI и передача информации об этом "
"событии другим членам группы. Достаточно добавить члена группы в один "
"экземпляр, так как все остальные экземпляры в группе со временем получат "
"информацию об этом. Не имеет значения, кто кого добавляет."

#: ../doc/reference/reference_rock/membership.rst:230
msgid "the ``advertise_uri`` of the member to add"
msgstr "параметр ``advertise_uri`` добавляемого члена группы"

#: ../doc/reference/reference_rock/membership.rst:231
msgid "``true`` or ``nil`` in case of an error"
msgstr "``true`` (правда) или нулевое значение ``nil`` в случае ошибки"

#: ../doc/reference/reference_rock/membership.rst:233
msgid "parse error if the URI cannot be parsed"
msgstr "ошибка анализа, если URI нельзя проанализировать"

#: ../doc/reference/reference_rock/membership.rst:239
msgid ""
"Send a message to a member to make sure it is in the group. If the member"
" is ``alive`` but not in the group, it is added. If it already is in the "
"group, nothing happens."
msgstr ""
"Отправка сообщения члену группы, чтобы убедиться, что он включен в "
"группу. Если экземпляр активен со статусом ``alive``, но не включен в "
"группу, происходит его добавление. Если он уже включен в группу, ничего "
"не происходит."

#: ../doc/reference/reference_rock/membership.rst:242
msgid "the ``advertise_uri`` of the member to ping"
msgstr ""
"параметр ``advertise_uri`` члена группы, которому отправляются сообщения "
"проверки связи"

#: ../doc/reference/reference_rock/membership.rst:243
msgid ""
"``true`` if the member responds within 0.2 seconds, otherwise ``no "
"response``"
msgstr ""
"``true`` (правда), если ответ возвращается в течение 0.2 секунды, в "
"остальных случаях ``no response`` (нет ответа)"

#: ../doc/reference/reference_rock/membership.rst:245
msgid "``ping was not sent`` if the hostname could not be resolved"
msgstr ""
"``ping was not sent`` (сообщение проверки связи не отправлено), если имя "
"хоста не разрешено"

#: ../doc/reference/reference_rock/membership.rst:251
msgid ""
"Discover members in local network by sending a UDP broadcast message to "
"all networks discovered by a ``getifaddrs()`` C call."
msgstr ""
"Обнаружение членов группы в локальной сети путем отправки "
"широковещательного сообщения UDP во все сети, обнаруженные с помощью "
"вызова ``getifaddrs()`` на языке C."

#: ../doc/reference/reference_rock/membership.rst:254
msgid "``true`` if broadcast was sent, ``false`` if ``getaddrinfo()`` fails."
msgstr ""
"``true`` (правда), если сообщение отправлено, ``false`` (ложь), если "
"``getaddrinfo()`` не выполнена."

#: ../doc/reference/reference_rock/membership.rst:261
msgid ""
"Update ``myself().payload`` and disseminate it along with the member "
"status."
msgstr ""
"Обновление ``myself().payload`` и распространение соответствующей "
"информации вместе со статусом члена группы."

#: ../doc/reference/reference_rock/membership.rst:263
msgid "Increments ``incarnation``."
msgstr "Увеличивает значение параметра ``incarnation``."

#: ../doc/reference/reference_rock/membership.rst:265
msgid "a key to set in payload table"
msgstr "ключ, задаваемый в таблице payload"

#: ../doc/reference/reference_rock/membership.rst:266
msgid "auxiliary data"
msgstr "дополнительные данные"

#: ../doc/reference/reference_rock/membership.rst:274
msgid ""
"Gracefully leave the ``membership`` group. The node will be marked with "
"the ``left`` status and no other members will ever try to reconnect it."
msgstr ""
"Корректное исключение из группы ``membership``. Узел получает статус "
"выбывшего ``left``, другие члены группы не будут пытаться снова "
"подключить его."

#: ../doc/reference/reference_rock/membership.rst:284
msgid "``true`` if encryption is enabled, ``false`` otherwise."
msgstr "``true`` (правда), если шифрование включено, ``false`` в противном случае."

#: ../doc/reference/reference_rock/membership.rst:287
msgid "Encryption functions:"
msgstr "Функции шифрования:"

#: ../doc/reference/reference_rock/membership.rst:293
msgid ""
"Set the key used for low-level message encryption. The key is either "
"trimmed or padded automatically to be exactly 32 bytes. If the ``key`` "
"value is ``nil``, the encryption is disabled."
msgstr ""
"Установка ключа, который используется для низкоуровневого шифрования "
"сообщений. Ключ автоматически обрезается или дополняется до 32 байтов. "
"Если значения ключа ``key`` нулевое ``nil``, шифрование будет отключено."

#: ../doc/reference/reference_rock/membership.rst:297
msgid ""
"The encryption is handled by the ``crypto.cipher.aes256.cbc`` Tarantool "
"module."
msgstr "Модуль Tarantool ``crypto.cipher.aes256.cbc`` занимается шифрованием."

#: ../doc/reference/reference_rock/membership.rst:300
msgid ""
"For proper communication, all members must be configured to use the same "
"encryption key. Otherwise, members report either ``dead`` or ``non-"
"decryptable`` in their status."
msgstr ""
"Чтобы обеспечить правильную связь, все члены группы должны быть настроены"
" на использование одного и того же ключа шифрования. В противном случае "
"члены группы получат статус либо ``dead``, либо ``non-decryptable`` "
"(невозможно расшифровать)."

#: ../doc/reference/reference_rock/membership.rst:304
msgid "encryption key"
msgstr "ключ шифрования"

#: ../doc/reference/reference_rock/membership.rst:305
#: ../doc/reference/reference_rock/membership.rst:336
msgid "``nil``."
msgstr "``nil``."

#: ../doc/reference/reference_rock/membership.rst:311
msgid "Retrieve the encryption key that is currently in use."
msgstr "Получение используемого ключа шифрования."

#: ../doc/reference/reference_rock/membership.rst:313
msgid "encryption key or ``nil`` if the encryption is disabled."
msgstr "ключ шифрования или нулевое значение ``nil``, если шифрование отключено."

#: ../doc/reference/reference_rock/membership.rst:316
msgid "Subscription functions:"
msgstr "Функции подписки:"

#: ../doc/reference/reference_rock/membership.rst:322
msgid "Subscribe for updates in the members table."
msgstr "Подписка на обновления членов таблицы."

#: ../doc/reference/reference_rock/membership.rst:324
msgid "a ``fiber.cond`` object broadcasted whenever the members table changes."
msgstr "объект ``fiber.cond``, который передается при каждом изменении таблицы."

#: ../doc/reference/reference_rock/membership.rst:325
msgid "object"
msgstr "объект"

#: ../doc/reference/reference_rock/membership.rst:331
msgid ""
"Remove subscription on ``cond`` obtained by the :ref:`subscribe() "
"function <membership-subscribe>`."
msgstr ""
"Удаление подписки на ``cond``, получаемый с помощью функции "
":ref:`subscribe() <membership-subscribe>`."

#: ../doc/reference/reference_rock/membership.rst:333
msgid "The ``cond``'s validity is not checked."
msgstr "Достоверность ``cond`` не проверяется."

#: ../doc/reference/reference_rock/membership.rst:335
msgid ""
"the ``fiber.cond`` object obtained from :ref:`subscribe() <membership-"
"subscribe>`"
msgstr ""
"объект ``fiber.cond``, получаемый с помощью функции :ref:`subscribe() "
"<membership-subscribe>`"

#: ../doc/reference/reference_rock/membership.rst:338
msgid "Below is a list of ``membership`` options. They can be set as follows:"
msgstr ""
"Ниже приведен перечень параметров ``membership``. Их можно задать "
"следующим образом:"

#: ../doc/reference/reference_rock/membership.rst:340
msgid ""
"options = require('membership.options')\n"
"options.<option> = <value>"
msgstr ""
"options = require('membership.options')\n"
"options.<параметр> = <значение>"

#: ../doc/reference/reference_rock/membership.rst:349
msgid "Period of sending direct pings. Denoted as ``T'`` in the SWIM protocol."
msgstr ""
"Период отправки сообщение проверки связи напрямую. Обозначается как "
"``T'`` в протоколе SWIM."

#: ../doc/reference/reference_rock/membership.rst:355
msgid ""
"Time to wait for ACK message after a ping. If a member is late to reply, "
"the indirect ping algorithm is invoked."
msgstr ""
"Время ожидания сообщения подтверждения после отправки сообщения проверки "
"связи. Если ответ запаздывает, вызывается алгоритм косвенной проверки "
"связи."

#: ../doc/reference/reference_rock/membership.rst:362
msgid ""
"Period to perform the anti-entropy synchronization algorithm of the SWIM "
"protocol."
msgstr ""
"Период выполнения алгоритма синхронизации во избежание энтропии из "
"протокола SWIM."

#: ../doc/reference/reference_rock/membership.rst:369
msgid "Timeout to mark ``suspect`` members as ``dead``."
msgstr ""
"Время ожидания, чтобы перевести члена группы из статуса ``suspect`` в "
"``dead``."

#: ../doc/reference/reference_rock/membership.rst:375
msgid ""
"Number of members to try pinging a ``suspect`` indirectly. Denoted as "
"``k`` in the SWIM protocol."
msgstr ""
"Число членов группы, которые пытаются отправить сообщения проверки связи "
"члену группы в статусе ``suspect``. Обозначается как ``k`` в протоколе "
"SWIM."

#: ../doc/reference/reference_rock/shard.rst:5
msgid "Module `shard`"
msgstr "Модуль `shard`"

#: ../doc/reference/reference_rock/shard.rst:9
msgid ""
"With sharding, the tuples of a tuple set are distributed to multiple "
"nodes, with a Tarantool database server instance on each node. With this "
"arrangement, each instance is handling only a subset of the total data, "
"so larger loads can be handled by simply adding more computers to a "
"network."
msgstr ""
"Во время шардинга кортежи из набора кортежей распределяются по нескольким"
" узлам, на каждом из которых есть экземпляр сервера базы данных "
"Tarantool'а. При таком распределении каждый экземпляр обрабатывает только"
" подмножество общих данных, поэтому появляется возможность обрабатывать "
"данные при больших нагрузках путем простого добавления большего "
"количества компьютеров в сеть."

#: ../doc/reference/reference_rock/shard.rst:14
msgid ""
"The Tarantool `shard` module has facilities for creating shards, as well "
"as analogues for the data-manipulation functions of the box library "
"(select, insert, replace, update, delete)."
msgstr ""
"Модуль Tarantool'а `shard` позволяет создавать шарды, а также аналоги "
"функций по управлению данными из библиотеки box (select, insert, replace,"
" update, delete)."

#: ../doc/reference/reference_rock/shard.rst:18
msgid "First some terminology:"
msgstr "Для начала введем терминологию:"

#: ../doc/reference/reference_rock/shard.rst:21
msgid "**Consistent hash**"
msgstr "**Консистентное хеширование**"

#: ../doc/reference/reference_rock/shard.rst:23
msgid ""
"The `shard` module distributes according to a hash algorithm, that is, it"
" applies a hash function to a tuple's primary-key value in order to "
"decide which shard the tuple belongs to. The hash function is `consistent"
" <https://en.wikipedia.org/wiki/Consistent_hashing>`_ so that changing "
"the number of servers will not affect results for many keys. The specific"
" hash function that the `shard` module uses is :ref:`digest.guava "
"<digest-guava>` in the :codeitalic:`digest` module."
msgstr ""
"Модуль `shard` распределяет данные в соответствии с алгоритмом "
"хеширования, то есть применяет хеш-функцию к значению первичного ключа "
"кортежа, что определить к какому шарду относится кортеж. Хеш-функция "
"является `консистентной "
"<https://en.wikipedia.org/wiki/Consistent_hashing>`_, поэтому изменение "
"количества серверов не повлияет на результат для множества ключей. Модуль"
" `shard` использует специальную хеш-функцию :ref:`digest.guava <digest-"
"guava>` из модуля :codeitalic:`digest`."

#: ../doc/reference/reference_rock/shard.rst:30
msgid "**Instance**"
msgstr "**Экземпляр**"

#: ../doc/reference/reference_rock/shard.rst:32
msgid ""
"A currently-running in-memory copy of the Tarantool server, sometimes "
"called a \"server instance\". Usually each shard is associated with one "
"instance, or, if both sharding and replicating are going on, each shard "
"is associated with one replica set."
msgstr ""
"Запущенная in-memory копия Tarantool-сервера иногда называется "
"экземпляром сервера. Как правило, каждый шард ассоциирован с одним "
"экземпляром, или же, если выполняется и шардинг, и репликация, каждый "
"шард ассоциирован с одним набором реплик."

#: ../doc/reference/reference_rock/shard.rst:36
msgid "**Queue**"
msgstr "**Очередь**"

#: ../doc/reference/reference_rock/shard.rst:38
msgid ""
"A temporary list of recent update requests. Sometimes called "
"\"batching\". Since updates to a sharded database can be slow, it may "
"speed up throughput to send requests to a queue rather than wait for the "
"update to finish on every node. The `shard` module has functions for "
"adding requests to the queue, which it will process without further "
"intervention. Queuing is optional."
msgstr ""
"Временный список последних запросов обновления. Иногда называется "
"\"пакетная обработка\". Поскольку обновления в базу данных с шардингом "
"могут быть замедлены, ускорить выполнение можно путем отправки запросов в"
" очередь вместо ожидания окончания обновления на каждом узле. В модуле "
"`shard` присутствуют функции для добавления запросов в очередь, которые "
"будут затем обработаны без дополнительных действий. Использование очереди"
" необязательно."

#: ../doc/reference/reference_rock/shard.rst:44
msgid "**Redundancy**"
msgstr "**Резервирование по принципу избыточности**"

#: ../doc/reference/reference_rock/shard.rst:46
msgid "The number of replicated data copies in each shard."
msgstr "Количество копий реплицируемых данных в каждом шарде."

#: ../doc/reference/reference_rock/shard.rst:47
#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:401
msgid "**Replica**"
msgstr "**Реплика**"

#: ../doc/reference/reference_rock/shard.rst:49
msgid "An instance which is part of a replica set."
msgstr "Экземпляр, который входит в набор реплик."

#: ../doc/reference/reference_rock/shard.rst:50
#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:390
msgid "**Replica set**"
msgstr "**Набор реплик**"

#: ../doc/reference/reference_rock/shard.rst:52
msgid ""
"Often a single shard is associated with a single instance; however, often"
" the shard is replicated. When a shard is replicated, the multiple "
"instances (\"replicas\"), which handle the shard's replicated data, are a"
" \"replica set\"."
msgstr ""
"Часто отдельный шард ассоциирован с отдельным экземпляром. Однако, часто "
"шард реплицируется. Когда шард реплицируется, множество экземпляров "
"(\"реплики\"), которые обрабатывают реплицируемые данные шарда, "
"составляют \"набор реплик\"."

#: ../doc/reference/reference_rock/shard.rst:56
msgid "**Replicated data**"
msgstr "**Реплицируемые данные**"

#: ../doc/reference/reference_rock/shard.rst:58
msgid ""
"A complete copy of the data. The `shard` module handles both sharding and"
" replication. One shard can contain one or more replicated data copies. "
"When a write occurs, the write is attempted on every replicated data copy"
" in turn. The `shard` module does not use the built-in replication "
"feature."
msgstr ""
"Полная копия данных. Модуль `shard` обрабатывает как шардинг, так и "
"репликацию. Один шард может содержать одну или несколько копий "
"реплицируемых данных. Попытки записи производятся по очереди на каждую "
"копию реплицируемых данных. Модуль `shard` не использует встроенную "
"функцию репликации."

#: ../doc/reference/reference_rock/shard.rst:62
msgid "**Shard**"
msgstr "**Шард**"

#: ../doc/reference/reference_rock/shard.rst:64
msgid ""
"A subset of the tuples in the database partitioned according to the value"
" returned by the consistent hash function. Usually each shard is on a "
"separate node, or a separate set of nodes (for example if redundancy = 3 "
"then the shard will be on three nodes)."
msgstr ""
"Подмножество кортежей в базе данных, разделенное по значению, которое "
"возвращает консистентная хеш-функция. Как правило, каждый шард находится "
"на отдельном узле или отдельном наборе узлов (например, если "
"резервирование = 3, то шард будет на трех узлах)."

#: ../doc/reference/reference_rock/shard.rst:68
msgid "**Zone**"
msgstr "**Зона**"

#: ../doc/reference/reference_rock/shard.rst:70
msgid ""
"A physical location where the nodes are closely connected, with the same "
"security and backup and access points. The simplest example of a zone is "
"a single computer with a single Tarantool-server instance. A shard's "
"replicated data copies should be in different zones."
msgstr ""
"Физическое местоположение, где узлы тесно связаны, с одинаковыми точками "
"безопасности, резервного копирования и доступа. Простейшим примером зоны "
"является один компьютер с одним экземпляром Tarantool-сервера. Копии "
"реплицируемых данных на шарде должны находиться в разных зонах."

#: ../doc/reference/reference_rock/shard.rst:75
msgid ""
"The `shard` package is distributed separately from the main `tarantool` "
"package. To acquire it, do a separate installation:"
msgstr ""
"Пакет `shard` распространяется отдельно от основного пакета `Tarantool`. "
"Для работы с ним выполните установку отдельно:"

#: ../doc/reference/reference_rock/shard.rst:78
msgid "with Tarantool 1.7.4+, say:"
msgstr "либо на версии Tarantool'а 1.7.4+ выполните команду:"

#: ../doc/reference/reference_rock/shard.rst:80
msgid "$ tarantoolctl rocks install shard"
msgstr "$ tarantoolctl rocks install shard"

#: ../doc/reference/reference_rock/shard.rst:84
msgid "install with `yum` or `apt`, for example on Ubuntu say:"
msgstr ""
"либо установите с помощью `yum` или `apt`, например, на Ubuntu выполните "
"команду:"

#: ../doc/reference/reference_rock/shard.rst:86
msgid "$ sudo apt-get install tarantool-shard"
msgstr "$ sudo apt-get install tarantool-shard"

#: ../doc/reference/reference_rock/shard.rst:90
msgid ""
"or download from GitHub `tarantool/shard` and use the Lua files as "
"described in the `README <https://github.com/tarantool/shard>`_."
msgstr ""
"либо скачайте из GitHub `tarantool/shard` и используйте Lua-файлы, как "
"описано в файле `README <https://github.com/tarantool/shard>`_."

#: ../doc/reference/reference_rock/shard.rst:93
msgid "Then, before using the module, say ``shard = require('shard')``."
msgstr ""
"Затем перед использованием модуля выполните команду ``shard = "
"require('shard')``."

#: ../doc/reference/reference_rock/shard.rst:95
msgid "The most important function is:"
msgstr "Самой необходимой функцией модуля является"

#: ../doc/reference/reference_rock/shard.rst:134
msgid "shard.init(*shard-configuration*)"
msgstr "shard.init(*настройка-шарда*)"

#: ../doc/reference/reference_rock/shard.rst:102
msgid "This must be called for every shard."
msgstr "Ее следует вызывать для каждого шарда."

#: ../doc/reference/reference_rock/shard.rst:104
msgid "The shard configuration is a table with these fields:"
msgstr "Настройка шарда представляет собой таблицу со следующими полями:"

#: ../doc/reference/reference_rock/shard.rst:106
msgid "`servers` (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""
"`servers` -- серверы, т.е. список URI узлов и зон, в которых находятся "
"узлы"

#: ../doc/reference/reference_rock/shard.rst:107
msgid "`login` (the user name which applies for accessing via the `shard` module)"
msgstr ""
"`login` -- имя пользователя, которое используется для доступа по модулю "
"`shard`"

#: ../doc/reference/reference_rock/shard.rst:108
msgid "`password` (the password for the login)"
msgstr "`password` -- пароль для имени пользователя"

#: ../doc/reference/reference_rock/shard.rst:109
msgid "`redundancy` (a number, minimum 1)"
msgstr "`redundancy` -- резервирование, число, минимум 1"

#: ../doc/reference/reference_rock/shard.rst:110
msgid ""
"`binary` (a port number that this host is listening on, on the current "
"host, (distinguishable from the 'listen' port specified by `box.cfg`)"
msgstr ""
"`binary` -- номер порта, на котором настроено прослушивание для текущего "
"хоста (отличный от порта 'listen', который определяет `box.cfg`)"

#: ../doc/reference/reference_rock/shard.rst:113
msgid "Possible errors:"
msgstr "Возможные ошибки:"

#: ../doc/reference/reference_rock/shard.rst:115
msgid "redundancy should not be greater than the number of servers;"
msgstr ""
"значение параметра redundancy (резервирование) не должно быть больше "
"количества серверов;"

#: ../doc/reference/reference_rock/shard.rst:116
msgid "the servers must be alive;"
msgstr "серверы должны быть рабочими;"

#: ../doc/reference/reference_rock/shard.rst:117
msgid ""
"two replicated data copies of the same shard should not be in the same "
"zone."
msgstr ""
"две копии реплицируемых данных одного шарда не должны находиться в одной "
"зоне."

#: ../doc/reference/reference_rock/shard.rst:121
msgid "Example: `shard.init` syntax for one shard"
msgstr "Пример: синтаксис `shard.init` для одного шарда"

#: ../doc/reference/reference_rock/shard.rst:123
msgid "The number of replicated data copies per shard (redundancy) is 3."
msgstr ""
"Количество копий реплицируемых данных на один шард (redundancy -- "
"резервирование) равно 3."

#: ../doc/reference/reference_rock/shard.rst:124
msgid "The number of instances is 3."
msgstr "Количество экземпляров равно 3."

#: ../doc/reference/reference_rock/shard.rst:125
msgid "The `shard` module will conclude that there is only one shard."
msgstr "Модуль `shard` делает вывод, что существует только один шард."

#: ../doc/reference/reference_rock/shard.rst:127
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."

#: ../doc/reference/reference_rock/shard.rst:148
msgid "Example: `shard.init` syntax for three shards"
msgstr "Пример: синтаксис `shard.init` для трех шардов"

#: ../doc/reference/reference_rock/shard.rst:150
msgid ""
"This describes three shards. Each shard has two replicated data copies. "
"Since the number of servers is 7, and the number of replicated data "
"copies per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of"
" the servers will not be used. This is not necessarily an error, because "
"perhaps one of the servers in the list is not alive."
msgstr ""
"Здесь описаны три шарда. Каждый шард содержит две копии реплицируемых "
"данных. Поскольку количество серверов равно 7, количество копий "
"реплицируемых данных на один шард равно 2, а деление 7 на 2 дает в "
"остатке 1, -- один из серверов не будет использоваться. Это необязательно"
" должно быть ошибкой, поскольку один из серверов может быть нерабочим."

#: ../doc/reference/reference_rock/shard.rst:155
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."

#: ../doc/reference/reference_rock/shard.rst:178
msgid ""
"Every data-access function in the `box` module has an analogue in the "
"`shard` module:"
msgstr ""
"Каждой функции взаимодействия с данными модуля `box` соответствует "
"функция в модуле `shard`:"

#: ../doc/reference/reference_rock/shard.rst:218
msgid ""
"shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""
"shard[*имя-спейса*].insert{...}\n"
"shard[*имя-спейса*].replace{...}\n"
"shard[*имя-спейса*].delete{...}\n"
"shard[*имя-спейса*].select{...}\n"
"shard[*имя-спейса*].update{...}\n"
"shard[*имя-спейса*].auto_increment{...}"

#: ../doc/reference/reference_rock/shard.rst:191
msgid ""
"For example, to insert in table T in a sharded database you simply say "
"``shard.T:insert{...}`` instead of ``box.space.T:insert{...}``."
msgstr ""
"Например, чтобы выполнить вставку в таблицу T в базе данных с шардингом, "
"просто выполните команду ``shard.T:insert{...}`` вместо "
"``box.space.T:insert{...}``."

#: ../doc/reference/reference_rock/shard.rst:194
msgid "A ``shard.T:select{}`` request without a primary key will cause an error."
msgstr "Запрос ``shard.T:select{}`` без первичного ключа вызовет ошибку."

#: ../doc/reference/reference_rock/shard.rst:196
msgid "Every queued data-access function has an analogue in the `shard` module:"
msgstr ""
"Каждой функции модуля `box` для взаимодействия с данными, поставленной в "
"очередь, соответствует функция в модуле `shard`:"

#: ../doc/reference/reference_rock/shard.rst:235
msgid ""
"shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""
"shard[*имя-спейса*].q_insert{...}\n"
"shard[*имя-спейса*].q_replace{...}\n"
"shard[*имя-спейса*].q_delete{...}\n"
"shard[*имя-спейса*].q_select{...}\n"
"shard[*имя-спейса*].q_update{...}\n"
"shard[*имя-спейса*].q_auto_increment{...}"

#: ../doc/reference/reference_rock/shard.rst:208
msgid ""
"The user must add an `operation_id`. For details of queued data-access "
"functions, and of maintenance-related functions, see the `README "
"<https://github.com/tarantool/shard>`_."
msgstr ""
"Пользователь должен добавить `operation_id`. Чтобы получить "
"дополнительную информацию о функциях для взаимодействия с данными, "
"поставленными в очередь, и о функциях, предназначенных для обслуживания, "
"см. файл `README <https://github.com/tarantool/shard>`_."

#: ../doc/reference/reference_rock/shard.rst:214
msgid "Example: shard, minimal configuration"
msgstr "Пример: шард, минимальная настройка"

#: ../doc/reference/reference_rock/shard.rst:216
msgid ""
"There is only one shard, and that shard contains only one replicated data"
" copy. So this isn't illustrating the features of either replication or "
"sharding, it's only illustrating what the syntax is, and what the "
"messages look like, that anyone could duplicate in a minute or two with "
"the magic of cut-and-paste."
msgstr ""
"Создан только один шард, который содержит только одну копию реплицируемых"
" данных. Таким образом, данный пример не иллюстрирует возможности "
"репликации или шардинга, он показывает синтаксис и отображаемые "
"сообщения, что каждый может повторить за пару минут лишь с помощью "
"вырезания и вставки."

#: ../doc/reference/reference_rock/shard.rst:222
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Введите что-нибудь ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"

#: ../doc/reference/reference_rock/shard.rst:249
msgid ""
"If you cut and paste the above, then the result, showing only the "
"requests and responses for `shard.init` and `shard.tester`, should look "
"approximately like this:"
msgstr ""
"Если вырезать и вставить вышеуказанное, то результат с запросами и "
"ответами только для `shard.init` и `shard.tester` должен выглядеть "
"примерно так:"

#: ../doc/reference/reference_rock/shard.rst:253
msgid ""
"<...>\n"
"tarantool> shard.init(cfg)\n"
"2017-09-06 ... I> Sharding initialization started...\n"
"2017-09-06 ... I> establishing connection to cluster servers...\n"
"2017-09-06 ... I> connected to all servers\n"
"2017-09-06 ... I> started\n"
"2017-09-06 ... I> redundancy = 1\n"
"2017-09-06 ... I> Adding localhost:3301 to shard 1\n"
"2017-09-06 ... I> shards = 1\n"
"2017-09-06 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""
"<...>\n"
"tarantool> shard.init(cfg)\n"
"2017-09-06 ... I> Sharding initialization started...\n"
"2017-09-06 ... I> establishing connection to cluster servers...\n"
"2017-09-06 ... I> connected to all servers\n"
"2017-09-06 ... I> started\n"
"2017-09-06 ... I> redundancy = 1\n"
"2017-09-06 ... I> Adding localhost:3301 to shard 1\n"
"2017-09-06 ... I> shards = 1\n"
"2017-09-06 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Введите что--нибудь...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."

#: ../doc/reference/reference_rock/shard.rst:278
msgid "Example: shard, scaling out"
msgstr "Пример: шард, горизонтальное масштабирование"

#: ../doc/reference/reference_rock/shard.rst:280
msgid ""
"There are two shards, and each shard contains one replicated data copy. "
"This requires two nodes. In real life the two nodes would be two "
"computers, but for this illustration the requirement is merely: start two"
" shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""
"Созданы два шарда, каждый из которых содержит одну копию реплицируемых "
"данных. В реальной жизни два узла будут представлены двумя компьютерами, "
"для примера же требуется использовать две оболочки, которые мы назовем "
"\"терминал №1\" и \"терминал №2\"."

#: ../doc/reference/reference_rock/shard.rst:285
msgid "On Terminal #1, say:"
msgstr "В первом терминале введите:"

#: ../doc/reference/reference_rock/shard.rst:287
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Введите что-нибудь ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"

#: ../doc/reference/reference_rock/shard.rst:316
msgid "On Terminal #2, say:"
msgstr "Во втором терминале введите:"

#: ../doc/reference/reference_rock/shard.rst:318
msgid ""
"$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""
"$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Выведите что-нибудь ...\n"
"tarantool> shard.tester:select{1}"

#: ../doc/reference/reference_rock/shard.rst:347
msgid ""
"What will appear on Terminal #1 is: a loop of error messages saying "
"\"Connection refused\" and \"server check failure\". This is normal. It "
"will go on until Terminal #2 process starts."
msgstr ""
"На терминале №1 появится цикл сообщений с ошибками типа \"Connection "
"refused\" (в подключении отказано) и \"server check failure\" (отказ "
"проверки сервера). Это нормально. Сообщения будут появляться, пока не "
"начнется процесс на терминале №2."

#: ../doc/reference/reference_rock/shard.rst:351
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr "В конце, на терминале №2 появится примерно следующее:"

#: ../doc/reference/reference_rock/shard.rst:353
msgid ""
"tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""
"tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."

#: ../doc/reference/reference_rock/shard.rst:360
msgid ""
"This shows that what was inserted by Terminal #1 can be selected by "
"Terminal #2, via the `shard` module."
msgstr ""
"Данный пример показывает, что введенная на терминале №1 информация может "
"быть извлечена на терминале №2 с помощью модуля `shard`."

#: ../doc/reference/reference_rock/shard.rst:363
msgid "For details, see the `README <https://github.com/tarantool/shard>`_."
msgstr ""
"Для получения подробной информации см. файл `README "
"<https://github.com/tarantool/shard>`_."

#: ../doc/reference/reference_rock/tdb.rst:3
msgid "Module `tdb`"
msgstr "Модуль `tdb`"

#: ../doc/reference/reference_rock/tdb.rst:5
msgid ""
"The Tarantool Debugger (abbreviation = ``tdb``) can be used with any Lua "
"program. The operational features include: setting breakpoints, examining"
" variables, going forward one line at a time, backtracing, and showing "
"information about fibers. The display features include: using different "
"colors for different situations, including line numbers, and adding "
"hints."
msgstr ""
"Отладчик Tarantool'а (сокращенно ``tdb``) можно использовать с любой "
"Lua-программой. Рабочие функции: определение точек прерывания, "
"исследование переменных, перебор строк по одной, обратная трассировка и "
"отображение информации о файберах. Функции вывода: использование "
"различных цветов в разных ситуациях, включая номера строк, и добавление "
"подсказок."

#: ../doc/reference/reference_rock/tdb.rst:11
msgid ""
"It is not supplied as part of the Tarantool repository; it must be "
"installed separately. Here is the usual way:"
msgstr ""
"Модуль не поставляется в репозитории Tarantool'а, его следует "
"устанавливать отдельно. Это обычно делается следующим образом:"

#: ../doc/reference/reference_rock/tdb.rst:14
msgid ""
"$ git clone --recursive https://github.com/Sulverus/tdb\n"
"$ cd tdb\n"
"$ make\n"
"$ sudo make install prefix=/usr/share/tarantool/"
msgstr ""
"$ git clone --recursive https://github.com/Sulverus/tdb\n"
"$ cd tdb\n"
"$ make\n"
"$ sudo make install prefix=/usr/share/tarantool/"

#: ../doc/reference/reference_rock/tdb.rst:21
msgid ""
"To initiate ``tdb`` within a Lua program and set a breakpoint, edit the "
"program to include these lines:"
msgstr ""
"Чтобы запустить ``tdb`` в рамках Lua-программы и определить точку "
"прерывания, включите в программу следующие строки:"

#: ../doc/reference/reference_rock/tdb.rst:24
msgid ""
"tdb = require('tdb')\n"
"tdb.start()"
msgstr ""
"tdb = require('tdb')\n"
"tdb.start()"

#: ../doc/reference/reference_rock/tdb.rst:29
msgid ""
"To start the debugging session, execute the Lua program. Execution will "
"stop at the breakpoint, and it will be possible to enter debugging "
"commands."
msgstr ""
"Чтобы начать сессию отладки, выполните Lua-программу: выполнение "
"остановится на точке прерывания, и можно будет вводить команды отладчика."

#: ../doc/reference/reference_rock/tdb.rst:34
msgid "Debugger Commands"
msgstr "Команды отладчика"

#: ../doc/reference/reference_rock/tdb.rst:38
msgid ":codebold:`bt`"
msgstr ":codebold:`bt`"

#: ../doc/reference/reference_rock/tdb.rst:37
msgid ""
"Backtrace -- show the stack (in red), with program/function names and "
"line numbers of whatever has been invoked to reach the current line."
msgstr ""
"Обратная трассировка -- отображение стека (красным) с именами "
"программы/функции и номерами строк, выполнение которых привело к текущей "
"строке."

#: ../doc/reference/reference_rock/tdb.rst:41
msgid ":codebold:`c`"
msgstr ":codebold:`c`"

#: ../doc/reference/reference_rock/tdb.rst:41
msgid "Continue till next breakpoint or till program ends."
msgstr ""
"Продолжение выполнения до следующей точки прерывания или до окончания "
"программы."

#: ../doc/reference/reference_rock/tdb.rst:48
msgid ":codebold:`e`"
msgstr ":codebold:`e`"

#: ../doc/reference/reference_rock/tdb.rst:44
msgid ""
"Enter evaluation mode. When the program is in evaluation mode, one can "
"execute certain Lua statements that would be valid in the context. This "
"is particularly useful for displaying the values of the program's "
"variables. Other debugger commands will not work until one exits "
"evaluation mode by typing :codebold:`-e`."
msgstr ""
"Вход в режим вычисления. Когда программа находится в режиме вычисления, "
"можно выполнять определенные запросы, которые будут действовать с точки "
"зрения контекста. Это особенно полезно для отображения значений "
"переменных программы. Другие команды отладчика не будут работать, пока не"
" выйти из режима оценки, набрав: :codebold:`-e`."

#: ../doc/reference/reference_rock/tdb.rst:51
msgid ":codebold:`-e`"
msgstr ":codebold:`-e`"

#: ../doc/reference/reference_rock/tdb.rst:51
msgid "Exit evaluation mode."
msgstr "Выход из режима оценка."

#: ../doc/reference/reference_rock/tdb.rst:55
msgid ":codebold:`f`"
msgstr ":codebold:`f`"

#: ../doc/reference/reference_rock/tdb.rst:54
msgid ""
"Display the fiber id, the program name, and the percentage of memory "
"used, as a table."
msgstr ""
"Отображение идентификатора файбера, имени программы и процентного "
"соотношения использованной памяти в виде таблицы."

#: ../doc/reference/reference_rock/tdb.rst:58
msgid ":codebold:`n`"
msgstr ":codebold:`n`"

#: ../doc/reference/reference_rock/tdb.rst:58
msgid "Go to the next line, skipping over any function calls."
msgstr "Переход на следующую строку с пропуском любых вызовов функций."

#: ../doc/reference/reference_rock/tdb.rst:61
msgid ":codebold:`globals`"
msgstr ":codebold:`globals`"

#: ../doc/reference/reference_rock/tdb.rst:61
msgid "Display names of variables or functions which are defined as global."
msgstr "Отображение имен переменных или функций, которые являются глобальными."

#: ../doc/reference/reference_rock/tdb.rst:64
msgid ":codebold:`h`"
msgstr ":codebold:`h`"

#: ../doc/reference/reference_rock/tdb.rst:64
msgid "Display a list of debugger commands."
msgstr "Отображение списка команд отладчика."

#: ../doc/reference/reference_rock/tdb.rst:68
msgid ":codebold:`locals`"
msgstr ":codebold:`locals`"

#: ../doc/reference/reference_rock/tdb.rst:67
msgid ""
"Display names and values of variables, for example the control variables "
"of a Lua \"for\" statement."
msgstr ""
"Отображение имен и значений переменных, например, переменных для "
"управления Lua-оператором \"for\"."

#: ../doc/reference/reference_rock/tdb.rst:71
msgid ":codebold:`q`"
msgstr ":codebold:`q`"

#: ../doc/reference/reference_rock/tdb.rst:71
msgid "Quit immediately."
msgstr "Немедленный выход."

#: ../doc/reference/reference_rock/tdb.rst:75
msgid "Example Session"
msgstr "Пример сессии"

#: ../doc/reference/reference_rock/tdb.rst:77
msgid ""
"Put the following program in a default directory and call it "
"\"example.lua\":"
msgstr ""
"Сохраните следующую программу в директории по умолчанию и назовите ее "
"\"example.lua\":"

#: ../doc/reference/reference_rock/tdb.rst:79
msgid ""
"tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""
"tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"

#: ../doc/reference/reference_rock/tdb.rst:87
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr "Запустите Tarantool, используя example.lua в качестве файла инициализации."

#: ../doc/reference/reference_rock/tdb.rst:89
msgid "$ tarantool example.lua"
msgstr "$ tarantool example.lua"

#: ../doc/reference/reference_rock/tdb.rst:93
#: ../doc/reference/reference_rock/tdb.rst:118
msgid "The screen should now look like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/reference/reference_rock/tdb.rst:132
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"

#: ../doc/reference/reference_rock/tdb.rst:105
msgid ""
"Debugger prompts are blue, debugger hints and information are green, and "
"the current line -- line 3 of example.lua -- is the default color. Now "
"enter six debugger commands:"
msgstr ""
"Запросы отладчика выделены синим, подсказки и информация -- зеленым, а "
"текущая строка -- 3 строка программы example.lua -- цветом, который "
"используется по умолчанию. Введите 6 команд отладчика:"

#: ../doc/reference/reference_rock/tdb.rst:109
msgid ""
"n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""
"n  -- переход на следующую строку\n"
"n  -- переход на следующую строку\n"
"e  -- вход в режим оценки\n"
"j  -- отображение j\n"
"-e -- выход из режима оценки\n"
"q  -- выход"

#: ../doc/reference/reference_rock/tdb.rst:157
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"

#: ../doc/reference/reference_rock/tdb.rst:140
msgid ""
"Another debugger example can be found `here "
"<https://github.com/sulverus/tdb>`_."
msgstr ""
"Другой пример работы отладчика можно найти `здесь "
"<https://github.com/sulverus/tdb>`_."

#: ../doc/reference/reference_rock/vshard/index.rst:5
msgid "Module `vshard`"
msgstr "Модуль `vshard`"

#: ../doc/reference/reference_rock/vshard/index.rst:7
#, fuzzy
msgid ""
"The ``vshard`` module introduces an advanced sharding feature based on "
"the concept of :ref:`virtual buckets <vshard-vbuckets>` and enables "
"horizontal scaling in Tarantool."
msgstr ""
"В модуле ``vshard`` реализована новая функция шардинга (сегментирования),"
" которая позволяет осуществлять горизонтальное масштабирование в "
"Tarantool'е."

#: ../doc/reference/reference_rock/vshard/index.rst:11
msgid ""
"Check out the :ref:`Quick start guide <vshard-quick-start>` -- or dive "
"into the complete ``vshard`` documentation:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:5
msgid "Administration"
msgstr "Администрирование"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:13
#, fuzzy
msgid ""
"The ``vshard`` module is distributed separately from the main Tarantool "
"package. To install it, say this:"
msgstr ""
"Пакет ``vshard`` распространяется отдельно от основного пакета "
"Tarantool'а. Для работы с ним выполните установку отдельно:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:16
msgid "$ tarantoolctl rocks install vshard"
msgstr "$ tarantoolctl rocks install vshard"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:22
msgid "The ``vshard`` module requires Tarantool version 1.9+."
msgstr "Для работы с модулем ``vshard`` необходима версия Tarantool'а 1.9+."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:28
#, fuzzy
msgid "Configuration"
msgstr "Образец конфигурации"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:30
#, fuzzy
msgid "Any viable sharded cluster consists of:"
msgstr "Минимальный рабочий сегментированный кластер должен состоять из:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:32
#, fuzzy
msgid ""
"one or more replica sets, each containing two or more :ref:`storage "
"<vshard-storage>` instances,"
msgstr ""
"одного или нескольких наборов реплик с двумя или несколькими "
":ref:`хранилищами <vshard-storage>` в каждом,"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:34
#, fuzzy
msgid "one or more :ref:`router <vshard-router>` instances."
msgstr "одного или нескольких :ref:`роутеров <vshard-router>`."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:36
msgid ""
"The number of ``storage`` instances in a replica set defines the "
"redundancy factor of the data. The recommended value is 3 or more. The "
"number of ``router`` instances is not limited, because routers are "
"completely stateless. We recommend increasing the number of routers when "
"an existing ``router`` instance becomes CPU or I/O bound."
msgstr ""
"Количество хранилищ в наборе реплик определяет коэффициент избыточности "
"данных. Рекомендуемое значение: 3 или более. Количество роутеров не "
"ограничено, потому что у роутеров нет состояния. Рекомендуем увеличивать "
"количество роутеров, если существующий экземпляр роутера ограничен "
"возможностями процессора или ввода-вывода."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:41
msgid ""
"``vshard`` supports multiple ``router`` instances on a single Tarantool "
"instance. Each ``router`` can be connected to any ``vshard`` cluster. "
"Multiple ``router`` instances can be connected to the same cluster."
msgstr ""
"``vshard`` поддерживает работу с несколькими роутерами в отдельном "
"экземпляре Tarantool'а. Каждый роутер может подключиться к любому "
"кластеру ``vshard``. Несколько роутеров могут быть подключены к одному "
"кластеру."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:45
msgid ""
"As the ``router`` and ``storage`` applications perform completely "
"different sets of functions, they should be deployed to different "
"Tarantool instances. Although it is technically possible to place the "
"router application on every ``storage`` node, this approach is highly "
"discouraged and should be avoided on production deployments."
msgstr ""
"Поскольку приложения роутера (``router``) и хранилища (``storage``) "
"выполняют совершенно разные наборы функций, их следует разворачивать на "
"различных экземплярах Tarantool'а. Хотя технически возможно разместить "
"приложение роутера на каждом узле типа хранилища, такой подход крайне не "
"рекомендуется, и его следует избегать при развертывании в "
"производственной среде."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:50
msgid ""
"All ``storage`` instances can be deployed using identical instance "
"(configuration) files."
msgstr ""
"Все хранилища можно развернуть, используя один набор файлов экземпляра "
"(конфигурационных файлов)."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:53
msgid "Self-identification is currently performed using ``tarantoolctl``:"
msgstr ""
"Самоопределение в настоящий момент осуществляется с помощью "
"``tarantoolctl``:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:55
msgid "$ tarantoolctl instance_name"
msgstr "$ tarantoolctl имя_экземпляра"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:59
msgid ""
"All ``router`` instances can also be deployed using identical instance "
"(configuration) files."
msgstr ""
"Все роутеры также можно развернуть, используя один набор файлов "
"экземпляра (конфигурационных файлов)."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:62
msgid ""
"All cluster nodes must share a common topology. An administrator must "
"ensure that the configurations are identical. We suggest using a "
"configuration management tool like Ansible or Puppet to deploy the "
"cluster."
msgstr ""
"Топология всех узлов кластера должна быть одинаковой. Администратор "
"должен убедиться, что конфигурации совпадают. Рекомендуем использовать "
"инструмент управления конфигурациями, такой как Ansible или Puppet, во "
"время развертывания кластера."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:66
msgid ""
"Sharding is not integrated into any system for centralized configuration "
"management. It is expected that the application itself is responsible for"
" interacting with such a system and passing the sharding parameters."
msgstr ""
"Шардинг не интегрирован ни в одну систему для централизованного "
"управления конфигурациями. Предполагается, что само приложение отвечает "
"за взаимодействие с такой системой и передачу параметров шардинга."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:70
msgid ""
"The configuration example of a simple sharded cluster is available "
":ref:`here <vshard-config-cluster-example>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:77
msgid "Replica weights"
msgstr "Вес реплики"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:79
#, fuzzy
msgid ""
"The ``router`` sends all read-write requests to the master instance only."
" Setting replica weights allows sending read-only requests not only to "
"the master instance, but to any available replica that is the 'nearest' "
"to the ``router``. Weights are used to define distances between replicas "
"within a replica set."
msgstr ""
"Роутер отправляет все запросы только на мастер-экземпляр. Задав вес "
"реплики, можно разрешить отправку запросов на чтение не только на "
"мастер-экземпляр, но и на доступную реплику, которая находится ближе "
"всего к роутеру. Вес используется для определения расстояния между "
"репликами в наборе реплик."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:84
msgid ""
"Weights can be used, for example, to define the physical distance between"
" the ``router`` and each replica in each replica set. In such a case read"
" requests are sent to the nearest replica."
msgstr ""
"Например, вес можно использовать для определения физического расстояния "
"между роутером и каждой репликой в наборе реплик. В таком случае запросы "
"на чтение будут отправляться на ближайшую реплику."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:88
msgid ""
"Setting weights can also help to define the most powerful replicas: the "
"ones that can process the largest number of requests per second."
msgstr ""
"Кроме того, можно задать вес реплик, чтобы определить наиболее мощную "
"реплику, которая может обрабатывать наибольшее количество запросов в "
"секунду."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:91
msgid ""
"The idea is to specify the zone for every ``router`` and every replica, "
"therefore filling a matrix of relative zone weights. This approach allows"
" setting different weights in different zones for the same replica set."
msgstr ""
"Основная идея состоит в том, чтобы указать зону для каждого ``роутера`` и"
" каждой реплики, и таким образом составить матрицу относительных весов "
"зоны. Этот подход позволяет устанавливать разный вес в разных зонах для "
"одного набора реплик."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:95
msgid ""
"To set weights, use the zone attribute for each replica during "
"configuration:"
msgstr ""
"Чтобы задать вес, используйте атрибут zone (зона) для каждой реплики во "
"время конфигурации:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:97
msgid ""
"local cfg = {\n"
"   sharding = {\n"
"      ['...replicaset_uuid...'] = {\n"
"         replicas = {\n"
"            ['...replica_uuid...'] = {\n"
"                 ...,\n"
"                 zone = <number or string>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"
msgstr ""
"local cfg = {\n"
"   sharding = {\n"
"      ['...uuid_набора_реплик...'] = {\n"
"         replicas = {\n"
"            ['...uuid_реплики...'] = {\n"
"                 ...,\n"
"                 zone = <число или строка>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:112
#, fuzzy
msgid ""
"Then, specify relative weights for each zone pair in the ``weights`` "
"parameter of ``vshard.router.cfg``. For example:"
msgstr ""
"Затем укажите относительный вес для каждой пары зон в параметре weights "
"(вес) в ``vshard.router.cfg``. Например:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:115
#, fuzzy
msgid ""
"weights = {\n"
"    [1] = {\n"
"        [2] = 1, -- Routers of the 1st zone see the weight of the 2nd "
"zone as 1.\n"
"        [3] = 2, -- Routers of the 1st zone see the weight of the 3rd "
"zone as 2.\n"
"        [4] = 3, -- ...\n"
"    },\n"
"    [2] = {\n"
"        [1] = 10,\n"
"        [2] = 0,\n"
"        [3] = 10,\n"
"        [4] = 20,\n"
"    },\n"
"    [3] = {\n"
"        [1] = 100,\n"
"        [2] = 200, -- Routers of the 3rd zone see the weight of the 2nd "
"zone as 200.\n"
"                   -- Mind that it is not equal to the weight of the 2nd "
"zone visible\n"
"                   -- from the 1st zone (= 1).\n"
"        [4] = 1000,\n"
"    }\n"
"}\n"
"\n"
"local cfg = vshard.router.cfg({weights = weights, sharding = ...})"
msgstr ""
"weights = {\n"
"    [1] = {\n"
"        [2] = 1, -- роутеры 1 зоны видят вес 2 зоны = 1\n"
"        [3] = 2, -- роутеры 1 зоны видят вес 3 зоны = 2\n"
"\n"
"\n"
"   [4] = 3, -- ...\n"
"    },\n"
"    [2] = {\n"
"        [1] = 10,\n"
"        [2] = 0,\n"
"        [3] = 10,\n"
"        [4] = 20,\n"
"    },\n"
"    [3] = {\n"
"        [1] = 100,\n"
"        [2] = 200, -- роутеры 3 зоны видят вес 2 зоны = 200. Обратите "
"внимание, что этот вес не равен весу 2 зоны (= 2), который видят роутеры "
"1 зоны\n"
"        [4] = 1000,\n"
"    }\n"
"}\n"
"\n"
"local cfg = vshard.router.cfg({weights = weights, sharding = ...})"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:144
msgid "Replica set weights"
msgstr "Вес набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:146
msgid ""
"A replica set weight is not the same as the replica weight. The weight of"
" a replica set defines the capacity of the replica set: the larger the "
"weight, the more buckets the replica set can store. The total size of all"
" sharded spaces in the replica set is also its capacity metric."
msgstr ""
"Вес набора реплик не равноценен весу реплики. Вес набора реплик "
"определяет производительность набора реплик: чем больше вес, тем больше "
"сегментов может хранить набор реплик. Общий размер всех сегментированных "
"спейсов в наборе реплик также определяет его производительность."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:151
msgid ""
"You can consider replica set weights as the relative amount of data "
"within a replica set. For example, if ``replicaset_1 = 100``, and "
"``replicaset_2 = 200``, the second replica set stores twice as many "
"buckets as the first one. By default, all weights of all replica sets are"
" equal."
msgstr ""
"Вес набора реплик можно рассматривать как относительный объем данных в "
"наборе реплик. Например, если ``replicaset_1 = 100``, и ``replicaset_2 = "
"200``, второй набор реплик хранит в два раза больше сегментов, чем "
"первый. По умолчанию веса всех наборов реплик равны."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:156
msgid ""
"You can use weights, for example, to store the prevailing amount of data "
"on a replica set with more memory space."
msgstr ""
"Вес можно использовать, к примеру, чтобы хранить преобладающий объем "
"данных в наборе реплик с большим объемом памяти."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:163
msgid "Rebalancing process"
msgstr "Процесс балансировки"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:165
msgid ""
"There is an **etalon number** of buckets for a replica set. (Etalon in "
"this context means \"ideal\".) If there is no deviation from this number "
"in the whole replica set, then the buckets are distributed evenly."
msgstr ""
"Существует **эталонное число** сегментов в наборе реплик (\"эталонный\" в"
" данном случае значит идеальный). Если во всем наборе реплик это число "
"остается неизменным, то сегменты распределяются равномерно."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:170
msgid ""
"The etalon number is calculated automatically considering the number of "
"buckets in the cluster and weights of the replica sets."
msgstr ""
"Эталонное число рассчитывается автоматически с учетом количества "
"сегментов в кластере и веса наборов реплик."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:173
msgid ""
"Rebalancing starts if the **disbalance threshold of a replica set** "
"exceeds the disbalance threshold :ref:`specified in the configuration "
"<cfg_basic-rebalancer_disbalance_threshold>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:177
#, fuzzy
msgid "The disbalance threshold of a replica set is calculated as follows:"
msgstr "Предел дисбаланса рассчитывается следующим образом:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:179
#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:214
msgid "|etalon_bucket_number - real_bucket_number| / etalon_bucket_number * 100"
msgstr ""
"|эталонное_число_сегментов - текущее_число_сегментов| / "
"эталонное_число_сегментов * 100"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:183
msgid ""
"For example: The user specified the number of buckets is 3000, and "
"weights of 3 replica sets are 1, 0.5, and 1.5. The resulting etalon "
"numbers of buckets for the replica sets are: 1st replica set – 1000, 2nd "
"replica set – 500, 3rd replica set – 1500."
msgstr ""
"Например: Пользователь указал, что количество сегментов = 3000, а вес 3 "
"наборов реплик составляет 1, 0,5 и 1,5. В результате получаем следующее "
"эталонное число сегментов для наборов реплик: 1 набор реплик – 1000, 2 "
"набор реплик – 500, 3 набор реплик – 1500."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:188
msgid ""
"This approach allows assigning a zero weight to a replica set, which "
"initiates migration of its buckets to the remaining cluster nodes. It "
"also allows adding a new zero-load replica set, which initiates migration"
" of the buckets from the loaded replica sets to the zero-load replica "
"set."
msgstr ""
"Такой подход позволяет назначить нулевой вес для набора реплик, который "
"запускает миграцию сегментов на оставшиеся узлы кластера. Это также "
"позволяет добавить новый набор реплик с нулевой нагрузкой, который "
"запускает миграцию сегментов из загруженных наборов реплик в набор реплик"
" с нулевой нагрузкой."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:195
msgid ""
"A new zero-load replica set should be assigned a weight for rebalancing "
"to start."
msgstr ""
"Новому набору реплик с нулевой нагрузкой следует присвоить вес, чтобы "
"начать процесс балансировки."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:197
msgid "When a new shard is added, the configuration can be updated dynamically:"
msgstr "При добавлении нового шарда конфигурацию можно обновить динамически:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:199
msgid ""
"The configuration should be updated on all the ``routers`` first, and "
"then on all the ``storages``."
msgstr ""
"Конфигурацию следует сначала обновить на всех роутерах, а затем на всех "
"хранилищах."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:201
msgid "The new shard becomes available for rebalancing in the ``storage`` layer."
msgstr "Новый шард становится доступен для балансирования на уровне хранилища."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:202
msgid "As a result of rebalancing, buckets are migrated to the new shard."
msgstr "В результате балансировки происходит миграция сегментов на новый шард."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:203
msgid ""
"If a migrated bucket is requested, ``router`` receives an error code "
"containing information about the new location of the bucket."
msgstr ""
"Если происходит запрос к перемещенному сегменту, ``роутер`` получает код "
"ошибки с информацией о новом местонахождении сегмента."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:206
msgid ""
"At this time, the new shard is already present in the ``router``'s pool "
"of connections, so redirection is transparent for the application."
msgstr ""
"В это время новый шард уже включен в пул соединений ``роутера``, поэтому "
"переадресация видима для приложения."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:213
#, fuzzy
msgid "Parallel rebalancing"
msgstr "Параллельная балансировка"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:215
msgid ""
"Originally, ``vshard`` had quite a simple ``rebalancer`` – one process on"
" one node that calculated *routes* which should send buckets, how many, "
"and to whom. The nodes applied these routes one by one sequentially."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:220
msgid ""
"Unfortunately, such a simple schema worked not fast enough, especially "
"for Vinyl, where costs of reading disk were comparable with network "
"costs. In fact, with Vinyl the ``rebalancer`` routes applier was sleeping"
" most of the time."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:225
msgid ""
"Now each node can send multiple buckets in parallel in a round-robin "
"manner to multiple destinations, or to just one."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:228
msgid ""
"To set the degree of parallelism, a new option was added -- "
":ref:`rebalancer_max_sending <cfg_basic-rebalancer_max_sending>`. You can"
" specify it in a storage configuration in the root table:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:232
msgid ""
"cfg.rebalancer_max_sending = 5\n"
"vshard.storage.cfg(cfg, box.info.uuid)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:237
#, fuzzy
msgid "In routers, this option is ignored."
msgstr "Этот параметр не учитывается для ``YAML``."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:241
msgid ""
"Specifying ``cfg.rebalancer_max_sending = N`` probably won't give N times"
" speed up. It depends on network, disk, number of other fibers in the "
"system."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:246
msgid ""
"You have 10 replica sets and a new one is added. Now all the 10 replica "
"sets will try to send buckets to the new one."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:249
msgid ""
"Assume that each replica set can send up to 5 buckets at once. In that "
"case, the new replica set will experience a rather big load of 50 buckets"
" being downloaded at once. If the node needs to do some other work, "
"perhaps such a big load is undesirable. Also too many parallel buckets "
"can cause timeouts in the rebalancing process itself."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:256
msgid ""
"To fix the problem, you can set a lower value for "
"``rebalancer_max_sending`` for old replica sets, or decrease "
"``rebalancer_max_receiving`` for the new one. In the latter case some "
"workers on old nodes will be throttled, and you will see that in the "
"logs."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:261
msgid ""
"``rebalancer_max_sending`` is important, if you have restrictions for the"
" maximal number of buckets that can be read-only at once in the cluster. "
"As you remember, when a bucket is being sent, it does not accept new "
"write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:266
#, fuzzy
msgid "**Example #2:**"
msgstr "**Пример 2:**"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:268
#, python-format
msgid ""
"You have 100000 buckets and each bucket stores ~0.001% of your data. The "
"cluster has 10 replica sets. And you never can afford > 0.1% of data "
"locked on write. Then you should not set ``rebalancer_max_sending`` > 10 "
"on these nodes. It guarantees that the rebalancer won't send more than "
"100 buckets at once in the whole cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:275
msgid ""
"If ``max_sending`` is too high and ``max_receiving`` is too low, then "
"some buckets will try to get relocated – and will fail with that. This "
"problem will consume network resources and time. It is important to "
"configure these parameters to not conflict with each other."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:284
msgid "Replica set lock and bucket pin"
msgstr "Блокировка набора реплик и закрепление корзины"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:286
msgid ""
"A replica set lock makes a replica set invisible to the ``rebalancer``: a"
" locked replica set can neither receive new buckets nor migrate its own "
"buckets."
msgstr ""
"Блокировка набора реплик делает набор реплик невидимым для "
"балансировщика: заблокированный набор реплик не может ни принимать новые "
"сегменты, ни мигрировать собственные сегменты."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:289
msgid ""
"A bucket pin blocks a specific bucket from migrating: a pinned bucket "
"stays on the replica set to which it is pinned, until it is unpinned."
msgstr ""
"В результате закрепления сегмента определенный сегмент блокируется для "
"миграции: закрепленный сегмент остается в наборе реплик, в котором он "
"закреплен, до отмены закрепления."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:292
msgid ""
"Pinning all replica set buckets is not equivalent to locking a replica "
"set. Even if you pin all buckets, a non-locked replica set can still "
"receive new buckets."
msgstr ""
"Закрепление всех сегментов в наборе реплик не означает блокирование "
"набора реплик. Даже после закрепления всех сегментов незаблокированный "
"набор реплик может принимать новые сегменты."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:295
msgid ""
"Replica set lock is helpful, for example, to separate a replica set from "
"production replica sets for testing, or to preserve some application "
"metadata that must not be sharded for a while. A bucket pin is used for "
"similar cases but in a smaller scope."
msgstr ""
"Блокировка набора реплик используется, к примеру, чтобы выделить для "
"тестирования набор реплик из наборов реплик, используемых в производстве,"
" или чтобы сохранить некоторые метаданные приложения, которые в течение "
"некоторого времени не должны быть сегментированы. Закрепление сегмента "
"используется в похожих случаях, но в меньшем масштабе."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:300
msgid ""
"By both locking a replica set and pinning all buckets, one can isolate an"
" entire replica set."
msgstr ""
"Блокировка набора реплик и закрепление всех сегментов означает изоляцию "
"целого набора реплик."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:303
msgid ""
"Locked replica sets and pinned buckets affect the rebalancing algorithm "
"as the ``rebalancer`` must ignore locked replica sets and consider pinned"
" buckets when attempting to reach the best possible balance."
msgstr ""
"Заблокированные наборы реплик и закрепленные сегменты влияют на алгоритм "
"балансировки, так как ``балансировщик`` должен игнорировать "
"заблокированные наборы реплик и учитывать закрепленные сегменты при "
"попытке достичь наилучшего возможного баланса."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:307
msgid ""
"The issue is not trivial as a user can pin too many buckets to a replica "
"set, so a perfect balance becomes unreachable. For example, consider the "
"following cluster (assume all replica set weights are equal to 1)."
msgstr ""
"Это нетривиальная задача, поскольку пользователь может закрепить слишком "
"много сегментов в наборе реплик, так что становится невозможным "
"достижение идеального баланса. Например, рассмотрим следующий кластер "
"(предположим, что все веса наборов реплик равны 1)."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:311
msgid "The initial configuration:"
msgstr "Начальная конфигурация:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:313
msgid ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120"
msgstr ""
"rs1: bucket_count = 150 -- число сегментов\n"
"rs2: bucket_count = 150, pinned_count = 120 -- число сегментов, число "
"закрепленных сегментов"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:318
msgid "Adding a new replica set:"
msgstr "Добавление нового набора реплик:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:320
msgid ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"
msgstr ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:326
msgid ""
"The perfect balance would be ``100 - 100 - 100``, which is impossible "
"since the ``rs2`` replica set has 120 pinned buckets. The best possible "
"balance here is the following:"
msgstr ""
"Идеальным балансом было бы ``100 - 100 - 100``, чего невозможно достичь, "
"поскольку набор реплик ``rs2`` содержит 120 закрепленных сегментов. The "
"best possible balance here is the following:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:330
msgid ""
"rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"
msgstr ""
"rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:336
msgid ""
"The ``rebalancer`` moved as many buckets as possible from ``rs2`` to "
"decrease the disbalance. At the same time it respected equal weights of "
"``rs1`` and ``rs3``."
msgstr ""
"``Балансировщик`` переместил максимально возможное количество сегментов "
"из ``rs2``, чтобы уменьшить дисбаланс. В то же время он учел одинаковый "
"вес respected ``rs1`` и ``rs3``."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:339
msgid ""
"The algorithms for implementing locks and pins are completely different, "
"although they look similar in terms of functionality."
msgstr ""
"Алгоритмы реализации блокировки и закрепления совершенно разные, хотя с "
"точки зрения функций они похожи."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:346
msgid "Replica set lock and rebalancing"
msgstr "Заблокированный набор реплик и балансировка"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:348
msgid ""
"Locked replica sets simply do not participate in rebalancing. This means "
"that even if the actual total number of buckets is not equal to the "
"etalon number, the disbalance cannot be fixed due to the lock. When the "
"rebalancer detects that one of the replica sets is locked, it "
"recalculates the etalon number of buckets of the non-locked replica sets "
"as if the locked replica set and its buckets did not exist at all."
msgstr ""
"Заблокированные наборы реплик просто не участвуют в балансировке. Это "
"означает, что даже если фактическое общее количество сегментов не равно "
"эталонному числу, дисбаланс нельзя исправить из-за блокировки. Когда "
"балансировщик обнаруживает, что один из наборов реплик заблокирован, он "
"пересчитывает эталонное число сегментов неблокированных наборов реплик, "
"как если бы заблокированный набор реплик и его сегменты вообще не "
"существовали."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:359
msgid "Bucket pin and rebalancing"
msgstr "Закрепленный набор реплик и балансировка"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:361
#, fuzzy
msgid ""
"Rebalancing replica sets with pinned buckets requires a more complex "
"algorithm. Here ``pinned_count[o]`` is the number of pinned buckets, and "
"``etalon_count`` is the etalon number of buckets for a replica set:"
msgstr ""
"Балансировка наборов реплик с закрепленными сегментами требует более "
"сложного алгоритма. Здесь pinned_count[o] -- это число закрепленных "
"сегментов, а ``etalon_count`` -- это эталонное число сегментов для набора"
" реплик:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:365
msgid ""
"The ``rebalancer`` calculates the etalon number of buckets as if all "
"buckets were not pinned. Then the rebalancer checks each replica set and "
"compares the etalon number of buckets with the number of pinned buckets "
"in a replica set. If ``pinned_count < etalon_count``, non-locked replica "
"sets (at this point all locked replica sets already are filtered out) "
"with pinned buckets can receive new buckets."
msgstr ""
"Балансировщик рассчитывает эталонное число сегментов, как если бы все "
"сегменты не были закреплены. Затем балансировщик проверяет каждый набор "
"реплик и сопоставляет эталонное число сегментов с числом закрепленных "
"сегментов в наборе реплик. Если ``pinned_count < etalon_count``, "
"незаблокированные наборы реплик (на данном этапе все заблокированные "
"наборы реплик уже отфильтрованы) с закрепленными сегментами могут "
"получать новые сегменты."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:371
msgid ""
"If ``pinned_count > etalon_count``, the disbalance cannot be fixed, as "
"the ``rebalancer`` cannot move pinned buckets out of this replica set. In"
" such a case the etalon number is updated and set equal to the number of "
"pinned buckets. The replica sets with ``pinned_count > etalon_count`` are"
" not processed by the ``rebalancer``, and the number of pinned buckets is"
" subtracted from the total number of buckets. The rebalancer tries to "
"move out as many buckets as possible from such replica sets."
msgstr ""
"Если же ``pinned_count > etalon_count``, дисбаланс исправить нельзя, так "
"как балансировщик не может вывести закрепленные сегменты из этого набора "
"реплик. В таком случае эталонное число обновляется как равное числу "
"закрепленных сегментов. Наборы реплик с ``pinned_count > etalon_count`` "
"не обрабатываются балансировщиком`, а число закрепленных сегментов "
"вычитается из общего числа сегментов. Балансировщик пытается вывести как "
"можно больше сегментов из таких наборов реплик."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:378
msgid ""
"This procedure is restarted from step 1 for replica sets with "
"``pinned_count >= etalon_count`` until ``pinned_count <= etalon_count`` "
"on all replica sets. The procedure is also restarted when the total "
"number of buckets is changed."
msgstr ""
"Эта процедура перезапускается с шага 1 для наборов реплик с "
"``pinned_count >= etalon_count`` до тех пор, пока не будет выполнено "
"условие ``pinned_count <= etalon_count`` для всех наборов реплик. "
"Процедура также перезапускается при изменении общего числа сегментов."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:383
msgid "Here is the pseudocode for the algorithm:"
msgstr "Псевдокод для данного алгоритма будет следующим:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:385
msgid ""
"function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- rebalance the buckets using weights of the still viable "
"replica sets --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"
msgstr ""
"function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- балансировка сегментов с использованием веса рабочих наборов "
"реплик --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:409
msgid ""
"The complexity of the algorithm is ``O(N^2)``, where N is the number of "
"replica sets. On each step, the algorithm either finishes the "
"calculation, or ignores at least one new replica set overloaded with the "
"pinned buckets, and updates the etalon number of buckets on other replica"
" sets."
msgstr ""
"Сложность алгоритма составляет ``O(N^2)``, где N -- количество наборов "
"реплик. На каждом шаге алгоритм либо завершает вычисление, либо "
"игнорирует хотя бы один новый набор реплик, перегруженный закрепленными "
"сегментами, и обновляет эталонное число сегментов в других наборах "
"реплик."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:418
msgid "Bucket ref"
msgstr "Ссылка в сегменте"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:420
msgid ""
"Bucket ref is an in-memory counter that is similar to the :ref:`bucket "
"pin <vshard-lock-pin>`, but has the following differences:"
msgstr ""
"Ссылка в сегменте -- это счетчик в оперативной памяти, который похож на "
":ref:`закрепление сегмента <vshard-lock-pin>` со следующими отличиями:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:423
msgid ""
"Bucket ref is not persistent. Refs are intended for forbidding bucket "
"transfer during request execution, but on restart all requests are "
"dropped."
msgstr ""
"Ссылка в сегменте никогда не сохраняется. Ссылки предназначены для "
"запрета передачи сегментов во время выполнения запроса, но при "
"перезапуске все запросы отбрасываются."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:426
msgid "There are two types of bucket refs: read-only (RO) and read-write (RW)."
msgstr "Есть 2 типа ссылок в сегменте: только чтение (RO) и чтение-запись (RW)."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:428
#, fuzzy
msgid ""
"If a bucket has RW refs, it cannot be moved. However, when the rebalancer"
" needs it to be sent, it locks the bucket for new write requests, waits "
"until all current requests are finished, and then sends the bucket."
msgstr ""
"Если в сегменте есть ссылки типа RW, его нельзя перемещать. Однако, если "
"балансировщику требуется отправка этого сегмента, он блокирует его для "
"новых запросов на запись, ожидает завершения всех текущих запросов, а "
"затем отправляет сегмент."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:432
msgid ""
"If a bucket has RO refs, it can be sent, but cannot be dropped. Such a "
"bucket can even enter GARBAGE or SENT state, but its data is kept until "
"the last reader is gone."
msgstr ""
"Если в сегменте есть ссылки типа RO, его можно отправить, но нельзя "
"удалить. Такой сегмент может даже перейти в статус мусора GARBAGE или "
"отправки SENT, но его данные сохраняются до тех пор, пока не уйдет "
"последний читатель."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:436
msgid "A single bucket can have both RO and RW refs."
msgstr "В одном сегменте могут быть ссылки как типа RO, так и типа RW."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:438
msgid "Bucket ref is countable."
msgstr "Ссылки в сегменте исчисляются."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:440
msgid ""
"The :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` "
"methods are called automatically when :ref:`vshard.router.call() "
"<router_api-call>` or :ref:`vshard.storage.call() <storage_api-call>` is "
"used. For raw API like ``r = vshard.router.route() r:callro/callrw`` you "
"should explicitly call the ``bucket_ref()`` method inside the function. "
"Also, make sure that you call ``bucket_unref()`` after ``bucket_ref()``, "
"otherwise the bucket cannot be moved from the storage until the instance "
"restart."
msgstr ""
"Методы :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` "
"вызываются автоматически при использовании :ref:`vshard.router.call() "
"<router_api-call>` или :ref:`vshard.storage.call() <storage_api-call>`. "
"При использовании API, например ``r = vshard.router.route() "
"r:callro/callrw``, следует дополнительно вызвать метод ``bucket_ref()`` в"
" рамках функции. Кроме того, следует убедиться, что после "
"``bucket_ref()`` вызывается ``bucket_unref()``, иначе сегмент нельзя "
"перемещать из хранилища до перезапуска экземпляра."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:448
msgid ""
"To see how many refs there are for a bucket, use "
":ref:`vshard.storage.buckets_info([bucket_id]) <storage_api-"
"buckets_info>` (the ``bucket_id`` parameter is optional)."
msgstr ""
"Чтобы узнать количество ссылок в сегменте, используйте "
":ref:`vshard.storage.buckets_info([идентификатор_сегмента]) <storage_api-"
"buckets_info>` (параметр ``идентификатор_сегмента`` необязателен)."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:454
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:888
msgid ""
"vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"
msgstr ""
"vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:470
msgid "Defining spaces"
msgstr "Определение спейса"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:472
msgid ""
"Database Schema is stored on ``storages``, while ``routers`` know nothing"
" about spaces and tuples."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:475
msgid ""
"Spaces should be defined within a storage application using "
"``box.once()``. For example:"
msgstr ""
"В приложении хранилища следует определить спейсы с помощью "
"``box.once()``. Например:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:478
msgid ""
"box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique "
"= false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', "
"'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"
msgstr ""
"box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique "
"= false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', "
"'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:508
msgid ""
"Every space you plan to shard must have ``bucket_id`` unsigned field "
"indexed by ``bucket_id`` TREE index. Spaces without ``bucket_id`` index "
"don't participate in a sharded Tarantool cluster and can be used as "
"regular spaces if needed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:517
msgid "Adding data"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:519
msgid ""
"All DML operations with data should be performed via ``router``. The only"
" operation supported by ``router`` is `CALL` via ``bucket_id``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:522
#, fuzzy
msgid "result = vshard.router.call(bucket_id, mode, func, args)"
msgstr ""
"result = vshard.router.call(<идентификатор_сегмента>, <режим>, "
"<имя_функции>, {<список_аргументов>}, {<опции>})"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:526
msgid ""
"``vshard.router.call()`` routes ``result = func(unpack(args))`` call to a"
" shard which serves ``bucket_id``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:529
msgid ""
"``bucket_id`` is just a regular number in the range "
"``1..``:ref:`bucket_count<cfg_basic-bucket_count>`. This number can be "
"assigned in an arbitrary way by the client application. A sharded "
"Tarantool cluster uses this number as an opaque unique identifier to "
"distribute data across replica sets. It is guaranteed that all records "
"with the same ``bucket_id`` will be stored on the same replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:540
msgid "Bootstrapping and restarting a storage"
msgstr "Настройка и перезапуск хранилища"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:542
msgid "If a replica set master fails, it is recommended to:"
msgstr "В случае отказа мастера в наборе реплик рекомендуется:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:544
msgid ""
"Switch one of the replicas into the master mode. This allows the new "
"master to process all the incoming requests."
msgstr ""
"Переключить одну из реплик в режим мастера, что позволит новому мастеру "
"обрабатывать все входящие запросы."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:546
msgid ""
"Update the configuration of all the cluster members. This forwards all "
"the requests to the new master."
msgstr ""
"Обновить конфигурацию всех членов кластера, в результате чего все запросы"
" будут перенаправлены на новый мастер."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:549
msgid ""
"Monitoring the master and switching the instance modes can be handled by "
"any external utility."
msgstr ""
"Мониторинг состояния мастера и переключение режимов экземпляров можно "
"осуществлять с помощью внешней утилиты."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:552
msgid ""
"To perform a scheduled downtime of a replica set master, it is "
"recommended to:"
msgstr ""
"Для проведения запланированного остановки мастера в наборе реплик "
"рекомендуется:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:554
msgid ""
"Update the configuration of the master and wait for the replicas to get "
"into sync. All the requests then are forwarded to a new master."
msgstr ""
"Обновить конфигурацию мастера и подождать синхронизации всех реплик, в "
"результате чего все запросы будут перенаправлены на новый мастер."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:556
msgid "Switch another instance into the master mode."
msgstr "Переключить другой экземпляр в режим мастера."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:557
#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:563
msgid "Update the configuration of all the nodes."
msgstr "Обновить конфигурацию всех узлов."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:558
msgid "Shut down the old master."
msgstr "Отключить старый мастер."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:560
msgid "To perform a scheduled downtime of a replica set, it is recommended to:"
msgstr "Для проведения запланированной остановки набора реплик рекомендуется:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:562
msgid "Migrate all the buckets to the other cluster storages."
msgstr "Произвести миграцию всех сегментов в другие хранилища кластера."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:564
msgid "Shut down the replica set."
msgstr "Отключить набор реплик."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:566
msgid ""
"In case a whole replica set fails, some part of the dataset becomes "
"inaccessible. Meanwhile, the ``router`` tries to reconnect to the master "
"of the failed replica set. This way, once the replica set is up and "
"running again, the cluster is automatically restored."
msgstr ""
"В случае отказа всего набора реплик некоторая часть набора данных "
"становится недоступной. Тем временем ``роутер`` пытается повторно "
"подключиться к мастеру отказавшего набора реплик. Таким образом, после "
"того, как набор реплик снова запущен, кластер автоматически "
"восстанавливается."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:577
#, fuzzy
msgid ""
"Searches for buckets, buckets recovery, and buckets rebalancing are "
"performed automatically and do not require manual intervention."
msgstr ""
"Поиск сегментов, восстановление сегментов и балансировка сегментов "
"выполняются автоматически и не требуют вмешательства человека."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:580
msgid ""
"Technically, there are multiple fibers responsible for different types of"
" operations:"
msgstr ""
"С технической точки зрения есть несколько файберов, которые отвечают за "
"различные типы действий:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:583
msgid ""
"a **discovery** fiber on the ``router`` searches for buckets in the "
"background"
msgstr ""
"файбер **обнаружения** на ``роутере`` выполняет поиск сегментов в фоновом"
" режиме"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:584
msgid "a **failover** fiber on the ``router`` maintains replica connections"
msgstr ""
"файбер **восстановления после отказа** на ``роутере`` поддерживает "
"соединения с репликами"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:585
msgid ""
"a **garbage collector** fiber on each master ``storage`` removes the "
"contents of buckets that were moved"
msgstr ""
"файбер **сборки мусора** на каждом мастер-хранилище удаляет содержимое "
"перемещенных сегментов"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:587
msgid ""
"a **bucket recovery** fiber on each master ``storage`` recovers buckets "
"in the SENDING and RECEIVING states in case of reboot"
msgstr ""
"файбер **восстановления сегмента** на каждом мастер-хранилище "
"восстанавливает сегменты в статусах отправки SENDING и получения "
"RECEIVING в случае перезагрузки"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:589
msgid ""
"a **rebalancer** on a single master ``storage`` among all replica sets "
"executes the rebalancing process."
msgstr ""
"**балансировщик** на отдельном мастер-хранилище среди множества наборов "
"реплик выполняет процесс балансировки."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:592
#, fuzzy
msgid ""
"See the :ref:`Rebalancing process <vshard-rebalancing>` and "
":ref:`Migration of buckets <vshard-migrate-buckets>` sections for "
"details."
msgstr ""
"Для получения подробной информации см. раздел :ref:`Процесс балансировки "
"<vshard-rebalancing>`."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:599
msgid "Garbage collector"
msgstr "Сборщик мусора"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:601
msgid ""
"A **garbage collector** fiber runs in the background on the master "
"storages of each replica set. It starts deleting the contents of the "
"bucket in the GARBAGE state part by part. Once the bucket is empty, its "
"record is deleted from the ``_bucket`` system space."
msgstr ""
"Файбер **сборщик мусора** работает в фоновом режиме на мастер-хранилищах "
"в каждом наборе реплик. Он начинает удалять содержимое сегмента в "
"состоянии мусора GARBAGE по частям. Когда сегмент пуст, запись о нем "
"удаляется из системного спейса ``_bucket``."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:610
msgid "Bucket recovery"
msgstr "Восстановление сегмента"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:612
msgid ""
"A **bucket recovery** fiber runs on the master storages. It helps to "
"recover buckets in the SENDING and RECEIVING states in case of reboot."
msgstr ""
"Файбер **восстановления сегмента** работает на мастер-хранилищах. Он "
"помогает восстановить сегменты в статусах отправки SENDING и получения "
"RECEIVING в случае перезагрузки."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:615
msgid "Buckets in the SENDING state are recovered as follows:"
msgstr "Сегменты в статусе SENDING восстанавливаются следующим образом:"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:617
msgid "The system first searches for buckets in the SENDING state."
msgstr "Сначала система ищет сегменты в статусе SENDING."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:618
msgid ""
"If such a bucket is found, the system sends a request to the destination "
"replica set."
msgstr ""
"Если такой сегмент обнаружен, система отправляет запрос в целевой набор "
"реплик."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:620
msgid ""
"If the bucket on the destination replica set is ACTIVE, the original "
"bucket is deleted from the source node."
msgstr ""
"Если сегмент в целевом наборе реплик находится в активном статусе ACTIVE,"
" исходный сегмент удаляется из исходного узла."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:623
msgid "Buckets in the RECEIVING state are deleted without extra checks."
msgstr "Сегменты в статусе RECEIVING удаляются без дополнительных проверок."

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:629
msgid "Failover"
msgstr "Восстановление после отказа"

#: ../doc/reference/reference_rock/vshard/vshard_admin.rst:631
msgid ""
"A **failover** fiber runs on every ``router``. If a master of a replica "
"set becomes unavailable, the failover fiber redirects read requests to "
"the replicas. Write requests are rejected with an error until the master "
"becomes available."
msgstr ""
"Файбер **восстановления после отказа** работает на каждом роутере. Если "
"мастер набора реплик становится недоступным, файбер перенаправляет "
"запросы на чтение к репликам. Запросы на запись отклоняются с ошибкой до "
"тех пор, пока мастер не будет доступен."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:5
msgid "Architecture"
msgstr "Архитектура"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:13
msgid ""
"Consider a distributed Tarantool cluster that consists of subclusters "
"called **shards**, each storing some part of data. Each shard, in its "
"turn, constitutes a **replica set** consisting of several **replicas**, "
"one of which serves as a master node that processes all read and write "
"requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:18
msgid ""
"The whole dataset is logically partitioned into a predefined number of "
":ref:`virtual buckets <vshard-vbuckets>` (further just **buckets**), each"
" assigned a unique number ranging from 1 to N, where N is the total "
"number of buckets. The number of buckets is specifically chosen to be "
"several orders of magnitude larger than the potential number of cluster "
"nodes, even given future cluster scaling. For example, with M projected "
"nodes the dataset may be split into 100 * M or even 1,000 * M buckets. "
"Care should be taken when picking the number of buckets: if too large, it"
" may require extra memory for storing the routing information; if too "
"small, it may decrease the granularity of rebalancing."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:29
#, fuzzy
msgid ""
"Each shard stores a unique subset of buckets, which means that a bucket "
"cannot belong to several shards at once, as illustrated below:"
msgstr ""
"Каждый шард хранит уникальное подмножество сегментов. Один сегмент не "
"может относиться к нескольким шардам одновременно, как показано на схеме "
"ниже:"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:35
msgid ""
"This shard-to-bucket mapping is stored in a table in one of Tarantool’s "
"system spaces, with each shard holding only a specific part of the "
"mapping that covers those buckets that were assigned to this shard."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:39
msgid ""
"Apart from the mapping table, the **bucket id** is also stored in a "
"special field of every tuple of every table participating in sharding."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:42
msgid ""
"Once a shard receives any request (except for SELECT) from an "
"application, this shard checks the bucket id specified in the request "
"against the table of bucket ids that belong to a given node. If the "
"specified bucket id is invalid, the request gets terminated with the "
"following error: “wrong bucket”. Otherwise the request is executed, and "
"all the data created in the process is assigned the bucket id specified "
"in the request. Note that the request should only modify the data that "
"has the same bucket id as the request itself."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:51
msgid ""
"Storing bucket ids both in the data itself and the mapping table ensures "
"data consistency regardless of the application logic and makes "
"rebalancing transparent for the application. Storing the mapping table in"
" a system space ensures sharding is performed consistently in case of a "
"failover, as all the replicas in a shard share a common table state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:61
msgid "Virtual buckets"
msgstr "Виртуальные сегменты"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:63
#, fuzzy
msgid ""
"The sharded dataset is partitioned into a large number of abstract nodes "
"called **virtual buckets** (further just **buckets**)."
msgstr ""
"Набор данных при шардинге распределяется на большое количество "
"абстрактных узлов, которые называются **виртуальные сегменты** (далее по "
"тексту **сегменты**)."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:66
msgid ""
"The dataset is partitioned using the sharding key (or **bucket id**, in "
"Tarantool terminology). Bucket id is a number from 1 to N, where N is the"
" total number of buckets."
msgstr ""
"Секционирование набора данных происходит с помощью сегментного ключа (или"
" **идентификатора сегмента** (bucket id) в терминах Tarantool'а). "
"Идентификатор сегмента -- это число от 1 до N, где N -- это общее "
"количество сегментов."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:73
msgid ""
"Each replica set stores a unique subset of buckets. One bucket cannot "
"belong to multiple replica sets at a time."
msgstr ""
"В каждом наборе реплик есть уникальное подмножество сегментов. Одна "
"сегмент не может относиться к нескольким наборам реплик одновременно."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:76
msgid ""
"The total number of buckets is determined by the administrator who sets "
"up the initial cluster configuration."
msgstr ""
"Общее количество сегментов определяет администратор, который настраивает "
"первоначальную конфигурацию кластера."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:79
#, fuzzy
msgid ""
"Every Tarantool space you plan to shard must have a bucket id field "
"indexed by the bucket id index. Spaces without bucket id indexes do not "
"participate in sharding but can be used as regular spaces. By default, "
"the name of the index coincides with the bucket id."
msgstr ""
"Каждый спейс Tarantool'а, который планируется сегментировать, должен "
"включать в себя проиндексированное поле с идентификатором сегмента. "
"Спейсы без индексов идентификаторов сегментов не участвуют в шардинге, но"
" могут использоваться в качестве обычных спейсов. По умолчанию, имя "
"индекса совпадает с идентификатором сегмента."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:88
#, fuzzy
msgid "Structure"
msgstr "Структура"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:90
#, fuzzy
msgid "A sharded cluster in Tarantool consists of:"
msgstr "Минимальный рабочий сегментированный кластер должен состоять из:"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:92
#, fuzzy
msgid "storages,"
msgstr "хранилище,"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:93
#, fuzzy
msgid "routers,"
msgstr "роутеры,"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:94
#, fuzzy
msgid "and a rebalancer."
msgstr "и ребалансировщик."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:103
msgid "Storage"
msgstr "Хранилище"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:105
#, fuzzy
msgid ""
"**Storage** is a node storing a subset of the dataset. Multiple "
"replicated (for redundancy) storages comprise a **replica set** (also "
"called **shard**)."
msgstr ""
"**Хранилище** (storage) -- это узел, который хранит подмножество набора "
"данных. Развертывание нескольких реплицируемых хранилищ осуществляется в "
"виде наборов реплик, чтобы обеспечить резерв (набор реплик также можно "
"называть шардом или сегментом)."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:108
#, fuzzy
msgid ""
"Each storage in a replica set has a role, **master** or **replica**. A "
"master processes read and write requests. A replica processes read "
"requests but cannot process write requests."
msgstr ""
"**Хранилище** (storage) -- это узел, который хранит подмножество набора "
"данных. Несколько реплицируемых хранилищ составляют набор реплик. У "
"каждого хранилища в наборе реплик есть роль: **мастер** или **реплика**. "
"Мастер обрабатывает запросы на чтение и запись. Реплика обрабатывает "
"запросы на чтение, но не может обрабатывать запросы на запись."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:119
msgid "Router"
msgstr "Роутер"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:121
#, fuzzy
msgid ""
"**Router** is a standalone software component that routes read and write "
"requests from the client application to shards."
msgstr ""
"**Роутер** (router) -- это автономный компонент ПО, который обеспечивает "
"маршрутизацию запросов чтения и записи от клиентского приложения к "
"шардам."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:124
msgid ""
"All requests from the application come to the sharded cluster through a "
"``router``. The ``router`` keeps the topology of a sharded cluster "
"transparent for the application, thus keeping the application unaware of:"
msgstr ""
"Все запросы из приложения приходят в сегментированный кластер через "
"роутер (``router``). Роутер сохраняет топологию сегментированного "
"кластера прозрачной для приложения, не сообщая приложению:"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:128
msgid "the number and location of shards,"
msgstr "номер и местоположение шардов,"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:129
msgid "data rebalancing process,"
msgstr "процесс балансировки данных,"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:130
msgid ""
"the fact and the process of a failover that occurred after a replica's "
"failure."
msgstr "наличие отказа и восстановление после отказа реплики."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:132
msgid ""
"A router can also calculate a bucket id on its own provided that the "
"application clearly defines rules for calculating a bucket id based on "
"the request data. To do it, a router needs to be aware of the data "
"schema."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:136
msgid ""
"The ``router`` does not have a persistent state, nor does it store the "
"cluster topology or balance the data. The ``router`` is a standalone "
"software component that can run in the storage layer or application layer"
" depending on the application features."
msgstr ""
"У роутера нет постоянного статуса, он не хранит топологию кластера и не "
"выполняет балансировку данных. Роутер -- это автономный компонент ПО, "
"который может работать на уровне хранилища или на уровне приложения в "
"зависимости от функций приложения."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:140
msgid ""
"A router maintains a constant pool of connections to all the storages "
"that is created at startup. Creating it this way helps avoid "
"configuration errors. Once a pool is created, a router caches the current"
" state of the ``_vbucket`` table to speed up the routing. In case a "
"bucket id is moved to another storage as a result of data rebalancing, or"
" one of the shards fails over to a replica, a router updates the routing "
"table in a way that's transparent for the application."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:147
msgid ""
"Sharding is not integrated into any centralized configuration storage "
"system. It is assumed that the application itself handles all the "
"interactions with such systems and passes sharding parameters. That said,"
" the configuration can be changed dynamically - for example, when adding "
"or deleting one or several shards:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:152
msgid ""
"To add a new shard to the cluster, a system administrator first changes "
"the configuration of all the routers and then the configuration of all "
"the storages."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:154
#, fuzzy
msgid "The new shard becomes available to the storage layer for rebalancing."
msgstr "Новый шард становится доступен для балансирования на уровне хранилища."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:155
#, fuzzy
msgid "As a result of rebalancing, one of the vbuckets is moved to the new shard."
msgstr "В результате балансировки происходит миграция сегментов на новый шард."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:156
msgid ""
"When trying to access the vbucket, a router receives a special error code"
" that specifies the new vbucket location."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:161
msgid "CRUD (create, replace, update, delete) operations"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:163
msgid "CRUD operations can be:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:165
msgid "executed in a stored procedure inside a storage, or"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:166
msgid "initialized by the application."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:168
msgid ""
"In any case, the application must include the operation bucket id in a "
"request. When executing an INSERT request, the operation bucket id is "
"stored in a newly created tuple. In other cases, it is checked if the "
"specified operation bucket id matches the bucket id of a tuple being "
"modified."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:175
#, fuzzy
msgid "SELECT requests"
msgstr "SELECT-запросы"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:177
msgid ""
"Since a storage is not aware of the mapping between a bucket id and a "
"primary key, all the SELECT requests executed in stored procedures inside"
" a storage are only executed locally. Those SELECT requests that were "
"initialized by the application are forwarded to a router. Then, if the "
"application has passed a bucket id, a router uses it for shard "
"calculation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:185
#, fuzzy
msgid "Calling stored procedures"
msgstr "Вызов хранимой процедуры"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:187
msgid ""
"There are several ways of calling stored procedures in cluster replica "
"sets. Stored procedures can be called:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:190
msgid ""
"on a specific vbucket located in a replica set (in this case, it is "
"necessary to differentiate between read and write procedures, as write "
"procedures are not applicable to vbuckets that are being migrated), or"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:193
msgid "without specifying any particular vbucket."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:195
msgid ""
"All the routing validity checks performed for sharded DML operations hold"
" true for vbucket-bound stored procedures as well."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:202
msgid "Rebalancer"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:204
#, fuzzy
msgid ""
"**Rebalancer** is a background rebalancing process that ensures an even "
"distribution of buckets across the shards. During rebalancing, buckets "
"are being migrated among replica sets."
msgstr ""
"**Балансировщик** представляет собой фоновый процесс балансировки, "
"который обеспечивает равномерное распределение сегментов по шардам. Во "
"время балансировки происходит миграция сегментов по наборам реплик."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:208
#, fuzzy
msgid ""
"The rebalancer \"wakes up\" periodically and redistributes data from the "
"most loaded nodes to less loaded nodes. Rebalancing starts if the "
"**disbalance threshold** of a replica set exceeds a disbalance threshold "
"specified in the configuration."
msgstr ""
"``Балансировщик`` периодически просыпается и перераспределяет данные из "
"наиболее загруженных узлов в менее загруженные узлы. Балансировка "
"начинается, когда предел дисбаланса в наборе реплик превышает предел "
"дисбаланса, указанный в конфигурации."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:212
msgid "The disbalance threshold is calculated as follows:"
msgstr "Предел дисбаланса рассчитывается следующим образом:"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:222
msgid "Migration of buckets"
msgstr "Миграция сегментов"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:224
msgid ""
"A replica set from which the bucket is being migrated is called a "
"**source** ; a target replica set to which the bucket is being migrated "
"is called a **destination**."
msgstr ""
"Набор реплик, из которого переносится сегмент, называется **исходный** "
"(source); а набор реплик, куда переносится сегмент, называется "
"**целевой** (destination)."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:227
msgid ""
"A **replica set lock** makes a replica set invisible to the rebalancer. A"
" locked replica set can neither receive new buckets nor migrate its own "
"buckets."
msgstr ""
"**Блокировка набора реплик** позволяет набору реплик оставаться невидимым"
" для балансировщика. Набор реплик с блокировкой не может ни принимать "
"новые сегменты, ни мигрировать свои собственные."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:230
msgid "While a bucket is being migrated, it can have different states:"
msgstr "Во время миграции у сегмента могут быть разные статусы:"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:232
msgid "ACTIVE – the bucket is available for read and write requests."
msgstr "ACTIVE (активный) -- сегмент доступен для запросов чтения и записи."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:233
msgid ""
"PINNED – the bucket is locked for migrating to another replica set. "
"Otherwise pinned buckets are similar to buckets in the ACTIVE state."
msgstr ""
"PINNED (закрепленный) -- сегмент заблокирован для миграции в другой набор"
" реплик. Во всем остальном закрепленные сегменты аналогичны активным "
"сегментам."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:235
msgid ""
"SENDING – the bucket is currently being copied to the destination replica"
" set; read requests to the source replica set are still processed."
msgstr ""
"SENDING (отправляемый) -- в настоящий момент сегмент копируется в целевой"
" набор реплик; запросы на чтение в исходный набор реплик обрабатываются."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:237
msgid ""
"RECEIVING – the bucket is currently being filled; all requests to it are "
"rejected."
msgstr ""
"RECEIVING (принимающий) -- происходит наполнение сегмента; все запросы "
"отклоняются."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:238
msgid ""
"SENT – the bucket was migrated to the destination replica set. The "
"`router` uses the SENT state to calculate the new location of the bucket."
" A bucket in the SENT state goes to the GARBAGE state automatically after"
" BUCKET_SENT_GARBAGE_DELAY seconds, which by default is :ref:`0.5 seconds"
" <cfg_basic-collect_bucket_garbage_interval>`."
msgstr ""
"SENT (отправленный) -- сегмент был перенесен в целевой набор реплик. "
"Роутер использует статус SENT, чтобы определить новое местонахождение "
"сегмента. Сегмент в статусе SENT переходит в статус мусора GARBAGE "
"автоматически через количество секунд, указанное в "
"BUCKET_SENT_GARBAGE_DELAY, по умолчанию равное :ref:`0,5 секунды "
"<cfg_basic-collect_bucket_garbage_interval>`."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:242
msgid ""
"GARBAGE – the bucket was already migrated to the destination replica set "
"during rebalancing; or the bucket was initially in the RECEIVING state, "
"but some error occurred during the migration."
msgstr ""
"GARBAGE (мусор) -- произошла миграция сегмента в целевой набор реплик во "
"время балансировки; или же принимающий сегмент был в статусе RECEIVING, "
"но произошла ошибка во время миграции."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:246
msgid "Buckets in the GARBAGE state are deleted by the garbage collector."
msgstr "Сегменты в статусе мусора GARBAGE удаляются сборщиком мусора."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:251
msgid "Migration is performed as follows:"
msgstr "Миграция происходит следующим образом:"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:253
msgid ""
"At the destination replica set, a new bucket is created and assigned the "
"RECEIVING state, the data copying starts, and the bucket rejects all "
"requests."
msgstr ""
"В целевом наборе реплик создается новый сегмент, который получает статус "
"RECEIVING (принимающий), начинается копирование данных, и сегмент "
"отклоняет все запросы."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:255
msgid ""
"The source bucket in the source replica set is assigned the SENDING "
"state, and the bucket continues to process read requests."
msgstr ""
"Отправляемый сегмент в исходном наборе реплик получает статус SENDING и "
"продолжает обрабатывать запросы на чтение."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:257
msgid ""
"Once the data is copied, the bucket on the source replica set is assigned"
" the SENT and it starts rejecting all requests."
msgstr ""
"После копирования данных сегмент в исходном наборе реплик получает статус"
" отправленного (SENT) и перестает принимать запросы."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:259
msgid ""
"The bucket on the destination replica set is assigned the ACTIVE state "
"and starts accepting all requests."
msgstr ""
"Сегмент в целевом наборе реплик переходит в активный статус (ACTIVE) и "
"начинает принимать все запросы."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:264
msgid ""
"There is a specific error ``vshard.error.code.TRANSFER_IS_IN_PROGRESS`` "
"that returns in case a request tries to perform an action not applicable "
"to a bucket which is being relocated. You need to retry the request in "
"this case."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:272
msgid "The `_bucket` system space"
msgstr "Системный спейс `_bucket`"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:274
msgid ""
"The ``_bucket`` system space of each replica set stores the ids of "
"buckets present in the replica set. The space contains the following "
"fields:"
msgstr ""
"Системный спейс ``_bucket`` в каждом наборе реплик хранит идентификаторы "
"сегментов данного набора реплик. Спейс содержит следующие поля:"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:277
msgid "``bucket`` – bucket id"
msgstr "``bucket`` -- идентификатор сегмента"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:278
#, fuzzy
msgid "``status`` – state of the bucket"
msgstr "``status`` -- статус сегмента"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:279
msgid "``destination`` – UUID of the destination replica set"
msgstr "``destination`` -- UUID целевого набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:281
msgid "An example of ``_bucket.select{}``:"
msgstr "Пример ``_bucket.select{}``:"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:283
msgid ""
"---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."
msgstr ""
"---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:290
msgid ""
"Once the bucket is migrated, the destination replica set identified by "
"UUID is filled in the table. While the bucket is still located on the "
"source replica set, the value of the destination replica set UUID is "
"equal to ``NULL``."
msgstr ""
"После миграции сегмента UUID целевого набора реплик вносится в таблицу. "
"Пока сегмент еще находится в исходном наборе реплик, значение UUID "
"целевого набора реплик равно ``NULL``."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:298
msgid "The routing table"
msgstr "Таблица маршрутизации"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:300
msgid ""
"А routing table on the ``router`` stores the map of all bucket ids to "
"replica sets. It ensures the consistency of sharding in case of failover."
msgstr ""
"Таблица маршрутизации роутера отображает все идентификаторы сегментов с "
"соответствующими наборами реплик. Она обеспечивает консистентность "
"шардинга в случае отказа."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:303
msgid ""
"The ``router`` keeps a persistent pool of connections to all the storages"
" that are created at startup. This helps prevent configuration errors. "
"Once the connection pool is created, the ``router`` caches the current "
"state of the routing table in order to speed up routing. If a bucket "
"migrated to another ``storage`` after rebalancing, or a failover occurred"
" and caused one of the shards switching to another replica, the "
"``discovery fiber`` on the ``router`` updates the routing table "
"automatically."
msgstr ""
"Роутер поддерживает постоянный пул соединений со всеми хранилищами, "
"созданными при запуске, что помогает избежать ошибки конфигурации. После "
"создания пула соединений роутер кэширует текущее состояние таблицы "
"маршрутизации, чтобы ускорить ее. Если произошла миграция сегмента в "
"другое хранилище после балансировки или же отказ, который вызвал "
"переключение шарда на другую реплику, файбер обнаружения (``discovery "
"fiber``) в роутере обновит таблицу маршрутизации автоматически."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:310
msgid ""
"As the bucket id is explicitly indicated both in the data and in the "
"mapping table on the ``router``, the data is consistent regardless of the"
" application logic. It also makes rebalancing transparent for the "
"application."
msgstr ""
"Поскольку идентификатор сегмента явно указан как в данных, так и в "
"таблице отображения на роутере, данные сохраняются независимо от логики "
"приложения. Это также обеспечивает прозрачность балансировки для "
"приложения."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:318
msgid "Processing requests"
msgstr "Обработка запросов"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:320
msgid ""
"Requests to the database can be performed by the application or using "
"stored procedures. Either way, the bucket id should be explicitly "
"specified in the request."
msgstr ""
"Запросы в базу данных можно производить из приложения или с помощью "
"хранимых процедур. В любом случае идентификатор сегмента следует явным "
"образом указать в запросе."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:323
msgid ""
"All requests are forwarded to the ``router`` first. The only operation "
"supported by the ``router`` is ``call``. The operation is performed via "
"the ``vshard.router.call()`` function:"
msgstr ""
"Сначала все запросы направляются в роутер. Роутер поддерживает только "
"операцию вызова, которая выполняется с помощью функции "
"``vshard.router.call()``:"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:327
msgid ""
"result = vshard.router.call(<bucket_id>, <mode>, <function_name>, "
"{<argument_list>}, {<opts>})"
msgstr ""
"result = vshard.router.call(<идентификатор_сегмента>, <режим>, "
"<имя_функции>, {<список_аргументов>}, {<опции>})"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:331
msgid "Requests are processed as follows:"
msgstr "Запросы обрабатываются следующим образом:"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:333
msgid ""
"The ``router`` uses the bucket id to search for a replica set with the "
"corresponding bucket in the routing table."
msgstr ""
"Роутер использует идентификатор сегмента для поиска набора реплик с "
"соответствующим сегментом в таблице маршрутизации."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:336
msgid ""
"If the map of the bucket id to the replica set is not known to the "
"``router`` (the discovery fiber hasn’t filled the table yet), the "
"``router`` makes requests to all ``storages`` to find out where the "
"bucket is located."
msgstr ""
"Если роутер не содержит информацию о соответствии идентификатора сегмента"
" набору реплик (файбер обнаружения еще не заполнил таблицу), роутер "
"выполняет запросы ко всем хранилищам, чтобы обнаружить местонахождение "
"сегмента."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:339
msgid "Once the bucket is located, the shard checks:"
msgstr "После обнаружения сегмента шард проверяет:"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:341
msgid ""
"whether the bucket is stored in the ``_bucket`` system space of the "
"replica set;"
msgstr "хранится ли сегмент в системном спейсе ``_bucket`` набора реплик;"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:342
msgid ""
"whether the bucket is ACTIVE or PINNED (for a read request, it can also "
"be SENDING)."
msgstr ""
"находится ли сегмент в статусе ACTIVE (активный) или PINNED "
"(закрепленный) (если выполняется запрос на чтение, то сегмент может "
"находиться в состоянии отправки SENDING)."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:344
msgid ""
"If all the checks succeed, the request is executed. Otherwise, it is "
"terminated with the error: ``“wrong bucket”``."
msgstr ""
"Если проверка пройдена, запрос выполняется. В противном случае, "
"выполнение запроса прекращается с ошибкой: ``“wrong bucket”`` "
"(несоответствующий сегмент)."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:351
msgid "Glossary"
msgstr "Глоссарий"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:356
msgid "**Vertical scaling**"
msgstr "**Вертикальное масштабирование**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:358
msgid ""
"Adding more power to a single server: using a more powerful CPU, adding "
"more capacity to RAM, adding more storage space, etc."
msgstr ""
"Добавление мощности в отдельный сервер: использование более мощного "
"процессора, добавление оперативной памяти, добавление хранилищ и т.д. "

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:362
msgid "**Horizontal scaling**"
msgstr "**Горизонтальное масштабирование**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:364
msgid ""
"Adding more servers to the pool of resources, then partitioning and "
"distributing a dataset across the servers."
msgstr ""
"Добавление дополнительных серверов в пул ресурсов, последующее "
"секционирование и распределение набора данных по серверам."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:368
msgid "**Sharding**"
msgstr "**Шардинг**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:370
msgid ""
"A database architecture that allows partitioning a dataset using a "
"sharding key and distributing a dataset across multiple servers. Sharding"
" is a special case of horizontal scaling."
msgstr ""
"Архитектура базы данных, которая допускает секционирование набора данных "
"по сегментному ключу и распределение набора данных по нескольким "
"серверам. Шардинг представляет собой частный случай горизонтального "
"масштабирования."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:375
msgid "**Node**"
msgstr "**Узел**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:377
msgid "A virtual or physical server instance."
msgstr "Виртуальный или физический экземпляр сервера."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:380
msgid "**Cluster**"
msgstr "**Кластер**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:382
msgid "A set of nodes that make up a single group."
msgstr "Набор узлов, которые составляют отдельную группу."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:385
msgid "**Storage**"
msgstr "**Хранилище**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:387
msgid "A node storing a subset of a dataset."
msgstr "Узел, который хранит подмножество данных из набора."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:392
msgid ""
"A set of storage nodes storing copies of a dataset. Each storage in a "
"replica set has a role, master or replica."
msgstr ""
"Ряд узлов, на которых хранятся копии набора данных. У каждого хранилища в"
" наборе реплик есть роль: мастер или реплика."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:396
msgid "**Master**"
msgstr "**Мастер**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:398
msgid "A storage in a replica set processing read and write requests."
msgstr ""
"Хранилище в наборе реплик, которое обрабатывает запросы на чтение и "
"запись."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:403
msgid "A storage in a replica set processing only read requests."
msgstr "Хранилище в наборе реплик, которое обрабатывает только запросы на чтение."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:406
msgid "**Read requests**"
msgstr "**Запросы на чтение**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:408
msgid "Read-only requests, that is, select requests."
msgstr "Запросы только на чтение, то есть выборка."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:411
msgid "**Write requests**"
msgstr "**Запросы на запись**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:413
msgid "Data-change operations, that is create, replace, update, delete requests."
msgstr ""
"Операции по изменению данных, то есть запросы на создание, замену, "
"обновление и удаление данных."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:416
msgid "**Buckets (virtual buckets)**"
msgstr "**Сегменты (виртуальные сегменты)**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:418
msgid ""
"The abstract virtual nodes into which the dataset is partitioned by the "
"sharding key (bucket id)."
msgstr ""
"Абстрактные виртуальные узлы, на которые производится секционирование "
"набора данных по сегментному ключу (идентификатору сегмента)."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:422
msgid "**Bucket id**"
msgstr "**Идентификатор сегмента**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:424
msgid ""
"A sharding key defining which bucket belongs to which replica set. A "
"bucket id may be calculated from a :ref:`hash key <router_api-"
"bucket_id>`."
msgstr ""
"Сегментный ключ, который определяет принадлежность сегмента к "
"определенному набору реплик. Идентификатор сегмента можно вычислить из "
":ref:`хеш-ключа <router_api-bucket_id>`."

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:428
msgid "**Router**"
msgstr "**Роутер**"

#: ../doc/reference/reference_rock/vshard/vshard_architecture.rst:430
msgid ""
"A proxy server responsible for routing requests from an application to "
"nodes in a cluster."
msgstr ""
"Прокси-сервер, который отвечает за запросы маршрутизации от приложения к "
"узлам в кластере."

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:5
#, fuzzy
msgid "Quick start guide"
msgstr "Краткое руководство"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:7
msgid ""
"For installation instructions, check out the :ref:`vshard installation "
"manual <vshard-install>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:9
msgid ""
"For a pre-configured development cluster, check out the ``example/`` "
"directory in the `vshard repository "
"<https://github.com/tarantool/vshard/>`_. This example includes 5 "
"Tarantool instances and 2 replica sets:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:13
msgid "``router_1`` – a ``router`` instance"
msgstr "``router_1`` – экземпляр роутера (``router``)"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:14
#, fuzzy
msgid ""
"``storage_1_a`` – a ``storage`` instance, the **master** of the **first**"
" replica set"
msgstr ""
"``storage_1_a`` – экземпляр хранилища (``storage``), мастер первого "
"набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:15
#, fuzzy
msgid ""
"``storage_1_b`` – a ``storage`` instance, the **replica** of the "
"**first** replica set"
msgstr ""
"``storage_1_b`` – экземпляр хранилища (``storage``), реплика из первого "
"набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:16
#, fuzzy
msgid ""
"``storage_2_a`` – a ``storage`` instance, the **master** of the "
"**second** replica set"
msgstr ""
"``storage_2_a`` – экземпляр хранилища (``storage``), мастер второго "
"набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:17
#, fuzzy
msgid ""
"``storage_2_b`` – a ``storage`` instance, the **replica** of the "
"**second** replica set"
msgstr ""
"``storage_2_b`` – экземпляр хранилища (``storage``), реплика из второго "
"набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:19
msgid ""
"All instances are managed using the ``tarantoolctl`` utility which comes "
"with Tarantool."
msgstr ""
"Управление всеми экземплярами осуществляется с помощью утилиты "
"``tarantoolctl``."

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:21
msgid ""
"Change the directory to ``example/`` and use ``make`` to run the "
"development cluster:"
msgstr ""
"Измените директорию ``example/`` и используйте команду ``make`` для "
"запуска кластера:"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:23
msgid ""
"$ cd example/\n"
"$ make\n"
"tarantoolctl stop storage_1_a  # stop the first storage instance\n"
"Stopping instance storage_1_a...\n"
"tarantoolctl stop storage_1_b\n"
"<...>\n"
"rm -rf data/\n"
"tarantoolctl start storage_1_a # start the first storage instance\n"
"Starting instance storage_1_a...\n"
"Starting configuration of replica 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"I am master\n"
"Taking on replicaset master role...\n"
"Run console at unix/:./data/storage_1_a.control\n"
"started\n"
"mkdir ./data/storage_1_a\n"
"<...>\n"
"tarantoolctl start router_1 # start the router\n"
"Starting instance router_1...\n"
"Starting router configuration\n"
"Calling box.cfg()...\n"
"<...>\n"
"Run console at unix/:./data/router_1.control\n"
"started\n"
"mkdir ./data/router_1\n"
"Waiting cluster to start\n"
"echo \"vshard.router.bootstrap()\" | tarantoolctl enter router_1\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control> vshard.router.bootstrap()\n"
"---\n"
"- true\n"
"...\n"
"unix/:./data/router_1.control>\n"
"tarantoolctl enter router_1 # enter the admin console\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control>"
msgstr ""
"$ cd example/\n"
"$ make\n"
"tarantoolctl stop storage_1_a  # stop the first storage instance\n"
"Stopping instance storage_1_a...\n"
"tarantoolctl stop storage_1_b\n"
"<...>\n"
"rm -rf data/\n"
"tarantoolctl start storage_1_a # start the first storage instance\n"
"Starting instance storage_1_a...\n"
"Starting configuration of replica 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"I am master\n"
"Taking on replicaset master role...\n"
"Run console at unix/:./data/storage_1_a.control\n"
"started\n"
"mkdir ./data/storage_1_a\n"
"<...>\n"
"tarantoolctl start router_1 # start the router\n"
"Starting instance router_1...\n"
"Starting router configuration\n"
"Calling box.cfg()...\n"
"<...>\n"
"Run console at unix/:./data/router_1.control\n"
"started\n"
"mkdir ./data/router_1\n"
"Waiting cluster to start\n"
"echo \"vshard.router.bootstrap()\" | tarantoolctl enter router_1\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control> vshard.router.bootstrap()\n"
"---\n"
"- true\n"
"...\n"
"unix/:./data/router_1.control>\n"
"tarantoolctl enter router_1 # enter the admin console\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control>"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:61
msgid "Some ``tarantoolctl`` commands:"
msgstr "Некоторые команды ``tarantoolctl``:"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:63
msgid "``tarantoolctl start router_1`` – start the router instance"
msgstr "``tarantoolctl start router_1`` – запуск экземпляра роутера"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:64
msgid "``tarantoolctl enter router_1``  – enter the admin console"
msgstr "``tarantoolctl enter router_1``  – вход в административную консоль"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:66
msgid ""
"The full list of ``tarantoolctl`` commands for managing Tarantool "
"instances is available in the :ref:`tarantoolctl reference "
"<tarantoolctl>`."
msgstr ""
"Полный список команд ``tarantoolctl`` для управления экземплярами "
"Tarantool'а можно найти в :ref:`справочнике по tarantoolctl "
"<tarantoolctl>`."

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:69
#, fuzzy
msgid "Essential ``make`` commands you need to know:"
msgstr "Необходимо знать следующие команды make:"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:71
msgid "``make start`` – start all Tarantool instances"
msgstr "``make start`` – запуск всех экземпляров Tarantool'а"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:72
msgid "``make stop`` – stop all Tarantool instances"
msgstr "``make stop`` – остановка всех экземпляров Tarantool'а"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:73
msgid "``make logcat`` – show logs from all instances"
msgstr "``make logcat`` – вывод журналов всех экземпляров"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:74
#, fuzzy
msgid "``make enter`` – enter the admin console on ``router_1``"
msgstr "``make enter`` – вход в административную консоль на роутере router_1"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:75
msgid "``make clean`` – clean up all persistent data"
msgstr "``make clean`` – очистка всех персистентных данных"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:76
#, fuzzy
msgid ""
"``make test`` – run the test suite (you can also run ``test-run.py`` in "
"the ``test`` directory)"
msgstr ""
"``make test`` – запуск набора тестов (можно также выполнить test-run.py в"
" директории с тестами)"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:77
msgid ""
"``make`` – execute ``make stop``, ``make clean``, ``make start`` and "
"``make enter``"
msgstr ""
"``make`` – выполнить ``make stop``, ``make clean``, ``make start`` и "
"``make enter``"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:79
msgid "For example, to start all instances, use ``make start``:"
msgstr "Например, для запуска всех экземпляров используйте ``make start``:"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:81
msgid ""
"$ make start\n"
"$ ps x|grep tarantool\n"
"46564   ??  Ss     0:00.34 tarantool storage_1_a.lua <running>\n"
"46566   ??  Ss     0:00.19 tarantool storage_1_b.lua <running>\n"
"46568   ??  Ss     0:00.35 tarantool storage_2_a.lua <running>\n"
"46570   ??  Ss     0:00.20 tarantool storage_2_b.lua <running>\n"
"46572   ??  Ss     0:00.25 tarantool router_1.lua <running>"
msgstr ""
"$ make start\n"
"$ ps x|grep tarantool\n"
"46564   ??  Ss     0:00.34 tarantool storage_1_a.lua <running>\n"
"46566   ??  Ss     0:00.19 tarantool storage_1_b.lua <running>\n"
"46568   ??  Ss     0:00.35 tarantool storage_2_a.lua <running>\n"
"46570   ??  Ss     0:00.20 tarantool storage_2_b.lua <running>\n"
"46572   ??  Ss     0:00.25 tarantool router_1.lua <running>"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:91
#, fuzzy
msgid ""
"To perform commands in the admin console, use the router's :ref:`public "
"API <vshard_api_reference-router_public_api>`:"
msgstr ""
"Для выполнения команд в административной консоли, используйте API "
"``router``:"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:94
msgid ""
"unix/:./data/router_1.control> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""
"unix/:./data/router_1.control> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:128
msgid "Sample configuration"
msgstr "Образец конфигурации"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:130
msgid "The configuration of a simple sharded cluster can look like this:"
msgstr ""
"Конфигурация простого сегментированного кластера может выглядеть "
"следующим образом:"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:132
msgid ""
"local cfg = {\n"
"    memtx_memory = 100 * 1024 * 1024,\n"
"    replication_connect_quorum = 0,\n"
"    bucket_count = 10000,\n"
"    rebalancer_disbalance_threshold = 10,\n"
"    rebalancer_max_receiving = 100,\n"
"    sharding = {\n"
"        ['cbf06940-0790-498b-948d-042b62cf3d29'] = {\n"
"            replicas = {\n"
"                ['8a274925-a26d-47fc-9e1b-af88ce939412'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3301',\n"
"                    name = 'storage_1_a',\n"
"                    master = true\n"
"                },\n"
"                ['3de2e3e1-9ebe-4d0d-abb1-26d301b84633'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3302',\n"
"                    name = 'storage_1_b'\n"
"                }\n"
"            },\n"
"        },\n"
"        ['ac522f65-aa94-4134-9f64-51ee384f1a54'] = {\n"
"            replicas = {\n"
"                ['1e02ae8a-afc0-4e91-ba34-843a356b8ed7'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3303',\n"
"                    name = 'storage_2_a',\n"
"                    master = true\n"
"                },\n"
"                ['001688c3-66f8-4a31-8e19-036c17d489c2'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3304',\n"
"                    name = 'storage_2_b'\n"
"                }\n"
"            },\n"
"        },\n"
"    },\n"
"}"
msgstr ""
"local cfg = {\n"
"    memtx_memory = 100 * 1024 * 1024,\n"
"    replication_connect_quorum = 0,\n"
"    bucket_count = 10000,\n"
"    rebalancer_disbalance_threshold = 10,\n"
"    rebalancer_max_receiving = 100,\n"
"    sharding = {\n"
"        ['cbf06940-0790-498b-948d-042b62cf3d29'] = {\n"
"            replicas = {\n"
"                ['8a274925-a26d-47fc-9e1b-af88ce939412'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3301',\n"
"                    name = 'storage_1_a',\n"
"                    master = true\n"
"                },\n"
"                ['3de2e3e1-9ebe-4d0d-abb1-26d301b84633'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3302',\n"
"                    name = 'storage_1_b'\n"
"                }\n"
"            },\n"
"        },\n"
"        ['ac522f65-aa94-4134-9f64-51ee384f1a54'] = {\n"
"            replicas = {\n"
"                ['1e02ae8a-afc0-4e91-ba34-843a356b8ed7'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3303',\n"
"                    name = 'storage_2_a',\n"
"                    master = true\n"
"                },\n"
"                ['001688c3-66f8-4a31-8e19-036c17d489c2'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3304',\n"
"                    name = 'storage_2_b'\n"
"                }\n"
"            },\n"
"        },\n"
"    },\n"
"}"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:170
msgid ""
"This cluster includes one ``router`` instance and two ``storage`` "
"instances. Each ``storage`` instance includes one master and one replica."
" The ``sharding`` field defines the logical topology of a sharded "
"Tarantool cluster. All the other fields are passed to ``box.cfg()`` as "
"they are, without modifications. See the :ref:`Configuration reference "
"<vshard-config-reference>` section for details."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:176
#, fuzzy
msgid "On routers, call ``vshard.router.cfg(cfg)``:"
msgstr "На роутерах вызовите ``vshard.router.cfg(cfg)``:"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:178
msgid ""
"cfg.listen = 3300\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.router.cfg(cfg)"
msgstr ""
"cfg.listen = 3300\n"
"\n"
"-- Запуск базы данных с шардингом\n"
"vshard = require('vshard')\n"
"vshard.router.cfg(cfg)"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:186
#, fuzzy
msgid "On storages, call ``vshard.storage.cfg(cfg, instance_uuid)``:"
msgstr "На хранилищах вызовите ``vshard.storage.cfg(cfg, uuid_экземпляра)``:"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:188
msgid ""
"-- Get instance name\n"
"local MY_UUID = \"de0ea826-e71d-4a82-bbf3-b04a6413e417\"\n"
"\n"
"-- Call a configuration provider\n"
"local cfg = require('localcfg')\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.storage.cfg(cfg, MY_UUID)"
msgstr ""
"-- Получение имени экземпляра\n"
"local MY_UUID = \"de0ea826-e71d-4a82-bbf3-b04a6413e417\"\n"
"\n"
"-- Вызов поставщика конфигурации\n"
"local cfg = require('localcfg')\n"
"\n"
"-- Запуск базы данных с шардингом\n"
"vshard = require('vshard')\n"
"vshard.storage.cfg(cfg, MY_UUID)"

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:200
msgid ""
"``vshard.storage.cfg()`` automatically calls ``box.cfg()`` and configures"
" the listen port and replication parameters."
msgstr ""
"``vshard.storage.cfg()`` автоматически вызывает ``box.cfg()`` и "
"настраивает порт для прослушивания и параметры репликации."

#: ../doc/reference/reference_rock/vshard/vshard_quick.rst:203
msgid ""
"For a sample configuration, see ``router.lua`` and ``storage.lua`` in the"
" ``example/`` directory of the `vshard repository "
"<https://github.com/tarantool/vshard>`_."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:13
msgid ":ref:`sharding <cfg_basic-sharding>`"
msgstr ":ref:`sharding <cfg_basic-sharding>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:14
msgid ":ref:`weights <cfg_basic-weights>`"
msgstr ":ref:`weights <cfg_basic-weights>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:15
msgid ":ref:`shard_index <cfg_basic-shard_index>`"
msgstr ":ref:`shard_index <cfg_basic-shard_index>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:16
msgid ":ref:`bucket_count <cfg_basic-bucket_count>`"
msgstr ":ref:`bucket_count <cfg_basic-bucket_count>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:17
msgid ""
":ref:`collect_bucket_garbage_interval <cfg_basic-"
"collect_bucket_garbage_interval>`"
msgstr ""
":ref:`collect_bucket_garbage_interval <cfg_basic-"
"collect_bucket_garbage_interval>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:18
msgid ":ref:`collect_lua_garbage <cfg_basic-collect_lua_garbage>`"
msgstr ":ref:`collect_lua_garbage <cfg_basic-collect_lua_garbage>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:19
msgid ":ref:`sync_timeout <cfg_basic-sync_timeout>`"
msgstr ":ref:`sync_timeout <cfg_basic-sync_timeout>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:20
msgid ""
":ref:`rebalancer_disbalance_threshold <cfg_basic-"
"rebalancer_disbalance_threshold>`"
msgstr ""
":ref:`rebalancer_disbalance_threshold <cfg_basic-"
"rebalancer_disbalance_threshold>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:21
msgid ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"
msgstr ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:22
#, fuzzy
msgid ":ref:`rebalancer_max_sending <cfg_basic-rebalancer_max_sending>`"
msgstr ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:28
msgid "A field defining the logical topology of the sharded Tarantool cluster."
msgstr ""
"Поле, которое определяет логическую топологию сегментированного кластера "
"Tarantool'а."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:30
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:41
msgid "Type: table"
msgstr "Тип: таблица"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:38
msgid ""
"A field defining the configuration of relative weights for each zone pair"
" in a replica set. See the :ref:`Replica weights <vshard-replica-"
"weights>` section."
msgstr ""
"Поле, которое определяет конфигурацию относительного веса для каждой пары"
" зон в наборе реплик. См. раздел :ref:`Вес реплики <vshard-replica-"
"weights>`."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:49
msgid "An index over the bucket id."
msgstr "Индекс по идентификатору сегмента."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:51
msgid "Type: non-empty string or non-negative integer"
msgstr "Тип: непустая строка или неотрицательное целое число"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:52
msgid "Default: coincides with the bucket id number"
msgstr "По умолчанию: совпадает с числом идентификатора сегмента"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:59
msgid "The total number of buckets in a cluster."
msgstr "Общее число сегментов в кластере."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:61
msgid ""
"This number should be several orders of magnitude larger than the "
"potential number of cluster nodes, considering potential scaling out in "
"the foreseeable future."
msgstr ""
"Это число должно быть на несколько порядков больше, чем потенциальное "
"число узлов кластера, учитывая потенциальное масштабирование в обозримом "
"будущем."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:66
msgid ""
"If the estimated number of nodes is M, then the data set should be "
"divided into 100M or even 1000M buckets, depending on the planned scaling"
" out. This number is certainly greater than the potential number of "
"cluster nodes in the system being designed."
msgstr ""
"Если предполагаемое количество узлов равно M, тогда набор данных должен "
"быть разделен на 100M или даже 1000M сегментов, в зависимости от "
"запланированного масштабирования. Это число, безусловно, больше "
"потенциального числа узлов кластера в проектируемой системе."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:71
msgid ""
"Keep in mind that too many buckets can cause a need to allocate more "
"memory to store routing information. On the other hand, an insufficient "
"number of buckets can lead to decreased granularity when rebalancing."
msgstr ""
"Следует помнить, что слишком большое число сегментов может привести к "
"необходимости выделять больше памяти для хранения информации о "
"маршрутизации. С другой стороны, недостаточное число сегментов может "
"привести к снижению степени детализации при балансировке."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:75
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:85
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:107
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:122
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:143
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:158
msgid "Type: number"
msgstr "Тип: число"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:76
msgid "Default: 3000"
msgstr "По умолчанию: 3000"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:83
msgid "The interval between garbage collector actions, in seconds."
msgstr "Интервал между действиями сборщика мусора в секундах."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:93
#, fuzzy
msgid ""
"If set to true, the Lua ``collectgarbage()`` function is called "
"periodically."
msgstr ""
"Если задано значение true (правда), периодически вызывается Lua-функция "
"collectgarbage()."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:96
msgid "Default: no"
msgstr "По умолчанию: нет"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:103
msgid ""
"Timeout to wait for synchronization of the old master with replicas "
"before demotion. Used when switching a master or when manually calling "
"the ``sync()`` function."
msgstr ""
"Время ожидания синхронизации старого мастера с репликами перед сменой "
"мастера. Используется при переключении мастера или при вызове функции "
"``sync()`` вручную."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:115
msgid ""
"A maximum bucket disbalance threshold, in percent. The threshold is "
"calculated for each replica set using the following formula:"
msgstr ""
"Максимальный предел дисбаланса сегментов в процентах. Предел вычисляется "
"для каждого набора реплик по следующей формуле:"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:118
msgid "|etalon_bucket_count - real_bucket_count| / etalon_bucket_count * 100"
msgstr ""
"|эталонное_число_сегментов - фактическое_число_сегментов| / "
"эталонное_число_сегментов * 100"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:130
#, fuzzy
msgid ""
"The maximum number of buckets that can be received in parallel by a "
"single replica set. This number must be limited, because when a new "
"replica set is added to a cluster, the rebalancer sends a very large "
"amount of buckets from the existing replica sets to the new replica set. "
"This produces a heavy load on the new replica set."
msgstr ""
"Максимальное количество сегментов, которые может получить параллельно "
"один набор реплик. Это число должно быть ограничено, так как при "
"добавлении нового набора реплик в кластер балансировщик отправляет очень "
"большое количество сегментов из существующих наборов реплик в новый набор"
" реплик. Это создает большую нагрузку на новый набор реплик."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:137
msgid ""
"Suppose ``rebalancer_max_receiving`` is equal to 100, ``bucket_count`` is"
" equal to 1000. There are 3 replica sets with 333, 333 and 334 buckets on"
" each respectively. When a new replica set is added, each replica set’s "
"``etalon_bucket_count`` becomes equal to 250. Rather than receiving all "
"250 buckets at once, the new replica set receives 100, 100 and 50 buckets"
" sequentially."
msgstr ""
"Предположим, ``rebalancer_max_receiving`` = 100, число сегментов в "
"``bucket_count`` = 1000. Есть 3 набора реплик с 333, 333 и 334 сегментами"
" соответственно. При добавлении нового набора реплик "
"``эталонное_число_сегментов`` становится равным 250. Вместо того, чтобы "
"сразу получить все 250 сегментов, новый набор реплик получит "
"последовательно 100, 100 и 50 сегментов."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:144
msgid "Default: 100"
msgstr "По умолчанию: 100"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:151
msgid ""
"The degree of parallelism for :ref:`parallel rebalancing <vshard-"
"parallel-rebalancing>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:154
msgid "Works for storages only, ignored for routers."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:156
msgid "The maximum value is ``15``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:166
msgid "Replica set functions"
msgstr "Функции набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:168
msgid ":ref:`uuid <cfg_replica_set-uuid>`"
msgstr ":ref:`uuid <cfg_replica_set-uuid>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:169
msgid ":ref:`weight <cfg_replica_set-weight>`"
msgstr ":ref:`weight <cfg_replica_set-weight>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:175
msgid "A unique identifier of a replica set."
msgstr "Уникальный идентификатор набора реплик."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:177
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:188
msgid "Type:"
msgstr "Тип:"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:178
msgid "Default:"
msgstr "По умолчанию:"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:179
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:190
msgid "Dynamic:"
msgstr "Динамическое:"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:185
msgid ""
"A weight of a replica set. See the :ref:`Replica set weights <vshard-"
"replica-set-weights>` section for details."
msgstr ""
"Вес набора реплик. Для получения подробной информации см. раздел "
":ref:`Вес набора реплик <vshard-replica-set-weights>`."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:202
msgid "Router public API"
msgstr "Общедоступные API роутера"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:204
msgid ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"
msgstr ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:205
msgid ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"
msgstr ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:206
msgid ":ref:`vshard.router.new(name, cfg) <router_api-new>`"
msgstr ":ref:`vshard.router.new(name, cfg) <router_api-new>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:207
msgid ""
":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list},"
" {options}) <router_api-call>`"
msgstr ""
":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list},"
" {options}) <router_api-call>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:208
msgid ""
":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callro>`"
msgstr ""
":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callro>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:209
msgid ""
":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callrw>`"
msgstr ""
":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callrw>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:210
msgid ""
":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callre>`"
msgstr ""
":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callre>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:211
msgid ""
":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbro>`"
msgstr ""
":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbro>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:212
msgid ""
":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbre>`"
msgstr ""
":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbre>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:213
msgid ":ref:`vshard.router.route(bucket_id) <router_api-route>`"
msgstr ":ref:`vshard.router.route(bucket_id) <router_api-route>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:214
msgid ":ref:`vshard.router.routeall() <router_api-routeall>`"
msgstr ":ref:`vshard.router.routeall() <router_api-routeall>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:215
msgid ":ref:`vshard.router.bucket_id(key) <router_api-bucket_id>`"
msgstr ":ref:`vshard.router.bucket_id(key) <router_api-bucket_id>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:216
msgid ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"
msgstr ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:217
msgid ":ref:`vshard.router.sync(timeout) <router_api-sync>`"
msgstr ":ref:`vshard.router.sync(timeout) <router_api-sync>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:218
msgid ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"
msgstr ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:219
msgid ":ref:`vshard.router.info() <router_api-info>`"
msgstr ":ref:`vshard.router.info() <router_api-info>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:220
msgid ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"
msgstr ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:221
msgid ":ref:`replicaset.call() <router_api-replicaset_call>`"
msgstr ":ref:`replicaset.call() <router_api-replicaset_call>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:222
msgid ":ref:`replicaset.callro() <router_api-replicaset_callro>`"
msgstr ":ref:`replicaset.callro() <router_api-replicaset_callro>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:223
msgid ":ref:`replicaset.callrw() <router_api-replicaset_callrw>`"
msgstr ":ref:`replicaset.callrw() <router_api-replicaset_callrw>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:224
msgid ":ref:`replicaset.callre() <router_api-replicaset_callre>`"
msgstr ":ref:`replicaset.callre() <router_api-replicaset_callre>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:230
msgid ""
"Perform the initial cluster bootstrap and distribute all buckets across "
"the replica sets."
msgstr ""
"Выполнение первоначальной настройки кластера и распределение всех "
"сегментов по наборам реплик."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:233
msgid ""
"a number of seconds before ending a bootstrap attempt as unsuccessful. "
"Recreate the cluster in case of bootstrap timeout."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:241
msgid ""
"Configure the database and start sharding for the specified ``router`` "
"instance. See the :ref:`sample configuration <vshard-config-cluster-"
"example>` above."
msgstr ""
"Настройка базы данных и начало шардинга указанного ``роутера``. См. "
":ref:`образец конфигурации<vshard-config-cluster-example>` выше."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:245
msgid "a configuration table"
msgstr "конфигурационная таблица"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:251
msgid ""
"Create a new router instance. ``vshard`` supports multiple routers in a "
"single Tarantool instance. Each router can be connected to any ``vshard``"
" cluster, and multiple routers can be connected to the same cluster."
msgstr ""
"Создание нового экземпляра роутера. ``vshard`` поддерживает работу "
"нескольких роутеров в отдельном экземпляре Tarantool'а. Каждый роутер "
"может подключаться к любом кластеру ``vshard``, несколько роутеров могут "
"подключаться к одному кластеру."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:255
msgid ""
"A router created via ``vshard.router.new()`` works in the same way as a "
"static router, but the method name is preceded by a colon "
"(``vshard.router:method_name(...)``), while for a static router the "
"method name is preceded by a period (``vshard.router.method_name(...)``)."
msgstr ""
"Роутер, созданный с помощью ``vshard.router.new()``, работает так же, как"
" и статичный роутер, но перед его методами указывается двоеточие "
"(``vshard.router:имя_метода(...)``), а перед методами статичного роутера "
"-- точка (``vshard.router.имя_метода(...)``)."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:260
msgid ""
"A static router can be obtained via the ``vshard.router.static()`` method"
" and then used like a router created via the ``vshard.router.new()`` "
"method."
msgstr ""
"Статичный роутер можно получить при помощи метода "
"``vshard.router.static()``, а затем использовать его как роутер, "
"созданный с помощью метода ``vshard.router.new()``."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:266
msgid "``box.cfg`` is shared among all the routers of a single instance."
msgstr "``box.cfg`` используется всеми роутерами одного экземпляра."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:268
msgid ""
"a router instance name. This name is used as a prefix in logs of the "
"router and must be unique within the instance"
msgstr ""
"имя экземпляра роутера, которое используется в качестве префикса в "
"журналах роутера и должно быть уникальным в пределах экземпляра"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:270
msgid ""
"a configuration table. The :ref:`sample configuration <vshard-config-"
"cluster-example>` is described above."
msgstr ""
"конфигурационная таблица. :ref:`Образец конфигурации <vshard-config-"
"cluster-example>` описан выше."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:274
msgid ""
"a router instance, if created successfully; otherwise, nil and an error "
"object"
msgstr "экземпляр роутера, если он создан; в противном случае, nil и ошибка"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:281
msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id. See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id). Для получения подробной "
"информации о работе функции см. раздел :ref:`Обработка запросов <vshard-"
"process-requests>`."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:286
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:344
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:375
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:408
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:452
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:485
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:692
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:772
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:800
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:811
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:822
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:848
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:967
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:987
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:996
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1021
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1039
msgid "a bucket identifier"
msgstr "идентификатор сегмента"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:287
msgid ""
"either a string = 'read'|'write', or a map with mode='read'|'write' "
"and/or prefer_replica=true|false and/or balance=true|false."
msgstr ""
"либо строка = 'read'|'write' (чтение|запись), либо ассоциативный массив с"
" параметром mode ='read'|'write' (чтение|запись) и/или "
"prefer_replica=true|false (правда|ложь), и/или balance=true|false "
"(правда|ложь)."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:288
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:345
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:376
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:409
msgid "a function to execute"
msgstr "выполняемая функция"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:289
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:346
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:377
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:410
msgid "an array of the function's arguments"
msgstr "массив аргументов функции"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:290
#, fuzzy
msgid ""
"* ``timeout`` – a request timeout, in seconds. If the router cannot "
"identify a   shard with the specified ``bucket_id``, the operation will "
"be repeated until the   timeout is reached."
msgstr ""
"* ``timeout`` -- время ожидания запроса в секундах. Если роутер не может "
"определить шард с указанным идентификатором сегмента, операция "
"повторяется до истечения времени ожидания."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:292
#, fuzzy
msgid ""
"``timeout`` – a request timeout, in seconds. If the router cannot "
"identify a shard with the specified ``bucket_id``, the operation will be "
"repeated until the timeout is reached."
msgstr ""
"``timeout`` -- время ожидания запроса в секундах. Если роутер не может "
"определить шард с указанным идентификатором сегмента, операция "
"повторяется до истечения времени ожидания."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:296
#, fuzzy
msgid ""
"The mode parameter has two possible forms: a string or a map. Examples of"
" the string form are: ``'read'``, ``'write'``. Examples of the map form "
"are: ``{mode='read'}``, ``{mode='write'}``, ``{mode='read', "
"prefer_replica=true}``, ``{mode='read', balance=true}``, ``{mode='read', "
"prefer_replica=true, balance=true}``."
msgstr ""
"У параметра режима mode есть две доступные формы: строка или "
"ассоциативный массив. Примеры строки: 'read' (чтение), 'write' (запись). "
"Примеры ассоциативного массива: {mode='read'}, {mode='write'}, "
"{mode='read', prefer_replica=true}, {mode='read', balance=true}, "
"{mode='read', prefer_replica=true, balance=true}. Если указать значение "
"'write' (запись), то целью будет мастер. Если указать "
"prefer_replica=true, то предпочитаемая цель -- одна из реплик; если же "
"доступной реплики нет, то целью будет мастер. Удобно указать "
"prefer_replica=true для ресурсозатратных функций во избежание замедления "
"работы мастера. Если задать balance=true, добавится балансировка нагрузки"
" -- чтения распределяются по всем узлам набора реплик по кругу, "
"предпочтение отдается репликам, если также задан параметр "
"prefer_replica=true."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:301
msgid "If ``'write'`` is specified then the target is the master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:303
msgid ""
"If ``prefer_replica=true`` is specified then the preferred target is one "
"of the replicas, but the target is the master if there is no conveniently"
" available replica."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:306
msgid ""
"It may be good to specify prefer_replica=true for functions which are "
"expensive in terms of resource use, to avoid slowing down the master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:309
msgid ""
"If ``balance=true`` then there is load balancing -- reads are distributed"
" over all the nodes in the replica set in round-robin fashion, with a "
"preference for replicas if prefer_replica=true is also set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:313
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:355
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:386
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:419
msgid ""
"The original return value of the executed function, or ``nil`` and error "
"object. The error object has a type attribute equal to ``ShardingError`` "
"or one of the regular Tarantool errors (``ClientError``, ``OutOfMemory``,"
" ``SocketError``, etc.)."
msgstr ""
"Исходное возвращаемое значение выполняемой функции или ``nil`` и ошибка. "
"Объект ошибки содержит атрибут типа, который равен ``ShardingError`` или "
"одной из стандартных ошибок Tarantool'а(``ClientError``, ``OutOfMemory``,"
" ``SocketError`` и т.д.)."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:318
msgid ""
"``ShardingError`` is returned on errors specific for sharding: the master"
" is missing, wrong bucket id, etc. It has an attribute code containing "
"one of the values from the ``vshard.error.code.*`` LUA table, an optional"
" attribute containing a message with the human-readable error "
"description, and other attributes specific for the error code."
msgstr ""
"``ShardingError`` возвращается в случае ошибок шардинга: набор реплик "
"недоступен, отсутствует мастер, неверный идентификатор сегмента и т.д. "
"Такая ошибка содержит код с одним из значений из Lua-таблицы "
"``vshard.error.code.*``, необязательный атрибут сообщения с удобным для "
"восприятия описанием ошибки и другие атрибуты, специфичные для данного "
"кода ошибки."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:326
msgid "To call ``customer_add`` function from ``vshard/example``, say:"
msgstr ""
"Для вызова функции ``customer_add`` из ``vshard/example`` выполните "
"команду:"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:328
msgid ""
"vshard.router.call(100, 'write', 'customer_add', {{customer_id = 2, "
"bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})\n"
"-- or, the same thing but with a map for the second argument\n"
"vshard.router.call(100, {mode='write'}, 'customer_add', {{customer_id = "
"2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})"
msgstr ""
"vshard.router.call(100, 'write', 'customer_add', {{customer_id = 2, "
"bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})\n"
"-- или то же самое, но с ассоциативным массивом в качестве второго "
"аргумента\n"
"vshard.router.call(100, {mode='write'}, 'customer_add', {{customer_id = "
"2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:338
msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-only mode (similar to calling "
"vshard.router.call with mode='read'). See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id) в режиме только для "
"чтения (аналогично вызову vshard.router.call в режиме mode='read'). Для "
"получения подробной информации о работе функции см. раздел "
":ref:`Обработка запросов <vshard-process-requests>`."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:347
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:378
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:411
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:608
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:629
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:648
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:670
msgid ""
"* ``timeout`` – a request timeout, in seconds. In case the ``router`` "
"cannot identify a   shard with the bucket id, the operation will be "
"repeated until the   timeout is reached."
msgstr ""
"* ``timeout`` -- время ожидания запроса в секундах. Если ``роутер`` не "
"может определить шард с идентификатором сегмента, операция повторяется до"
" истечения времени ожидания."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:349
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:380
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:413
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:610
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:631
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:650
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:672
msgid ""
"``timeout`` – a request timeout, in seconds. In case the ``router`` "
"cannot identify a shard with the bucket id, the operation will be "
"repeated until the timeout is reached."
msgstr ""
"``timeout`` -- время ожидания запроса в секундах. Если ``роутер`` не "
"может определить шард с идентификатором сегмента, операция повторяется до"
" истечения времени ожидания."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:360
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:391
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:424
msgid ""
"``ShardingError`` is returned on errors specific for sharding: the "
"replica set is not available, the master is missing, wrong bucket id, "
"etc. It has an attribute code containing one of the values from the "
"``vshard.error.code.*`` LUA table, an optional attribute containing a "
"message with the human-readable error description, and other attributes "
"specific for this error code."
msgstr ""
"``ShardingError`` возвращается в случае ошибок шардинга: набор реплик "
"недоступен, отсутствует мастер, неверный идентификатор сегмента и т.д. "
"Такая ошибка сб.одержит код с одним из значений из Lua-таблицы "
"``vshard.error.code.*``, необязательный атрибут сообщения с удобным для "
"восприятия описанием ошибки и другие атрибуты, специфичные для данного "
"кода ошибки."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:370
msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-write mode (similar to calling "
"vshard.router.call with mode='write'). See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id) в режиме чтения и записи "
"(аналогично вызову vshard.router.call в режиме mode='write'). Для "
"получения подробной информации о работе функции см. раздел "
":ref:`Обработка запросов <vshard-process-requests>`."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:401
#, fuzzy
msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-only mode (similar to calling "
"``vshard.router.call`` with ``mode='read'``), with preference for a "
"replica rather than a master (similar to calling ``vshard.router.call`` "
"with ``prefer_replica = true``). See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id) в режиме только для "
"чтения (аналогично вызову vshard.router.call в режиме mode='read'), когда"
" предпочтение отдается реплике, а не мастеру (аналогично вызову "
"vshard.router.call с параметром  prefer_replica = true). Для получения "
"подробной информации о работе функции см. раздел :ref:`Обработка запросов"
" <vshard-process-requests>`."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:434
msgid ""
"This has the same effect as :ref:`vshard.router.call() <router_api-call>`"
" with mode parameter = {mode='read', balance=true}."
msgstr ""
"Эквивалент :ref:`vshard.router.call() <router_api-call>` с параметром "
"mode = {mode='read', balance=true}."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:442
#, fuzzy
msgid ""
"This has the same effect as :ref:`vshard.router.call() <router_api-call>`"
" with mode ``parameter = {mode='read', balance=true, "
"prefer_replica=true}``."
msgstr ""
"Эквивалент :ref:`vshard.router.call() <router_api-call>` с параметром "
"mode = {mode='read', balance=true, prefer_replica=true}."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:450
msgid ""
"Return the replica set object for the bucket with the specified bucket id"
" value."
msgstr ""
"Возврат объекта набора реплик для сегмента с указанным значением "
"идентификатора сегмента (bucket id)."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:454
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:469
msgid "a replica set object"
msgstr "объект набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:458
msgid "replicaset = vshard.router.route(123)"
msgstr "replicaset = vshard.router.route(123)"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:466
msgid "Return all available replica set objects."
msgstr "Возврат всех доступных объектов наборов реплик."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:468
msgid "a map of the following type: ``{UUID = replicaset}``"
msgstr "ассоциативный массив следующего вида: ``{UUID = replicaset}``"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:473
msgid "replicaset = vshard.router.routeall()"
msgstr "replicaset = vshard.router.routeall()"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:481
msgid "Calculate the bucket id using a simple built-in hash function."
msgstr ""
"Вычисление идентификатора сегмента с помощью простой встроенной "
"хеш-функции."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:483
msgid "a hash key. This can be any Lua object (number, table, string)."
msgstr "хеш-ключ. Это может быть любой Lua-объект (число, таблица, строка)."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:490
msgid "bucket_id = vshard.router.bucket_id(18374927634039)"
msgstr "bucket_id = vshard.router.bucket_id(18374927634039)"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:498
msgid "Return the total number of buckets specified in ``vshard.router.cfg()``."
msgstr "Возврат общего количества сегментов, указанных в `vshard.router.cfg()``."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:500
msgid "the total number of buckets"
msgstr "общее количество сегментов"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:507
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:786
msgid "Wait until the dataset is synchronized on replicas."
msgstr "Ожидание синхронизации набора данных на репликах."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:509
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:788
msgid "a timeout, in seconds"
msgstr "время ожидания в секундах"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:511
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:790
msgid ""
"``true`` if the dataset was synchronized successfully; or ``nil`` and "
"``err`` explaining why the dataset cannot be synchronized."
msgstr ""
"``true`` (правда), если выполнена синхронизация набора данных; или же "
"``nil`` и ошибка ``err`` с объяснением причины невозможности "
"синхронизации набора данных."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:518
msgid "Force wakeup of the bucket discovery fiber."
msgstr "Принудительный запуск файбера обнаружения сегментов."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:524
msgid "Return information about each instance."
msgstr "Возврат информации по каждому экземпляру."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:528
msgid "Replica set parameters:"
msgstr "Параметры набора реплик:"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:530
msgid "replica set uuid"
msgstr "UUID набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:531
msgid "master instance parameters"
msgstr "параметры мастер-экземпляра"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:532
msgid "replica instance parameters"
msgstr "параметры реплики"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:534
msgid "Instance parameters:"
msgstr "Параметры экземпляра:"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:536
msgid "``uri`` — URI of the instance"
msgstr "``uri`` -- URI экземпляра"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:537
msgid "``uuid`` — UUID of the instance"
msgstr "``uuid`` -- UUID экземпляра"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:538
msgid ""
"``status`` – status of the instance (``available``, ``unreachable``, "
"``missing``)"
msgstr ""
"``status`` -- статус экземпляра: ``available`` (доступный), "
"``unreachable`` (недоступный), ``missing`` (отсутствующий)"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:539
msgid ""
"``network_timeout`` – a timeout for the request. The value is updated "
"automatically on each 10th successful request and each 2nd failed "
"request."
msgstr ""
"``network_timeout`` -- время ожидания запроса. Данное значение "
"обновляется автоматически на каждом 10 выполненном запросе и на каждом 2 "
"невыполненном запросе."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:542
msgid "Bucket parameters:"
msgstr "Параметры сегмента:"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:544
msgid ""
"``available_ro`` – the number of buckets known to the ``router`` and "
"available for read requests"
msgstr ""
"``available_ro`` -- количество сегментов, известных роутеру и доступных "
"для запросов чтения"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:545
msgid ""
"``available_rw`` – the number of buckets known to the router and "
"available for read and write requests"
msgstr ""
"``available_rw`` -- количество сегментов, известных роутеру и доступных "
"для запросов чтения и записи"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:546
msgid ""
"``unavailable`` – the number of buckets known to the ``router`` but "
"unavailable for any requests"
msgstr ""
"``unavailable`` -- количество сегментов, известных роутеру, но "
"недоступных для любых запросов"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:547
msgid ""
"``unreachable`` – the number of buckets whose replica sets are not known "
"to the ``router``"
msgstr ""
"``unreachable``-- количество сегментов, для которых роутер не знает "
"соответствующие наборы реплик"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:551
msgid ""
"tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""
"tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:585
msgid ""
"Return information about each bucket. Since a bucket map can be huge, "
"only the required range of buckets can be specified."
msgstr ""
"Возврат информации по каждому сегменту. Поскольку массив сегментов может "
"быть огромен, можно указать только необходимый ряд сегментов."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:588
msgid "the offset in a bucket map of the first bucket to show"
msgstr "начальное значение выборки сегментов"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:589
msgid "the maximum number of buckets to show"
msgstr "максимальное количество показываемых сегментов"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:591
msgid "a map of the following type: ``{bucket_id = 'unknown'/replicaset_uuid}``"
msgstr ""
"ассоциативный массив следующего вида: ``{bucket_id = "
"'unknown'/replicaset_uuid}``"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:597
msgid ""
"Call a function on a nearest available master (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with specified "
"arguments."
msgstr ""
"Вызов функции с указанными аргументами на ближайшем доступном мастере "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``)."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:603
msgid "The ``replicaset.call`` method is similar to ``replicaset.callrw``."
msgstr "Метод ``replicaset.call`` аналогичен ``replicaset.callrw``."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:605
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:626
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:645
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:667
msgid "UUID of a replica set"
msgstr "UUID набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:606
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:627
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:646
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:668
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:774
msgid "function to execute"
msgstr "выполняемая функция"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:607
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:628
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:647
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:669
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:775
msgid "array of the function's arguments"
msgstr "массив аргументов функции"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:618
msgid ""
"Call a function on a nearest available master (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with a specified "
"arguments."
msgstr ""
"Вызов функции с указанными аргументами на ближайшем доступном мастере "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``)."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:624
msgid "The ``replicaset.callrw`` method is similar to ``replicaset.call``."
msgstr "Метод ``replicaset.callrw`` аналогичен ``replicaset.call``."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:639
msgid ""
"Call a function on the nearest available replica (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with specified "
"arguments. It is recommended to call only read-only functions using "
"``replicaset.callro()``, as the function can be executed not only on a "
"master, but also on replicas."
msgstr ""
"Вызов функции с указанными аргументами на ближайшей доступной реплике "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``). С помощью ``replicaset.callro()`` рекомендуется "
"вызывать исключительно функции, доступные только для чтения. поскольку "
"такие функции можно выполнять не только на мастере, но и на репликах."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:658
msgid ""
"Call a function on the nearest available replica (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with specified "
"arguments, with preference for a replica rather than a master (similar to"
" calling vshard.router.call with prefer_replica = true). It is "
"recommended to call only read-only functions using "
"``replicaset.callre()``, as the function can be executed not only on a "
"master, but also on replicas."
msgstr ""
"Вызов функции с указанными аргументами на ближайшей доступной реплике "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``), предпочтение отдается реплике, а не мастеру (аналогично"
" вызову vshard.router.call с параметром prefer_replica = true). С помощью"
" ``replicaset.callre()`` рекомендуется вызывать исключительно функции, "
"доступные только для чтения. поскольку такие функции можно выполнять не "
"только на мастере, но и на репликах."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:680
msgid "Router internal API"
msgstr "Внутренние API роутера"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:682
msgid ""
":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-"
"bucket_discovery>`"
msgstr ""
":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-"
"bucket_discovery>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:688
msgid ""
"Search for the bucket in the whole cluster. If the bucket is not found, "
"it is likely that it does not exist. The bucket might also be moved "
"during rebalancing and currently is in the RECEIVING state."
msgstr ""
"Поиск сегмента по всему кластеру. Если сегмент не обнаружен, скорее "
"всего, он не существует. Также сегмент также может быть перемещен во "
"время балансировки и в данный момент находится в статусе получения "
"RECEIVING."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:698
msgid "Storage public API"
msgstr "Общедоступные API хранилища"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:700
msgid ":ref:`vshard.storage.cfg(cfg, name) <storage_api-cfg>`"
msgstr ":ref:`vshard.storage.cfg(cfg, name) <storage_api-cfg>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:701
msgid ":ref:`vshard.storage.info() <storage_api-info>`"
msgstr ":ref:`vshard.storage.info() <storage_api-info>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:702
msgid ""
":ref:`vshard.storage.call(bucket_id, mode, function_name, "
"{argument_list}) <storage_api-call>`"
msgstr ""
":ref:`vshard.storage.call(bucket_id, mode, function_name, "
"{argument_list}) <storage_api-call>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:703
msgid ":ref:`vshard.storage.sync(timeout) <storage_api-sync>`"
msgstr ":ref:`vshard.storage.sync(timeout) <storage_api-sync>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:704
msgid ":ref:`vshard.storage.bucket_pin(bucket_id) <storage_api-bucket_pin>`"
msgstr ":ref:`vshard.storage.bucket_pin(bucket_id) <storage_api-bucket_pin>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:705
msgid ":ref:`vshard.storage.bucket_unpin(bucket_id) <storage_api-bucket_unpin>`"
msgstr ":ref:`vshard.storage.bucket_unpin(bucket_id) <storage_api-bucket_unpin>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:706
msgid ":ref:`vshard.storage.bucket_ref(bucket_id, mode) <storage_api-bucket_ref>`"
msgstr ":ref:`vshard.storage.bucket_ref(bucket_id, mode) <storage_api-bucket_ref>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:707
msgid ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"
msgstr ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:708
msgid ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"
msgstr ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:709
msgid ""
":ref:`vshard.storage.bucket_unref(bucket_id, mode) <storage_api-"
"bucket_unref>`"
msgstr ""
":ref:`vshard.storage.bucket_unref(bucket_id, mode) <storage_api-"
"bucket_unref>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:710
msgid ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"
msgstr ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:711
msgid ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"
msgstr ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:712
msgid ""
":ref:`vshard.storage.find_garbage_bucket(bucket_index, control) "
"<storage_api-find_garbage_bucket>`"
msgstr ""
":ref:`vshard.storage.find_garbage_bucket(bucket_index, control) "
"<storage_api-find_garbage_bucket>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:713
msgid ""
":ref:`vshard.storage.rebalancer_disable() <storage_api-"
"rebalancer_disable>`"
msgstr ""
":ref:`vshard.storage.rebalancer_disable() <storage_api-"
"rebalancer_disable>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:714
msgid ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"
msgstr ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:715
msgid ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"
msgstr ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:716
msgid ""
":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-"
"rebalancing_is_in_progress>`"
msgstr ""
":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-"
"rebalancing_is_in_progress>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:717
msgid ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"
msgstr ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:718
msgid ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"
msgstr ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:719
msgid ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"
msgstr ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:725
msgid ""
"Configure the database and start sharding for the specified ``storage`` "
"instance."
msgstr ""
"Конфигурация базы данных и начало шардинга на указанном экземпляре "
"хранилища."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:728
msgid "a ``storage`` configuration"
msgstr "конфигурация хранилища"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:729
msgid "UUID of the instance"
msgstr "UUID экземпляра"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:735
msgid "Return information about the storage instance in the following format:"
msgstr "Возврат информации по экземпляру хранилища в следующем формате:"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:737
msgid ""
"tarantool> vshard.storage.info()\n"
"---\n"
"- buckets:\n"
"    2995:\n"
"      status: active\n"
"      id: 2995\n"
"    2997:\n"
"      status: active\n"
"      id: 2997\n"
"    2999:\n"
"      status: active\n"
"      id: 2999\n"
"  replicasets:\n"
"    2dd0a343-624e-4d3a-861d-f45efc571cd3:\n"
"      uuid: 2dd0a343-624e-4d3a-861d-f45efc571cd3\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"        uuid: 2ec29309-17b6-43df-ab07-b528e1243a79\n"
"    c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1:\n"
"      uuid: c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"        uuid: 810d85ef-4ce4-4066-9896-3c352fec9e64\n"
"..."
msgstr ""
"tarantool> vshard.storage.info()\n"
"---\n"
"- buckets:\n"
"    2995:\n"
"      status: active\n"
"      id: 2995\n"
"    2997:\n"
"      status: active\n"
"      id: 2997\n"
"    2999:\n"
"      status: active\n"
"      id: 2999\n"
"  replicasets:\n"
"    2dd0a343-624e-4d3a-861d-f45efc571cd3:\n"
"      uuid: 2dd0a343-624e-4d3a-861d-f45efc571cd3\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"        uuid: 2ec29309-17b6-43df-ab07-b528e1243a79\n"
"    c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1:\n"
"      uuid: c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"        uuid: 810d85ef-4ce4-4066-9896-3c352fec9e64\n"
"..."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:770
msgid "Call the specified function on the current ``storage`` instance."
msgstr "Вызов указанной функции на текущем экземпляре хранилища."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:773
msgid "a type of the function: 'read' or 'write'"
msgstr "тип функции: 'read' или 'write' (чтение или запись)"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:779
msgid ""
"The original return value of the executed function, or ``nil`` and error "
"object."
msgstr "Исходное возвращаемое значение выполняемой функции или ``nil`` и ошибка."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:797
msgid ""
"Pin a bucket to a replica set. A pinned bucket cannot be moved even if it"
" breaks the cluster balance."
msgstr ""
"Закрепление сегмента в наборе реплик. Закрепленный сегмент нельзя "
"перемещать, даже если это нарушает баланс в кластере."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:802
msgid ""
"``true`` if the bucket is pinned successfully; or ``nil`` and ``err`` "
"explaining why the bucket cannot be pinned"
msgstr ""
"``true`` (правда), если выполнено закрепление сегмента; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности закрепления сегмента"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:809
msgid "Return a pinned bucket back into the active state."
msgstr "Возврат закрепленного сегмента в активное состояние."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:813
msgid ""
"``true`` if the bucket is unpinned successfully; or ``nil`` and ``err`` "
"explaining why the bucket cannot be unpinned"
msgstr ""
"``true`` (правда), если выполнено открепление сегмента; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности открепления сегмента"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:820
msgid "Create an RO or RW :ref:`ref <vshard-ref>`."
msgstr "Создание :ref:`ссылки <vshard-ref>` типа RO или RW."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:823
#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:849
msgid "'read' or 'write'"
msgstr "'read' или 'write' (чтение или запись)"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:825
msgid ""
"``true`` if the bucket ref is created successfully; or ``nil`` and "
"``err`` explaining why the ref cannot be created"
msgstr ""
"``true`` (правда), если выполнено создание ссылки; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности создания ссылки"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:832
msgid ""
"An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in"
" the RO mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` в"
" режиме только чтения."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:839
msgid ""
"An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in"
" the RW mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` в"
" режиме чтения и записи."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:846
msgid "Remove a RO/RW :ref:`ref <vshard-ref>`."
msgstr "Удаление :ref:`ссылки <vshard-ref>` RO/RW."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:851
msgid ""
"``true`` if the bucket ref is removed successfully; or ``nil`` and "
"``err`` explaining why the ref cannot be removed"
msgstr ""
"``true`` (правда), если выполнено удаление ссылки; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности удаления ссылки"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:858
msgid ""
"An alias for :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` in the RO mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` в режиме только чтения."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:865
msgid ""
"An alias for :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` in the RW mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` в режиме чтения и записи."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:872
msgid ""
"Find a bucket which has data in a space but is not stored in a "
"``_bucket`` space; or is in a GARBAGE state."
msgstr ""
"Поиск сегмента, который хранит данные в спейсе, но не указан в спейсе "
"``_bucket``, или находится в статусе мусора (GARBAGE)."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:875
msgid "index of a space with the part of a bucket id"
msgstr "индекс спейса с частью идентификатора спейса"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:876
msgid ""
"a garbage collector controller. If there is an increased buckets "
"generation, then the search should be interrupted."
msgstr ""
"контроллер сборщика мусора. Если увеличивается масштаб создания "
"сегментов, поиск следует прервать."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:879
msgid "an identifier of the bucket in the garbage state, if found; otherwise, nil"
msgstr ""
"идентификатор сегмента в статусе мусора, если таковой обнаружен; в "
"противном случае, nil"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:886
msgid "Return information about each bucket located in storage. For example:"
msgstr ""
"Возврат информации по каждому сегменту, расположенному в хранилище. "
"Например:"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:904
msgid "Return the number of buckets located in storage."
msgstr "Возврат количества сегментов, расположенных в хранилище."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:910
msgid "Immediately wake up a recovery fiber, if it exists."
msgstr "Немедленный запуск файбера восстановления, если такой есть."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:916
msgid ""
"Return a flag indicating whether rebalancing is in progress. The result "
"is true if the node is currently applying routes received from a "
"rebalancer node in the special fiber."
msgstr ""
"Возврат флага, указывающего на ход процесса балансировки. Результатом "
"будет true (правда), если в данный момент узел применяет маршруты, "
"полученные от узла балансировки в специальном файбере."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:924
msgid "Return a flag indicating whether storage is invisible to the rebalancer."
msgstr "Возврат флага, указывающего на недоступность хранилища для балансировщика."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:930
msgid ""
"Disable rebalancing. A disabled rebalancer sleeps until it is enabled "
"again with vshard.storage.rebalancer_enable()."
msgstr ""
"Отключение балансировки. Отключенный балансировщик находится в режиме "
"ожидания до повторного запуска с помощью "
"vshard.storage.rebalancer_enable()."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:937
msgid "Enable rebalancing."
msgstr "Запуск балансировки."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:943
msgid ""
"Show the spaces that are visible to rebalancer and garbage collector "
"fibers."
msgstr ""
"Отображение спейсов, которые доступны балансировщику и файберам сборщика "
"мусора."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:949
msgid "Storage internal API"
msgstr "Внутренние API хранилища"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:951
msgid ":ref:`vshard.storage.bucket_stat(bucket_id) <storage_api-bucket_stat>`"
msgstr ":ref:`vshard.storage.bucket_stat(bucket_id) <storage_api-bucket_stat>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:952
msgid ""
":ref:`vshard.storage.bucket_recv(bucket_id, from, data) <storage_api-"
"bucket_recv>`"
msgstr ""
":ref:`vshard.storage.bucket_recv(bucket_id, from, data) <storage_api-"
"bucket_recv>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:953
msgid ""
":ref:`vshard.storage.bucket_delete_garbage(bucket_id) <storage_api-"
"bucket_delete_garbage>`"
msgstr ""
":ref:`vshard.storage.bucket_delete_garbage(bucket_id) <storage_api-"
"bucket_delete_garbage>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:954
msgid ""
":ref:`vshard.storage.bucket_collect(bucket_id) <storage_api-"
"bucket_collect>`"
msgstr ""
":ref:`vshard.storage.bucket_collect(bucket_id) <storage_api-"
"bucket_collect>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:955
msgid ""
":ref:`vshard.storage.bucket_force_create(first_bucket_id, count) "
"<storage_api-bucket_force_create>`"
msgstr ""
":ref:`vshard.storage.bucket_force_create(first_bucket_id, count) "
"<storage_api-bucket_force_create>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:956
msgid ""
":ref:`vshard.storage.bucket_force_drop(bucket_id, to) <storage_api-"
"bucket_force_drop>`"
msgstr ""
":ref:`vshard.storage.bucket_force_drop(bucket_id, to) <storage_api-"
"bucket_force_drop>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:957
msgid ":ref:`vshard.storage.bucket_send(bucket_id, to) <storage_api-bucket_send>`"
msgstr ":ref:`vshard.storage.bucket_send(bucket_id, to) <storage_api-bucket_send>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:958
msgid ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"
msgstr ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:959
msgid ""
":ref:`vshard.storage.rebalancer_request_state() <storage_api-"
"rebalancer_request_state>`"
msgstr ""
":ref:`vshard.storage.rebalancer_request_state() <storage_api-"
"rebalancer_request_state>`"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:965
msgid "Receive a bucket identified by bucket id from a remote replica set."
msgstr ""
"Получение сегмента по идентификатору сегмента (bucket id) из удаленного "
"набора реплик."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:968
msgid "UUID of source replica set"
msgstr "UUID исходного набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:969
msgid ""
"data logically stored in a bucket identified by bucket_id, in the same "
"format as the return value from ``bucket_collect() <storage_api-"
"bucket_collect>``"
msgstr ""
"данные, которые хранятся логически в сегменте, определенном по "
"идентификатору сегмента (bucket_id), в том же формате, что и возвращаемое"
" значение метода ``bucket_collect() <storage_api-bucket_collect>``"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:976
msgid "Return information about the bucket id:"
msgstr "Возврат информации об идентификаторе сегмента (bucket id):"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:978
msgid ""
"tarantool> vshard.storage.bucket_stat(1)\n"
"---\n"
"- 0\n"
"- status: active\n"
"  id: 1\n"
"..."
msgstr ""
"tarantool> vshard.storage.bucket_stat(1)\n"
"---\n"
"- 0\n"
"- status: active\n"
"  id: 1\n"
"..."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:993
msgid ""
"Force garbage collection for the bucket identified by bucket_id in case "
"the bucket was transferred to a different replica set."
msgstr ""
"Принудительная сборка мусора для сегмента, найденного по идентификатору "
"(bucket_id), если сегмент был перемещен в другой набор реплик."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1002
msgid ""
"Collect all the data that is logically stored in the bucket identified by"
" bucket_id:"
msgstr ""
"Сбор всех данных, которые хранятся логически в сегменте, найденном по "
"идентификатору (bucket_id):"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1004
msgid ""
"tarantool> vshard.storage.bucket_collect(1)\n"
"---\n"
"- 0\n"
"- - - 514\n"
"    - - [10, 1, 1, 100, 'Account 10']\n"
"      - [11, 1, 1, 100, 'Account 11']\n"
"      - [12, 1, 1, 100, 'Account 12']\n"
"      - [50, 5, 1, 100, 'Account 50']\n"
"      - [51, 5, 1, 100, 'Account 51']\n"
"      - [52, 5, 1, 100, 'Account 52']\n"
"  - - 513\n"
"    - - [1, 1, 'Customer 1']\n"
"      - [5, 1, 'Customer 5']\n"
"..."
msgstr ""
"tarantool> vshard.storage.bucket_collect(1)\n"
"---\n"
"- 0\n"
"- - - 514\n"
"    - - [10, 1, 1, 100, 'Account 10']\n"
"      - [11, 1, 1, 100, 'Account 11']\n"
"      - [12, 1, 1, 100, 'Account 12']\n"
"      - [50, 5, 1, 100, 'Account 50']\n"
"      - [51, 5, 1, 100, 'Account 51']\n"
"      - [52, 5, 1, 100, 'Account 52']\n"
"  - - 513\n"
"    - - [1, 1, 'Customer 1']\n"
"      - [5, 1, 'Customer 5']\n"
"..."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1027
msgid ""
"Force creation of the buckets (single or multiple) on the current replica"
" set. Use only for manual emergency recovery or for initial bootstrap."
msgstr ""
"Принудительное создание сегментов (одного или нескольких) в текущем "
"наборе реплик. Используется только для ручного аварийного восстановления "
"или для начальной настройки."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1030
msgid "an identifier of the first bucket in a range"
msgstr "идентификатор первого сегмента в диапазоне"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1031
msgid "the number of buckets to insert (default = 1)"
msgstr "количество вставляемых сегментов (по умолчанию, 1)"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1037
msgid "Drop a bucket manually for tests or emergency cases."
msgstr "Удаление сегмента вручную для тестирования или в аварийной ситуации."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1045
msgid ""
"Send a specified bucket from the current replica set to a remote replica "
"set."
msgstr ""
"Отправка указанного сегмента из текущего набора реплик в удаленный набор "
"реплик."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1047
msgid "bucket identifier"
msgstr "идентификатор сегмента"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1048
msgid "UUID of a remote replica set"
msgstr "UUID удаленного набора реплик"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1054
msgid ""
"Check all buckets of the host storage that have the SENT or ACTIVE state,"
" return the number of active buckets."
msgstr ""
"Проверка всех сегментов хост-хранилища в статусе отправки SENT или "
"активном статусе ACTIVE, возврат количества активных сегментов."

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1057
msgid "the number of buckets in the active state, if found; otherwise, nil"
msgstr ""
"количество сегментов в активном статусе, если таковые обнаружены; в "
"противном случае, nil"

#: ../doc/reference/reference_rock/vshard/vshard_ref.rst:1063
msgid "Collect an array of active bucket identifiers for discovery."
msgstr "Сбор массива идентификаторов активных сегментов для обнаружения."

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:5
msgid "Summary"
msgstr "Обзор"

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:7
#, fuzzy
msgid ""
"Scaling databases in a growing project is often considered one of the "
"most challenging issues. Once a single server cannot withstand the load, "
"scaling methods should be applied."
msgstr ""
"С ростом проекта масштабируемость баз данных становится проблемой. Если "
"отдельный сервер не может справиться с нагрузкой, необходимо применять "
"средства масштабирования."

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:11
msgid ""
"**Sharding** is a database architecture that allows for `horizontal "
"scaling "
"<https://en.wikipedia.org/wiki/Scalability#Horizontal_and_vertical_scaling>`_,"
" which implies that a dataset is partitioned and distributed over "
"multiple servers."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:15
#, fuzzy
msgid ""
"With ``vshard``, the tuples of a dataset are distributed across multiple "
"nodes, with a Tarantool database server instance on each node. Each "
"instance handles only a subset of the total data, so larger loads can be "
"handled by simply adding more servers. The initial dataset is partitioned"
" into multiple parts, so each part is stored on a separate server."
msgstr ""
"С помощью модуля ``vshard`` кортежи набора данных распределяются по "
"множеству узлов, на каждом из которых находится экземпляр сервера базы "
"данных Tarantool'а. Каждый экземпляр обрабатывает лишь подмножество от "
"общего количества данных, поэтому увеличение нагрузки можно "
"компенсировать добавлением новых серверов. Первоначальный набор данных "
"секционируется на множество частей, то есть каждая часть хранится на "
"отдельном сервере. Секционирование набора данных осуществляется с помощью"
" сегментных ключей."

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:21
msgid ""
"The ``vshard`` module is based on the concept of :ref:`virtual buckets "
"<vshard-vbuckets>`, where a tuple set is partitioned into a large number "
"of abstract virtual nodes (**virtual buckets**, further just **buckets**)"
" rather than into a smaller number of physical nodes."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:26
msgid ""
"The dataset is partitioned using **sharding keys** (bucket id numbers). "
"Hashing a sharding key into a large number of buckets allows seamlessly "
"changing the number of servers in the cluster. The **rebalancing "
"mechanism** distributes buckets evenly among all shards in case some "
"servers were added or removed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:31
#, fuzzy
msgid ""
"The buckets have **states**, so it is easy to monitor the server states. "
"For example, a server instance is active and available for all types of "
"requests, or a failover occurred and the instance accepts only read "
"requests."
msgstr ""
"Для сегментов предусмотрены состояния, поэтому можно легко отслеживать "
"состояние сервера. Например, активен ли экземпляр сервера и доступен ли "
"он для всех типов запросов, или же произошел отказ, и сервер принимает "
"только запросы на чтение."

#: ../doc/reference/reference_rock/vshard/vshard_summary.rst:35
#, fuzzy
msgid ""
"The ``vshard`` module provides analogs of the **data-manipulation "
"functions** of the Tarantool ``box`` library (select, insert, replace, "
"update, delete) for sharding-aware applications."
msgstr ""
"Модуль ``vshard`` предоставляет функции, аналогичные функциям по "
"управлению данными библиотеки Tarantool'а ``box`` (select, insert, "
"replace, update, delete)."

#: ../doc/reference/reference_sql/index.rst:5
#, fuzzy
msgid "SQL reference"
msgstr "Справочник по сторонним библиотекам"

#: ../doc/reference/reference_sql/index.rst:7
msgid ""
"This reference covers all the SQL statements and clauses supported by "
"Tarantool."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:3
msgid "SQL statements and clauses"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:9
#, fuzzy
msgid "ALTER TABLE"
msgstr "строка, таблица"

#: ../doc/reference/reference_sql/sql.rst:11
#: ../doc/reference/reference_sql/sql.rst:96
#: ../doc/reference/reference_sql/sql.rst:178
#: ../doc/reference/reference_sql/sql.rst:510
#: ../doc/reference/reference_sql/sql.rst:559
#: ../doc/reference/reference_sql/sql.rst:614
#: ../doc/reference/reference_sql/sql.rst:656
#: ../doc/reference/reference_sql/sql.rst:732
#: ../doc/reference/reference_sql/sql.rst:771
#: ../doc/reference/reference_sql/sql.rst:843
#: ../doc/reference/reference_sql/sql.rst:921
#: ../doc/reference/reference_sql/sql.rst:971
#: ../doc/reference/reference_sql/sql.rst:1015
#: ../doc/reference/reference_sql/sql.rst:1350
#: ../doc/reference/reference_sql/sql.rst:1389
#: ../doc/reference/reference_sql/sql.rst:1435
#: ../doc/reference/reference_sql/sql.rst:1461
#: ../doc/reference/reference_sql/sql.rst:1524
#: ../doc/reference/reference_sql/sql.rst:1579
#: ../doc/reference/reference_sql/sql.rst:1619
#: ../doc/reference/reference_sql/sql.rst:1704
#: ../doc/reference/reference_sql/sql.rst:1787
#: ../doc/reference/reference_sql/sql.rst:1840
#: ../doc/reference/reference_sql/sql.rst:1938
#: ../doc/reference/reference_sql/sql.rst:1989
#: ../doc/reference/reference_sql/sql.rst:2024
#: ../doc/reference/reference_sql/sql.rst:2084
#: ../doc/reference/reference_sql/sql.rst:2229
#: ../doc/reference/reference_sql/sql.rst:2314
#: ../doc/reference/reference_sql/sql.rst:2379
#: ../doc/reference/reference_sql/sql.rst:2448
#: ../doc/reference/reference_sql/sql.rst:2477
#: ../doc/reference/reference_sql/sql.rst:2507
#: ../doc/reference/reference_sql/sql.rst:2536
#: ../doc/reference/reference_sql/sql.rst:2590
#: ../doc/reference/reference_sql/sql.rst:2604
#: ../doc/reference/reference_sql/sql.rst:2637
#: ../doc/reference/reference_sql/sql.rst:2653
#: ../doc/reference/reference_sql/sql.rst:2677
#: ../doc/reference/reference_sql/sql.rst:2695
#: ../doc/reference/reference_sql/sql.rst:2721
#: ../doc/reference/reference_sql/sql.rst:2736
#: ../doc/reference/reference_sql/sql.rst:2754
#: ../doc/reference/reference_sql/sql.rst:2776
#: ../doc/reference/reference_sql/sql.rst:2795
#: ../doc/reference/reference_sql/sql.rst:2815
#: ../doc/reference/reference_sql/sql.rst:2831
#: ../doc/reference/reference_sql/sql.rst:2846
msgid "Syntax:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:13
msgid ":samp:`ALTER TABLE {table-name} RENAME TO {new-table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:14
msgid ""
":samp:`ALTER TABLE {table-name} ADD CONSTRAINT {constraint-name} "
"{constraint-definition};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:15
msgid ":samp:`ALTER TABLE {table-name} DROP CONSTRAINT {constraint-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:17
#: ../doc/reference/reference_sql/sql.rst:22
#: ../doc/reference/reference_sql/sql.rst:100
#: ../doc/reference/reference_sql/sql.rst:105
#: ../doc/reference/reference_sql/sql.rst:198
#: ../doc/reference/reference_sql/sql.rst:514
#: ../doc/reference/reference_sql/sql.rst:519
#: ../doc/reference/reference_sql/sql.rst:563
#: ../doc/reference/reference_sql/sql.rst:568
#: ../doc/reference/reference_sql/sql.rst:618
#: ../doc/reference/reference_sql/sql.rst:623
#: ../doc/reference/reference_sql/sql.rst:660
#: ../doc/reference/reference_sql/sql.rst:665
#: ../doc/reference/reference_sql/sql.rst:736
#: ../doc/reference/reference_sql/sql.rst:741
#: ../doc/reference/reference_sql/sql.rst:777
#: ../doc/reference/reference_sql/sql.rst:782
#: ../doc/reference/reference_sql/sql.rst:849
#: ../doc/reference/reference_sql/sql.rst:854
#: ../doc/reference/reference_sql/sql.rst:925
#: ../doc/reference/reference_sql/sql.rst:930
#: ../doc/reference/reference_sql/sql.rst:977
#: ../doc/reference/reference_sql/sql.rst:982
#: ../doc/reference/reference_sql/sql.rst:1027
#: ../doc/reference/reference_sql/sql.rst:1032
#: ../doc/reference/reference_sql/sql.rst:1354
#: ../doc/reference/reference_sql/sql.rst:1359
#: ../doc/reference/reference_sql/sql.rst:1393
#: ../doc/reference/reference_sql/sql.rst:1398
#: ../doc/reference/reference_sql/sql.rst:1444
#: ../doc/reference/reference_sql/sql.rst:1449
#: ../doc/reference/reference_sql/sql.rst:1466
#: ../doc/reference/reference_sql/sql.rst:1471
#: ../doc/reference/reference_sql/sql.rst:1528
#: ../doc/reference/reference_sql/sql.rst:1533
#: ../doc/reference/reference_sql/sql.rst:1583
#: ../doc/reference/reference_sql/sql.rst:1588
#: ../doc/reference/reference_sql/sql.rst:1623
#: ../doc/reference/reference_sql/sql.rst:1628
#: ../doc/reference/reference_sql/sql.rst:1791
#: ../doc/reference/reference_sql/sql.rst:1796
#: ../doc/reference/reference_sql/sql.rst:1844
#: ../doc/reference/reference_sql/sql.rst:1849
#: ../doc/reference/reference_sql/sql.rst:1948
#: ../doc/reference/reference_sql/sql.rst:1953
#: ../doc/reference/reference_sql/sql.rst:1993
#: ../doc/reference/reference_sql/sql.rst:1998
#: ../doc/reference/reference_sql/sql.rst:2090
#: ../doc/reference/reference_sql/sql.rst:2095
#: ../doc/reference/reference_sql/sql.rst:2160
#: ../doc/reference/reference_sql/sql.rst:2165
#: ../doc/reference/reference_sql/sql.rst:2235
#: ../doc/reference/reference_sql/sql.rst:2240
#: ../doc/reference/reference_sql/sql.rst:2245
#: ../doc/reference/reference_sql/sql.rst:2250
#: ../doc/reference/reference_sql/sql.rst:2318
#: ../doc/reference/reference_sql/sql.rst:2323
#: ../doc/reference/reference_sql/sql.rst:2383
#: ../doc/reference/reference_sql/sql.rst:2388
#: ../doc/reference/reference_sql/sql.rst:2452
#: ../doc/reference/reference_sql/sql.rst:2457
#: ../doc/reference/reference_sql/sql.rst:2481
#: ../doc/reference/reference_sql/sql.rst:2486
#: ../doc/reference/reference_sql/sql.rst:2511
#: ../doc/reference/reference_sql/sql.rst:2516
#: ../doc/reference/reference_sql/sql.rst:2540
#: ../doc/reference/reference_sql/sql.rst:2545
msgid "|br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:24
msgid ""
"ALTER is used to change a table's name or to add new constraints or to "
"drop old constraints."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:27
#: ../doc/reference/reference_sql/sql.rst:144
#: ../doc/reference/reference_sql/sql.rst:542
#: ../doc/reference/reference_sql/sql.rst:594
#: ../doc/reference/reference_sql/sql.rst:639
#: ../doc/reference/reference_sql/sql.rst:712
#: ../doc/reference/reference_sql/sql.rst:821
#: ../doc/reference/reference_sql/sql.rst:885
#: ../doc/reference/reference_sql/sql.rst:956
#: ../doc/reference/reference_sql/sql.rst:992
#: ../doc/reference/reference_sql/sql.rst:1065
#: ../doc/reference/reference_sql/sql.rst:1374
#: ../doc/reference/reference_sql/sql.rst:1503
#: ../doc/reference/reference_sql/sql.rst:1560
#: ../doc/reference/reference_sql/sql.rst:1604
#: ../doc/reference/reference_sql/sql.rst:1681
#: ../doc/reference/reference_sql/sql.rst:1817
#: ../doc/reference/reference_sql/sql.rst:1901
#: ../doc/reference/reference_sql/sql.rst:1965
#: ../doc/reference/reference_sql/sql.rst:2007
#: ../doc/reference/reference_sql/sql.rst:2126
#: ../doc/reference/reference_sql/sql.rst:2559
#: ../doc/reference/reference_sql/sql.rst:2666
#: ../doc/reference/reference_sql/sql.rst:2708
#: ../doc/reference/reference_sql/sql.rst:2743
#, fuzzy
msgid "Examples:"
msgstr "Примеры"

#: ../doc/reference/reference_sql/sql.rst:29
msgid ""
"-- renaming a table:\n"
"ALTER TABLE t1 RENAME TO t2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:34
msgid ""
"For ``ALTER ... RENAME``, the *old-table* must exist, the *new-table* "
"must not exist."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:37
msgid ""
"-- adding a foreign-key constraint definition:\n"
"ALTER TABLE t1 ADD CONSTRAINT c FOREIGN KEY (s1) REFERENCES t1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:42
msgid ""
"For ``ALTER ... ADD CONSTRAINT``, the table must exist, table must be "
"empty, the constraint name must not already exist for the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:45
msgid ""
"It is not possible to say ``CREATE TABLE table_a ... REFERENCES table_b "
"...`` if table ``b`` does not exist yet. This is a situation where "
"``ALTER TABLE`` is handy -- users can ``CREATE TABLE table_a`` without "
"the foreign key, then ``CREATE TABLE table_b``, then ``ALTER TABLE "
"table_a ... REFERENCES table_b ...``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:50
msgid ""
"-- adding a primary-key constraint definition:\n"
"-- This is unusual because primary keys are created automatically\n"
"-- and it is illegal to have two primary keys for the same table.\n"
"-- However, it is possible to drop a primary-key index, and this\n"
"-- is a way to restore the primary key if that happens.\n"
"ALTER TABLE t1 ADD CONSTRAINT primary_key PRIMARY KEY (s1);\n"
"\n"
"-- adding a unique-constraint definition:\n"
"-- Alternatively, you can say CREATE UNIQUE INDEX unique_key ON t1 (s1);\n"
"ALTER TABLE t1 ADD CONSTRAINT unique_key UNIQUE (s1);\n"
"\n"
"-- Adding a check-constraint definition:\n"
"ALTER TABLE t1 ADD CONSTRAINT check_ CHECK (s1 > 0);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:68
msgid ""
"For ``ALTER ... DROP CONSTRAINT``, it is only legal to drop a named "
"constraint, and Tarantool only looks for names of foreign-key "
"constraints. (Tarantool generates the constraint names automatically if "
"the user does not provide them.)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:72
msgid ""
"To remove a unique constraint, use DROP INDEX, which will drop the "
"constraint as well."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:75
msgid ""
"-- dropping a constraint:\n"
"ALTER TABLE t1 DROP CONSTRAINT c;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:81
#: ../doc/reference/reference_sql/sql.rst:164
#: ../doc/reference/reference_sql/sql.rst:603
#: ../doc/reference/reference_sql/sql.rst:1330
#: ../doc/reference/reference_sql/sql.rst:1690
#: ../doc/reference/reference_sql/sql.rst:1830
#: ../doc/reference/reference_sql/sql.rst:1926
#: ../doc/reference/reference_sql/sql.rst:1976
#: ../doc/reference/reference_sql/sql.rst:2289
#, fuzzy
msgid "Limitations:"
msgstr "Администрирование"

#: ../doc/reference/reference_sql/sql.rst:83
msgid "It is not possible to add or drop a column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:84
msgid ""
"It is not possible to modify NOT NULL constraints or column properties "
"DEFAULT and data type. However, it is possible to modify them with "
"Tarantool/NOSQL, for example by calling :ref:`space_object:format() "
"<box_space-format>` with a different ``is_nullable`` value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:94
#, fuzzy
msgid "CREATE TABLE"
msgstr "Тип возвращаемого значения: таблица"

#: ../doc/reference/reference_sql/sql.rst:98
msgid ""
":samp:`CREATE TABLE [IF NOT EXISTS] {table-name} ((column-definition or "
"table-constraint list);`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:107
msgid "Create a new base table, usually called a \"table\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:111
msgid ""
"A table is a *base table* if it is created with CREATE TABLE and contains"
" data in persistent storage."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:114
msgid ""
"A table is a *viewed table*, or just \"view\", if it is created with "
"CREATE VIEW and gets its data from other views or from base tables."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:117
msgid ""
"The *table-name* must be an identifier which is valid according to the "
"rules for identifiers, and must not be the name of an already existing "
"base table or view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:120
msgid ""
"The *column-definition* or *table-constraint* list is a comma-separated "
"list of column definitions or table constraints."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:123
msgid ""
"A *table-element-list* must be a comma-separated list of table elements; "
"each table element may be either a column definition or a table "
"constraint definition."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:127
#: ../doc/reference/reference_sql/sql.rst:526
#: ../doc/reference/reference_sql/sql.rst:580
#: ../doc/reference/reference_sql/sql.rst:676
#: ../doc/reference/reference_sql/sql.rst:794
#: ../doc/reference/reference_sql/sql.rst:866
#: ../doc/reference/reference_sql/sql.rst:940
#: ../doc/reference/reference_sql/sql.rst:1042
#: ../doc/reference/reference_sql/sql.rst:1405
#, fuzzy
msgid "Rules:"
msgstr "true"

#: ../doc/reference/reference_sql/sql.rst:129
msgid ""
"A primary key is necessary; it can be specified with a table constraint "
"``PRIMARY KEY``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:131
msgid "There must be at least one column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:132
msgid ""
"When ``IF NOT EXISTS`` is specified, and there is already a table with "
"the same name, the statement is ignored."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:135
#: ../doc/reference/reference_sql/sql.rst:534
#: ../doc/reference/reference_sql/sql.rst:587
#: ../doc/reference/reference_sql/sql.rst:632
#: ../doc/reference/reference_sql/sql.rst:683
#: ../doc/reference/reference_sql/sql.rst:751
#: ../doc/reference/reference_sql/sql.rst:809
#: ../doc/reference/reference_sql/sql.rst:875
#: ../doc/reference/reference_sql/sql.rst:946
#: ../doc/reference/reference_sql/sql.rst:1059
#: ../doc/reference/reference_sql/sql.rst:1368
#: ../doc/reference/reference_sql/sql.rst:1412
#, fuzzy
msgid "Actions:"
msgstr "функция"

#: ../doc/reference/reference_sql/sql.rst:137
msgid ""
"Tarantool evaluates each column definition and *table-constraint*, and "
"returns an error if any of the rules is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:139
msgid "Tarantool makes a new definition in the schema."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:140
msgid ""
"Tarantool makes new indexes for ``PRIMARY KEY`` or ``UNIQUE`` "
"constraints. A unique index name is created automatically."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:142
msgid "Tarantool effectively executes a ``COMMIT`` statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:146
msgid ""
"-- the simplest form, with one column and one constraint:\n"
"CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
"\n"
"-- you can see the effect of the statement by querying\n"
"-- Tarantool system spaces:\n"
"SELECT * FROM \"_space\" WHERE \"name\" = 'T1';\n"
"SELECT * FROM \"_index\" JOIN \"_space\" ON \"_index\".\"id\" = "
"\"_space\".\"id\"\n"
"         WHERE \"_space\".\"name\" = 'T1';\n"
"\n"
"-- variation of the simplest form, with delimited identifiers\n"
"-- and an inline comment:\n"
"CREATE TABLE \"T1\" (\"S1\" INT /* synonym of INTEGER */, PRIMARY KEY "
"(\"S1\"));\n"
"\n"
"-- two columns, one named constraint\n"
"CREATE TABLE t1 (s1 INTEGER, s2 STRING, CONSTRAINT c1 PRIMARY KEY (s1, "
"s2));"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:166
#, fuzzy
msgid "The maximum number of columns is 2000."
msgstr "максимальное количество показываемых сегментов"

#: ../doc/reference/reference_sql/sql.rst:167
msgid ""
"The maximum length of a row depends on the :ref:`memtx_max_tuple_size "
"<cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size  "
"<cfg_storage-memtx_max_tuple_size>` configuration option."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:176
#, fuzzy
msgid "Column definition"
msgstr "Простые функции"

#: ../doc/reference/reference_sql/sql.rst:180
msgid ":samp:`column-name data-type [, column-constraint]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:182
msgid ""
"Define a column, which is a table-element used in a CREATE TABLE "
"statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:184
msgid ""
"The ``column-name`` must be an identifier which is valid according to the"
" rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:187
msgid "Each ``column-name`` must be unique within a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:193
msgid "Column definition -- data type"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:200
msgid "Every operand has a data type."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:202
msgid "For literals, the data type is usually determined by the format."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:204
msgid "For identifiers, the data type is usually determined by the definition."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:206
msgid ""
"The usual determination may change because of context or because of "
"explicit casting."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:208
msgid ""
"For some SQL data type names there are *aliases*. An alias may be used "
"for data definition. For example VARCHAR(5) and TEXT are aliases of "
"STRING and may appear in `CREATE TABLE table_name (column_name VARCHAR(5)"
" PRIMARY KEY);` but Tarantool, if asked, will report that the data type "
"of `column_name` is STRING."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:214
msgid ""
"For every SQL data type there is a corresponding NoSQL type, for example "
"an SQL STRING is stored in a NoSQL space as type = 'string'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:217
msgid ""
"To avoid confusion in this manual, all references to SQL data type names "
"are in upper case and all similar words which refer to NoSQL types or to "
"other kinds of object are in lower case, for example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:221
msgid "STRING is a data type name, but string is a general term;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:222
msgid "NUMBER is a data type name, but number is a general term."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:224
msgid ""
"Although it is common to say that a VARBINARY value is a \"binary "
"string\", this manual will not use that term and will instead say \"byte "
"sequence\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:227
msgid ""
"Here are all the SQL data types, their corresponding NoSQL types, their "
"aliases, and minimum / maximum literal examples."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:232
#: ../doc/reference/reference_sql/sql.rst:420
msgid "**Data types**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:240
#, fuzzy
msgid "SQL type"
msgstr "тип возвращаемого значения"

#: ../doc/reference/reference_sql/sql.rst:240
msgid "NoSQL type"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:240
#, fuzzy
msgid "Aliases"
msgstr "вызывает"

#: ../doc/reference/reference_sql/sql.rst:240
#, fuzzy
msgid "Minimum"
msgstr "num"

#: ../doc/reference/reference_sql/sql.rst:240
msgid "Maximum"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:242
#, fuzzy
msgid "BOOLEAN"
msgstr "boolean (логический)"

#: ../doc/reference/reference_sql/sql.rst:242
#, fuzzy
msgid "BOOL"
msgstr "bool (логический)"

#: ../doc/reference/reference_sql/sql.rst:242
#: ../doc/reference/reference_sql/sql.rst:255
#, fuzzy
msgid "FALSE"
msgstr "false"

#: ../doc/reference/reference_sql/sql.rst:242
#, fuzzy
msgid "TRUE"
msgstr "true"

#: ../doc/reference/reference_sql/sql.rst:244
#, fuzzy
msgid "INTEGER"
msgstr "целое число"

#: ../doc/reference/reference_sql/sql.rst:244
#, fuzzy
msgid "INT"
msgstr "целое число"

#: ../doc/reference/reference_sql/sql.rst:244
msgid "-9223372036854775808"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:244
#: ../doc/reference/reference_sql/sql.rst:246
msgid "18446744073709551615"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:246
msgid "UNSIGNED"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:246
msgid "unsigned"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:246
#: ../doc/reference/reference_sql/sql.rst:248
#: ../doc/reference/reference_sql/sql.rst:253
#: ../doc/reference/reference_sql/sql.rst:255
msgid "(none)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:246
msgid "0"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:248
#, fuzzy
msgid "NUMBER"
msgstr "число"

#: ../doc/reference/reference_sql/sql.rst:248
msgid "-1.79769e308"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:248
msgid "1.79769e308"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:250
#, fuzzy
msgid "STRING"
msgstr "строка"

#: ../doc/reference/reference_sql/sql.rst:250
msgid "TEXT, VARCHAR(n)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:250
#, fuzzy
msgid "''"
msgstr "'a'"

#: ../doc/reference/reference_sql/sql.rst:250
#, fuzzy
msgid "'many-characters'"
msgstr "управляющие символы,"

#: ../doc/reference/reference_sql/sql.rst:253
msgid "VARBINARY"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:253
msgid "varbinary"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:253
#, fuzzy
msgid "X''"
msgstr "'a'"

#: ../doc/reference/reference_sql/sql.rst:253
msgid "'X'many-hex-digits'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:255
msgid "SCALAR"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:255
msgid "X'many-hex-digits'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:258
msgid ""
"BOOLEAN values are FALSE, TRUE, and UNKNOWN (which is the same as NULL). "
"FALSE is less than TRUE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:261
msgid ""
"INTEGER values are numbers that do not contain decimal points and are not"
" expressed with exponential notation. The range of possible values is "
"between -2^63 and +2^64, or NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:265
msgid ""
"UNSIGNED values are numbers that do not contain decimal points and are "
"not expressed with exponential notation. The range of possible values is "
"between 0 and +2^64, or NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:269
msgid ""
"NUMBER values are numbers that do contain decimal points (for example "
"0.5) or are expressed with exponential notation (for example 5E-1). The "
"range of possible values is the same as for the IEEE 754 floating-point "
"standard, or NULL. Numbers outside the range of NUMBER literals may be "
"displayed as -inf or inf."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:275
msgid ""
"STRING values are any sequence of zero or more characters encoded with "
"UTF-8, or NULL. The possible character values are the same as for the "
"Unicode standard. Byte sequences which are not valid UTF-8 characters are"
" allowed but not recommended. STRING literal values are enclosed within "
"single quotes, for example 'literal'. If the VARCHAR alias is used for "
"column definition, it must include a maximum length, for example column_1"
" VARCHAR(40). However, the maximum length is ignored. The data-type may "
"be followed by ``[COLLATE collation-name]``. .. // see section COLLATE "
"clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:284
msgid ""
"VARBINARY values are any sequence of zero or more octets (bytes), or "
"NULL. VARBINARY literal values are expressed as X followed by pairs of "
"hexadecimal digits enclosed within single quotes, for example X'0044'. "
"VARBINARYs NoSQL equivalent is 'varbinary' but not character string -- "
"the MessagePack storage is MP_BIN (MsgPack binary)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:290
msgid ""
"SCALAR can be used for column definitions but the individual column "
"values have one of the preceding types -- BOOLEAN, INTEGER, UNSIGNED, "
"NUMBER, STRING, or VARBINARY. See more about SCALAR in the next section. "
"The data-type may be followed by ``[COLLATE collation-name]``. .. // see "
"section COLLATE clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:296
msgid ""
"Any value of any data type may be NULL. Ordinarily NULL will be cast to "
"the data type of any operand it is being compared to or to the data type "
"of the column it is in. If the data type of NULL cannot be determined "
"from context, it is BOOLEAN."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:303
msgid "Column definition -- the rules for the SCALAR data type"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:305
msgid ""
"SCALAR is a \"complex\" data type, unlike all the other data types which "
"are \"primitive\". Two column values in a SCALAR column can have two "
"different primitive data types."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:308
msgid ""
"Any item defined as SCALAR has an underlying primitive type. For example,"
" here:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:310
msgid ""
"CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (55),('41');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:315
msgid ""
"the underlying primitive type of the item in the first row is INTEGER "
"because literal 55 has data type INTEGER, and the underlying primitive "
"type in the second row is STRING (the data type of a literal is always "
"clear from its format)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:320
msgid ""
"An item's primitive type is far more important than its defined type. "
"Incidentally Tarantool might find the primitive type by looking at the "
"way MsgPack stores it, but that is an implementation detail."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:324
msgid ""
"A SCALAR definition may not include a maximum length, as there is no "
"suggested restriction."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:326
msgid ""
"A SCALAR definition may include a COLLATE clause, which affects any items"
" whose primitive data type is STRING. The default collation is "
"\"binary\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:328
msgid ""
"Some assignments are illegal when data types differ, but legal when the "
"target is a SCALAR item. For example ``UPDATE ... SET column1 = 'a'`` is "
"illegal if ``column1`` is defined as INTEGER, but is legal if ``column1``"
" is defined as SCALAR -- values which happen to be INTEGER will be "
"changed so their data type is STRING."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:333
msgid "There is no literal syntax which implies data type SCALAR."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:334
msgid ""
"TYPEOF(x) is never SCALAR, it is always the underlying data type. This is"
" true even if ``x`` is null (in that case the data type is BOOLEAN). In "
"fact there is no function that is guaranteed to return the defined data "
"type. For example, ``TYPEOF(CAST(1 AS SCALAR));`` returns INTEGER, not "
"SCALAR."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:338
msgid ""
"For any operation that requires implicit casting from an item defined as "
"SCALAR, the syntax is legal but the operation may fail at runtime. At "
"runtime, Tarantool detects the underlying primitive data type and applies"
" the rules for that. For example, if a definition is:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:343
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY, s2 INTEGER);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:347
msgid ""
"and within any row ``s1 = 'a'``, that is, its underlying primitive type "
"is STRING to indicate character strings, then ``UPDATE t SET s2 = s1;`` "
"is illegal. Tarantool usually does not know that in advance."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:350
msgid ""
"For any dyadic operation that requires implicit casting for comparison, "
"the syntax is legal and the operation will not fail at runtime. Take this"
" situation: comparison with a primitive type VARBINARY and a primitive "
"type STRING."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:355
msgid ""
"CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (X'41');\n"
"SELECT * FROM t WHERE s1 > 'a';"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:361
msgid ""
"The comparison is valid, because Tarantool knows the ordering of X'41' "
"and 'a' in Tarantool/NoSQL 'scalar'. This would be true even if ``s1`` "
"was not defined as SCALAR."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:364
msgid ""
"The result data type of min/max operation on a column defined as SCALAR "
"is the data type of the minimum/maximum operand, unless the result value "
"is NULL. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:368
msgid ""
"CREATE TABLE t (s1 INT, s2 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (1,X'44'),(2,11),(3,1E4),(4,'a');\n"
"SELECT MIN(s2), HEX(MAX(s2)) FROM t;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:374
msgid "The result is: ``- - [11, '44',]``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:376
msgid ""
"That is only possible with Tarantool/NoSQL scalar rules, but ``SELECT "
"SUM(s2)`` would not be legal because addition would in this case require "
"implicit casting from VARBINARY to integer, which is not sensible."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:379
msgid ""
"The result data type of a primitive combination is never SCALAR because "
"we in effect use TYPEOF(item) not the defined data type. (Here we use the"
" word \"combination\" in the way that the standard document uses it for "
"section \"Result of data type combinations\".) Therefore for ``MAX(1E308,"
" 'a', 0, X'00')`` the result is X'00'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:387
msgid "Column definition -- relation to NoSQL"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:389
msgid ""
"All the SQL data types correspond to :ref:`Tarantool/NoSQL types with the"
" same name <box_space-index_field_types>`. For example an SQL STRING is "
"stored in a NoSQL space as type = 'string'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:393
msgid ""
"Therefore specifying an SQL data type X determines that the storage will "
"be in a space with a format column saying that the NoSQL type is 'x'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:396
msgid "The rules for that NoSQL type are applicable to the SQL data type."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:398
msgid ""
"If two items have SQL data types that have the same underlying type, then"
" they are compatible for all assignment or comparison purposes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:401
msgid ""
"If two items have SQL data types that have different underlying types, "
"then the rules for explicit casts, or implicit (assignment) casts, or "
"implicit (comparison) casts, apply."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:405
msgid ""
"There is one floating-point value which is not handled by SQL: -nan is "
"seen as NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:407
msgid ""
"There are also some Tarantool/NoSQL data types which have no "
"corresponding SQL data types. For example, ``SELECT \"flags\" FROM "
"\"_space\";`` will return a column whose data type is 'map'. Such columns"
" can only be manipulated in SQL by invoking Lua functions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:414
msgid "Column definition -- column-constraint or default clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:416
msgid "The column-constraint or default clause may be as follows:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:426
msgid "Comment"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:428
#, fuzzy
msgid "NOT NULL"
msgstr "null"

#: ../doc/reference/reference_sql/sql.rst:428
msgid "means \"it is illegal to assign a NULL to this column\""
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:431
msgid "PRIMARY KEY"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:431
#: ../doc/reference/reference_sql/sql.rst:434
#: ../doc/reference/reference_sql/sql.rst:437
msgid "explained in the later section \"Constraint definition\""
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:434
msgid "UNIQUE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:437
msgid "CHECK (expression)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:440
msgid "DEFAULT expression"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:440
msgid ""
"means \"if INSERT does not assign to this column then assign expression "
"result to this column\" -- if there is no DEFAULT clause then DEFAULT "
"NULL is assumed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:447
msgid ""
"If column-constraint is PRIMARY KEY, this is a shorthand for a separate "
"table-constraint definition: \"PRIMARY KEY (column-name)\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:450
msgid ""
"If column-constraint is UNIQUE, this is a shorthand for a separate table-"
"constraint definition: \"UNIQUE (column-name)\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:453
msgid "Columns defined with PRIMARY KEY are automatically NOT NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:455
msgid ""
"To enforce some restrictions that Tarantool does not enforce "
"automatically, add CHECK clauses, like these:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:458
msgid ""
"CREATE TABLE t (\"smallint\" INTEGER PRIMARY KEY, CHECK (\"smallint\" <= "
"32767 AND \"smallint\" >= -32768));\n"
"CREATE TABLE t (\"shorttext\" CHAR(10) PRIMARY KEY, CHECK "
"(length(\"shorttext\") <= 10));"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:463
msgid "but this may cause inserts or updates to be slow."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:467
msgid "Column definition -- examples"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:469
msgid ""
"These are shown within CREATE TABLE statements. Data types may also "
"appear in CAST functions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:472
msgid ""
"-- the simple form with column-name and data-type\n"
"CREATE TABLE t (column1 INTEGER ...);\n"
"-- with column-name and data-type and column-constraint\n"
"CREATE TABLE t (column1 STRING PRIMARY KEY ...);\n"
"-- with column-name and data-type and collate-clause and two column-"
"constraints\n"
"CREATE TABLE t (column1 SCALAR COLLATE \"unicode\" ...);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:481
msgid ""
"-- with all possible data types and aliases\n"
"CREATE TABLE t\n"
"(column1 BOOLEAN, column2 BOOL,\n"
" column3 INT PRIMARY KEY, column4 INTEGER,\n"
" column4 NUMBER,\n"
" column7 STRING, column8 STRING COLLATE \"unicode\",\n"
" column9 TEXT, columna TEXT COLLATE \"unicode_sv_s1\",\n"
" columnb VARCHAR(0), columnc VARCHAR(100000) COLLATE \"binary\",\n"
" columnd VARBINARY,\n"
" columne SCALAR, columnf SCALAR COLLATE \"unicode_uk_s2\");"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:494
msgid ""
"-- with all possible column constraints and a default clause\n"
"CREATE TABLE t\n"
"(column1 INT PRIMARY KEY,\n"
" column2 INT UNIQUE,\n"
" column3 INT CHECK (column3 > column2),\n"
" column4 INT REFERENCES t,\n"
" column6 INT DEFAULT NULL);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:508
#, fuzzy
msgid "DROP TABLE"
msgstr "Тип возвращаемого значения: таблица"

#: ../doc/reference/reference_sql/sql.rst:512
msgid ":samp:`DROP TABLE [IF EXISTS] {table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:521
#, fuzzy
msgid "Drop a table."
msgstr "Тип возвращаемого значения: таблица"

#: ../doc/reference/reference_sql/sql.rst:523
msgid ""
"The *table-name* must identify a table that was created earlier with the "
":ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:528
msgid ""
"If there is a view that references the table, the drop will fail. Please "
"drop the referencing view with DROP VIEW first."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:530
msgid ""
"If there is a foreign key that references the table, the drop will fail. "
"Please drop the referencing constraint with :ref:`ALTER TABLE ... DROP "
"<sql_alter_table_drop_constraint>` first."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:536
msgid "Tarantool returns an error if the table does not exist."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:537
msgid "The table and all its data are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:538
msgid "All indexes for the table are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:539
msgid "All triggers for the table are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:540
#: ../doc/reference/reference_sql/sql.rst:592
#: ../doc/reference/reference_sql/sql.rst:637
#: ../doc/reference/reference_sql/sql.rst:689
#: ../doc/reference/reference_sql/sql.rst:756
#: ../doc/reference/reference_sql/sql.rst:1063
#: ../doc/reference/reference_sql/sql.rst:1372
msgid "Tarantool effectively executes a COMMIT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:544
msgid ""
"-- the simple case:\n"
"DROP TABLE t31;\n"
"-- with an IF EXISTS clause:\n"
"DROP TABLE IF EXISTS t31;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:551
msgid "See also: :ref:`DROP VIEW <sql_drop_view>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:557
msgid "CREATE VIEW"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:561
msgid ""
":samp:`CREATE VIEW [IF NOT EXISTS] {view-name} [(column-list)] AS "
"subquery;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:570
msgid "Create a new viewed table, usually called a \"view\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:572
msgid "The *view-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:574
msgid ""
"The optional *column-list* must be a comma-separated list of names of "
"columns in the view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:577
msgid ""
"The syntax of the subquery must be the same as the syntax of a SELECT "
"statement, or of a VALUES clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:582
msgid ""
"There must not already be a base table or view with the same name as "
"*view-name*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:584
msgid ""
"If *column-list* is specified, the number of columns in *column-list* "
"must be the same as the number of columns in the *select-list* of the "
"subquery."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:589
#: ../doc/reference/reference_sql/sql.rst:685
#: ../doc/reference/reference_sql/sql.rst:1061
msgid "Tarantool will throw an error if a rule is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:590
msgid ""
"Tarantool will create a new persistent object with *column-names* equal "
"to the names in the *column-list* or the names in the subquery's *select-"
"list*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:596
msgid ""
"-- the simple case:\n"
"CREATE VIEW v AS SELECT column1, column2 FROM t;\n"
"-- with a column-list:\n"
"CREATE VIEW v (a,b) AS SELECT column1, column2 FROM t;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:605
msgid ""
"It is not possible to insert or update or delete from a view, although "
"sometimes a possible substitution is to create an INSTEAD OF trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:612
msgid "DROP VIEW"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:616
msgid ":samp:`DROP VIEW [IF EXISTS] {view-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:625
#, fuzzy
msgid "Drop a view."
msgstr "Копирование файла"

#: ../doc/reference/reference_sql/sql.rst:627
msgid ""
"The *view-name* must identify a view that was created earlier with the "
":ref:`CREATE VIEW statement <sql_create_view>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:630
#: ../doc/reference/reference_sql/sql.rst:749
#: ../doc/reference/reference_sql/sql.rst:1366
msgid "Rules: none"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:634
msgid "Tarantool returns an error if the view does not exist."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:635
msgid "The view is dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:636
msgid "All triggers for the view are dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:641
msgid ""
"-- the simple case:\n"
"DROP VIEW v31;\n"
"-- with an IF EXISTS clause:\n"
"DROP VIEW IF EXISTS v31;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:648
msgid "See also: :ref:`DROP TABLE <sql_drop_table>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:654
msgid "CREATE INDEX"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:658
msgid ""
":samp:`CREATE [UNIQUE] INDEX [IF NOT EXISTS] {index-name} ON {table-name}"
" (column-list);`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:667
#, fuzzy
msgid "Create an index."
msgstr "Создание экземпляра iconv"

#: ../doc/reference/reference_sql/sql.rst:669
msgid "The *index-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:671
msgid "The *table-name* must refer to an existing table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:673
msgid ""
"The *column-list* must be a comma-separated list of names of columns in "
"the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:678
msgid ""
"There must not already be, for the same table, an index with the same "
"name as *index-name*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:680
msgid "An index name is local to the table the index is defined on."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:681
#, fuzzy
msgid "The maximum number of indexes per table is 128."
msgstr "максимальное количество показываемых сегментов"

#: ../doc/reference/reference_sql/sql.rst:686
msgid ""
"If the new index is UNIQUE, Tarantool will throw an error if any row "
"exists with columns that have duplicate values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:688
msgid "Tarantool will create a new index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:691
msgid "Automatic indexes:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:693
msgid ""
"Indexes may be created automatically for columns mentioned in the PRIMARY"
" KEY or UNIQUE clauses of a CREATE TABLE statement. If an index was "
"created automatically, then the *index-name* is based on four items:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:698
msgid ""
"``pk`` if this is for a PRIMARY KEY clause, ``unique`` if this is for a "
"UNIQUE clause;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:700
msgid "``_unnamed_``;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:701
#, fuzzy
msgid "the name of the table;"
msgstr "копия таблицы"

#: ../doc/reference/reference_sql/sql.rst:702
msgid ""
"``_`` and an ordinal number; the first index is 1, the second index is 2,"
" and so on."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:705
msgid ""
"For example, after ``CREATE TABLE t (s1 INT PRIMARY KEY, s2 INT, UNIQUE "
"(s2));`` there are two indexes named ``pk_unnamed_T_1`` and "
"``unique_unnamed_T_2``. You can confirm this by saying ``SELECT * FROM "
"\"_index\";`` which will list all indexes on all tables. There is no need"
" to say ``CREATE INDEX`` for columns that already have automatic indexes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:714
msgid ""
"-- the simple case\n"
"CREATE INDEX i ON t (column1);\n"
"-- with IF NOT EXISTS clause\n"
"CREATE INDEX IF NOT EXISTS i ON t (column1);\n"
"-- with UNIQUE specifier and more than one column\n"
"CREATE UNIQUE INDEX i ON t (column1, column2);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:723
msgid ""
"Dropping an automatic index created for a unique constraint will drop the"
" unique constraint as well."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:730
msgid "DROP INDEX"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:734
msgid ":samp:`DROP INDEX [IF EXISTS] index-name ON {table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:743
msgid ""
"The *index-name* must be the name of an existing index, which was created"
" with CREATE INDEX. Or, the *index-name* must be the name of an index "
"that was created automatically due to a PRIMARY KEY or UNIQUE clause in "
"the CREATE TABLE statement. To see what a table's indexes are, use "
"``PRAGMA index_list (table-name)``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:753
msgid ""
"Tarantool throws an error if the index does not exist, or is an "
"automatically created index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:755
msgid "Tarantool will drop the index."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:760
msgid ""
"-- the simplest form:\n"
"DROP INDEX i ON t;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:769
#, fuzzy
msgid "INSERT"
msgstr "целое число"

#: ../doc/reference/reference_sql/sql.rst:773
msgid ""
":samp:`INSERT INTO {table-name} [(column-list)] VALUES (expression-list) "
"[, (expression-list)];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:774
msgid ":samp:`INSERT INTO {table-name} [(column-list)]  select-statement;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:775
#, fuzzy
msgid ":samp:`INSERT INTO {table-name} DEFAULT VALUES;`"
msgstr ":samp:`db = {имя-базы-данных}` -- строка, по умолчанию пустая"

#: ../doc/reference/reference_sql/sql.rst:784
msgid "Insert one or more new rows into a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:786
msgid ""
"The *table-name* must be a name of a table defined earlier with CREATE "
"TABLE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:788
msgid ""
"The optional *column-list* must be a comma-separated list of names of "
"columns in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:791
msgid ""
"The *expression-list* must be a comma-separated list of expressions; each"
" expression may contain literals and operators and subqueries and "
"function invocations."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:796
msgid "The values in the *expression-list* are evaluated from left to right."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:797
msgid ""
"The order of the values in the *expression-list* must correspond to the "
"order of the columns in the table, or (if a *column-list* is specified) "
"to the order of the columns in the *column-list*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:800
#: ../doc/reference/reference_sql/sql.rst:869
msgid ""
"The data type of the value should correspond to the data type of the "
"column, that is, the data type that was specified with CREATE TABLE."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:802
msgid ""
"If a *column-list* is not specified, then the number of expressions must "
"be the same as the number of columns in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:804
msgid ""
"If a *column-list* is specified, then some columns may be omitted; "
"omitted columns will get default values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:806
msgid ""
"The parenthesized *expression-list* may be repeated -- ``(expression-list"
"),(expression-list),...`` -- for multiple rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:811
msgid ""
"Tarantool evaluates each expression in *expression-list*, and returns an "
"error if any of the rules is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:813
msgid ""
"Tarantool creates zero or more new rows containing values based on the "
"values in the VALUES list or based on the results of the *select-"
"expression* or based on the default values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:816
msgid ""
"Tarantool executes constraint checks and trigger actions and the actual "
"insertion."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:817
msgid "Tarantool inserts values into the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:823
msgid ""
"-- the simplest form:\n"
"INSERT INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"INSERT INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"INSERT INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"INSERT INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:835
msgid "See also: :ref:`REPLACE statement <sql_replace>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:841
#, fuzzy
msgid "UPDATE"
msgstr "шаблон"

#: ../doc/reference/reference_sql/sql.rst:845
msgid ""
":samp:`UPDATE {table-name} SET column-name = expression [, column-name = "
"expression ...] [WHERE search-condition];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:856
msgid "Update zero or more existing rows in a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:858
#: ../doc/reference/reference_sql/sql.rst:934
msgid ""
"The *table-name* must be a name of a table defined earlier with CREATE "
"TABLE or CREATE VIEW."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:861
msgid "The *column-name* must be an updatable column in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:863
msgid ""
"The *expression* may contain literals and operators and subqueries and "
"function invocations and column names."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:868
msgid "The values in the SET clause are evaluated from left to right."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:871
msgid ""
"If a *search-condition* is not specified, then all rows in the table will"
" be updated; otherwise only those rows which match the *search-condition*"
" will be updated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:877
msgid ""
"Tarantool evaluates each expression in the SET clause, and returns an "
"error if any of the rules is violated. For each row that is found by the "
"WHERE clause, a temporary new row is formed based on the original "
"contents and the modifications caused by the SET clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:881
msgid ""
"Tarantool executes constraint checks and trigger actions and the actual "
"update."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:887
msgid ""
"-- the simplest form:\n"
"UPDATE t SET column1 = 1;\n"
"-- with more than one assignment in the SET clause:\n"
"UPDATE t SET column1 = 1, column2 = 2;\n"
"-- with a WHERE clause:\n"
"UPDATE t SET column1 = 5 WHERE column2 = 6;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:896
msgid "Special cases:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:898
msgid "It is legal to say SET (list of columns) = (list of values). For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:900
msgid "UPDATE t SET (column1, column2, column3) = (1,2,3);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:904
msgid "It is not legal to assign to a column more than once. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:906
msgid ""
"INSERT INTO t (column1) VALUES (0);\n"
"UPDATE t SET column1 = column1 + 1, column1 = column1 + 1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:911
msgid "The result is an error: \"duplicate column name\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:913
msgid "It is not legal to assign to a primary-key column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:919
msgid "DELETE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:923
msgid ":samp:`DELETE FROM {table-name} [WHERE search-condition];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:932
msgid "Delete zero or more existing rows in a table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:937
msgid ""
"The *search-condition* may contain literals and operators and subqueries "
"and function invocations and column names."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:942
msgid ""
"If a search-condition is not specified, then all rows in the table will "
"be deleted; otherwise only those rows which match the *search-condition* "
"will be deleted."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:948
msgid ""
"Tarantool evaluates each expression in the *search-condition*, and "
"returns an error if any of the rules is violated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:950
msgid "Tarantool finds the set of rows that are to be deleted."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:951
msgid ""
"Tarantool executes constraint checks and trigger actions and the actual "
"deletion."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:952
msgid "Tarantool deletes the set of matching rows from the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:958
msgid ""
"-- the simplest form:\n"
"DELETE FROM t;\n"
"-- with a WHERE clause:\n"
"DELETE FROM t WHERE column2 = 6;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:969
msgid "REPLACE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:973
msgid ""
":samp:`REPLACE INTO {table-name} [(column-list)] VALUES (expression-list)"
" [, (expression-list)];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:974
msgid ":samp:`REPLACE INTO {table-name} [(column-list)] select-statement;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:975
#, fuzzy
msgid ":samp:`REPLACE INTO {table-name} DEFAULT VALUES;`"
msgstr ":samp:`db = {имя-базы-данных}` -- строка, по умолчанию пустая"

#: ../doc/reference/reference_sql/sql.rst:984
msgid "Insert one or more new rows into a table, or update existing rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:986
msgid ""
"If a row already exists (as determined by the primary key or any unique "
"key), then the action is delete + insert, and the rules are the same as "
"for a DELETE statement followed by an INSERT statement. Otherwise the "
"action is insert, and the rules are the same as for the INSERT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:994
msgid ""
"-- the simplest form:\n"
"REPLACE INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"REPLACE INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"REPLACE INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"REPLACE INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1005
msgid ""
"See also: :ref:`INSERT Statement <sql_insert>`, :ref:`UPDATE Statement "
"<sql_update>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1013
msgid "CREATE TRIGGER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1017
msgid ""
":samp:`CREATE TRIGGER [IF NOT EXISTS] {trigger-name}` |br| "
":samp:`BEFORE|AFTER|INSTEAD OF` |br| :samp:`INSERT|UPDATE|DELETE ON "
"{table-name}` |br| :samp:`FOR EACH ROW` |br| :samp:`[WHEN (search-"
"condition)]` |br| :samp:`BEGIN` |br| :samp:`update-statement | insert-"
"statement | delete-statement | select-statement;` |br| :samp:`[update-"
"statement | insert-statement | delete-statement | select-statement; ...]`"
" |br| :samp:`END;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1034
msgid "The *trigger-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1036
msgid ""
"If the trigger action time is BEFORE or AFTER, then the *table-name* must"
" refer to an existing base table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1039
msgid ""
"If the trigger action time is INSTEAD OF, then the *table-name* must "
"refer to an existing view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1044
msgid "There must not already be a trigger with the same name as *trigger-name*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1045
msgid "Triggers on different tables or views share the same namespace."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1046
msgid ""
"The statements between BEGIN and END should not refer to the *table-name*"
" mentioned in the ON clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1048
msgid ""
"The statements between BEGIN and END should not contain an INDEXED BY "
"clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1050
msgid ""
"SQL triggers are not fired upon Tarantool/NoSQL requests. This will "
"change in version 2.2."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1053
msgid ""
"On a replica, effects of trigger execution are applied, and the SQL "
"triggers themselves are not fired upon replication events."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1056
msgid ""
"NoSQL triggers are fired both on replica and master, thus if you have a "
"NoSQL trigger on replica, it is fired when applying effects of an SQL "
"trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1062
msgid "Tarantool will create a new trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1067
msgid ""
"-- the simple case:\n"
"CREATE TRIGGER delete_if_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with IF NOT EXISTS clause:\n"
"CREATE TRIGGER IF NOT EXISTS delete_if_insert BEFORE INSERT ON stores FOR"
" EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with FOR EACH ROW and WHEN clauses:\n"
"CREATE TRIGGER delete_if_insert BEFORE INSERT ON stores FOR EACH ROW WHEN"
" a=5\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with multiple statements between BEGIN and END:\n"
"CREATE TRIGGER delete_if_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; INSERT INTO inventories VALUES (1); END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1086
msgid "Trigger extra clauses"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1088
msgid ":samp:`UPDATE OF column-list`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1090
msgid ""
"After BEFORE|AFTER UPDATE it is optional to add ``OF column-list``. If "
"any of the columns in *column-list* is affected at the time the row is "
"processed, then the trigger will be activated for that row. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1094
msgid ""
"CREATE TRIGGER trigger_on_table1\n"
" BEFORE UPDATE  OF column1, column2 ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"UPDATE table1 SET column3 = column3 + 1; -- Trigger will not be activated"
"\n"
"UPDATE table1 SET column2 = column2 + 0; -- Trigger will be activated"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1103
msgid ":samp:`WHEN`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1105
msgid ""
"After *table-name* FOR EACH ROW it is optional to add [``WHEN "
"expression``]. If the expression is true at the time the row is "
"processed, only then the trigger will be activated for that row. For "
"example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1109
msgid ""
"CREATE TRIGGER trigger_on_table1 BEFORE UPDATE ON table1 FOR EACH ROW\n"
" WHEN (SELECT COUNT(*) FROM table1) > 1\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1115
msgid ""
"This trigger will not be activated unless there is more than one row in "
"``table1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1118
msgid ":samp:`OLD and NEW`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1120
msgid ""
"The keywords OLD and NEW have special meaning in the context of trigger "
"action:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1122
msgid "OLD.column-name refers to the value of *column-name* before the change."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1123
msgid "NEW.column-name refers to the value of *column-name* after the change."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1127
msgid ""
"CREATE TABLE table1 (column1 VARCHAR(15), column2 INT PRIMARY KEY);\n"
"CREATE TABLE table2 (column1 VARCHAR(15), column2 VARCHAR(15), column3 "
"INT PRIMARY KEY);\n"
"INSERT INTO table1 VALUES ('old value', 1);\n"
"INSERT INTO table2 VALUES ('', '', 1);\n"
"CREATE TRIGGER trigger_on_table1 BEFORE UPDATE ON table1 FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = old.column1, column2 = new.column1; "
"END;\n"
"UPDATE table1 SET column1 = 'new value';\n"
"SELECT * FROM table2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1138
msgid ""
"At the beginning of the UPDATE for the single row of ``table1``, the "
"value in ``column1`` is 'old value' -- so that is what is seen as "
"``old.column1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1141
msgid ""
"At the end of the UPDATE for the single row of ``table1``, the value in "
"``column1`` is 'new value' -- so that is what is seen as ``new.column1``."
" (OLD and NEW are qualifiers for ``table1``, not ``table2.``)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1145
msgid ""
"Therefore, ``SELECT * FROM table2;`` returns ``['old value', 'new "
"value']``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1147
msgid "``OLD.column-name`` does not exist for an INSERT trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1149
msgid "``NEW.column-name`` does not exist for a DELETE trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1151
msgid "OLD and NEW are read-only; you cannot change their values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1153
msgid "Deprecated or illegal statements:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1155
msgid ""
"It is legal for the trigger action to include a SELECT statement or a "
"REPLACE statement, but not recommended."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1158
msgid ""
"It is illegal for the trigger action to include a qualified column "
"reference other than ``OLD.column-name`` or ``NEW.column-name``. For "
"example, ``CREATE TRIGGER ... BEGIN UPDATE table1 SET table1.column1=5; "
"END;`` is illegal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1163
msgid ""
"It is illegal for the trigger action to include statements that include a"
" WITH clause, a DEFAULT VALUES clause, or an INDEXED BY clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1166
msgid ""
"It is usually not a good idea to have a trigger on ``table1`` which "
"causes a change on ``table2``, and at the same time have a trigger on "
"``table2`` which causes a change on ``table1``. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1170
msgid ""
"CREATE TRIGGER trigger_on_table1\n"
" BEFORE UPDATE ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"CREATE TRIGGER trigger_on_table2\n"
" BEFORE UPDATE ON table2\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table1 SET column1 = column1 + 1; END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1181
msgid ""
"Luckily ``UPDATE table1 ...`` will not cause an infinite loop, because "
"Tarantool recognizes when it has already updated so it will stop. "
"However, not every DBMS acts this way."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1189
msgid "Trigger activation"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1191
msgid "These are remarks concerning trigger activation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1193
#, fuzzy
msgid "Standard terminology:"
msgstr "Для начала введем терминологию:"

#: ../doc/reference/reference_sql/sql.rst:1195
msgid "\"trigger action time\" = BEFORE or AFTER or INSTEAD OF"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1196
msgid "\"trigger event\" = INSERT or DELETE or UPDATE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1197
msgid "\"triggered statement\" = BEGIN ... INSERT|DELETE|UPDATE ... END"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1198
msgid "\"triggered when clause\" = WHEN (search condition)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1199
msgid "\"activate\" = execute a triggered statement"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1200
msgid "some vendors use the word \"fire\" instead of \"activate\""
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1202
msgid ""
"If there is more than one trigger for the same trigger event, Tarantool "
"may execute the triggers in any order."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1205
msgid ""
"It is possible for a triggered statement to cause activation of another "
"triggered statement. For example, this is legal:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1208
msgid ""
"CREATE TRIGGER on_t1 BEFORE DELETE ON t1 BEGIN DELETE FROM t2; END;\n"
"CREATE TRIGGER on_t2 BEFORE DELETE ON t2 BEGIN DELETE FROM t3; END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1213
msgid ""
"Activation occurs FOR EACH ROW, not FOR EACH STATEMENT. Therefore, if no "
"rows are candidates for insert or update or delete, then no triggers are "
"activated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1216
msgid "The BEFORE trigger is activated even if the trigger event fails."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1218
msgid ""
"If an UPDATE trigger event does not make a change, the trigger is "
"activated anyway. For example, if row 1 ``column1`` contains 'a', and the"
" trigger event is ``UPDATE ... SET column1 = 'a';``, the trigger is "
"activated."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1222
msgid ""
"The triggered statement may refer to a function: ``RAISE(FAIL, error-"
"message)``. If a triggered statement invokes a ``RAISE(FAIL, error-"
"message)`` function, or if a triggered statement causes an error, then "
"statement execution stops immediately."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1228
msgid ""
"The triggered statement may refer to column values within the rows being "
"changed. in this case:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1231
msgid ""
"The row \"as of before\" the change is called the \"old\" row (which "
"makes sense only for UPDATE and DELETE statements)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1233
msgid ""
"The row \"as of after\" the change is called the \"new\" row (which makes"
" sense only for UPDATE and INSERT statements)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1236
msgid ""
"This example shows how an INSERT can be done to a view by referring to "
"the \"new\" row:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1239
msgid ""
"CREATE TABLE t (s1 INT PRIMARY KEY, s2 INT);\n"
"CREATE VIEW v AS SELECT s1, s2 FROM t;\n"
"CREATE TRIGGER tv INSTEAD OF INSERT ON v\n"
"  FOR EACH ROW\n"
"  BEGIN INSERT INTO t VALUES (new.s1, new.s2); END;\n"
"INSERT INTO v VALUES (1,2);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1248
msgid ""
"Ordinarily saying ``INSERT INTO view_name ...`` is illegal in Tarantool, "
"so this is a workaround."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1251
msgid ""
"It is possible to generalize this so that all data-change statements on "
"views will change the base tables, provided that the view contains all "
"the columns of the base table, and provided that the triggers refer to "
"those columns when necessary, as in this example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1256
msgid ""
"CREATE TABLE base_table (primary_key_column INT PRIMARY KEY, value_column"
" INT);\n"
"CREATE VIEW viewed_table AS SELECT primary_key_column, value_column FROM "
"base_table;\n"
"CREATE TRIGGER viewed_insert INSTEAD OF INSERT ON viewed_table FOR EACH "
"ROW\n"
"  BEGIN\n"
"    INSERT INTO base_table VALUES (new.primary_key_column, "
"new.value_column);\n"
"  END;\n"
"CREATE TRIGGER viewed_update INSTEAD OF UPDATE ON viewed_table FOR EACH "
"ROW\n"
"  BEGIN\n"
"    UPDATE base_table\n"
"    SET primary_key_column = new.primary_key_column, value_column = "
"new.value_column\n"
"    WHERE primary_key_column = old.primary_key_column;\n"
"  END;\n"
"CREATE TRIGGER viewed_delete INSTEAD OF DELETE ON viewed_table FOR EACH "
"ROW\n"
"  BEGIN\n"
"    DELETE FROM base_table WHERE primary_key_column = "
"old.primary_key_column;\n"
"  END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1275
msgid ""
"When INSERT or UPDATE or DELETE occurs for table ``X``, Tarantool usually"
" operates in this order (a basic scheme):"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1278
msgid ""
"For each row\n"
"  Perform constraint checks\n"
"  For each BEFORE trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the trigger's BEGIN|END block.\n"
"  Insert or update or delete the row in table X.\n"
"  Perform more constraint checks\n"
"  For each AFTER trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the trigger's BEGIN|END block."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1293
msgid ""
"However, Tarantool does not guarantee execution order when there are "
"multiple constraints, or multiple triggers for the same event (including "
"NoSQL ``on_replace`` triggers or SQL INSTEAD OF triggers that affect a "
"view of table ``X``)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1298
msgid "The maximum number of trigger activations per statement is 32."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1304
#, fuzzy
msgid "INSTEAD OF triggers"
msgstr "Создание подключения"

#: ../doc/reference/reference_sql/sql.rst:1306
msgid ""
"A trigger which is created with the clause |br| :samp:`INSTEAD OF "
"{INSERT|UPDATE|DELETE} ON {view-name}` |br| is an INSTEAD OF trigger. For"
" each affected row, the trigger action is performed \"instead of\" the "
"INSERT or UPDATE or DELETE statement that causes trigger activation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1312
msgid ""
"For example, ordinarily it is illegal to INSERT rows in a view, but it is"
" legal to create a trigger which intercepts attempts to INSERT, and puts "
"rows in the underlying base table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1316
msgid ""
"CREATE TABLE t1 (column1 INT PRIMARY KEY, column2 INT);\n"
"CREATE VIEW v1 AS SELECT column1, column2 FROM t1;\n"
"CREATE TRIGGER t1 INSTEAD OF INSERT ON v1 FOR EACH ROW BEGIN\n"
" INSERT INTO t1 VALUES (NEW.column1, NEW.column2); END;\n"
"INSERT INTO v1 VALUES (1, 1);\n"
"-- ... The result will be: table t1 will contain a new row."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1325
msgid ""
"INSTEAD OF triggers are only legal for views, while BEFORE or AFTER "
"triggers are not legal for views."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1328
msgid "It is legal to create INSTEAD OF triggers with triggered WHEN clauses."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1332
msgid ""
"It is legal to create INSTEAD OF triggers with UPDATE OF *column-list* "
"clauses, but they are not standard SQL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1337
msgid ""
"CREATE TRIGGER et1\n"
"  INSTEAD OF UPDATE OF column2,column1 ON ev1\n"
"  FOR EACH ROW BEGIN\n"
"  INSERT INTO et2 VALUES (NEW.column1, NEW.column2); END;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1348
msgid "DROP TRIGGER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1352
msgid ":samp:`DROP TRIGGER [IF EXISTS] {trigger-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1361
msgid "Drop a trigger."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1363
msgid ""
"The *trigger-name* must identify a trigger that was created earlier with "
"the CREATE TRIGGER statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1370
msgid "Tarantool returns an error if the trigger does not exist."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1371
msgid "The trigger is dropped."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1376
msgid ""
"-- the simple case:\n"
"DROP TRIGGER tr;\n"
"-- with an IF EXISTS clause:\n"
"DROP TRIGGER IF EXISTS tr;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1387
#, fuzzy
msgid "TRUNCATE"
msgstr "Структура"

#: ../doc/reference/reference_sql/sql.rst:1391
msgid ":samp:`TRUNCATE TABLE {table-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1400
msgid "Remove all rows in the table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1402
msgid ""
"TRUNCATE is considered to be a schema-change rather than a data-change "
"statement, so it does not work within transactions (it cannot be rolled "
"back)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1407
msgid "It is illegal to truncate a table which is referenced by a foreign key."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1408
msgid ""
"It is illegal to truncate a table which is also a system space, such as "
"``_space``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1410
msgid "The table must be a base table rather than a view."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1414
msgid ""
"All rows in the table are removed. Usually this is faster than ``DELETE "
"FROM table-name;``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1416
msgid ""
"If the table has an autoincrement primary key, its sequence is reset to "
"zero."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1417
#, fuzzy
msgid "There is no effect for any triggers associated with the table."
msgstr "функция, которая будет связана с файбером"

#: ../doc/reference/reference_sql/sql.rst:1418
msgid "There is no effect on the counts for the ``row_count()`` function."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1419
msgid ""
"Only one action is written to the write-ahead log (with ``DELETE FROM "
"table-name;`` there would be one action for each deleted row)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1425
#, fuzzy
msgid "TRUNCATE TABLE t;"
msgstr "Тип возвращаемого значения: таблица"

#: ../doc/reference/reference_sql/sql.rst:1433
msgid "SELECT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1437
msgid ""
":samp:`SELECT [ALL|DISTINCT] select-list [from clause] [where clause] "
"[group-by clause] [having clause] [order-by clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1451
#, fuzzy
msgid "Select zero or more rows."
msgstr "Выбор одного или нескольких кортежей"

#: ../doc/reference/reference_sql/sql.rst:1453
msgid ""
"The clauses of the SELECT statement are discussed in the following five "
"sections."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1459
msgid "Select-list"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1463
msgid ":samp:`select-list-column [, select-list-column ...] select-list-column:`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1473
msgid ""
"Define what will be in a result set; this is a clause in a SELECT "
"statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1475
msgid ""
"The *select-list* is a comma-delimited list of expressions, or ``*`` "
"(asterisk). An expression can have an alias provided with ``[AS [column-"
"name]]`` clause."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1478
msgid ""
"The ``*`` \"asterisk\" shorthand is valid if and only if the SELECT "
"statement also contains a FROM clause which specifies the table or tables"
" (details about the FROM clause are in the next section). The simple form"
" is ``*`` which means \"all columns\" -- for example, if the select is "
"done for a table which contains three columns ``s1`` ``s2`` ``s3``, then "
"``SELECT * ...`` is equivalent to ``SELECT s1, s2, s3 ...``. The "
"qualified form is ``table-name.*`` which means \"all columns in the "
"specified table\", which again must be a result of the FROM clause -- for"
" example, if the table is named ``table1``, then ``table1.*`` is "
"equivalent to a list of the columns of ``table1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1490
msgid ""
"The ``[AS [column-name]]`` clause determines the column name. The column "
"name is useful for two reasons:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1493
msgid "in a tabular display, the column names are the headings"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1494
msgid ""
"if the results of the SELECT are used in ``CREATE TABLE new-table-name "
"... AS SELECT select-list ...``, then the column names in the new table "
"will be the column names in the *select-list*."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1498
msgid ""
"If ``[AS [column-name]]`` is missing, Tarantool makes a name equal to the"
" expression, for example ``SELECT 5*88`` will cause the column name to be"
" ``5*88``, but such names may be ambiguous or illegal in other contexts, "
"so it is better to say, for example, ``SELECT 5 * 88 AS column1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1505
msgid ""
"-- the simple form:\n"
"SELECT 5;\n"
"-- with multiple expressions including operators:\n"
"SELECT 1, 2 * 2, 'Three' || 'Four';\n"
"-- with [[AS] column-name] clause:\n"
"SELECT 5 AS column1;\n"
"-- * which must be eventually followed by a FROM clause:\n"
"SELECT * FROM table1;\n"
"-- as a list:\n"
"SELECT 1 AS a, 2 AS b, table1.* FROM table1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1522
msgid "FROM clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1526
msgid ":samp:`FROM table-reference [, table-reference ...]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1535
msgid "Specify the table or tables for the source of a SELECT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1537
msgid ""
"The *table-reference* must be a name of an existing table, or a subquery,"
" or a joined table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1540
msgid "A joined table looks like this:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1542
msgid ""
":samp:`table-reference-or-joined-table join-operator table-reference-or-"
"joined-table [join-specification]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1544
msgid ""
"A *join-operator* must be any of `the standard types "
"<https://en.wikipedia.org/wiki/Join_(SQL)>`_:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1547
msgid "[NATURAL] LEFT [OUTER] JOIN,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1548
msgid "[NATURAL] INNER JOIN, or"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1549
msgid "CROSS JOIN"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1551
msgid "A *join-specification* must be any of:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1553
msgid "ON expression, or"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1554
msgid "USING (column-name [, column-name ...])"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1556
msgid "Parentheses are allowed, and ``[[AS] correlation-name]`` is allowed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1558
#, fuzzy
msgid "The maximum number of joins in a FROM clause is 64."
msgstr ""
"Максимальное количество байтов оперативной памяти, которые использует "
"vinyl."

#: ../doc/reference/reference_sql/sql.rst:1562
msgid ""
"-- the simplest form:\n"
"SELECT * FROM t;\n"
"-- with two tables, making a Cartesian join:\n"
"SELECT * FROM t1, t2;\n"
"-- with one table joined to itself, requiring correlation names:\n"
"SELECT a.*, b.* FROM t1 AS a, t1 AS b;\n"
"-- with a left outer join:\n"
"SELECT * FROM t1 LEFT JOIN t2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1577
msgid "WHERE clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1581
msgid ":samp:`WHERE condition;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1590
msgid ""
"Specify the condition for filtering rows from a table; this is a clause "
"in a SELECT or UPDATE or DELETE statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1593
msgid ""
"The condition may contain any expression that returns a BOOLEAN (TRUE or "
"FALSE or UNKNOWN) value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1596
#: ../doc/reference/reference_sql/sql.rst:1809
msgid "For each row in the table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1598
#: ../doc/reference/reference_sql/sql.rst:1811
msgid "if the condition is true, then the row is kept;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1599
#: ../doc/reference/reference_sql/sql.rst:1812
msgid "if the condition is false or unknown, then the row is ignored."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1601
msgid ""
"In effect, WHERE condition takes a table with n rows and returns a table "
"with n or fewer rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1606
msgid ""
"-- with a simple condition:\n"
"SELECT 1 FROM t WHERE column1 = 5;\n"
"-- with a condition that contains AND and OR and parentheses:\n"
"SELECT 1 FROM t WHERE column1 = 5 AND (x > 1 OR y < 1);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1617
msgid "GROUP BY clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1621
msgid ":samp:`GROUP BY expression [, expression ...]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1630
msgid "Make a grouped table; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1632
msgid ""
"The expressions should be column names in the table, and each column "
"should be specified only once."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1635
msgid ""
"In effect, GROUP BY clause takes a table with rows that may have matching"
" values, combines rows that have matching values into single rows, and "
"returns a table which, because it is the result of GROUP BY, is called a "
"grouped table."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1640
msgid "Thus, if the input is a table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1642
msgid ""
"a    b      c\n"
"-    -      -\n"
"1    'a'   'b\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'\n"
"1    'b'   'b'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1652
msgid "then ``GROUP BY a, b`` will produce a grouped table:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1654
msgid ""
"a    b      c\n"
"-    -      -\n"
"1    'a'   'b'\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1663
msgid ""
"The rows where column ``a`` and column ``b`` have the same value have "
"been merged; column ``c`` has been preserved but its value should not be "
"depended on -- if the rows were not all 'b', Tarantool could pick any "
"value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1667
msgid ""
"It is useful to envisage a grouped table as having hidden extra columns "
"for the aggregation of the values, for example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1670
msgid ""
"a    b      c    COUNT(a) SUM(a) MIN(c)\n"
"-    -      -    -------- ------ ------\n"
"1    'a'  'b'         2      2    'b'\n"
"1    'b'  'b'         1      1    'b'\n"
"2    'a'  'b'         1      2    'b'\n"
"     'a'  'b'         1      3    'b'"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1679
msgid ""
"These extra columns are what :ref:`aggregate functions <sql_aggregate>` "
"are for."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1683
msgid ""
"-- with a single column:\n"
"SELECT 1 FROM t GROUP BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t GROUP BY column1, column2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1692
msgid "``SELECT s1,s2 FROM t GROUP BY s1;`` is legal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1693
msgid "``SELECT s1 AS q FROM t GROUP BY q;`` is legal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1694
msgid "``SELECT s1 FROM t GROUP by 1;`` is legal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1702
#, fuzzy
msgid "Aggregate functions"
msgstr "функция"

#: ../doc/reference/reference_sql/sql.rst:1706
#: ../doc/reference/reference_sql/sql.rst:2592
msgid ":samp:`function-name (one or more expressions)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1708
msgid ""
"Apply a built-in aggregate function to one or more expressions and return"
" a scalar value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1711
msgid ""
"Aggregate functions are only legal in certain clauses of SELECT for "
"grouped tables. (A table is a grouped table if a GROUP BY clause is "
"present.) Also, if an aggregate function is used in a select-list and "
"GROUP BY clause is omitted, then Tarantool assumes ``SELECT ... GROUP BY "
"[all columns];``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1718
msgid "NULLs are ignored for all aggregate functions except COUNT(*)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1725
msgid "``AVG([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1723
#, fuzzy
msgid "Return the average value of expression."
msgstr "Возврат шестнадцатеричного значения введенной строки."

#: ../doc/reference/reference_sql/sql.rst:1725
msgid "Example: :samp:`AVG({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1732
msgid "``COUNT([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1730
#, fuzzy
msgid "Return the number of occurrences of expression."
msgstr "Возврат числа секунд с начала отсчета."

#: ../doc/reference/reference_sql/sql.rst:1732
msgid "Example: :samp:`COUNT({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1739
#, fuzzy
msgid "``COUNT(*)``"
msgstr "``y:unpack()``"

#: ../doc/reference/reference_sql/sql.rst:1737
#, fuzzy
msgid "Return the number of occurrences of a row."
msgstr "Возврат количества сегментов, расположенных в хранилище."

#: ../doc/reference/reference_sql/sql.rst:1739
msgid "Example: :samp:`COUNT(*)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1749
msgid "``GROUP_CONCAT(expression-1 [, expression-2])``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1744
msgid ""
"Return a list of *expression-1* values, separated by commas if "
"*expression-2* is omitted, or separated by the *expression-2* value if "
"*expression-2* is not omitted."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1749
msgid "Example: :samp:`GROUP_CONCAT({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1756
msgid "``MAX([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1754
#, fuzzy
msgid "Return the maximum value of expression."
msgstr "Возврат шестнадцатеричного значения введенной строки."

#: ../doc/reference/reference_sql/sql.rst:1756
msgid "Example: :samp:`MAX({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1763
msgid "``MIN([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1761
msgid "Return the minimum value of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1763
msgid "Example: :samp:`MIN({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1770
msgid "``SUM([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1768
#: ../doc/reference/reference_sql/sql.rst:1775
msgid "Return the sum of values of expression."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1770
msgid "Example: :samp:`SUM({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1777
msgid "``TOTAL([DISTINCT] expression)``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1777
msgid "Example: :samp:`TOTAL({column1})`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1785
msgid "HAVING clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1789
msgid ":samp:`HAVING condition;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1798
msgid ""
"Specify the condition for filtering rows from a grouped table; this is a "
"clause in a SELECT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1801
msgid ""
"The clause preceding the HAVING clause may be a GROUP BY clause. HAVING "
"operates on the table that the GROUP BY produces, which may contain "
"grouped columns and aggregates."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1805
msgid ""
"If the preceding clause is not a GROUP BY clause, then there is only one "
"group and the HAVING clause may only contain aggregate functions or "
"literals."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1814
msgid ""
"In effect, HAVING condition takes a table with n rows and returns a table"
" with n or fewer rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1819
msgid ""
"-- with a simple condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5;\n"
"-- with a more complicated condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5 OR column2 < 5;\n"
"-- with an aggregate:\n"
"SELECT x, SUM(y) FROM t GROUP BY x HAVING SUM(y) > 0;\n"
"-- with no GROUP BY and an aggregate:\n"
"SELECT SUM(y) FROM t GROUP BY x HAVING MIN(y) < MAX(y);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1832
msgid "HAVING without GROUP BY is not supported for multiple tables."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1838
msgid "ORDER BY clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1842
msgid ":samp:`ORDER BY expression [ASC|DESC] [, expression [ASC|DESC] ...]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1851
msgid "Put rows in order; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1853
msgid "An ORDER BY expression has one of three types which are checked in order:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1855
msgid ""
"Expression is a positive integer, representing the ordinal position of "
"the column in the select list. For example, in the statement |br| "
"``SELECT x, y, z FROM t ORDER BY 2;`` |br| ``ORDER BY 2`` means \"order "
"by the second column in the select list\", which is ``y``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1860
msgid ""
"Expression is a name of a column in the select list, which is determined "
"by an AS clause. For example, in the statement |br| ``SELECT x, y AS x, z"
" FROM t ORDER BY x;`` |br| ``ORDER BY x`` means \"order by the column "
"explicitly named ``x`` in the select list\", which is the second column."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1865
msgid ""
"Expression contains a name of a column in a table of the FROM clause. For"
" example, in the statement |br| ``SELECT x, y FROM t1 JOIN t2 ORDER BY "
"z;`` |br| ``ORDER BY z`` means \"order by a column named ``z`` which is "
"expected to be in table ``t1`` or table ``t2``\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1871
msgid ""
"If both tables contain a column named ``z``, then Tarantool will choose "
"the first column that it finds."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1874
msgid ""
"The expression may also contain operators and function names and "
"literals. For example, in the statement |br| ``SELECT x, y FROM t ORDER "
"BY UPPER(z);`` |br| ``ORDER BY UPPER(z)`` means \"order by the uppercase "
"form of column ``t.z``\", which may be similar to doing ordering in a "
"case-insensitive manner."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1880
msgid ""
"Type 3 is illegal if the SELECT statement contains UNION or EXCEPT or "
"INTERSECT."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1882
msgid ""
"If an ORDER BY clause contains multiple expressions, then expressions on "
"the left are processed first and expressions on the right are processed "
"only if necessary for tie-breaking. For example, in the statement |br| "
"``SELECT x, y FROM t ORDER BY x, y;`` if there are two rows which both "
"have the same values for column ``x``, then an additional check is made "
"to see which row has a greater value for column ``y``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1891
msgid ""
"In effect, ORDER BY clause takes a table with rows that may be out of "
"order, and returns a table with rows in order."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1894
msgid "Sorting order:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1896
msgid ""
"The default order is ASC (ascending), the optional order is DESC "
"(descending)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1897
msgid ""
"NULLs come first, then numbers (INTEGER or NUMBER), then STRINGs, then "
"VARBINARYs."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1898
msgid "Within STRINGs, ordering is according to collation."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1899
msgid ""
"Collation may be specified within the ORDER BY column-list, or may be "
"default."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1903
msgid ""
"-- with a single column:\n"
"SELECT 1 FROM t ORDER BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t ORDER BY column1, column2;\n"
"-- with a variety of data:\n"
"CREATE TABLE h (s1 INT PRIMARY KEY, s2 INT);\n"
"INSERT INTO h VALUES (7,'A'),(4,'A '),(-4,'AZ'),(17,17),(23,NULL);\n"
"INSERT INTO h VALUES (17.5,'Д'),(1e+300,'a'),(0,''),(-1,'');\n"
"SELECT * FROM h ORDER BY s2, s1;\n"
"-- The result of the above SELECT will be:\n"
"- - [23, null]\n"
"  - [17, 17]\n"
"  - [-1, '']\n"
"  - [0, '']\n"
"  - [7, 'A']\n"
"  - [4, 'A ']\n"
"  - [-4, 'AZ']\n"
"  - [1e+300, 'a']\n"
"  - [17.5, 'Д']\n"
"..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1928
msgid "ORDER BY 1 is legal. This is common but is not standard SQL nowadays."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1936
msgid "LIMIT clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1940
msgid ":samp:`LIMIT limit-expression [OFFSET offset-expression]`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1941
msgid ":samp:`LIMIT offset-expression, limit-expression`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1945
msgid ""
"The above is not a typo: *offset-expression* and *limit-expression* are "
"in reverse order if a comma is used."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1955
msgid ""
"Specify a maximum number of rows and a start row; this is a clause in a "
"SELECT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1958
msgid ""
"Expressions may contain integers and arithmetic operators or functions, "
"for example ``ABS(-3/1)``. However, the result must be an integer value "
"greater than or equal to zero."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1962
msgid ""
"Usually the LIMIT clause follows an ORDER BY clause, because otherwise "
"Tarantool does not guarantee that rows are in order."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1967
msgid ""
"-- simple case:\n"
"SELECT * FROM t LIMIT 3;\n"
"-- both limit and order:\n"
"SELECT * FROM t LIMIT 3 OFFSET 1;\n"
"-- applied to a UNIONed result (LIMIT clause must be the final clause):\n"
"SELECT column1 FROM table1 UNION SELECT column1 FROM table2 ORDER BY 1 "
"LIMIT 1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1978
msgid ""
"If ORDER BY ... LIMIT is used, then all order-by columns must be ASC or "
"all must be DESC."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1987
msgid "VALUES"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:1991
msgid ""
":samp:`VALUES (expression [, expression ...]) [, (expression [, "
"expression ...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2000
#, fuzzy
msgid "Select one or more rows."
msgstr "Выбор одного или нескольких кортежей"

#: ../doc/reference/reference_sql/sql.rst:2002
msgid ""
"VALUES has the same effect as SELECT, that is, it returns a result set, "
"but VALUES statements may not have FROM or GROUP or ORDER BY or LIMIT "
"clauses."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2005
msgid "VALUES may be used wherever SELECT may be used, for example in subqueries."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2009
msgid ""
"-- simple case:\n"
"VALUES (1);\n"
"-- equivalent to SELECT 1, 2, 3:\n"
"VALUES (1, 2, 3);\n"
"-- two rows:\n"
"VALUES (1, 2, 3), (4, 5, 6);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2022
msgid "Subquery"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2026
msgid ":ref:`SELECT-statement <sql_select>` syntax"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2027
msgid ":ref:`VALUES-statement <sql_values>` syntax"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2029
msgid ""
"A subquery has the same syntax as a SELECT statement or VALUES statement "
"embedded inside a main statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2034
msgid ""
"The SELECT and VALUES statements are called \"queries\" because they "
"return answers, in the form of result sets."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2037
msgid "Subqueries may be the second part of INSERT statements. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2039
msgid "INSERT INTO t2 SELECT a,b,c FROM t1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2043
msgid "Subqueries may be in the FROM clause of SELECT statements."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2045
msgid ""
"Subqueries may be expressions, or be inside expressions. In this case "
"they must be parenthesized, and usually the number of rows must be 1. For"
" example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2049
msgid "SELECT 1, (SELECT 5), 3 FROM t WHERE c1 * (SELECT COUNT(*) FROM t2) > 5;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2053
msgid ""
"Subqueries may be expressions on the right side of certain comparison "
"operators, and in this unusual case the number of rows may be greater "
"than 1. The comparison operators are: [NOT] EXISTS and [NOT] IN. For "
"example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2057
msgid "DELETE FROM t WHERE s1 NOT IN (SELECT s2 FROM t);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2061
msgid ""
"Subqueries may refer to values in the outer query. In this case, the "
"subquery is called a \"correlated subquery\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2064
msgid ""
"Subqueries may refer to rows which are being updated or deleted by the "
"main query. In that case, the subquery finds the matching rows first, "
"before starting to update or delete. For example, after:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2068
msgid ""
"CREATE TABLE t (s1 INT PRIMARY KEY, s2 INT);\n"
"INSERT INTO t VALUES (1,3),(2,1);\n"
"DELETE FROM t WHERE s2 NOT IN (SELECT s1 FROM t);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2074
msgid "only one of the rows is deleted, not both rows."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2080
msgid "WITH clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2082
msgid "**WITH clause (common table expression)**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2086
msgid ""
":samp:`WITH {temporary-table-name} AS (subquery)` |br| :samp:`[, "
"{temporary-table-name} AS (subquery)]` |br| :samp:`SELECT statement | "
"INSERT statement | DELETE statement | UPDATE statement | REPLACE "
"statement;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2097
msgid "WITH v AS (SELECT * FROM t) SELECT * FROM v;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2101
msgid "is equivalent to creating a view and selecting from it:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2103
msgid ""
"CREATE VIEW v AS SELECT * FROM t;\n"
"SELECT * FROM v;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2108
msgid ""
"The difference is that a WITH-clause \"view\" is temporary and only "
"useful within the same statement. No CREATE privilege is required."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2111
msgid ""
"The WITH-clause can also be thought of as a subquery that has a name. "
"This is useful when the same subquery is being repeated. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2114
msgid "SELECT * FROM t WHERE a < (SELECT s1 FROM x) AND b < (SELECT s1 FROM x);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2118
#, fuzzy
msgid "can be replaced with:"
msgstr "Можно создать?"

#: ../doc/reference/reference_sql/sql.rst:2120
msgid ""
"WITH S AS (SELECT s1 FROM x) SELECT * FROM t,S WHERE a < S.s1 AND b < "
"S.s1;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2124
msgid ""
"This \"factoring out\" of a repeated expression is regarded as good "
"practice."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2128
msgid ""
"WITH cte AS (VALUES (7,'') INSERT INTO j SELECT * FROM cte;\n"
"WITH cte AS (SELECT s1 AS x FROM k) SELECT * FROM cte;\n"
"WITH cte AS (SELECT COUNT(*) FROM k WHERE s2 < 'x' GROUP BY s3)\n"
"  UPDATE j SET s2 = 5\n"
"  WHERE s1 = (SELECT s1 FROM cte) OR s3 = (SELECT s1 FROM cte);"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2136
msgid ""
"WITH can only be used at the beginning of a statement, therefore it "
"cannot be used at the beginning of a subquery or after a set operator or "
"inside a CREATE statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2140
msgid ""
"A WITH-clause \"view\" is read-only because Tarantool does not support "
"updatable views."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2147
msgid "WITH RECURSIVE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2149
msgid "**WITH RECURSIVE clause (iterative common table expression)**"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2151
msgid ""
"The real power of WITH lies in the WITH RECURSIVE clause, which is useful"
" when it is combined with UNION or UNION ALL:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2154
msgid ""
":samp:`WITH RECURSIVE recursive-table-name AS` |br| :samp:`(SELECT ... "
"FROM non-recursive-table-name ...` |br| :samp:`UNION [ALL]` |br| "
":samp:`SELECT ... FROM recursive-table-name ...)` |br| :samp:`statement-"
"that-uses-recursive-table-name;` |br|"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2167
msgid ""
"In non-SQL this can be read as: starting with a seed value from a non-"
"recursive table, produce a recursive viewed table, UNION that with "
"itself, UNION that with itself, UNION that with itself ... forever, or "
"until a condition in the WHERE clause says \"stop\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2174
msgid ""
"CREATE TABLE ts (s1 INT PRIMARY KEY);\n"
"INSERT INTO ts VALUES (1);\n"
"WITH RECURSIVE w AS (\n"
"  SELECT s1 FROM ts\n"
"  UNION ALL\n"
"  SELECT s1+1 FROM w WHERE s1 < 4)\n"
"SELECT * FROM w;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2184
msgid "First, table ``w`` is seeded from ``t1``, so it has one row: [1]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2186
msgid ""
"Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- "
"which contains [1] -- adds 1 because the select list says \"s1+1\", and "
"so it has one row: [2]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2190
msgid ""
"Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- "
"which contains [2] -- adds 1 because the select list says \"s1+1\", and "
"so it has one row: [3]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2194
msgid ""
"Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- "
"which contains [3] -- adds 1 because the select list says \"s1+1\", and "
"so it has one row: [4]."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2198
msgid ""
"Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- "
"which contains [4] -- and now the importance of the WHERE clause becomes "
"evident, because \"s1 < 4\" is false for this row, and therefore we have "
"reached the \"stop\" condition."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2203
msgid ""
"So, before the \"stop\", table ``w`` got 4 rows -- [1], [2], [3], [4] -- "
"and the result of the statement looks like:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2206
msgid ""
"tarantool> WITH RECURSIVE w AS (\n"
"         >   SELECT s1 FROM ts\n"
"         >   UNION ALL\n"
"         >   SELECT s1+1 FROM w WHERE s1 < 4)\n"
"         > SELECT * FROM w;\n"
"---\n"
"- - [1]\n"
"  - [2]\n"
"  - [3]\n"
"  - [4]\n"
"..."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2220
msgid ""
"In other words, this ``WITH RECURSIVE ... SELECT`` produces a table of "
"auto-incrementing values."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2227
msgid "UNION, EXCEPT, and INTERSECT clauses"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2231
msgid ""
":samp:`select-statement UNION [ALL] select-statement [ORDER BY clause] "
"[LIMIT clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2232
msgid ""
":samp:`select-statement EXCEPT select-statement [ORDER BY clause] [LIMIT "
"clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2233
msgid ""
":samp:`select-statement INTERSECT select-statement [ORDER BY clause] "
"[LIMIT clause];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2252
msgid ""
"UNION, EXCEPT, and INTERSECT are collectively called \"set operators\" or"
" \"table operators\". In particular:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2255
msgid "``a UNION b`` means \"take rows which occur in a OR b\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2256
msgid "``a EXCEPT b`` means \"take rows which occur in a AND NOT b\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2257
msgid "``a INTERSECT b`` means \"take rows which occur in a AND b\"."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2259
msgid "Duplicate rows are eliminated unless ALL is specified."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2261
msgid ""
"The *select-statements* may be chained: ``SELECT ... SELECT ... SELECT "
"...;``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2263
msgid "Each *select-statement* must result in the same number of columns."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2265
msgid "The *select-statements* may be replaced with VALUES statements."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2267
#, fuzzy
msgid "The maximum number of set operations is 50."
msgstr "максимальное количество показываемых сегментов"

#: ../doc/reference/reference_sql/sql.rst:2271
msgid ""
"CREATE TABLE t1 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"CREATE TABLE t2 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"INSERT INTO t1 VALUES (1,'A'),(2,'B'),(3,NULL);\n"
"INSERT INTO t2 VALUES (1,'A'),(2,'C'),(3,NULL);\n"
"SELECT s2 FROM t1 UNION SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 UNION ALL SELECT s2 FROM t2 ORDER BY s2;\n"
"SELECT s2 FROM t1 EXCEPT SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 INTERSECT SELECT s2 FROM t2;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2284
msgid "The UNION query returns 4 rows: NULL, 'A', 'B', 'C'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2285
msgid "The UNION ALL query returns 6 rows: NULL, NULL, 'A', 'A', 'B', 'C'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2286
msgid "The EXCEPT query returns 1 row: 'B'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2287
msgid "The INTERSECT query returns 2 rows: NULL, 'A'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2291
msgid "Parentheses are not allowed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2292
msgid "Evaluation is left to right, INTERSECT does not have precedence."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2296
msgid ""
"CREATE TABLE t01 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"CREATE TABLE t02 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"CREATE TABLE t03 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"INSERT INTO t01 VALUES (1,'A');\n"
"INSERT INTO t02 VALUES (1,'B');\n"
"INSERT INTO t03 VALUES (1,'A');\n"
"SELECT s2 FROM t01 INTERSECT SELECT s2 FROM t03 UNION SELECT s2 FROM t02;"
"\n"
"SELECT s2 FROM t03 UNION SELECT s2 FROM t02 INTERSECT SELECT s2 FROM t03;"
"\n"
"-- ... results are different."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2312
msgid "INDEXED BY clause"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2316
msgid ":samp:`INDEXED BY {index-name}`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2325
msgid ""
"The INDEXED BY clause may be used in a SELECT, DELETE, or UPDATE "
"statement, immediately after the *table-name*. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2328
msgid "DELETE FROM table7 INDEXED BY index7 WHERE column1 = 'a';"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2332
msgid ""
"In this case the search for 'a' will take place within ``index7``. For "
"example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2334
msgid "SELECT * FROM table7 NOT INDEXED WHERE column1 = 'a';"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2338
msgid ""
"In this case the search for 'a' will be done via a search of the whole "
"table, what is sometimes called a \"full table scan\", even if there is "
"an index for ``column1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2342
msgid ""
"Ordinarily Tarantool chooses the appropriate index or lookup method "
"depending on a complex set of \"optimizer\" rules; the INDEXED BY clause "
"overrides the optimizer choice."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2348
msgid "Suppose a table has two columns:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2350
msgid ""
"The first column is the primary key and therefore it has an automatic "
"index named ``pk_unnamed_T_1``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2352
msgid "The second column has an index created by the user."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2354
msgid ""
"The user selects with ``INDEXED BY the-index-on-column1``, then selects "
"with ``INDEXED BY the-index-on-column-2``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2357
msgid ""
"CREATE TABLE t (column1 INT PRIMARY KEY, column2 INT);\n"
"CREATE INDEX i ON t (column2);\n"
"INSERT INTO t VALUES (1,2),(2,1);\n"
"SELECT * FROM t INDEXED BY \"pk_unnamed_T_1\";\n"
"SELECT * FROM t INDEXED BY i;\n"
"-- Result for the first select: (1,2),(2,1)\n"
"-- Result for the second select: (2,1),(1,2)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2371
#, fuzzy
msgid "Transactions"
msgstr "функция"

#: ../doc/reference/reference_sql/sql.rst:2377
msgid "START TRANSACTION"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2381
msgid ":samp:`START TRANSACTION;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2390
msgid ""
"Start a transaction. After ``START TRANSACTION;``, a transaction is "
"\"active\". If a transaction is already active, then ``START "
"TRANSACTION;`` is illegal."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2393
msgid ""
"Transactions should be active for fairly short periods of time, to avoid "
"concurrency issues. To end a transaction, say ``COMMIT;`` or "
"``ROLLBACK;``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2396
msgid ""
"Just like in NoSQL, transaction control statements are subject to "
"limitations set by the storage engine involved:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2399
msgid ""
"For memtx storage engine, if a yield happens within an active "
"transaction, the transaction is rolled back."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2401
msgid "For vinyl engine, yields are allowed."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2403
msgid ""
"However,transaction control statements still may not work as you expect "
"when run over a network connection: a transaction is associated with a "
"fiber, not a network connection, and different transaction control "
"statements sent via the same network connection may be executed by "
"different fibers from the fiber pool."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2409
msgid ""
"In order to ensure that all statements are part of the intended "
"transaction, put all of them between ``START TRANSACTION;`` and "
"``COMMIT;`` or ``ROLLBACK;`` then send as a single batch. For example:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2413
msgid ""
"Enclose each separate SQL statement in a :ref:`box.execute() <box-"
"sql_box_execute>` function."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2415
msgid ""
"Pass all the ``box.execute()`` functions to the server in a single "
"message."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2417
msgid ""
"If you are using a console, you can do this by writing everything on a "
"single line."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2420
msgid ""
"If you are using :ref:`net.box <net_box-module>`, you can do this by "
"putting all the function calls in a single string and calling "
":ref:`eval(string) <net_box-eval>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2426
msgid "START TRANSACTION;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2430
msgid ""
"Example of a whole transaction sent to a server on ``localhost:3301`` "
"with ``eval(string)``:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2433
msgid ""
"net_box = require('net.box')\n"
"conn = net_box.new('localhost', 3301)\n"
"s = 'box.execute([[START TRANSACTION; ]]) '\n"
"s = s .. 'box.execute([[INSERT INTO t VALUES (1); ]]) '\n"
"s = s .. 'box.execute([[ROLLBACK; ]]) '\n"
"conn:eval(s)"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2446
msgid "COMMIT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2450
msgid ":samp:`COMMIT;`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2459
msgid ""
"Commit an active transaction, so all changes are made permanent and the "
"transaction ends."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2462
msgid ""
"COMMIT is illegal unless a transaction is active. If a transaction is not"
" active then SQL statements are committed automatically."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2467
msgid "COMMIT;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2475
msgid "SAVEPOINT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2479
msgid ":samp:`SAVEPOINT {savepoint-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2488
msgid "Set a savepoint, so that ROLLBACK TO *savepoint-name* is possible."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2490
msgid "SAVEPOINT is illegal unless a transaction is active."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2492
msgid ""
"If a savepoint with the same name already exists, it is released before "
"the new savepoint is set."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2497
msgid "SAVEPOINT x;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2505
msgid "RELEASE SAVEPOINT"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2509
msgid ":samp:`RELEASE SAVEPOINT {savepoint-name};`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2518
msgid "Release (destroy) a savepoint created by SAVEPOINT statement."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2520
msgid "RELEASE is illegal unless a transaction is active."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2522
msgid "Savepoints are released automatically when a transaction ends."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2526
msgid "RELEASE SAVEPOINT x;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2534
msgid "ROLLBACK"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2538
msgid ":samp:`ROLLBACK [TO [SAVEPOINT] {savepoint-name}];`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2547
msgid ""
"If ROLLBACK does not specify a *savepoint-name*, rollback an active "
"transaction, so all changes since START TRANSACTION are cancelled, and "
"the transaction ends."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2552
msgid ""
"If ROLLBACK does specify a *savepoint-name*, rollback an active "
"transaction, so all changes since *savepoint-name* are cancelled, and the"
" transaction does not end."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2557
msgid "ROLLBACK is illegal unless a transaction is active."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2561
msgid ""
"-- the simple form:\n"
"ROLLBACK;\n"
"-- the form so changes before a savepoint are not cancelled:\n"
"ROLLBACK TO SAVEPOINT x;"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2568
msgid ""
"-- An example of a Lua function that will do a transaction\n"
"-- containing savepoint and rollback to savepoint.\n"
"function f()\n"
"box.execute([[DROP TABLE IF EXISTS t;]]) -- commits automatically\n"
"box.execute([[CREATE TABLE t (s1 VARCHAR(20) PRIMARY KEY);]]) -- commits "
"automatically\n"
"box.execute([[START TRANSACTION;]]) -- after this succeeds, a transaction"
" is active\n"
"box.execute([[INSERT INTO t VALUES ('Data change #1');]])\n"
"box.execute([[SAVEPOINT \"1\";]])\n"
"box.execute([[INSERT INTO t VALUES ('Data change #2');]])\n"
"box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) -- rollback Data change #2\n"
"box.execute([[ROLLBACK TO SAVEPOINt \"1\";]]) -- this is legal but does "
"nothing\n"
"box.execute([[COMMIT;]]) -- make Data change #1 permanent, end the "
"transaction\n"
"end"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2588
#, fuzzy
msgid "Functions"
msgstr "функция"

#: ../doc/reference/reference_sql/sql.rst:2594
msgid ""
"Apply a built-in function to one or more expressions and return a scalar "
"value."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2596
msgid "Tarantool supports 32 built-in functions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2602
msgid "CHAR"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2606
msgid ":samp:`CHAR([numeric-expression [,numeric-expression...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2608
msgid ""
"Return the characters whose Unicode code point values are equal to the "
"numeric expressions."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2611
#, fuzzy
msgid "Short example:"
msgstr "Пример:"

#: ../doc/reference/reference_sql/sql.rst:2613
msgid ""
"The first 128 Unicode characters are the \"ASCII\" characters, so "
"CHAR(65,66,67) is 'ABC'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2616
#, fuzzy
msgid "Long example:"
msgstr "Пример:"

#: ../doc/reference/reference_sql/sql.rst:2618
msgid ""
"For the current list of Unicode characters, in order by code point, see "
"`www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt "
"<http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt>`_. In that"
" list, there is a line for a Linear B ideogram"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2624
msgid "``100CC;LINEAR B IDEOGRAM B240 WHEELED CHARIOT ...``"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2626
msgid ""
"Therefore, for a string with a chariot in the middle, use the "
"concatenation operator ``||`` and the CHAR function"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2629
msgid "``'start of string ' || CHAR(0X100CC) || ' end of string'``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2635
#, fuzzy
msgid "COALESCE"
msgstr "false"

#: ../doc/reference/reference_sql/sql.rst:2639
msgid ":samp:`COALESCE(expression, expression [, expression ...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2641
msgid ""
"Return the value of the first non-NULL expression, or, if all expression "
"values are NULL, return NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2645
msgid "``COALESCE(NULL, 17, 32)`` is 17."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2651
msgid "HEX"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2655
msgid ":samp:`HEX(expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2657
msgid ""
"Return the hexadecimal code for each byte in **expression**, which may be"
" either a string or a byte sequence. For ASCII characters, this is "
"straightforward because the encoding is the same as the code point value."
" For non-ASCII characters, since character strings are usually encoded in"
" UTF-8, each character will require two or more bytes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2668
msgid "``HEX('A')`` will return ``41``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2669
msgid "``HEX('Д')`` will return ``D094``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2675
#, fuzzy
msgid "IFNULL"
msgstr "null"

#: ../doc/reference/reference_sql/sql.rst:2679
msgid ":samp:`IFNULL(expression, expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2681
msgid ""
"Return the value of the first non-NULL expression, or, if both expression"
" values are NULL, return NULL. Thus ``IFNULL(expression, expression)`` is"
" the same as :ref:`COALESCE(expression, expression) "
"<sql_function_coalesce>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2687
msgid "``IFNULL(NULL, 17)`` is 17"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2693
msgid "LENGTH"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2697
msgid ":samp:`LENGTH(expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2699
msgid ""
"Return the number of characters in the **expression**, or the number of "
"bytes in the **expression**. It depends on the data type: strings with "
"data type STRING are counted in characters, byte sequences with data type"
" VARBINARY are counted in bytes and are not ended by the nul character. "
"There are two aliases for ``LENGTH(expression)`` -- "
"``CHAR_LENGTH(expression)`` and ``CHARACTER_LENGTH(expression)`` do the "
"same thing."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2710
msgid "``LENGTH('ДД')`` is 2, the string has 2 characters."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2711
msgid "``LENGTH(CAST('ДД' AS VARBINARY))`` is 4, the string has 4 bytes."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2712
msgid "``LENGTH(CHAR(0,65))`` is 2, '\\0' does not mean 'end of string'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2713
msgid "``LENGTH(X'410041')`` is 3, X'...' byte sequences have type VARBINARY."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2719
#, fuzzy
msgid "LOWER"
msgstr "Восстановление после отказа"

#: ../doc/reference/reference_sql/sql.rst:2723
msgid ":samp:`LOWER(string-expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2725
msgid ""
"Return the expression, with upper-case characters converted to lower "
"case. This is the reverse of :ref:`UPPER(string-expression) "
"<sql_function_upper>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2728
msgid "Example: ``LOWER('-4ЩL')`` is '-4щl'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2734
#, fuzzy
msgid "NULLIF"
msgstr "null"

#: ../doc/reference/reference_sql/sql.rst:2738
msgid ":samp:`NULLIF(expression-1, expression-2)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2740
msgid ""
"Return *expression-1* if *expression-1* <> *expression-2*, otherwise "
"return NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2745
msgid "``NULLIF('a','A')`` is 'a'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2746
msgid "``NULLIF(1.00, 1)`` is NULL."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2752
#, fuzzy
msgid "PRINTF"
msgstr "порт"

#: ../doc/reference/reference_sql/sql.rst:2756
msgid ":samp:`PRINTF(string-expression [, expression ...])`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2758
#, python-format
msgid ""
"Return a string formatted according to the rules of the C ``sprintf()`` "
"function, where ``%d%s`` means the next two arguments are a number and a "
"string, etc."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2762
msgid "If an argument is missing or is NULL, it becomes:"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2764
msgid "'0' if the format requires an integer,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2765
msgid "'0.0' if the format requires a decimal number,"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2766
msgid "'' if the format requires a string."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2768
#, python-format
msgid "Example: ``PRINTF('%da', 5)`` is '5a'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2774
msgid "QUOTE"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2778
msgid ":samp:`QUOTE(string-literal)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2780
msgid ""
"Return a string with enclosing quotes if necessary, and with quotes "
"inside the enclosing quotes if necessary. This function is useful for "
"creating strings which are part of SQL statements, because of SQL's rules"
" that string literals are enclosed by single quotes, and single quotes "
"inside such strings are shown as two single quotes in a row."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2787
msgid "Example: ``QUOTE('a')`` is ``'a'``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2793
#, fuzzy
msgid "SOUNDEX"
msgstr "Указатель"

#: ../doc/reference/reference_sql/sql.rst:2797
msgid ":samp:`SOUNDEX(string-expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2799
msgid ""
"Return a four-character string which represents the sound of ``string-"
"expression``. Often words and names which have different spellings will "
"have the same Soundex representation if they are pronounced similarly, so"
" it is possible to search by what they sound like. The algorithm works "
"with characters in the Latin alphabet and works best with English words."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2807
msgid ""
"Example: ``SOUNDEX('Crater')`` and ``SOUNDEX('Creature')`` both return "
"``C636``."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2813
#, fuzzy
msgid "UNICODE"
msgstr "Lua-код"

#: ../doc/reference/reference_sql/sql.rst:2817
msgid ":samp:`UNICODE(string-expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2819
msgid ""
"Return the Unicode code point value of the first character of **string-"
"expression**. If *string-expression* is empty, the return is NULL. This "
"is the reverse of :ref:`CHAR(integer) <sql_function_char>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2823
msgid "Example: ``UNICODE('Щ')`` is 1065 (hexadecimal 0429)."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2829
msgid "UPPER"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2833
msgid ":samp:`UPPER(string-expression)`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2835
msgid ""
"Return the expression, with lower-case characters converted to upper "
"case. This is the reverse of :ref:`LOWER(string-"
"expression)<sql_function_lower>`."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2838
msgid "Example: ``UPPER('-4щl')`` is '-4ЩL'."
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2844
#, fuzzy
msgid "VERSION"
msgstr "Замена регистра"

#: ../doc/reference/reference_sql/sql.rst:2848
msgid ":samp:`VERSION()`"
msgstr ""

#: ../doc/reference/reference_sql/sql.rst:2850
#, fuzzy
msgid "Return the Tarantool version."
msgstr "Запустите Tarantool-сервер, как описано выше."

#: ../doc/reference/reference_sql/sql.rst:2852
msgid "Example: for a March 2019 build VERSION() is ``2.1.1-374-g27283debc``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:5
msgid "Utility `tarantoolctl`"
msgstr "Утилита `tarantoolctl`"

#: ../doc/reference/tarantoolctl.rst:7
msgid ""
"``tarantoolctl`` is a utility for administering Tarantool :ref:`instances"
" <tarantoolctl-instance_management>`, :ref:`checkpoint files "
"<tarantoolctl-checkpoint_management>` and :ref:`modules <tarantoolctl-"
"module_management>`. It is shipped and installed as part of Tarantool "
"distribution."
msgstr ""
"``tarantoolctl`` представляет собой утилиту для администрирования "
":ref:`экземпляров <tarantoolctl-instance_management>`, :ref:`файлов "
"контрольной точки <tarantoolctl-checkpoint_management>` и :ref:`модулей "
"<tarantoolctl-module_management>` в Tarantool'е. Утилита поставляется и "
"устанавливается как часть дистрибутива Tarantool'а."

#: ../doc/reference/tarantoolctl.rst:13
msgid ""
"See also ``tarantoolctl`` usage examples in :ref:`Server administration "
"<admin>` section."
msgstr ""
"См. также примеры использования ``tarantoolctl`` в разделе "
":ref:`Администрирование серверной части <admin>`."

#: ../doc/reference/tarantoolctl.rst:20
msgid "Command format"
msgstr "Формат команд"

#: ../doc/reference/tarantoolctl.rst:22
msgid "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"
msgstr "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"

#: ../doc/reference/tarantoolctl.rst:24
msgid "where:"
msgstr "где:"

#: ../doc/reference/tarantoolctl.rst:26
msgid ""
"``COMMAND`` is one of the following: ``start``, ``stop``, ``status``, "
"``restart``, ``logrotate``, ``check``, ``enter``, ``eval``, ``connect``, "
"``cat``, ``play``, ``rocks``."
msgstr ""
"``COMMAND`` -- это одна из следующих команд, описанных ниже: ``start``, "
"``stop``, ``status``, ``restart``, ``logrotate``, ``check``, ``enter``, "
"``eval``, ``connect``, ``cat``, ``play``, ``rocks``."

#: ../doc/reference/tarantoolctl.rst:30
msgid ""
"``NAME`` is the name of an :ref:`instance file <admin-instance_file>` or "
"a :ref:`module <app_server-modules>`."
msgstr ""
"``NAME`` -- это имя :ref:`файла экземпляра <admin-instance_file>` или "
":ref:`модуля <app_server-modules>`."

#: ../doc/reference/tarantoolctl.rst:33
msgid "``FILE`` is the path to some file (.lua, .xlog or .snap)."
msgstr "``FILE`` -- это путь к какому-либо файлу (.lua, .xlog или .snap)."

#: ../doc/reference/tarantoolctl.rst:35
msgid "``URI`` is the URI of some Tarantool instance."
msgstr "``URI`` -- это URI некого экземпляра Tarantool'а."

#: ../doc/reference/tarantoolctl.rst:37
msgid "``OPTIONS`` are options taken by some ``tarantoolctl`` commands."
msgstr "``OPTIONS`` -- это параметры, которые принимают команды ``tarantoolctl``."

#: ../doc/reference/tarantoolctl.rst:43
msgid "Commands for managing Tarantool instances"
msgstr "Команды для управления экземплярами Tarantool'а"

#: ../doc/reference/tarantoolctl.rst:61
msgid "``tarantoolctl start NAME``"
msgstr "``tarantoolctl start NAME``"

#: ../doc/reference/tarantoolctl.rst:46
msgid "Start a Tarantool instance."
msgstr "Запуск экземпляра Tarantool’а."

#: ../doc/reference/tarantoolctl.rst:48
msgid ""
"Additionally, this command sets the TARANTOOLCTL environment variable to "
"'true', to mark that the instance was started by ``tarantoolctl``."
msgstr ""
"Кроме того, данная команда задает значение переменной окружения "
"TARANTOOLCTL = 'true' (правда), чтобы отметить, что экземпляр был запущен"
" с помощью ``tarantoolctl``."

#: ../doc/reference/tarantoolctl.rst:53
msgid ""
"``tarantoolctl`` works for instances without ``box.cfg{}`` called or with"
" delayed ``box.cfg{}`` call."
msgstr ""
"``tarantoolctl`` работает для экземпляров, где не вызвана функция "
"``box.cfg{}`` или вызов ``box.cfg{}`` отложен."

#: ../doc/reference/tarantoolctl.rst:56
msgid ""
"For example, this can be used to manage instances which receive "
"configuration from an external server. For such instances, ``tarantoolctl"
" start`` goes to background when ``box.cfg{}`` is called, so it will wait"
" until options for ``box.cfg`` are received. However this is not the case"
" for daemon management systems like ``systemd``, as they handle "
"backgrounding on their side."
msgstr ""
"Например, это можно использовать для управления экземплярами, которые "
"получают конфигурацию из внешнего сервера. Для таких экземпляров "
"``tarantoolctl start`` goes to background when ``box.cfg{}`` is called, "
"so it will wait until options for ``box.cfg`` are received. However this "
"is not the case for daemon management systems like ``systemd``, as they "
"handle backgrounding on their side."

#: ../doc/reference/tarantoolctl.rst:64
msgid "``tarantoolctl stop NAME``"
msgstr "``tarantoolctl stop NAME``"

#: ../doc/reference/tarantoolctl.rst:64
msgid "Stop a Tarantool instance."
msgstr "Остановка экземпляра Tarantool'а."

#: ../doc/reference/tarantoolctl.rst:72
msgid "``tarantoolctl status NAME``"
msgstr "``tarantoolctl status NAME``"

#: ../doc/reference/tarantoolctl.rst:67
msgid ""
"Show an instance's status (started/stopped). If pid file exists and an "
"alive control socket exists, the return code is ``0``. Otherwise, the "
"return code is not ``0``."
msgstr ""
"Отображение статуса экземпляра (работает/остановлен). Если есть PID-файл "
"и активный управляющий сокет, возвращается код ``0``. В остальных случаях"
" возвращается не ``0``."

#: ../doc/reference/tarantoolctl.rst:71
msgid ""
"Reports typical problems to stderr (e.g. pid file exists and control "
"socket doesn't)."
msgstr ""
"Сообщает о типичных проблемах стандартного вывода ошибок (например, "
"PID-файл есть, а управляющий сокет отсутствует)."

#: ../doc/reference/tarantoolctl.rst:79
msgid "``tarantoolctl restart NAME``"
msgstr "``tarantoolctl restart NAME``"

#: ../doc/reference/tarantoolctl.rst:75
msgid "Stop and start a Tarantool instance."
msgstr "Остановка и запуск экземпляра Tarantool’а."

#: ../doc/reference/tarantoolctl.rst:77
msgid ""
"Additionally, this command sets the TARANTOOL_RESTARTED environment "
"variable to 'true', to mark that the instance was restarted by "
"``tarantoolctl``."
msgstr ""
"Кроме того, данная команда задает значение переменной окружения "
"TARANTOOL_RESTARTED = 'true' (правда), чтобы отметить, что экземпляр был "
"перезапущен с помощью ``tarantoolctl``."

#: ../doc/reference/tarantoolctl.rst:84
msgid "``tarantoolctl logrotate NAME``"
msgstr "``tarantoolctl logrotate NAME``"

#: ../doc/reference/tarantoolctl.rst:82
msgid ""
"Rotate logs of a started Tarantool instance. Works only if logging-into-"
"file is enabled in the instance file. Pipe/syslog make no effect."
msgstr ""
"Ротация файлов журнала работающего Tarantool-экземпляра. Работает только "
"в том случае, если в файле экземпляра задан параметр записи журнала в "
"файл. Отправка записей в конвейер или системный журнал syslog не имеет "
"значения в данном случае."

#: ../doc/reference/tarantoolctl.rst:87
msgid "``tarantoolctl check NAME``"
msgstr "``tarantoolctl check NAME``"

#: ../doc/reference/tarantoolctl.rst:87
msgid "Check an instance file for syntax errors."
msgstr "Проверка файла экземпляра на ошибки синтаксиса."

#: ../doc/reference/tarantoolctl.rst:95
#, fuzzy
msgid "``tarantoolctl enter NAME [--language=language]``"
msgstr "``tarantoolctl enter NAME``"

#: ../doc/reference/tarantoolctl.rst:90
#, fuzzy
msgid "Enter an instance's interactive Lua or SQL console."
msgstr "Вход в интерактивную Lua-консоль экземпляра."

#: ../doc/reference/tarantoolctl.rst:92
#, fuzzy
msgid "Supported option:"
msgstr "Поддерживаемые опции:"

#: ../doc/reference/tarantoolctl.rst:94
msgid ""
"``--language=language`` to set :ref:`interactive console "
"<interactive_console>` language. Can be either ``Lua`` or ``SQL``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:98
msgid "``tarantoolctl eval NAME FILE``"
msgstr "``tarantoolctl eval NAME FILE``"

#: ../doc/reference/tarantoolctl.rst:98
msgid "Evaluate a local Lua file on a running Tarantool instance."
msgstr "Выполнение локального Lua-файла на работающем экземпляре Tarantool'а."

#: ../doc/reference/tarantoolctl.rst:102
msgid "``tarantoolctl connect URI``"
msgstr "``tarantoolctl connect URI``"

#: ../doc/reference/tarantoolctl.rst:101
msgid ""
"Connect to a Tarantool instance on an admin-console port. Supports both "
"TCP/Unix sockets."
msgstr ""
"Подключение к экземпляру Tarantool'а по порту административной консоли. "
"Поддерживаются TCP и Unix сокеты."

#: ../doc/reference/tarantoolctl.rst:108
msgid "Commands for managing checkpoint files"
msgstr "Команды для управления файлами контрольной точки"

#: ../doc/reference/tarantoolctl.rst:111
msgid ""
"``tarantoolctl cat FILE.. [--space=space_no ..] [--show-system] "
"[--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""
"``tarantoolctl cat FILE.. [--space=space_no ..] [--show-system] "
"[--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"

#: ../doc/reference/tarantoolctl.rst:111
msgid "Print into stdout the contents of .snap/.xlog files."
msgstr "Стандартный вывод содержимого .snap-файла или .xlog-файла."

#: ../doc/reference/tarantoolctl.rst:114
msgid ""
"``tarantoolctl play URI FILE.. [--space=space_no ..] [--show-system] "
"[--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""
"``tarantoolctl play URI FILE.. [--space=space_no ..] [--show-system] "
"[--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"

#: ../doc/reference/tarantoolctl.rst:114
msgid "Play the contents of .snap/.xlog files to another Tarantool instance."
msgstr ""
"Передача содержимого .snap-файла или .xlog-файла на другой экземпляр "
"Tarantool'а."

#: ../doc/reference/tarantoolctl.rst:116 ../doc/reference/tarantoolctl.rst:167
msgid "Supported options:"
msgstr "Поддерживаемые опции:"

#: ../doc/reference/tarantoolctl.rst:118
msgid ""
"``--space=space_no`` to filter the output by space number. May be passed "
"more than once."
msgstr ""
"``--space=space_no`` для фильтрации вывода по номеру спейса. Можно "
"передавать несколько раз."

#: ../doc/reference/tarantoolctl.rst:120
msgid "``--show-system`` to show the contents of system spaces."
msgstr "``--show-system`` для отображения содержимого системных спейсов."

#: ../doc/reference/tarantoolctl.rst:121
msgid "``--from=from_lsn`` to show operations starting from the given lsn."
msgstr "``--from=from_lsn`` для отображения операций, начиная с заданного LSN."

#: ../doc/reference/tarantoolctl.rst:122
msgid "``--to=to_lsn`` to show operations ending with the given lsn."
msgstr "``--to=to_lsn`` для отображения операций, заканчивая заданным LSN."

#: ../doc/reference/tarantoolctl.rst:123
msgid ""
"``--replica=replica_id`` to filter the output by replica id. May be "
"passed more than once."
msgstr ""
"``--replica=replica_id`` для фильтрации вывода по идентификатору реплики."
" Можно передавать несколько раз."

#: ../doc/reference/tarantoolctl.rst:130
msgid "Commands for managing Tarantool modules"
msgstr "Команды для управления модулями Tarantool'а"

#: ../doc/reference/tarantoolctl.rst:133
msgid "``tarantoolctl rocks install NAME``"
msgstr "``tarantoolctl rocks install NAME``"

#: ../doc/reference/tarantoolctl.rst:133
msgid "Install a module in the current directory."
msgstr "Установка модуля в текущей директории."

#: ../doc/reference/tarantoolctl.rst:136
msgid "``tarantoolctl rocks remove NAME``"
msgstr "``tarantoolctl rocks remove NAME``"

#: ../doc/reference/tarantoolctl.rst:136
msgid "Remove a module."
msgstr "Удаление модуля."

#: ../doc/reference/tarantoolctl.rst:139
msgid "``tarantoolctl rocks show NAME``"
msgstr "``tarantoolctl rocks show NAME``"

#: ../doc/reference/tarantoolctl.rst:139
msgid "Show information about an installed module."
msgstr "Отображение информации об установленном модуле."

#: ../doc/reference/tarantoolctl.rst:142
msgid "``tarantoolctl rocks search NAME``"
msgstr "``tarantoolctl rocks search NAME``"

#: ../doc/reference/tarantoolctl.rst:142
msgid "Search the repository for modules."
msgstr "Поиск модулей по репозиторию."

#: ../doc/reference/tarantoolctl.rst:145
msgid "``tarantoolctl rocks list``"
msgstr "``tarantoolctl rocks list``"

#: ../doc/reference/tarantoolctl.rst:145
msgid "List all installed modules."
msgstr "Вывод списка всех установленных модулей."

#: ../doc/reference/tarantoolctl.rst:155
msgid "``tarantoolctl rocks pack {<rockspec> | <name> [<version>]}``"
msgstr "``tarantoolctl rocks pack {<rockspec> | <имя> [<версия>]}``"

#: ../doc/reference/tarantoolctl.rst:148
msgid "Create a rock by packing sources or binaries."
msgstr "Создание модуля путем компоновки исходных или бинарных файлов."

#: ../doc/reference/tarantoolctl.rst:150 ../doc/reference/tarantoolctl.rst:160
msgid "As an argument, you can specify:"
msgstr "В качестве аргумента можно указать:"

#: ../doc/reference/tarantoolctl.rst:152
msgid ""
"a ``.rockspec`` file to create a source rock containing the module's "
"sources, or"
msgstr ""
"файл в формате ``.rockspec`` для создания модуля, который содержит "
"исходные файлы или"

#: ../doc/reference/tarantoolctl.rst:154
msgid ""
"the name of an installed module (and its version if there are more than "
"one) to create a binary rock containing the compiled module."
msgstr ""
"имя установленного модуля (с версией, если их больше одной) для создания "
"модуля, который содержит скомпилированные файлы."

#: ../doc/reference/tarantoolctl.rst:165
msgid ""
"``tarantoolctl rocks unpack {<rock_file> | <rockspec> | <name> "
"[version]}``"
msgstr "``tarantoolctl rocks unpack {<rock_file> | <rockspec> | <имя> [версия]}``"

#: ../doc/reference/tarantoolctl.rst:158
msgid "Unpack the contents of a rock into a new directory under the current one."
msgstr "Распаковка содержимого модуля в новую директорию в текущей директории."

#: ../doc/reference/tarantoolctl.rst:162
msgid "source or binary rock files,"
msgstr "исходные или бинарные файлы модуля,"

#: ../doc/reference/tarantoolctl.rst:163
msgid "``.rockspec`` files, or"
msgstr "файлы ``.rockspec`` или"

#: ../doc/reference/tarantoolctl.rst:164
msgid ""
"names of rocks or ``.rockspec`` files in remote repositories (and the "
"rock version if there are more than one)."
msgstr ""
"имя модулей или файлов в формате ``.rockspec`` в удаленных репозиториях "
"(с версией модуля, если их больше одной)."

#: ../doc/reference/tarantoolctl.rst:169
msgid "``--server=server_name`` check this server first, then the usual list."
msgstr "``--server=имя_севрера`` сначала проверить данный сервер, затем по списку."

#: ../doc/reference/tarantoolctl.rst:170
msgid ""
"``--only-server=server_name`` check this server only, ignore the usual "
"list."
msgstr ""
"``--only-server=имя_сервера`` проверить только данный сервер, остальные "
"пропустить."

#~ msgid "the maximum number of entries in the connection cache."
#~ msgstr "максимальное количество записей в кэше соединения."

#~ msgid ""
#~ "The ``json`` module provides JSON "
#~ "manipulation routines. It is based on"
#~ " the `Lua-CJSON module by Mark "
#~ "Pulford`_. For a complete manual on "
#~ "Lua-CJSON please read `the official "
#~ "documentation`_."
#~ msgstr ""
#~ "Модуль ``json`` обеспечивает процедуры работы"
#~ " с форматом JSON. Он основан на "
#~ "`модуле Lua-CJSON от Mark Pulford`_. "
#~ "Полное руководство по Lua-CJSON включено"
#~ " в официальную документацию (`the official"
#~ " documentation`_)."

#~ msgid "Configuration settings"
#~ msgstr "Параметры конфигурации"

#~ msgid ""
#~ "There are configuration settings which "
#~ "affect the way that Tarantool encodes"
#~ " invalid numbers or types. They are"
#~ " all boolean ``true``/``false`` values"
#~ msgstr ""
#~ "Следующие параметры конфигурации определяют, "
#~ "как Tarantool кодирует недопустимые числа "
#~ "или типы. Значения параметров -- "
#~ "логические ``true``/``false`` (правда/ложь)."

#~ msgid ""
#~ "``cfg.decode_use_tostring`` (default is false) "
#~ "-- use tostring for unrecognizable types"
#~ msgstr ""
#~ "``cfg.encode_use_tostring`` (по умолчанию, false)"
#~ " -- использовать tostring для "
#~ "нераспознаваемых типов"

#~ msgid ""
#~ "The actual output will be a line"
#~ " containing:  * the current timestamp, "
#~ "* a module name, * 'E', 'W', "
#~ "'I', 'V' or 'D' depending on "
#~ "``log_level_function_name``, and * ``message``.  "
#~ "Output will not occur if "
#~ "``log_level_function_name`` is for a type "
#~ "greater than :ref:`log_level <cfg_logging-"
#~ "log_level>`.  Messages may contain C-style "
#~ "format specifiers %d or %s, so "
#~ ":samp:`log.error('...%d...%s', {x}, {y})` will "
#~ "work if ``x`` is a number and "
#~ "``y`` is a string."
#~ msgstr ""
#~ "Выходное значение будет представлять собой "
#~ "строку, которая содержит следующее: * "
#~ "текущая временная отметка, * название "
#~ "модуля, * 'E', 'W', 'I', 'V' или"
#~ " 'D' в зависимости от "
#~ "``log_level_function_name`` и * ``сообщение``. "
#~ "Вывода не будет, если "
#~ "``log_level_function_name`` соответствует типу "
#~ "больше, чем :ref:`log_level <cfg_logging-"
#~ "log_level>`.  Сообщения могут содержать "
#~ "спецификаторы формата в стиле C: %d "
#~ "или %s, то есть :samp:`log.error('...%d...%s',"
#~ " {x}, {y})` сработает, если ``x`` --"
#~ " это число, а ``y`` -- это "
#~ "строка."

#~ msgid "The module is fully built-in so ``require('utf8')`` is not necessary."
#~ msgstr ""
#~ "Модуль является встроенным, поэтому нет "
#~ "необходимости выполнять команду ``require('utf8')``."

#~ msgid ""
#~ "tarantool> fiber.self():cancel() -- kill self, may make program end\n"
#~ "---\n"
#~ "- error: fiber is cancelled\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> fiber.self():cancel() -- функция с"
#~ " self может вызвать окончание программы"
#~ "\n"
#~ "---\n"
#~ "- error: fiber is cancelled\n"
#~ "..."

#~ msgid "Module `jit`"
#~ msgstr "Модуль `jit`"

#~ msgid ""
#~ "The ``jit`` module has functions for "
#~ "tracing the `LuaJIT <http://luajit.org>`_ "
#~ "Just-In-Time compiler's progress, showing"
#~ " the byte-code or assembler output"
#~ " that the compiler produces, and in"
#~ " general providing information about what"
#~ " LuaJIT does with Lua code."
#~ msgstr ""
#~ "В модуле ``jit`` есть функции для "
#~ "отслеживания работы Just-In-Time "
#~ "компилятора `LuaJIT <http://luajit.org>`_, которые"
#~ " показывают вывод байт-кода или языка "
#~ "ассемблера, который генерирует компилятор, и"
#~ " в целом обеспечивают информацию о "
#~ "том, что LuaJIT делает с кодом на"
#~ " Lua."

#~ msgid "Below is a list of all ``jit`` functions."
#~ msgstr "Ниже приведен перечень всех функций модуля ``jit``."

#~ msgid ":ref:`jit.bc.dump() <jit-bc-dump>`"
#~ msgstr ":ref:`jit.bc.dump() <jit-bc-dump>`"

#~ msgid "Print the byte code of a function"
#~ msgstr "Вывод байт-кода функции"

#~ msgid ":ref:`jit.dis_x86.disass() <jit-dis-x86-disass>`"
#~ msgstr ":ref:`jit.dis_x86.disass() <jit-dis-x86-disass>`"

#~ msgid "Print the i386 assembler code of a string of bytes"
#~ msgstr "Вывод кода на языке ассемблере i386 из строки байтов"

#~ msgid ":ref:`jit.dis_x64.disass() <jit-dis-x64-disass>`"
#~ msgstr ":ref:`jit.dis_x64.disass() <jit-dis-x64-disass>`"

#~ msgid "Print the x86-64 assembler code of a string of bytes"
#~ msgstr "Вывод кода на языке ассемблере x86-64 из строки байтов"

#~ msgid ""
#~ ":ref:`jit.dump.on() <jit-dump-on>`, "
#~ ":ref:`jit.dump.off() <jit-dump-off>`"
#~ msgstr ""
#~ ":ref:`jit.dump.on() <jit-dump-on>`, "
#~ ":ref:`jit.dump.off() <jit-dump-off>`"

#~ msgid "Print the intermediate or machine code of the following Lua code"
#~ msgstr "Вывод промежуточного или машинного кода из следующего кода на Lua"

#~ msgid ":ref:`jit.v.on() <jit-v-on>`, :ref:`jit.v.off() <jit-v-off>`"
#~ msgstr ":ref:`jit.v.on() <jit-v-on>`, :ref:`jit.v.off() <jit-v-off>`"

#~ msgid "Print a trace of LuaJIT's progress compiling and interpreting code"
#~ msgstr "Вывод трассировки компиляции LuaJIT и интерпретируемого кода"

#~ msgid "Prints the byte code of a function."
#~ msgstr "Выводит байт-код функции."

#~ msgid ""
#~ "function f()\n"
#~ "  print(\"D\")\n"
#~ "end\n"
#~ "jit.bc.dump(f)"
#~ msgstr ""
#~ "function f()\n"
#~ "  print(\"D\")\n"
#~ "end\n"
#~ "jit.bc.dump(f)"

#~ msgid ""
#~ "For a list of available options, "
#~ "read `the source code of bc.lua "
#~ "<https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/bc.lua>`_."
#~ msgstr ""
#~ "Перечень доступных параметров см. в "
#~ "`исходном коде bc.lua "
#~ "<https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/bc.lua>`_."

#~ msgid "Prints the i386 assembler code of a string of bytes."
#~ msgstr "Выводит код на языке ассемблера i386 из строки байтов."

#~ msgid ""
#~ "-- Disassemble hexadecimal 97 which is the x86 code for xchg eax, edi\n"
#~ "jit.dis_x86.disass('\\x97')"
#~ msgstr ""
#~ "-- Дизассемблировать в шестнадцатеричной "
#~ "системе 97, что представляет собой код"
#~ " в x86 для xchg eax, edi\n"
#~ "jit.dis_x86.disass('\\x97')"

#~ msgid ""
#~ "For a list of available options, "
#~ "read `the source code of dis_x86.lua "
#~ "<https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/dis_x86.lua>`_."
#~ msgstr ""
#~ "Перечень доступных параметров см. в "
#~ "`исходном коде dis_x86.lua "
#~ "<https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/dis_x86.lua>`_."

#~ msgid "Prints the x86-64 assembler code of a string of bytes."
#~ msgstr "Выводит код на языке ассемблера x86-64 из строки байтов."

#~ msgid ""
#~ "-- Disassemble hexadecimal 97 which is"
#~ " the x86-64 code for xchg eax, "
#~ "edi\n"
#~ "jit.dis_x64.disass('\\x97')"
#~ msgstr ""
#~ "-- Дизассемблировать в шестнадцатеричной "
#~ "системе 97, что представляет собой код"
#~ " в x86-64 для xchg eax, edi\n"
#~ "jit.dis_x64.disass('\\x97')"

#~ msgid ""
#~ "For a list of available options, "
#~ "read `the source code of dis_x64.lua "
#~ "<https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/dis_x64.lua>`_."
#~ msgstr ""
#~ "Перечень доступных параметров см. в "
#~ "`исходном коде dis_x64.lua "
#~ "<https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/dis_x64.lua>`_."

#~ msgid "Prints the intermediate or machine code of the following Lua code."
#~ msgstr "Выводит промежуточный или машинный код из следующего кода на Lua."

#~ msgid ""
#~ "-- Show the machine code of a Lua \"for\" loop\n"
#~ "jit.dump.on('m')\n"
#~ "local x = 0;\n"
#~ "for i = 1, 1e6 do\n"
#~ "  x = x + i\n"
#~ "end\n"
#~ "print(x)\n"
#~ "jit.dump.off()"
#~ msgstr ""
#~ "-- Показать машинный код цикла \"for\" на Lua\n"
#~ "jit.dump.on('m')\n"
#~ "local x = 0;\n"
#~ "for i = 1, 1e6 do\n"
#~ "  x = x + i\n"
#~ "end\n"
#~ "print(x)\n"
#~ "jit.dump.off()"

#~ msgid ""
#~ "For a list of available options, "
#~ "read `the source code of dump.lua "
#~ "<https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/dump.lua>`_."
#~ msgstr ""
#~ "Перечень доступных параметров см. в "
#~ "`исходном коде dump.lua "
#~ "<https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/dump.lua>`_."

#~ msgid "Prints a trace of LuaJIT's progress compiling and interpreting code."
#~ msgstr "Выводит трассировку компиляции LuaJIT и интерпретируемого кода"

#~ msgid ""
#~ "-- Show what LuaJIT is doing for a Lua \"for\" loop\n"
#~ "jit.v.on()\n"
#~ "local x = 0\n"
#~ "for i = 1, 1e6 do\n"
#~ "    x = x + i\n"
#~ "end\n"
#~ "print(x)\n"
#~ "jit.v.off()"
#~ msgstr ""
#~ "-- Показать, что делает LuaJIT для цикла \"for\" на Lua\n"
#~ "jit.v.on()\n"
#~ "local x = 0\n"
#~ "for i = 1, 1e6 do\n"
#~ "    x = x + i\n"
#~ "end\n"
#~ "print(x)\n"
#~ "jit.v.off()"

#~ msgid ""
#~ "For a list of available options, "
#~ "read `the source code of v.lua "
#~ "<https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/v.lua>`_."
#~ msgstr ""
#~ "Перечень доступных параметров см. в "
#~ "`исходном коде v.lua "
#~ "<https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/v.lua>`_."

#~ msgid ""
#~ "There are two different approaches for"
#~ " scaling data, `vertical and horizontal "
#~ "scaling "
#~ "<https://en.wikipedia.org/wiki/Scalability#Horizontal_and_vertical_scaling>`_:"
#~ msgstr ""
#~ "Есть два различных подхода к "
#~ "масштабированию данных: `вертикальное и "
#~ "горизонтальное масштабирование "
#~ "<https://en.wikipedia.org/wiki/Scalability#Horizontal_and_vertical_scaling>`_:"

#~ msgid ""
#~ "*Vertical scaling* implies that the "
#~ "hardware capacities of a single server"
#~ " would be increased."
#~ msgstr ""
#~ "*Вертикальное масштабирование* подразумевает "
#~ "увеличение производительности системы отдельного "
#~ "сервера."

#~ msgid ""
#~ "*Horizontal scaling* implies that a "
#~ "dataset is partitioned and distributed "
#~ "over multiple servers. In case new "
#~ "servers are added, the dataset is "
#~ "re-distributed evenly across all servers,"
#~ " both the original and new ones."
#~ msgstr ""
#~ "*Горизонтальное масштабирование* подразумевает "
#~ "секционирование набора данных и распределение"
#~ " данных по множеству серверов. При "
#~ "добавлении новых серверов набор данных "
#~ "повторно равномерно распределяется по всем "
#~ "серверам, новым и старым."

#~ msgid "Sharding is a database architecture that allows for horizontal scaling."
#~ msgstr ""
#~ "Шардинг, или сегментирование, представляет "
#~ "собой архитектуру базы данных, которая "
#~ "предоставляет возможность горизонтального "
#~ "масштабирования."

#~ msgid ""
#~ "The ``vshard`` module is based on "
#~ "the concept of virtual buckets, where"
#~ " a tuple set is partitioned into "
#~ "a large number of abstract virtual "
#~ "nodes (virtual buckets, or buckets) "
#~ "rather than into a smaller number "
#~ "of physical nodes."
#~ msgstr ""
#~ "Модуль ``vshard`` основан на концепции "
#~ "виртуальных сегментов: набор кортежей "
#~ "распределяется на большое количество "
#~ "абстрактных виртуальных узлов (виртуальных "
#~ "сегментов, или сегментов), а не на "
#~ "малое количество физических узлов."

#~ msgid ""
#~ "Hashing a sharding key into a "
#~ "large number of virtual buckets allows"
#~ " seamlessly changing the number of "
#~ "servers in the cluster. The rebalancing"
#~ " mechanism distributes buckets evenly among"
#~ " all shards in case some servers "
#~ "were added or removed."
#~ msgstr ""
#~ "Хеширование сегментного ключа в большое "
#~ "количество виртуальных сегментов позволяет "
#~ "незаметно для пользователя изменять количество"
#~ " серверов в кластере. Механизм "
#~ "балансирования распределяет сегменты между "
#~ "шардами, если некоторые серверы добавляются"
#~ " или убираются."

#~ msgid ""
#~ "The ``example/`` directory of `the "
#~ "vshard git-repository "
#~ "<https://github.com/tarantool/vshard>`_ includes a "
#~ "pre-configured development cluster of 1 "
#~ "``router`` and 2 replica sets of 2"
#~ " nodes (2 ``storages``) each, making "
#~ "5 Tarantool instances in total:"
#~ msgstr ""
#~ "В директории ``example/`` из `git-репозитория"
#~ " vshard <https://github.com/tarantool/vshard>`_ "
#~ "находится предварительно настроенный кластер "
#~ "из 1 роутера и 2 наборов реплик"
#~ " из 2 узлов (2 хранилища) в "
#~ "каждом, что составляет всего 5 "
#~ "экземпляров Tarantool'а в целом:"

#~ msgid ""
#~ "A sharded cluster in Tarantool consists"
#~ " of storages, routers, and a "
#~ "rebalancer."
#~ msgstr ""
#~ "Сегментированный кластер в Tarantool'е состоит"
#~ " из хранилищ, роутеров и балансировщика."

#~ msgid ""
#~ "A **rebalancer** is an internal "
#~ "component that distributes the dataset "
#~ "among all shards evenly in case "
#~ "some servers are added or removed. "
#~ "It also balances the load considering"
#~ " the capacities of existing replica "
#~ "sets."
#~ msgstr ""
#~ "**Балансировщик** (rebalancer) -- это "
#~ "внутренний компонент, который равномерно "
#~ "распределяет набор данных между всеми "
#~ "шардами в случае добавления или удаления"
#~ " серверов. Он также занимается "
#~ "выравниванием нагрузки с учетом "
#~ "производительности существующих наборов реплик."

#~ msgid "Configuring a sharded cluster"
#~ msgstr "Конфигурация сегментированного кластера"

#~ msgid ""
#~ "This cluster includes one ``router`` "
#~ "instance and two ``storage`` instances. "
#~ "Each ``storage`` instance includes one "
#~ "master and one replica."
#~ msgstr ""
#~ "Данный кластер включает в себя один "
#~ "роутер (``router``) и два хранилища "
#~ "(``storage``). Каждое хранилище включает в "
#~ "себя один мастер и одну реплику."

#~ msgid ""
#~ "The sharding field defines the logical"
#~ " topology of a sharded Tarantool "
#~ "cluster. All the other fields are "
#~ "passed to ``box.cfg()`` as they are, "
#~ "without modifications. See the "
#~ ":ref:`Configuration reference <vshard-config-"
#~ "reference>` section for details."
#~ msgstr ""
#~ "Поле sharding (шардинг) определяет логическую"
#~ " топологию сегментированного кластера "
#~ "Tarantool'а. Все остальные поля передаются "
#~ "в ``box.cfg()`` в неизменном виде. Для"
#~ " получения подробной информации см. раздел"
#~ " :ref:`Справочник по настройке <vshard-"
#~ "config-reference>`."

#~ msgid ""
#~ "See ``router.lua`` and ``storage.lua`` in "
#~ "the ``vshard/example`` directory for a "
#~ "sample configuration."
#~ msgstr ""
#~ "Образец конфигурации можно посмотреть в "
#~ "файлах ``router.lua`` и ``storage.lua`` в "
#~ "директории ``vshard/example``."

#~ msgid ""
#~ "The mode parameter has two possible "
#~ "forms: a string or a map. Examples"
#~ " of the string form are: 'read', "
#~ "'write'. Examples of the map form "
#~ "are: {mode='read'}, {mode='write'}, {mode='read',"
#~ " prefer_replica=true}, {mode='read', balance=true}, "
#~ "{mode='read', prefer_replica=true, balance=true}. If"
#~ " 'write' is specified then the target"
#~ " is the master. If prefer_replica=true "
#~ "is specified then the preferred target"
#~ " is one of the replicas, but "
#~ "the target is the master if there"
#~ " is no conveniently available replica. "
#~ "It may be good to specify "
#~ "prefer_replica=true for functions which are"
#~ " expensive in terms of resource use,"
#~ " to avoid slowing down the master."
#~ " If balance=true then there is load"
#~ " balancing -- reads are distributed "
#~ "over all the nodes in the replica"
#~ " set in round-robin fashion, with "
#~ "a preference for replicas if "
#~ "prefer_replica=true is also set."
#~ msgstr ""
#~ "У параметра режима mode есть две "
#~ "доступные формы: строка или ассоциативный "
#~ "массив. Примеры строки: 'read' (чтение), "
#~ "'write' (запись). Примеры ассоциативного "
#~ "массива: {mode='read'}, {mode='write'}, "
#~ "{mode='read', prefer_replica=true}, {mode='read', "
#~ "balance=true}, {mode='read', prefer_replica=true, "
#~ "balance=true}. Если указать значение 'write'"
#~ " (запись), то целью будет мастер. "
#~ "Если указать prefer_replica=true, то "
#~ "предпочитаемая цель -- одна из реплик;"
#~ " если же доступной реплики нет, то"
#~ " целью будет мастер. Удобно указать "
#~ "prefer_replica=true для ресурсозатратных функций "
#~ "во избежание замедления работы мастера. "
#~ "Если задать balance=true, добавится "
#~ "балансировка нагрузки -- чтения распределяются"
#~ " по всем узлам набора реплик по "
#~ "кругу, предпочтение отдается репликам, если"
#~ " также задан параметр prefer_replica=true."

#~ msgid ""
#~ "``ShardingError`` is returned on errors "
#~ "specific for sharding: the replica set"
#~ " is not available, the master is "
#~ "missing, wrong bucket id, etc. It "
#~ "has an attribute code containing one "
#~ "of the values from the "
#~ "``vshard.error.code.*`` LUA table, an optional"
#~ " attribute containing a message with "
#~ "the human-readable error description, "
#~ "and other attributes specific for the"
#~ " error code."
#~ msgstr ""
#~ "``ShardingError`` возвращается в случае ошибок"
#~ " шардинга: набор реплик недоступен, "
#~ "отсутствует мастер, неверный идентификатор "
#~ "сегмента и т.д. Такая ошибка содержит"
#~ " код с одним из значений из "
#~ "Lua-таблицы ``vshard.error.code.*``, необязательный "
#~ "атрибут сообщения с удобным для "
#~ "восприятия описанием ошибки и другие "
#~ "атрибуты, специфичные для данного кода "
#~ "ошибки."

#~ msgid ""
#~ "If ``log_nonblock`` equals true, Tarantool "
#~ "does not block on the log file "
#~ "descriptor when it’s not ready for "
#~ "write, and drops the message instead."
#~ " If :ref:`log_level <cfg_logging-log_level>` "
#~ "is high, and many messages go to"
#~ " the log file, setting ``log_nonblock`` "
#~ "to true may improve logging performance"
#~ " at the cost of some log "
#~ "messages getting lost."
#~ msgstr ""
#~ "Если значение ``log_nonblock`` равно true "
#~ "(правда), Tarantool не блокирует дескриптор"
#~ " файла журнала, когда он не готов "
#~ "вести запись, а вместо этого сбрасывает"
#~ " сообщение. Если задан высокий уровень "
#~ ":ref:`log_level <cfg_logging-log_level>`,и много "
#~ "сообщений попадают в файл журнала, "
#~ "перевод ``log_nonblock`` в true может "
#~ "улучшить производительность ценой потери "
#~ "некоторых сообщений журнала."

#~ msgid ""
#~ "1. You may want to control the "
#~ "maximum number of sockets that a "
#~ "particular http client uses simultaneously."
#~ " If a system passes many requests "
#~ "to distinct hosts, then libcurl cannot"
#~ " reuse sockets. In this case setting"
#~ " ``max_total_connections`` may be useful, "
#~ "since it causes curl to avoid "
#~ "creating too many sockets which would"
#~ " not be used anyway."
#~ msgstr ""
#~ "1. Возможно, вы захотите регулировать "
#~ "максимальное количество сокетов, которые "
#~ "конкретный http-клиент использует одновременно. "
#~ "Если система передает много запросов "
#~ "различным хостам, то libcurl не может"
#~ " повторно использовать сокеты. В этом "
#~ "случае важен параметр``max_total_connections``, "
#~ "поскольку он запретит curl создавать "
#~ "слишком большое количество сокетов, которые"
#~ " все равно не будут использоваться."

#~ msgid "Miscellaneous"
#~ msgstr "Разное"

#~ msgid "Below is a list of miscellaneous functions."
#~ msgstr "Ниже приведен перечень разных доступных функций."

#~ msgid "Return the value of the input string, but without spaces on the left."
#~ msgstr "Возврат значения введенной строки без пробелов слева."

#~ msgid "Return the value of the input string, but without spaces on the right."
#~ msgstr "Возврат значения введенной строки без пробелов справа."

#~ msgid ""
#~ "Return the value of the input "
#~ "string, but without spaces on the "
#~ "left or the right."
#~ msgstr "Возврат значения введенной строки без пробелов слева или справа."

#~ msgid "Below is a list of all ``tap`` functions."
#~ msgstr "Ниже приведен перечень всех функций модуля ``tap``."

#~ msgid ""
#~ "tarantool> tarantool = require('tarantool')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> tarantool\n"
#~ "---\n"
#~ "- build:\n"
#~ "    target: Linux-x86_64-RelWithDebInfo\n"
#~ "    options: cmake . "
#~ "-DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
#~ "    mod_format: so\n"
#~ "    flags: ' -fno-common -fno-"
#~ "omit-frame-pointer -fno-stack-protector "
#~ "-fexceptions\n"
#~ "      -funwind-tables -fopenmp -msse2 "
#~ "-std=c11 -Wall -Wextra -Wno-sign-compare"
#~ " -Wno-strict-aliasing\n"
#~ "      -fno-gnu89-inline'\n"
#~ "    compiler: /usr/bin/x86_64-linux-gnu-gcc"
#~ " /usr/bin/x86_64-linux-gnu-g++\n"
#~ "  uptime: 'function: 0x408668e0'\n"
#~ "  version: 1.7.0-66-g9093daa\n"
#~ "  pid: 'function: 0x40866900'\n"
#~ "...\n"
#~ "tarantool> tarantool.pid()\n"
#~ "---\n"
#~ "- 30155\n"
#~ "...\n"
#~ "tarantool> tarantool.uptime()\n"
#~ "---\n"
#~ "- 108.64641499519\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> tarantool = require('tarantool')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> tarantool\n"
#~ "---\n"
#~ "- build:\n"
#~ "    target: Linux-x86_64-RelWithDebInfo\n"
#~ "    options: cmake . "
#~ "-DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
#~ "    mod_format: so\n"
#~ "    flags: ' -fno-common -fno-"
#~ "omit-frame-pointer -fno-stack-protector "
#~ "-fexceptions\n"
#~ "      -funwind-tables -fopenmp -msse2 "
#~ "-std=c11 -Wall -Wextra -Wno-sign-compare"
#~ " -Wno-strict-aliasing\n"
#~ "      -fno-gnu89-inline'\n"
#~ "    compiler: /usr/bin/x86_64-linux-gnu-gcc"
#~ " /usr/bin/x86_64-linux-gnu-g++\n"
#~ "  uptime: 'function: 0x408668e0'\n"
#~ "  version: 1.7.0-66-g9093daa\n"
#~ "  pid: 'function: 0x40866900'\n"
#~ "...\n"
#~ "tarantool> tarantool.pid()\n"
#~ "---\n"
#~ "- 30155\n"
#~ "...\n"
#~ "tarantool> tarantool.uptime()\n"
#~ "---\n"
#~ "- 108.64641499519\n"
#~ "..."

#~ msgid "A minimal viable sharded cluster should consist of:"
#~ msgstr "Минимальный рабочий сегментированный кластер должен состоять из:"

#~ msgid ""
#~ "The ``rebalancer`` wakes up periodically "
#~ "and redistributes data from the most "
#~ "loaded nodes to less loaded nodes. "
#~ "Rebalancing starts if the disbalance "
#~ "threshold of a replica set exceeds "
#~ "a disbalance threshold specified in the"
#~ " configuration."
#~ msgstr ""
#~ "``Балансировщик`` периодически просыпается и "
#~ "перераспределяет данные из наиболее "
#~ "загруженных узлов в менее загруженные "
#~ "узлы. Балансировка начинается, когда предел"
#~ " дисбаланса в наборе реплик превышает "
#~ "предел дисбаланса, указанный в конфигурации."

