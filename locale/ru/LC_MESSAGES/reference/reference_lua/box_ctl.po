
msgid "Submodule `box.ctl`"
msgstr "Вложенный модуль `box.ctl`"

msgid ""
"The ``box.ctl`` submodule contains two functions: ``wait_ro`` (wait until"
" read-only) and ``wait_rw`` (wait until read-write). The functions are "
"useful during initialization of a server."
msgstr ""
"Вложенный модуль ``box.ctl`` включает в себя две функции: ``wait_ro`` "
"(дождаться режима только для чтения) и ``wait_rw`` (дождаться режима "
"чтения и записи). Эти функции используются во время инициализации "
"сервера."

msgid ""
"A particular use is for :doc:`box.once() "
"</reference/reference_lua/box_once>`. For example, when a replica is "
"initializing, it may call a ``box.once()`` function while the server is "
"still in read-only mode, and fail to make changes that are necessary only"
" once before the replica is fully initialized. This could cause conflicts"
" between a master and a replica if the master is in read-write mode and "
"the replica is in read-only mode. Waiting until \"read only mode = "
"false\" solves this problem."
msgstr ""
"Для :doc:`box.once() </reference/reference_lua/box_once>` есть особое "
"предназначение. Например, при инициализации реплика может вызвать функцию"
" ``box.once()``, пока сервер все еще находится в режиме только для "
"чтения, и не сможет применить изменения однократно до окончательной "
"инициализации реплики. Это может привести к конфликту между мастером и "
"репликой, если мастер находится в режиме чтения и записи, а реплика "
"доступна только для чтения. Ожидание условия \"read only mode = false\" "
"(режим только для чтения отключен) решает эту проблему."

msgid ""
"To see whether a function is already in read-only or read-write mode, "
"check :ref:`box.info.ro <box_introspection-box_info>`."
msgstr ""
"Чтобы проверить режим функции -- только для чтения или чтение и запись, "
"используйте :ref:`box.info.ro <box_introspection-box_info>`."

msgid "Below is a list of all ``box.ctl`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``box.ctl``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Использование"

msgid ":doc:`./box_ctl/wait_ro`"
msgstr ""

msgid "Wait until ``box.info.ro`` is true"
msgstr "Дождаться, пока не будет выполнено ``box.info.ro``"

msgid ":doc:`./box_ctl/wait_rw`"
msgstr ""

msgid "Wait until ``box.info.ro`` is false"
msgstr "Дождаться, пока не перестанет соблюдаться ``box.info.ro``"

#~ msgid ""
#~ "The ``box.ctl`` submodule also contains "
#~ "two functions for the two :ref:`server"
#~ " trigger <triggers>` definitions: ``on_shutdown``"
#~ " and ``on_schema_init``. Please, familiarize "
#~ "yourself with the mechanism of trigger"
#~ " functions before using them."
#~ msgstr ""
#~ "Встроенный модуль ``box.ctl`` также содержит"
#~ " две функции для определения двух "
#~ ":ref:`серверных триггеров <triggers>`: "
#~ "``on_shutdown`` и ``on_schema_init``. Пожалуйста,"
#~ " ознакомьтесь с механизмом триггерных "
#~ "функций перед их использованием."

#~ msgid ""
#~ "Create a \"shutdown :ref:`trigger "
#~ "<triggers>`\". The ``trigger-function`` will"
#~ " be executed whenever   :ref:`os.exit() "
#~ "<os-exit>` happens, or when the "
#~ "server is shut down after receiving "
#~ "a SIGTERM or SIGINT or SIGHUP "
#~ "signal (but not after SIGSEGV or "
#~ "SIGABORT or any signal that causes "
#~ "immediate program termination)."
#~ msgstr ""
#~ "Создать \":ref:`триггер <triggers>` выключения\"."
#~ " Триггер-функция будет выполняться всякий "
#~ "раз, когда происходит :ref:`os.exit() <os-"
#~ "exit>`, или когда сервер выключается "
#~ "после получения сигнала SIGTERM или "
#~ "SIGINT или SIGHUP (но не после "
#~ "сигнала SIGSEGV или SIGABORT или любого"
#~ " другого сигнала, вызывающего немедленное "
#~ "завершение программы)."

#~ msgid "function which will become the trigger function"
#~ msgstr "функция, в которой будет триггер"

#~ msgid "existing trigger function which will be replaced by trigger-function"
#~ msgstr "существующая функция с триггером, которую заменит новая"

#~ msgid "nil or function pointer"
#~ msgstr "nil или указатель функции"

#~ msgid ""
#~ "If the parameters are (nil, old-"
#~ "trigger-function), then the old trigger "
#~ "is deleted."
#~ msgstr ""
#~ "Если указаны параметры (nil, old-"
#~ "trigger-function), старый триггер будет "
#~ "удален."

#~ msgid ""
#~ "Details about trigger characteristics are "
#~ "in the :ref:`triggers <triggers-box_triggers>`"
#~ " section."
#~ msgstr ""
#~ "Подробная информация о характеристиках "
#~ "триггера находится в разделе :ref:`Триггеры"
#~ " <triggers-box_triggers>`."

#~ msgid ""
#~ "Create a \"schema_init :ref:`trigger "
#~ "<triggers>`\". The ``trigger-function`` will"
#~ " be executed when :ref:`box.cfg{} "
#~ "<index-book_cfg>` happens for the first "
#~ "time. That is, the ``schema_init`` "
#~ "trigger is called before the server's"
#~ " configuration and recovery begins, and "
#~ "therefore ``box.ctl.on_schema_init`` must be "
#~ "called before ``box.cfg`` is called."
#~ msgstr ""
#~ "Создать :ref:`триггер <triggers>` ``schema_init``."
#~ " Функция триггера будет выполнена, когда"
#~ " :ref:`box.cfg{} <index-book_cfg>` произойдет "
#~ "в первый раз. То есть триггер "
#~ "``schema_init`` вызывается до начала "
#~ "конфигурирования и восстановления сервера, и"
#~ " поэтому ``box.ctl.on_schema_init`` должен быть"
#~ " вызван до вызова ``box.cfg``."

#~ msgid ""
#~ "A common use is: make a "
#~ "``schema_init`` trigger function which creates"
#~ " a ``before_replace`` trigger function on"
#~ " a system space. Thus, since system"
#~ " spaces are created when the server"
#~ " starts, the ``before_replace`` triggers "
#~ "will be activated for each tuple "
#~ "in each system space. For example, "
#~ "such a trigger could change the "
#~ "storage engine of a given space, "
#~ "or make a given space :ref:`replica-"
#~ "local <replication-local>` while a "
#~ "replica is being bootstrapped. Making "
#~ "such a change after ``box.cfg`` is "
#~ "not reliable because other connections "
#~ "might use the database before the "
#~ "change is made."
#~ msgstr ""
#~ "Обычно используется следующее: сделать "
#~ "триггерную функцию ``schema_init``, которая "
#~ "создает триггерную функцию ``before_replace`` "
#~ "на системном спейсе. Таким образом, "
#~ "поскольку системные спейсы создаются при "
#~ "старте сервера, триггеры ``before_replace`` "
#~ "будут активированы для каждого кортежа в"
#~ " каждом системном спейсе. Например, такой"
#~ " триггер может изменить механизм хранения"
#~ " заданного спейса, или сделать заданный "
#~ "спейс :ref:`локальной репликой <replication-"
#~ "local>` во время загрузки реплики. "
#~ "Выполнение такого изменения после ``box.cfg``"
#~ " не является надежным, поскольку другие "
#~ "подключения могут использовать базу данных "
#~ "до внесения изменения."

#~ msgid ""
#~ "Suppose that, before the server is "
#~ "fully up and ready for connections, "
#~ "you want to make sure that the "
#~ "engine of space ``space_name`` is vinyl."
#~ " So you want to make a trigger"
#~ " that will be activated when a "
#~ "tuple is inserted in the ``_space`` "
#~ "system space. In this case you "
#~ "could end up with a master that"
#~ " has space-name with ``engine='memtx'`` "
#~ "and a replica that has space_name "
#~ "with ``engine='vinyl'``, with the same "
#~ "contents."
#~ msgstr ""
#~ "Предположим, что до того, как сервер "
#~ "будет полностью готов к подключениям, вы"
#~ " хотите убедиться, что движком "
#~ "``space_name`` является vinyl. Поэтому вы "
#~ "хотите сделать триггер, который будет "
#~ "активирован при вставке кортежа в "
#~ "системный спейс ``_space``. В этом "
#~ "случае может получиться мастер, который "
#~ "имеет space-name с ``engine='memtx'`` и"
#~ " реплику, которая имеет space_name с "
#~ "``engine='vinyl'``, с тем же самым "
#~ "содержимым."

#~ msgid ""
#~ "function function_for_before_replace(old, new)\n"
#~ "  if old == nil and new ~="
#~ " nil and new[3] == 'space_name' and"
#~ " new[4] ~= 'vinyl' then\n"
#~ "    return new:update{{'=', 4, 'vinyl'}}\n"
#~ "  end\n"
#~ "end\n"
#~ "\n"
#~ "box.ctl.on_schema_init(function()\n"
#~ "  box.space._space:before_replace(function_for_before_replace)\n"
#~ "end)\n"
#~ "\n"
#~ "box.cfg{replication='master_uri', ...}"
#~ msgstr ""
