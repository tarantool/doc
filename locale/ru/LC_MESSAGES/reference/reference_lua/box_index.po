
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.index`"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"The ``box.index`` submodule provides read-only access for index "
"definitions and index keys. Indexes are contained in :samp:`box.space"
".{space-name}.index` array within each space object. They provide an API "
"for ordered iteration over tuples. This API is a direct binding to "
"corresponding methods of index objects of type ``box.index`` in the "
"storage engine."
msgstr ""
"Вложенный модуль ``box.index`` обеспечивает доступ к схемам индекса и "
"ключам индекса в режиме только для чтения. Индексы хранятся в массиве "
":samp:`box.space.{имя-спейса}.index` в каждом спейсе. Они предоставляют "
"API для упорядоченной итерации по кортежам. Этот API представляет собой "
"прямую привязку к соответствующим методам объектов типа``box.index`` в "
"движке базы данных."

msgid "Index"
msgstr "Индекс"

msgid "Below is a list of all ``box.index`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``box.index``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Использование"

msgid ":ref:`index_object.unique <box_index-unique>`"
msgstr ":ref:`index_object.unique <box_index-unique>`"

msgid "Flag, true if an index is unique"
msgstr "Флаг, если индекс уникальный -- true"

msgid ":ref:`index_object.type <box_index-type>`"
msgstr ":ref:`index_object.type <box_index-type>`"

msgid "Index type"
msgstr "Тип индекса"

msgid ":ref:`index_object.parts <box_index-parts>`"
msgstr ":ref:`index_object.parts <box_index-parts>`"

msgid "Array of index key fields"
msgstr "Массив полей с ключами индекса"

msgid ":ref:`index_object:pairs() <box_index-index_pairs>`"
msgstr ":ref:`index_object:pairs() <box_index-index_pairs>`"

msgid "Prepare for iterating"
msgstr "Подготовка к итерации"

msgid ":ref:`index_object:select() <box_index-select>`"
msgstr ":ref:`index_object:select() <box_index-select>`"

msgid "Select one or more tuples via index"
msgstr "Выбор одного или более кортежей по индексу"

msgid ":ref:`index_object:get() <box_index-get>`"
msgstr ":ref:`index_object:get() <box_index-get>`"

msgid "Select a tuple via index"
msgstr "Выбор кортежа по индексу"

msgid ":ref:`index_object:min() <box_index-min>`"
msgstr ":ref:`index_object:min() <box_index-min>`"

msgid "Find the minimum value in index"
msgstr "Поиск минимального значения в индексе"

msgid ":ref:`index_object:max() <box_index-max>`"
msgstr ":ref:`index_object:max() <box_index-max>`"

msgid "Find the maximum value in index"
msgstr "Поиск максимального значения в индексе"

msgid ":ref:`index_object:random() <box_index-random>`"
msgstr ":ref:`index_object:random() <box_index-random>`"

msgid "Find a random value in index"
msgstr "Поиск случайного значения в индексе"

msgid ":ref:`index_object:count() <box_index-count>`"
msgstr ":ref:`index_object:count() <box_index-count>`"

msgid "Count tuples matching key value"
msgstr "Подсчет кортежей с совпадающим значением ключа"

msgid ":ref:`index_object:update() <box_index-update>`"
msgstr ":ref:`index_object:update() <box_index-update>`"

msgid "Update a tuple"
msgstr "Обновление кортежа"

msgid ":ref:`index_object:delete() <box_index-delete>`"
msgstr ":ref:`index_object:delete() <box_index-delete>`"

msgid "Delete a tuple by key"
msgstr "Удаление кортежа по ключу"

msgid ":ref:`index_object:alter() <box_index-alter>`"
msgstr ":ref:`index_object:alter() <box_index-alter>`"

msgid "Alter an index"
msgstr "Изменение индекса"

msgid ":ref:`index_object:drop() <box_index-drop>`"
msgstr ":ref:`index_object:drop() <box_index-drop>`"

msgid "Drop an index"
msgstr "Удаление индекса"

msgid ":ref:`index_object:rename() <box_index-rename>`"
msgstr ":ref:`index_object:rename() <box_index-rename>`"

msgid "Rename an index"
msgstr "Переименование индекса"

msgid ":ref:`index_object:bsize() <box_index-bsize>`"
msgstr ":ref:`index_object:bsize() <box_index-bsize>`"

msgid "Get count of bytes for an index"
msgstr "Подсчет байтов для индекса"

msgid ":ref:`index_object:stat() <box_index-stat>`"
msgstr ":ref:`index_object:stat() <box_index-stat>`"

msgid "Get statistics for an index"
msgstr "Получение статистических данных по индексу"

msgid ":ref:`index_object:compact() <box_index-compact>`"
msgstr ":ref:`index_object:compact() <box_index-compact>`"

msgid "Remove unused index space"
msgstr "Удаление неиспользуемого пространства индекса"

msgid ":ref:`index_object:user_defined() <box_index-user_defined>`"
msgstr ":ref:`index_object:user_defined() <box_index-user_defined>`"

msgid "Any function / method that any user wants to add"
msgstr "Любая функция / метод, которые хочет добавить любой пользователь"

msgid "True if the index is unique, false if the index is not unique."
msgstr "Если индекс уникальный -- true, если индекс не уникален -- false."

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "boolean"
msgstr "boolean (логический)"

msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr "Тип индекса: 'TREE' или 'HASH' или 'BITSET' или 'RTREE'."

msgid ""
"An array describing the index fields. To learn more about the index field"
" types, refer to :ref:`this table <box_space-index_field_types>`."
msgstr ""
"Массив, описывающий поля индекса. Чтобы узнать больше о типах полей "
"индекса, обращайтесь к :ref:`этой таблице <box_space-index_field_types>`."

msgid "table"
msgstr "таблица"

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."

msgid ""
"Search for a tuple or a set of tuples via the given index, and allow "
"iterating over one tuple at a time."
msgstr ""
"Поиск кортежа или набора кортежей по заданному индексу и итерация по "
"одному кортежу за раз."

msgid "The :samp:`{key}` parameter specifies what must match within the index."
msgstr ""
"Параметр :samp:`{key}` (ключ) задает, что именно должно совпадать в "
"индексе."

msgid ""
":samp:`{key}` is only used to find the first match. Do not assume all "
"matched tuples will contain the key."
msgstr ""
":samp:`{key}` используется в поиске только первого совпадения. Не стоит "
"ожидать, что все подобранные кортежи будут содержать этот ключ."

msgid ""
"The :samp:`{iterator}` parameter specifies the rule for matching and "
"ordering. Different index types support different iterators. For example,"
" a TREE index maintains a strict order of keys and can return all tuples "
"in ascending or descending order, starting from the specified key. Other "
"index types, however, do not support ordering."
msgstr ""
"Параметр :samp:`{iterator}` (итератор) задает правило для совпадений и "
"упорядочивания. Различные типы индексов поддерживают различные итераторы."
" Например, TREE-индекс поддерживает строгий порядок ключей и может "
"вернуть все кортежи в порядке по возрастанию или по убыванию, начиная с "
"указанного ключа. Однако другие типы индексов не поддерживают "
"упорядочивание."

msgid ""
"To understand consistency of tuples returned by an iterator, it's "
"essential to know the principles of the Tarantool transaction processing "
"subsystem. An iterator in Tarantool does not own a consistent read view. "
"Instead, each procedure is granted exclusive access to all tuples and "
"spaces until there is a \"context switch\": which may happen due to "
":ref:`the implicit yield rules <atomic-implicit-yields>`, or by an "
"explicit call to :ref:`fiber.yield <fiber-yield>`. When the execution "
"flow returns to the yielded procedure, the data set could have changed "
"significantly. Iteration, resumed after a yield point, does not preserve "
"the read view, but continues with the new content of the database. The "
"tutorial :ref:`Indexed pattern search <c_lua_tutorial-"
"indexed_pattern_search>` shows one way that iterators and yields can be "
"used together."
msgstr ""
"Чтобы понять логику возврата кортежей с помощью итератора, важно знать "
"принципы работы подсистемы обработки транзакций в Tarantool'е. В "
"итераторе Tarantool'а нет собственного постоянного вида просмотра. "
"Наоборот, каждая процедура получает эксклюзивный доступ ко всем кортежам "
"и спейсам до тех пор, пока не \"переключится контекст\", что может "
"произойти по причине :ref:`неявной передачи управления <atomic-implicit-"
"yields>` или в результате явного вызова функции :ref:`fiber.yield <fiber-"
"yield>`. Когда поток выполнения возвращается к процедуре, передавшей "
"управление, набор данных может уже значительно измениться. Итерация "
"возобновляется после стадии передачи управления и не сохраняет вид "
"просмотра, а продолжает работу с новым содержимым базы данных. В "
"практическом задании :ref:`\"Индексированный поиск по шаблонам\" "
"<c_lua_tutorial-indexed_pattern_search>` демонстрируется один из способов"
" одновременного использования итераторов и передачи управления."

msgid ""
"For information about iterators' internal structures see the `\"Lua "
"Functional library\" <https://luafun.github.io/index.html>`_ "
"documentation."
msgstr ""
"Для получения информации о внутренней структуре итераторов см. "
"документацию по библиотеке для функционального программирования в Lua "
"`\"Lua Functional library\" <https://luafun.github.io/index.html>`_."

msgid "Parameters"
msgstr "Параметры"

msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ":ref:`ссылка на объект <app_server-object_reference>`."

msgid "value to be matched against the index key, which may be multi-part"
msgstr "значение должно совпасть с индексным ключом, который может быть составным"

msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr "как определено в таблицах ниже. По умолчанию используется итератор 'EQ'"

msgid "return"
msgstr "возвращается"

msgid ""
"`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a "
"for/end loop or with `totable() "
"<https://luafun.github.io/reducing.html#fun.totable>`_"
msgstr ""
"`итератор <https://www.lua.org/pil/7.1.html>`_, который может "
"использовать в цикле for/end или с функцией `totable() "
"<https://luafun.github.io/reducing.html#fun.totable>`_"

msgid "**Possible errors:**"
msgstr "**Возможные ошибки:**"

msgid "no such space; wrong type;"
msgstr "спейс отсутствует; неправильный тип;"

msgid "selected iteration type is not supported for the index type;"
msgstr "выбранный тип итерации не поддерживается для данного типа индекса;"

msgid "key is not supported for the iteration type."
msgstr "ключ не поддерживается для данного типа итерации."

msgid "**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса; количество кортежей, к"
" которым получен доступ."

msgid ""
"A search-key-value can be a number (for example ``1234``), a string (for "
"example ``'abcd'``), or a table of numbers and strings (for example "
"``{1234, 'abcd'}``). Each part of a key will be compared to each part of "
"an index key."
msgstr ""
"Значение искомого ключа может представлять собой число (например, "
"``1234``), строку (например, ``'abcd'``) или таблицу из чисел и строк "
"(например, ``{1234, 'abcd'}``). Каждая часть ключа будет сопоставляться с"
" каждой частью ключа в индексе."

msgid ""
"The returned tuples will be in order by index key value, or by the hash "
"of the index key value if index type = 'hash'. If the index is non-"
"unique, then duplicates will be secondarily in order by primary key "
"value. The order will be reversed if the iterator type is 'LT' or 'LE' or"
" 'REQ'."
msgstr ""
"Найденные кортежи будут упорядочены по значению ключа в индексе или по "
"хешу значения ключа, если тип индекса -- 'hash'. Если индекс не уникален,"
" то дубликаты будут упорядочены во вторую очередь по первичному значению "
"ключа. Порядок будет обратным, если тип итератора -- 'LT', 'LE' или "
"'REQ'."

msgid "**Iterator types for TREE indexes**"
msgstr "**Типы итераторов для TREE-индексов**"

msgid "Iterator type"
msgstr "Тип итератора"

msgid "Arguments"
msgstr "Аргументы"

msgid "Description"
msgstr "Описание"

msgid "box.index.EQ or 'EQ'"
msgstr "box.index.EQ или 'EQ'"

msgid "search value"
msgstr "искомое значение"

msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a"
" search value, it matches. Tuples are returned in ascending order by "
"index key. This is the default."
msgstr ""
"Оператором сравнения будет '==' (равно). Если ключ индекса равен искомому"
" значению, получим совпадение. Найденные кортежи упорядочены по "
"возрастанию по ключу индекса. Этот тип используется по умолчанию."

msgid "box.index.REQ or 'REQ'"
msgstr "box.index.REQ или 'REQ'"

msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in "
"descending order by index key."
msgstr ""
"Совпадения находятся таким же образом, что и для ``box.index.EQ``. "
"Разница только в том, что найденные кортежи упорядочены по ключу индекса "
"по убыванию, а не по возрастанию."

msgid "box.index.GT or 'GT'"
msgstr "box.index.GT или 'GT'"

msgid ""
"The comparison operator is '>' (greater than). If an index key is greater"
" than a search value, it matches. Tuples are returned in ascending order "
"by index key."
msgstr ""
"Оператором сравнения будет '>' (больше чем). Если ключ индекса больше, "
"чем искомое значение, получим совпадение. Найденные кортежи упорядочены "
"по возрастанию по ключу индекса."

msgid "box.index.GE or 'GE'"
msgstr "box.index.GE или 'GE'"

msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index "
"key is greater than or equal to a search value, it matches. Tuples are "
"returned in ascending order by index key."
msgstr ""
"Оператором сравнения будет '>=' (больше или равен). Если ключ индекса "
"больше искомого значения или равен ему, получим совпадение. Найденные "
"кортежи упорядочены по возрастанию по ключу индекса."

msgid "box.index.ALL or 'ALL'"
msgstr "box.index.ALL или 'ALL'"

msgid "Same as box.index.GE."
msgstr "Как для box.index.GE."

msgid "box.index.LT or 'LT'"
msgstr "box.index.LT или 'LT'"

msgid ""
"The comparison operator is '<' (less than). If an index key is less than "
"a search value, it matches. Tuples are returned in descending order by "
"index key."
msgstr ""
"Оператором сравнения будет  '<' (меньше чем). Если ключ индекса меньше "
"искомого значения, получим совпадение. Найденные кортежи упорядочены по "
"убыванию по ключу индекса."

msgid "box.index.LE or 'LE'"
msgstr "box.index.LE или 'LE'"

msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key "
"is less than or equal to a search value, it matches. Tuples are returned "
"in descending order by index key."
msgstr ""
"Оператором сравнения будет '<=' (меньше или равен). Если ключ индекса "
"меньше искомого значения или равен ему, получим совпадение. Найденные "
"кортежи упорядочены по убыванию по ключу индекса."

msgid ""
"Informally, we can state that searches with TREE indexes are generally "
"what users will find is intuitive, provided that there are no nils and no"
" missing parts. Formally, the logic is as follows. A search key has zero "
"or more parts, for example {}, {1,2,3},{1,nil,3}. An index key has one or"
" more parts, for example {1}, {1,2,3},{1,2,3}. A search key may contain "
"nil (but not msgpack.NULL, which is the wrong type). An index key may not"
" contain nil or msgpack.NULL, although a later version of Tarantool will "
"have different rules --  the behavior of searches with nil is subject to "
"change. Possible iterators are LT, LE, EQ, REQ, GE, GT. A search key is "
"said to \"match\" an index key if the following statements, which are "
"pseudocode for the comparison operation, return TRUE."
msgstr ""
"Неофициально можно сказать, что поиск с помощью TREE-индексов "
"пользователи обычно считают интуитивно понятным при условии, что нет "
"нулевых значений и отсутствующих частей. Формально же логика заключается "
"в следующем. Ключ поиска состоит из нуля или более частей, например, {}, "
"{1,2,3},{1,nil,3}. Ключ индекса состоит из одной или более частей, "
"например, {1}, {1,2,3},{1,2,3}. Ключ поиска может содержать нулевое "
"значение nil (но не msgpack.NULL, этот тип не будет правильным). Ключ "
"индекса не может содержать nil или msgpack.NULL, хотя в последующих "
"версиях правила работы Tarantool'а будут другие -- поведение поиска с nil"
" может измениться. Возможные итераторы: LT, LE, EQ, REQ, GE, GT. "
"Считается, что ключ поиска соответствует ключу индекса, если следующие "
"операторы, которые представляют собой псевдокод для операции "
"сопоставления, возвращают TRUE."

msgid ""
"If (number-of-search-key-parts > number-of-index-key-parts) return ERROR\n"
"If (number-of-search-key-parts == 0) return TRUE\n"
"for (i = 1; ; ++i)\n"
"{\n"
"  if (i > number-of-search-key-parts) OR (search-key-part[i] is nil)\n"
"  {\n"
"    if (iterator is LT or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (type of search-key-part[i] is not compatible with type of index-"
"key-part[i])\n"
"  {\n"
"    return ERROR\n"
"  }\n"
"  if (search-key-part[i] == index-key-part[i])\n"
"  {\n"
"    continue\n"
"  }\n"
"  if (search-key-part[i] > index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or LE or LT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (search-key-part[i] < index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or GE or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"}"
msgstr ""

msgid "**Iterator types for HASH indexes**"
msgstr "**Типы итераторов для HASH-индексов**"

msgid "Type"
msgstr "Тип возвращаемого значения"

msgid "box.index.ALL"
msgstr "box.index.ALL"

msgid "none"
msgstr "нет"

msgid ""
"All index keys match. Tuples are returned in ascending order by hash of "
"index key, which will appear to be random."
msgstr ""
"Все ключи индекса являются совпадениями. Найденные кортежи упорядочены по"
" возрастанию по хешу ключа индекса, который будет выглядеть случайным."

msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a"
" search value, it matches. The number of returned tuples will be 0 or 1. "
"This is the default."
msgstr ""
"Оператором сравнения будет '==' (равный). Если ключ индекса равен "
"искомому значению, получим совпадение. Количество найденных кортежей "
"будет 0 или 1. Этот тип используется по умолчанию."

msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key "
"is greater than a hash of a search value, it matches. Tuples are returned"
" in ascending order by hash of index key, which will appear to be random."
" Provided that the space is not being updated, one can retrieve all the "
"tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} "
"in each search, and using the last returned value from the previous "
"result as the start search value for the next search."
msgstr ""
"Оператором сравнения будет '>' (больше чем). Если хеш ключа индекса "
"больше, чем хеш искомого значения, получим совпадение. Найденные кортежи "
"упорядочены по возрастанию по хешу ключа индекса, который будет выглядеть"
" случайным. При условии, что спейс не обновляется, можно получить все "
"кортежи в спейсе, N кортежей за раз, используя  {iterator='GT', limit=N} "
"в каждом поиске и последнее найденное значение из предыдущего результата "
"поиска в качестве начального значения для следующего поиска."

msgid "**Iterator types for BITSET indexes**"
msgstr "**Типы итераторов для BITSET-индексов**"

msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""
"Все ключи индекса являются совпадениями. Найденные кортежи упорядочены по"
" положению в спейсе."

msgid "bitset value"
msgstr "значение bitset (битовое множество)"

msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are "
"returned in their order within the space. This is the default."
msgstr ""
"Если ключ индекса равен искомому значению, получим совпадение. Найденные "
"кортежи упорядочены по положению в спейсе. Этот тип используется по "
"умолчанию."

msgid "box.index.BITS_ALL_SET"
msgstr "box.index.BITS_ALL_SET"

msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все биты, которые равны 1 в битовом множестве, также равны 1 в ключе"
" индекса, получим совпадение. Найденные кортежи упорядочены по положению "
"в спейсе."

msgid "box.index.BITS_ANY_SET"
msgstr "box.index.BITS_ANY_SET"

msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если один из битов, которые равны 1 в битовом множестве, также равен 1 в "
"ключе индекса, получим совпадение. Найденные кортежи упорядочены по "
"положению в спейсе."

msgid "box.index.BITS_ALL_NOT_SET"
msgstr "box.index.BITS_ALL_NOT_SET"

msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все биты, которые равны 1 в битовом множестве, равны 0 в ключе "
"индекса, получим совпадение. Найденные кортежи упорядочены по положению в"
" спейсе."

msgid "**Iterator types for RTREE indexes**"
msgstr "**Типы итераторов для RTREE-индексов**"

msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""
"Все ключи являются совпадениями. Найденные кортежи упорядочены по "
"положению в спейсе."

msgid ""
"If all points of the rectangle-or-box defined by the search value are the"
" same as the rectangle-or-box defined by the index key, it matches. "
"Tuples are returned in their order within the space. \"Rectangle-or-box\""
" means \"rectangle-or-box as explained in section about :ref:`RTREE "
"<box_index-rtree>`\". This is the default."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, совпадают с точками прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе. \"Прямоугольник-или-параллелепипед\" "
"означает \"прямоугольник-или-параллелепипед, как описано в разделе о "
":ref:`RTREE <box_index-rtree>`\". Этот тип используется по умолчанию."

msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within, or at the side of, the rectangle-or-box defined by the index key,"
" it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, или рядом с ним, получим совпадение. "
"Найденные кортежи упорядочены по положению в спейсе."

msgid ""
"If all points of the rectangle-or-box defined by the index key are within"
" the rectangle-or-box defined by the search key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные ключом "
"индекса, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного искомым значением, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

msgid ""
"If all points of the rectangle-or-box defined by the index key are "
"within, or at the side of, the rectangle-or-box defined by the search "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные ключом "
"индекса, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного искомым значением, или рядом с ним, получим совпадение. "
"Найденные кортежи упорядочены по положению в спейсе."

msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr "box.index.OVERLAPS или 'OVERLAPS'"

msgid ""
"If some points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""
"Если некоторые точки прямоугольника-или-параллелепипеда, определенные "
"искомым значением, находятся в пределах "
"прямоугольника-или-параллелепипеда, определенного ключом индекса, получим"
" совпадение. Найденные кортежи упорядочены по положению в спейсе."

msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr "box.index.NEIGHBOR или 'NEIGHBOR'"

msgid ""
"If some points of the rectangle-or-box defined by the defined by the key "
"are within, or at the side of, defined by the index key, it matches. "
"Tuples are returned in order: nearest neighbor first."
msgstr ""
"Если некоторые точки прямоугольника-или-параллелепипеда, определенные "
"ключом, находятся в пределах, определенных ключом индекса, или рядом с "
"ним, получим совпадение. Найденные кортежи упорядочены следующим образом:"
" сначала ближайший сосед."

msgid "**First example of index pairs():**"
msgstr "**Первый пример pairs():**"

msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr "'TREE'-индекс, используемый по умолчанию, и функция ``pairs()``:"

msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."

msgid "**Second example of index pairs():**"
msgstr "**Второй пример pairs():**"

msgid ""
"This Lua code finds all the tuples whose primary key values begin with "
"'XY'. The assumptions include that there is a one-part primary-key TREE "
"index on the first field, which must be a string. The iterator loop "
"ensures that the search will return tuples where the first value is "
"greater than or equal to 'XY'. The conditional statement within the loop "
"ensures that the looping will stop when the first two letters are not "
"'XY'."
msgstr ""
"Данный код на Lua найдет все кортежи, значения первичного ключа в которых"
" начинаются с 'XY'. Рабочие предположения заключаются в следующем: есть "
"однокомпонентный первичный TREE-индекс по первому полю, которое должно "
"представлять собой строку. Цикл с итератором обеспечивает поиск кортежей,"
" в которых первое значение больше или равно 'XY'. Условный оператор в "
"цикле служит для того, чтобы цикл останавливался, если первые две буквы "
"не 'XY'."

msgid ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"

msgid "**Third example of index pairs():**"
msgstr "**Третий пример pairs():**"

msgid ""
"This Lua code finds all the tuples whose primary key values are greater "
"than or equal to 1000, and less than or equal to 1999 (this type of "
"request is sometimes called a \"range search\" or a \"between search\"). "
"The assumptions include that there is a one-part primary-key TREE index "
"on the first field, which must be a :ref:`number <index-box_number>`. The"
" iterator loop ensures that the search will return tuples where the first"
" value is greater than or equal to 1000. The conditional statement within"
" the loop ensures that the looping will stop when the first value is "
"greater than 1999."
msgstr ""
"Данный код на Lua найдет все кортежи, значения первичного ключа которых "
"равны или больше 1000 и меньше или равны 1999 (такой тип запроса иногда "
"называют поиском по диапазону или поиском в заданных пределах). Рабочие "
"предположения заключаются в следующем: есть однокомпонентный первичный "
"TREE-индекс по первому полю, которое должно представлять собой "
":ref:`число <index-box_number>`. Цикл с итератором обеспечивает поиск "
"кортежей, в которых первое значение больше или равно 1000. Условный "
"оператор в цикле служит для того, чтобы цикл останавливался, если первое "
"значение больше 1999."

msgid ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"

msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` "
"which goes via a particular index and can make use of additional "
"parameters that specify the iterator type, and the limit (that is, the "
"maximum number of tuples to return) and the offset (that is, which tuple "
"to start with in the list)."
msgstr ""
"Это может быть альтернативой для функции :ref:`box.space...select() "
"<box_space-select>`, которая проходит по определенному индексу и может "
"использовать дополнительные параметры, которые определяют тип итератора и"
" пределы (то есть максимальное количество возвращаемых кортежей) и "
"смещение (то есть с какого кортежа в списке начинать)."

msgid "values to be matched against the index key"
msgstr "значения для сопоставления с ключом индекса"

msgid ""
"none, any, or all of the following parameters:  * ``iterator`` -- type of"
" iterator * ``limit`` -- maximum number of tuples * ``offset`` -- start "
"tuple number"
msgstr ""

msgid "none, any, or all of the following parameters:"
msgstr "ни один, любой или все следующие параметры:"

msgid "``iterator`` -- type of iterator"
msgstr "``interator`` -- тип итератора"

msgid "``limit`` -- maximum number of tuples"
msgstr "``limit`` -- максимальное количество кортежей"

msgid "``offset`` -- start tuple number"
msgstr "``offset`` -- номер начального кортежа"

msgid "the tuple or tuples that match the field values."
msgstr "кортеж или кортежи, которые совпадают со значениями поля."

msgid "array of tuples"
msgstr "массив кортежей"

msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""
"-- Создать спейс под названием tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Создать уникальный индекс 'primary'\n"
"-- который не будет нужен для данного примера..\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Создать неуникальный индекс 'secondary'\n"
"-- по второму полю.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Вставить три кортежа, значения в поле2 field[2]\n"
"-- равны 'X', 'Y' и 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Выбрать все кортежи, где вторичные ключи\n"
"-- больше, чем 'X'.\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"

msgid "The result will be a table of tuple and will look like this:"
msgstr "Результатом будет следующая таблица кортежа:"

msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."

msgid ""
"The arguments are optional. If you call :samp:`box.space.{space-"
"name}:select{}`, then every key in the index is considered to be a match,"
" regardless of the iterator type. Therefore, for the example above, "
"``box.space.tester:select{}`` will select every tuple in the ``tester`` "
"space via the first (primary-key) index."
msgstr ""
"Аргументы необязательны. Если вы вызываете "
":samp:`box.space.{имя-спейса}:select{}`, то каждый ключ в индексе "
"считается совпадающим, независимо от типа итератора. Таким образом, в "
"приведённом выше примере, ``box.space.tester:select{}`` выберет каждый "
"кортеж в спейсе ``tester`` по первому индексу (первичный ключ)."

msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the "
"assumed index is the first (primary-key) index. Therefore, for the "
"example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would "
"have returned the same two rows, via the 'primary' index."
msgstr ""
"Параметр :samp:`index.{имя-индекса}` необязателен. Если он пропущен, то "
"подразумевается первый индекс (первичный ключ). Таким образом, для "
"примера выше, ``box.space.tester:select({1}, {iterator = 'GT'})`` вернет "
"две одинаковых строки по первичному индексу 'primary'."

msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""
"Параметр типа итератора :samp:`iterator = {тип-итератора}` необязателен. "
"Если он пропущен, то подразумевается, что ``iterator = 'EQ'``."

msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]`. can be "
"replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. "
"That is, ``get`` can be used as a convenient shorthand to get the first "
"tuple in the tuple set that would be returned by ``select``. However, if "
"there is more than one tuple in the tuple set, then ``get`` throws an "
"error."
msgstr ""
":samp:`box.space.{имя-спейса}.index.{имя-индекса}:select(...)[1]` можно "
"заменить :samp:`box.space.{имя-спейса}.index.{имя-индекса}:get(...)`. А "
"именно, ``get`` можно использовать в качестве удобного сокращения для "
"получения первого кортежа в наборе кортежей, который был бы выведен по "
"запросу ``select``. Однако, если в наборе кортежей больше одного кортежа,"
" ``get`` завершится с ошибкой."

msgid "**Example with BITSET index:**"
msgstr "**Пример с индексом BITSET:**"

msgid ""
"The following script shows creation and search with a BITSET index. "
"Notice: BITSET cannot be unique, so first a primary-key index is created."
" Notice: bit values are entered as hexadecimal literals for easier "
"reading."
msgstr ""
"Следующий скрипт показывает создание BITSET-индекса и поиск по нему. "
"Обратите внимание, что битовое множество BITSET не может быть уникальным,"
" поэтому сначала создается первичный индекс. Обратите внимание, что "
"битовые значения вводятся как шестнадцатеричные литералы для удобства "
"чтения."

msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."

msgid ""
"Search for a tuple via the given index, as described :ref:`earlier "
"<box_index-note>`."
msgstr ""
"Поиск кортежа по заданному индексу, как описано :ref:`выше <box_index-"
"note>`."

msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr "кортеж, в котором поля ключа в индексе равны переданным значениям ключа."

msgid "tuple"
msgstr "кортеж"

msgid "no such index;"
msgstr "отсутствие такого индекса;"

msgid "wrong type;"
msgstr "неправильный тип;"

msgid "more than one tuple matches."
msgstr "больше одного кортежа подходят."

msgid ""
"**Complexity factors:** Index size, Index type. See also "
":ref:`space_object:get() <box_space-get>`."
msgstr ""
"**Факторы сложности:** Размер индекса, тип индекса. См. также "
":ref:`space_object:get() <box_space-get>`."

msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."

msgid "Find the minimum value in the specified index."
msgstr "Поиск минимального значения в указанном индексе."

msgid ""
"the tuple for the first key in the index. If optional ``key`` value is "
"supplied, returns the first key which is greater than or equal to ``key``"
" value. In a future version of Tarantool, index:min(``key`` value) will "
"return nothing if ``key`` value is not equal to a value in the index."
msgstr ""
"кортеж для первого ключа в индексе. Если указано необязательное значение "
"ключа ``key``, будет выведен первый ключ, который больше или равен "
"значению ключа ``key``. В будущей версии Tarantool'а index:min(значение "
"``key``) не вернет ничего, если значение ``key`` не равно значению в "
"индексе."

msgid "**Possible errors:** index is not of type 'TREE'."
msgstr "**Возможные ошибки:** тип индекса не 'TREE'."

msgid "**Complexity factors:** Index size, Index type."
msgstr "**Факторы сложности:** Размер индекса, тип индекса."

msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."

msgid "Find the maximum value in the specified index."
msgstr "Поиск максимального значения в указанном индексе."

msgid ""
"the tuple for the last key in the index. If optional ``key`` value is "
"supplied, returns the last key which is less than or equal to ``key`` "
"value. In a future version of Tarantool, index:max(``key`` value) will "
"return nothing if ``key`` value is not equal to a value in the index."
msgstr ""
"кортеж для последнего ключа в индексе. Если указано необязательное "
"значение ключа ``key``, будет выведен последний ключ, который меньше или "
"равен значению ключа ``key``. В будущей версии Tarantool'а "
"index:max(значение ``key``) не вернет ничего, если значение ``key`` не "
"равно значению в индексе."

msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."

msgid ""
"Find a random value in the specified index. This method is useful when "
"it's important to get insight into data distribution in an index without "
"having to iterate over the entire data set."
msgstr ""
"Поиск случайного значения в заданном индексе. Данный метод используется, "
"когда важно получить представление о распределении данных в индексе без "
"необходимости проходить по всему набору данных."

msgid "an arbitrary non-negative integer"
msgstr "произвольное неотрицательное целое число"

msgid "the tuple for the random key in the index."
msgstr "кортеж для случайного ключа в индексе."

msgid "**Note re storage engine:** vinyl does not support ``random()``."
msgstr "**Примечание про движок базы данных:** vinyl не поддерживает ``random()``."

msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."

msgid ""
"Iterate over an index, counting the number of tuples which match the key-"
"value."
msgstr ""
"Итерация по индексу с подсчетом количества кортежей, которые "
"соответствуют паре ключ-значение."

msgid "comparison method"
msgstr "метод сопоставления"

msgid "the number of matching tuples."
msgstr "количество совпадающих кортежей."

msgid "number"
msgstr "число"

msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."

msgid "Update a tuple."
msgstr "Обновление кортежа."

msgid ""
"Same as :ref:`box.space...update() <box_space-update>`, but key is "
"searched in this index instead of primary key. This index ought to be "
"unique."
msgstr ""
"То же, что и :ref:`box.space...update() <box_space-update>`, но поиск "
"ключа происходит в этом индексе, вместо первичного. Данный индекс должен "
"быть уникальным."

msgid "operation type represented in string"
msgstr "тип операции, представленный строкой"

msgid ""
"what field the operation will apply to. The field number can be negative,"
" meaning the position from the end of tuple. (#tuple + negative field "
"number + 1)"
msgstr ""
"к какому полю применяется операция. Номер поля может быть отрицательным, "
"что означает, что позиция рассчитывается с конца кортежа. (#кортеж + "
"отрицательный номер поля + 1)"

msgid "what value will be applied"
msgstr "какое значение применяется"

msgid "the updated tuple"
msgstr "обновленный кортеж"

msgid "nil if the key is not found"
msgstr "nil, если ключ не найден"

msgid "tuple or nil"
msgstr ""

msgid "Delete a tuple identified by a key."
msgstr "Удаление кортежа по ключу."

msgid ""
"Same as :ref:`box.space...delete() <box_space-delete>`, but key is "
"searched in this index instead of in the primary-key index. This index "
"ought to be unique."
msgstr ""
"То же, что и :ref:`box.space...delete() <box_space-delete>`, но поиск "
"ключа происходит в этом индексе, вместо первичного. Данный индекс должен "
"быть уникальным."

msgid "the deleted tuple."
msgstr "удаленный кортеж."

msgid ""
"**Note re storage engine:** vinyl will return `nil`, rather than the "
"deleted tuple."
msgstr ""
"**Примечание про движок базы данных:** vinyl вернет `nil`, а не удаленный"
" кортеж."

msgid ""
"Alter an index. It is legal in some circumstances to change one or more "
"of the index characteristics, for example its type, its sequence options,"
" its parts, and whether it is unique. Usually this causes rebuilding of "
"the space,  except for the simple case where a part's ``is_nullable`` "
"flag is changed from ``false`` to ``true``."
msgstr ""
"Изменение индекса. В определенных обстоятельствах можно изменять "
"некоторые характеристики индекса, например тип, параметры "
"последовательности и определение его уникальности. Тем не менее, это "
"обычно приводит к перестроению спейса за исключением простого случая, "
"когда значение флага ``is_nullable`` меняется с ``false`` на ``true``."

msgid ""
"options list, same as the options list for ``create_index``, see the "
"chart named :ref:`Options for space_object:create_index() <box_space-"
"create_index>`."
msgstr ""
"список параметров, аналогичный списку параметров для ``create_index``, "
"см. таблицу под названием :ref:`Параметры для space_object:create_index()"
" <box_space-create_index>`."

msgid "nil"
msgstr "nil"

msgid "index does not exist,"
msgstr "индекс не существует,"

msgid "the primary-key index cannot be changed to ``{unique = false}``."
msgstr ""
"индекс по первичному ключу не может быть неуникальным, то есть нельзя "
"задать ``{unique = false}``."

msgid ""
"**Note re storage engine:** vinyl does not support ``alter()`` of a "
"primary-key index unless the space is empty."
msgstr ""
"**Примечание про движок базы данных:** vinyl не поддерживает ``alter()`` "
"для первичного индекса, если спейс содержит данные."

msgid "**Example 1:**"
msgstr "**Пример 1:**"

msgid "You can add and remove fields that make up a primary index:"
msgstr "Можно добавлять и удалять поля, которые составляют первичный индекс:"

msgid ""
"tarantool> s = box.schema.create_space('test')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('i', {parts = {{field = 1, type = "
"'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s:insert({1, 2})\n"
"---\n"
"- [1, 2]\n"
"...\n"
"tarantool> i:select()\n"
"---\n"
"- - [1, 2]\n"
"...\n"
"tarantool> i:alter({parts = {{field = 1, type = 'unsigned'}, {field = 2, "
"type = 'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s:insert({1, 't'})\n"
"---\n"
"- error: 'Tuple field 2 type does not match one required by operation: "
"expected unsigned'\n"
"..."
msgstr ""
"tarantool> s = box.schema.create_space('test')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('i', {parts = {{field = 1, type = "
"'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s:insert({1, 2})\n"
"---\n"
"- [1, 2]\n"
"...\n"
"tarantool> i:select()\n"
"---\n"
"- - [1, 2]\n"
"...\n"
"tarantool> i:alter({parts = {{field = 1, type = 'unsigned'}, {field = 2, "
"type = 'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s:insert({1, 't'})\n"
"---\n"
"- error: 'Tuple field 2 type does not match one required by operation: "
"expected unsigned'\n"
"..."

msgid "**Example 2:**"
msgstr "**Пример 2:**"

msgid "You can change index options for both memtx and vinyl spaces:"
msgstr "Можно изменять опции индекса для спейсов как в memtx'е, так и в vinyl'е:"

msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."

msgid ""
"Drop an index. Dropping a primary-key index has a side effect: all tuples"
" are deleted."
msgstr ""
"Удаление индекса. Побочный эффект удаления первичного индекса -- все "
"кортежи удалятся."

msgid "nil."
msgstr "nil."

msgid "a primary-key index cannot be dropped while a secondary-key index exists."
msgstr "первичный индекс невозможно удалить, если существует вторичный индекс."

msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."

msgid "Rename an index."
msgstr "Переименование индекса."

msgid "new name for index"
msgstr "новое имя индекса"

msgid "**Possible errors:** index_object does not exist."
msgstr "**Возможные ошибки:** index_object не существует."

msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."

msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""
"**Факторы сложности:** Размер индекса, тип индекса, количество кортежей, "
"к которым получен доступ."

msgid "Return the total number of bytes taken by the index."
msgstr "Возврат общего количества байтов, занятых индексом."

msgid "number of bytes"
msgstr "количество байтов"

msgid "Return statistics about actions taken that affect the index."
msgstr "Получение статистики о предпринятых действиях, которые влияют на индекс."

msgid "This is for use with the vinyl engine."
msgstr "Используется с движком базы данных vinyl."

msgid "Some detail items in the output from ``index_object:stat()`` are:"
msgstr "Подробные данные в выводе ``index_object:stat()``:"

msgid "``index_object:stat().latency`` -- timings subdivided by percentages;"
msgstr "``index_object:stat().latency`` содержит отметки времени в процентах;"

msgid "``index_object:stat().bytes`` -- the number of bytes total;"
msgstr "``index_object:stat().bytes`` содержит общее количество байтов;"

msgid ""
"``index_object:stat().disk.rows`` -- the approximate number of tuples in "
"each range;"
msgstr ""
"``index_object:stat().disk.rows`` содержит примерное количество кортежей "
"в каждом диапазоне;"

msgid ""
"``index_object:stat().disk.statement`` -- counts of "
"inserts|updates|upserts|deletes;"
msgstr ""
"``index_object:stat().disk.statement`` содержит количество вставок, "
"обновлений, обновлений и вставок, удалений "
"(inserts|updates|upserts|deletes);"

msgid ""
"``index_object:stat().disk.compaction`` -- counts of compactions and "
"their amounts;"
msgstr ""
"``index_object:stat().disk.compaction`` содержит количество слияний и их "
"объем;"

msgid "``index_object:stat().disk.dump`` -- counts of dumps and their amounts;"
msgstr "``index_object:stat().disk.dump`` содержит количество дампов и их объем;"

msgid ""
"``index_object:stat().disk.iterator.bloom`` -- counts of bloom filter "
"hits|misses;"
msgstr ""
"``index_object:stat().disk.iterator.bloom`` содержит количество "
"совпадений и несовпадений по фильтрами Блума;"

msgid "``index_object:stat().disk.pages`` -- the size in pages;"
msgstr "``index_object:stat().disk.pages`` содержит размер в страницах;"

msgid ""
"``index_object:stat().disk.last_level`` -- size of data in the last LSM "
"tree level;"
msgstr ""
"``index_object:stat().disk.last_level`` содержит объем данных на "
"последнем уровне LSM-дерева;"

msgid "``index_object:stat().cache.evict`` -- number of evictions from the cache;"
msgstr "``index_object:stat().cache.evict`` содержит количество освобождений кэша;"

msgid "``index_object:stat().range_size`` -- maximum number of bytes in a range;"
msgstr ""
"``index_object:stat().range_size`` содержит максимальное количество "
"байтов в диапазоне;"

msgid ""
"``index_object:stat().dumps_per_compaction`` -- average number of dumps "
"required to trigger major compaction in any range of the LSM tree."
msgstr ""
"``index_object:stat().dumps_per_compaction`` содержит среднее число "
"дампов, которое необходимо для запуска значительного слияния в любом "
"диапазоне LSM-дерева."

msgid ""
"Summary index statistics are also available via :ref:`box.stat.vinyl() "
"<box_introspection-box_stat_vinyl_details>`."
msgstr ""
"С помощью :ref:`box.stat.vinyl() <box_introspection-"
"box_stat_vinyl_details>` можно получить сводную статистику по индексу."

msgid "statistics"
msgstr "статистические данные"

msgid ""
"Remove unused index space. For the memtx storage engine this method does "
"nothing; ``index_object:compact()`` is only for the vinyl storage engine."
" For example, with vinyl, if a tuple is deleted, the space is not "
"immediately reclaimed. There is a scheduler for reclaiming space "
"automatically based on factors such as lsm shape and amplification as "
"discussed in the section :ref:`Storing data with vinyl <engines-vinyl>`, "
"so calling ``index_object:compact()`` manually is not always necessary."
msgstr ""
"Удаление неиспользуемого пространства индекса. Для движка базы данных "
"memtx метод бесполезен; ``index_object:compact()`` используется только "
"для движка vinyl. Например, на движке vinyl при удалении кортежа память "
"не возвращается незамедлительно. Существует планировщик автоматического "
"восстановления ресурсов на основании таких факторов, как форма LSM-дерева"
" и усложнение, как описано в разделе :ref:`Хранение данных с помощью "
"vinyl <engines-vinyl>`, поэтому выполнять ``index_object:compact()`` "
"вручную необходимости нет."

msgid "nil (Tarantool returns without waiting for compaction to complete)"
msgstr ""
"nil (Tarantool возвращает нулевое значение сразу же, не ожидая завершения"
" слияния)"

msgid ""
"Users can define any functions they want, and associate them with "
"indexes: in effect they can make their own index methods. They do this "
"by:"
msgstr ""
"Пользователи могут сами определять любые желаемые функции и связывать их "
"с индексами: фактически они могут создавать собственные методы для работы"
" с индексом. Это можно сделать так:"

msgid "creating a Lua function,"
msgstr "создать Lua-функцию,"

msgid ""
"adding the function name to a predefined global variable which has type ="
" table, and"
msgstr ""
"добавить имя функции в заданную глобальную переменную с типом \"таблица\""
" (table),"

msgid ""
"invoking the function any time thereafter, as long as the server is up, "
"by saying ``index_object:function-name([parameters])``."
msgstr ""
"впоследствии в любое время, пока работает сервер, вызвать функцию с "
"помощью ``объект_индекса:имя-функции([параметры])``."

msgid "There are three predefined global variables:"
msgstr "Есть три заданные глобальные переменные:"

msgid ""
"Adding to ``box_schema.index_mt`` makes the method available for all "
"indexes."
msgstr ""
"Метод, добавленный в ``box_schema.index_mt``, будет доступен для всех "
"индексов."

msgid ""
"Adding to ``box_schema.memtx_index_mt`` makes the method available for "
"all memtx indexes."
msgstr ""
"Метод, добавленный в ``box_schema.memtx_index_mt``, будет доступен для "
"всех индексов в memtx'е."

msgid ""
"Adding to ``box_schema.vinyl_index_mt`` makes the method available for "
"all vinyl indexes."
msgstr ""
"Метод, добавленный в ``box_schema.vinyl_index_mt``, будет доступен для "
"всех индексов в vinyl'е."

msgid ""
"Alternatively, user-defined methods can be made available for only one "
"index, by calling ``getmetatable(index_object)`` and then adding the "
"function name to the meta table."
msgstr ""
"Можно также сделать задаваемый пользователем метод доступным только для "
"одного индекса путем вызова ``getmetatable(объект_индекса)`` и "
"последующего добавления имени функции в метатаблицу."

msgid "whatever the user defines"
msgstr "то, что определяет пользователь"

msgid ""
"-- Visible to any index of a memtx space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t', {engine='memtx'})\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f() global_variable = global_variable + 1 end\n"
"box.schema.memtx_index_mt.counter = f\n"
"box.space.t.index.i:counter()"
msgstr ""
"-- Доступный для любого индекса спейса memtx, без параметров.\n"
"-- После таких запросов значение глобальной переменной global_variable "
"будет 6.\n"
"box.schema.space.create('t', {engine='memtx'})\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f() global_variable = global_variable + 1 end\n"
"box.schema.memtx_index_mt.counter = f\n"
"box.space.t.index.i:counter()"

msgid ""
"-- Visible to index box.space.t.index.i only, 1 parameter.\n"
"-- After these requests, the value of X will be 1005.\n"
"box.schema.space.create('t', {engine='memtx', id = 1000})\n"
"box.space.t:create_index('i')\n"
"X = 0\n"
"i = box.space.t.index.i\n"
"function f(i_arg, param) X = X + param + i_arg.space_id end\n"
"box.schema.memtx_index_mt.counter = f\n"
"meta = getmetatable(i)\n"
"meta.counter = f\n"
"i:counter(5)"
msgstr ""
"-- Доступный только для индекса box.space.t.index.i, 1 параметр.\n"
"-- После таких запросов значение X будет 1005.\n"
"box.schema.space.create('t', {engine='memtx', id = 1000})\n"
"box.space.t:create_index('i')\n"
"X = 0\n"
"i = box.space.t.index.i\n"
"function f(i_arg, param) X = X + param + i_arg.space_id end\n"
"box.schema.memtx_index_mt.counter = f\n"
"meta = getmetatable(i)\n"
"meta.counter = f\n"
"i:counter(5)"

msgid "Example showing use of the box functions"
msgstr "Пример использования функций box"

msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary "
"key. The example function will:"
msgstr ""
"Данный пример сработает на конфигурации из песочницы, описанной в "
"предисловии, то есть создан спейс под названием tester с первичным "
"числовым ключом. Функция в примере выполнит следующие действия:"

msgid "select a tuple whose key value is 1000;"
msgstr "выбрать кортеж, значение ключа в котором равно 1000;"

msgid "raise an error if the tuple already exists and already has 3 fields;"
msgstr ""
"выдать сообщение об ошибке, если такой кортеж уже существует и содержит 3"
" поля;"

msgid "Insert or replace the tuple with:"
msgstr "вставить или заменить кортеж следующими данными:"

msgid "field[1] = 1000"
msgstr "поле [1] = 1000"

msgid "field[2] = a uuid"
msgstr "поле [2] = UUID"

msgid "field[3] = number of seconds since 1970-01-01;"
msgstr "поле [3] = количество секунд с 01.01.1970;"

msgid "Get field[3] from what was replaced;"
msgstr "получить поле [3] из того, что заменили;"

msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""
"преобразовать значение из поля [3] в формат yyyy-mm-dd hh:mm:ss.ffff "
"(год-месяц-день час:минута:секунда.десятитысячные доли секунды);"

msgid "Return the formatted value."
msgstr "вернуть преобразованное значение."

msgid ""
"The function uses Tarantool box functions :ref:`box.space...select "
"<box_space-select>`, :ref:`box.space...replace <box_space-replace>`, "
":ref:`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function "
"uses Lua functions `os.date()`_ and `string.sub()`_."
msgstr ""
"Данная функция использует функции box в Tarantool'е: "
":ref:`box.space...select <box_space-select>`, :ref:`box.space...replace "
"<box_space-replace>`, :ref:`fiber.time <fiber-time>`, :ref:`uuid.str "
"<uuid-str>`. Данная функция использует Lua-функции `os.date()`_ и "
"`string.sub()`_."

#, python-format
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"

msgid "... And here is what happens when one invokes the function:"
msgstr "... А вот что происходит, когда вызывается функция:"

msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."

msgid "Example showing a user-defined iterator"
msgstr "Пример с заданным пользователем итератором"

msgid ""
"Here is an example that shows how to build one's own iterator. The "
"``paged_iter`` function is an \"iterator function\", which will only be "
"understood by programmers who have read the Lua manual section `Iterators"
" and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated "
"retrievals, that is, it returns 10 tuples at a time from a table named "
"\"t\", whose primary key was defined with "
"``create_index('primary',{parts={1,'string'}})``."
msgstr ""
"Здесь приведен пример того, как создать свой собственный итератор. "
"Функция ``paged_iter`` представляет собой \"функцию с итератором\", что "
"поймут только разработчики, которые ознакомились с разделом руководства "
"по Lua `Итераторы и замыкания <https://www.lua.org/pil/7.1.html>`_. Она "
"делает постраничную выборку, то есть возвращает 10 кортежей одновременно "
"из таблицы под названием \"t\", первичный ключ которой определен с "
"помощью ``create_index('primary',{parts={1,'string'}})``."

msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"

msgid ""
"Programmers who use ``paged_iter`` do not need to know why it works, they"
" only need to know that, if they call it within a loop, they will get 10 "
"tuples at a time until there are no more tuples."
msgstr ""
"Разработчикам, использующим ``paged_iter``, необязательно знать, почему "
"она работает, следует лишь понимать, что вызвав функцию в цикле, можно "
"получать 10 кортежей за раз до тех пор, пока кортежи не кончатся."

msgid ""
"In this example the tuples are merely printed, a page at a time. But it "
"should be simple to change the functionality, for example by yielding "
"after each retrieval, or by breaking when the tuples fail to match some "
"additional criteria."
msgstr ""
"В данном примере кортежи лишь выводятся по странице за раз. Но легко "
"изменить функцию, например, путем передачи управления после каждой "
"выборки или с помощью прерывания, если кортежи не будут соответствовать "
"дополнительным критериям."

msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"

msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""
"Вложенный модуль `box.index` с типом индекса RTREE для поиска в "
"пространственных данных"

msgid ""
"The :ref:`box.index <box_index>` submodule may be used for spatial "
"searches if the index type is RTREE. There are operations for searching "
"*rectangles* (geometric objects with 4 corners and 4 sides) and *boxes* "
"(geometric objects with more than 4 corners and more than 4 sides, "
"sometimes called hyperrectangles). This manual uses the term *rectangle-"
"or-box* for the whole class of objects that includes both rectangles and "
"boxes. Only rectangles will be illustrated."
msgstr ""
"Вложенный модуль :ref:`box.index <box_index>` может использоваться для "
"поиска в пространственных данных, если тип индекса -- RTREE. Существуют "
"операции для поиска *прямоугольников* (геометрические фигуры с 4 углами и"
" 4 сторонами) и *параллелепипедов* (геометрические фигуры с количеством "
"углов более 4 и количеством сторон более 4, которые иногда называются "
"гиперпрямоугольниками). В данном руководстве используется термин "
"*прямоугольник-или-параллелепипед* для всего класса объектов, который "
"включает в себя прямоугольники и параллелепипеды. Примерами "
"иллюстрируются только прямоугольники."

msgid ""
"Rectangles are described according to their X-axis (horizontal axis) and "
"Y-axis (vertical axis) coordinates in a grid of arbitrary size. Here is a"
" picture of four rectangles on a grid with 11 horizontal points and 11 "
"vertical points:"
msgstr ""
"Прямоугольники описаны в соответствии с координатами по оси X "
"(горизонтальной оси) и оси Y (вертикальной оси) на сетке произвольного "
"размера. Ниже представлен рисунок четырех прямоугольников на сетке с 11 "
"горизонтальными точками и 11 вертикальными точками:"

msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           "
"<-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   "
"<-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   "
"<-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               "
"<-Rectangle#4"
msgstr ""
"           X AXIS\n"
"                1   2   3   4   5   6   7   8   9   10  11\n"
"             1\n"
"             2  #-------+                                           "
"<-Прямоугольник №1\n"
"     Y AXIS  3  |       |\n"
"             4  +-------#\n"
"             5          #-----------------------+                   "
"<-Прямоугольник №2\n"
"             6          |                       |\n"
"             7          |   #---+               |                   "
"<-Прямоугольник №3\n"
"             8          |   |   |               |\n"
"             9          |   +---#               |\n"
"             10         +-----------------------#\n"
"             11                                     #               "
"<-Прямоугольник №4"

msgid ""
"The rectangles are defined according to this scheme: {X-axis coordinate "
"of top left, Y-axis coordinate of top left, X-axis coordinate of bottom "
"right, Y-axis coordinate of bottom right} -- or more succinctly: "
"{x1,y1,x2,y2}. So in the picture ... Rectangle#1 starts at position 1 on "
"the X axis and position 2 on the Y axis, and ends at position 3 on the X "
"axis and position 4 on the Y axis, so its coordinates are {1,2,3,4}. "
"Rectangle#2's coordinates are {3,5,9,10}. Rectangle#3's coordinates are "
"{4,7,5,9}. And finally Rectangle#4's coordinates are {10,11,10,11}. "
"Rectangle#4 is actually a \"point\" since it has zero width and zero "
"height, so it could have been described with only two digits: {10,11}."
msgstr ""
"Прямоугольники определяются в соответствии со следующей схемой: {верхняя "
"левая координата по оси X, верхняя левая координата по оси Y, нижняя "
"правая координата по оси X, нижняя правая координата по оси Y} -- или "
"коротко: {x1,y1,x2,y2}. Таким образом, на рисунке ... Прямоугольник № 1 "
"начинается в точке 1 по оси X и точке 2 по оси Y, а заканчивается в точке"
" 3 по оси X и точке 4 по оси Y, поэтому его координаты будут следующие: "
"{1,2,3,4}. Координаты Прямоугольника № 2: {3,5,9,10}. Координаты "
"Прямоугольника № 3: {4,7,5,9}. И наконец, координаты Прямоугольника № 4: "
"{10,11,10,11}. Прямоугольник № 4, на самом деле, является точкой, "
"поскольку у него нулевая ширина и нулевая высота, так что его можно "
"описать всего двумя числами: {10,11}."

msgid ""
"Some relationships between the rectangles are: \"Rectangle#1's nearest "
"neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside "
"Rectangle#2\"."
msgstr ""
"Некоторые отношения между прямоугольниками могут быть описаны так: "
"\"Прямоугольник №1 является ближайшим соседом Прямоугольника №2\", а "
"\"Прямоугольник №3 полностью находится внутри Прямоугольника №2\"."

msgid "Now let us create a space and add an RTREE index."
msgstr "Сейчас создадим спейс и добавим RTREE-индекс."

msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

msgid ""
"Field#1 doesn't matter, we just make it because we need a primary-key "
"index. (RTREE indexes cannot be unique and therefore cannot be primary-"
"key indexes.) The second field must be an \"array\", which means its "
"values must represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let "
"us populate the table by inserting two tuples, containing the coordinates"
" of Rectangle#2 and Rectangle#4."
msgstr ""
"Поле №1 не имеет значения, мы создаем его лишь потому, что необходим "
"первичный индекс. (RTREE-индексы не могут быть уникальными, поэтому не "
"могут быть первичными индексами.) Второе поле должно быть массивом "
"(\"array\"), что означает, что его значения должны представлять собой "
"точки {x,y} или прямоугольники {x1,y1,x2,y2}. Заполним таблицу, вставив "
"два кортежа с координатами Прямоугольника №2 и Прямоугольника №4."

msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"

msgid ""
"And now, following the description of `RTREE iterator types`_, we can "
"search the rectangles with these requests:"
msgstr ""
"Затем, после описания типов RTREE-итераторов (`RTREE iterator types`_), "
"можно произвести поиск прямоугольников с помощью данных запросов:"

msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."

msgid ""
"Request#1 returns 1 tuple because the point {10,11} is the same as the "
"rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 "
"returns 1 tuple because the rectangle {4,7,5,9}, which was "
"\"Rectangle#3\" in the picture, is entirely within{3,5,9,10} which was "
"Rectangle#2. Request#3 returns 2 tuples, because the NEIGHBOR iterator "
"always returns all tuples, and the first returned tuple will be "
"{3,5,9,10} (\"Rectangle#2\" in the picture) because it is the closest "
"neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""
"Запрос №1 возвращает 1 кортеж, потому что точка {10,11} представляет "
"собой то же, что и прямоугольник {10,11,10,11} (\"Прямоугольник №4\" на "
"рисунке). Запрос № 2 возвращает 1 кортеж, потому что прямоугольник "
"{4,7,5,9}, который был \"Прямоугольником №3\" на рисунке находится "
"полностью внутри {3,5,9,10}, что представляет собой Прямоугольник № 2. "
"Запрос № 3 возвращает 2 кортежа, потому что итератор NEIGHBOR (сосед) "
"всегда возвращает все кортежи, а первым найденным кортежем будет "
"{3,5,9,10} (\"Прямоугольник №2\" на рисунке), потому что он является "
"ближайшим соседом {1,2,3,4} (\"Прямоугольник №1\" на рисунке)."

msgid ""
"Now let us create a space and index for cuboids, which are rectangle-or-"
"boxes that have 6 corners and 6 sides."
msgstr ""
"Теперь создадим спейс и индекс для кубоидов, которые представляют собой "
"прямоугольники-или-параллелепипеды, у которых 6 углов и 6 сторон."

msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

msgid ""
"The additional option here is ``dimension=3``. The default dimension is "
"2, which is why it didn't need to be specified for the examples of "
"rectangle. The maximum dimension is 20. Now for insertions and selections"
" there will usually be 6 coordinates. For example:"
msgstr ""
"Здесь задается дополнительный параметр``dimension=3``. По умолчанию, "
"измерений 2, поэтому не было необходимости указывать данный параметр в "
"примерах для прямоугольника. Максимальное количество измерений -- 20. Что"
" касается вставки и выборки, здесь будет 6 координат. Например:"

msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"

msgid ""
"Now let us create a space and index for Manhattan-style spatial objects, "
"which are rectangle-or-boxes that have a different way to calculate "
"neighbors."
msgstr ""
"Теперь создадим спейс и индекс для пространственных объектов с метрикой "
"расстояния городских кварталов (метрика Манхэттена), которые представляют"
" собой прямоугольники-или-параллелепипеды; соседи для них рассчитываются "
"иным образом."

msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

msgid ""
"The additional option here is ``distance='manhattan'``. The default "
"distance calculator is 'euclid', which is the straightforward as-the-"
"crow-flies method. The optional distance calculator is 'manhattan', which"
" can be a more appropriate method if one is following the lines of a grid"
" rather than traveling in a straight line."
msgstr ""
"Здесь задается дополнительный параметр ``distance='manhattan'``. По "
"умолчанию, расстояние измеряется по Евклидовой метрике, что лучше всего "
"подходит для измерений по прямой линии. Другой способ расчета расстояния "
"по метрике Манхэттена ('manhattan'), который больше подходит, если "
"необходимо следовать линиям сетки, а не по прямой."

msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"

msgid ""
"More examples of spatial searching are online in the file `R tree index "
"quick start and usage`_."
msgstr ""
"Другие примеры поиска в пространственных данных см. по ссылке `R tree "
"index quick start and usage`_."

#~ msgid ""
#~ "none, any or all of next "
#~ "parameters:  * iterator - type of "
#~ "iterator * limit - maximum number "
#~ "of tuples * offset - start tuple"
#~ " number"
#~ msgstr ""
