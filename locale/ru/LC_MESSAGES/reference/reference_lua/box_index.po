# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-06 15:02+0000\n"
"PO-Revision-Date: 2019-12-06 16:16+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"Generated-By: Babel 2.7.0\n"

#, fuzzy
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.error`"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"The ``box.index`` submodule provides read-only access for index definitions "
"and index keys. Indexes are contained in :samp:`box.space.{space-name}."
"index` array within each space object. They provide an API for ordered "
"iteration over tuples. This API is a direct binding to corresponding methods "
"of index objects of type ``box.index`` in the storage engine."
msgstr ""

msgid "Index"
msgstr "Указатель"

#, fuzzy
msgid "Below is a list of all ``box.index`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``json``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Назначение"

msgid ":ref:`index_object.unique <box_index-unique>`"
msgstr ""

msgid "Flag, true if an index is unique"
msgstr ""

#, fuzzy
msgid ":ref:`index_object.type <box_index-type>`"
msgstr ":ref:`fiber_object.storage <fiber_object-storage>`"

#, fuzzy
msgid "Index type"
msgstr "Указатель"

#, fuzzy
msgid ":ref:`index_object.parts <box_index-parts>`"
msgstr ":ref:`cond_object:wait() <cond_object-wait>`"

msgid "Array of index key fields"
msgstr ""

#, fuzzy
msgid ":ref:`index_object:pairs() <box_index-index_pairs>`"
msgstr ":ref:`pairs() <membership-pairs>`"

msgid "Prepare for iterating"
msgstr ""

#, fuzzy
msgid ":ref:`index_object:select() <box_index-select>`"
msgstr ":ref:`socket_object:sendto() <socket-sendto>`"

#, fuzzy
msgid "Select one or more tuples via index"
msgstr "Выбор одного или нескольких кортежей"

#, fuzzy
msgid ":ref:`index_object:get() <box_index-get>`"
msgstr ":ref:`channel_object:get() <channel_object-get>`"

#, fuzzy
msgid "Select a tuple via index"
msgstr "Выбор кортежа"

#, fuzzy
msgid ":ref:`index_object:min() <box_index-min>`"
msgstr ":ref:`cond_object:signal() <cond_object-signal>`"

#, fuzzy
msgid "Find the minimum value in index"
msgstr "Возврат шестнадцатеричного значения введенной строки."

#, fuzzy
msgid ":ref:`index_object:max() <box_index-max>`"
msgstr ":ref:`cond_object:wait() <cond_object-wait>`"

#, fuzzy
msgid "Find the maximum value in index"
msgstr "Возврат шестнадцатеричного значения введенной строки."

#, fuzzy
msgid ":ref:`index_object:random() <box_index-random>`"
msgstr ":ref:`digest.urandom() <digest-urandom>`"

msgid "Find a random value in index"
msgstr ""

#, fuzzy
msgid ":ref:`index_object:count() <box_index-count>`"
msgstr ":ref:`channel_object:count() <channel_object-count>`"

msgid "Count tuples matching key value"
msgstr ""

#, fuzzy
msgid ":ref:`index_object:update() <box_index-update>`"
msgstr ":ref:`cond_object:wait() <cond_object-wait>`"

msgid "Update a tuple"
msgstr "Обновление кортежа"

#, fuzzy
msgid ":ref:`index_object:delete() <box_index-delete>`"
msgstr ":ref:`socket_object:sendto() <socket-sendto>`"

#, fuzzy
msgid "Delete a tuple by key"
msgstr "Удаление кортежа"

#, fuzzy
msgid ":ref:`index_object:alter() <box_index-alter>`"
msgstr ":ref:`cond_object:wait() <cond_object-wait>`"

#, fuzzy
msgid "Alter an index"
msgstr "Создание экземпляра iconv"

#, fuzzy
msgid ":ref:`index_object:drop() <box_index-drop>`"
msgstr ":ref:`fiber_object:id() <fiber_object-id>`"

#, fuzzy
msgid "Drop an index"
msgstr "Копирование файла"

#, fuzzy
msgid ":ref:`index_object:rename() <box_index-rename>`"
msgstr ":ref:`socket_object:name() <socket-name>`"

#, fuzzy
msgid "Rename an index"
msgstr "Создание экземпляра iconv"

#, fuzzy
msgid ":ref:`index_object:bsize() <box_index-bsize>`"
msgstr ":ref:`cond_object:signal() <cond_object-signal>`"

msgid "Get count of bytes for an index"
msgstr ""

#, fuzzy
msgid ":ref:`index_object:stat() <box_index-stat>`"
msgstr ":ref:`client_object:stat() <client_object-stat>`"

#, fuzzy
msgid "Get statistics for an index"
msgstr "Получение статистики об открытом файле"

#, fuzzy
msgid ":ref:`index_object:compact() <box_index-compact>`"
msgstr ":ref:`cond_object:broadcast() <cond_object-broadcast>`"

msgid "Remove unused index space"
msgstr ""

#, fuzzy
msgid ":ref:`index_object:user_defined() <box_index-user_defined>`"
msgstr ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"

msgid "Any function / method that any user wants to add"
msgstr ""

#, fuzzy
msgid "True if the index is unique, false if the index is not unique."
msgstr ""
"true, если сокет доступен для записи, false, если истекло время ожидания;"

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "boolean"
msgstr "boolean (логический)"

msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

msgid ""
"An array describing the index fields. To learn more about the index field "
"types, refer to :ref:`this table <box_space-index_field_types>`."
msgstr ""

msgid "table"
msgstr "таблица"

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#, fuzzy
msgid ""
"Search for a tuple or a set of tuples via the given index, and allow "
"iterating over one tuple at a time."
msgstr "Открытие файла и итерация по одной записи файла за раз."

msgid "The :samp:`{key}` parameter specifies what must match within the index."
msgstr ""

msgid ""
":samp:`{key}` is only used to find the first match. Do not assume all "
"matched tuples will contain the key."
msgstr ""

msgid ""
"The :samp:`{iterator}` parameter specifies the rule for matching and "
"ordering. Different index types support different iterators. For example, a "
"TREE index maintains a strict order of keys and can return all tuples in "
"ascending or descending order, starting from the specified key. Other index "
"types, however, do not support ordering."
msgstr ""

msgid ""
"To understand consistency of tuples returned by an iterator, it's essential "
"to know the principles of the Tarantool transaction processing subsystem. An "
"iterator in Tarantool does not own a consistent read view. Instead, each "
"procedure is granted exclusive access to all tuples and spaces until there "
"is a \"context switch\": which may happen due to :ref:`the implicit yield "
"rules <atomic-implicit-yields>`, or by an explicit call to :ref:`fiber.yield "
"<fiber-yield>`. When the execution flow returns to the yielded procedure, "
"the data set could have changed significantly. Iteration, resumed after a "
"yield point, does not preserve the read view, but continues with the new "
"content of the database. The tutorial :ref:`Indexed pattern search "
"<c_lua_tutorial-indexed_pattern_search>` shows one way that iterators and "
"yields can be used together."
msgstr ""

msgid ""
"For information about iterators' internal structures see the `\"Lua "
"Functional library\" <https://luafun.github.io/index.html>`_ documentation."
msgstr ""

msgid "Parameters"
msgstr "Параметры"

msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ""

msgid "value to be matched against the index key, which may be multi-part"
msgstr ""

msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr ""

msgid "return"
msgstr "возвращает"

msgid ""
"`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a for/"
"end loop or with `totable() <https://rtsisyk.github.io/luafun/reducing."
"html#fun.totable>`_"
msgstr ""

#, fuzzy
msgid "**Possible errors:**"
msgstr "**Возможные ошибки:** nil."

msgid "no such space; wrong type;"
msgstr ""

msgid "selected iteration type is not supported for the index type;"
msgstr ""

msgid "key is not supported for the iteration type."
msgstr ""

msgid ""
"**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""

msgid ""
"A search-key-value can be a number (for example ``1234``), a string (for "
"example ``'abcd'``), or a table of numbers and strings (for example ``{1234, "
"'abcd'}``). Each part of a key will be compared to each part of an index key."
msgstr ""

msgid ""
"The returned tuples will be in order by index key value, or by the hash of "
"the index key value if index type = 'hash'. If the index is non-unique, then "
"duplicates will be secondarily in order by primary key value. The order will "
"be reversed if the iterator type is 'LT' or 'LE' or 'REQ'."
msgstr ""

msgid "**Iterator types for TREE indexes**"
msgstr ""

#, fuzzy
msgid "Type"
msgstr "тип возвращаемого значения"

msgid "Arguments"
msgstr ""

#, fuzzy
msgid "Description"
msgstr "дескриптор файла"

msgid "box.index.EQ or 'EQ'"
msgstr ""

msgid "search value"
msgstr ""

msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a "
"search value, it matches. Tuples are returned in ascending order by index "
"key. This is the default."
msgstr ""

msgid "box.index.REQ or 'REQ'"
msgstr ""

msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in "
"descending order by index key."
msgstr ""

msgid "box.index.GT or 'GT'"
msgstr ""

msgid ""
"The comparison operator is '>' (greater than). If an index key is greater "
"than a search value, it matches. Tuples are returned in ascending order by "
"index key."
msgstr ""

msgid "box.index.GE or 'GE'"
msgstr ""

msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index key "
"is greater than or equal to a search value, it matches. Tuples are returned "
"in ascending order by index key."
msgstr ""

msgid "box.index.ALL or 'ALL'"
msgstr ""

msgid "Same as box.index.GE."
msgstr ""

msgid "box.index.LT or 'LT'"
msgstr ""

msgid ""
"The comparison operator is '<' (less than). If an index key is less than a "
"search value, it matches. Tuples are returned in descending order by index "
"key."
msgstr ""

msgid "box.index.LE or 'LE'"
msgstr ""

msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key is "
"less than or equal to a search value, it matches. Tuples are returned in "
"descending order by index key."
msgstr ""

msgid ""
"Informally, we can state that searches with TREE indexes are generally what "
"users will find is intuitive, provided that there are no nils and no missing "
"parts. Formally, the logic is as follows. A search key has zero or more "
"parts, for example {}, {1,2,3},{1,nil,3}. An index key has one or more "
"parts, for example {1}, {1,2,3},{1,2,3}. A search key may contain nil (but "
"not msgpack.NULL, which is the wrong type). An index key may not contain nil "
"or msgpack.NULL, although a later version of Tarantool will have different "
"rules --  the behavior of searches with nil is subject to change. Possible "
"iterators are LT, LE, EQ, REQ, GE, GT. A search key is said to \"match\" an "
"index key if the following statements, which are pseudocode for the "
"comparison operation, return TRUE."
msgstr ""

msgid ""
"If (number-of-search-key-parts > number-of-index-key-parts) return ERROR\n"
"If (number-of-search-key-parts == 0) return TRUE\n"
"for (i = 1; ; ++i)\n"
"{\n"
"  if (i > number-of-search-key-parts) OR (search-key-part[i] is nil)\n"
"  {\n"
"    if (iterator is LT or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (type of search-key-part[i] is not compatible with type of index-key-"
"part[i])\n"
"  {\n"
"    return ERROR\n"
"  }\n"
"  if (search-key-part[i] == index-key-part[i])\n"
"  {\n"
"    continue\n"
"  }\n"
"  if (search-key-part[i] > index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or LE or LT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (search-key-part[i] < index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or GE or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"}"
msgstr ""

msgid "**Iterator types for HASH indexes**"
msgstr ""

msgid "box.index.ALL"
msgstr ""

msgid "none"
msgstr ""

msgid ""
"All index keys match. Tuples are returned in ascending order by hash of "
"index key, which will appear to be random."
msgstr ""

msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a "
"search value, it matches. The number of returned tuples will be 0 or 1. This "
"is the default."
msgstr ""

msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key is "
"greater than a hash of a search value, it matches. Tuples are returned in "
"ascending order by hash of index key, which will appear to be random. "
"Provided that the space is not being updated, one can retrieve all the "
"tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} in "
"each search, and using the last returned value from the previous result as "
"the start search value for the next search."
msgstr ""

msgid "**Iterator types for BITSET indexes**"
msgstr ""

msgid ""
"All index keys match. Tuples are returned in their order within the space."
msgstr ""

msgid "bitset value"
msgstr ""

msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are returned "
"in their order within the space. This is the default."
msgstr ""

msgid "box.index.BITS_ALL_SET"
msgstr ""

msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""

msgid "box.index.BITS_ANY_SET"
msgstr ""

msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""

msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""

msgid "**Iterator types for RTREE indexes**"
msgstr ""

msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

msgid ""
"If all points of the rectangle-or-box defined by the search value are the "
"same as the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space. \"Rectangle-or-box\" means "
"\"rectangle-or-box as explained in section about :ref:`RTREE <box_index-"
"rtree>`\". This is the default."
msgstr ""

msgid ""
"If all points of the rectangle-or-box defined by the search value are within "
"the rectangle-or-box defined by the index key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""

msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within, or at the side of, the rectangle-or-box defined by the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

msgid ""
"If all points of the rectangle-or-box defined by the index key are within "
"the rectangle-or-box defined by the search key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""

msgid ""
"If all points of the rectangle-or-box defined by the index key are within, "
"or at the side of, the rectangle-or-box defined by the search key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

msgid ""
"If some points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""

msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

msgid ""
"If some points of the rectangle-or-box defined by the defined by the key are "
"within, or at the side of, defined by the index key, it matches. Tuples are "
"returned in order: nearest neighbor first."
msgstr ""

msgid "**First example of index pairs():**"
msgstr ""

msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

msgid "**Second example of index pairs():**"
msgstr ""

msgid ""
"This Lua code finds all the tuples whose primary key values begin with 'XY'. "
"The assumptions include that there is a one-part primary-key TREE index on "
"the first field, which must be a string. The iterator loop ensures that the "
"search will return tuples where the first value is greater than or equal to "
"'XY'. The conditional statement within the loop ensures that the looping "
"will stop when the first two letters are not 'XY'."
msgstr ""

msgid ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

msgid "**Third example of index pairs():**"
msgstr ""

msgid ""
"This Lua code finds all the tuples whose primary key values are greater than "
"or equal to 1000, and less than or equal to 1999 (this type of request is "
"sometimes called a \"range search\" or a \"between search\"). The "
"assumptions include that there is a one-part primary-key TREE index on the "
"first field, which must be a :ref:`number <index-box_number>`. The iterator "
"loop ensures that the search will return tuples where the first value is "
"greater than or equal to 1000. The conditional statement within the loop "
"ensures that the looping will stop when the first value is greater than 1999."
msgstr ""

msgid ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` "
"which goes via a particular index and can make use of additional parameters "
"that specify the iterator type, and the limit (that is, the maximum number "
"of tuples to return) and the offset (that is, which tuple to start with in "
"the list)."
msgstr ""

msgid "values to be matched against the index key"
msgstr ""

msgid "none, any or all of next parameters"
msgstr ""

#, fuzzy
msgid "type of iterator"
msgstr "Lua-итератор"

#, fuzzy
msgid "maximum number of tuples"
msgstr "максимальное количество показываемых сегментов"

msgid "start tuple number"
msgstr ""

msgid "the tuple or tuples that match the field values."
msgstr ""

msgid "array of tuples"
msgstr ""

msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#, fuzzy
msgid "The result will be a table of tuple and will look like this:"
msgstr "Результат последнего запроса выглядит следующим образом:"

msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the assumed "
"index is the first (primary-key) index. Therefore, for the example above, "
"``box.space.tester:select({1}, {iterator = 'GT'})`` would have returned the "
"same two rows, via the 'primary' index."
msgstr ""

msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""

msgid ""
":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, "
"then every key in the index is considered to be a match, regardless of "
"iterator type. Therefore, for the example above, ``box.space.tester:select{}"
"`` will select every tuple in the tester space via the first (primary-key) "
"index."
msgstr ""

msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be "
"replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That "
"is, ``get`` can be used as a convenient shorthand to get the first tuple in "
"the tuple set that would be returned by ``select``. However, if there is "
"more than one tuple in the tuple set, then ``get`` throws an error."
msgstr ""

msgid "**Example with BITSET index:**"
msgstr ""

msgid ""
"The following script shows creation and search with a BITSET index. Notice: "
"BITSET cannot be unique, so first a primary-key index is created. Notice: "
"bit values are entered as hexadecimal literals for easier reading."
msgstr ""

msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

msgid ""
"Search for a tuple via the given index, as described :ref:`earlier "
"<box_index-note>`."
msgstr ""

msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

msgid "tuple"
msgstr ""

msgid "no such index;"
msgstr ""

msgid "wrong type;"
msgstr ""

msgid "more than one tuple matches."
msgstr ""

msgid ""
"**Complexity factors:** Index size, Index type. See also :ref:`space_object:"
"get() <box_space-get>`."
msgstr ""

#, fuzzy
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""
"tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."

#, fuzzy
msgid "Find the minimum value in the specified index."
msgstr "Возврат статуса указанного файбера."

msgid ""
"the tuple for the first key in the index. If optional ``key`` value is "
"supplied, returns the first key which is greater than or equal to ``key`` "
"value. Starting with Tarantool version 2.0, index_object:min(``key`` value) "
"will return nothing if ``key`` value is not equal to a value in the index."
msgstr ""

#, fuzzy
msgid "**Possible errors:** index is not of type 'TREE'."
msgstr "**Возможные ошибки:** nil."

msgid "**Complexity factors:** Index size, Index type."
msgstr ""

msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#, fuzzy
msgid "Find the maximum value in the specified index."
msgstr "Возврат шестнадцатеричного значения введенной строки."

msgid ""
"the tuple for the last key in the index. If optional ``key`` value is "
"supplied, returns the last key which is less than or equal to ``key`` value. "
"Starting with Tarantool version 2.0, index_object:max(``key`` value) will "
"return nothing if ``key`` value is not equal to a value in the index."
msgstr ""

msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

msgid ""
"Find a random value in the specified index. This method is useful when it's "
"important to get insight into data distribution in an index without having "
"to iterate over the entire data set."
msgstr ""

#, fuzzy
msgid "an arbitrary non-negative integer"
msgstr "Тип: непустая строка или неотрицательное целое число"

msgid "the tuple for the random key in the index."
msgstr ""

msgid "**Note re storage engine:** vinyl does not support ``random()``."
msgstr ""

msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

msgid ""
"Iterate over an index, counting the number of tuples which match the key-"
"value."
msgstr ""

#, fuzzy
msgid "comparison method"
msgstr "Сравнения"

#, fuzzy
msgid "the number of matching tuples."
msgstr "количество сообщений."

msgid "number"
msgstr "число"

msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#, fuzzy
msgid "Update a tuple."
msgstr "Обновление кортежа"

msgid ""
"Same as :ref:`box.space...update() <box_space-update>`, but key is searched "
"in this index instead of primary key. This index ought to be unique."
msgstr ""

msgid "operation type represented in string"
msgstr ""

msgid ""
"what field the operation will apply to. The field number can be negative, "
"meaning the position from the end of tuple. (#tuple + negative field number "
"+ 1)"
msgstr ""

#, fuzzy
msgid "what value will be applied"
msgstr "значение для проверки"

#, fuzzy
msgid "the updated tuple."
msgstr "Обновление кортежа"

msgid "Delete a tuple identified by a key."
msgstr ""

msgid ""
"Same as :ref:`box.space...delete() <box_space-delete>`, but key is searched "
"in this index instead of in the primary-key index. This index ought to be "
"unique."
msgstr ""

#, fuzzy
msgid "the deleted tuple."
msgstr "Удаление кортежа"

msgid ""
"**Note re storage engine:** vinyl will return `nil`, rather than the deleted "
"tuple."
msgstr ""

msgid ""
"Alter an index. It is legal in some circumstances to change one or more of "
"the index characteristics, for example its type, its sequence options, its "
"parts, and whether it is unique, Usually this causes rebuilding of the "
"space,  except for the simple case where a part's ``is_nullable`` flag is "
"changed from ``false`` to ``true``."
msgstr ""

#, fuzzy
msgid ""
"options list, same as the options list for ``create_index``, see the chart "
"named :ref:`Options for space_object:create_index() <box_space-"
"create_index>`."
msgstr ""
"Если ``vinyl_range_size`` содержит не нулевое значение nil и не 0, это "
"значение используется в качестве значения по умолчанию для параметра "
"``range_size`` в таблице :ref:`Параметры space_object:create_index() "
"<box_space-create_index>`."

msgid "nil"
msgstr "nil"

#, fuzzy
msgid "index does not exist,"
msgstr "Указанный спейс отсутствует."

msgid "the primary-key index cannot be changed to ``{unique = false}``."
msgstr ""

msgid ""
"**Note re storage engine:** vinyl does not support ``alter()`` of a primary-"
"key index unless the space is empty."
msgstr ""

msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."
msgstr ""

msgid ""
"Drop an index. Dropping a primary-key index has a side effect: all tuples "
"are deleted."
msgstr ""

msgid "nil."
msgstr ""

msgid ""
"a primary-key index cannot be dropped while a secondary-key index exists."
msgstr ""

#, fuzzy
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."

#, fuzzy
msgid "Rename an index."
msgstr "Создание экземпляра iconv"

msgid "new name for index"
msgstr ""

#, fuzzy
msgid "**Possible errors:** index_object does not exist."
msgstr "**Возможные ошибки:** nil."

msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

msgid ""
"**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#, fuzzy
msgid "Return the total number of bytes taken by the index."
msgstr "Возврат числа секунд между двумя значениями времени."

#, fuzzy
msgid "number of bytes"
msgstr "количество байтов для чтения"

#, fuzzy
msgid "Return statistics about actions taken that affect the index."
msgstr "Получение статистики об открытом файле"

msgid "This is for use with the vinyl engine."
msgstr ""

msgid "Some detail items in the output from ``index_object:stat()`` are:"
msgstr ""

msgid "``index_object:stat().latency`` -- timings subdivided by percentages;"
msgstr ""

msgid "``index_object:stat().bytes`` -- the number of bytes total;"
msgstr ""

msgid ""
"``index_object:stat().disk.rows`` -- the approximate number of tuples in "
"each range;"
msgstr ""

msgid ""
"``index_object:stat().disk.statement`` -- counts of inserts|updates|upserts|"
"deletes;"
msgstr ""

msgid ""
"``index_object:stat().disk.compaction`` -- counts of compactions and their "
"amounts;"
msgstr ""

msgid "``index_object:stat().disk.dump`` -- counts of dumps and their amounts;"
msgstr ""

msgid ""
"``index_object:stat().disk.iterator.bloom`` -- counts of bloom filter hits|"
"misses;"
msgstr ""

msgid "``index_object:stat().disk.pages`` -- the size in pages;"
msgstr ""

msgid ""
"``index_object:stat().disk.last_level`` -- size of data in the last LSM tree "
"level;"
msgstr ""

msgid ""
"``index_object:stat().cache.evict`` -- number of evictions from the cache;"
msgstr ""

msgid ""
"``index_object:stat().range_size`` -- maximum number of bytes in a range;"
msgstr ""

msgid ""
"``index_object:stat().dumps_per_compaction`` -- average number of dumps "
"required to trigger major compaction in any range of the LSM tree."
msgstr ""

msgid ""
"Summary index statistics are also available via :ref:`box.stat.vinyl() "
"<box_introspection-box_stat_vinyl_details>`."
msgstr ""

msgid "statistics"
msgstr ""

msgid ""
"Remove unused index space. For the memtx storage engine this method does "
"nothing; ``index_object:compact()`` is only for the vinyl storage engine. "
"For example, with vinyl, if a tuple is deleted, the space is not immediately "
"reclaimed. There is a scheduler for reclaiming space automatically based on "
"factors such as lsm shape and amplification as discussed in the section :ref:"
"`Storing data with vinyl <engines-vinyl>`, so calling ``index_object:"
"compact()`` manually is not always necessary."
msgstr ""

msgid "nil (Tarantool returns without waiting for compaction to complete)"
msgstr ""

msgid ""
"Users can define any functions they want, and associate them with indexes: "
"in effect they can make their own index methods. They do this by:"
msgstr ""

msgid "creating a Lua function,"
msgstr ""

msgid ""
"adding the function name to a predefined global variable which has type = "
"table, and"
msgstr ""

msgid ""
"invoking the function any time thereafter, as long as the server is up, by "
"saying ``index_object:function-name([parameters])``."
msgstr ""

msgid "There are three predefined global variables:"
msgstr ""

msgid ""
"Adding to ``box_schema.index_mt`` makes the method available for all indexes."
msgstr ""

msgid ""
"Adding to ``box_schema.memtx_index_mt`` makes the method available for all "
"memtx indexes."
msgstr ""

msgid ""
"Adding to ``box_schema.vinyl_index_mt`` makes the method available for all "
"vinyl indexes."
msgstr ""

msgid ""
"Alternatively, user-defined methods can be made available for only one "
"index, by calling ``getmetatable(index_object)`` and then adding the "
"function name to the meta table."
msgstr ""

msgid "whatever the user defines"
msgstr ""

msgid ""
"-- Visible to any index of a memtx space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t', {engine='memtx'})\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f() global_variable = global_variable + 1 end\n"
"box.schema.memtx_index_mt.counter = f\n"
"box.space.t.index.i:counter()"
msgstr ""

msgid ""
"-- Visible to index box.space.t.index.i only, 1 parameter.\n"
"-- After these requests, the value of X will be 1005.\n"
"box.schema.space.create('t', {engine='memtx', id = 1000})\n"
"box.space.t:create_index('i')\n"
"X = 0\n"
"i = box.space.t.index.i\n"
"function f(i_arg, param) X = X + param + i_arg.space_id end\n"
"box.schema.memtx_index_mt.counter = f\n"
"meta = getmetatable(i)\n"
"meta.counter = f\n"
"i:counter(5)"
msgstr ""

msgid "Example showing use of the box functions"
msgstr ""

msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary key. "
"The example function will:"
msgstr ""

msgid "select a tuple whose key value is 1000;"
msgstr ""

msgid "raise an error if the tuple already exists and already has 3 fields;"
msgstr ""

#, fuzzy
msgid "Insert or replace the tuple with:"
msgstr "Вставка или замена кортежа"

msgid "field[1] = 1000"
msgstr ""

msgid "field[2] = a uuid"
msgstr ""

#, fuzzy
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr "Получение числа секунд с начала отсчета"

msgid "Get field[3] from what was replaced;"
msgstr ""

msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#, fuzzy
msgid "Return the formatted value."
msgstr "Возврат даты в формате."

msgid ""
"The function uses Tarantool box functions :ref:`box.space...select "
"<box_space-select>`, :ref:`box.space...replace <box_space-replace>`, :ref:"
"`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function uses Lua "
"functions `os.date()`_ and `string.sub()`_."
msgstr ""

msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

msgid "... And here is what happens when one invokes the function:"
msgstr ""

msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#, fuzzy
msgid "Example showing a user-defined iterator"
msgstr "номер предварительно заданной ошибки"

msgid ""
"Here is an example that shows how to build one's own iterator. The "
"``paged_iter`` function is an \"iterator function\", which will only be "
"understood by programmers who have read the Lua manual section `Iterators "
"and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated "
"retrievals, that is, it returns 10 tuples at a time from a table named \"t"
"\", whose primary key was defined with ``create_index('primary',"
"{parts={1,'string'}})``."
msgstr ""

msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

msgid ""
"Programmers who use ``paged_iter`` do not need to know why it works, they "
"only need to know that, if they call it within a loop, they will get 10 "
"tuples at a time until there are no more tuples."
msgstr ""

msgid ""
"In this example the tuples are merely printed, a page at a time. But it "
"should be simple to change the functionality, for example by yielding after "
"each retrieval, or by breaking when the tuples fail to match some additional "
"criteria."
msgstr ""

msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""

msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""

msgid ""
"The :ref:`box.index <box_index>` submodule may be used for spatial searches "
"if the index type is RTREE. There are operations for searching *rectangles* "
"(geometric objects with 4 corners and 4 sides) and *boxes* (geometric "
"objects with more than 4 corners and more than 4 sides, sometimes called "
"hyperrectangles). This manual uses the term *rectangle-or-box* for the whole "
"class of objects that includes both rectangles and boxes. Only rectangles "
"will be illustrated."
msgstr ""

msgid ""
"Rectangles are described according to their X-axis (horizontal axis) and Y-"
"axis (vertical axis) coordinates in a grid of arbitrary size. Here is a "
"picture of four rectangles on a grid with 11 horizontal points and 11 "
"vertical points:"
msgstr ""

msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-"
"Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-"
"Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-"
"Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""

msgid ""
"The rectangles are defined according to this scheme: {X-axis coordinate of "
"top left, Y-axis coordinate of top left, X-axis coordinate of bottom right, "
"Y-axis coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So "
"in the picture ... Rectangle#1 starts at position 1 on the X axis and "
"position 2 on the Y axis, and ends at position 3 on the X axis and position "
"4 on the Y axis, so its coordinates are {1,2,3,4}. Rectangle#2's coordinates "
"are {3,5,9,10}. Rectangle#3's coordinates are {4,7,5,9}. And finally "
"Rectangle#4's coordinates are {10,11,10,11}. Rectangle#4 is actually a "
"\"point\" since it has zero width and zero height, so it could have been "
"described with only two digits: {10,11}."
msgstr ""

msgid ""
"Some relationships between the rectangles are: \"Rectangle#1's nearest "
"neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside "
"Rectangle#2\"."
msgstr ""

msgid "Now let us create a space and add an RTREE index."
msgstr ""

msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

msgid ""
"Field#1 doesn't matter, we just make it because we need a primary-key index. "
"(RTREE indexes cannot be unique and therefore cannot be primary-key "
"indexes.) The second field must be an \"array\", which means its values must "
"represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let us populate the "
"table by inserting two tuples, containing the coordinates of Rectangle#2 and "
"Rectangle#4."
msgstr ""

msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

msgid ""
"And now, following the description of `RTREE iterator types`_, we can search "
"the rectangles with these requests:"
msgstr ""

msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

msgid ""
"Request#1 returns 1 tuple because the point {10,11} is the same as the "
"rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns "
"1 tuple because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the "
"picture, is entirely within{3,5,9,10} which was Rectangle#2. Request#3 "
"returns 2 tuples, because the NEIGHBOR iterator always returns all tuples, "
"and the first returned tuple will be {3,5,9,10} (\"Rectangle#2\" in the "
"picture) because it is the closest neighbor of {1,2,3,4} (\"Rectangle#1\" in "
"the picture)."
msgstr ""

msgid ""
"Now let us create a space and index for cuboids, which are rectangle-or-"
"boxes that have 6 corners and 6 sides."
msgstr ""

msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

msgid ""
"The additional option here is ``dimension=3``. The default dimension is 2, "
"which is why it didn't need to be specified for the examples of rectangle. "
"The maximum dimension is 20. Now for insertions and selections there will "
"usually be 6 coordinates. For example:"
msgstr ""

msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

msgid ""
"Now let us create a space and index for Manhattan-style spatial objects, "
"which are rectangle-or-boxes that have a different way to calculate "
"neighbors."
msgstr ""

msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

msgid ""
"The additional option here is ``distance='manhattan'``. The default distance "
"calculator is 'euclid', which is the straightforward as-the-crow-flies "
"method. The optional distance calculator is 'manhattan', which can be a more "
"appropriate method if one is following the lines of a grid rather than "
"traveling in a straight line."
msgstr ""

msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

msgid ""
"More examples of spatial searching are online in the file `R tree index "
"quick start and usage`_."
msgstr ""
