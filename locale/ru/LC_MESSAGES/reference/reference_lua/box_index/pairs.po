
msgid "index_object:pairs()"
msgstr ""

msgid ""
"Search for a tuple or a set of tuples via the given index, and allow "
"iterating over one tuple at a time."
msgstr ""
"Поиск кортежа или набора кортежей по заданному индексу и итерация по одному "
"кортежу за раз."

msgid ""
"The :samp:`{key}` parameter specifies what must match within the index."
msgstr ""
"Параметр :samp:`{key}` (ключ) задает, что именно должно совпадать в индексе."

msgid ""
":samp:`{key}` is only used to find the first match. Do not assume all "
"matched tuples will contain the key."
msgstr ""
":samp:`{key}` используется в поиске только первого совпадения. Не стоит "
"ожидать, что все подобранные кортежи будут содержать этот ключ."

msgid ""
"The :samp:`{iterator}` parameter specifies the rule for matching and "
"ordering. Different index types support different iterators. For example, a "
"TREE index maintains a strict order of keys and can return all tuples in "
"ascending or descending order, starting from the specified key. Other index "
"types, however, do not support ordering."
msgstr ""
"Параметр :samp:`{iterator}` (итератор) задает правило для совпадений и "
"упорядочивания. Различные типы индексов поддерживают различные итераторы. "
"Например, TREE-индекс поддерживает строгий порядок ключей и может вернуть "
"все кортежи в порядке по возрастанию или по убыванию, начиная с указанного "
"ключа. Однако другие типы индексов не поддерживают упорядочивание."

msgid ""
"To understand consistency of tuples returned by an iterator, it's essential "
"to know the principles of the Tarantool transaction processing subsystem. An"
" iterator in Tarantool does not own a consistent read view. Instead, each "
"procedure is granted exclusive access to all tuples and spaces until there "
"is a \"context switch\": which may happen due to :ref:`the implicit yield "
"rules <atomic-implicit-yields>`, or by an explicit call to :ref:`fiber.yield"
" <fiber-yield>`. When the execution flow returns to the yielded procedure, "
"the data set could have changed significantly. Iteration, resumed after a "
"yield point, does not preserve the read view, but continues with the new "
"content of the database. The tutorial :ref:`Indexed pattern search "
"<c_lua_tutorial-indexed_pattern_search>` shows one way that iterators and "
"yields can be used together."
msgstr ""
"Чтобы понять логику возврата кортежей с помощью итератора, важно знать "
"принципы работы подсистемы обработки транзакций в Tarantool. В итераторе "
"Tarantool нет собственного постоянного вида просмотра. Наоборот, каждая "
"процедура получает эксклюзивный доступ ко всем кортежам и спейсам до тех "
"пор, пока не \"переключится контекст\", что может произойти по причине "
":ref:`неявной передачи управления <atomic-implicit-yields>` или в результате"
" явного вызова функции :ref:`fiber.yield <fiber-yield>`. Когда поток "
"выполнения возвращается к процедуре, передавшей управление, набор данных "
"может уже значительно измениться. Итерация возобновляется после стадии "
"передачи управления и не сохраняет вид просмотра, а продолжает работу с "
"новым содержимым базы данных. В практическом задании :ref:`\"Индексированный"
" поиск по шаблонам\" <c_lua_tutorial-indexed_pattern_search>` "
"демонстрируется один из способов одновременного использования итераторов и "
"передачи управления."

msgid ""
"For information about iterators' internal structures see the `\"Lua "
"Functional library\" <https://luafun.github.io/index.html>`_ documentation."
msgstr ""
"Для получения информации о внутренней структуре итераторов см. документацию "
"по библиотеке для функционального программирования в Lua `\"Lua Functional "
"library\" <https://luafun.github.io/index.html>`_."

msgid "Parameters"
msgstr "Параметры"

msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ":ref:`ссылка на объект <app_server-object_reference>`."

msgid "value to be matched against the index key, which may be multi-part"
msgstr ""
"значение должно совпасть с индексным ключом, который может быть составным"

msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr ""
"как определено в таблицах ниже. По умолчанию используется итератор 'EQ'"

msgid "return"
msgstr "возвращает"

msgid ""
"`iterator <https://luafun.github.io/under_the_hood.html>`_ which can be used in a "
"``for/end`` loop or with `totable() "
"<https://luafun.github.io/reducing.html#fun.totable>`_"
msgstr ""
"`итератор <https://luafun.github.io/under_the_hood.html>`_, который может использовать в"
" цикле for/end или с функцией `totable() "
"<https://luafun.github.io/reducing.html#fun.totable>`_"

msgid "**Possible errors:**"
msgstr "**Возможные ошибки:**"

msgid "no such space; wrong type;"
msgstr "спейс отсутствует; неправильный тип;"

msgid "selected iteration type is not supported for the index type;"
msgstr "выбранный тип итерации не поддерживается для данного типа индекса;"

msgid "key is not supported for the iteration type."
msgstr "ключ не поддерживается для данного типа итерации."

msgid ""
"**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса; количество кортежей, к "
"которым получен доступ."

msgid ""
"A search-key-value can be a number (for example ``1234``), a string (for "
"example ``'abcd'``), or a table of numbers and strings (for example ``{1234,"
" 'abcd'}``). Each part of a key will be compared to each part of an index "
"key."
msgstr ""
"Значение искомого ключа может представлять собой число (например, ``1234``),"
" строку (например, ``'abcd'``) или таблицу из чисел и строк (например, "
"``{1234, 'abcd'}``). Каждая часть ключа будет сопоставляться с каждой частью"
" ключа в индексе."

msgid ""
"The returned tuples will be in order by index key value, or by the hash of "
"the index key value if index type = 'hash'. If the index is non-unique, then"
" duplicates will be secondarily in order by primary key value. The order "
"will be reversed if the iterator type is 'LT' or 'LE' or 'REQ'."
msgstr ""
"Найденные кортежи будут упорядочены по значению ключа в индексе или по хешу "
"значения ключа, если тип индекса -- 'hash'. Если индекс не уникален, то "
"дубликаты будут упорядочены во вторую очередь по первичному значению ключа. "
"Порядок будет обратным, если тип итератора -- 'LT', 'LE' или 'REQ'."

msgid "**Iterator types for TREE indexes**"
msgstr "**Типы итераторов для TREE-индексов**"

msgid "Iterator type"
msgstr "Тип итератора"

msgid "Arguments"
msgstr "Аргументы"

msgid "Description"
msgstr "Описание"

msgid "box.index.EQ or 'EQ'"
msgstr "box.index.EQ или 'EQ'"

msgid "search value"
msgstr "искомое значение"

msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a "
"search value, it matches. Tuples are returned in ascending order by index "
"key. This is the default."
msgstr ""
"Оператором сравнения будет '==' (равно). Если ключ индекса равен искомому "
"значению, получим совпадение. Найденные кортежи упорядочены по возрастанию "
"по ключу индекса. Этот тип используется по умолчанию."

msgid "box.index.REQ or 'REQ'"
msgstr "box.index.REQ или 'REQ'"

msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in "
"descending order by index key."
msgstr ""
"Совпадения находятся таким же образом, что и для ``box.index.EQ``. Разница "
"только в том, что найденные кортежи упорядочены по ключу индекса по "
"убыванию, а не по возрастанию."

msgid "box.index.GT or 'GT'"
msgstr "box.index.GT или 'GT'"

msgid ""
"The comparison operator is '>' (greater than). If an index key is greater "
"than a search value, it matches. Tuples are returned in ascending order by "
"index key."
msgstr ""
"Оператором сравнения будет '>' (больше чем). Если ключ индекса больше, чем "
"искомое значение, получим совпадение. Найденные кортежи упорядочены по "
"возрастанию по ключу индекса."

msgid "box.index.GE or 'GE'"
msgstr "box.index.GE или 'GE'"

msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index key "
"is greater than or equal to a search value, it matches. Tuples are returned "
"in ascending order by index key."
msgstr ""
"Оператором сравнения будет '>=' (больше или равен). Если ключ индекса больше"
" искомого значения или равен ему, получим совпадение. Найденные кортежи "
"упорядочены по возрастанию по ключу индекса."

msgid "box.index.ALL or 'ALL'"
msgstr "box.index.ALL или 'ALL'"

msgid "Same as box.index.GE."
msgstr "Как для box.index.GE."

msgid "box.index.LT or 'LT'"
msgstr "box.index.LT или 'LT'"

msgid ""
"The comparison operator is '<' (less than). If an index key is less than a "
"search value, it matches. Tuples are returned in descending order by index "
"key."
msgstr ""
"Оператором сравнения будет  '<' (меньше чем). Если ключ индекса меньше "
"искомого значения, получим совпадение. Найденные кортежи упорядочены по "
"убыванию по ключу индекса."

msgid "box.index.LE or 'LE'"
msgstr "box.index.LE или 'LE'"

msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key is "
"less than or equal to a search value, it matches. Tuples are returned in "
"descending order by index key."
msgstr ""
"Оператором сравнения будет '<=' (меньше или равен). Если ключ индекса меньше"
" искомого значения или равен ему, получим совпадение. Найденные кортежи "
"упорядочены по убыванию по ключу индекса."

msgid ""
"Informally, we can state that searches with TREE indexes are generally what "
"users will find is intuitive, provided that there are no nils and no missing"
" parts. Formally, the logic is as follows. A search key has zero or more "
"parts, for example {}, {1,2,3},{1,nil,3}. An index key has one or more "
"parts, for example {1}, {1,2,3},{1,2,3}. A search key may contain nil (but "
"not msgpack.NULL, which is the wrong type). An index key may not contain nil"
" or msgpack.NULL, although a later version of Tarantool will have different "
"rules --  the behavior of searches with nil is subject to change. Possible "
"iterators are LT, LE, EQ, REQ, GE, GT. A search key is said to \"match\" an "
"index key if the following statements, which are pseudocode for the "
"comparison operation, return TRUE."
msgstr ""
"Неофициально можно сказать, что поиск с помощью TREE-индексов пользователи "
"обычно считают интуитивно понятным при условии, что нет нулевых значений и "
"отсутствующих частей. Формально же логика заключается в следующем. Ключ "
"поиска состоит из нуля или более частей, например, {}, {1,2,3},{1,nil,3}. "
"Ключ индекса состоит из одной или более частей, например, {1}, "
"{1,2,3},{1,2,3}. Ключ поиска может содержать нулевое значение nil (но не "
"msgpack.NULL, этот тип не будет правильным). Ключ индекса не может содержать"
" nil или msgpack.NULL, хотя в последующих версиях правила работы Tarantool"
" будут другие -- поведение поиска с nil может измениться. Возможные "
"итераторы: LT, LE, EQ, REQ, GE, GT. Считается, что ключ поиска соответствует"
" ключу индекса, если следующие операторы, которые представляют собой "
"псевдокод для операции сопоставления, возвращают TRUE."

msgid ""
"If (number-of-search-key-parts > number-of-index-key-parts) return ERROR\n"
"If (number-of-search-key-parts == 0) return TRUE\n"
"for (i = 1; ; ++i)\n"
"{\n"
"  if (i > number-of-search-key-parts) OR (search-key-part[i] is nil)\n"
"  {\n"
"    if (iterator is LT or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (type of search-key-part[i] is not compatible with type of index-key-part[i])\n"
"  {\n"
"    return ERROR\n"
"  }\n"
"  if (search-key-part[i] == index-key-part[i])\n"
"  {\n"
"    continue\n"
"  }\n"
"  if (search-key-part[i] > index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or LE or LT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (search-key-part[i] < index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or GE or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"}"
msgstr ""

msgid "**Iterator types for HASH indexes**"
msgstr "**Типы итераторов для HASH-индексов**"

msgid "Type"
msgstr "Тип возвращаемого значения"

msgid "box.index.ALL"
msgstr "box.index.ALL"

msgid "none"
msgstr "нет"

msgid ""
"All index keys match. Tuples are returned in ascending order by hash of "
"index key, which will appear to be random."
msgstr ""
"Все ключи индекса являются совпадениями. Найденные кортежи упорядочены по "
"возрастанию по хешу ключа индекса, который будет выглядеть случайным."

msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a "
"search value, it matches. The number of returned tuples will be 0 or 1. This"
" is the default."
msgstr ""
"Оператором сравнения будет '==' (равный). Если ключ индекса равен искомому "
"значению, получим совпадение. Количество найденных кортежей будет 0 или 1. "
"Этот тип используется по умолчанию."

msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key is "
"greater than a hash of a search value, it matches. Tuples are returned in "
"ascending order by hash of index key, which will appear to be random. "
"Provided that the space is not being updated, one can retrieve all the "
"tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} in "
"each search, and using the last returned value from the previous result as "
"the start search value for the next search."
msgstr ""
"Оператором сравнения будет '>' (больше чем). Если хеш ключа индекса больше, "
"чем хеш искомого значения, получим совпадение. Найденные кортежи упорядочены"
" по возрастанию по хешу ключа индекса, который будет выглядеть случайным. "
"При условии, что спейс не обновляется, можно получить все кортежи в спейсе, "
"N кортежей за раз, используя  {iterator='GT', limit=N} в каждом поиске и "
"последнее найденное значение из предыдущего результата поиска в качестве "
"начального значения для следующего поиска."

msgid "**Iterator types for BITSET indexes**"
msgstr "**Типы итераторов для BITSET-индексов**"

msgid ""
"All index keys match. Tuples are returned in their order within the space."
msgstr ""
"Все ключи индекса являются совпадениями. Найденные кортежи упорядочены по "
"положению в спейсе."

msgid "bitset value"
msgstr "значение bitset (битовое множество)"

msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are returned "
"in their order within the space. This is the default."
msgstr ""
"Если ключ индекса равен искомому значению, получим совпадение. Найденные "
"кортежи упорядочены по положению в спейсе. Этот тип используется по "
"умолчанию."

msgid "box.index.BITS_ALL_SET"
msgstr "box.index.BITS_ALL_SET"

msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все биты, которые равны 1 в битовом множестве, также равны 1 в ключе "
"индекса, получим совпадение. Найденные кортежи упорядочены по положению в "
"спейсе."

msgid "box.index.BITS_ANY_SET"
msgstr "box.index.BITS_ANY_SET"

msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""
"Если один из битов, которые равны 1 в битовом множестве, также равен 1 в "
"ключе индекса, получим совпадение. Найденные кортежи упорядочены по "
"положению в спейсе."

msgid "box.index.BITS_ALL_NOT_SET"
msgstr "box.index.BITS_ALL_NOT_SET"

msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все биты, которые равны 1 в битовом множестве, равны 0 в ключе "
"индекса, получим совпадение. Найденные кортежи упорядочены по положению в "
"спейсе."

msgid "**Iterator types for RTREE indexes**"
msgstr "**Типы итераторов для RTREE-индексов**"

msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""
"Все ключи являются совпадениями. Найденные кортежи упорядочены по положению "
"в спейсе."

msgid ""
"If all points of the rectangle-or-box defined by the search value are the "
"same as the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space. \"Rectangle-or-box\" means "
"\"rectangle-or-box as explained in section about :ref:`RTREE <box_index-"
"rtree>`\". This is the default."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, совпадают с точками прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе. \"Прямоугольник-или-параллелепипед\" "
"означает \"прямоугольник-или-параллелепипед, как описано в разделе о "
":ref:`RTREE <box_index-rtree>`\". Этот тип используется по умолчанию."

msgid ""
"If all points of the rectangle-or-box defined by the search value are within"
" the rectangle-or-box defined by the index key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within, or at the side of, the rectangle-or-box defined by the index key, it"
" matches. Tuples are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, или рядом с ним, получим совпадение. Найденные"
" кортежи упорядочены по положению в спейсе."

msgid ""
"If all points of the rectangle-or-box defined by the index key are within "
"the rectangle-or-box defined by the search key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные ключом "
"индекса, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного искомым значением, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

msgid ""
"If all points of the rectangle-or-box defined by the index key are within, "
"or at the side of, the rectangle-or-box defined by the search key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные ключом "
"индекса, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного искомым значением, или рядом с ним, получим совпадение. "
"Найденные кортежи упорядочены по положению в спейсе."

msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr "box.index.OVERLAPS или 'OVERLAPS'"

msgid ""
"If some points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples are"
" returned in their order within the space."
msgstr ""
"Если некоторые точки прямоугольника-или-параллелепипеда, определенные "
"искомым значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr "box.index.NEIGHBOR или 'NEIGHBOR'"

msgid ""
"If some points of the rectangle-or-box defined by the defined by the key are"
" within, or at the side of, defined by the index key, it matches. Tuples are"
" returned in order: nearest neighbor first."
msgstr ""
"Если некоторые точки прямоугольника-или-параллелепипеда, определенные "
"ключом, находятся в пределах, определенных ключом индекса, или рядом с ним, "
"получим совпадение. Найденные кортежи упорядочены следующим образом: сначала"
" ближайший сосед."

msgid "**First example of index pairs():**"
msgstr "**Первый пример pairs():**"

msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr "'TREE'-индекс, используемый по умолчанию, и функция ``pairs()``:"

msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."

msgid "**Second example of index pairs():**"
msgstr "**Второй пример pairs():**"

msgid ""
"This Lua code finds all the tuples whose primary key values begin with 'XY'."
" The assumptions include that there is a one-part primary-key TREE index on "
"the first field, which must be a string. The iterator loop ensures that the "
"search will return tuples where the first value is greater than or equal to "
"'XY'. The conditional statement within the loop ensures that the looping "
"will stop when the first two letters are not 'XY'."
msgstr ""
"Данный код на Lua найдет все кортежи, значения первичного ключа в которых "
"начинаются с 'XY'. Рабочие предположения заключаются в следующем: есть "
"однокомпонентный первичный TREE-индекс по первому полю, которое должно "
"представлять собой строку. Цикл с итератором обеспечивает поиск кортежей, в "
"которых первое значение больше или равно 'XY'. Условный оператор в цикле "
"служит для того, чтобы цикл останавливался, если первые две буквы не 'XY'."

msgid ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"

msgid "**Third example of index pairs():**"
msgstr "**Третий пример pairs():**"

msgid ""
"This Lua code finds all the tuples whose primary key values are greater than"
" or equal to 1000, and less than or equal to 1999 (this type of request is "
"sometimes called a \"range search\" or a \"between search\"). The "
"assumptions include that there is a one-part primary-key TREE index on the "
"first field, which must be a :ref:`number <index-box_number>`. The iterator "
"loop ensures that the search will return tuples where the first value is "
"greater than or equal to 1000. The conditional statement within the loop "
"ensures that the looping will stop when the first value is greater than "
"1999."
msgstr ""
"Данный код на Lua найдет все кортежи, значения первичного ключа которых "
"равны или больше 1000 и меньше или равны 1999 (такой тип запроса иногда "
"называют поиском по диапазону или поиском в заданных пределах). Рабочие "
"предположения заключаются в следующем: есть однокомпонентный первичный TREE-"
"индекс по первому полю, которое должно представлять собой :ref:`число "
"<index-box_number>`. Цикл с итератором обеспечивает поиск кортежей, в "
"которых первое значение больше или равно 1000. Условный оператор в цикле "
"служит для того, чтобы цикл останавливался, если первое значение больше "
"1999."

msgid ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
