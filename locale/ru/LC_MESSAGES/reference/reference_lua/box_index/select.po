
msgid "index_object:select()"
msgstr ""

msgid ""
"Search for a tuple or a set of tuples by the current index. To search by the"
" primary index in the specified space, use the :ref:`box_space-select` "
"method."
msgstr ""

msgid "Parameters"
msgstr "Параметры"

msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ":ref:`ссылка на объект <app_server-object_reference>`."

#, fuzzy
msgid "a value to be matched against the index key, which may be multi-part."
msgstr "значения для сопоставления с ключом индекса"

msgid ""
"none, any, or all of the following parameters:  * ``iterator`` -- the "
":ref:`iterator type <box_index-iterator-types>`. The default iterator type "
"is 'EQ'. * ``limit`` -- the maximum number of tuples. * ``offset`` -- the "
"number of tuples to skip (use this parameter carefully when scanning "
":ref:`large data sets <offset-warning>`). * ``options.after`` -- a tuple or "
"the position of a tuple (:ref:`tuple_pos <box_index-tuple_pos>`) after which"
" ``select`` starts the search. You can pass an empty string or "
":ref:`box.NULL <box-null>` to this option to start the search from the first"
" tuple. * ``options.fetch_pos`` -- if **true**, the ``select`` method "
"returns the position of the last selected tuple as the second value.    .. "
"NOTE::        The ``after`` and ``fetch_pos`` options are supported for the "
"``TREE`` :ref:`index <index-types>` only."
msgstr ""

msgid "none, any, or all of the following parameters:"
msgstr "ни один, любой или все следующие параметры:"

msgid ""
"``iterator`` -- the :ref:`iterator type <box_index-iterator-types>`. The "
"default iterator type is 'EQ'."
msgstr ""

#, fuzzy
msgid "``limit`` -- the maximum number of tuples."
msgstr "``limit`` -- максимальное количество кортежей"

msgid ""
"``offset`` -- the number of tuples to skip (use this parameter carefully "
"when scanning :ref:`large data sets <offset-warning>`)."
msgstr ""

msgid ""
"``options.after`` -- a tuple or the position of a tuple (:ref:`tuple_pos "
"<box_index-tuple_pos>`) after which ``select`` starts the search. You can "
"pass an empty string or :ref:`box.NULL <box-null>` to this option to start "
"the search from the first tuple."
msgstr ""

msgid ""
"``options.fetch_pos`` -- if **true**, the ``select`` method returns the "
"position of the last selected tuple as the second value."
msgstr ""

msgid ""
"The ``after`` and ``fetch_pos`` options are supported for the ``TREE`` "
":ref:`index <index-types>` only."
msgstr ""

msgid "return"
msgstr "возвращает"

msgid "This function might return one or two values:"
msgstr ""

msgid ""
"The tuples whose fields are equal to the fields of the passed key. If the "
"number of passed fields is less than the number of fields in the current "
"key, then only the passed fields are compared, so ``select{1,2}`` matches a "
"tuple whose primary key is ``{1,2,3}``."
msgstr ""

msgid ""
"(Optionally) If ``options.fetch_pos`` is set to **true**, returns a "
"base64-encoded string representing the position of the last selected tuple "
"as the second value. If no tuples are fetched, returns ``nil``."
msgstr ""

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "array of tuples"
msgstr "массив кортежей"

msgid "(Optionally) string"
msgstr ""

msgid ""
"Use the ``offset`` option carefully when scanning large data sets as it "
"linearly increases the number of scanned tuples and leads to a full space "
"scan. Instead, you can use the ``after`` and ``fetch_pos`` options."
msgstr ""

#, fuzzy
msgid "**Examples:**"
msgstr "**Пример:**"

msgid ""
"Below are few examples of using ``select`` with different parameters. To try"
" out these examples, you need to bootstrap a Tarantool database as described"
" in :ref:`Using data operations <box_space-operations-detailed-examples>`."
msgstr ""

msgid ""
"-- Insert test data --\n"
"box.space.bands:insert { 1, 'Roxette', 1986 }\n"
"box.space.bands:insert { 2, 'Scorpions', 1965 }\n"
"box.space.bands:insert { 3, 'Ace of Base', 1987 }\n"
"box.space.bands:insert { 4, 'The Beatles', 1960 }\n"
"box.space.bands:insert { 5, 'Pink Floyd', 1965 }\n"
"box.space.bands:insert { 6, 'The Rolling Stones', 1962 }\n"
"box.space.bands:insert { 7, 'The Doors', 1965 }\n"
"box.space.bands:insert { 8, 'Nirvana', 1987 }\n"
"box.space.bands:insert { 9, 'Led Zeppelin', 1968 }\n"
"box.space.bands:insert { 10, 'Queen', 1970 }\n"
"\n"
"-- Select a tuple by the specified primary key value --\n"
"select_primary = bands.index.primary:select { 1 }\n"
"--[[\n"
"---\n"
"- - [1, 'Roxette', 1986]\n"
"...\n"
"--]]\n"
"\n"
"-- Select a tuple by the specified secondary key value --\n"
"select_secondary = bands.index.band:select { 'The Doors' }\n"
"--[[\n"
"---\n"
"- - [7, 'The Doors', 1965]\n"
"...\n"
"--]]\n"
"\n"
"-- Select a tuple by the specified multi-part secondary key value --\n"
"select_multipart = bands.index.year_band:select { 1960, 'The Beatles' }\n"
"--[[\n"
"---\n"
"- - [4, 'The Beatles', 1960]\n"
"...\n"
"--]]\n"
"\n"
"-- Select tuples by the specified partial key value --\n"
"select_multipart_partial = bands.index.year_band:select { 1965 }\n"
"--[[\n"
"---\n"
"- - [5, 'Pink Floyd', 1965]\n"
"  - [2, 'Scorpions', 1965]\n"
"  - [7, 'The Doors', 1965]\n"
"...\n"
"--]]\n"
"\n"
"-- Select maximum 3 tuples by the specified secondary index --\n"
"select_limit = bands.index.band:select({}, { limit = 3 })\n"
"--[[\n"
"---\n"
"- - [3, 'Ace of Base', 1987]\n"
"  - [9, 'Led Zeppelin', 1968]\n"
"  - [8, 'Nirvana', 1987]\n"
"...\n"
"--]]\n"
"\n"
"-- Select maximum 3 tuples with the key value greater than 1965 --\n"
"select_greater = bands.index.year:select({ 1965 }, { iterator = 'GT', limit = 3 })\n"
"--[[\n"
"---\n"
"- - [9, 'Led Zeppelin', 1968]\n"
"  - [10, 'Queen', 1970]\n"
"  - [1, 'Roxette', 1986]\n"
"...\n"
"--]]\n"
"\n"
"-- Select maximum 3 tuples after the specified tuple --\n"
"select_after_tuple = bands.index.primary:select({}, { after = { 4, 'The Beatles', 1960 }, limit = 3 })\n"
"--[[\n"
"---\n"
"- - [5, 'Pink Floyd', 1965]\n"
"  - [6, 'The Rolling Stones', 1962]\n"
"  - [7, 'The Doors', 1965]\n"
"...\n"
"--]]\n"
"\n"
"-- Select first 3 tuples and fetch a last tuple's position --\n"
"result, position = bands.index.primary:select({}, { limit = 3, fetch_pos = true })\n"
"-- Then, pass this position as the 'after' parameter --\n"
"select_after_position = bands.index.primary:select({}, { limit = 3, after = position })\n"
"--[[\n"
"---\n"
"- - [4, 'The Beatles', 1960]\n"
"  - [5, 'Pink Floyd', 1965]\n"
"  - [6, 'The Rolling Stones', 1962]\n"
"...\n"
"--]]\n"
msgstr ""

msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]`. can be "
"replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That"
" is, ``get`` can be used as a convenient shorthand to get the first tuple in"
" the tuple set that would be returned by ``select``. However, if there is "
"more than one tuple in the tuple set, then ``get`` throws an error."
msgstr ""
":samp:`box.space.{имя-спейса}.index.{имя-индекса}:select(...)[1]` можно "
"заменить :samp:`box.space.{имя-спейса}.index.{имя-индекса}:get(...)`. А "
"именно, ``get`` можно использовать в качестве удобного сокращения для "
"получения первого кортежа в наборе кортежей, который был бы выведен по "
"запросу ``select``. Однако, если в наборе кортежей больше одного кортежа, "
"``get`` завершится с ошибкой."

#~ msgid ""
#~ "This is an alternative to :ref:`box.space...select() <box_space-select>` "
#~ "which goes via a particular index and can make use of additional parameters "
#~ "that specify the iterator type, and the limit, and the offset."
#~ msgstr ""

#~ msgid ""
#~ "none, any, or all of the following parameters:  * ``iterator`` -- type of "
#~ "iterator * ``limit`` -- maximum number of tuples * ``offset`` -- start tuple"
#~ " number   (do not use it. See   :ref:`warning <offset-warning>`)"
#~ msgstr ""

#~ msgid "``iterator`` -- type of iterator"
#~ msgstr "``iterator`` -- тип итератора"

#~ msgid ""
#~ "``offset`` -- start tuple number (do not use it. See :ref:`warning <offset-"
#~ "warning>`)"
#~ msgstr ""

#~ msgid "the tuple or tuples that match the field values."
#~ msgstr "кортеж или кортежи, которые совпадают со значениями поля."

#~ msgid ""
#~ "We do not recommend using the ``offset`` option for scanning large values "
#~ "because it linearly increases the number of scanned tuples and leads to the "
#~ "full scan of the space."
#~ msgstr ""

#~ msgid ""
#~ "For unique indexes you can build cursors with :doc:`pairs() "
#~ "</reference/reference_lua/box_index/pairs>`:"
#~ msgstr ""

#~ msgid "index_obj:pairs(key, {iterator = 'GT'})"
#~ msgstr ""

#~ msgid ""
#~ "-- Create a space named tester.\n"
#~ "tarantool> sp = box.schema.space.create('tester')\n"
#~ "-- Create a unique index 'primary'\n"
#~ "-- which won't be needed for this example.\n"
#~ "tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
#~ "-- Create a non-unique index 'secondary'\n"
#~ "-- with an index on the second field.\n"
#~ "tarantool> sp:create_index('secondary', {\n"
#~ "         >   type = 'tree',\n"
#~ "         >   unique = false,\n"
#~ "         >   parts = {2, 'string'}\n"
#~ "         > })\n"
#~ "-- Insert three tuples, values in field[2]\n"
#~ "-- equal to 'X', 'Y', and 'Z'.\n"
#~ "tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
#~ "tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
#~ "tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
#~ "-- Select all tuples where the secondary index\n"
#~ "-- keys are greater than 'X'.\n"
#~ "tarantool> sp.index.secondary:select({'X'}, {\n"
#~ "         >   iterator = 'GT',\n"
#~ "         >   limit = 1000\n"
#~ "         > })"
#~ msgstr ""

#~ msgid "The result will be a table of tuple and will look like this:"
#~ msgstr "Результатом будет следующая таблица кортежа:"

#~ msgid ""
#~ "---\n"
#~ "- - [2, 'Y', 'Row with field[2]=Y']\n"
#~ "  - [3, 'Z', 'Row with field[2]=Z']\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "The arguments are optional. If you call :samp:`box.space.{space-"
#~ "name}:select{}`, then every key in the index is considered to be a match, "
#~ "regardless of the iterator type. Therefore, for the example above, "
#~ "``box.space.tester:select{}`` will select every tuple in the ``tester`` "
#~ "space via the first (primary-key) index."
#~ msgstr ""
#~ "Аргументы необязательны. Если вы вызываете :samp:`box.space.{имя-"
#~ "спейса}:select{}`, то каждый ключ в индексе считается совпадающим, "
#~ "независимо от типа итератора. Таким образом, в приведённом выше примере, "
#~ "``box.space.tester:select{}`` выберет каждый кортеж в спейсе ``tester`` по "
#~ "первому индексу (первичный ключ)."

#~ msgid ""
#~ ":samp:`index.{index-name}` is optional. If it is omitted, then the assumed "
#~ "index is the first (primary-key) index. Therefore, for the example above, "
#~ "``box.space.tester:select({1}, {iterator = 'GT'})`` would have returned the "
#~ "same two rows, via the 'primary' index."
#~ msgstr ""
#~ "Параметр :samp:`index.{имя-индекса}` необязателен. Если он пропущен, то "
#~ "подразумевается первый индекс (первичный ключ). Таким образом, для примера "
#~ "выше, ``box.space.tester:select({1}, {iterator = 'GT'})`` вернет две "
#~ "одинаковых строки по первичному индексу 'primary'."

#~ msgid ""
#~ ":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
#~ "``iterator = 'EQ'`` is assumed."
#~ msgstr ""
#~ "Параметр типа итератора :samp:`iterator = {тип-итератора}` необязателен. "
#~ "Если он пропущен, то подразумевается, что ``iterator = 'EQ'``."
