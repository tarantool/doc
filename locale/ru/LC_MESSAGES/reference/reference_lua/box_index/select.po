
msgid "index_object:select()"
msgstr ""

msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` "
"which goes via a particular index and can make use of additional "
"parameters that specify the iterator type, and the limit (that is, the "
"maximum number of tuples to return) and the offset (that is, which tuple "
"to start with in the list)."
msgstr ""
"Это может быть альтернативой для функции :ref:`box.space...select() "
"<box_space-select>`, которая проходит по определенному индексу и может "
"использовать дополнительные параметры, которые определяют тип итератора и"
" пределы (то есть максимальное количество возвращаемых кортежей) и "
"смещение (то есть с какого кортежа в списке начинать)."

msgid "Parameters"
msgstr "Параметры"

msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ":ref:`ссылка на объект <app_server-object_reference>`."

msgid "values to be matched against the index key"
msgstr "значения для сопоставления с ключом индекса"

msgid ""
"none, any, or all of the following parameters:  * ``iterator`` -- type of"
" iterator * ``limit`` -- maximum number of tuples * ``offset`` -- start "
"tuple number"
msgstr ""

msgid "none, any, or all of the following parameters:"
msgstr "ни один, любой или все следующие параметры:"

msgid "``iterator`` -- type of iterator"
msgstr "``interator`` -- тип итератора"

msgid "``limit`` -- maximum number of tuples"
msgstr "``limit`` -- максимальное количество кортежей"

msgid "``offset`` -- start tuple number"
msgstr "``offset`` -- номер начального кортежа"

msgid "return"
msgstr "возвращает"

msgid "the tuple or tuples that match the field values."
msgstr "кортеж или кортежи, которые совпадают со значениями поля."

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "array of tuples"
msgstr "массив кортежей"

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

msgid "The result will be a table of tuple and will look like this:"
msgstr "Результатом будет следующая таблица кортежа:"

msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

msgid ""
"The arguments are optional. If you call :samp:`box.space.{space-"
"name}:select{}`, then every key in the index is considered to be a match,"
" regardless of the iterator type. Therefore, for the example above, "
"``box.space.tester:select{}`` will select every tuple in the ``tester`` "
"space via the first (primary-key) index."
msgstr ""
"Аргументы необязательны. Если вы вызываете "
":samp:`box.space.{имя-спейса}:select{}`, то каждый ключ в индексе "
"считается совпадающим, независимо от типа итератора. Таким образом, в "
"приведённом выше примере, ``box.space.tester:select{}`` выберет каждый "
"кортеж в спейсе ``tester`` по первому индексу (первичный ключ)."

msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the "
"assumed index is the first (primary-key) index. Therefore, for the "
"example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would "
"have returned the same two rows, via the 'primary' index."
msgstr ""
"Параметр :samp:`index.{имя-индекса}` необязателен. Если он пропущен, то "
"подразумевается первый индекс (первичный ключ). Таким образом, для "
"примера выше, ``box.space.tester:select({1}, {iterator = 'GT'})`` вернет "
"две одинаковых строки по первичному индексу 'primary'."

msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""
"Параметр типа итератора :samp:`iterator = {тип-итератора}` необязателен. "
"Если он пропущен, то подразумевается, что ``iterator = 'EQ'``."

msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]`. can be "
"replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. "
"That is, ``get`` can be used as a convenient shorthand to get the first "
"tuple in the tuple set that would be returned by ``select``. However, if "
"there is more than one tuple in the tuple set, then ``get`` throws an "
"error."
msgstr ""
":samp:`box.space.{имя-спейса}.index.{имя-индекса}:select(...)[1]` можно "
"заменить :samp:`box.space.{имя-спейса}.index.{имя-индекса}:get(...)`. А "
"именно, ``get`` можно использовать в качестве удобного сокращения для "
"получения первого кортежа в наборе кортежей, который был бы выведен по "
"запросу ``select``. Однако, если в наборе кортежей больше одного кортежа,"
" ``get`` завершится с ошибкой."

msgid "**Example with BITSET index:**"
msgstr "**Пример с индексом BITSET:**"

msgid ""
"The following script shows creation and search with a BITSET index. "
"Notice: BITSET cannot be unique, so first a primary-key index is created."
" Notice: bit values are entered as hexadecimal literals for easier "
"reading."
msgstr ""
"Следующий скрипт показывает создание BITSET-индекса и поиск по нему. "
"Обратите внимание, что битовое множество BITSET не может быть уникальным,"
" поэтому сначала создается первичный индекс. Обратите внимание, что "
"битовые значения вводятся как шестнадцатеричные литералы для удобства "
"чтения."

msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""
