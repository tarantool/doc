
msgid "Submodule `box.schema`"
msgstr "Вложенный модуль `box.schema`"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"The ``box.schema`` submodule has data-definition functions for spaces, "
"users, roles, function tuples, and sequences."
msgstr ""
"Вложенный модуль ``box.schema`` содержит функции для определения данных "
"для спейсов, пользователей, ролей, кортежей и последовательностей."

msgid "Index"
msgstr "Индекс"

msgid "Below is a list of all ``box.schema`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``box.schema``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Использование"

msgid ""
":ref:`box.schema.space.create() <box_schema-space_create>` or "
":ref:`box.schema.create_space() <box_schema-space_create>`"
msgstr ""
":ref:`box.schema.space.create() <box_schema-space_create>` или "
":ref:`box.schema.create_space() <box_schema-space_create>`"

msgid "Create a space"
msgstr "Создание спейса"

msgid ":ref:`box.schema.upgrade <admin-upgrades>`"
msgstr ":ref:`box.schema.upgrade <admin-upgrades>`"

msgid "Upgrade a database"
msgstr "Обновить базу данных"

msgid ":ref:`box.schema.user.create() <box_schema-user_create>`"
msgstr ":ref:`box.schema.user.create() <box_schema-user_create>`"

msgid "Create a user"
msgstr "Создание пользователя"

msgid ":ref:`box.schema.user.drop() <box_schema-user_drop>`"
msgstr ":ref:`box.schema.user.drop() <box_schema-user_drop>`"

msgid "Drop a user"
msgstr "Удаление пользователя"

msgid ":ref:`box.schema.user.exists() <box_schema-user_exists>`"
msgstr ":ref:`box.schema.user.exists() <box_schema-user_exists>`"

msgid "Check if a user exists"
msgstr "Проверка существования пользователя"

msgid ":ref:`box.schema.user.grant() <box_schema-user_grant>`"
msgstr ":ref:`box.schema.user.grant() <box_schema-user_grant>`"

msgid "Grant privileges to a user or a role"
msgstr "Выдача прав пользователю или роли"

msgid ":ref:`box.schema.user.revoke() <box_schema-user_revoke>`"
msgstr ":ref:`box.schema.user.revoke() <box_schema-user_revoke>`"

msgid "Revoke privileges from a user or a role"
msgstr "Отмена прав пользователя или роли"

msgid ":ref:`box.schema.user.password() <box_schema-user_password>`"
msgstr ":ref:`box.schema.user.password() <box_schema-user_password>`"

msgid "Get a hash of a user's password"
msgstr "Получение хеша пароля пользователя"

msgid ":ref:`box.schema.user.passwd() <box_schema-user_passwd>`"
msgstr ":ref:`box.schema.user.passwd() <box_schema-user_passwd>`"

msgid "Associate a password with a user"
msgstr "Ассоциация пароля с пользователем"

msgid ":ref:`box.schema.user.info() <box_schema-user_info>`"
msgstr ":ref:`box.schema.user.info() <box_schema-user_info>`"

msgid "Get a description of a user's privileges"
msgstr "Получение описания прав пользователя"

msgid ":ref:`box.schema.role.create() <box_schema-role_create>`"
msgstr ":ref:`box.schema.role.create() <box_schema-role_create>`"

msgid "Create a role"
msgstr "Создание роли"

msgid ":ref:`box.schema.role.drop() <box_schema-role_drop>`"
msgstr ":ref:`box.schema.role.drop() <box_schema-role_drop>`"

msgid "Drop a role"
msgstr "Удаление роли"

msgid ":ref:`box.schema.role.exists() <box_schema-role_exists>`"
msgstr ":ref:`box.schema.role.exists() <box_schema-role_exists>`"

msgid "Check if a role exists"
msgstr "Проверка наличия роли"

msgid ":ref:`box.schema.role.grant() <box_schema-role_grant>`"
msgstr ":ref:`box.schema.role.grant() <box_schema-role_grant>`"

msgid "Grant privileges to a role"
msgstr "Выдача прав роли"

msgid ":ref:`box.schema.role.revoke() <box_schema-role_revoke>`"
msgstr ":ref:`box.schema.role.revoke() <box_schema-role_revoke>`"

msgid "Revoke privileges from a role"
msgstr "Отмена прав роли"

msgid ":ref:`box.schema.role.info() <box_schema-role_info>`"
msgstr ":ref:`box.schema.role.info() <box_schema-role_info>`"

msgid "Get a description of a role's privileges"
msgstr "Получение описания прав роли"

msgid ":ref:`box.schema.func.create() <box_schema-func_create>`"
msgstr ":ref:`box.schema.func.create() <box_schema-func_create>`"

msgid "Create a function tuple"
msgstr "Создание кортежа с функцией"

msgid ":ref:`box.schema.func.drop() <box_schema-func_drop>`"
msgstr ":ref:`box.schema.func.drop() <box_schema-func_drop>`"

msgid "Drop a function tuple"
msgstr "Удаление кортежа с функцией"

msgid ":ref:`box.schema.func.exists() <box_schema-func_exists>`"
msgstr ":ref:`box.schema.func.exists() <box_schema-func_exists>`"

msgid "Check if a function tuple exists"
msgstr "Проверка наличия кортежа с функцией"

msgid ":ref:`box.schema.sequence.create() <box_schema-sequence_create>`"
msgstr ":ref:`box.schema.sequence.create() <box_schema-sequence_create>`"

msgid "Create a new sequence generator"
msgstr "Создание нового генератора последовательностей"

msgid ":ref:`sequence_object:next() <box_schema-sequence_next>`"
msgstr ":ref:`sequence_object:next() <box_schema-sequence_next>`"

msgid "Generate and return the next value"
msgstr "Генерация и возврат следующего значения"

msgid ":ref:`sequence_object:alter() <box_schema-sequence_alter>`"
msgstr ":ref:`sequence_object:alter() <box_schema-sequence_alter>`"

msgid "Change sequence options"
msgstr "Изменение параметров последовательности"

msgid ":ref:`sequence_object:reset() <box_schema-sequence_reset>`"
msgstr ":ref:`sequence_object:reset() <box_schema-sequence_reset>`"

msgid "Reset sequence state"
msgstr "Сброс состояния последовательности"

msgid ":ref:`sequence_object:set() <box_schema-sequence_set>`"
msgstr ":ref:`sequence_object:set() <box_schema-sequence_set>`"

msgid "Set the new value"
msgstr "Установка нового значения"

msgid ":ref:`sequence_object:current() <box_schema-sequence_current>`"
msgstr ""

msgid "Return the last retrieved value"
msgstr "Возврат последнего найденного значения"

msgid ":ref:`sequence_object:drop() <box_schema-sequence_drop>`"
msgstr ":ref:`sequence_object:drop() <box_schema-sequence_drop>`"

msgid "Drop the sequence"
msgstr "Удаление последовательности"

msgid ":ref:`space_object:create_index() <box_schema-sequence_create_index>`"
msgstr ":ref:`space_object:create_index() <box_schema-sequence_create_index>`"

msgid "Create an index"
msgstr "Создание индекса"

msgid "Create a :ref:`space <index-box_space>`."
msgstr "Создание :ref:`спейса <index-box_space>`."

msgid "Parameters"
msgstr "Параметры"

msgid ""
"name of space, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя спейса, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr "см. таблицу \"Параметры для box.schema.space.create\" ниже"

msgid "return"
msgstr "возвращается"

msgid "space object"
msgstr "объект спейса"

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "userdata"
msgstr "пользовательские данные"

msgid ""
"You can use either syntax. For example, ``s = "
"box.schema.space.create('tester')`` has the same effect as ``s = "
"box.schema.create_space('tester')``."
msgstr ""
"Можно использовать любой вариант синтаксиса. Например, ``s = "
"box.schema.space.create('tester')`` эквивалентно ``s = "
"box.schema.create_space('tester')``."

msgid "**Options for box.schema.space.create**"
msgstr "**Параметры для box.schema.space.create**"

msgid "Effect"
msgstr "Эффект"

msgid "Type"
msgstr "Type"

msgid "Default"
msgstr "Значение по умолчанию"

msgid "engine"
msgstr "engine (движок)"

msgid "'memtx' or 'vinyl'"
msgstr "'memtx' или 'vinyl'"

msgid "string"
msgstr "string (строка)"

msgid "'memtx'"
msgstr "'memtx'"

msgid "field_count"
msgstr "field_count (количество полей)"

msgid ""
"fixed count of :ref:`fields <index-box_tuple>`: for example if "
"field_count=5, it is illegal to insert a tuple with fewer than or more "
"than 5 fields"
msgstr ""
"заданное количество :ref:`полей <index-box_tuple>`: например, если "
"field_count=5, нельзя вставить кортеж с количеством полей, большим или "
"меньшим, чем 5"

msgid "number"
msgstr "число"

msgid "0 i.e. not fixed"
msgstr "0, то есть не задано"

msgid "format"
msgstr "format (формат)"

msgid ""
"field names and types: See the illustrations of format clauses in the "
":ref:`space_object:format() <box_space-format>` description and in the "
":ref:`box.space._space <box_space-space>` example. Optional and usually "
"not specified."
msgstr ""
"имена и типы полей: см. наглядные примеры операторов в описании "
":ref:`space_object:format() <box_space-format>` и в "
":ref:`box.space._space <box_space-space>`. Необязательный параметр, "
"обычно значение не указывается."

msgid "table"
msgstr "таблица"

msgid "(blank)"
msgstr "(пустое)"

msgid "id"
msgstr "id"

msgid ""
"unique identifier: users can refer to spaces with the id instead of the "
"name"
msgstr ""
"уникальный идентификатор: пользователи могут ссылаться на спейсы "
"посредством идентификатора вместо имени"

msgid "last space's id, +1"
msgstr "идентификатор последнего спейса +1"

msgid "if_not_exists"
msgstr "if_not_exists (если отсутствует)"

msgid ""
"create space only if a space with the same name does not exist already, "
"otherwise do nothing but do not cause an error"
msgstr ""
"спейс создается, только если спейса с таким же именем нет в базе данных, "
"в противном случае эффект отсутствует, но ошибка не выдается"

msgid "boolean"
msgstr "boolean (логический)"

msgid "false"
msgstr "false (ложь)"

msgid "is_local"
msgstr "is_local"

msgid ""
"space contents are :ref:`replication-local <replication-local>`: changes "
"are stored in the :ref:`write-ahead log <internals-wal>` of the local "
"node but there is no :ref:`replication <replication>`."
msgstr ""
"содержимое спейса :ref:`реплицируется локально <replication-local>`: "
"изменения сохраняются в :ref:`журнале упреждающей записи <internals-wal>`"
" локального узла, но не происходит :ref:`репликация <replication>`."

msgid "temporary"
msgstr "temporary (временный)"

msgid ""
"space contents are temporary: changes are not stored in the :ref:`write-"
"ahead log <internals-wal>` and there is no :ref:`replication "
"<replication>`. Note re storage engine: vinyl does not support temporary "
"spaces."
msgstr ""
"содержимое спейса хранится временно: изменения не хранятся в "
":ref:`журнале упреждающей записи <internals-wal>`, и не проводится "
":ref:`репликация <replication>`. Примечание по движку базы данных: vinyl "
"не поддерживает временные спейсы."

msgid "user"
msgstr "user (пользователь)"

msgid ""
"name of the user who is considered to be the space's :ref:`owner "
"<authentication-owners_privileges>` for authorization purposes"
msgstr ""
"имя пользователя, который считается :ref:`владельцем <authentication-"
"owners_privileges>` спейса, для целей авторизации"

msgid "current user's name"
msgstr "имя текущего пользователя"

msgid ""
"There are three :ref:`syntax variations <app_server-object_reference>` "
"for object references targeting space objects, for example "
":samp:`box.schema.space.drop({space-id})` will drop a space. However, the"
" common approach is to use functions attached to the space objects, for "
"example :ref:`space_object:drop() <box_space-drop>`."
msgstr ""
"Существуют три :ref:`варианта синтаксиса <app_server-object_reference>` "
"для ссылок на объекты спейса, например, "
":samp:`box.schema.space.drop({id-спейса})` удалит спейс. Однако общий "
"подход заключается в использовании функций, прикрепленных к объектам "
"спейса, например :ref:`space_object:drop() <box_space-drop>`."

# ; ../doc/book/box/box_session.rst:313
msgid "**Example**"
msgstr "**Пример**"

msgid ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."

msgid ""
"After a space is created, usually the next step is to :ref:`create an "
"index <box_space-create_index>` for it, and then it is available for "
"insert, select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""
"Следующим шагом после создания спейса будет :ref:`создание индекса "
"<box_space-create_index>` для него, после чего можно будет выполнять "
"вставку, выборку и другие функции :ref:`box.space <box_space>`."

msgid ""
"Create a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users<authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""
"Создание пользователя. Чтобы получить информацию о том, как происходит "
"управление данными пользователя в Tarantool'е, см. раздел "
":ref:`Пользователи <authentication-users>` и справочник по спейсу "
":ref:`_user <box_space-user>`."

msgid "The possible options are:"
msgstr "Возможные параметры:"

msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the user already exists,"
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если пользователь уже существует,"

msgid ""
"``password`` (default = '') - string; the ``password`` = *password* "
"specification is good because in a :ref:`URI <index-uri>` (Uniform "
"Resource Identifier) it is usually illegal to include a user-name without"
" a password."
msgstr ""
"``password`` (пароль) -- строка; указать ``password`` = *password* "
"неплохо, поскольку в :ref:`URI <index-uri>` (унифицированный "
"идентификатор ресурса) обычно нельзя включать имя пользователя без "
"пароля."

msgid "The maximum number of users is 32."
msgstr "Максимальное количество пользователей -- 32."

msgid ""
"name of user, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя пользователя, которое должно соответствовать :ref:`правилам "
"именования объектов <app_server-names>`"

msgid "``if_not_exists``, ``password``"
msgstr "``if_not_exists``, ``password``"

msgid "nil"
msgstr "nil"

msgid "**Examples:**"
msgstr "**Примеры:**"

msgid ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"

msgid ""
"Drop a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users <authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""
"Удаление пользователя. Чтобы получить информацию о том, как происходит "
"управление данными пользователя в Tarantool'е, см. раздел "
":ref:`Пользователи <authentication-users>` и справочник по спейсу "
":ref:`_user <box_space-user>`."

msgid "the name of the user"
msgstr "имя пользователя"

msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the user does not exist."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если такой пользователь не существует."

msgid ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"

msgid ""
"Return ``true`` if a user exists; return ``false`` if a user does not "
"exist. For explanation of how Tarantool maintains user data, see section "
":ref:`Users <authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""
"Возврат ``true`` (правда), если пользователь существует; возврат "
"``false`` (ложь), если пользователь отсутствует. Чтобы получить "
"информацию о том, как происходит управление данными пользователя в "
"Tarantool'е, см. раздел :ref:`Пользователи <authentication-users>` и "
"справочник по спейсу :ref:`_user <box_space-user>`."

msgid "bool"
msgstr "логическое значение bool"

msgid "**Example:**"
msgstr "**Пример:**"

msgid "box.schema.user.exists('Lena')"
msgstr "box.schema.user.exists('Lena')"

msgid ""
"Grant :ref:`privileges <authentication-owners_privileges>` to a user or "
"to another role."
msgstr ""
"Выдача :ref:`прав <authentication-owners_privileges>` пользователю или "
"другой роли."

msgid "the name of the user."
msgstr "имя пользователя."

msgid ""
"'read' or 'write' or 'execute' or 'create' or 'alter' or 'drop' or a "
"combination."
msgstr ""
"'read' (чтение) или 'write' (запись), или 'execute' (выполнение), или "
"'create' (создание), или 'alter' (изменение), или 'drop' (удаление) или "
"их сочетание."

msgid "'space' or 'function' or 'sequence' or 'role'."
msgstr ""
"'space' (спейс) или 'function' (функция), или 'sequence' "
"(последовательность), или 'role' (роль)."

msgid "name of object to grant permissions for."
msgstr "имя объекта, на который выдаются права."

msgid "name of role to grant to user."
msgstr "имя роли, которая назначается пользователю."

msgid "``grantor``, ``if_not_exists``."
msgstr "``grantor``, ``if_not_exists``."

msgid ""
"If :samp:`'function','{object-name}'` is specified, then a _func tuple "
"with that object-name must exist."
msgstr ""
"Если есть :samp:`'function','{имя-объекта}'`, то должен существовать "
"кортеж в _func с таким именем объекта."

msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' "
"which means 'all object-types and all objects'. In this case, object name"
" is omitted."
msgstr ""
"**Вариант:** вместо ``object-type, object-name`` введите 'universe', что "
"означает 'все типы объектов и все объекты'. В таком случае имя объекта "
"опускается."

msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""
"**Вариант:** вместо ``privilege, object-type, object-name`` введите "
"``role-name`` (имя роли) (см. раздел :ref:`Роли <authentication-roles>`)."

msgid ""
"**Variation:** instead of :samp:`box.schema.user.grant('{user-"
"name}','usage,session','universe',nil,` :code:`{if_not_exists=true})` say"
" :samp:`box.schema.user.enable('{user-name}')`."
msgstr ""

msgid ""
"``grantor`` = *grantor_name_or_id* -- string or number, for custom "
"grantor,"
msgstr ""
"``grantor`` = *grantor_name_or_id* -- строка или номер для заданного "
"пользователя, выдающего права,"

msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the user already has the "
"privilege."
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если у пользователя уже есть права."

msgid ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"

msgid ""
"Revoke :ref:`privileges <authentication-owners_privileges>` from a user "
"or from another role."
msgstr ""
"Отмена :ref:`прав <authentication-owners_privileges>` пользователя или "
"другой роли."

msgid "'space' or 'function' or 'sequence'."
msgstr ""
"'space' (спейс) или 'function' (функция), или 'sequence' "
"(последовательность)."

msgid "the name of a function or space or sequence."
msgstr "имя функции, спейса или последовательности."

#, fuzzy
msgid "``if_exists``."
msgstr "if_not_exists (если отсутствует)"

#, fuzzy
msgid ""
"The user must exist, and the object must exist, but if the option setting"
" is ``{if_exists=true}`` then it is not an error if the user does not "
"have the privilege."
msgstr ""
"Должен существовать пользователь, должен существовать объект, но ошибка "
"не выпадет, если у пользователя нет прав."

msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' "
"which means 'all object-types and all objects'."
msgstr ""
"**Вариант:** вместо ``object-type, object-name`` введите 'universe', что "
"означает 'все типы объектов и все объекты'."

msgid ""
"**Variation:** instead of :samp:`box.schema.user.revoke('{user-"
"name}','usage,session','universe',nil,` :code:`{if_exists=true})` say "
":samp:`box.schema.user.disable('{user-name}')`."
msgstr ""

msgid ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"

msgid ""
"Return a hash of a user's password. For explanation of how Tarantool "
"maintains passwords, see section :ref:`Passwords <authentication-"
"passwords>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""
"Возврат хеша пароля пользователя. Чтобы получить информацию о том, как "
"происходит управление паролями в Tarantool'е, см. раздел :ref:`Пароли "
"<authentication-passwords>` и справочник по спейсу :ref:`_user "
"<box_space-user>`."

msgid ""
"If a non-'guest' user has no password, it’s **impossible** to connect to "
"Tarantool using this user. The user is regarded as “internal” only, not "
"usable from a remote connection. Such users can be useful if they have "
"defined some procedures with the :ref:`SETUID <box_schema-func_create>` "
"option, on which privileges are granted to externally-connectable users. "
"This way, external users cannot create/drop objects, they can only invoke"
" procedures."
msgstr ""
"Если у пользователя, который не является пользователем 'guest' нет "
"пароля, **невозможно** подключиться к Tarantool'у через этого "
"пользователя. Пользователь считается только “внутренним”, его нельзя "
"использовать для удаленного подключения. Такие пользователи могут "
"работать, если они определили какие-либо процедуры с помощью :ref:`SETUID"
" <box_schema-func_create>`, на которые есть доступ у пользователей с "
"внешним подключением. Таким образом, внешние пользователи могут не "
"создавать/удалять объекты, а только вызывать процедуры."

msgid ""
"For the 'guest' user, it’s impossible to set a password: that would be "
"misleading, since 'guest' is the default user on a newly-established "
"connection over a :ref:`binary port <admin-security>`, and Tarantool does"
" not require a password to establish a :ref:`binary connection "
"<box_protocol-iproto_protocol>`. It is, however, possible to change the "
"current user to ‘guest’ by providing the :ref:`AUTH packet <box_protocol-"
"authentication>` with no password at all or an empty password. This "
"feature is useful for connection pools, which want to reuse a connection "
"for a different user without re-establishing it."
msgstr ""
"Для пользователя 'guest' невозможно установить пароль: это бы привело к "
"путанице, поскольку 'guest' является пользователем по умолчанию для "
"любого установленного подключения по :ref:`бинарному порту <admin-"
"security>`, а Tarantool не требует пароль при установке :ref:`бинарного "
"подключения <box_protocol-iproto_protocol>`. Тем не менее, можно сменить "
"текущего пользователя на пользователя ‘guest’, предоставив "
":ref:`AUTH-пакет <box_protocol-authentication>` (пакет авторизации) без "
"пароля или с пустым паролем. Данная функция полезна для пулов соединений,"
" которые хотят повторно использовать соединение для другого пользователя "
"без повторного подключения."

msgid "password to be hashed"
msgstr "пароль для хеширования"

msgid "box.schema.user.password('ЛЕНА')"
msgstr "box.schema.user.password('ЛЕНА')"

msgid ""
"Associate a password with the user who is currently logged in, or with "
"the user specified by user-name. The user must exist and must not be "
"'guest'."
msgstr ""
"Ассоциация пароля с авторизованным пользователем или с указанным именем "
"пользователя. Такой пользователь должен существовать и не быть "
"пользователем 'guest'."

msgid ""
"Users who wish to change their own passwords should use "
"``box.schema.user.passwd(password)`` syntax."
msgstr ""
"Если пользователь хочет поменять свой пароль, ему следует использовать "
"синтаксис ``box.schema.user.passwd(password)``."

msgid ""
"Administrators who wish to change passwords of other users should use "
"``box.schema.user.passwd(user-name, password)`` syntax."
msgstr ""
"Если администратор хочет поменять пароль других пользователей, ему "
"следует использовать синтаксис ``box.schema.user.passwd(user-name, "
"password)``."

msgid "user-name"
msgstr "имя пользователя"

msgid "password"
msgstr "пароль"

msgid ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"

#, fuzzy
msgid ""
"Return a description of a user's :ref:`privileges <authentication-"
"owners_privileges>`."
msgstr "Выдача :ref:`прав <authentication-owners_privileges>` роли."

msgid ""
"Create a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""
"Создание роли. Чтобы получить информацию о том, как происходит управление"
" данными о ролях в Tarantool'е, см. раздел :ref:`Роли <authentication-"
"roles>`."

msgid ""
"name of role, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя роли, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the role already exists"
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если роль уже существует."

msgid ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"

msgid ""
"Drop a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""
"Удаление роли. Чтобы получить информацию о том, как происходит управление"
" данными о ролях в Tarantool'е, см. раздел :ref:`Роли <authentication-"
"roles>`."

msgid "the name of the role"
msgstr "имя роли"

msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the role does not exist."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если такая роль не существует."

msgid "box.schema.role.drop('Accountant')"
msgstr "box.schema.role.drop('Accountant')"

msgid ""
"Return ``true`` if a role exists; return ``false`` if a role does not "
"exist."
msgstr ""
"Возврат ``true`` (правда), если роль существует; возврат ``false`` "
"(ложь), если роль отсутствует."

msgid "box.schema.role.exists('Accountant')"
msgstr "box.schema.role.exists('Accountant')"

msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a role."
msgstr "Выдача :ref:`прав <authentication-owners_privileges>` роли."

msgid "the name of the role."
msgstr "имя роли."

msgid "the name of a function or space or sequence or role."
msgstr "имя функции, спейса, последовательности или роли."

msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the role already has the "
"privilege."
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если у роли уже есть права."

msgid "The role must exist, and the object must exist."
msgstr "Должна существовать роль, должен существовать объект."

msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name`` -- to grant a role to a role."
msgstr ""
"**Вариант:** вместо ``privilege, object-type, object-name`` введите "
"``role-name``, чтобы назначить роль для роли."

msgid ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"

msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a role."
msgstr "Отмена :ref:`прав <authentication-owners_privileges>` роли."

msgid ""
"The role must exist, and the object must exist, but it is not an error if"
" the role does not have the privilege."
msgstr ""
"Должна существовать роль, должен существовать объект, но ошибка не "
"выпадет, если у роли нет прав."

msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name``."
msgstr ""
"**Вариант:** вместо ``privilege, object-type, object-name`` введите "
"``role-name``."

msgid ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"

msgid "Return a description of a role's privileges."
msgstr "Возврат описания прав роли."

msgid "box.schema.role.info('Accountant')"
msgstr "box.schema.role.info('Accountant')"

#, fuzzy
msgid ""
"Create a function :ref:`tuple <index-box_tuple>`. without including the "
"``body`` option. (For functions created with the ``body`` option, see "
":ref:`box.schema.func.create(func-name [, {options-with-body}]) "
"<box_schema-func_create_with-body>`."
msgstr ""
"Создание :ref:`кортежа <index-box_tuple>` с функцией. Сама функция не "
"создается -- это делается с помощью Lua -- но если необходимо выдать "
"права функции, следует сначала выполнить box.schema.func.create. Чтобы "
"получить информацию о том, как происходит управление данными функций в "
"Tarantool'е, см. справочник по спейсу :ref:`_func <box_space-func>`."

msgid ""
"This is called a \"not persistent\" function because functions without "
"bodies are not persistent. This does not create the function itself -- "
"that is done with Lua -- but if it is necessary to grant privileges for a"
" function, box.schema.func.create must be done first. For explanation of "
"how Tarantool maintains function data, see the reference for the "
":ref:`box.space._func <box_space-func>` space."
msgstr ""

msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the ``_func`` tuple already "
"exists."
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если кортеж в ``_func`` уже существует."

#, fuzzy
msgid ""
"``setuid`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means that Tarantool should treat the function’s caller as the function’s"
" owner, with owner privileges. ``setuid`` works only over :ref:`binary "
"ports <admin-security>`, ``setuid`` does not work if the function is "
"invoked via an :ref:`admin console <admin-security>` or inside a Lua "
"script."
msgstr ""
"``setuid`` = ``true|false`` (по умолчанию, false) -- значение ``true`` "
"(правда) заставит Tarantool рассматривать пользователя, вызвавшего "
"функцию, в качестве владельца функции с полными правами. Следует помнить,"
" что SETUID работает только по :ref:`бинарным портам <admin-security>`. "
"SETUID не сработает, если вызвать функцию через :ref:`административную "
"консоль <admin-security>` или в Lua-скрипте."

#, fuzzy
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’) - string."
msgstr "``language`` = 'LUA'|'C' (выбор языка из Lua и C; по умолчанию, ‘LUA’)."

msgid ""
"name of function, which should conform to the :ref:`rules for object "
"names <app_server-names>`"
msgstr ""
"имя функции, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr "``if_not_exists``, ``setuid``, ``language``."

msgid ""
"These functions can be called with :samp:`{function-"
"object}:call({arguments})`; however, unlike the case with ordinary "
"functions, array arguments will not be correctly recognized unless they "
"are enclosed in braces."
msgstr ""

msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"

msgid ""
"Create a function :ref:`tuple <index-box_tuple>`. including the ``body`` "
"option. (For functions created without the ``body`` option, see "
":ref:`box.schema.func.create(func-name [, {options-without-body}]) "
"<box_schema-func_create>`."
msgstr ""

msgid ""
"This is called a \"persistent\" function because only functions with "
"bodies are persistent. This does create the function itself, the body is "
"a function definition. For explanation of how Tarantool maintains "
"function data, see the reference for the :ref:`box.space._func "
"<box_space-func>` space."
msgstr ""

msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; same "
"as for :ref:`box.schema.func.create(func-name [, {options-without-body}])"
" <box_schema-func_create>`."
msgstr ""

msgid ""
"``setuid`` = ``true|false`` (default = ``false``) - boolean; same as for "
":ref:`box.schema.func.create(func-name [, {options-without-body}]) "
"<box_schema-func_create>`."
msgstr ""

msgid ""
"``language`` = 'LUA'|'C' (default = ‘LUA’) - string. same as for "
":ref:`box.schema.func.create(func-name [, {options-without-body}]) "
"<box_schema-func_create>`."
msgstr ""

#, fuzzy
msgid ""
"``is_sandboxed`` = ``true|false`` (default = ``false``) - boolean; "
"whether the function should be executed in a sandbox."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если такой пользователь не существует."

#, fuzzy
msgid ""
"``is_deterministic`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means that the function should be deterministic, ``false`` means"
" that the function may or may not be deterministic."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если кортеж в _func не существует."

msgid ""
"``body`` = function definition (default = nil) - string; the function "
"definition."
msgstr ""

msgid ""
"Additional options for SQL = See :ref:`Calling Lua routines from SQL "
"<sql_calling_lua>`."
msgstr ""

#, fuzzy
msgid ""
"``if_not_exists``, ``setuid``, ``language``, ``is_sandboxed``, "
"``is_deterministic``, ``body``."
msgstr "``if_not_exists``, ``setuid``, ``language``."

msgid ""
"C functions are imported from .so files, Lua functions can be defined "
"within ``body``. We will only describe Lua functions in this section."
msgstr ""

msgid ""
"A function tuple with a body is \"persistent\" because the tuple is "
"stored in a snapshot and is recoverable if the server restarts. All of "
"the option values described in this section are visible in the "
":ref:`box.space._func <box_space-func>` system space."
msgstr ""

msgid ""
"If ``is_sandboxed`` is true, then the function will be executed in an "
"isolated environment: any operation that accesses the world outside the "
"sandbox will be forbidden or will have no effect. Therefore a sandboxed "
"function can only use modules and functions which cannot affect "
"isolation: `assert <https://www.lua.org/manual/5.1/manual.html#pdf-"
"assert>`_, `error <://www.lua.org/manual/5.1/manual.html#pdf-error>`_, "
"`ipairs <https://www.lua.org/manual/5.1/manual.html#pdf-ipairs>`_, "
"`math.* <https://www.lua.org/manual/5.1/manual.html#5.6>`_, `next "
"<https://www.lua.org/manual/5.1/manual.html#pdf-next>`_, `pairs "
"<https://www.lua.org/manual/5.1/manual.html#pdf-pairs>`_, `pcall "
"<https://www.lua.org/manual/5.1/manual.html#pdf-pcall>`_, `print "
"<https://www.lua.org/manual/5.1/manual.html#pdf-print>`_, `select "
"<https://www.lua.org/manual/5.1/manual.html#pdf-select>`_, `string.* "
"<https://www.lua.org/manual/5.1/manual.html#5.4>`_, `table.* "
"<https://www.lua.org/manual/5.1/manual.html#5.5>`_, `tonumber "
"<https://www.lua.org/manual/5.1/manual.html#pdf-tonumber>`_, `tostring "
"<https://www.lua.org/manual/5.1/manual.html#pdf-tostring>`_, `type "
"<https://www.lua.org/manual/5.1/manual.html#pdf-type>`_, `unpack "
"<https://www.lua.org/manual/5.1/manual.html#pdf-unpack>`_, :ref:`utf8.* "
"<utf8-module>`, `xpcall <https://www.lua.org/manual/5.1/manual.html#pdf-"
"xpcall>`_. Also a sandboxed function cannot refer to global variables -- "
"they will be treated as local variables because the sandbox is "
"established with `setfenv <https://www.lua.org/manual/5.1/manual.html"
"#pdf-setfenv>`_. So a sandboxed function will happen to be stateless and "
"deterministic."
msgstr ""

msgid ""
"If ``is_deterministic`` is true, there is no immediate effect. Tarantool "
"plans to use the is_deterministic value in a future version. A function "
"is deterministic if it always returns the same outputs given the same "
"inputs. It is the function creator's responsibility to ensure that a "
"function is truly deterministic."
msgstr ""

msgid "**Using a persistent Lua function**"
msgstr ""

msgid ""
"After a persistent Lua function is created, it can be found in the "
":ref:`box.space._func <box_space-func>` system space, and it can be shown"
" with |br| :samp:`box.func.{func-name}` |br| and it can be invoked by any"
" user with :ref:`authorization <authentication-owners_privileges>` to "
"'execute' it. The syntax for invoking is: |br| :samp:`box.func.{func-"
"name}:call([parameters])` |br| or, if the connection is remote, the "
"syntax is as in :ref:`net_box:call() <net_box-call>`."
msgstr ""

msgid ""
"tarantool> lua_code = [[function(a, b) return a + b end]]\n"
"tarantool> box.schema.func.create('sum', {body = lua_code})\n"
"\n"
"tarantool> box.func.sum\n"
"---\n"
"- is_sandboxed: false\n"
"  is_deterministic: false\n"
"  id: 2\n"
"  setuid: false\n"
"  body: function(a, b) return a + b end\n"
"  name: sum\n"
"  language: LUA\n"
"...\n"
"\n"
"tarantool> box.func.sum:call({1, 2})\n"
"---\n"
"- 3\n"
"..."
msgstr ""

msgid ""
"Drop a function tuple. For explanation of how Tarantool maintains "
"function data, see reference on :ref:`_func space <box_space-func>`."
msgstr ""
"Удаление кортежа с функцией. Чтобы получить информацию о том, как "
"происходит управление данными функций в Tarantool'е, см. справочник по "
"спейсу :ref:`_func <box_space-func>`."

msgid "the name of the function"
msgstr "имя функции"

msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the _func tuple does not exist."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если кортеж в _func не существует."

msgid "box.schema.func.drop('calculate')"
msgstr "box.schema.func.drop('calculate')"

msgid ""
"Return true if a function tuple exists; return false if a function tuple "
"does not exist."
msgstr ""
"Возврат true (правда), если кортеж с функцией существует; возврат false "
"(ложь), если кортеж с функцией отсутствует."

msgid "box.schema.func.exists('calculate')"
msgstr "box.schema.func.exists('calculate')"

msgid "Reload a C module with all its functions without restarting the server."
msgstr "Перезагрузка модуля на C (со всеми его функциями) без перезапуска сервера."

msgid ""
"Under the hood, Tarantool loads a new copy of the module (``*.so`` shared"
" library) and starts routing all new request to the new version. The "
"previous version remains active until all started calls are finished. All"
" shared libraries are loaded with ``RTLD_LOCAL`` (see \"man 3 dlopen\"), "
"therefore multiple copies can co-exist without any problems."
msgstr ""
"С точки зрения внутреннего устройства, Tarantool загружает новую копию "
"модуля (библиотека общего пользования ``*.so``) и запускает маршрутизацию"
" всех новых запросов на новую версию. Предыдущая версия остается активной"
" до тех пор, пока не завершатся все начатые вызовы. Все библиотеки общего"
" пользования загружены с ``RTLD_LOCAL`` (см. \"man 3 dlopen\"), таким "
"образом, множество копий могут работать одновременно без каких-либо "
"проблем."

msgid ""
"Reload will fail if a module was loaded from Lua script with `ffi.load() "
"<http://luajit.org/ext_ffi_api.html#ffi_load>`_."
msgstr ""
"Перезагрузка не сработает, если модуль был загружен из Lua-скрипта с "
"`ffi.load() <http://luajit.org/ext_ffi_api.html#ffi_load>`_."

msgid "the name of the module to reload"
msgstr "имя модуля для перезагрузки"

msgid ""
"-- reload the entire module contents\n"
"box.schema.func.reload('module')"
msgstr ""
"-- перегрузить целиком всё содержимое модуля\n"
"box.schema.func.reload('module')"

msgid "Sequences"
msgstr "Последовательности"

msgid ""
"An introduction to sequences is in the :ref:`Sequences <index-"
"box_sequence>` section of the \"Data model\" chapter. Here are the "
"details for each function and option."
msgstr ""
"Вводная информация о последовательностях дается в разделе "
":ref:`Последовательности <index-box_sequence>` главы \"Модель данных\". "
"Здесь же приведена подробная информация о каждой функции и каждом "
"параметре."

msgid ""
"All functions related to sequences require appropriate :ref:`privileges "
"<authentication-owners_privileges>`."
msgstr ""
"Все функции, связанные с последовательностями, требуют наличия "
"соответствующих :ref:`прав <authentication-owners_privileges>`."

msgid "Create a new sequence generator."
msgstr "Создание нового генератора последовательностей."

msgid "the name of the sequence"
msgstr "имя последовательности"

msgid ""
"see a quick overview in the \"Options for "
"``box.schema.sequence.create()``\" :ref:`chart <index-box_sequence-"
"options>` (in the :ref:`Sequences <index-box_sequence>` section of the "
"\"Data model\" chapter), and see more details below."
msgstr ""
"см. краткий обзор в :ref:`таблице <index-box_sequence-options>` "
"\"Параметры для ``box.schema.sequence.create()``\"  (в разделе "
":ref:`Последовательности <index-box_sequence>` главы \"Модель данных\"), "
"а более подробную информацию ниже."

msgid "a reference to a new sequence object."
msgstr "ссылка на новый объект последовательности."

msgid "Options:"
msgstr "Параметры:"

msgid "``start`` -- the STARTS WITH value. Type = integer, Default = 1."
msgstr "``start`` -- НАЧАЛЬНОЕ значение. Тип = целое число, по умолчанию = 1."

msgid "``min`` -- the MINIMUM value. Type = integer, Default = 1."
msgstr "``min`` -- МИНИМАЛЬНОЕ значение. Тип = целое число, по умолчанию = 1."

msgid ""
"``max`` - the MAXIMUM value. Type = integer, Default = "
"9223372036854775807."
msgstr ""
"``max`` --МАКСИМАЛЬНОЕ значение. Тип = целое число, по умолчанию = "
"9223372036854775807."

msgid ""
"There is a rule: ``min`` <= ``start`` <= ``max``. For example it is "
"illegal to say ``{start=0}`` because then the specified start value (0) "
"would be less than the default min value (1)."
msgstr ""
"Есть следующее правило: ``min`` <= ``start`` <= ``max``. Например, нельзя"
" указать ``{start=0}``, поскольку указанное начальное значение (0) будет "
"меньше, чем минимальное значение, используемое по умолчанию (1)."

msgid ""
"There is a rule: ``min`` <= next-value <= ``max``. For example, if the "
"next generated value would be 1000, but the maximum value is 999, then "
"that would be considered \"overflow\"."
msgstr ""
"Есть следующее правило: ``min`` <= следующее-значение <= ``max``. "
"Например, если сгенерированное значение будет 1000, но максимальное "
"значение -- 999, это будет считаться переполнением."

msgid ""
"There is a rule: ``start`` and ``min`` and ``max`` must all be <= "
"9223372036854775807 which is 2^63 - 1 (not 2^64)."
msgstr ""

msgid "``cycle`` -- the CYCLE value. Type = bool. Default = false."
msgstr ""
"``cycle`` -- значение ЦИКЛА. Тип = bool (логический), по умолчанию = "
"false (ложь)."

msgid ""
"If the sequence generator's next value is an overflow number, it causes "
"an error return -- unless ``cycle == true``."
msgstr ""
"Если следующее значение в генераторе последовательности будет "
"переполнением, это вызовет ошибку -- не считая случаев, когда задан цикл "
"(``cycle == true``)."

msgid ""
"But if ``cycle == true``, the count is started again, at the MINIMUM "
"value or at the MAXIMUM value (not the STARTS WITH value)."
msgstr ""
"Если же ``cycle == true``, отсчет начинается заново с МИНИМАЛЬНОГО "
"значения или с МАКСИМАЛЬНОГО значения (не с НАЧАЛЬНОГО значения)."

msgid "``cache`` -- the CACHE value. Type = unsigned integer. Default = 0."
msgstr ""
"``cache`` -- значение КЭША. Тип = беззнаковое целое число, по умолчанию ="
" 0."

msgid "Currently Tarantool ignores this value, it is reserved for future use."
msgstr ""
"В данный момент Tarantool игнорирует это значение, оно зарезервировано "
"для последующего использования."

msgid "``step`` -- the INCREMENT BY value. Type = integer. Default = 1."
msgstr "``step`` -- значение УВЕЛИЧЕНИЯ. Тип = целое число, по умолчанию = 1."

msgid "Ordinarily this is what is added to the previous value."
msgstr "Это значение прибавляется к предыдущему."

msgid "Generate the next value and return it."
msgstr "Генерация и возврат следующего значения."

msgid "The generation algorithm is simple:"
msgstr "Простой алгоритм для генерации:"

msgid "If this is the first time, then return the STARTS WITH value."
msgstr "В первый раз вернуть НАЧАЛЬНОЕ значение."

msgid ""
"If the previous value plus the INCREMENT value is less than the MINIMUM "
"value or greater than the MAXIMUM value, that is \"overflow\", so either "
"raise an error (if ``cycle`` = ``false``) or return the MAXIMUM value (if"
" ``cycle`` = ``true`` and ``step`` < 0) or return the MINIMUM value (if "
"``cycle`` = ``true`` and ``step`` > 0)."
msgstr ""
"Если предыдущее значение плюс значение УВЕЛИЧЕНИЯ меньше, чем МИНИМАЛЬНОЕ"
" значение, или больше, чем МАКСИМАЛЬНОЕ значение, будет переполнение, "
"поэтому либо выдать сообщение об ошибке (если цикл не задан -- ``cycle`` "
"= ``false``) или вернуть МАКСИМАЛЬНОЕ значение (если цикл задан -- "
"``cycle`` = ``true`` -- и ``step`` < 0), или вернуть МИНИМАЛЬНОЕ значение"
" (если цикл задан -- ``cycle`` = ``true`` -- и ``step`` > 0)."

msgid ""
"If there was no error, then save the returned result, it is now the "
"\"previous value\"."
msgstr ""
"Если ошибки нет, сохранить результат, который становится \"предыдущим "
"значением\"."

msgid "For example, suppose sequence 'S' has:"
msgstr "Например, предположим, что для последовательности 'S':"

msgid "``min`` == -6,"
msgstr "``min`` == -6,"

msgid "``max`` == -1,"
msgstr "``max`` == -1,"

msgid "``step`` == -3,"
msgstr "``step`` == -3,"

msgid "``start`` = -2,"
msgstr "``start`` = -2,"

msgid "``cycle`` = true,"
msgstr "``cycle`` = true,"

msgid "previous value = -2."
msgstr "предыдущее значение = -2."

msgid "Then ``box.sequence.S:next()`` returns -5 because -2 + (-3) == -5."
msgstr "Тогда ``box.sequence.S:next()`` вернет -5, потому что -2 + (-3) == -5."

msgid ""
"Then ``box.sequence.S:next()`` again returns -1 because -5 + (-3) < -6, "
"which is overflow, causing cycle, and ``max`` == -1."
msgstr ""
"Затем ``box.sequence.S:next()`` снова вернет -1, потому что -5 + (-3) < "
"-6, что будет переполнением, которое вызовет цикл, а ``max`` == -1."

msgid ""
"This function requires a :ref:`'write' privilege <box_schema-user_grant>`"
" on the sequence."
msgstr ""
"Для данной функции необходимы права на :ref:`запись ('write') "
"<box_schema-user_grant>` на последовательность."

msgid ""
"This function should not be used in \"cross-engine\" transactions "
"(transactions which use both the memtx and the vinyl storage engines)."
msgstr ""
"Данную функцию не следует использовать в транзакциях между движками "
"(транзакции, в которых используется и движок memtx, и движок vinyl)."

msgid ""
"To see what the previous value was, without changing it, you can select "
"from the :ref:`_sequence_data <box_space-sequence_data>` system space."
msgstr ""
"Чтобы увидеть предыдущее значение, не изменяя его, сделайте выборку из "
"системного спейса :ref:`_sequence_data <box_space-sequence_data>`."

msgid ""
"The ``alter()`` function can be used to change any of the sequence's "
"options. Requirements and restrictions are the same as for "
":ref:`box.schema.sequence.create() <box_schema-sequence_create>`."
msgstr ""
"Функцию ``alter()`` можно использовать для изменения любых параметров "
"последовательности. Требования и ограничения в данном случае такие же, "
"как для :ref:`box.schema.sequence.create() <box_schema-sequence_create>`."

msgid ""
"Set the sequence back to its original state. The effect is that a "
"subsequent ``next()`` will return the ``start`` value. This function "
"requires a :ref:`'write' privilege <box_schema-user_grant>` on the "
"sequence."
msgstr ""
"Возврат последовательности в оригинальное состояние. Смысл в том, что "
"последующий вызов ``next()`` вернет начальное значение ``start``. Для "
"данной функции необходимы права на :ref:`запись ('write') <box_schema-"
"user_grant>` на последовательность."

msgid ""
"Set the \"previous value\" to ``new-previous-value``. This function "
"requires a :ref:`'write' privilege <box_schema-user_grant>` on the "
"sequence."
msgstr ""
"Установите \"предыдущее значение\" на ``new-previous-value`` (новое "
"предыдущее значение). Для данной функции необходимы права на :ref:`запись"
" ('write') <box_schema-user_grant>` на последовательность."

msgid ""
"Return the last retrieved value of the specified sequence or throw an "
"error if no value has been generated yet (``next()`` has not been called "
"yet, or ``current()`` is called right after ``reset()`` is called)."
msgstr "Вернуть последнее найденное значение заданной последовательности или "
"выдать ошибку, если значение еще не было сгенерировано (функция ``next`` еще "
"не вызывалась или ``current`` была вызвана сразу после вызова ``reset``)."

msgid ""
"tarantool> sq = box.schema.sequence.create('test')\n"
"---\n"
"...\n"
"tarantool> sq:current()\n"
"---\n"
"- error: Sequence 'test' is not started\n"
"...\n"
"tarantool> sq:next()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> sq:current()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> sq:set(42)\n"
"---\n"
"...\n"
"tarantool> sq:current()\n"
"---\n"
"- 42\n"
"...\n"
"tarantool> sq:reset()\n"
"---\n"
"...\n"
"tarantool> sq:current()  -- error\n"
"---\n"
"- error: Sequence 'test' is not started\n"
"..."
msgstr ""

msgid "Drop an existing sequence."
msgstr "Удаление существующей последовательности."

msgid "Here is an example showing all sequence options and operations:"
msgstr ""
"Ниже представлен пример, иллюстрирующий все параметры и операции для "
"последовательностей:"

#, fuzzy
msgid ""
"s = box.schema.sequence.create(\n"
"               'S2',\n"
"               {start=100,\n"
"               min=100,\n"
"               max=tonumber64('9223372036854775807'),\n"
"               cache=100000,\n"
"               cycle=false,\n"
"               step=100\n"
"               })\n"
"s:alter({step=6})\n"
"s:next()\n"
"s:reset()\n"
"s:set(150)\n"
"s:drop()"
msgstr ""
"s = box.schema.sequence.create(\n"
"               'S2',\n"
"               {start=100,\n"
"               min=100,\n"
"               max=200,\n"
"               cache=100000,\n"
"               cycle=false,\n"
"               step=100\n"
"               })\n"
"s:alter({step=6})\n"
"s:next()\n"
"s:reset()\n"
"s:set(150)\n"
"s:drop()"

#, fuzzy
msgid ""
"You can use the ``sequence`` option when :ref:`creating <box_space-"
"create_index>` or :ref:`altering <box_index-alter>` a primary-key index. "
"The sequence becomes associated with the index, so that the next "
"``insert()`` will put the next generated number into the primary-key "
"field, if the field value would otherwise be nil."
msgstr ""
"Можно использовать опцию :samp:`sequence={имя-последовательности}` (или "
":samp:`sequence={id-последовательности}`, или :samp:`sequence=true`) при "
":ref:`создании <box_space-create_index>` или :ref:`изменении <box_index-"
"alter>` первичного индекса. Происходит ассоциация последовательности с "
"индексом, так что следующий вызов ``insert()`` поместит следующее "
"сгенерированное число в поле первичного ключа, если в противном случае "
"поле было бы nil."

msgid ""
"The syntax may be any of: |br| :samp:`sequence = {sequence identifier}` "
"|br| or :code:`sequence = {id =` :samp:`{sequence identifier}` :code:`}` "
"|br| or :code:`sequence = {field =` :samp:`{field number}` :code:`}` |br|"
" or :code:`sequence = {id =` :samp:`{sequence identifier}` :code:`, field"
" =` :samp:`{field number}` :code:`}` |br| or :code:`sequence = true` |br|"
" or :code:`sequence = {}`. |br| The sequence identifier may be either a "
"number (the sequence id) or a string (the sequence name). The field "
"number may be the ordinal number of any field in the index; default = 1. "
"Examples of all possibilities: ``sequence = 1`` or ``sequence = "
"'sequence_name'`` or ``sequence = {id = 1}`` or ``sequence = {id = "
"'sequence_name'}`` or ``sequence = {id = 1, field = 1}`` or ``sequence = "
"{id = 'sequence_name', field = 1}`` or ``sequence = {field = 1}`` or "
"``sequence = true`` or ``sequence = {}``. Notice that the sequence "
"identifier can be omitted, if it is omitted then a new sequence is "
"created automatically with default name = :samp:`{space-name}_seq`. "
"Notice that the field number does not have to be 1, that is, the sequence"
" can be associated with any field in the primary-key index."
msgstr ""

msgid ""
"For example, if 'Q' is a sequence and 'T' is a new space, then this will "
"work:"
msgstr ""
"Например, если 'Q' -- это последовательность, а 'T' -- это новый спейс, "
"то сработает:"

msgid ""
"tarantool> box.space.T:create_index('Q',{sequence='Q'})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  sequence_id: 8\n"
"  id: 0\n"
"  space_id: 514\n"
"  name: Q\n"
"  type: TREE\n"
"..."
msgstr ""
"tarantool> box.space.T:create_index('Q',{sequence='Q'})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  sequence_id: 8\n"
"  id: 0\n"
"  space_id: 514\n"
"  name: Q\n"
"  type: TREE\n"
"..."

msgid "(Notice that the index now has a ``sequence_id`` field.)"
msgstr ""
"(Обратите внимание, что теперь в индексе есть поле идентификатора "
"последовательности ``sequence_id``.)"

msgid "And this will work:"
msgstr "И сработает:"

msgid ""
"tarantool> box.space.T:insert{nil,0}\n"
"---\n"
"- [1, 0]\n"
"..."
msgstr ""
"tarantool> box.space.T:insert{nil,0}\n"
"---\n"
"- [1, 0]\n"
"..."

msgid ""
"The index key type may be either 'integer' or 'unsigned'. If any of the "
"sequence options is a negative number, then the index key type should be "
"'integer'."
msgstr ""

msgid ""
"Users should not insert a value greater than 9223372036854775807, which "
"is 2^63 - 1, in the indexed field. The sequence generator will ignore it."
msgstr ""

msgid ""
"A sequence cannot be dropped if it is associated with an index. However, "
":ref:`index_object:alter() <box_index-alter>` can be used to say that a "
"sequence is not associated with an index, for example "
"``box.space.T.index.I:alter({sequence=false})``."
msgstr ""
"Последовательность нельзя удалить, если она связана с индексом. Тем не "
"менее, можно использовать :ref:`index_object:alter() <box_index-alter>`, "
"чтобы показать, что последовательность не связана с индексом, например "
"так ``box.space.T.index.I:alter({sequence=false})``."

msgid ""
"If a sequence was created automatically because the sequence identifier "
"was omitted, then it will be dropped automatically if the index is "
"altered so that ``sequence=false``, or if the index is dropped."
msgstr ""

msgid ""
"``index_object:alter()`` can also be used to associate a sequence with an"
" existing index, with the same syntax for options."
msgstr ""

msgid ""
"When a sequence is used with an index based on a JSON path, inserted "
"tuples must have all components of the path preceding the autoincrement "
"field, and the autoincrement field. To achieve that use ``box.NULL`` "
"rather than ``nil``. Example:"
msgstr ""

msgid ""
"s = box.schema.space.create('test')\n"
"s:create_index('pk', {parts = {{'[1].a.b[1]', 'unsigned'}}, sequence = "
"true})\n"
"s:replace{} -- error\n"
"s:replace{{c = {}}} -- error\n"
"s:replace{{a = {c = {}}}} -- error\n"
"s:replace{{a = {b = {}}}} -- error\n"
"s:replace{{a = {b = {nil}}}} -- error\n"
"s:replace{{a = {b = {box.NULL}}}} -- ok"
msgstr ""
