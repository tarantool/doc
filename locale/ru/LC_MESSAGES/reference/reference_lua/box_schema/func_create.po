
msgid "box.schema.func.create()"
msgstr ""

msgid ""
"Create a function. The created function can be used in different usage "
"scenarios, for example, in :ref:`field or tuple constraints <index-"
"constraints>` or :ref:`functional indexes <box_space-index_func>`."
msgstr ""

msgid ""
"Using the :ref:`body <function_options_body>` option, you can make a "
"function *persistent*. In this case, the function is \"persistent\" because "
"its definition is stored in a snapshot (the :ref:`box.space._func "
"<box_space-func>` system space) and can be recovered if the server restarts."
msgstr ""

msgid "Parameters"
msgstr "Параметры"

#, fuzzy
msgid ""
"a name of the function, which should conform to the :ref:`rules for object "
"names <app_server-names>`"
msgstr ""
"имя функции, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

msgid "see :ref:`function_options <func_create_function_options>`"
msgstr ""

msgid "return"
msgstr "возвращает"

msgid "nil"
msgstr "nil"

msgid ""
":ref:`box.schema.user.grant() <box_schema-user_grant>` can be used to allow "
"the specified user or role to execute the created function."
msgstr ""

msgid "**Example 1: a non-persistent Lua function**"
msgstr ""

msgid "The example below shows how to create a non-persistent Lua function:"
msgstr ""

msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

msgid "**Example 2: a persistent Lua function**"
msgstr ""

msgid ""
"The example below shows how to create a persistent Lua function, show its "
"definition using ``box.func.{func-name}``, and call this function using "
"``box.func.{func-name}:call([parameters])``:"
msgstr ""

msgid ""
"tarantool> lua_code = [[function(a, b) return a + b end]]\n"
"tarantool> box.schema.func.create('sum', {body = lua_code})\n"
"\n"
"tarantool> box.func.sum\n"
"---\n"
"- is_sandboxed: false\n"
"  is_deterministic: false\n"
"  id: 2\n"
"  setuid: false\n"
"  body: function(a, b) return a + b end\n"
"  name: sum\n"
"  language: LUA\n"
"...\n"
"\n"
"tarantool> box.func.sum:call({1, 2})\n"
"---\n"
"- 3\n"
"..."
msgstr ""

msgid ""
"To call functions using ``net.box``, use :ref:`net_box:call() <net_box-"
"call>`."
msgstr ""

msgid "**Example 3: a persistent SQL expression used in a tuple constraint**"
msgstr ""

msgid ""
"The code snippet below defines a function that checks a tuple's data using "
"the SQL expression:"
msgstr ""

msgid ""
"box.schema.func.create('check_person', {\n"
"    language = 'SQL_EXPR',\n"
"    is_deterministic = true,\n"
"    body = [[\"age\" > 21 AND \"name\" != 'Admin']]\n"
"})\n"
msgstr ""

msgid ""
"Then, this function is used to create a tuple :ref:`constraint <index-"
"constraints>`:"
msgstr ""

msgid ""
"local customers = box.schema.space.create('customers', { constraint = 'check_person' })\n"
"customers:format({\n"
"    { name = 'id', type = 'number' },\n"
"    { name = 'name', type = 'string' },\n"
"    { name = 'age', type = 'number' },\n"
"})\n"
"customers:create_index('primary', { parts = { 1 } })\n"
msgstr ""

msgid ""
"On an attempt to insert a tuple that doesn't meet the required criteria, an "
"error is raised:"
msgstr ""

msgid ""
"customers:insert { 2, \"Bob\", 18 }\n"
"-- error: Check constraint 'check_person' failed for tuple\n"
msgstr ""

msgid "function_options"
msgstr ""

msgid ""
"A table containing options passed to the :ref:`box.schema.func.create(func-"
"name [, function_options]) <box_schema-func_create_with-body>` function."
msgstr ""

msgid ""
"Specify whether there should be no error if the function already exists."
msgstr ""

msgid "Type: boolean"
msgstr ""

msgid "Default: ``false``"
msgstr ""

#, fuzzy
msgid ""
"Make Tarantool treat the function's caller as the function's creator, with "
"full privileges. Note that ``setuid`` works only over :ref:`binary ports "
"<admin-security>`. ``setuid`` doesn't work if you invoke a function using "
"the :ref:`admin console <admin-security>` or inside a Lua script."
msgstr ""
"``setuid`` = ``true|false`` (по умолчанию, false) -- значение ``true`` "
"(правда) заставит Tarantool рассматривать пользователя, вызвавшего функцию, "
"в качестве владельца функции с полными правами. Следует помнить, что SETUID "
"работает только по :ref:`бинарным портам <admin-security>`. SETUID не "
"сработает, если вызвать функцию через :ref:`административную консоль <admin-"
"security>` или в Lua-скрипте."

msgid "Specify the function language. The possible values are:"
msgstr ""

msgid ""
"``LUA``: define a Lua function in the :ref:`body <function_options_body>` "
"attribute."
msgstr ""

msgid ""
"``SQL_EXPR``: define an :ref:`SQL expression <sql_expressions>` in the "
":ref:`body <function_options_body>` attribute. An SQL expression can only be"
" used as a field or tuple :ref:`constraint <index-constraints>`."
msgstr ""

msgid ""
"``C``: import a C function using its name from a ``.so`` file. Learn how to "
"call C code from Lua in the :ref:`C tutorial <f_c_tutorial-"
"c_stored_procedures>`."
msgstr ""

msgid ""
"To reload a C module with all its functions without restarting the server, "
"call :ref:`box.schema.func.reload() <box_schema-func_reload>`."
msgstr ""

msgid "Type: string"
msgstr ""

msgid "Default: ``LUA``"
msgstr ""

msgid ""
"Whether the function should be executed in an isolated environment. This "
"means that any operation that accesses the world outside the sandbox is "
"forbidden or has no effect. Therefore, a sandboxed function can only use "
"modules and functions that cannot affect isolation:"
msgstr ""

msgid ""
"`assert <https://www.lua.org/manual/5.1/manual.html#pdf-assert>`_, `assert "
"<https://www.lua.org/manual/5.1/manual.html#pdf-assert>`_, `error "
"<https://www.lua.org/manual/5.1/manual.html#pdf-error>`_, `ipairs "
"<https://www.lua.org/manual/5.1/manual.html#pdf-ipairs>`_, `math.* "
"<https://www.lua.org/manual/5.1/manual.html#5.6>`_, `next "
"<https://www.lua.org/manual/5.1/manual.html#pdf-next>`_, `pairs "
"<https://www.lua.org/manual/5.1/manual.html#pdf-pairs>`_, `pcall "
"<https://www.lua.org/manual/5.1/manual.html#pdf-pcall>`_, `print "
"<https://www.lua.org/manual/5.1/manual.html#pdf-print>`_, `select "
"<https://www.lua.org/manual/5.1/manual.html#pdf-select>`_, `string.* "
"<https://www.lua.org/manual/5.1/manual.html#5.4>`_, `table.* "
"<https://www.lua.org/manual/5.1/manual.html#5.5>`_, `tonumber "
"<https://www.lua.org/manual/5.1/manual.html#pdf-tonumber>`_, `tostring "
"<https://www.lua.org/manual/5.1/manual.html#pdf-tostring>`_, `type "
"<https://www.lua.org/manual/5.1/manual.html#pdf-type>`_, `unpack "
"<https://www.lua.org/manual/5.1/manual.html#pdf-unpack>`_, `xpcall "
"<https://www.lua.org/manual/5.1/manual.html#pdf-xpcall>`_, :ref:`utf8.* "
"<utf8-module>`."
msgstr ""

msgid ""
"Also, a sandboxed function cannot refer to global variables -- they are "
"treated as local variables because the sandbox is established with `setfenv "
"<https://www.lua.org/manual/5.1/manual.html#pdf-setfenv>`_. So, a sandboxed "
"function is stateless and deterministic."
msgstr ""

msgid "Specify whether a function should be deterministic."
msgstr ""

msgid ""
"If ``true`` is set in the function definition for a functional index, the "
"function returns multiple keys. For details, see the :ref:`example "
"<box_space-index_func_multikey>`."
msgstr ""

msgid ""
"Specify a function body. You can set a function's language using the "
":ref:`language <function_options_language>` attribute."
msgstr ""

msgid ""
"The code snippet below defines a :ref:`constraint <index-constraints>` "
"function that checks a tuple's data using a Lua function:"
msgstr ""

msgid ""
"box.schema.func.create('check_person', {\n"
"    language = 'LUA',\n"
"    is_deterministic = true,\n"
"    body = 'function(t, c) return (t.age >= 0 and #(t.name) > 3) end'\n"
"})\n"
msgstr ""

msgid ""
"In the following example, an SQL expression is used to check a tuple's data:"
msgstr ""

msgid ""
"Example: :ref:`A persistent SQL expression used in a tuple constraint "
"<box_schema-func_example-sql>`"
msgstr ""

msgid "Default: ``nil``"
msgstr ""

msgid "**Since:** :doc:`2.10.0 </release/2.10.0>`"
msgstr ""

msgid ""
"If set to ``true`` for a Lua function and the function is called via "
"``net.box`` (:ref:`conn:call() <net_box-call>`) or by ``box.func.<func-"
"name>:call()``, the function arguments are passed being wrapped in a "
":ref:`MsgPack object <msgpack-object-info>`:"
msgstr ""

msgid ""
"local msgpack = require('msgpack')\n"
"box.schema.func.create('my_func', {takes_raw_args = true})\n"
"local my_func = function(mp)\n"
"    assert(msgpack.is_object(mp))\n"
"    local args = mp:decode() -- array of arguments\n"
"end"
msgstr ""

msgid ""
"If a function forwards most of its arguments to another Tarantool instance "
"or writes them to a database, the usage of this option can improve "
"performance because it skips the MsgPack data decoding in Lua."
msgstr ""

msgid "Specify the languages that can call the function."
msgstr ""

msgid "Example: ``exports = {'LUA', 'SQL'}``"
msgstr ""

msgid "See also: :ref:`Calling Lua routines from SQL <sql_calling_lua>`"
msgstr ""

msgid "Type: table"
msgstr ""

msgid "Default: ``{'LUA'}``"
msgstr ""

msgid "Specify the Lua type names for each parameter of the function."
msgstr ""

msgid "Example: ``param_list = {'number', 'number'}``"
msgstr ""

msgid "Specify the Lua type name for a function's return value."
msgstr ""

msgid "Example: ``returns = 'number'``"
msgstr ""

#~ msgid ""
#~ "Create a function :ref:`tuple <index-box_tuple>`. without including the "
#~ "``body`` option. (For functions created with the ``body`` option, see "
#~ ":ref:`box.schema.func.create(func-name [, {options-with-body}]) <box_schema-"
#~ "func_create_with-body>`."
#~ msgstr ""

#~ msgid ""
#~ "This is called a \"not persistent\" function because functions without "
#~ "bodies are not persistent. This does not create the function itself -- that "
#~ "is done with Lua -- but if it is necessary to grant privileges for a "
#~ "function, box.schema.func.create must be done first. For explanation of how "
#~ "Tarantool maintains function data, see the reference for the "
#~ ":ref:`box.space._func <box_space-func>` space."
#~ msgstr ""

#~ msgid "The possible options are:"
#~ msgstr "Возможны следующие опции:"

#~ msgid ""
#~ "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true``"
#~ " means there should be no error if the ``_func`` tuple already exists."
#~ msgstr ""
#~ "``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
#~ "умолчанию ложь) - логическое значение boolean; ``true`` (правда) означает, "
#~ "что ошибка не выпадет, если кортеж в ``_func`` уже существует."

#~ msgid "``language`` = 'LUA'|'C' (default = ‘LUA’)."
#~ msgstr ""
#~ "``language`` = 'LUA'|'C' (выбор языка из Lua и C; по умолчанию, ‘LUA’)."

#~ msgid "``if_not_exists``, ``setuid``, ``language``."
#~ msgstr "``if_not_exists``, ``setuid``, ``language``."

#~ msgid ""
#~ "These functions can be called with :samp:`{function-"
#~ "object}:call({arguments})`; however, unlike the case with ordinary "
#~ "functions, array arguments will not be correctly recognized unless they are "
#~ "enclosed in braces."
#~ msgstr ""

#~ msgid "**Example:**"
#~ msgstr "**Пример:**"

#~ msgid ""
#~ "Create a function :ref:`tuple <index-box_tuple>`. including the ``body`` "
#~ "option. (For functions created without the ``body`` option, see "
#~ ":ref:`box.schema.func.create(func-name [, {options-without-body}]) "
#~ "<box_schema-func_create>`."
#~ msgstr ""

#~ msgid ""
#~ "This is called a \"persistent\" function because only functions with bodies "
#~ "are persistent. This does create the function itself, the body is a function"
#~ " definition. For explanation of how Tarantool maintains function data, see "
#~ "the reference for the :ref:`box.space._func <box_space-func>` space."
#~ msgstr ""

#~ msgid ""
#~ "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; same as "
#~ "for :ref:`box.schema.func.create(func-name [, {options-without-body}]) "
#~ "<box_schema-func_create>`."
#~ msgstr ""

#~ msgid ""
#~ "``setuid`` = ``true|false`` (default = ``false``) - boolean; same as for "
#~ ":ref:`box.schema.func.create(func-name [, {options-without-body}]) "
#~ "<box_schema-func_create>`."
#~ msgstr ""

#~ msgid ""
#~ "``language`` = 'LUA'|'C' (default = ‘LUA’) - string. same as for "
#~ ":ref:`box.schema.func.create(func-name [, {options-without-body}]) "
#~ "<box_schema-func_create>`."
#~ msgstr ""

#~ msgid ""
#~ "``is_sandboxed`` = ``true|false`` (default = ``false``) - boolean; whether "
#~ "the function should be executed in a sandbox."
#~ msgstr ""

#~ msgid ""
#~ "``is_deterministic`` = ``true|false`` (default = ``false``) - boolean; "
#~ "``true`` means that the function should be deterministic, ``false`` means "
#~ "that the function may or may not be deterministic."
#~ msgstr ""

#~ msgid ""
#~ "``body`` = function definition (default = nil) - string; the function "
#~ "definition."
#~ msgstr ""

#~ msgid ""
#~ "Additional options for SQL = See :ref:`Calling Lua routines from SQL "
#~ "<sql_calling_lua>`."
#~ msgstr ""

#~ msgid ""
#~ "``if_not_exists``, ``setuid``, ``language``, ``is_sandboxed``, "
#~ "``is_deterministic``, ``body``."
#~ msgstr ""

#~ msgid ""
#~ "C functions are imported from .so files, Lua functions can be defined within"
#~ " ``body``. We will only describe Lua functions in this section."
#~ msgstr ""

#~ msgid ""
#~ "A function tuple with a body is \"persistent\" because the tuple is stored "
#~ "in a snapshot and is recoverable if the server restarts. All of the option "
#~ "values described in this section are visible in the :ref:`box.space._func "
#~ "<box_space-func>` system space."
#~ msgstr ""

#~ msgid ""
#~ "If ``is_sandboxed`` is true, then the function will be executed in an "
#~ "isolated environment: any operation that accesses the world outside the "
#~ "sandbox will be forbidden or will have no effect. Therefore, a sandboxed "
#~ "function can only use modules and functions which cannot affect isolation: "
#~ "`assert <https://www.lua.org/manual/5.1/manual.html#pdf-assert>`_, `error "
#~ "<https://www.lua.org/manual/5.1/manual.html#pdf-error>`_, `ipairs "
#~ "<https://www.lua.org/manual/5.1/manual.html#pdf-ipairs>`_, `math.* "
#~ "<https://www.lua.org/manual/5.1/manual.html#5.6>`_, `next "
#~ "<https://www.lua.org/manual/5.1/manual.html#pdf-next>`_, `pairs "
#~ "<https://www.lua.org/manual/5.1/manual.html#pdf-pairs>`_, `pcall "
#~ "<https://www.lua.org/manual/5.1/manual.html#pdf-pcall>`_, `print "
#~ "<https://www.lua.org/manual/5.1/manual.html#pdf-print>`_, `select "
#~ "<https://www.lua.org/manual/5.1/manual.html#pdf-select>`_, `string.* "
#~ "<https://www.lua.org/manual/5.1/manual.html#5.4>`_, `table.* "
#~ "<https://www.lua.org/manual/5.1/manual.html#5.5>`_, `tonumber "
#~ "<https://www.lua.org/manual/5.1/manual.html#pdf-tonumber>`_, `tostring "
#~ "<https://www.lua.org/manual/5.1/manual.html#pdf-tostring>`_, `type "
#~ "<https://www.lua.org/manual/5.1/manual.html#pdf-type>`_, `unpack "
#~ "<https://www.lua.org/manual/5.1/manual.html#pdf-unpack>`_, :ref:`utf8.* "
#~ "<utf8-module>`, `xpcall <https://www.lua.org/manual/5.1/manual.html#pdf-"
#~ "xpcall>`_. Also a sandboxed function cannot refer to global variables -- "
#~ "they will be treated as local variables because the sandbox is established "
#~ "with `setfenv <https://www.lua.org/manual/5.1/manual.html#pdf-setfenv>`_. So"
#~ " a sandboxed function will happen to be stateless and deterministic."
#~ msgstr ""

#~ msgid ""
#~ "If ``is_deterministic`` is true, there is no immediate effect. Tarantool "
#~ "plans to use the is_deterministic value in a future version. A function is "
#~ "deterministic if it always returns the same outputs given the same inputs. "
#~ "It is the function creator's responsibility to ensure that a function is "
#~ "truly deterministic."
#~ msgstr ""

#~ msgid "**Using a persistent Lua function**"
#~ msgstr ""

#~ msgid ""
#~ "After a persistent Lua function is created, it can be found in the "
#~ ":ref:`box.space._func <box_space-func>` system space, and it can be shown "
#~ "with |br| :samp:`box.func.{func-name}` |br| and it can be invoked by any "
#~ "user with :ref:`authorization <authentication-owners_privileges>` to "
#~ "'execute' it. The syntax for invoking is: |br| :samp:`box.func.{func-"
#~ "name}:call([parameters])` |br| or, if the connection is remote, the syntax "
#~ "is as in :ref:`net_box:call() <net_box-call>`."
#~ msgstr ""
