
msgid "Submodule `box.session`"
msgstr "Вложенный модуль `box.session`"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"The ``box.session`` submodule allows querying the session state, writing "
"to a session-specific temporary Lua table, or sending out-of-band "
"messages, or setting up triggers which will fire when a session starts or"
" ends."
msgstr ""
"Вложенный модуль ``box.session`` позволяет делать запросы состояния "
"сессии, вносить записи во временную Lua-таблицу по отдельной сессии, "
"отправлять экстренные сообщения и настраивать триггеры, которые сработают"
" в начале или окончании сессии."

msgid "A *session* is an object associated with each client connection."
msgstr "*Сессия* -- это объект, связанный с каждым подключением клиента."

msgid "Index"
msgstr "Индекс"

msgid "Below is a list of all ``box.session`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``box.session``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Использование"

msgid ":ref:`box.session.id() <box_session-id>`"
msgstr ":ref:`box.session.id() <box_session-id>`"

msgid "Get the current session's ID"
msgstr "Получение идентификатора текущей сессии"

msgid ":ref:`box.session.exists() <box_session-exists>`"
msgstr ":ref:`box.session.exists() <box_session-exists>`"

msgid "Check if a session exists"
msgstr "Проверка наличия сессии"

msgid ":ref:`box.session.peer() <box_session-peer>`"
msgstr ":ref:`box.session.peer() <box_session-peer>`"

msgid "Get the session peer's host address and port"
msgstr "Получение адреса хоста и порта подключенного узла"

msgid ":ref:`box.session.sync() <box_session-sync>`"
msgstr ":ref:`box.session.sync() <box_session-sync>`"

msgid "Get the sync integer constant"
msgstr "Получение целочисленной константы sync"

msgid ":ref:`box.session.user() <box_session-user>`"
msgstr ":ref:`box.session.user() <box_session-user>`"

msgid "Get the current user's name"
msgstr "Получение имени текущего пользователя"

msgid ":ref:`box.session.type() <box_session-type>`"
msgstr ":ref:`box.session.type() <box_session-type>`"

msgid "Get the connection type or cause of action"
msgstr "Получение типа соединения или повода к действию"

msgid ":ref:`box.session.su() <box_session-su>`"
msgstr ":ref:`box.session.su() <box_session-su>`"

msgid "Change the current user"
msgstr "Изменение текущего пользователя"

msgid ":ref:`box.session.uid() <box_session-uid>`"
msgstr ":ref:`box.session.uid() <box_session-uid>`"

msgid "Get the current user's ID"
msgstr "Получение идентификатора текущего пользователя"

msgid ":ref:`box.session.euid() <box_session-euid>`"
msgstr ":ref:`box.session.euid() <box_session-euid>`"

msgid "Get the current effective user's ID"
msgstr "Получение идентификатора текущего действующего пользователя"

msgid ":ref:`box.session.storage <box_session-storage>`"
msgstr ":ref:`box.session.storage <box_session-storage>`"

msgid "Table with session-specific names and values"
msgstr "Таблица с именами и значениями по сессии"

msgid ":ref:`box.session.on_connect() <box_session-on_connect>`"
msgstr ":ref:`box.session.on_connect() <box_session-on_connect>`"

msgid "Define a connect trigger"
msgstr "Определение триггера для подключения"

msgid ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`"
msgstr ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`"

msgid "Define a disconnect trigger"
msgstr "Определение триггера для отключения"

msgid ":ref:`box.session.on_auth() <box_session-on_auth>`"
msgstr ":ref:`box.session.on_auth() <box_session-on_auth>`"

msgid "Define an authentication trigger"
msgstr "Определение триггера для аутентификации"

msgid ":ref:`box.session.push() <box_session-push>`"
msgstr ":ref:`box.session.push() <box_session-push>`"

msgid "Send an out-of-band message"
msgstr "Отправка внеполосного сообщения"

msgid "return"
msgstr "возвращается"

msgid ""
"the unique identifier (ID) for the current session. The result can be 0 "
"or -1 meaning there is no session."
msgstr ""
"уникальный идентификатор (ID) для текущей сессии. Результатом может быть "
"0 или -1, что означает, что сессии нет."

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "number"
msgstr "число"

#, fuzzy
msgid "true if the session exists, false if the session does not exist."
msgstr "1, если сессия есть; 0, если сессии нет."

msgid "boolean"
msgstr ""

msgid ""
"This function works only if there is a peer, that is, if a connection has"
" been made to a separate Tarantool instance."
msgstr ""
"Данная функция сработает только в том случае, если есть подключенная "
"программа, то есть если было выполнено подключение к отдельному "
"экземпляру Tarantool'а."

msgid ""
"The host address and port of the session peer, for example "
"\"127.0.0.1:55457\". If the session exists but there is no connection to "
"a separate instance, the return is null. The command is executed on the "
"server instance, so the \"local name\" is the server instance's host and "
"port, and the \"peer name\" is the client's host and port."
msgstr ""
"Адрес хоста и порт подключенного узла, например \"127.0.0.1:55457\". Если"
" существует сессия, но отсутствует подключение к отдельному экземпляру, "
"вернется null. Команда выполняется на экземпляре сервера,  поэтому "
"\"локальное имя\" -- это хост и порт экземпляра сервера, а \"имя узла\" "
"-- это хост и порт клиента."

msgid "string"
msgstr "string (строка)"

msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr "Возможные ошибки: 'session.peer(): сессия отсутствует'"

msgid ""
"the value of the :code:`sync` integer constant used in the `binary "
"protocol "
"<https://github.com/tarantool/tarantool/blob/2.1/src/box/iproto_constants.h>`_."
" This value becomes invalid when the session is disconnected."
msgstr ""
"значение целочисленной константы :code:`sync`, используемой в `бинарном "
"протоколе "
"<https://github.com/tarantool/tarantool/blob/2.1/src/box/iproto_constants.h>`_."
" Это значение будет недействительным после отключения сессии."

msgid ""
"This function is local for the request, i.e. not global for the session. "
"If the connection behind the session is multiplexed, this function can be"
" safely used inside the request processor."
msgstr ""

msgid "the name of the :ref:`current user <authentication-users>`"
msgstr "имя :ref:`текущего пользователя <authentication-users>`"

msgid "the type of connection or cause of action."
msgstr "тип соединения или повод к действию."

msgid "Possible return values are:"
msgstr "Возможные возвращаемые значения:"

msgid ""
"'binary' if the connection was done via the binary protocol, for example "
"to a target made with :ref:`box.cfg{listen=...} <cfg_basic-listen>`;"
msgstr ""
"'binary' (бинарное), если подключение было выполнено по бинарному "
"протоколу, например, к объекту с помощью :ref:`box.cfg{listen=...} "
"<cfg_basic-listen>`;"

msgid ""
"'console' if the connection was done via the administrative console, for "
"example to a target made with :ref:`console.listen <console-listen>`;"
msgstr ""
"'console' (консоль), если подключение было выполнено по административной "
"консоли, например, к объекту с помощью :ref:`console.listen <console-"
"listen>`;"

msgid ""
"'repl' if the connection was done directly, for example when :ref:`using "
"Tarantool as a client <admin-using_tarantool_as_a_client>`;"
msgstr ""
"'repl' (репликация), если подключение было выполнено напрямую, например, "
"при :ref:`использовании Tarantool'а в качестве клиента <admin-"
"using_tarantool_as_a_client>`;"

msgid ""
"'applier' if the action is due to :ref:`replication <replication>`, "
"regardless of how the connection was done;"
msgstr ""
"'applier' (наложение), если действие происходит по причине "
":ref:`репликации <replication>`, независимо от типа подключения;"

msgid ""
"'background' if the action is in a :ref:`background fiber <fiber-"
"module>`, regardless of whether the Tarantool server was :ref:`started in"
" the background <cfg_basic-background>`."
msgstr ""
"'background' (в фоне), если действие происходит в :ref:`фоновом файбере "
"<fiber-module>`, независимо от того, был ли Tarantool :ref:`запущен в "
"фоновом режиме <cfg_basic-background>`."

msgid ""
"``box.session.type()`` is useful for an :ref:`on_replace() <box_space-"
"on_replace>` trigger on a replica -- the value will be 'applier' if and "
"only if the trigger was activated because of a request that was done on "
"the master."
msgstr ""
"``box.session.type()`` используется для триггера при замене "
":ref:`on_replace() <box_space-on_replace>` на реплике -- значение будет "
"'applier' только в том случае, если триггер был активирован по причине "
"запроса, выполненного на мастере."

msgid ""
"Change Tarantool's :ref:`current user <authentication-users>` -- this is "
"analogous to the Unix command ``su``."
msgstr ""
"Изменение :ref:`текущего пользователя <authentication-users>` Tarantool'а"
" -- аналогично Unix-команде ``su``."

msgid ""
"Or, if function-to-execute is specified, change Tarantool's :ref:`current"
" user <authentication-users>` temporarily while executing the function --"
" this is analogous to the Unix command ``sudo``."
msgstr ""
"Или, если указана выполняемая функция (function-to-execute), временное "
"изменение :ref:`текущего пользователя <authentication-users>` Tarantool'а"
" во время выполнения функции – аналогично Unix-команде ``sudo``."

msgid "Parameters"
msgstr "Параметры"

msgid "name of a target user"
msgstr "целевое имя пользователя"

msgid ""
"name of a function, or definition of a function. Additional parameters "
"may be passed to ``box.session.su``, they will be interpreted as "
"parameters of function-to-execute."
msgstr ""
"имя функции или определение функции. Дополнительные параметры могут "
"передаваться в ``box.session.su``, они будут интерпретироваться как "
"параметры выполняемой функции."

msgid "**Example**"
msgstr "**Пример**"

msgid ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."

msgid "the user ID of the :ref:`current user <authentication-users>`."
msgstr "ID :ref:`текущего пользователя <authentication-users>`."

msgid ""
"Every user has a unique name (seen with :ref:`box.session.user() "
"<box_session-user>`) and a unique ID (seen with ``box.session.uid()``). "
"The values are stored together in the ``_user`` space."
msgstr ""
"У каждого пользователя есть уникальное имя (узнать с помощью "
":ref:`box.session.user() <box_session-user>`) и уникальный идентификатор "
"(узнать с помощью ``box.session.uid()``). Значения хранятся вместе в "
"спейсе ``_user``."

msgid "the effective user ID of the :ref:`current user <authentication-users>`."
msgstr "рабочий ID :ref:`текущего пользователя <authentication-users>`."

msgid ""
"This is the same as :ref:`box.session.uid() <box_session-uid>`, except in"
" two cases:"
msgstr ""
"Аналогично :ref:`box.session.uid() <box_session-uid>`, за исключением "
"двух случаев:"

msgid ""
"The first case: if the call to ``box.session.euid()`` is within a "
"function invoked by :ref:`box.session.su(user-name, function-to-execute) "
"<box_session-su>` -- in that case, ``box.session.euid()`` returns the ID "
"of the changed user (the user who is specified by the ``user-name`` "
"parameter of the ``su`` function)  but ``box.session.uid()`` returns the "
"ID of the original user (the user who is calling the ``su`` function)."
msgstr ""
"Первый случай: если вызов ``box.session.euid()`` выполняется в рамках "
"функции, вызываемой по :ref:`box.session.su(user-name, function-to-"
"execute) <box_session-su>` -- в таком случае ``box.session.euid()`` "
"вернет измененный идентификатор пользователя (пользователь, который "
"указан в параметре ``user-name`` функции ``su``), но "
"``box.session.uid()`` вернет идентификатор оригинального пользователя "
"(пользователя, который вызывает функцию ``su``)."

msgid ""
"The second case: if the call to ``box.session.euid()`` is within a "
"function specified with :ref:`box.schema.func.create(function-name, "
"{setuid= true}) <box_schema-func_create>` and the binary protocol is in "
"use -- in that case, ``box.session.euid()`` returns the ID of the user "
"who created \"function-name\" but ``box.session.uid()`` returns the ID of"
" the the user who is calling \"function-name\"."
msgstr ""
"Второй случай: если вызов ``box.session.euid()`` выполняется в рамках "
"функции по :ref:`box.schema.func.create(function-name, {setuid= true}) "
"<box_schema-func_create>`, и используется бинарный протокол -- в таком "
"случае ``box.session.euid()`` вернет идентификатор пользователя, который "
"создал функцию \"function-name\", а ``box.session.uid()`` вернет "
"идентификатор пользователя, который вызывает эту функцию \"function-"
"name\"."

msgid ""
"tarantool> box.session.su('admin')\n"
"---\n"
"...\n"
"tarantool> box.session.uid(), box.session.euid()\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"tarantool> function f() return {box.session.uid(),box.session.euid()} end"
"\n"
"---\n"
"...\n"
"tarantool> box.session.su('guest', f)\n"
"---\n"
"- - 1\n"
"  - 0\n"
"..."
msgstr ""
"tarantool> box.session.su('admin')\n"
"---\n"
"...\n"
"tarantool> box.session.uid(), box.session.euid()\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"tarantool> function f() return {box.session.uid(),box.session.euid()} end"
"\n"
"---\n"
"...\n"
"tarantool> box.session.su('guest', f)\n"
"---\n"
"- - 1\n"
"  - 0\n"
"..."

msgid ""
"A Lua table that can hold arbitrary unordered session-specific names and "
"values, which will last until the session ends. For example, this table "
"could be useful to store current tasks when working with a `Tarantool "
"queue manager <https://github.com/tarantool/queue>`_."
msgstr ""
"Lua-таблица с произвольными неупорядоченными именами и значениями по "
"сессии, которая хранится до конца сессии. Например, эту таблицу можно "
"использовать для хранения текущих задач при работе с `очередями сообщений"
" в Tarantool'е <https://github.com/tarantool/queue>`_."

msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the "
"eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the "
"eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."

msgid ""
"Define a trigger for execution when a new session is created due to an "
"event such as :ref:`console.connect <console-connect>`. The trigger "
"function will be the first thing executed after a new session is created."
" If the trigger execution fails and raises an error, the error is sent to"
" the client and the connection is closed."
msgstr ""
"Определение исполняемого триггера во время создания новой сессии при "
"подключению по консоли :ref:`console.connect <console-connect>`. Функция "
"с триггером будет первой исполняемой функцией после создания сессии. Если"
" триггер не выполняется и выдает ошибку, эта ошибка отправляется на "
"клиент, и подключение разрывается."

msgid "function which will become the trigger function"
msgstr "функция, в которой будет триггер"

msgid "existing trigger function which will be replaced by trigger-function"
msgstr "существующая функция с триггером, которую заменит новая"

msgid "nil or function pointer"
msgstr "nil или указатель функции"

msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger "
"is deleted."
msgstr ""
"Если указаны параметры (nil, old-trigger-function), старый триггер будет "
"удален."

msgid ""
"If both parameters are omitted, then the response is a list of existing "
"trigger functions."
msgstr ""
"Если не указан ни один параметр, ответом будет список существующих "
"функций с триггером."

msgid ""
"Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""
"Подробная информация о характеристиках триггера находится в разделе "
":ref:`Триггеры <triggers-box_triggers>`."

msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"

msgid ""
"If a trigger always results in an error, it may become impossible to "
"connect to a server to reset it."
msgstr ""
"Если триггер всегда приводит к ошибке, подключение к серверу для его "
"переустановки может стать невозможным."

msgid ""
"Define a trigger for execution after a client has disconnected. If the "
"trigger function causes an error, the error is logged but otherwise is "
"ignored. The trigger is invoked while the session associated with the "
"client still exists and can access session properties, such as "
":ref:`box.session.id() <box_session-id>`."
msgstr ""
"Определение исполняемого триггера после отключения клиента. Если функция "
"с триггером вызывает ошибку, то ошибка записывается в журнал, в противном"
" случае записей не будет. Триггер вызывается во время сессии клиента и "
"может получить доступ к свойствам сессии, как :ref:`box.session.id() "
"<box_session-id>`."

msgid ""
"Since version 1.10, the trigger function is invoked immediately after the"
" disconnect, even if requests that were made during the session have not "
"finished."
msgstr ""
"Начиная с версии 1.10, функция с триггером вызывается сразу же после "
"прерывания сессии, даже если сделанные запросы не были выполнены."

msgid "**Example #1**"
msgstr "**Пример №1**"

msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"

msgid "**Example #2**"
msgstr "**Пример №2**"

msgid ""
"After the following series of requests, a Tarantool instance will write a"
" message using the :ref:`log <log-module>` module whenever any user "
"connects or disconnects."
msgstr ""
"После следующей серии запросов экземпляр Tarantool'а запишет сообщение с "
"помощью модуля :ref:`log <log-module>` при подключении или отключении "
"любого пользователя."

msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"

msgid "Here is what might appear in the log file in a typical installation:"
msgstr "Вот что может быть записано в файл журнала при обычной установке:"

msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"

msgid ""
"Define a trigger for execution during :ref:`authentication "
"<authentication-users>`."
msgstr ""
"Определение триггера, используемого во время :ref:`аутентификации "
"<authentication-users>`."

msgid "The ``on_auth`` trigger function is invoked in these circumstances:"
msgstr ""
"Вызов функции ``on_auth`` с триггером происходит в следующих "
"обстоятельствах:"

msgid ""
"The :ref:`console.connect <console-connect>` function includes an "
"authentication check for all users except 'guest'. For this case, the "
"``on_auth`` trigger function is invoked after the ``on_connect`` trigger "
"function, if and only if the connection has succeeded so far."
msgstr ""
"Функция :ref:`console.connect <console-connect>` включает в себя проверку"
" аутентификации всех пользователей, кроме 'guest'. Вызов функции "
"``on_auth`` с триггером происходит после триггера ``on_connect`` только в"
" том случае, если подключение было успешным."

msgid ""
"The :ref:`binary protocol <admin-security>` has a separate "
":ref:`authentication packet <box_protocol-authentication>`. For this "
"case, connection and authentication are considered to be separate steps."
msgstr ""
"В :ref:`бинарном протоколе <admin-security>` есть отдельный :ref:`пакет "
"для аутентификации <box_protocol-authentication>`. В этом случае "
"подключение и аутентификация считаются отдельными действиям."

msgid ""
"Unlike other trigger types, ``on_auth`` trigger functions are invoked "
"**before** the event. Therefore a trigger function like :code:`function "
"auth_function () v = box.session.user(); end` will set :code:`v` to "
"\"guest\", the user name before the authentication is done. To get the "
"user name **after** the authentication is done, use the special syntax: "
":code:`function auth_function (user_name) v = user_name; end`"
msgstr ""
"В отличие от других типов триггеров, вызов функций с триггером "
"``on_auth`` происходит **до** события. Таким образом, функция с таким "
"триггером, как :code:`function auth_function () v = box.session.user(); "
"end`, определит :code:`v` как \"guest\", то есть имя пользователя до "
"проведения аутентификации. Чтобы получить имя пользователя **после** "
"проведения аутентификации, используйте специальный синтаксис: "
":code:`function auth_function (user_name) v = user_name; end`"

msgid ""
"If the trigger fails by raising an error, the error is sent to the client"
" and the connection is closed."
msgstr ""
"Если триггер не выполняется и выдает ошибку, эта ошибка отправляется на "
"клиент, и подключение разрывается."

msgid "**Example 1**"
msgstr "**Пример 1**"

msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"

msgid "**Example 2**"
msgstr "**Пример 2**"

msgid "This is a more complex example, with two server instances."
msgstr "Более сложный пример с двумя экземплярами сервера."

msgid ""
"The first server instance listens on port 3301; its default user name is "
"'admin'. There are three ``on_auth`` triggers:"
msgstr ""
"Первый экземпляр сервера настроен на прослушивание по порту 3301; имя "
"пользователя по умолчанию -- 'admin'. Есть три триггера ``on_auth``:"

msgid ""
"The first trigger has a function with no arguments, it can only look at "
"``box.session.user()``."
msgstr ""
"В первом триггере есть функция без аргументов, которая только смотрит на "
"``box.session.user()``."

msgid ""
"The second trigger has a function with a ``user_name`` argument, it can "
"look at both of: ``box.session.user()`` and ``user_name``."
msgstr ""
"Во втором триггере есть функция с аргументом ``user_name``, которая может"
" смотреть на ``box.session.user()`` и ``user_name``."

msgid ""
"The third trigger has a function with a ``user_name`` argument and a "
"``status`` argument, it can look at all three of: ``box.session.user()`` "
"and ``user_name`` and ``status``."
msgstr ""
"В третьем триггере есть функция с аргументом ``user_name`` и аргументом "
"``status``, которая может смотреть на ``box.session.user()`` и "
"``user_name``, и``status``."

msgid ""
"The second server instance will connect with :ref:`console.connect "
"<console-connect>`, and then will cause a display of the variables that "
"were set by the trigger functions."
msgstr ""
"Второй экземпляр сервера подключится по :ref:`console.connect <console-"
"connect>`, а затем отобразит переменные, определенные функциями с "
"триггером."

msgid ""
"-- On the first server instance, which listens on port 3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"function function3(user_name, status)\n"
"  print('function 3, box.session.user()='..box.session.user())\n"
"  print('function 3, user_name='..user_name)\n"
"  if status == true then\n"
"    print('function 3, status = true, authorization succeeded')\n"
"    end\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.session.on_auth(function3)\n"
"box.schema.user.passwd('admin')"
msgstr ""
"-- На первом экземпляре сервера, прослушивание на котором настроено на "
"порт 3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"function function3(user_name, status)\n"
"  print('function 3, box.session.user()='..box.session.user())\n"
"  print('function 3, user_name='..user_name)\n"
"  if status == true then\n"
"    print('function 3, status = true, authorization succeeded')\n"
"    end\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.session.on_auth(function3)\n"
"box.schema.user.passwd('admin')"

msgid ""
"-- On the second server instance, that connects to port 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"
msgstr ""
"-- На втором экземпляре сервера, который подключается по порту 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"

msgid "The result looks like this:"
msgstr "Теперь результат выглядит следующим образом:"

msgid ""
"function 3, box.session.user()=guest\n"
"function 3, user_name=admin\n"
"function 3, status = true, authorization succeeded\n"
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"
msgstr ""
"function 3, box.session.user()=guest\n"
"function 3, user_name=admin\n"
"function 3, status = true, authorization succeeded\n"
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"

msgid ""
"Generate an out-of-band message. By \"out-of-band\" we mean an extra "
"message which supplements what is passed in a network via the usual "
"channels. Although ``box.session.push()`` can be called at any time, in "
"practice it is used with networks that are set up with :ref:`module "
"net.box <net_box-module>`, and it is invoked by the server (on the "
"\"remote database system\" to use our terminology for net.box), and the "
"client has options for getting such messages."
msgstr ""
"Создание внеполосного сообщения. Под внеполосным мы понимаем "
"дополнительное сообщение, которое дополняет то, что отправляется в сети "
"по обычным каналам. Хотя ``box.session. push()`` можно вызвать в любое "
"время, на практике эта функция используется в сетях, настроенных с "
"помощью :ref:`модуля net.box <net_box-module>`, и вызывается сервером (на"
" \"удаленной системе с базой данных\", если использовать нашу "
"терминологию для net.box), а у клиента есть возможность принимать такие "
"сообщения."

msgid "This function returns an error if the session is disconnected."
msgstr "Функция возвращает ошибку, если сессия была прервана."

msgid "what to send"
msgstr "что отправляется"

msgid ""
"an optional argument to indicate what the session is, as taken from an "
"earlier call to :ref:`box_session:sync() <box_session-sync>`. If it is "
"omitted, the default is the current ``box.session.sync()`` value."
msgstr ""
"необязательный аргумент, который показывает информацию о сессии, "
"полученную из предшествующего вызова :ref:`box_session:sync() "
"<box_session-sync>`. Если не указать, по умолчанию используется текущее "
"значение ``box.session.sync()``."

msgid "{nil, error} or true:"
msgstr "{nil, ошибка} или true:"

msgid ""
"If the result is an error, then the first part of the return is ``nil`` "
"and the second part is the error object."
msgstr ""
"Если результатом будет ошибка, то вернется ``nil`` вместе с объектом "
"ошибки."

msgid ""
"If the result is not an error, then the return is the boolean value "
"``true``."
msgstr ""
"Если результатом будет не ошибка, то вернется логическое значение "
"``true`` (правда)."

msgid ""
"When the return is ``true``, the message has gone to the network buffer "
"as a :ref:`packet <box_protocol-iproto_protocol>` with the code "
"IPROTO_CHUNK (0x80)."
msgstr ""
"Если возвращается ``true``, сообщение отправлено в буфер сети в виде "
":ref:`пакета <box_protocol-iproto_protocol>` с кодом IPROTO_CHUNK (0x80)."

msgid ""
"The server's sole job is to call ``box.session.push()``, there is no "
"automatic mechanism for showing that the message was received."
msgstr ""
"Единственная задача сервера -- вызвать ``box.session.push()``, поскольку "
"нет автоматического механизма, который показал бы, что сообщение "
"получено."

msgid ""
"The client's job is to check for such messages after it sends something "
"to the server. The major client methods -- :ref:`conn:call <net_box-"
"call>`, :ref:`conn:eval <net_box-eval>`, :ref:`conn:select <conn-"
"select>`, :ref:`conn:insert <conn-insert>`, :ref:`conn:replace <conn-"
"replace>`, :ref:`conn:update <conn-update>`, :ref:`conn:upsert <conn-"
"upsert>`, :ref:`delete <conn-delete>` -- may cause the server to send a "
"message."
msgstr ""
"Задача клиента заключается в том, чтобы проверять наличие таких сообщений"
" после отправки чего-либо на сервер. Основные клиентские методы -- "
":ref:`conn:call <net_box-call>`, :ref:`conn:eval <net_box-eval>`, "
":ref:`conn:select <conn-select>`, :ref:`conn:insert <conn-insert>`, "
":ref:`conn:replace <conn-replace>`, :ref:`conn:update <conn-update>`, "
":ref:`conn:upsert <conn-upsert>`, :ref:`delete <conn-delete>` -- могут "
"привести к отправке такого сообщения сервером."

msgid ""
"Situation 1: when the client calls synchronously with the default "
"``{async=false}`` option. There are two optional additional options: "
":samp:`on_push={function-name}`, and :samp:`on_push_ctx={function-"
"argument}`. When the client receives an out-of-band message for the "
"session, it invokes \"function-name(function-argument)\". For example, "
"with options ``{on_push=table.insert, on_push_ctx=messages}``, the client"
" will insert whatever it receives into a table named 'messages'."
msgstr ""
"Ситуация 1: когда клиент делает синхронный вызов со значением параметра "
"``{async=false}`` по умолчанию. Есть два необязательных дополнительных "
"параметра: :samp:`on_push={function-name}` и :samp:`on_push_ctx"
"={function-argument}`. Когда клиент получает внеполосное сообщение в "
"сессии, он вызывает \"имя-функции(аргумент-функции)\". Например, с такими"
" значениями параметров: ``{on_push=table.insert, on_push_ctx=messages}`` "
"-- клиент произведет вставку полученных данных в таблицу под названием "
"'messages'."

msgid ""
"Situation 2: when the client calls asynchronously with the non-default "
"``{async=true}`` option. Here ``on_push`` and ``on_push_ctx`` are not "
"allowed, but the messages can be seen by calling ``pairs()`` in a loop."
msgstr ""
"Ситуация 2: когда клиент делает асинхронный вызов с измененным значением "
"параметра ``{async=true}``. Здесь не разрешены ``on_push`` и "
"``on_push_ctx``, но сообщения можно увидеть путем вызова ``pairs()`` в "
"цикле."

msgid ""
"Situation 2 complication: ``pairs()`` is subject to timeout. So there is "
"an optional argument = timeout per iteration. If timeout occurs before "
"there is a new message or a final response, there is an error return. To "
"check for an error one can use the first loop parameter (if the loop "
"starts with \"for i, message in future:pairs()\" then the first loop "
"parameter is i). If it is ``box.NULL`` then the second parameter (in our "
"example, \"message\") is the error object."
msgstr ""
"Осложненная ситуация 2: ``pairs()`` зависит от времени ожидания. Таким "
"образом, есть необязательный аргумент -- время ожидания для итерации. "
"Если время ожидания истечет до получения нового сообщения или "
"окончательного ответа, вернется ошибка. Чтобы проверить наличие ошибки, "
"можно использовать первый параметр в цикле (если цикл начинается с \"for "
"i, message in future:pairs()\", то первым параметром в цикле будет i). "
"Если это будет ``box.NULL``, то второй параметр (в нашем примере "
"\"message\") -- это объект ошибки."

msgid ""
"-- Make two shells. On Shell#1 set up a \"server\", and\n"
"-- in it have a function that includes box.session.push:\n"
"box.cfg{listen=3301}\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"x = 0\n"
"fiber = require('fiber')\n"
"function server_function() x=x+1; fiber.sleep(1); box.session.push(x); "
"end\n"
"\n"
"-- On Shell#2 connect to this server as a \"client\" that\n"
"-- can handle Lua (such as another Tarantool server operating\n"
"-- as a client), and initialize a table where we'll get messages:\n"
"net_box = require('net.box')\n"
"conn = net_box.connect(3301)\n"
"messages_from_server = {}\n"
"\n"
"-- On Shell#2 remotely call the server function and receive\n"
"-- a SYNCHRONOUS out-of-band message:\n"
"conn:call('server_function', {},\n"
"          {is_async = false,\n"
"           on_push = table.insert,\n"
"           on_push_ctx = messages_from_server})\n"
"messages_from_server\n"
"-- After a 1-second pause that is caused by the fiber.sleep()\n"
"-- request inside server_function, the result in the\n"
"--  messages_from_server table will be: 1. Like this:\n"
"-- tarantool> messages_from_server\n"
"-- ---\n"
"-- - - 1\n"
"-- ...\n"
"-- Good. That shows that box.session.push(x) worked,\n"
"-- because we know that x was 1.\n"
"\n"
"-- On Shell#2 remotely call the same server function and\n"
"-- get an ASYNCHRONOUS out-of-band message. For this we cannot\n"
"-- use on_push and on_push_ctx options, but we can use pairs():\n"
"future = conn:call('server_function', {}, {is_async = true})\n"
"messages = {}\n"
"keys = {}\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"future:wait_result(1000)\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"-- There is no pause because conn:call does not wait for\n"
"-- server_function to finish. The first time that we go through\n"
"-- the pairs() loop, we see the messages table is empty. Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - []\n"
"-- ...\n"
"-- That is okay because the server hasn't yet called\n"
"-- box.session.push(). The second time that we go through\n"
"-- the pairs() loop, we see the value of x at the time of\n"
"-- the second call to box.session.push(). Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - &0 []\n"
"--   - 2\n"
"--   - *0\n"
"-- ...\n"
"-- Good. That shows that the message was asynchronous, and\n"
"-- that box.session.push() did its job."
msgstr ""
"-- Создайте две оболочки. В оболочке №1 настройте сервер, а\n"
"-- в нем функцию, которая содержит box.session.push:\n"
"box.cfg{listen=3301}\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"x = 0\n"
"fiber = require('fiber')\n"
"function server_function() x=x+1; fiber.sleep(1); box.session.push(x); "
"end\n"
"\n"
"-- В оболочке №2 подключитесь к серверу в качестве клиента, который\n"
"-- поддерживает Lua (как второй Tarantool-сервер, работающий\n"
"-- в качестве клиента), и создайте таблицу, в которую мы будем получать "
"сообщения:\n"
"net_box = require('net.box')\n"
"conn = net_box.connect(3301)\n"
"messages_from_server = {}\n"
"\n"
"-- В оболочке №2 удаленно вызовите функцию и получите\n"
"-- СИНХРОННОЕ внеполосное сообщение:\n"
"conn:call('server_function', {},\n"
"          {is_async = false,\n"
"           on_push = table.insert,\n"
"           on_push_ctx = messages_from_server})\n"
"messages_from_server\n"
"-- Через секунду, во время которой происходит запрос fiber.sleep()\n"
"-- в server_function, результат в таблице\n"
"--  messages_from_server будет следующим: 1. Проверим:\n"
"-- tarantool> messages_from_server\n"
"-- ---\n"
"-- - - 1\n"
"-- ...\n"
"-- Хорошо. Это означает, что box.session.push(x) сработала,\n"
"-- поскольку мы знаем, что x был 1.\n"
"\n"
"-- В оболочке №2 удаленно вызовите ту же самую функцию\n"
"-- для получения АСИНХРОННОГО внеполосного сообщения. При этом мы не "
"можем\n"
"-- использовать параметры on_push и on_push_ctx, но можем использовать "
"pairs():\n"
"future = conn:call('server_function', {}, {is_async = true})\n"
"messages = {}\n"
"keys = {}\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"future:wait_result(1000)\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"-- Задержки нет, поскольку conn:call не ждет\n"
"-- окончания вызова функции server_function. После первой итерации\n"
"-- цикла pairs(), видим, что таблица пуста. Это выглядит так:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - []\n"
"-- ...\n"
"-- Это нормально, поскольку сервер еще не вызвал\n"
"-- box.session.push(). При второй итерации\n"
"-- цикла pairs(), видим значение x во время\n"
"-- второго вызова box.session.push(). Так:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - &0 []\n"
"--   - 2\n"
"--   - *0\n"
"-- ...\n"
"-- Хорошо. Это означает, что сообщение было асинхронным, и\n"
"-- box.session.push() выполнила свою задачу."

#~ msgid ":ref:`box.session.on_access_denied() <box_session-on_access_denied>`"
#~ msgstr ":ref:`box.session.on_access_denied() <box_session-on_access_denied>`"

#~ msgid "Define a trigger to report restricted actions"
#~ msgstr "Определение триггера для регистрации запрещенных действий"

#~ msgid ""
#~ "Define a trigger for reacting to "
#~ "user's attempts to execute actions that"
#~ " are not within the user's "
#~ "privileges."
#~ msgstr ""
#~ "Определение триггера для ответа на "
#~ "попытки пользователя выполнить неразрешенные "
#~ "ему действия."

#~ msgid ""
#~ "If the parameters are `(nil, old-"
#~ "trigger-function)`, then the old trigger"
#~ " is deleted."
#~ msgstr ""
#~ "Если указаны параметры `(nil, old-"
#~ "trigger-function)`, старый триггер будет "
#~ "удален."

#~ msgid "For example, server administrator can log restricted actions like this:"
#~ msgstr ""
#~ "Например, администратор сервера может "
#~ "регистрировать запрещенные действия:"

#~ msgid ""
#~ "tarantool> function on_access_denied(op, type, name)\n"
#~ "         > log.warn('User %s tried to"
#~ " %s %s %s without required "
#~ "privileges', box.session.user(), op, type, "
#~ "name)\n"
#~ "         > end\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.session.on_access_denied(on_access_denied)\n"
#~ "---\n"
#~ "- 'function: 0x011b41af38'\n"
#~ "...\n"
#~ "tarantool> function test() print('you shall not pass') end\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.schema.func.create('test')\n"
#~ "---\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> function on_access_denied(op, type, name)\n"
#~ "         > log.warn('User %s tried to"
#~ " %s %s %s without required "
#~ "privileges', box.session.user(), op, type, "
#~ "name)\n"
#~ "         > end\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.session.on_access_denied(on_access_denied)\n"
#~ "---\n"
#~ "- 'function: 0x011b41af38'\n"
#~ "...\n"
#~ "tarantool> function test() print('you shall not pass') end\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.schema.func.create('test')\n"
#~ "---\n"
#~ "..."

#~ msgid ""
#~ "Then, when some user without required"
#~ " privileges tries to call ``test()`` "
#~ "and gets the error, the server "
#~ "will execute this trigger and write "
#~ "to log **\"User *user_name* tried to "
#~ "Execute function test without required "
#~ "privileges\"**"
#~ msgstr ""
#~ "И когда какой-нибудь пользователь без "
#~ "соответствующих прав попытается вызвать "
#~ "``test()``` и получит ошибку, сервер "
#~ "выполнит этот триггер и запишет в "
#~ "журнал **\"User *имя_пользователя* tried to"
#~ " Execute function test without required "
#~ "privileges\"** (Пользователь *имя_пользователя* "
#~ "пытался выполнить функцию текст без "
#~ "соответствующих прав)."
