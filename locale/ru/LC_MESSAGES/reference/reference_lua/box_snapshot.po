
msgid "Function box.snapshot"
msgstr "Функция box.snapshot"

msgid "**Memtx**"
msgstr "**Memtx**"

msgid ""
"Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first"
" enters the delayed garbage collection mode for all data. In this mode, the "
":ref:`Tarantool garbage collector <cfg_checkpoint_daemon-garbage-collector>`"
" will not remove files which were created before the snapshot started, it "
"will not remove them until the snapshot has finished. To preserve "
"consistency of the primary key, used to iterate over tuples, a copy-on-write"
" technique is employed. If the master process changes part of a primary key,"
" the corresponding process page is split, and the snapshot process obtains "
"an old copy of the page. In effect, the snapshot process uses multi-version "
"concurrency control in order to avoid copying changes which are superseded "
"while it is running."
msgstr ""
"Создает снимок всех данных и сохраняет его в :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`:samp:`/{<latest-lsn>}.snap`. Чтобы сделать снимок, сначала "
"Tarantool входит в режим отложенной сборки мусора по всем данным. В этом "
"режиме :ref:`сборщик мусора Tarantool <cfg_checkpoint_daemon-garbage-"
"collector>` не будет удалять файлы, созданные до начала создания снимка, до "
"тех пор, пока не будет завершено создание снимка. Чтобы сохранить "
"консистентность первичного ключа, используемого для итерации по кортежам, "
"применяется технология копирования при записи. Если главный процесс изменяет"
" часть первичного ключа, страница соответствующего процесса разделяется, и "
"процесс создания снимка получает старую копию страницы. В результате, "
"процесс создания снимка использует многоверсионную параллельную обработку "
"данных, чтобы не скопировать изменения в данных, появившихся уже после "
"начала создания снимка."

msgid ""
"Since a snapshot is written sequentially, you can expect a very high write "
"performance (averaging to 80MB/second on modern disks), which means an "
"average database instance gets saved in a matter of minutes. You may "
"restrict the speed by changing :ref:`snap_io_rate_limit "
"<cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""
"Поскольку снимок создается последовательно, можно ожидать высокую скорость "
"записи (в среднем до 80 МБ/секунду на современных дисках), что означает "
"сохранение данных усредненного экземпляра базы данных за несколько минут. "
"Пользователи могут ограничить скорость записи, изменив значение "
":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`."

msgid ""
"As long as there are any changes to the parent index memory through "
"concurrent updates, there are going to be page splits, and therefore you "
"need to have some extra free memory to run this command. 10% of "
":ref:`memtx_memory <cfg_storage-memtx_memory>` is, on average, sufficient. "
"This statement waits until a snapshot is taken and returns operation result."
msgstr ""
"При условии, что происходят изменения в родительском индексе в ходе "
"многопоточного обновления данных, будет происходить и расщепление страниц, "
"поэтому возникнет необходимость в наличии дополнительной свободной памяти "
"для выполнения этой команды. В среднем, будет достаточно 10% от "
":ref:`memtx_memory <cfg_storage-memtx_memory>`. Оператор подождет окончания "
"создания снимка и вернет результат операции."

msgid ""
"**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process "
"caused a fork, which could cause occasional latency spikes. Starting with "
"Tarantool version 1.6.6, the snapshot process creates a consistent read view"
" and this view is written to the snapshot file by a separate thread (the "
"\"Write Ahead Log\" thread)."
msgstr ""
"**Обновление:** До версии 1.6.6 Tarantool процесс создания снимка вызывал "
"клонирование системного процесса (fork), что могло привести к скачкам "
"задержки отклика. Начиная с версии 1.6.6 Tarantool, процесс создания "
"снимка создает вид постоянного просмотра, который и записывается в файл "
"снимка с помощью отдельного потока (поток упреждающей записи в журнал)."

msgid ""
"Although ``box.snapshot()`` does not cause a fork, there is a separate fiber"
" which may produce snapshots at regular intervals -- see the discussion of "
"the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""
"Хотя ``box.snapshot()`` не создает ответвление, есть отдельный файбер, "
"который может создавать снимки на регулярной основе -- см. обсуждение "
":ref:`демона создания контрольных точек <book_cfg_checkpoint_daemon>`."

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."

msgid ""
"Taking a snapshot does not cause the server to start a new write-ahead log. "
"Once a snapshot is taken, old WALs can be deleted as long as all replicated "
"data is up to date. But the WAL which was current at the time "
"``box.snapshot()`` started must be kept for recovery, since it still "
"contains log records written after the start of ``box.snapshot()``."
msgstr ""
"Создание снимка не приводит к записи нового журнала упреждающей записи на "
"сервере. После создания снимка старые WAL-файлы можно удалить, если все "
"реплицируемые данные актуальны. Но WAL-файл на момент начала работы "
"``box.snapshot()`` следует сохранить на случай восстановления, поскольку он "
"содержит записи журнала после начала работы ``box.snapshot()``."

msgid ""
"An alternative way to save a snapshot is to send a SIGUSR1 signal to the "
"instance. While this approach could be handy, it is not recommended for use "
"in automation: a signal provides no way to find out whether the snapshot was"
" taken successfully or not."
msgstr ""
"Другим способом сохранения снимка будет отправка сигнала SIGUSR1 процессу. "
"Хотя это может быть удобно, не рекомендуется использовать такой метод в "
"автоматическом процессе: сигнал не дает возможность проверить, был ли "
"корректно сделан снимок."

msgid "**Vinyl**"
msgstr "**Vinyl**"

msgid ""
"In vinyl, inserted data is stacked in memory until the limit, set in the "
":ref:`vinyl_memory <cfg_storage-vinyl_memory>` parameter, is reached. Then "
"vinyl automatically dumps it to the disc. ``box.snapshot()`` forces this "
"dump in order to have the ability to recover from this checkpoint. The "
"snapshot files are stored in :samp:`{space_id}/{index_id}/*.run`. Thus, "
"strictly all the data that was written at the time of LSN of the checkpoint "
"is in the ``*.run`` files on the disk, and all operations that happened "
"after the checkpoint will be written in the ``*.xlog``. All dump files "
"created by ``box.snapshot()`` are consistent and have the same LSN as "
"checkpoint."
msgstr ""
"При использовании vinyl'a вставляемые данные складываются в память до тех "
"пор, пока не будет достигнут предел, установленный в параметре "
":ref:`vinyl_memory <cfg_storage-vinyl_memory>`. Затем vinyl автоматически "
"делает дамп на диск. ``box.snapshot()`` форсирует создание дампа, чтобы "
"иметь возможность восстановить данные из этой контрольной точки. Файлы "
"снимков хранятся в :samp:`{space_id}/{index_id}/*.run`. Таким образом, "
"строго все данные, которые были записаны во время LSN контрольной точки, "
"находятся в `*.run` файлах на диске, а все операции, которые происходили "
"после контрольной точки, будут записаны в ``*.xlog``. Все файлы дампа, "
"созданные функцией ``box.snapshot()``, консистентны и имеют тот же LSN, что "
"и контрольная точка."

msgid ""
"At the checkpoint vinyl also rotates the metadata log ``*.vylog``, "
"containing data manipulation operations like \"create file\" and \"delete "
"file\". It goes through the log, removes duplicating operations from the "
"memory and creates a new ``*.vylog`` file, giving it the name according to "
"the :ref:`vclock <box_introspection-box_info>` of the new checkpoint, with "
"\"create\" operations only. This procedure cleans ``*.vylog`` and is useful "
"for recovery because the name of the log is the same as the checkpoint "
"signature."
msgstr ""
"На контрольной точке vinyl также пересматривает журнал метаданных "
"``*.vylog``, содержащий операции манипуляции с данными, такие как \"создать "
"файл\" и \"удалить файл\". Он проходит по логу, удаляет дублирующие операции"
" из памяти и создает новый файл ``*.vylog``, присваивая ему имя в "
"соответствии с :ref:`vclock <box_introspection-box_info>` новой контрольной "
"точки, оставляя только операци создания. Эта процедура очищает ``*.vylog`` и"
" полезна для восстановления, так как имя лога совпадает с именем подписи "
"контрольной точки."
