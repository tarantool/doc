
msgid "Function `box.snapshot`"
msgstr "Функция `box.snapshot`"

msgid "**Memtx**"
msgstr ""

msgid ""
"Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool "
"first enters the delayed garbage collection mode for all data. In this "
"mode, the :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-"
"garbage-collector>` will not remove files which were created before the "
"snapshot started, it will not remove them until the snapshot has "
"finished. To preserve consistency of the primary key, used to iterate "
"over tuples, a copy-on-write technique is employed. If the master process"
" changes part of a primary key, the corresponding process page is split, "
"and the snapshot process obtains an old copy of the page. In effect, the "
"snapshot process uses multi-version concurrency control in order to avoid"
" copying changes which are superseded while it is running."
msgstr ""
"Создает снимок всех данных и сохраняет его в :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`:samp:`/{<latest-lsn>}.snap`. Чтобы сделать снимок, сначала "
"Tarantool входит в режим сборки мусора по всем данным. В этом режиме "
":ref:`сборщик мусора Tarantool'а <cfg_checkpoint_daemon-garbage-"
"collector>` не будет удалять файлы, созданные до начала создания снимка, "
"до тех пор, пока не будет завершено создание снимка. Чтобы сохранить "
"консистентность первичного ключа, используемого для итерации по кортежам,"
" применяется технология копирования при записи. Если главный процесс "
"изменяет часть первичного ключа, страница соответствующего процесса "
"разделяется, и процесс создания снимка получает старую копию страницы. В "
"результате, процесс создания снимка использует многоверсионную "
"параллельную обработку данных, чтобы не скопировать изменения, замененные"
" одновременно с ходом процесса."

msgid ""
"Since a snapshot is written sequentially, you can expect a very high "
"write performance (averaging to 80MB/second on modern disks), which means"
" an average database instance gets saved in a matter of minutes. You may "
"restrict the speed by changing :ref:`snap_io_rate_limit "
"<cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""
"Поскольку снимок создается последовательно, можно ожидать высокую "
"скорость записи (в среднем до 80 МБ/секунду на современных дисках), что "
"означает сохранение данных усредненного экземпляра базы данных за "
"несколько минут. Пользователи могут ограничить скорость записи, изменив "
"значение :ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-"
"snap_io_rate_limit>`."

#, python-format
msgid ""
"As long as there are any changes to the parent index memory through "
"concurrent updates, there are going to be page splits, and therefore you "
"need to have some extra free memory to run this command. 10% of "
":ref:`memtx_memory <cfg_storage-memtx_memory>` is, on average, "
"sufficient. This statement waits until a snapshot is taken and returns "
"operation result."
msgstr ""
"При условии, что происходят изменения в родительском индексе в ходе "
"многопоточного обновления данных, будет происходить и расщепление "
"страниц, поэтому возникнет необходимость в наличии дополнительной "
"свободной памяти для выполнения этой команды. В среднем, будет достаточно"
" 10% от :ref:`memtx_memory <cfg_storage-memtx_memory>`. Оператор подождет"
" окончания создания снимка и вернет результат операции."

msgid ""
"**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process"
" caused a fork, which could cause occasional latency spikes. Starting "
"with Tarantool version 1.6.6, the snapshot process creates a consistent "
"read view and this view is written to the snapshot file by a separate "
"thread (the \"Write Ahead Log\" thread)."
msgstr ""
"**Обновление:** До версии 1.6.6 Tarantool'а процесс создания снимка "
"вызывал создание ответвления, что могло привести к скачкам задержки "
"отклика. Начиная с версии 1.6.6 Tarantool'а, процесс создания снимка "
"создает вид постоянного просмотра, который и записывается в файл снимка с"
" помощью отдельного потока (поток упреждающей записи в журнал)."

msgid ""
"Although ``box.snapshot()`` does not cause a fork, there is a separate "
"fiber which may produce snapshots at regular intervals -- see the "
"discussion of the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""
"Хотя ``box.snapshot()`` не создает ответвление, есть отдельный файбер, "
"который может создавать снимки на регулярной основе -- см. обсуждение "
":ref:`демона создания контрольных точек <book_cfg_checkpoint_daemon>`."

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."

msgid ""
"Taking a snapshot does not cause the server to start a new write-ahead "
"log. Once a snapshot is taken, old WALs can be deleted as long as all "
"replicated data is up to date. But the WAL which was current at the time "
"``box.snapshot()`` started must be kept for recovery, since it still "
"contains log records written after the start of ``box.snapshot()``."
msgstr ""
"Создание снимка не приводит к записи нового журнала упреждающей записи на"
" сервере. После создания снимка старые WAL-файлы можно удалить, если все "
"реплицируемые данные актуальны. Но WAL-файл на момент начала работы "
"``box.snapshot()`` следует сохранить на случай восстановления, поскольку "
"он содержит записи журнала после начала работы ``box.snapshot()``."

msgid ""
"An alternative way to save a snapshot is to send a SIGUSR1 signal to the "
"instance. While this approach could be handy, it is not recommended for "
"use in automation: a signal provides no way to find out whether the "
"snapshot was taken successfully or not."
msgstr ""
"Другим способом сохранения снимка будет отправка сигнала SIGUSR1 на "
"экземпляр. Хотя это может быть удобно, не рекомендуется использовать "
"такой метод в автоматическом процессе: сигнал не дает возможность "
"проверить, был ли корректно сделан снимок."

msgid "**Vinyl**"
msgstr ""

msgid ""
"In vinyl, inserted data is stacked in memory until the limit, set in the "
":ref:`vinyl_memory <cfg_storage-vinyl_memory>` parameter, is reached. "
"Then vinyl automatically dumps it to the disc. ``box.snapshot()`` forces "
"this dump in order to have the ability to recover from this checkpoint. "
"The snapshot files are stored in :samp:`{space_id}/{index_id}/*.run`. "
"Thus, strictly all the data that was written at the time of LSN of the "
"checkpoint is in the ``*.run`` files on the disk, and all operations that"
" happened after the checkpoint will be written in the ``*.xlog``. All "
"dump files created by ``box.snapshot()`` are consistent and have the same"
" LSN as checkpoint."
msgstr ""
"При использовании vinyl'a вставляемые данные складываются в память до тех"
" пор, пока не будет достигнут предел, установленный в параметре "
":ref:`vinyl_memory <cfg_storage-vinyl_memory>`. Затем винил автоматически"
" делает дамп на диск. ``box.snapshot()`` форсирует создание дампа, чтобы "
"иметь возможность восстановить данные из этой контрольной точки. Файлы "
"снимков хранятся в :samp:`{space_id}/{index_id}/*.run`. Таким образом, "
"строго все данные, которые были записаны во время LSN контрольной точки, "
"находятся в `*.run` файлах на диске, а все операции, которые происходили "
"после контрольной точки, будут записаны в ``*.xlog``. Все файлы дампа, "
"созданные функцией ``box.snapshot()``, консистентны и имеют тот же LSN, "
"что и контрольная точка."

msgid ""
"At the checkpoint vinyl also rotates the metadata log ``*.vylog``, "
"containing data manipulation operations like \"create file\" and \"delete"
" file\". It goes through the log, removes duplicating operations from the"
" memory and creates a new ``*.vylog`` file, giving it the name according "
"to the :ref:`vclock <box_introspection-box_info>` of the new checkpoint, "
"with \"create\" operations only. This procedure cleans ``*.vylog`` and is"
" useful for recovery because the name of the log is the same as the "
"checkpoint signature."
msgstr ""
"На контрольной точке vinyl также пересматривает журнал метаданных "
"``*.vylog``, содержащий операции манипуляции с данными, такие как "
"\"создать файл\" и \"удалить файл\". Он проходит по логу, удаляет "
"дублирующие операции из памяти и создает новый файл ``*.vylog``, "
"присваивая ему имя в соответствии с :ref:`vclock <box_introspection-"
"box_info>` новой контрольной точки, оставляя только операци создания. Эта"
" процедура очищает ``*.vylog`` и полезна для восстановления, так как имя "
"лога совпадает с именем подписи контрольной точки."
