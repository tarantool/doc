
msgid "Submodule `box.space`"
msgstr "Вложенный модуль `box.space`"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"The ``box.space`` submodule has the data-manipulation functions "
"``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, "
"``get``, ``put``. It also has members, such as id, and whether or not a "
"space is enabled. Submodule source code is available in file "
"`src/box/lua/schema.lua "
"<https://github.com/tarantool/tarantool/blob/2.1/src/box/lua/schema.lua>`_."
msgstr ""
"Вложенный модуль ``box.space`` включает в себя функции по управлению "
"данными ``select`` (выборка), ``insert`` (вставка), ``replace`` (замена),"
" ``update`` (обновление), ``upsert`` (обновление и вставка), ``delete`` "
"(удаление), ``get`` (получение), ``put`` (выдача). Также в модуле есть "
"такие элементы, как id, и указание на активность спейса. Код вложенного "
"модуля находится в файле `src/box/lua/schema.lua "
"<https://github.com/tarantool/tarantool/blob/2.1/src/box/lua/schema.lua>`_."

msgid "Index"
msgstr "Индекс"

msgid "Below is a list of all ``box.space`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``box.space``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Использование"

msgid ":ref:`space_object:auto_increment() <box_space-auto>`"
msgstr ""

msgid "Generate key + Insert a tuple"
msgstr "Генерация ключа + вставка кортежа"

msgid ":ref:`space_object:bsize() <box_space-bsize>`"
msgstr ":ref:`space_object:bsize() <box_space-bsize>`"

msgid "Get count of bytes"
msgstr "Подсчет байтов"

msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ":ref:`space_object:count() <box_space-count>`"

msgid "Get count of tuples"
msgstr "Подсчет кортежей"

msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ":ref:`space_object:create_index() <box_space-create_index>`"

msgid "Create an index"
msgstr "Создание индекса"

msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ":ref:`space_object:delete() <box_space-delete>`"

msgid "Delete a tuple"
msgstr "Удаление кортежа"

msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ":ref:`space_object:drop() <box_space-drop>`"

msgid "Destroy a space"
msgstr "Удаление спейса"

msgid ":ref:`space_object:format() <box_space-format>`"
msgstr ":ref:`space_object:format() <box_space-format>`"

msgid "Declare field names and types"
msgstr "Объявление имен и типов полей"

msgid ":ref:`space_object:frommap() <box_space-frommap>`"
msgstr ":ref:`space_object:frommap() <box_space-frommap>`"

msgid "Convert from map to tuple or table"
msgstr "Конвертация ассоциативного массива в кортеж или таблицу"

msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ":ref:`space_object:get() <box_space-get>`"

msgid "Select a tuple"
msgstr "Выбор кортежа"

msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ":ref:`space_object:insert() <box_space-insert>`"

msgid "Insert a tuple"
msgstr "Вставка кортежа"

msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ":ref:`space_object:len() <box_space-len>`"

msgid ":ref:`space_object:on_replace() <box_space-on_replace>`"
msgstr ":ref:`space_object:on_replace() <box_space-on_replace>`"

msgid "Create a replace trigger with a function that cannot change the tuple"
msgstr "Создание триггера замены с функцией, которая не может изменять кортеж"

msgid ":ref:`space_object:before_replace() <box_space-before_replace>`"
msgstr ":ref:`space_object:before_replace() <box_space-before_replace>`"

msgid "Create a replace trigger with a function that can change the tuple"
msgstr "Создание триггера замены с функцией, которая может изменять кортеж"

msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ":ref:`space_object:pairs() <box_space-pairs>`"

msgid "Prepare for iterating"
msgstr "Подготовка к итерации"

msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ":ref:`space_object:put() <box_space-replace>`"

msgid "Insert or replace a tuple"
msgstr "Вставка или замена кортежа"

msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ":ref:`space_object:rename() <box_space-rename>`"

msgid "Rename a space"
msgstr "Переименование спейса"

msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ":ref:`space_object:replace() <box_space-replace>`"

msgid ":ref:`space_object:run_triggers() <box_space-run_triggers>`"
msgstr ":ref:`space_object:run_triggers() <box_space-run_triggers>`"

msgid "Enable/disable a replace trigger"
msgstr "Включение/отключение триггера замены"

msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ":ref:`space_object:select() <box_space-select>`"

msgid "Select one or more tuples"
msgstr "Выбор одного или более кортежей"

msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ":ref:`space_object:truncate() <box_space-truncate>`"

msgid "Delete all tuples"
msgstr "Удаление всех кортежей"

msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ":ref:`space_object:update() <box_space-update>`"

msgid "Update a tuple"
msgstr "Обновление кортежа"

msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ":ref:`space_object:upsert() <box_space-upsert>`"

msgid ":ref:`space_object:user_defined() <box_space-user_defined>`"
msgstr ":ref:`space_object:user_defined() <box_space-user_defined>`"

msgid "Any function / method that any user wants to add"
msgstr "Любая функция / метод, которые хочет добавить любой пользователь"

#, fuzzy
msgid ""
":ref:`space_object:create_check_constraint() <box_space-"
"create_check_constraint>`"
msgstr ":ref:`space_object:create_index() <box_space-create_index>`"

msgid "Create a check constraint"
msgstr ""

msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ":ref:`space_object.enabled <box_space-enabled>`"

msgid "Flag, true if space is enabled"
msgstr "Флаг, если спейс активен -- true"

msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ":ref:`space_object.field_count <box_space-field_count>`"

msgid "Required number of fields"
msgstr "Необходимое количество полей"

msgid ":ref:`space_object.id <box_space-id>`"
msgstr ":ref:`space_object.id <box_space-id>`"

msgid "Numeric identifier of space"
msgstr "Числовой идентификатор спейса"

msgid ":ref:`space_object.index <box_space-space_index>`"
msgstr ":ref:`space_object.index <box_space-space_index>`"

msgid "Container of space's indexes"
msgstr "Контейнер для индексов спейса"

msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ":ref:`box.space._cluster <box_space-cluster>`"

msgid "(Metadata) List of replica sets"
msgstr "(Метаданные) Список наборов реплик"

msgid ":ref:`box.space._func <box_space-func>`"
msgstr ":ref:`box.space._func <box_space-func>`"

msgid "(Metadata) List of function tuples"
msgstr "(Метаданные) Список кортежей с функциями"

msgid ":ref:`box.space._index <box_space-index>`"
msgstr ":ref:`box.space._index <box_space-index>`"

msgid "(Metadata) List of indexes"
msgstr "(Метаданные) Список индексов"

msgid ":ref:`box.space._vindex <box_space-vindex>`"
msgstr ":ref:`box.space._vindex <box_space-vindex>`"

msgid "(Metadata) List of indexes accessible for the current user"
msgstr "(Метаданные) Список индексов, доступных текущему пользователю"

msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ":ref:`box.space._priv <box_space-priv>`"

msgid "(Metadata) List of privileges"
msgstr "(Метаданные) Список прав"

msgid ":ref:`box.space._vpriv <box_space-vpriv>`"
msgstr ":ref:`box.space._vpriv <box_space-vpriv>`"

msgid "(Metadata) List of privileges accessible for the current user"
msgstr "(Метаданные) Список прав, доступных текущему пользователю"

msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ":ref:`box.space._schema <box_space-schema>`"

msgid "(Metadata) List of schemas"
msgstr "(Метаданные) Список схем"

msgid ":ref:`box.space._sequence <box_space-sequence>`"
msgstr ":ref:`box.space._sequence <box_space-sequence>`"

msgid "(Metadata) List of sequences"
msgstr "(Метаданные) Список последовательностей"

msgid ":ref:`box.space._sequence_data <box_space-sequence_data>`"
msgstr ":ref:`box.space._sequence_data <box_space-sequence_data>`"

msgid ":ref:`box.space._space <box_space-space>`"
msgstr ":ref:`box.space._space <box_space-space>`"

msgid "(Metadata) List of spaces"
msgstr "(Метаданные) Список спейсов"

msgid ":ref:`box.space._vspace <box_space-vspace>`"
msgstr ":ref:`box.space._vspace <box_space-vspace>`"

msgid "(Metadata) List of spaces accessible for the current user"
msgstr "(Метаданные) Список спейсов, доступных текущему пользователю"

msgid ":ref:`box.space._user <box_space-user>`"
msgstr ":ref:`box.space._user <box_space-user>`"

msgid "(Metadata) List of users"
msgstr "(Метаданные) Список пользователей"

#, fuzzy
msgid ":ref:`box.space._ck_constraint <box_space-ck_constraint>`"
msgstr ":ref:`box.space._cluster <box_space-cluster>`"

#, fuzzy
msgid "(Metadata) List of check constraints"
msgstr "(Метаданные) Список схем"

msgid ":ref:`box.space._vuser <box_space-vuser>`"
msgstr ":ref:`box.space._vuser <box_space-vuser>`"

msgid "(Metadata) List of users accessible for the current user"
msgstr "(Метаданные) Список пользователей, доступных текущему пользователю"

#, fuzzy
msgid ":ref:`box.space._collation <box_space-collation>`"
msgstr ":ref:`box.space._cluster <box_space-cluster>`"

#, fuzzy
msgid "(Metadata) List of collations"
msgstr "(Метаданные) Список кортежей с функциями"

#, fuzzy
msgid ":ref:`box.space._vcollation <box_space-vcollation>`"
msgstr ":ref:`box.space._vindex <box_space-vindex>`"

#, fuzzy
msgid "(Metadata) List of collations accessible for the current user"
msgstr "(Метаданные) Список индексов, доступных текущему пользователю"

#, fuzzy
msgid ":ref:`box.space._session_settings <box_space-session_settings>`"
msgstr ":ref:`box.space._cluster <box_space-cluster>`"

#, fuzzy
msgid "(Metadata) List of settings affecting behavior of the current session"
msgstr "(Метаданные) Список пользователей, доступных текущему пользователю"

msgid ""
"Insert a new tuple using an auto-increment primary key. The space "
"specified by space_object must have an :ref:`'unsigned' or 'integer' or "
"'number' <index-box_indexed-field-types>` primary key index of type "
"``TREE``. The primary-key field will be incremented before the insert."
msgstr ""
"Вставка нового кортежа, используя первичный ключ с автоматическим "
"увеличением. В спейсе, указанном через space_object должен быть первичный"
" TREE-индекс типа :ref:`'unsigned' или 'integer', или 'number' <index-"
"box_indexed-field-types>`. Поле первичного ключа будет увеличиваться "
"перед вставкой."

msgid ""
"Since version 1.7.5 this method is deprecated – it is better to use a "
":ref:`sequence <index-box_sequence>`."
msgstr ""
"Данный метод объявлен устаревшим с версии 1.7.5 -- лучше использовать "
":ref:`последовательности <index-box_sequence>`."

msgid "Parameters"
msgstr "Параметры"

msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ":ref:`ссылка на объект <app_server-object_reference>`"

msgid "tuple's fields, other than the primary-key field"
msgstr "поля кортежа, не включая поле первичного ключа"

msgid "return"
msgstr "возвращается"

msgid "the inserted tuple."
msgstr "вставленный кортеж."

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "tuple"
msgstr "кортеж"

msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes "
"accessed, :ref:`WAL settings <cfg_binary_logging_snapshots-"
"rows_per_wal>`."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса, количество кортежей, к"
" которым получен доступ, :ref:`настройки журнала упреждающей записи (WAL)"
" <cfg_binary_logging_snapshots-rows_per_wal>`."

msgid "**Possible errors:**"
msgstr "**Возможные ошибки:**"

msgid "index has wrong type;"
msgstr "неподходящий тип индекса;"

msgid "primary-key indexed field is not a number."
msgstr "проиндексированное поле первичного ключа не является числовым."

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."

msgid ""
"Number of bytes in the space. This number, which is stored in Tarantool's"
" internal memory, represents the total number of bytes in all tuples, not"
" including index keys. For a measure of index size, see "
":ref:`index_object:bsize() <box_index-bsize>`."
msgstr ""
"Количество байтов в спейсе. Это число, которое хранится во внутренней "
"памяти Tarantool'а, представляет собой общее количество байтов во всех "
"кортежах, включая ключи индекса. Для получения информации об измерении "
"размера индекса, см. :ref:`index_object:bsize() <box_index-bsize>`."

msgid ""
"tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."
msgstr ""
"tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."

msgid ""
"Return the number of tuples. If compared with :ref:`len() <box_space-"
"len>`, this method works slower because ``count()`` scans the entire "
"space to count the tuples."
msgstr ""
"Возврат количества кортежей. Если сравнивать с :ref:`len() <box_space-"
"len>`, то данный метод работает медленнее, поскольку метод ``count()`` "
"сканирует весь спейс для подсчета кортежей."

msgid ""
"primary-key field values, must be passed as a Lua table if key is multi-"
"part"
msgstr ""
"значения поля первичного ключа, которые должны возвращаться в виде "
"Lua-таблицы, если ключ составной"

msgid "comparison method"
msgstr "метод сопоставления"

msgid "Number of tuples."
msgstr "Количество кортежей."

msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."

msgid ""
"Create an :ref:`index <index-box_index>`. It is mandatory to create an "
"index for a space before trying to insert tuples into it, or select "
"tuples from it. The first created index, which will be used as the "
"primary-key index, must be unique."
msgstr ""
"Создание :ref:`индекса <index-box_index>`. Индекс обязательно должен "
"создаваться для спейса до вставки в него кортежей или выборки. Первый "
"созданный индекс, который будет использоваться в качестве первичного "
"индекса, должен быть уникальным."

msgid ""
"name of index, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя индекса, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

msgid "see \"Options for space_object:create_index()\", below"
msgstr "см. \"Параметры для space_object:create_index()\" ниже"

msgid "index object"
msgstr "объект индекса"

msgid "index_object"
msgstr "объект индекса"

msgid "**Options for space_object:create_index()**"
msgstr "**Параметры для space_object:create_index()**"

msgid "Effect"
msgstr "Эффект"

msgid "Type"
msgstr "Type"

msgid "Default"
msgstr "Значение по умолчанию"

msgid "type"
msgstr "type"

msgid "type of index"
msgstr "тип индекса"

msgid ""
"string ('HASH' or 'TREE' or 'BITSET' or 'RTREE') Note re storage engine: "
"vinyl only supports 'TREE'"
msgstr ""
"строка ('HASH' или 'TREE', или 'BITSET', или 'RTREE') Примечание про "
"движок базы данных: vinyl поддерживает только 'TREE'"

msgid "'TREE'"
msgstr "'TREE'"

msgid "id"
msgstr "id"

msgid "unique identifier"
msgstr "уникальный идентификатор"

msgid "number"
msgstr "число"

msgid "last index's id, +1"
msgstr "идентификатор последнего индекса +1"

msgid "unique"
msgstr "unique"

msgid "index is unique"
msgstr "индекс уникален"

msgid "boolean"
msgstr "boolean (логический)"

msgid "``true``"
msgstr "``true`` (правда)"

msgid "if_not_exists"
msgstr "if_not_exists (если отсутствует)"

msgid "no error if duplicate name"
msgstr "ошибки нет, если имя дублируется"

msgid "``false``"
msgstr "``false`` (ложь)"

msgid "parts"
msgstr "parts"

msgid "field-numbers  + types"
msgstr "номера поля + типы"

#, fuzzy
msgid ""
"{field_no, ``'unsigned'`` or ``'string'`` or ``'integer'`` or "
"``'number'`` or ``'double'`` or ``'decimal'``or 'boolean'`` or "
"``'varbinary'`` or ``'array'`` or ``'scalar'``, and optional collation or"
" is_nullable value or path}"
msgstr ""
"{field_no, ``'unsigned'`` или ``'string'`` или ``'integer'`` или "
"``'number'`` или ``'double'`` или ``'decimal'`` или 'boolean'`` или "
"``'varbinary'`` или ``'array'`` или ``'scalar'``, возможна сортировка, "
"возможно значение is_nullable}"

msgid "``{1, 'unsigned'}``"
msgstr "``{1, 'unsigned'}``"

msgid "dimension"
msgstr "dimension"

msgid "affects :ref:`RTREE <box_index-rtree>` only"
msgstr "только для :ref:`RTREE <box_index-rtree>`"

msgid "2"
msgstr "2"

msgid "distance"
msgstr "distance"

msgid "affects RTREE only"
msgstr "только для RTREE"

msgid "string ('euclid' or 'manhattan')"
msgstr "строка ('euclid' или 'manhattan')"

msgid "'euclid'"
msgstr "'euclid' (Евклидова)"

msgid "bloom_fpr"
msgstr "bloom_fpr"

msgid "affects vinyl only"
msgstr "только для vinyl"

msgid "``vinyl_bloom_fpr``"
msgstr "``vinyl_bloom_fpr``"

msgid "page_size"
msgstr "page_size"

msgid "``vinyl_page_size``"
msgstr "``vinyl_page_size``"

msgid "range_size"
msgstr "range_size"

msgid "``vinyl_range_size``"
msgstr "``vinyl_range_size``"

msgid "run_count_per_level"
msgstr "run_count_per_level"

msgid "``vinyl_run_count_per_level``"
msgstr "``vinyl_run_count_per_level``"

msgid "run_size_ratio"
msgstr "run_size_ratio"

msgid "``vinyl_run_size_ratio``"
msgstr "``vinyl_run_size_ratio``"

msgid "sequence"
msgstr "sequence"

msgid ""
"see section regarding :ref:`specifying a sequence in create_index() "
"<box_schema-sequence_create_index>`"
msgstr ""
"см. раздел об :ref:`указании последовательности для create_index() "
"<box_schema-sequence_create_index>`"

msgid "string or number"
msgstr "строка или число"

msgid "not present"
msgstr "отсутствует"

msgid "func"
msgstr ""

#, fuzzy
msgid ":ref:`functional index <box_space-index_func>`"
msgstr ":ref:`box.space._index <box_space-index>`"

msgid "string"
msgstr "string (строка)"

msgid ""
"The options in the above chart are also applicable for "
":ref:`index_object:alter() <box_index-alter>`."
msgstr ""
"Параметры в вышеуказанной таблице также применимы к "
":ref:`index_object:alter() <box_index-alter>`."

msgid ""
"**Note re storage engine:** vinyl has extra options which by default are "
"based on configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-"
"vinyl_bloom_fpr>`, :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`,"
" and :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- "
"see the description of those parameters. The current values can be seen "
"by selecting from :ref:`box.space._index <box_space-index>`."
msgstr ""
"**Примечание про движок базы данных:** в vinyl'е есть дополнительные "
"параметры, которые по умолчанию основаны на конфигурационных параметрах "
":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`, "
":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>` "
"и :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- см. "
"описание этих параметров. Текущие значения можно увидеть, сделав выборку "
"из :ref:`box.space._index <box_space-index>`."

msgid ""
"Building or rebuilding a large index will cause occasional :ref:`yields "
"<atomic-cooperative_multitasking>` so that other requests will not be "
"blocked. If the other requests cause an illegal situation such as a "
"duplicate key in a unique index, the index building or rebuilding will "
"fail."
msgstr ""

msgid "too many parts;"
msgstr "слишком много частей;"

msgid "index '...' already exists;"
msgstr "индекс '...' уже существует;"

msgid "primary key must be unique."
msgstr "первичный ключ должен быть уникальным."

msgid ""
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = { {field = "
"1, type = 'unsigned'}, {field = 2, type = 'string'}} })\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = { {field = "
"1, type = 'unsigned'}, {field = 2, type = 'string'}} })\n"
"---\n"
"..."

msgid "**Details about index field types:**"
msgstr "**Подробнее о типах полей индекса:**"

msgid ""
"The ten index field types (unsigned | string | integer | number | double "
"| boolean | decimal | varbinary | array | scalar) differ depending on "
"what values are allowed, and what index types are allowed."
msgstr ""
"Десять типов полей индекса (unsigned | string | integer | number | "
"double | boolean | decimal | varbinary | array | scalar) "
"отличаются друг от друга возможными значениями и типами индексов, где "
"можно использовать такие поля."

msgid ""
"**unsigned**: unsigned integers between 0 and 18446744073709551615, about"
" 18 quintillion. May also be called 'uint' or 'num', but 'num' is "
"deprecated. Legal in memtx TREE or HASH indexes, and in vinyl TREE "
"indexes."
msgstr ""
"**unsigned**: беззнаковые целые числа от 0 до 18 446 744 073 709 551 615,"
" т.е. около18 квинтиллионов. Также может называться 'uint' или 'num', но "
"'num' объявлен устаревшим. Используется в индексах типа TREE или HASH в "
"memtx'е, и в TREE-индексах в vinyl'е."

msgid ""
"**string**: any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. May also be called 'str'. Legal in "
"memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes. A string"
" may have a :ref:`collation <index-collation>`."
msgstr ""
"**string**: строка, то есть любая последовательность октетов до "
":ref:`максимальной длины <limitations_bytes_in_index_key>`. Также может "
"называться 'str'. Используется в индексах типа TREE, HASH или BITSET в "
"memtx'е и в TREE-индексах в vinyl'е. В строке может быть :ref:`сортировка"
" <index-collation>`."

msgid ""
"**integer**: integers between -9223372036854775808 and "
"18446744073709551615. May also be called 'int'. Legal in memtx TREE or "
"HASH indexes, and in vinyl TREE indexes."
msgstr ""
"**integer**: целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 "
"709 551 615. Также может называться 'int'. Используется в индексах типа "
"TREE или HASH в memtx'е и в TREE-индексах в vinyl'е."

#, fuzzy
msgid ""
"**number**: integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, or double-"
"precision floating point numbers, or exact numbers. Legal in memtx TREE "
"or HASH indexes, and in vinyl TREE indexes."
msgstr ""
"**number**: целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 "
"709 551 615, числа с плавающей запятой с одинарной точностью или с "
"двойной точностью. Используется в индексах типа TREE или HASH в memtx'е и"
" в TREE-индексах в vinyl'е."

#, fuzzy
msgid ""
"**double**: double-precision floating point numbers. Legal in memtx TREE "
"or HASH indexes, and in vinyl TREE indexes."
msgstr ""
"**boolean**: логическое значение, true (правда) или false (ложь). "
"Используется в индексах типа TREE или HASH в memtx'е и в TREE-индексах в "
"vinyl'е."

msgid ""
"**boolean**: true or false. Legal in memtx TREE or HASH indexes, and in "
"vinyl TREE indexes."
msgstr ""
"**boolean**: логическое значение, true (правда) или false (ложь). "
"Используется в индексах типа TREE или HASH в memtx'е и в TREE-индексах в "
"vinyl'е."

#, fuzzy
msgid ""
"**decimal**: exact number returned from a function in the :ref:`decimal "
"<decimal>` module. Legal in memtx TREE or HASH indexes, and in vinyl TREE"
" indexes."
msgstr ""
"**boolean**: логическое значение, true (правда) или false (ложь). "
"Используется в индексах типа TREE или HASH в memtx'е и в TREE-индексах в "
"vinyl'е."

msgid ""
"**varbinary**: any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. Legal in memtx TREE or HASH indexes, "
"and in vinyl TREE indexes. A varbinary byte sequence does not have a "
":ref:`collation <index-collation>` because its contents are not UTF-8 "
"characters."
msgstr ""

msgid ""
"**array**: array of numbers. Legal in memtx :ref:`RTREE <box_index-"
"rtree>` indexes."
msgstr ""
"**array**: массив чисел. Используется в :ref:`RTREE-индексах <box_index-"
"rtree>` в memtx'е."

#, fuzzy
msgid ""
"**scalar**: null (input with ``msgpack.NULL`` or ``yaml.NULL`` or "
"``json.NULL``), booleans (true or false), or integers between "
"-9223372036854775808 and 18446744073709551615, or single-precision "
"floating point numbers, or double-precison floating-point numbers, or "
"exact numbers, or strings, or (varbinary) byte arrays. When there is a "
"mix of types, the key order is: null, then booleans, then numbers, then "
"strings, then byte arrays. Legal in memtx TREE or HASH indexes, and in "
"vinyl TREE indexes."
msgstr ""
"**scalar**: логические значения (true или false), целые числа от integers"
" between -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615, числа "
"с плавающей запятой с одинарной точностью или с двойной точностью или "
"строки. При использовании нескольких типов, порядок ключей должен быть "
"следующим: логические значения, затем числа, затем строки. Используется в"
" индексах типа TREE или HASH в memtx'е и в TREE-индексах в vinyl'е."

msgid ""
"Additionally, `nil` is allowed with any index field type if "
":ref:`is_nullable=true <box_space-is_nullable>` is specified."
msgstr ""
"Кроме того, допускается нулевое значение `nil` для любого типа поля, если"
" указана такая возможность :ref:`is_nullable=true <box_space-"
"is_nullable>`."

msgid "**Index field types to use in space_object:create_index()**"
msgstr "**Типы полей в индексах для использования в space_object:create_index()**"

msgid "Index field type"
msgstr "Тип поля для индексирования"

msgid "What can be in it"
msgstr "Чем может быть"

msgid "Where is it legal"
msgstr "Где может использоваться"

msgid "Examples"
msgstr "Примеры"

msgid "**unsigned**"
msgstr "**unsigned**"

msgid "integers between 0 and 18446744073709551615"
msgstr "целые числа от 0 до 18 446 744 073 709 551 615"

msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr "индексы типа TREE или HASH в memtx'е, |br| TREE-индексы в vinyl'е"

msgid "123456 |br|"
msgstr "123456 |br|"

msgid "**string**"
msgstr "**string**"

msgid "strings -- any set of octets"
msgstr "строки -- любой набор октетов"

msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr "индексы типа TREE или HASH в memtx'е |br| TREE-индексы в vinyl'е"

msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr "'A B C' |br| '\\\\65 \\\\66 \\\\67'"

msgid "**varbinary**"
msgstr "**varbinary**"

msgid "byte sequences -- any set of octets"
msgstr "последовательности байтов -- любой набор октетов"

msgid "'\\\\65 \\\\66 \\\\67' |br|"
msgstr "'\\\\65 \\\\66 \\\\67' |br|"

msgid "**integer**"
msgstr "**integer**"

msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr "целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615"

msgid "-2^63 |br|"
msgstr "-2^63 |br|"

msgid "**number**"
msgstr "**number**"

#, fuzzy
msgid ""
"integers between -9223372036854775808 and 18446744073709551615, single-"
"precision floating point numbers, double-precision floating point "
"numbers, exact (decimal) numbers"
msgstr ""
"целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615, "
"числа с плавающей запятой с одинарной точностью или с двойной точностью"

msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr "1.234 |br| -44 |br| 1.447e+44"

#, fuzzy
msgid "**double**"
msgstr "double (числа с двойной точностью)"

msgid "double-precision floating point numbers"
msgstr ""

msgid "1.234"
msgstr "1,234"

msgid "**boolean**"
msgstr "**boolean**"

msgid "true or false"
msgstr "true или false"

msgid "false |br| true"
msgstr "false |br| true"

msgid "**decimal**"
msgstr ""

msgid ""
"exact numbers returned by a function in the :ref:`decimal <decimal>` "
"module"
msgstr ""

msgid "decimal.new(1.2) |br|"
msgstr ""

msgid "**array**"
msgstr "**array**"

msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""
"массив целых чисел от -9 223 372 036 854 775 808 до 9 223 372 036 854 775"
" 807"

msgid "memtx RTREE indexes"
msgstr "RTREE-индексы в memtx'е"

msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr "{10, 11} |br| {3, 5, 9, 10}"

msgid "**scalar**"
msgstr "**scalar**"

#, fuzzy
msgid ""
"null, booleans (true or false), integers between -9223372036854775808 and"
" 18446744073709551615, single-precision floating point numbers, double-"
"precision floating point numbers, strings"
msgstr ""
"логические значения (true или false), целые числа от -9 223 372 036 854 "
"775 808 до 18 446 744 073 709 551 615, числа с плавающей запятой с "
"одинарной точностью или с двойной точностью, строки"

#, fuzzy
msgid "null |br| true |br| -1 |br| 1.234 |br| '' |br| 'ру'"
msgstr "true |br| -1 |br| 1.234 |br| '' |br| 'ру'"

msgid ""
"**Allowing null for an indexed key:** If the index type is TREE, and the "
"index is not the primary index, then the ``parts={...}`` clause may "
"include ``is_nullable=true`` or ``is_nullable=false`` (the default). If "
"``is_nullable`` is true, then it is legal to insert ``nil`` or an "
"equivalent such as ``msgpack.NULL`` (or it is legal to insert nothing at "
"all for trailing nullable fields). Within indexes, such \"null values\" "
"are always treated as equal to other null values, and are always treated "
"as less than non-null values. Nulls may appear multiple times even in a "
"unique index. Example:"
msgstr ""
"**Разрешение использования нулевых значений для индексируемого ключа:** "
"/Если тип индекса -- TREE, и индекс не является первичным, то оператор "
"``parts={...}`` может включать в себя ``is_nullable=true`` или "
"``is_nullable=false`` (по умолчанию). Если значение параметра "
"``is_nullable`` -- true, то можно вставлять ``nil`` или аналогичное "
"значение, например ``msgpack.NULL`` (или можно не вставлять вообще ничего"
" в завершающие ненулевые поля). В рамках индекса такие нулевые значения "
"считаются равными другим нулевым значениям и всегда меньше ненулевых "
"значений. Нулевые значения могут встречаться несколько раз даже в "
"уникальном индексе. Например:"

#, fuzzy
msgid ""
"box.space.tester:create_index('I',{unique=true,parts={{field = 2, type = "
"'number', is_nullable = true}}})"
msgstr "box.space.tester:create_index('I',{unique=true,parts={{2,'number',is_nullable=true}}})"

msgid ""
"It is legal to create multiple indexes for the same field with different "
"``is_nullable`` values, or to call :ref:`space_object:format() "
"<box_space-format>` with a different ``is_nullable`` value from what is "
"used for an index. When there is a contradiction, the rule is: null is "
"illegal unless ``is_nullable=true`` for every index and for the space "
"format."
msgstr ""
"Можно создать множество индексов для одного и того же поля с различными "
"значениями ``is_nullable`` или вызвать :ref:`space_object:format() "
"<box_space-format>` со значением ``is_nullable``, отличным от "
"используемого для индекса. При наличии несоответствий правило такое: "
"запрещается использовать null кроме случаев, когда ``is_nullable=true`` "
"для всех индексов и формата спейса."

msgid ""
"**Using field names instead of field numbers:** ``create_index()`` can "
"use field names and/or field types described by the optional "
":ref:`space_object:format() <box_space-format>` clause. In the following "
"example, we show ``format()`` for a space that has two columns named 'x' "
"and 'y', and then we show five variations of the ``parts={}`` clause of "
"``create_index()``, first for the 'x' column, second for both the 'x' and"
" 'y' columns. The variations include omitting the type, using numbers, "
"and adding extra braces."
msgstr ""
"**Использование имен полей вместо номеров полей:** в ``create_index()`` "
"можно использовать имена полей и/или типы полей, описанные в "
"необязательном операторе :ref:`space_object:format() <box_space-format>`."
" В следующем примере покажем ``format()`` для спейса с двумя столбцами "
"под названиями 'x' и 'y', а затем покажем пять вариантов оператора "
"``parts={}`` в ``create_index()``, сначала для столбца 'x', затем для "
"столбцов 'x' и 'y'. Варианты включают в себя пропуск типа, использование "
"номеров и добавление дополнительных фигурных скобок."

#, fuzzy
msgid ""
"box.space.tester:format({{name='x', type='scalar'}, {name='y', "
"type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x', 'scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})"
"\n"
"box.space.tester:create_index('I4',{parts={1,'scalar'}})\n"
"box.space.tester:create_index('I5',{parts={1,'scalar',2,'integer'}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"
msgstr ""
"box.space.tester:format({{name='x', type='scalar'}, {name='y', "
"type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x','scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})"
"\n"
"box.space.tester:create_index('I4',{parts={1,'scalar'}})\n"
"box.space.tester:create_index('I5',{parts={1,'scalar',2,'integer'}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"

msgid ""
"**Using the path option for map fields:** To create an index for a field "
"that is a map (a path string and a scalar value), specify the path string"
" during index_create, that is, :code:`parts={` :samp:`{field-number"
"},'{data-type}',path = '{path-name}'` :code:`}`. The index type must be "
"``'tree'`` or ``'hash'`` and the field's contents must always be maps "
"with the same path."
msgstr ""

msgid ""
"-- Example 1 -- The simplest use of path:\n"
"-- Result will be - - [{'age': 44}]\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('I',{parts={{field = 1, type = 'scalar', path = "
"'age'}}})\n"
"box.space.T:insert{{age=44}}\n"
"box.space.T:select(44)\n"
"-- Example 2 -- path plus format() plus JSON syntax to add clarity\n"
"-- Result will be: - [1, {'FIO': {'surname': 'Xi', 'firstname': "
"'Ahmed'}}]\n"
"s = box.schema.space.create('T')\n"
"format = {{'id', 'unsigned'}, {'data', 'map'}}\n"
"s:format(format)\n"
"parts = {{'data.FIO[\"firstname\"]', 'str'}, {'data.FIO[\"surname\"]', "
"'str'}}\n"
"i = s:create_index('info', {parts = parts})\n"
"s:insert({1, {FIO={firstname='Ahmed', surname='Xi'}}})"
msgstr ""

msgid ""
"**Note re storage engine:** vinyl supports only the TREE index type, and "
"vinyl secondary indexes must be created before tuples are inserted."
msgstr ""
"**Примечание про движок базы данных:** vinyl поддерживает только "
"TREE-индексы, и следует создать в vinyl'е вторичные индексы до вставки "
"кортежей."

msgid ""
"**Using the path option with [*]**  The string in a path option can "
"contain '[*]' which is called an array index placeholder. Indexes defined"
" with this are useful for JSON documents that all have the same "
"structure. For example, when creating an index on field#2 for a string "
"document that will start with ``{'data': [{'name': '...'}, {'name': "
"'...'}]``, the parts section in the create_index request could look like:"
" ``parts = {{field = 2, type = 'str', path = 'data[*].name'}}``. Then "
"tuples containing names can be retrieved quickly with "
"``index_object:select({key-value})``. In fact a single field can have "
"multiple keys, as in this example which retrieves the same tuple twice "
"because there are two keys 'A' and 'B' which both match the request:"
msgstr ""

msgid ""
"s = box.schema.space.create('json_documents')\n"
"s:create_index('primarykey')\n"
"i = s:create_index('multikey', {parts = {{field = 2, type = 'str', path ="
" 'data[*].name'}}})\n"
"s:insert({1,\n"
"         {data = {{name='A'},\n"
"                  {name='B'}},\n"
"          extra_field = 1}})\n"
"i:select({''},{iterator='GE'})\n"
"--  The result of the select request looks like this:\n"
"--  tarantool> i:select({''},{iterator='GE'})\n"
"--  ---\n"
"--  - - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"--    - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"--  ..."
msgstr ""

msgid ""
"Some restrictions exist: () '[*]' must be alone or must be at the end of "
"a name in the path; () '[*]' must not appear twice in the path; () if an "
"index has a path with x[*] then no other index can have a path with "
"x.component; () '[*]' must not appear in the path of a primary-key ; () "
"if an index has ``unique=true`` and has a path with '[*]' then duplicate "
"keys from different tuples are disallowed but duplicate keys for the same"
" tuple are allowed; () As with :ref:`Using the path option for map fields"
" <box_space-path>`, the field's value must have the structure that the "
"path definition implies, or be nil (nil is not indexed)."
msgstr ""

#, fuzzy
msgid "**Making a functional index with space_object:create_index()**"
msgstr "**Параметры для space_object:create_index()**"

msgid ""
"Functional indexes are indexes that call a user-defined function for "
"forming the index key, rather than depending entirely on the Tarantool "
"default formation. Functional indexes are useful for condensing or "
"truncating or reversing or any other way that users want to customize the"
" index."
msgstr ""

msgid ""
"The function definition must expect a tuple (which has the contents of "
"fields at the time a data-change request happens) and must return a tuple"
" (which has the contents that will actually be put in the index)."
msgstr ""

msgid ""
"The space must have a memtx engine. |br| The function must be "
":ref:`persistent <box_schema-func_create_with-body>` and deterministic. "
"|br| The key parts must not depend on JSON paths. |br| The "
"``create_index`` definition must include specification of all key parts, "
"and the function must return a table which has the same number of key "
"parts with the same types. |br| The function must access key-part values "
"by index, not by field name. |br| Functional indexes must not be primary-"
"key indexes. |br| Functional indexes cannot be altered and the function "
"cannot be changed if it is used for an index, so the only way to change "
"them is to drop the index and create it again."
msgstr ""

msgid "A function could make a key using only the first letter of a string field."
msgstr ""

msgid ""
"-- Step 1: Make the space.\n"
"-- The space needs a primary-key field, which is not the field that we\n"
"-- will use for the functional index.\n"
"box.schema.space.create('x', {engine = 'memtx'})\n"
"box.space.x:create_index('i',{parts={field = 1, type = 'string'}})\n"
"-- Step 2: Make the function.\n"
"-- The function expects a tuple. In this example it will work on tuple[2]"
"\n"
"-- because the key souce is field number 2 in what we will insert.\n"
"-- Use string.sub() from the string module to get the first character.\n"
"lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]\n"
"-- Step 3: Make the function persistent.\n"
"-- Use the box.schema.func.create function for this.\n"
"box.schema.func.create('F',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})\n"
"-- Step 4: Make the functional index.\n"
"-- Specify the fields whose values will be passed to the function.\n"
"-- Specify the function.\n"
"box.space.x:create_index('j',{parts={field = 1, type = 'string'},func = "
"'F'})\n"
"-- Step 5: Test.\n"
"-- Insert a few tuples.\n"
"-- Select using only the first letter, it will work because that is the "
"key\n"
"-- Or, select using the same function as was used for insertion\n"
"box.space.x:insert{'a', 'wombat'}\n"
"box.space.x:insert{'b', 'rabbit'}\n"
"box.space.x.index.j:select('w')\n"
"box.space.x.index.j:select(box.func.F:call({{'x', 'wombat'}}));"
msgstr ""

#, fuzzy
msgid "The results of the two ``select`` requests will look like this:"
msgstr "Результат будет выглядеть следующим образом:"

msgid ""
"tarantool>     box.space.x.index.j:select('w')\n"
"---\n"
"- - ['a', 'wombat']\n"
"...\n"
"\n"
"tarantool>     "
"box.space.x.index.j:select(box.func.F:call({{'x','wombat'}}));\n"
"---\n"
"- - ['a', 'wombat']\n"
"..."
msgstr ""

msgid ""
"Functions for functional indexes can return multiple keys. |br| Such "
"functions are called \"multikey\" functions. |br| The ``box.func.create``"
" options must include ``opts = {is_multikey = true}``. |br| The return "
"value must be a table of tuples. |br| If a multikey function returns N "
"tuples, then N keys will be added to the index."
msgstr ""

msgid ""
"s = box.schema.space.create('withdata')\n"
"s:format({{name = 'name', type = 'string'},\n"
"          {name = 'address', type = 'string'}})\n"
"pk = s:create_index('name', {parts = {field = 1, type = 'string'}})\n"
"lua_code = [[function(tuple)\n"
"               local address = string.split(tuple[2])\n"
"               local ret = {}\n"
"               for _, v in pairs(address) do\n"
"                 table.insert(ret, {utf8.upper(v)})\n"
"               end\n"
"               return ret\n"
"             end]]\n"
"box.schema.func.create('address',\n"
"                        {body = lua_code,\n"
"                         is_deterministic = true,\n"
"                         is_sandboxed = true,\n"
"                         opts = {is_multikey = true}})\n"
"idx = s:create_index('addr', {unique = false,\n"
"                              func = 'address',\n"
"                              parts = {{field = 1, type = 'string',\n"
"                                      collation = 'unicode_ci'}}})\n"
"s:insert({\"James\", \"SIS Building Lambeth London UK\"})\n"
"s:insert({\"Sherlock\", \"221B Baker St Marylebone London NW1 6XE UK\"})\n"
"idx:select('Uk')\n"
"-- Both tuples will be returned."
msgstr ""

msgid "Delete a tuple identified by a primary key."
msgstr "Удаление кортежа по первичному ключу."

msgid "the deleted tuple"
msgstr "удаленный кортеж."

msgid "**Complexity factors:** Index size, Index type"
msgstr "**Факторы сложности:** Размер индекса, тип индекса"

msgid ""
"**Note re storage engine:** vinyl will return ``nil``, rather than the "
"deleted tuple."
msgstr ""
"**Примечание про движок базы данных:** vinyl вернет ``nil``, а не "
"удаленный кортеж."

msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."

msgid ""
"For more usage scenarios and typical errors see :ref:`Example: using data"
" operations <box_space-operations-detailed-examples>` further in this "
"section."
msgstr ""
"Для получения дополнительной информации о сценариях использования и "
"типичных ошибках, см. :ref:`Пример: использование операций с данными "
"<box_space-operations-detailed-examples>` далее в разделе."

msgid ""
"Drop a space. The method is performed in background and doesn't block "
"consequent requests."
msgstr ""

msgid "nil"
msgstr "nil"

msgid "**Possible errors:** ``space_object`` does not exist."
msgstr "**Возможные ошибки:** ``space_object`` не существует."

msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes "
"accessed, WAL settings."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса, количество кортежей, к"
" которым получен доступ, настройки журнала упреждающей записи (WAL)."

msgid "box.space.space_that_does_not_exist:drop()"
msgstr "box.space.space_that_does_not_exist:drop()"

msgid "Declare field names and :ref:`types <index-box_data-types>`."
msgstr "Объявление имен и :ref:`типов <index-box_data-types>` полей."

msgid "a list of field names and types"
msgstr "список имен и типов полей"

msgid "nil, unless format-clause is omitted"
msgstr "nil, если не указан оператор формата"

msgid "``space_object`` does not exist;"
msgstr "``space_object`` не существует,"

msgid "field names are duplicated;"
msgstr "дублируются имена полей;"

msgid "type is not legal."
msgstr "тип не поддерживается."

msgid ""
"Ordinarily Tarantool allows unnamed untyped fields. But with ``format`` "
"users can, for example, document that the Nth field is the surname field "
"and must contain strings. It is also possible to specify a format clause "
"in :ref:`box.schema.space.create() <box_schema-space_create>`."
msgstr ""
"Как правило, Tarantool допускает поля без имен и без указания типа. Но с "
"помощью ``format`` можно, например, задокументировать, что N-ное поле "
"представляет собой поле для фамилии и должно содержать строковое "
"значение. Также оператор формата можно указать в "
":ref:`box.schema.space.create() <box_schema-space_create>`."

msgid ""
"The format clause contains, for each field, a definition within braces: "
"``{name='...',type='...'[,is_nullable=...]}``, where:"
msgstr ""
"Оператор формата для каждого поля содержит определение в фигурных "
"скобках: ``{name='...',type='...'[,is_nullable=...]}``, где:"

msgid ""
"the ``name`` value may be any string, provided that two fields do not "
"have the same name;"
msgstr ""
"значение ``name`` может представлять собой любую строку при условии, что "
"у двух полей не будет одинаковых имен;"

#, fuzzy
msgid ""
"the ``type`` value may be any of those allowed for :ref:`indexed fields "
"<index-box_indexed-field-types>`: unsigned | string | varbinary | integer"
" | number | double | boolean | decimal | array | scalar (the same as the "
"requirement in :ref:`\"Options for space_object:create_index\" "
"<box_space-create_index-options>`);"
msgstr ""
"значением ``type`` может быть любой допустимый тип для "
":ref:`индексируемых полей <index-box_indexed-field-types>`: unsigned | "
"string | integer | number | boolean | array | scalar (такое же "
"требование, как для :ref:`\"Параметров для space_object:create_index\" "
"<box_space-create_index-options>`);"

msgid ""
"the optional ``is_nullable`` value may be either ``true`` or ``false`` "
"(the same as the requirement in :ref:`\"Options for "
"space_object:create_index\" <box_space-create_index-options>`). See also "
"the warning notice in section :ref:`Allowing null for an indexed key "
"<box_space-is_nullable>`."
msgstr ""
"значение необязательного параметра ``is_nullable`` может быть ``true`` "
"или ``false`` (такое же требование, как для :ref:`\"Параметров для "
"space_object:create_index\" <box_space-create_index-options>`). См. также"
" предупреждение в разделе :ref:`Разрешение использования нулевых значений"
" для индексируемого ключа<box_space-is_nullable>`."

msgid ""
"It is not legal for tuples to contain values that have the wrong type; "
"for example after ``box.space.tester:format({{' ',type='number'}})`` the "
"request ``box.space.tester:insert{'string-which-is-not-a-number'}`` will "
"cause an error."
msgstr ""
"В кортежах недопустимы значения неправильного типа; например, после "
"``box.space.tester:format({{' ',type='number'}})`` (тип = число) запрос "
"``box.space.tester:insert{'строка-которая-не-является-числом'}`` вызовет "
"ошибку."

msgid ""
"It is not legal for tuples to contain null values if "
"``is_nullable=false``, which is the default; for example after "
"``box.space.tester:format({{' ',type='number',is_nullable=false}})`` the "
"request ``box.space.tester:insert{nil,2}`` will cause an error."
msgstr ""
"В кортежах недопустимы нулевые значения, если ``is_nullable=false``, что "
"задано по умолчанию; например, после ``box.space.tester:format({{' "
"',type='number',is_nullable=false}})`` запрос "
"``box.space.tester:insert{nil,2}`` вызовет ошибку."

msgid ""
"It is legal for tuples to have more fields than are described by a format"
" clause. The way to constrain the number of fields is to specify a "
"space's :ref:`field_count <box_space-field_count>` member."
msgstr ""
"В кортежах может быть больше полей, чем описано в операторе формата. "
"Чтобы ограничить количество полей, необходимо указать элемент спейса "
":ref:`field_count <box_space-field_count>`."

msgid ""
"It is legal for tuples to have fewer fields than are described by a "
"format clause, if the omitted trailing fields are described with "
"``is_nullable=true``; for example after "
"``box.space.tester:format({{'a',type='number'},{'b',type='number',is_nullable=true}})``"
" the request ``box.space.tester:insert{2}`` will not cause a format-"
"related error."
msgstr ""
"В кортежах может быть меньше полей, чем описано в операторе формата, если"
" пропущенные завершающие поля описаны с помощью ``is_nullable=true``; "
"например после "
"``box.space.tester:format({{'a',type='number'},{'b',type='number',is_nullable=true}})``"
" запрос ``box.space.tester:insert{2}`` не приведет к ошибке формата."

msgid ""
"It is legal to use ``format`` on a space that already has a format, thus "
"replacing any previous definitions, provided that there is no conflict "
"with existing data or index definitions."
msgstr ""
"Можно использовать ``format`` для спейса, в котором уже определен формат,"
" заменяя таким образом предыдущие определения при условии, что нет "
"конфликта с существующими данными или определениями индекса."

msgid ""
"It is legal to use ``format`` to change the ``is_nullable`` flag; for "
"example after ``box.space.tester:format({{' "
"',type='scalar',is_nullable=false}})`` the request "
"``box.space.tester:format({{' ',type='scalar',is_nullable=true}})`` will "
"not cause an error -- and will not cause rebuilding of the space. But "
"going the other way and changing ``is_nullable`` from ``true`` to "
"``false`` might cause rebuilding and might cause an error if there are "
"existing tuples with nulls."
msgstr ""
"Можно использовать ``format`` для того, чтобы изменить значение флага "
"``is_nullable``; например, после ``box.space.tester:format({{' "
"',type='scalar',is_nullable=false}})`` запрос "
"``box.space.tester:format({{' ',type='scalar',is_nullable=true}})`` не "
"вызовет ошибку -- и не приведет к перестроению спейса. Но обратное "
"изменение значения ``is_nullable`` с ``true`` на ``false`` может вызвать "
"перестроение и привести к ошибке, если уже есть кортежи с нулевыми "
"значениями."

msgid ""
"box.space.tester:format({{name='surname',type='string'},{name='IDX',type='array'}})"
"\n"
"box.space.tester:format({{name='surname',type='string',is_nullable=true}})"
msgstr ""
"box.space.tester:format({{name='surname',type='string'},{name='IDX',type='array'}})"
"\n"
"box.space.tester:format({{name='surname',type='string',is_nullable=true}})"

msgid "There are legal variations of the format clause:"
msgstr "Можно использовать следующие варианты оператора:"

msgid "omitting both 'name=' and 'type=',"
msgstr "пропуск и 'name=', и 'type=',"

msgid "omitting 'type=' alone, and"
msgstr "пропуск 'type=' и"

msgid "adding extra braces."
msgstr "добавление дополнительных фигурных скобок."

msgid ""
"The following examples show all the variations, first for one field named"
" 'x', second for two fields named 'x' and 'y'."
msgstr ""
"В следующем примере иллюстрируются все варианты, первый для поля с именем"
" 'x', второй -- для двух полей с именами 'x' и 'y'."

msgid ""
"box.space.tester:format({{'x'}})\n"
"box.space.tester:format({{'x'},{'y'}})\n"
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:format({{name='x',type='scalar'},{name='y',type='unsigned'}})"
"\n"
"box.space.tester:format({{name='x'}})\n"
"box.space.tester:format({{name='x'},{name='y'}})\n"
"box.space.tester:format({{'x',type='scalar'}})\n"
"box.space.tester:format({{'x',type='scalar'},{'y',type='unsigned'}})\n"
"box.space.tester:format({{'x','scalar'}})\n"
"box.space.tester:format({{'x','scalar'},{'y','unsigned'}})"
msgstr ""
"box.space.tester:format({{'x'}})\n"
"box.space.tester:format({{'x'},{'y'}})\n"
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:format({{name='x',type='scalar'},{name='y',type='unsigned'}})"
"\n"
"box.space.tester:format({{name='x'}})\n"
"box.space.tester:format({{name='x'},{name='y'}})\n"
"box.space.tester:format({{'x',type='scalar'}})\n"
"box.space.tester:format({{'x',type='scalar'},{'y',type='unsigned'}})\n"
"box.space.tester:format({{'x','scalar'}})\n"
"box.space.tester:format({{'x','scalar'},{'y','unsigned'}})"

msgid ""
"The following example shows how to create a space, format it with all "
"possible types, and insert into it."
msgstr ""
"В следующем примере показывается создание спейса, определение формата для"
" него со всеми возможными типа и вставка данных."

#, fuzzy
msgid ""
"tarantool> box.schema.space.create('t')\n"
"---\n"
"- engine: memtx\n"
"  before_replace: 'function: 0x4019c488'\n"
"  on_replace: 'function: 0x4019c460'\n"
"  ck_constraint: []\n"
"  field_count: 0\n"
"  temporary: false\n"
"  index: []\n"
"  is_local: false\n"
"  enabled: false\n"
"  name: t\n"
"  id: 534\n"
"- created\n"
"...\n"
"tarantool> ffi = require('ffi')\n"
"---\n"
"...\n"
"tarantool> decimal = require('decimal')\n"
"---\n"
"...\n"
"tarantool> box.space.t:format({{name = '1', type = 'any'},\n"
"         >                     {name = '2', type = 'unsigned'},\n"
"         >                     {name = '3', type = 'string'},\n"
"         >                     {name = '4', type = 'number'},\n"
"         >                     {name = '5', type = 'double'},\n"
"         >                     {name = '6', type = 'integer'},\n"
"         >                     {name = '7', type = 'boolean'},\n"
"         >                     {name = '8', type = 'decimal'},\n"
"         >                     {name = '9', type = 'scalar'},\n"
"         >                     {name = 'a', type = 'array'},\n"
"         >                     {name = 'b', type = 'map'}})\n"
"---\n"
"...\n"
"tarantool> box.space.t:create_index('i',{parts={2, type = 'unsigned'}})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  id: 0\n"
"  space_id: 534\n"
"  type: TREE\n"
"  name: i\n"
"...\n"
"tarantool> box.space.t:insert{{'a'}, -- any\n"
"         >                    1, -- unsigned\n"
"         >                    'W?', -- string\n"
"         >                    5.5, -- number\n"
"         >                    ffi.cast('double', 1), -- double\n"
"         >                    -0, -- integer\n"
"         >                    true, -- boolean\n"
"         >                    decimal.new(1.2), -- decimal\n"
"         >                    true, -- scalar\n"
"         >                    {{'a'}}, -- array\n"
"         >                    {val=1}} -- map\n"
"---\n"
"- [['a'], 1, 'W?', 5.5, 1, 0, true, 1.2, true, [['a']], {'val': 1}]\n"
"..."
msgstr ""
"tarantool> box.schema.space.create('t')\n"
"--- ...\n"
"tarantool> box.space.t:format({{name='1',type='any'},\n"
"         >                     {name='2',type='unsigned'},\n"
"         >                     {name='3',type='string'},\n"
"         >                     {name='4',type='number'},\n"
"         >                     {name='5',type='integer'},\n"
"         >                     {name='6',type='boolean'},\n"
"         >                     {name='7',type='scalar'},\n"
"         >                     {name='8',type='array'},\n"
"         >                     {name='9',type='map'}})\n"
"--- ...\n"
"tarantool> box.space.t:create_index('i',{parts={2,'unsigned'}})\n"
"--- ...\n"
"tarantool> box.space.t:insert{{'a'},      -- any\n"
"         >                    1,          -- unsigned\n"
"         >                    'W?',       -- string\n"
"         >                    5.5,        -- number\n"
"         >                    -0,         -- integer\n"
"         >                    true,       -- boolean\n"
"         >                    true,       -- scalar\n"
"         >                    {{'a'}},    -- array\n"
"         >                    {val=1}}    -- map\n"
"---\n"
"- [['a'], 1, 'W?', 5.5, 0, true, true, [['a']], {'val': 1}]\n"
"..."

msgid ""
"Names specified with the format clause can be used in "
":ref:`space_object:get() <box_space-get>` and in "
":ref:`space_object:create_index() <box_space-create_index>` and in "
":ref:`tuple_object[field-name] <box_tuple-field_name>` and in "
":ref:`tuple_object[field-path] <box_tuple-field_path>`."
msgstr ""
"Имена, указанные с помощью оператора формата, можно использовать в "
":ref:`space_object:get() <box_space-get>`, в "
":ref:`space_object:create_index() <box_space-create_index>`, в "
":ref:`tuple_object[field-name] <box_tuple-field_name>` и в "
":ref:`tuple_object[field-path] <box_tuple-field_path>`."

msgid ""
"If the format clause is omitted, then the returned value is the table "
"that was used in a previous :samp:`{space_object}:format({format-"
"clause})` invocation. For example, after "
"``box.space.tester:format({{'x','scalar'}})``, "
"``box.space.tester:format()`` will return ``[{'name': 'x', 'type': "
"'scalar'}]``."
msgstr ""
"Если оператор формата не указан, то вернется таблица, которая "
"использовалась при предыдущем вызове "
":samp:`{объект-спейса}:format({оператор-формата})`. Например, после "
"``box.space.tester:format({{'x','scalar'}})``, "
"``box.space.tester:format()`` вернет ``[{'name': 'x', 'type': "
"'scalar'}]``."

msgid ""
"Formatting or reformatting a large space will cause occasional "
":ref:`yields <atomic-cooperative_multitasking>` so that other requests "
"will not be blocked. If the other requests cause an illegal situation "
"such as a field value of the wrong type, the formatting or reformatting "
"will fail."
msgstr ""

msgid ""
"Convert a map to a tuple instance or to a table. The map must consist of "
"\"field name = value\" pairs. The field names and the value types must "
"match names and types stated previously for the space, via "
":ref:`space_object:format() <box_space-format>`."
msgstr ""
"Конвертация ассоциативного массива в экземпляр кортежа или в таблицу. "
"Ассоциативный массив должен состоять из пар \"имя поля = значение\". "
"Имена полей и типы значений должны соответствовать именам и типам, ранее "
"заданным для спейса через :ref:`space_object:format() <box_space-"
"format>`."

msgid "a series of \"field = value\" pairs, in any order."
msgstr "ряд пар \"поле = значение\" в любом порядке."

msgid ""
"the only legal option is ``{table = true|false}``; |br| if the option is "
"omitted or if ``{table = false}``, then return type will be 'cdata' (i.e."
" tuple); |br| if ``{table = true}``, then return type will be 'table'."
msgstr ""
"единственный возможный параметр ``{table = true|false}``; |br| если "
"параметр не указан, или же ``{table = false}``, то возвращается 'cdata' "
"(то есть кортеж); |br| если ``{table = true}``, то возвращается таблица."

msgid "a tuple instance or table."
msgstr "кортеж или таблица."

msgid "tuple or table"
msgstr "кортеж или таблица"

msgid ""
"**Possible errors:** ``space_object`` does not exist or has no format; "
"\"unknown field\"."
msgstr ""
"**Возможные ошибки:** отсутствует объект спейса ``space_object``, или в "
"спейсе нет формата; \"unknown field\" (неизвестное поле)."

msgid ""
"-- Create a format with two fields named 'a' and 'b'.\n"
"-- Create a space with that format.\n"
"-- Create a tuple based on a map consistent with that space.\n"
"-- Create a table based on a map consistent with that space.\n"
"tarantool> format1 = "
"{{name='a',type='unsigned'},{name='b',type='scalar'}}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.create_space('test', {format = format1})\n"
"---\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456})\n"
"---\n"
"- [123456, 'x']\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456}, {table = true})\n"
"---\n"
"- - 123456\n"
"  - x\n"
"..."
msgstr ""
"-- Создание формата с двумя полями под названиями 'a' и 'b'.\n"
"-- Создание спейса с таким форматом.\n"
"-- Создание кортежа на основе ассоциативного массива по данному спейсу.\n"
"-- Создание таблицы на основе ассоциативного массива по данному спейсу.\n"
"tarantool> format1 = "
"{{name='a',type='unsigned'},{name='b',type='scalar'}}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.create_space('test', {format = format1})\n"
"---\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456})\n"
"---\n"
"- [123456, 'x']\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456}, {table = true})\n"
"---\n"
"- - 123456\n"
"  - x\n"
"..."

msgid "Search for a tuple in the given space."
msgstr "Поиск кортежа в данном спейсе."

msgid "value to be matched against the index key, which may be multi-part."
msgstr "значение должно совпасть с индексным ключом, который может быть составным."

msgid "the tuple whose index key matches ``key``, or ``nil``."
msgstr "кортеж, ключ индекса в котором совпадает с ``key`` или ``nil``."

msgid ""
"The ``box.space...select`` function returns a set of tuples as a Lua "
"table; the ``box.space...get`` function returns at most a single tuple. "
"And it is possible to get the first tuple in a space by appending "
"``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as "
"``box.space.tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""
"Функция ``box.space...select`` вернет набор кортежей в виде Lua-таблицы; "
"функция ``box.space...get`` вернет самое большее один кортеж. Можно "
"получить первый кортеж в спейсе, добавив ``[1]``. Таким образом, "
"``box.space.tester:get{1}`` эквивалентна "
"``box.space.tester:select{1}[1]``, если найден только один кортеж."

msgid "box.space.tester:get{1}"
msgstr "box.space.tester:get{1}"

#, fuzzy
msgid ""
"**Using field names instead of field numbers:** `get()` can use field "
"names described by the optional :ref:`space_object:format() <box_space-"
"format>` clause. This is true because the object returned by ``get()`` "
"can be used with most of the features described in the :ref:`Submodule "
"box.tuple <box_tuple>` description, including :ref:`tuple_object[field-"
"name] <box_tuple-field_name>`."
msgstr ""
"**Использование имен полей вместо номеров полей:** в `get()` можно "
"использовать имена полей, описанные в необязательном операторе "
":ref:`space_object:format() <box_space-format>`. Это аналогично "
"стандартной Lua-функции, где на компонент можно ссылаться по имени, а не "
"по номеру. Например, может форматировать спейс `tester` с полем под "
"названием `x` и использовать имя `x` в определении индекса:"

msgid ""
"For example, we can format the `tester` space with a field named `x` and "
"use the name `x` in the index definition:"
msgstr ""

msgid ""
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:create_index('I',{parts={'x'}})"
msgstr ""
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:create_index('I',{parts={'x'}})"

#, fuzzy
msgid ""
"Then, if ``get`` or ``select`` retrieves a single tuple, we can reference"
" the field 'x' in the tuple by its name:"
msgstr ""
"Тогда если ``get`` или ``select`` вернут отдельный кортеж, можно "
"сослаться на поле 'x' в кортеже по имени:"

msgid ""
"box.space.tester:get{1}['x']\n"
"box.space.tester:select{1}[1]['x']"
msgstr ""
"box.space.tester:get{1}['x']\n"
"box.space.tester:select{1}[1]['x']"

msgid "Insert a tuple into a space."
msgstr "Вставка кортежа в спейс."

msgid "tuple to be inserted."
msgstr "вставляемый кортеж."

msgid "the inserted tuple"
msgstr "вставленный кортеж"

msgid ""
"**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a tuple with the same "
"unique-key value already exists."
msgstr ""
"**Возможные ошибки:** ошибка :errcode:`ER_TUPLE_FOUND`, если уже "
"существует кортеж с тем же уникальным значением ключа."

msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."

msgid ""
"Return the number of tuples in the space. If compared with :ref:`count() "
"<box_space-count>`, this method works faster because ``len()`` does not "
"scan the entire space to count the tuples."
msgstr ""
"Возврат количества кортежей в спейсе. Если сравнивать с :ref:`count() "
"<box_space-count>`, то данный метод работает быстрее, поскольку метод "
"``len()`` не сканирует весь спейс для подсчета кортежей."

msgid "Number of tuples in the space."
msgstr "Количество кортежей в спейсе."

msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."

msgid ""
"**Note re storage engine:** vinyl supports ``len()`` but the result may "
"be approximate. If an exact result is necessary then use :ref:`count() "
"<box_space-count>` or :ref:`pairs():length() <box_space-pairs>`."
msgstr ""
"**Примечание про движок базы данных:** vinyl поддерживает ``len()``, но "
"результат может быть неточным. Если необходим точный результат, "
"используйте :ref:`count() <box_space-count>` или :ref:`pairs():length() "
"<box_space-pairs>`."

msgid ""
"Create a \"replace :ref:`trigger <triggers>`\". The ``trigger-function`` "
"will be executed whenever a ``replace()`` or ``insert()`` or ``update()``"
" or ``upsert()`` or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""
"Создание \":ref:`триггера <triggers>` замены\". Функция с триггером "
"``trigger-function`` будет выполняться в случае операции ``replace()`` "
"или ``insert()``, или ``update()``, или ``upsert()``, или ``delete()`` "
"над кортежем в спейсе ``<space-name>``."

msgid ""
"function which will become the trigger function; see Example #2 below for"
" details about trigger function parameters"
msgstr ""
"функция, в которой будет триггер; для получения информации о параметрах "
"функции с триггером см. Пример №2 ниже"

msgid "existing trigger function which will be replaced by ``trigger-function``"
msgstr ""
"существующая функция с триггером, которую заменит новая ``trigger-"
"function``"

msgid "nil or function pointer"
msgstr "nil или указатель функции"

msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger "
"is deleted."
msgstr ""
"Если указаны параметры (nil, old-trigger-function), старый триггер будет "
"удален."

msgid ""
"If both parameters are omitted, then the response is a list of existing "
"trigger functions."
msgstr ""
"Если не указан ни один параметр, ответом будет список существующих "
"функций с триггером."

msgid ""
"If it is necessary to know whether the trigger activation happened due to"
" replication or on a specific connection type, the function can refer to "
":ref:`box.session.type() <box_session-type>`."
msgstr ""
"Следует знать, что если активация триггера произошла в случае репликации "
"или определенного вида подключения, функция может ссылаться на "
":ref:`box.session.type() <box_session-type>`."

msgid ""
"Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""
"Подробная информация о характеристиках триггера находится в разделе "
":ref:`Триггеры <triggers-box_triggers>`."

msgid "See also :ref:`space_object:before_replace() <box_space-before_replace>`."
msgstr "См. также :ref:`space_object:before_replace() <box_space-before_replace>`."

msgid "**Example #1:**"
msgstr "**Пример №1:**"

msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"

msgid "**Example #2:**"
msgstr "**Пример №2:**"

msgid "The ``trigger-function`` can have up to four parameters:"
msgstr "В функции с триггером может быть до 4 параметров:"

msgid "(tuple) old value which has the contents before the request started,"
msgstr "(кортеж) старое значение до начала запроса,"

msgid "(tuple) new value which has the contents after the request ended,"
msgstr "(кортеж) новое значение после окончания выполнения запроса,"

msgid "(string) space name,"
msgstr "(строка) имя спейса,"

msgid ""
"(string) type of request which is 'INSERT', 'DELETE', 'UPDATE', or "
"'REPLACE'."
msgstr ""
"(строка) тип запроса: 'INSERT' (вставка), 'DELETE' (удаление), 'UPDATE' "
"(обновление) или 'REPLACE' (замена)."

msgid ""
"For example, the following code causes nil and 'INSERT' to be printed "
"when the insert request is processed, and causes [1, 'Hi'] and 'DELETE' "
"to be printed when the delete request is processed:"
msgstr ""
"Например, следующий код вызывает вывод nil и 'INSERT' (вставка) при "
"обработке запроса на вставку и вывод [1, 'Hi'] и 'DELETE' (удаление) при "
"обработке запроса на удаление:"

msgid ""
"box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new, s, op) print(old) print(op) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"
msgstr ""

msgid "**Example #3:**"
msgstr "**Пример №3:**"

msgid ""
"The following series of requests will create a space, create an index, "
"create a function which increments a counter, create a trigger, do two "
"inserts, drop the space, and display the counter value - which is 2, "
"because the function is executed once after each insert."
msgstr ""
"Следующая серия запросов создаст спейс, создаст индекс, создаст функцию, "
"которая увеличит содержимое счетчика, создаст триггер, сделает две "
"вставки, удалит спейс и отобразит значение счетчика -- 2, поскольку "
"функция выполняется однократно после каждой вставки."

msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {{field = 1, type = "
"'unsigned'}}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

msgid ""
"You shouldn't use in trigger-functions for ``on_replace`` and "
"``before_replace``"
msgstr ""

msgid "transactions,"
msgstr ""

msgid "yield-oprations (:ref:`explicit <atomic-implicit-yields>` or not),"
msgstr ""

msgid ""
"actions that are not allowed to be used in transactions (see :ref:`rule "
"#2 <box-txn_management>`)"
msgstr ""

msgid "because everything executed inside triggers is already in a transaction."
msgstr ""

msgid ""
"tarantool> box.space.test:on_replace(fiber.yield)\n"
"tarantool> box.space.test:replace{1, 2, 3}\n"
"2020-02-02 21:22:03.073 [73185] main/102/init.lua txn.c:532 E> "
"ER_TRANSACTION_YIELD: Transaction has been aborted by a fiber yield\n"
"---\n"
"- error: Transaction has been aborted by a fiber yield\n"
"..."
msgstr ""

msgid ""
"function which will become the trigger function; for the trigger "
"function's optional parameters see the description of :ref:`on_replace "
"<box_space-on_replace>`."
msgstr ""
"функция, в которой будет триггер; необязательные параметры функции с "
"триггером см. в описании :ref:`on_replace <box_space-on_replace>`."

msgid ""
"If the parameters are ``(nil, old-trigger-function)``, then the old "
"trigger is deleted."
msgstr ""
"Если указаны параметры ``(nil, old-trigger-function)``, старый триггер "
"будет удален."

msgid "See also :ref:`space_object:on_replace() <box_space-on_replace>`."
msgstr "См. также :ref:`space_object:on_replace() <box_space-on_replace>`."

msgid ""
"Administrators can make replace triggers with ``on_replace()``, or make "
"triggers with ``before_replace()``. If they make both types, then all "
"``before_replace`` triggers are executed before all ``on_replace`` "
"triggers. The functions for both ``on_replace`` and ``before_replace`` "
"triggers can make changes to the database, but only the functions for "
"``before_replace`` triggers can change the tuple that is being replaced."
msgstr ""
"Администраторы могут создавать триггеры замены с условием после замены "
"``on_replace()`` или до замены ``before_replace()``. Если созданы оба "
"типа, то все триггеры до замены ``before_replace`` выполняются до всех "
"триггеров после замены ``on_replace``. Функции для обоих типов триггеров "
"``on_replace`` и ``before_replace`` могут вносить изменения в базу "
"данных, но только функции с триггерами до замены ``before_replace`` могут"
" изменять кортеж, который будет заменен."

msgid ""
"Since a ``before_replace`` trigger function has the extra capability of "
"making a change to the old tuple, it also can have extra overhead, to "
"fetch the old tuple before making the change. Therefore an ``on_replace``"
" trigger is better if there is no need to change the old tuple. However, "
"this only applies for the memtx engine -- for the vinyl engine, the fetch"
" will happen for either kind of trigger. (With memtx the tuple data is "
"stored along with the index key so no extra search is necessary; with "
"vinyl that is not the case so the extra search is necessary.)"
msgstr ""
"Поскольку функция с триггером до замены ``before_replace`` может вносить "
"дополнительные изменения в старый кортеж, для нее также потребуются "
"дополнительные ресурсы для вызова старого кортежа до внесения изменений. "
"Таким образом, лучше использовать триггер после замены ``on_replace``, "
"если нет необходимости изменять старый кортеж. Тем не менее, это "
"применимо только к движку memtx -- что касается движка vinyl, такой вызов"
" произойдет для любого типа триггера. (В memtx'е данные кортежа хранятся "
"вместе с ключом индекса, поэтому нет необходимости в дополнительном "
"поиске; для vinyl'а дело обстоит иначе, поэтому нужен дополнительный "
"поиск.)"

msgid ""
"Where the extra capability is not needed, ``on_replace`` should be used "
"instead of ``before_replace``. Usually ``before_replace`` is used only "
"for certain replication scenarios -- it is useful for conflict "
"resolution."
msgstr ""
"Если нет необходимости в дополнительных изменениях, следует использовать "
"``on_replace`` вместо ``before_replace``. Как правило, ``before_replace``"
" используется только для определенных сценариев репликации -- в части "
"разрешения конфликтов."

msgid ""
"The value that a ``before_replace`` trigger function can return affects "
"what will happen after the return. Specifically:"
msgstr ""
"Что случится после возврата значения, которое может вернуть функция с "
"триггером ``before_replace``, зависит от этого значения. А именно:"

msgid ""
"if there is no return value, then execution proceeds, inserting|replacing"
" the new value;"
msgstr ""
"если нет возвращаемого значения, выполнение продолжается со "
"вставкой|заменой нового значения;"

msgid "if the value is nil, then the tuple will be deleted;"
msgstr "если значение -- nil, то кортеж будет удален;"

msgid ""
"if the value is the same as the old parameter, then no `on_replace`` "
"function will be called and the data change will be skipped"
msgstr ""
"если значение совпадает со старым, то вызывается функция ``on_replace``, "
"и изменение данных не происходит"

msgid ""
"if the value is the same as the new parameter, then it's as if the "
"``before_replace`` function wasn't called;"
msgstr ""
"если значение совпадает с новым, то считаем, что вызова функции "
"``before_replace`` не было;"

msgid ""
"if the value is something else, then execution proceeds, "
"inserting|replacing the new value."
msgstr ""
"если значение другое, выполнение продолжается со вставкой|заменой нового "
"значения."

msgid ""
"However, if a trigger function returns an old tuple, or if a trigger "
"function calls :ref:`run_triggers(false) <box_space-run_triggers>`, that "
"will not affect other triggers that are activated for the same "
"insert|update|replace request."
msgstr ""
"Тем не менее, если функция с триггером возвращает старый кортеж или "
"вызывает :ref:`run_triggers(false) <box_space-run_triggers>`, это не "
"повлияет на другие триггеры, активируемые в том же запросе вставки, "
"обновления или замены."

msgid ""
"The following are ``before_replace`` functions that have no return value,"
" or that return nil, or the same as the old parameter, or the same as the"
" new parameter, or something else."
msgstr ""
"Далее представлены функции ``before_replace``: не возвращает значение, "
"возвращает nil, возвращает совпадающее со старым значение, возвращает "
"совпадающее с новым значение, возвращает другое значение."

msgid ""
"function f1 (old, new) return end\n"
"function f2 (old, new) return nil end\n"
"function f3 (old, new) return old end\n"
"function f4 (old, new) return new end\n"
"function f5 (old, new) return box.tuple.new({new[1],'b'}) end"
msgstr ""
"function f1 (old, new) return end\n"
"function f2 (old, new) return nil end\n"
"function f3 (old, new) return old end\n"
"function f4 (old, new) return new end\n"
"function f5 (old, new) return box.tuple.new({new[1],'b'}) end"

msgid ""
"Search for a tuple or a set of tuples in the given space, and allow "
"iterating over one tuple at a time."
msgstr ""
"Поиск кортежа или набора кортежей в заданном спейсе и итерация по одному "
"кортежу за раз."

msgid "value to be matched against the index key, which may be multi-part"
msgstr "значение должно совпасть с индексным ключом, который может быть составным"

msgid "see :ref:`index_object:pairs <box_index-index_pairs>`"
msgstr "см. :ref:`index_object:pairs <box_index-index_pairs>`"

#, fuzzy
msgid ""
"`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a "
"for/end loop or with `totable() "
"<https://luafun.github.io/reducing.html#fun.totable>`_"
msgstr ""
"`итератор <https://www.lua.org/pil/7.1.html>`_, который может "
"использовать в цикле for/end или с функцией `totable() "
"<https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_"

msgid "no such space;"
msgstr "отсутствие такого спейса."

msgid "wrong type."
msgstr "неправильный тип."

msgid "**Complexity factors:** Index size, Index type."
msgstr "**Факторы сложности:** Размер индекса, тип индекса."

msgid ""
"For examples of complex ``pairs`` requests, where one can specify which "
"index to search and what condition to use (for example \"greater than\" "
"instead of \"equal to\"), see the later section :ref:`index_object:pairs "
"<box_index-index_pairs>`."
msgstr ""
"Чтобы посмотреть примеры сложных запросов ``pairs``, где можно указать "
"индекс для поиска и используемое условие (например, \"больше чем\" вместо"
" \"равен\"), см. раздел далее по тексту :ref:`index_object:pairs "
"<box_index-index_pairs>`."

msgid ""
"For information about iterators' internal structures see the `\"Lua "
"Functional library\" <https://luafun.github.io/index.html>`_ "
"documentation."
msgstr ""
"Для получения информации о внутренней структуре итераторов см. "
"документацию по библиотеке для функционального программирования в Lua "
"`\"Lua Functional library\" <https://luafun.github.io/index.html>`_."

msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- в индексе 'X' количество частей по умолчанию {1, "
"'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."

msgid "Rename a space."
msgstr "Переименование спейса."

msgid "new name for space"
msgstr "новое имя спейса"

msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."

msgid ""
"Insert a tuple into a space. If a tuple with the same primary key already"
" exists, ``box.space...:replace()`` replaces the existing tuple with a "
"new one. The syntax variants ``box.space...:replace()`` and "
"``box.space...:put()`` have the same effect; the latter is sometimes used"
" to show that the effect is the converse of ``box.space...:get()``."
msgstr ""
"Вставка кортежа в спейс. Если уже существует кортеж с тем же первичным "
"ключом, ``box.space...:replace()`` заменит существующий кортеж новым. "
"Варианты синтаксиса (``box.space...:replace()`` и ``box.space...:put()``)"
" приведут к одному результату, но последний иногда используется как "
"противоположность ``box.space...:get()``."

msgid "tuple to be inserted"
msgstr "вставляемый кортеж"

msgid ""
"**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a different tuple with "
"the same unique-key value already exists. (This will only happen if there"
" is a unique secondary index.)"
msgstr ""
"**Возможные ошибки:** ошибка :errcode:`ER_TUPLE_FOUND`, если уже "
"существует другой кортеж с тем же уникальным значением ключа (это "
"произойдет только в том случае, если есть уникальный вторичный индекс)."

msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr "box.space.tester:replace{5000, 'tuple number five thousand'}"

msgid ""
"At the time that a :ref:`trigger <triggers>` is defined, it is "
"automatically enabled - that is, it will be executed. :ref:`Replace "
"<box_space-on_replace>` triggers can be disabled with :samp:`box.space"
".{space-name}:run_triggers(false)` and re-enabled with :samp:`box.space"
".{space-name}:run_triggers(true)`."
msgstr ""
"На тот момент, когда :ref:`триггер <triggers>` определен, он "
"автоматически активируется, то есть он будет исполняться. Триггеры "
":ref:`для замены <box_space-on_replace>` можно отключить с помощью "
":samp:`box.space.{имя-спейса}:run_triggers(false)` и повторно "
"активировать с помощью :samp:`box.space.{имя-спейса}:run_triggers(true)`."

msgid ""
"The following series of requests will associate an existing function "
"named `F` with an existing space named `T`, associate the function a "
"second time with the same space (so it will be called twice), disable all"
" triggers of `T`, and delete each trigger by replacing with ``nil``."
msgstr ""
"Следующая серия запросов ассоциирует существующую функцию с именем `F` с "
"существующим спейсом с именем `T`, ассоциирует функцию во второй раз с "
"тем же спейсом (чтобы вызвать ее дважды), отключит все триггеры на `T` и "
"удалит каждый триггер, заменив его на ``nil``."

msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"

msgid "Search for a tuple or a set of tuples in the given space."
msgstr "Поиск кортежа или набора кортежей в заданном спейсе."

msgid ""
"none, any or all of the same options that :ref:`index_object:select "
"<box_index-select>` allows:  * ``options.iterator`` (:ref:`type of "
"iterator <box_index-iterator-types>`) * ``options.limit`` (maximum number"
" of tuples) * ``options.offset`` (number of tuples to skip)"
msgstr ""
"ни один, любой или все параметры, которые допускает "
":ref:`index_object:select <box_index-select>`:  * ``options.iterator`` "
"(:ref:`тип итератора <box_index-iterator-types>`) * ``options.limit`` "
"(максимальное количество кортежей) * ``options.offset`` (количество "
"пропускаемых кортежей)"

msgid ""
"none, any or all of the same options that :ref:`index_object:select "
"<box_index-select>` allows:"
msgstr ""
"ни один, любой или все параметры, которые допускает "
":ref:`index_object:select <box_index-select>`:"

msgid "``options.iterator`` (:ref:`type of iterator <box_index-iterator-types>`)"
msgstr "``options.iterator`` (:ref:`тип итератора <box_index-iterator-types>`)"

msgid "``options.limit`` (maximum number of tuples)"
msgstr "``options.limit`` (максимальное количество кортежей)"

msgid "``options.offset`` (number of tuples to skip)"
msgstr "``options.offset`` (количество пропускаемых кортежей)"

msgid ""
"the tuples whose primary-key fields are equal to the fields of the passed"
" key. If the number of passed fields is less than the number of fields in"
" the primary key, then only the passed fields are compared, so "
"``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""
"кортежи, поля первичного ключа в которых равны полям переданного ключа. "
"Если количество переданных полей меньшей количества полей первичного "
"ключа, сопоставляются только переданные поля, то есть для ``select{1,2}``"
" совпадением будет кортеж с первичным ключом ``{1,2,3}``."

msgid "array of tuples"
msgstr "массив кортежей"

msgid ""
"A ``select`` request can also be done with a specific index and index "
"options, which are the subject of :ref:`index_object:select <box_index-"
"select>`."
msgstr ""
"Запрос выборки ``select`` также можно выполнить со специальными "
"параметрами индекса, которые указаны в :ref:`index_object:select "
"<box_index-select>`."

msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = { {field = 1, type = "
"'unsigned'}, {field = 2, type = 'string'}} })\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"...\n"
"tarantool> -- the first field must be greater than 0, and\n"
"tarantool> -- skip the first tuple, and return up to\n"
"tarantool> -- 2 tuples. This example's options all\n"
"tarantool> -- depend on index characteristics so see\n"
"tarantool> -- more explanation in index_object:select().\n"
"tarantool> s:select({0},{iterator='GT',offset=1,limit=2})\n"
"---\n"
"- - [1, 'B']\n"
"  - [1, 'C']\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = { {field = 1, type = "
"'unsigned'}, {field = 2, type = 'string'}} })\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- необходимо совпадение с двумя полями первичного ключа\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- необходимо совпадение только одного поля первичного ключа\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- необходимо совпадение с 0 полей, поэтому возвращает все "
"кортежи\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"...\n"
"tarantool> -- первое поле должно быть больше 0,\n"
"tarantool> -- пропуск первого кортежа и возврат до\n"
"tarantool> -- 2 кортежей. Все параметры в данном примере\n"
"tarantool> -- зависят от характеристик индекса, поэтому см.\n"
"tarantool> -- более подробное описание в index_object:select().\n"
"tarantool> s:select({0},{iterator='GT',offset=1,limit=2})\n"
"---\n"
"- - [1, 'B']\n"
"  - [1, 'C']\n"
"..."

msgid ""
"As the last request in the above example shows: to make complex "
"``select`` requests, where you can specify which index to search and what"
" condition to use (for example \"greater than\" instead of \"equal to\") "
"and how many tuples to return, it will be necessary to become familiar "
"with :ref:`index_object:select <box_index-select>`."
msgstr ""
"Как показано в последнем запросе вышеприведенного примера, чтобы "
"выполнять сложные запросы выборки ``select``, где можно указать, в каком "
"индексе производится поиск и с какими условиями (например, \"больше, "
"чем\" вместо \"равный\"), а также необходимое количество возвращаемых "
"кортежей, необходимо ознакомиться с :ref:`index_object:select <box_index-"
"select>`."

msgid ""
"Remember that you can get a field from a tuple both by field number and "
"by field name which is more convenient. See example: :ref:`using field "
"names instead of field numbers <box_space-get_field_names>`."
msgstr ""

msgid ""
"Deletes all tuples. The method is performed in background and doesn't "
"block consequent requests."
msgstr ""

msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""
"**Факторы сложности:** Размер индекса, тип индекса, количество кортежей, "
"к которым получен доступ."

msgid ""
"The ``truncate`` method can only be called by the user who created the "
"space, or from within a ``setuid`` function created by the user who "
"created the space. Read more about `setuid` functions in the reference "
"for :ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""
"Метод ``truncate`` может вызвать только тот пользователь, который создал "
"спейс, или другой пользователь через функцию ``setuid``, созданную "
"пользователем, который создал спейс. Более подробную информацию о "
"функциях `setuid` можно получить в справочнике по for "
":ref:`box.schema.func.create() <box_schema-func_create>`."

msgid "The ``truncate`` method cannot be called from within a transaction."
msgstr "Метод ``truncate`` нельзя вызвать из транзакции."

msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."

msgid "Update a tuple."
msgstr "Обновление кортежа."

#, fuzzy
msgid ""
"The ``update`` function supports operations on fields — assignment, "
"arithmetic (if the field is numeric), cutting and pasting fragments of a "
"field, deleting or inserting a field. Multiple operations can be combined"
" in a single update request, and in this case they are performed "
"atomically and sequentially. Each operation requires specification of a "
"field identifier, which is usually a number. When multiple operations are"
" present, the field number for each operation is assumed to be relative "
"to the most recent state of the tuple, that is, as if all previous "
"operations in a multi-operation update have already been applied. In "
"other words, it is always safe to merge multiple ``update`` invocations "
"into a single invocation, with no change in semantics."
msgstr ""
"Функция ``update`` поддерживает операции над полями -- присваивание, "
"арифметические операции (если поле числовое), вырезание и вставку "
"фрагментов поля, удаление или вставку поля. Несколько операций можно "
"объединить в отдельный запрос обновления, и в таком случае они будут "
"выполняться атомарно и последовательно. Для каждой операции необходимо "
"указать номер поля. Если выполняются несколько операций, то номер поля "
"для каждой операции считается относительно последнего состояния кортежа, "
"то есть как если бы все предыдущие операции в обновлении с несколькими "
"операциями уже были выполнены. Другими словами, всегда лучше объединить "
"несколько вызовов  ``update`` в один без изменений семантики."

msgid "Possible operators are:"
msgstr "Возможные операторы:"

#, fuzzy
msgid "``+`` for addition. values must be numeric, e.g. unsigned or decimal"
msgstr "``+`` для сложения (значения должны быть числовыми)"

#, fuzzy
msgid "``-`` for subtraction. values must be numeric"
msgstr "``-`` для вычитания (значения должны быть числовыми)"

#, fuzzy
msgid "``&`` for bitwise AND. values must be unsigned numeric"
msgstr ""
"``&`` для поразрядной операции И (значения должны быть беззнаковыми "
"числами)"

#, fuzzy
msgid "``|`` for bitwise OR. values must be unsigned numeric"
msgstr ""
"``|`` для поразрядной операции ИЛИ (значения должны быть беззнаковыми "
"числами)"

#, fuzzy
msgid ""
"``^`` for bitwise :abbr:`XOR(exclusive OR)`. values must be unsigned "
"numeric"
msgstr ""
"``^`` для поразрядной операции Исключающее ИЛИ (значения должны быть "
"беззнаковыми числами)"

#, fuzzy
msgid "``:`` for string splice."
msgstr "``:`` для разделения строк"

#, fuzzy
msgid "``!`` for insertion of a new field."
msgstr "``!`` для вставки"

#, fuzzy
msgid "``#`` for deletion."
msgstr "``#`` для удаления"

#, fuzzy
msgid "``=`` for assignment."
msgstr "``=`` для присваивания"

#, fuzzy
msgid "Possible field_identifiers are:"
msgstr "Возможные операторы:"

msgid ""
"Positive field number. The first field is 1, the second field is 2, and "
"so on."
msgstr ""

msgid ""
"Negative field number. The last field is -1, the second-last field is -2,"
" and so on. In other words: (#tuple + negative field number + 1)."
msgstr ""

#, fuzzy
msgid ""
"Name. If the space was formatted with :ref:`space_object:format() "
"<box_space-format>`, then this can be a string for the field 'name'."
msgstr ""
"Если первоначальный кортеж приходит из спейса, который был форматирован "
"посредством :ref:`оператора формата <box_space-format>`, форматирование "
"возвращаемого кортежа сохранится."

msgid "operation type represented in string"
msgstr "тип операции, представленный строкой"

msgid "what field the operation will apply to."
msgstr ""

msgid "what value will be applied"
msgstr "какое значение применяется"

msgid "the updated tuple."
msgstr "обновленный кортеж."

msgid "**Possible errors:** it is illegal to modify a primary-key field."
msgstr "**Возможные ошибки:** нельзя изменять поле первичного ключа."

msgid ""
"**Complexity factors:** Index size, Index type, number of indexes "
"accessed, WAL settings."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса, количество кортежей, к"
" которым получен доступ, настройки журнала упреждающей записи (WAL)."

msgid "Thus, in the instruction:"
msgstr "Таким образом, в инструкции:"

msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"

msgid ""
"the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` "
"meaning *add a value to a field and then assign a value to a field*, the "
"first affected field is field ``1`` and the value which will be added to "
"it is ``55``, the second affected field is field ``3`` and the value "
"which will be assigned to it is ``'x'``."
msgstr ""
"значение первичного ключа равно ``44``, заданы операторы ``'+'`` и "
"``'='``, что означает *прибавление значение к полю, а затем присваивание "
"значения полю*, первое затронутое поле -- это поле ``1``, к нему "
"прибавляется значение ``55``, второе затронутое поле -- это поле ``3``, "
"ему присваивается значение ``'x'``."

msgid ""
"Assume that initially there is a space named ``tester`` with a primary-"
"key index whose type is ``unsigned``. There is one tuple, with "
"``field[1]`` = ``999`` and ``field[2]`` = ``'A'``."
msgstr ""
"Предположим, что изначально есть спейс под названием ``tester`` с "
"первичным индексом, тип которого -- ``unsigned``. Есть один кортеж с "
"полем №1 ``field[1]`` = ``999`` и полем №2 ``field[2]`` = ``'A'``."

msgid ""
"In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` "
"|br| The first argument is ``tester``, that is, the affected space is "
"``tester``. The second argument is ``999``, that is, the affected tuple "
"is identified by primary key value = 999. The third argument is ``=``, "
"that is, there is one operation — *assignment to a field*. The fourth "
"argument is ``2``, that is, the affected field is ``field[2]``. The fifth"
" argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. "
"Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = "
"``'B'``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` |br|"
" Первый аргумент -- это ``tester``, то есть обновление происходит в "
"спейсе ``tester``. Второй аргумент -- ``999``, то есть затронутый кортеж "
"определяется по значению первичного ключа = 999. Третий аргумент -- "
"``=``, то есть будет одна операция -- *присваивание полю*. Четвертый "
"аргумент -- ``2``, то есть будет затронуто поле №2 ``field[2]``. Пятый "
"аргумент -- ``'B'``, то есть содержимое ``field[2]`` изменится на "
"``'B'``. Таким образом, после данного обновления ``field[1]`` = ``999``, "
"а ``field[2]`` = ``'B'``."

msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` "
"|br| the arguments are the same, except that the key is passed as a Lua "
"table (inside braces). This is unnecessary when the primary key has only "
"one field, but would be necessary if the primary key had more than one "
"field. Therefore, after this update, ``field[1]`` = ``999`` and "
"``field[2]`` = ``'B'`` (no change)."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` "
"|br| Аргументы повторяются за исключением того, что ключ передается в "
"виде Lua-таблицы (в фигурных скобках). В этом нет необходимости, если "
"первичный ключ содержит только одно поле, но было бы необходимо, если бы "
"в первичном ключе было больше одного поля. Таким образом, после данного "
"обновления ``field[1]`` = ``999``, а ``field[2]`` = ``'B'`` (без "
"изменений)."

msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` "
"|br| the arguments are the same, except that the fourth argument is "
"``3``, that is, the affected field is ``field[3]``. It is okay that, "
"until now, ``field[3]`` has not existed. It gets added. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]``"
" = ``1``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` |br|"
" Аргументы повторяются за исключением того, что четвертым аргументом "
"будет ``3``, то есть будет затронуто поле №3 ``field[3]``. Ничего "
"страшного, что до этого поле ``field[3]`` не существовало. Оно добавится."
" Таким образом, после данного обновления ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``1``."

msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` "
"|br| the arguments are the same, except that the third argument is "
"``'+'``, that is, the operation is addition rather than assignment. Since"
" ``field[3]`` previously contained ``1``, this means we're adding ``1`` "
"to ``1``. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` |br|"
" Аргументы повторяются за исключением того, что третьим аргументом будет "
"``'+'``, то есть будет операция добавления, а не присваивания. "
"Поскольку``field[3]`` ранее содержало значение ``1``, это означает, что к"
" ``1`` прибавится ``1``. Таким образом, после данного обновления "
"``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."

msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', "
"2, 'C'}})`` |br| the idea is to modify two fields at once. The formats "
"are ``'|'`` and ``=``, that is, there are two operations, OR and "
"assignment. The fourth and fifth arguments mean that ``field[3]`` gets "
"OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]``"
" gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = "
"``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', "
"2, 'C'}})`` |br| Основная идея состоит в том, чтобы изменить одновременно"
" два поля. Форматами будут ``'|'`` и ``=``, то есть имеем две операции: "
"ИЛИ и присваивание. Четвертый и пятый аргументы означают, что над полем "
"``field[3]`` проводится операция ИЛИ со значением ``1``. Седьмой и "
"восьмой аргументы означают, что полю ``field[2]`` присваивается ``'C'``. "
"Таким образом, после данного обновления ``field[1]`` = ``999``, "
"``field[2]`` = ``'C'``, ``field[3]`` = ``3``."

msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', "
"2, 3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` "
"from ``field[3]``. But after the delete, there is a renumbering, so "
"``field[3]`` becomes ``field[2]`` before we subtract ``3`` from it, and "
"that's why the seventh argument is ``2``, not ``3``. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', "
"2, 3}})`` |br| Основная идея состоит в том, чтобы удалить поле "
"``field[2]``, а затем вычесть ``3`` из ``field[3]``. Но после удаления, "
"произойдет перенумерация, поэтому поле ``field[3]`` становится "
"``field[2]`` до того, как мы вычтем из него ``3``, вот почему седьмым "
"аргументом будет ``2``, а не ``3``. Таким образом, после данного "
"обновления ``field[1]`` = ``999``, ``field[2]`` = ``0``."

msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})``"
" |br| we're making a long string so that splice will work in the next "
"example. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'XYZ'``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})`` "
"|br| Создаем длинную строку, чтобы в следующем примере сработало "
"разделение. Таким образом, после данного обновления ``field[1]`` = "
"``999``, ``field[2]`` = ``'XYZ'``."

msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, "
"'!!'}})`` |br| The third argument is ``':'``, that is, this is the "
"example of splice. The fourth argument is ``2`` because the change will "
"occur in ``field[2]``. The fifth argument is 2 because deletion will "
"begin with the second byte. The sixth argument is 1 because the number of"
" bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'``"
" is to be added at this position. Therefore, after this update, "
"``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, "
"'!!'}})`` |br| Третьим аргументом будет ``':'``, то есть это пример "
"разделения. Четвертым аргументом будет ``2``, поскольку изменение "
"произойдет в поле ``field[2]``. Пятым аргументом будет 2, поскольку "
"удаление начнется со второго байта. Шестым аргументом будет 1, количество"
" удаляемых байтов -- 1. Седьмым аргументом будет ``'!!'``, поскольку в "
"данном положении будет добавляться ``'!!'``. Таким образом, после данного"
" обновления ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."

msgid ""
"Since Tarantool 2.3 a tuple can also be updated via :ref:`JSON paths"
"<json_paths-module>`."
msgstr ""
"Начиная с версии Tarantool 2.3 кортеж можно обновить с помощью "
":ref:`JSON-путей <json_paths-module>`."

msgid "Update or insert a tuple."
msgstr "Обновление или вставка кортежа."

#, fuzzy
msgid ""
"If there is an existing tuple which matches the key fields of ``tuple``, "
"then the request has the same effect as :ref:`space_object:update() "
"<box_space-update>` and the ``{{operator, field_identifier, value}, "
"...}`` parameter is used. If there is no existing tuple which matches the"
" key fields of ``tuple``, then the request has the same effect as "
":ref:`space_object:insert() <box_space-insert>` and the ``{tuple}`` "
"parameter is used. However, unlike ``insert`` or ``update``, ``upsert`` "
"will not read a tuple and perform error checks before returning -- this "
"is a design feature which enhances throughput but requires more caution "
"on the part of the user."
msgstr ""
"Если существует кортеж, который совпадает с полями ключа ``tuple``, "
"запрос приведет к тому же результату, что и :ref:`space_object:update() "
"<box_space-update>`, и используется параметр ``{{operator, field_no, "
"value}, ...}``. Если нет кортежа, который совпадает с полями ключа "
"``tuple``, запрос приведет к тому же результату, что и  "
":ref:`space_object:insert() <box_space-insert>`, и используется параметр "
"``{tuple}``. Однако, в отличие от ``insert`` или ``update``, ``upsert`` "
"не считывает кортеж и не проверяет на ошибки перед возвратом -- это "
"конструктивная особенность, которая увеличивает быстродействие, но "
"требует большей осторожности со стороны пользователя."

msgid "default tuple to be inserted, if analogue isn't found"
msgstr "вставляемый по умолчанию кортеж, если не найдет аналог"

msgid "what field the operation will apply to"
msgstr ""

msgid "null"
msgstr "null"

msgid "It is illegal to modify a primary-key field."
msgstr "Нельзя изменять поле первичного ключа."

msgid ""
"It is illegal to use upsert with a space that has a unique secondary "
"index."
msgstr ""
"Нельзя проводить операцию upsert в спейсе, в котором есть уникальный "
"вторичный индекс."

msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"

msgid ""
"Users can define any functions they want, and associate them with spaces:"
" in effect they can make their own space methods. They do this by:"
msgstr ""
"Пользователи могут сами определять любые желаемые функции и связывать их "
"со спейсами: фактически они могут создавать собственные методы для работы"
" со спейсом. Это можно сделать так:"

msgid "creating a Lua function,"
msgstr "создать Lua-функцию,"

msgid ""
"adding the function name to a predefined global variable which has type ="
" table, and"
msgstr ""
"добавить имя функции в заданную глобальную переменную с типом \"таблица\""
" (table),"

msgid ""
"invoking the function any time thereafter, as long as the server is up, "
"by saying ``space_object:function-name([parameters])``."
msgstr ""
"впоследствии в любое время, пока работает сервер, вызвать функцию с "
"помощью ``объект_спейса:имя-функции([параметры])``."

msgid ""
"The predefined global variable is ``box.schema.space_mt``. Adding to "
"``box.schema.space_mt`` makes the method available for all spaces."
msgstr ""
"Задана глобальная переменная ``box.schema.space_mt``. Метод, добавленный "
"в ``box.schema.space_mt``, будет доступен для всех спейсов."

msgid ""
"Alternatively, user-defined methods can be made available for only one "
"space, by calling ``getmetatable(space_object)`` and then adding the "
"function name to the meta table. See also the example for "
":ref:`index_object:user_defined() <box_index-user_defined>`."
msgstr ""
"Можно также сделать задаваемый пользователем метод доступным только для "
"одного индекса путем вызова ``getmetatable(объект_спейса)`` и "
"последующего добавления имени функции в метатаблицу. См. также пример для"
" :ref:`index_object:user_defined() <box_index-user_defined>`."

msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ":ref:`ссылка на объект <app_server-object_reference>`."

msgid "whatever the user defines"
msgstr "то, что определяет пользователь"

msgid ""
"-- Visible to any space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f(space_arg) global_variable = global_variable + 1 end\n"
"box.schema.space_mt.counter = f\n"
"box.space.t:counter()"
msgstr ""
"-- Доступный для любого спейса, без параметров.\n"
"-- После таких запросов значение глобальной переменной global_variable "
"будет 6.\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f(space_arg) global_variable = global_variable + 1 end\n"
"box.schema.space_mt.counter = f\n"
"box.space.t:counter()"

msgid ""
"Create a check constraint. A check constraint is a requirement that must "
"be met when a tuple is inserted or updated in a space. Check constraints "
"created with ``space_object:create_check_constraint`` have the same "
"effect as check constraints created with an SQL CHECK() clause in a "
":ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

#, fuzzy
msgid ""
"name of check constraint, which should conform to the :ref:`rules for "
"object names <app_server-names>`"
msgstr ""
"имя пользователя, которое должно соответствовать :ref:`правилам "
"именования объектов <app_server-names>`"

msgid "SQL code of an expression which must return a boolean result"
msgstr ""

msgid "check constraint object"
msgstr ""

msgid "check_constraint_object"
msgstr ""

msgid ""
"The space must be formatted with :ref:`space_object:format() <box_space-"
"format>` so that the expression can contain field names. The space must "
"be empty. The space must not be a system space."
msgstr ""

msgid ""
"The expression must return true or false and should be deterministic. The"
" expresion may be any SQL (not Lua) expression containing field names, "
"built-in function names, literals, and operators. Not subqueries. If a "
"field name contains lower case characters, it must be enclosed in "
"\"double quotes\"."
msgstr ""

msgid ""
"Check constraints are checked before the request is performed, at the "
"same time as Lua :ref:`before_replace triggers <box_space-"
"before_replace>`. If there is more than one check constraint or "
"before_replace trigger, then they are ordered according to time of "
"creation. (This is a change from the earlier behavior of check "
"constraints, which caused checking before the tuple was formed.)"
msgstr ""

msgid ""
"Check constraints can be dropped with "
":samp:`{space_object}.ck_constraint.{check_constraint_name}:drop()`."
msgstr ""

msgid ""
"Check constraints can be disabled with "
":samp:`{space_object}.ck_constraint.{check_constraint_name}:enable(false)`"
" or :samp:`{check_constraint_object}:enable(false)`. Check constraints "
"can be enabled with "
":samp:`{space_object}.ck_constraint.{check_constraint_name}:enable(true)`"
" or :samp:`{check_constraint_object}:enable(true)`. By default a check "
"constraint is 'enabled' which means that the check is performed whenever "
"the request is performed, but can be changed to 'disabled' which means "
"that the check is not performed."
msgstr ""

msgid ""
"During the recovery process, for example when the Tarantool server is "
"starting, the check is not performed unless :ref:`force_recovery "
"<cfg_binary_logging_snapshots-force_recovery>`. is specified."
msgstr ""

msgid ""
"box.schema.space.create('t')\n"
"box.space.t:format({{name = 'f1', type = 'unsigned'},\n"
"                    {name = 'f2', type = 'string'},\n"
"                    {name = 'f3', type = 'string'}})\n"
"box.space.t:create_index('i')\n"
"box.space.t:create_check_constraint('c1', [[\"f2\" > 'A']])\n"
"box.space.t:create_check_constraint('c2',\n"
"                        [[\"f2\"=UPPER(\"f3\") AND NOT \"f2\" LIKE "
"'__']])\n"
"-- This insert will fail, constraint c1 expression returns false\n"
"box.space.t:insert{1, 'A', 'A'}\n"
"-- This insert will fail, constraint c2 expression returns false\n"
"box.space.t:insert{1, 'B', 'c'}\n"
"-- This insert will succeed, both constraint expressions return true\n"
"box.space.t:insert{1, 'B', 'b'}\n"
"-- This update will fail, constraint c2 expression returns false\n"
"box.space.t:update(1, {{'=', 2, 'xx'}, {'=', 3, 'xx'}})"
msgstr ""

msgid ""
"A list of check constraints is in :ref:`space_object._ck_constraint "
"<box_space-ck_constraint>`."
msgstr ""

msgid ""
"Whether or not this space is enabled. The value is ``false`` if the space"
" has no index."
msgstr ""
"Определение активности спейса. Значение ``false`` указывает на отсутствие"
" индекса."

msgid ""
"The required field count for all tuples in this space. The field_count "
"can be set initially with:"
msgstr ""
"Необходимость подсчета полей всех кортежей в спейсе, который можно "
"изначально задать следующим образом:"

msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"

msgid "The default value is ``0``, which means there is no required field count."
msgstr ""
"По умолчанию, будет использоваться значение ``0``, что указывает на "
"отсутствие необходимости подсчета полей."

msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."

msgid ""
"Ordinal space number. Spaces can be referenced by either name or number. "
"Thus, if space ``tester`` has ``id = 800``, then "
"``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are "
"equivalent requests."
msgstr ""
"Порядковый номер спейса. На спейс можно ссылаться либо по имени, либо по "
"номеру. Таким образом, если идентификатором спейса ``tester`` будет ``id "
"= 800``, то ``box.space.tester:insert{0}`` и ``box.space[800]:insert{0}``"
" представляют собой равнозначные запросы."

msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."

msgid ""
"A container for all defined indexes. There is a Lua object of type "
":ref:`box.index <box_index>` with methods to search tuples and iterate "
"over them in predefined order."
msgstr ""
"Контейнер для всех определенных индексов. Есть Lua-объект типа "
":ref:`box.index <box_index>` с методами поиска кортежей и итерации по ним"
" в заданном порядке."

msgid "To reset, use :ref:`box.stat.reset() <box_introspection-box_stat_reset>`."
msgstr ""
"Чтобы сбросить, use :ref:`box.stat.reset() <box_introspection-"
"box_stat_reset>`."

msgid "table"
msgstr "таблица"

msgid ""
"# checking the number of indexes for space 'tester'\n"
"tarantool> local counter=0; for i=0,#box.space.tester.index do\n"
"  if box.space.tester.index[i]~=nil then counter=counter+1 end\n"
"  end; print(counter)\n"
"1\n"
"---\n"
"...\n"
"# checking the type of index 'primary'\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""
"# проверка количества индексов для спейса 'tester'\n"
"tarantool> local counter=0; for i=0,#box.space.tester.index do\n"
"  if box.space.tester.index[i]~=nil then counter=counter+1 end\n"
"  end; print(counter)\n"
"1\n"
"---\n"
"...\n"
"# проверка, что тип индекса -- первичный 'primary'\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."

msgid ""
"``_cluster`` is a system space for support of the :ref:`replication "
"feature <replication>`."
msgstr ""
"``_cluster`` -- это системный спейс для поддержки :ref:`функции "
"репликации <replication>`."

#, fuzzy
msgid ""
"``_func`` is a system space with function tuples made by "
":ref:`box.schema.func.create() <box_schema-func_create>` or "
":ref:`box.schema.func.create(func-name [, {options-with-body}]) "
"<box_schema-func_create_with-body>`."
msgstr ""
"``_func`` -- это системный спейс, который содержит кортежи с функциями, "
"созданными с помощью :ref:`box.schema.func.create() <box_schema-"
"func_create>`."

msgid "Tuples in this space contain the following fields:"
msgstr "Кортежи в данном спейсе включают в себя следующие поля:"

msgid "id (integer identifier),"
msgstr "id (цельночисленный идентификатор),"

msgid "owner (integer identifier),"
msgstr "владелец (целочисленный идентификатор)"

msgid "the function name,"
msgstr "имя функции,"

msgid "the setuid flag,"
msgstr "флаг setuid,"

msgid "a language name (optional): 'LUA' (default) or 'C'."
msgstr "название языка (необязательно): 'LUA' (по умолчанию) or 'C'."

msgid "the body"
msgstr ""

msgid "the is_deterministic flag"
msgstr ""

msgid "the is_sandboxed flag"
msgstr ""

#, fuzzy
msgid "options"
msgstr "Параметры:"

#, fuzzy
msgid ""
"If the function tuple was made in the older way without specification of "
"``body``, then the ``_func`` space will contain default values for the "
"body and the is_deterministic flag and the is_sandboxed flag. Such "
"function tuples are called \"not persistent\". You continue to create Lua"
" functions in the usual way, by saying ``function function_name () ... "
"end``, without adding anything in the ``_func`` space. The ``_func`` "
"space only exists for storing function tuples so that their names can be "
"used within :ref:`grant/revoke <authentication-owners_privileges>` "
"functions."
msgstr ""
"Спейс ``_func`` не содержит саму функцию. Lua-функции создаются "
"по-прежнему с помощью ``function имя_функции () ... end`` без каких-либо "
"добавлений в спейс ``_func``. Спейс ``_func`` предназначен лишь для "
"хранения кортежей с функциями так, чтобы их имена могли использоваться в "
"функциях :ref:`выдачи/отмены прав <authentication-owners_privileges>`."

msgid ""
"If the function tuple was made the newer way with specification of "
"``body``, then all the fields may contain non-default values. Such "
"functions are called \"persistent\". They should be invoked with "
":samp:`box.func.{func-name}:call([parameters])`."
msgstr ""

msgid "You can:"
msgstr "Доступны следующие операции:"

msgid ""
"Create a ``_func`` tuple with :ref:`box.schema.func.create() <box_schema-"
"func_create>`,"
msgstr ""
"Создание кортежа в ``_func`` с помощью :ref:`box.schema.func.create() "
"<box_schema-func_create>`,"

msgid ""
"Drop a ``_func`` tuple with :ref:`box.schema.func.drop() <box_schema-"
"func_drop>`,"
msgstr ""
"Удаление кортежа в ``_func`` с помощью :ref:`box.schema.func.drop() "
"<box_schema-func_drop>`,"

msgid ""
"Check whether a ``_func`` tuple exists with "
":ref:`box.schema.func.exists() <box_schema-func_exists>`."
msgstr ""
"Проверка наличия кортежа в ``_func`` с помощью "
":ref:`box.schema.func.exists() <box_schema-func_exists>`."

msgid ""
"In the following example, we create a function named ‘f7’, put it into "
"Tarantool's ``_func`` space and grant 'execute' privilege for this "
"function to 'guest' user."
msgstr ""
"В следующем примере создадим функцию с именем ‘f7’, поместим ее в спейс "
"``_func`` в Tarantool'е и выдадим права на 'выполнение' этой функции "
"пользователю 'guest'."

msgid ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."
msgstr ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."

msgid "``_index`` is a system space."
msgstr "``_index`` -- это системный спейс."

msgid "``id`` (= id of space),"
msgstr "``id`` (= идентификатор спейса),"

msgid "``iid`` (= index number within space),"
msgstr "``iid`` (= номер индекса в спейсе),"

msgid "``name``,"
msgstr "``name``,"

msgid "``type``,"
msgstr "``type``,"

msgid ""
"``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` "
"...]."
msgstr ""
"``opts`` (например, уникальная опция), [``tuple-field-no``, ``tuple-"
"field-type`` ...]."

msgid "Here is what ``_index`` contains in a typical installation:"
msgstr "Вот что при обычной установке включает в себя спейс ``_index``:"

msgid ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."

msgid ""
"``_vindex`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_index <box_space-"
"index>`, but permissions for certain tuples are limited in accordance "
"with user privileges. ``_vindex`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vindex`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_index <box_space-index>`, но права доступа на определенные кортежи"
" ограничены в соответствии с правами пользователя. ``_vindex`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vindex`` match the contents of ``_index``. If the user has limited "
"access, ``_vindex`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vindex`` совпадает с содержимым ``_index``. Если же у "
"пользователя доступ ограничен, ``_vindex`` содержит только кортежи, "
"которые доступны текущему пользователю."

msgid "``_vindex`` is a system view, so it allows only read requests."
msgstr ""
"``_vindex`` -- это виртуальное представление системы, поэтому допускаются"
" только запросы на чтение."

msgid ""
"While the ``_index`` space requires proper access privileges, any user "
"can always read from ``_vindex``."
msgstr ""
"Если спейс ``_index`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vindex``."

msgid ""
"``_priv`` is a system space where :ref:`privileges <authentication-"
"owners_privileges>` are stored."
msgstr ""
"``_priv`` -- это системный спейс, где хранятся :ref:`права "
"<authentication-owners_privileges>`."

msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr "числовой идентификатор пользователя, который выдал права (\"grantor_id\"),"

msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""
"числовой идентификатор пользователя, который получил права "
"(\"grantee_id\"),"

msgid "the type of object: 'space', 'function', 'sequence' or 'universe',"
msgstr ""
"тип объекта: 'space' (спейс), 'function' (функция), 'sequence' "
"(последовательность) или 'universe' (вселенная),"

msgid "the numeric id of the object,"
msgstr "числовой идентификатор объекта,"

msgid ""
"the type of operation: \"read\" = 1, \"write\" = 2, \"execute\" = 4, "
"\"create\" = 32, \"drop\" = 64, \"alter\" = 128, or a combination such as"
" \"read,write,execute\"."
msgstr ""
"тип операции: \"read\" = 1, \"write\" = 2, \"execute\" = 4, \"create\" = "
"32, \"drop\" = 64, \"alter\" = 128, или их комбинация, например "
"\"read,write,execute\"."

msgid ""
"Grant a privilege with :ref:`box.schema.user.grant() <box_schema-"
"user_grant>`."
msgstr ""
"Выдача прав с помощью :ref:`box.schema.user.grant() <box_schema-"
"user_grant>`."

msgid ""
"Revoke a privilege with :ref:`box.schema.user.revoke() <box_schema-"
"user_revoke>`."
msgstr ""
"Отмена прав с помощью :ref:`box.schema.user.revoke() <box_schema-"
"user_revoke>`."

msgid ""
"Generally, privileges are granted or revoked by the owner of the object "
"(the user who created it), or by the 'admin' user."
msgstr ""
"Как правило, права выдаются или отменяются владельцем объекта "
"(пользователем, который создал его) или пользователем 'admin'."

msgid ""
"Before dropping any objects or users, make sure that all their associated"
" privileges have been revoked."
msgstr ""
"До удаления любых объектов или пользователей, убедитесь, что отменили все"
" связанные с ними права."

msgid ""
"Only the :ref:`'admin' user <authentication-owners_privileges>` can grant"
" privileges for the 'universe'."
msgstr ""
"Только пользователь :ref:`'admin' <authentication-owners_privileges>` "
"может выдавать права на 'universe'."

msgid ""
"Only the 'admin' user or the creator of a space can drop, alter, or "
"truncate the space."
msgstr ""
"Только пользователь 'admin' или создатель спейса может удалить, изменить "
"или очистить спейс."

msgid ""
"Only the 'admin' user or the creator of a user can change a different "
"user’s password."
msgstr ""
"Только пользователь 'admin' или создатель спейса может изменять  change a"
" different user’s password."

msgid ""
"``_vpriv`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_priv <box_space-"
"priv>`, but permissions for certain tuples are limited in accordance with"
" user privileges. ``_vpriv`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vpriv`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_priv <box_space-priv>`, но права доступа на определенные кортежи "
"ограничены в соответствии с правами пользователя. ``_vpriv`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vpriv`` match the contents of ``_priv``. If the user has limited "
"access, ``_vpriv`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vpriv`` совпадает с содержимым ``_priv``. Если же у "
"пользователя доступ ограничен, ``_vpriv`` содержит только кортежи, "
"которые доступны текущему пользователю."

msgid "``_vpriv`` is a system view, so it allows only read requests."
msgstr ""
"``_vpriv`` -- это виртуальное представление системы, поэтому допускаются "
"только запросы на чтение."

msgid ""
"While the ``_priv`` space requires proper access privileges, any user can"
" always read from ``_vpriv``."
msgstr ""
"Если спейс ``_priv`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vpriv``."

msgid "``_schema`` is a system space."
msgstr "``_schema`` -- это системный спейс."

msgid "This space contains the following tuples:"
msgstr "Этот спейс включает в себя следующие кортежи:"

msgid "``version`` tuple with version information for this Tarantool instance,"
msgstr "кортеж ``version`` с информацией о версии данного экземпляра Tarantool'а,"

msgid "``cluster`` tuple with the instance's replica set ID,"
msgstr "кортеж ``cluster`` с идентификатором набора реплик данного экземпляра,"

msgid "``max_id`` tuple with the maximal space ID,"
msgstr "кортеж ``max_id`` с максимальным ID спейса,"

msgid ""
"``once...`` tuples that correspond to specific :ref:`box.once() <box-"
"once>` blocks from the instance's :ref:`initialization file <index-"
"init_label>`. The first field in these tuples contains the ``key`` value "
"from the corresponding ``box.once()`` block prefixed with 'once' (e.g. "
"`oncehello`), so you can easily find a tuple that corresponds to a "
"specific ``box.once()`` block."
msgstr ""
"кортежи ``once...``, которые соответствуют определенным блокам "
":ref:`box.once() <box-once>` из :ref:`файла инициализации <index-"
"init_label>` экземпляра. Первое поле в таких кортежах содержит значение "
"ключа ``key`` из соответствующего блока ``box.once()`` с префиксом 'once'"
" (например, `oncehello`), поэтому можно легко найти кортеж, который "
"соответствует определенному блоку ``box.once()``."

msgid ""
"Here is what ``_schema`` contains in a typical installation (notice the "
"tuples for two ``box.once()`` blocks, ``'oncebye'`` and ``'oncehello'``):"
msgstr ""
"Вот что при обычной установке включает в себя спейс ``_schema`` (обратите"
" внимание на кортежи для двух блоков ``box.once()``: ``'oncebye'`` и "
"``'oncehello'``):"

msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"
msgstr ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"

msgid ""
"``_sequence`` is a system space for support of the :ref:`sequence feature"
" <index-box_sequence>`. It contains persistent information that was "
"established by :ref:`box.schema.sequence.create() <box_schema-"
"sequence_create>` or :ref:`box.schema.sequence.alter() <box_schema-"
"sequence_alter>`."
msgstr ""
"``_sequence`` -- это системный спейс для поддержки "
":ref:`последовательностей <index-box_sequence>`. Он содержит "
"персистентную информацию, определенную с помощью "
":ref:`box.schema.sequence.create() <box_schema-sequence_create>` или "
":ref:`box.schema.sequence.alter() <box_schema-sequence_alter>`."

msgid ""
"``_sequence_data`` is a system space for support of the :ref:`sequence "
"feature <index-box_sequence>`."
msgstr ""
"``_sequence_data`` -- это системный спейс для поддержки "
":ref:`последовательностей <index-box_sequence>`."

msgid "Each tuple in ``_sequence_data`` contains two fields:"
msgstr "Каждый кортеж в спейсе ``_sequence_data`` содержит два поля:"

msgid "the id of the sequence, and"
msgstr "идентификатор последовательности и"

msgid ""
"the last value that the sequence generator returned (non-persistent "
"information)."
msgstr ""
"последнее значение, возвращенное генератором последовательностей "
"(временная информация)."

msgid ""
"There is no guarantee that this space will be updated immediately after "
"every data-change request."
msgstr ""

msgid ""
"``_space`` is a system space. It contains all spaces hosted on the "
"current Tarantool instance, both system ones and created by users."
msgstr ""
"``_space`` – это системный спейс. Он содержит информацию о всех спейсах, "
"хранящихся в данном экземпляре Tarantool - как системные, так и созданные"
" пользователями."

msgid "``id``,"
msgstr "``id``,"

msgid "``owner`` (= id of user who owns the space),"
msgstr "``owner`` (= идентификатор пользователя, которому принадлежит спейс),"

msgid "``name``, ``engine``, ``field_count``,"
msgstr "``name``, ``engine``, ``field_count``,"

msgid "``flags`` (e.g. temporary),"
msgstr "``flags`` (например, временный),"

msgid "``format`` (as made by a :ref:`format clause <box_space-format>`)."
msgstr "``format`` (как задано через :ref:`оператор формата <box_space-format>`)."

msgid ""
"These fields are established by :ref:`space.create() <box_schema-"
"space_create>`."
msgstr ""
"Эти поля определены с помощью :ref:`space.create() <box_schema-"
"space_create>`."

msgid ""
"The following function will display every simple field in all tuples of "
"``_space``."
msgstr ""
"Следующая функция отобразит все простые поля во всех кортежах спейса "
"``_space``."

msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"

msgid "Here is what ``example()`` returns in a typical installation:"
msgstr "Вот что при обычной установке вернет ``example()``:"

msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."

msgid ""
"The following requests will create a space using "
"``box.schema.space.create()`` with a :ref:`format clause <box_space-"
"format>`, then retrieve the ``_space`` tuple for the new space. This "
"illustrates the typical use of the ``format`` clause, it shows the "
"recommended names and data types for the fields."
msgstr ""
"Следующая серия запросов создаст спейс, используя "
"``box.schema.space.create()`` с :ref:`оператором формата <box_space-"
"format>`, затем выберет кортеж из ``_space`` для нового спейса. Этот "
"пример иллюстрирует стандартное применение оператора ``format``, "
"показывая рекомендованные имена и типы данных для полей."

msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."
msgstr ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."

msgid ""
"``_vspace`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_space <box_space-"
"space>`, but permissions for certain tuples are limited in accordance "
"with user privileges. ``_vspace`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vspace`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_space <box_space-space>`, но права доступа на определенные кортежи"
" ограничены в соответствии с правами пользователя. ``_vspace`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vspace`` match the contents of ``_space``. If the user has limited "
"access, ``_vspace`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vspace`` совпадает с содержимым ``_space``. Если же у "
"пользователя доступ ограничен, ``_vspace`` содержит только кортежи, "
"которые доступны текущему пользователю."

msgid "``_vspace`` is a system view, so it allows only read requests."
msgstr ""
"``_vspace`` -- это виртуальное представление системы, поэтому допускаются"
" только запросы на чтение."

msgid ""
"While the ``_space`` space requires proper access privileges, any user "
"can always read from ``_vspace``."
msgstr ""
"Если спейс ``_space`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vspace``."

msgid ""
"``_user`` is a system space where user-names and password hashes are "
"stored."
msgstr ""
"``_user`` -- это системный спейс, где хранятся имена пользователей и хеши"
" паролей."

msgid "the numeric id of the tuple (\"id\"),"
msgstr "числовой идентификатор кортежа (\"id\"),"

msgid "the numeric id of the tuple’s creator,"
msgstr "числовой идентификатор создателя кортежа,"

msgid "the name,"
msgstr "имя,"

msgid "the type: 'user' or 'role',"
msgstr "тип: 'user' (пользователь) или 'role' (роль),"

msgid "optional password."
msgstr "пароль по желанию"

msgid ""
"There are five special tuples in the ``_user`` space: 'guest', 'admin', "
"'public', 'replication', and 'super'."
msgstr ""
"В спейсе ``_user`` есть пять специальных кортежей: 'guest', 'admin', "
"'public', 'replication' и 'super'."

msgid "ID"
msgstr "ID"

msgid "Description"
msgstr "Описание"

msgid "guest"
msgstr "guest"

msgid "0"
msgstr "0"

msgid "user"
msgstr "user (пользователь)"

msgid ""
"Default user when connecting remotely. Usually an untrusted user with few"
" privileges."
msgstr ""
"Пользователь, который используется по умолчанию при удаленном "
"подключении. Как правило, это не заслуживающий доверия пользователь с "
"небольшим количеством прав."

msgid "admin"
msgstr "admin"

msgid "1"
msgstr "1"

msgid ""
"Default user when using Tarantool as a console. Usually an "
":ref:`administrative user <authentication-owners_privileges>` with all "
"privileges."
msgstr ""
"Пользователь, который используется по умолчанию при работе с Tarantool'ом"
" как с консолью. Как правило, это :ref:`административный пользователь "
"<authentication-owners_privileges>` со всеми правами."

msgid "public"
msgstr "public"

msgid "role"
msgstr "роль"

msgid ""
"Pre-defined :ref:`role <authentication-roles>`, automatically granted to "
"new users when they are created with ``box.schema.user.create(user-"
"name)``. Therefore a convenient way to grant 'read' on space 't' to every"
" user that will ever exist is with "
"``box.schema.role.grant('public','read','space','t')``."
msgstr ""
"Заданная :ref:`роль <authentication-roles>`, которая автоматически "
"выдается новым пользователям при их создании методом "
"``box.schema.user.create(имя-пользователя)``. Таким образом, лучше всего "
"выдать права на чтение 'read' спейса 't' каждому когда-либо созданному "
"пользователю с помощью "
"``box.schema.role.grant('public','read','space','t')``."

msgid "replication"
msgstr "replication"

msgid "3"
msgstr "3"

msgid ""
"Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user "
"can grant to users who need to use :ref:`replication <replication>` "
"features."
msgstr ""
"Заданная :ref:`роль <authentication-roles>`, выдаваемая пользователем "
"'admin' другим пользователям для использования функций :ref:`репликации "
"<replication>`."

msgid "super"
msgstr "super"

msgid "31"
msgstr "31"

msgid ""
"Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user "
"can grant to users who need all privileges on all objects. The 'super' "
"role has these privileges on 'universe': read, write, execute, create, "
"drop, alter."
msgstr ""
"Заданная :ref:`роль <authentication-roles>`, выдаваемая пользователем "
"'admin' другим пользователям для получения всех прав на все объекты. Для "
"роли 'super' такие права выданы на 'universe': чтение, запись, "
"выполнение, создание, удаление, изменение."

msgid ""
"To select a tuple from the ``_user`` space, use "
"``box.space._user:select()``. For example, here is what happens with a "
"select for user id = 0, which is the 'guest' user, which by default has "
"no password:"
msgstr ""
"Чтобы выбрать кортеж из спейса ``_user``, используйте "
"``box.space._user:select()``. Например, при выборке от пользователя с id "
"= 0, который является пользователем 'guest' без пароля по умолчанию, "
"произойдет следующее:"

msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."

msgid ""
"To change tuples in the ``_user`` space, do not use ordinary "
"``box.space`` functions for insert or update or delete. The ``_user`` "
"space is special, so there are special functions which have appropriate "
"error checking."
msgstr ""
"Чтобы изменить кортежи в спейсе ``_user``, не пользуйтесь стандартными "
"функциями ``box.space`` для вставки, обновления или удаления. Речь идет "
"об особом спейсе ``_user``, поэтому есть особые функции с соответствующей"
" проверкой на ошибки."

msgid ""
"To create a new user, use :ref:`box.schema.user.create() <box_schema-"
"user_create>`:"
msgstr ""
"Чтобы создать нового пользователя, используйте "
":ref:`box.schema.user.create() <box_schema-user_create>`:"

msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})"
msgstr ""
"box.schema.user.create(*имя-пользователя*)\n"
"box.schema.user.create(*имя-пользователя*, {if_not_exists = true})\n"
"box.schema.user.create(*имя-пользователя*, {password = *пароль*})"

msgid ""
"To change the user's password, use :ref:`box.schema.user.password() "
"<box_schema-user_password>`:"
msgstr ""
"Чтобы изменить пароль пользователя, воспользуйтесь "
":ref:`box.schema.user.password() <box_schema-user_password>`:"

msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"-- (usually only 'admin' can do it)\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""
"-- Чтобы изменить пароль текущего пользователя\n"
"box.schema.user.passwd(*пароль*)\n"
"\n"
"-- Чтобы изменить пароль другого пользователя\n"
"-- (обычно это может делать только 'admin')\n"
"box.schema.user.passwd(*имя-пользователя*, *пароль*)"

msgid "To drop a user, use :ref:`box.schema.user.drop() <box_schema-user_drop>`:"
msgstr ""
"Чтобы удалить пользователя, используйте :ref:`box.schema.user.drop() "
"<box_schema-user_drop>`:"

msgid "box.schema.user.drop(*user-name*)"
msgstr "box.schema.user.drop(*имя-пользователя*)"

msgid ""
"To check whether a user exists, use :ref:`box.schema.user.exists() "
"<box_schema-user_exists>`, which returns ``true`` or ``false``:"
msgstr ""
"Чтобы проверить, существует ли пользователь, воспользуйтесь "
":ref:`box.schema.user.exists() <box_schema-user_exists>`, которая вернет "
"``true`` (правда) или ``false`` (ложь):"

msgid "box.schema.user.exists(*user-name*)"
msgstr "box.schema.user.exists(*имя-пользователя*)"

msgid ""
"To find what privileges a user has, use :ref:`box.schema.user.info() "
"<box_schema-user_info>`:"
msgstr ""
"Чтобы узнать, какие права есть у пользователя, используйте "
":ref:`box.schema.user.info() <box_schema-user_info>`:"

msgid "box.schema.user.info(*user-name*)"
msgstr "box.schema.user.info(*имя-пользователя*)"

msgid "The maximum number of users is 32."
msgstr "Максимальное количество пользователей -- 32."

msgid ""
"Here is a session which creates a new user with a strong password, "
"selects a tuple in the ``_user`` space, and then drops the user."
msgstr ""
"Ниже представлена сессия, в рамках которой создается новый пользователь с"
" надежным паролем, выбирается кортеж из спейса ``_user``, а затем "
"пользователь удаляется."

msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = "
"'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': "
"'t3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.user.create('JeanMartin', {password = "
"'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': "
"'t3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."

#, fuzzy
msgid "``_ck_constraint`` is a system space where check constraints are stored."
msgstr ""
"``_user`` -- это системный спейс, где хранятся имена пользователей и хеши"
" паролей."

#, fuzzy
msgid "the numeric id of the space (\"space_id\"),"
msgstr "числовой идентификатор кортежа (\"id\"),"

msgid "whether the check is deferred (\"is_deferred\"),"
msgstr ""

msgid "the language of the expression, such as 'SQL',"
msgstr ""

msgid "the expression (\"code\")"
msgstr ""

msgid ""
"tarantool> box.space._ck_constraint:select()\n"
"---\n"
"- - [527, 'c1', false, 'SQL', '\"f2\" > ''A''']\n"
"  - [527, 'c2', false, 'SQL', '\"f2\" == UPPER(\"f3\") AND NOT \"f2\" "
"LIKE ''__''']\n"
"..."
msgstr ""

msgid "Example: using box.space functions to read _space tuples"
msgstr "Пример: использование функций box.space для чтения кортежей из _space"

msgid ""
"This function will illustrate how to look at all the spaces, and for each"
" display: approximately how many tuples it contains, and the first field "
"of its first tuple. The function uses Tarantool ``box.space`` functions "
"``len()`` and ``pairs()``. The iteration through the spaces is coded as a"
" scan of the ``_space`` system space, which contains metadata. The third "
"field in ``_space`` contains the space name, so the key instruction "
"``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in"
" the tuple of ``_space`` that we've just fetched with ``pairs()``. The "
"function returns a table:"
msgstr ""
"Функция ниже проиллюстрирует, как обращаться ко всем спейсам, и для "
"каждого отобразит примерное количество кортежей и первое поле первого "
"кортежа. В данной функции используются функции из ``box.space`` в "
"Tarantool'е: ``len()`` и ``pairs()``. Итерация по спейсам закодирована в "
"форме сканирования системного спейса ``_space``, который содержит "
"метаданные. Третье поле в ``_space`` содержит имя спейса, поэтому "
"ключевая команда ``space_name = v[3]`` означает, что ``space_name`` -- "
"это поле ``space_name`` в кортеже ``_space``, который мы только что "
"получили с помощью ``pairs()``. Функция возвращает таблицу:"

msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"

msgid "And here is what happens when one invokes the function:"
msgstr "А вот что происходит, когда вызывается функция:"

msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."

msgid "Example: using box.space functions to organize a _space tuple"
msgstr "Пример: использование функций box.space для организации кортежа из _space"

msgid ""
"The objective is to display field names and field types of a system space"
" -- using metadata to find metadata."
msgstr ""
"Основная цель -- отобразить имена и типы полей системного спейса, то есть"
" использование метаданных для поиска метаданных."

msgid ""
"To begin: how can one select the ``_space`` tuple that describes "
"``_space``?"
msgstr ""
"Для начала: как можно сделать выборку кортежа из ``_space``, который "
"описывает ``_space``?"

msgid ""
"A simple way is to look at the constants in ``box.schema``, which tell us"
" that there is an item named SPACE_ID == 288, so these statements will "
"retrieve the correct tuple:"
msgstr ""
"Проще всего проверить постоянные в ``box.schema``, что укажет на наличие "
"элемента под названием SPACE_ID == 288. Таким образом, следующие запросы "
"вернут нужный кортеж:"

msgid ""
"box.space._space:select{ 288 }\n"
"-- or --\n"
"box.space._space:select{ box.schema.SPACE_ID }"
msgstr ""
"box.space._space:select{ 288 }\n"
"-- или --\n"
"box.space._space:select{ box.schema.SPACE_ID }"

msgid ""
"Another way is to look at the tuples in ``box.space._index``, which tell "
"us that there is a secondary index named 'name' for space number 288, so "
"this statement also will retrieve the correct tuple:"
msgstr ""
"Также можно обратиться к спейсам в ``box.space._index``, что укажет на "
"наличие вторичного индекса с именем 'name' для спейса под номером 288. "
"Таким образом, следующий запрос также вернет нужный кортеж:"

msgid "box.space._space.index.name:select{ '_space' }"
msgstr "box.space._space.index.name:select{ '_space' }"

msgid "However, the retrieved tuple is not easy to read:"
msgstr "Однако непросто прочитать информацию из полученного кортежа:"

msgid ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, "
"{'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': "
"'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': "
"'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."
msgstr ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, "
"{'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': "
"'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': "
"'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."

msgid ""
"It looks disorganized because field number 7 has been formatted with "
"recommended names and data types. How can one get those specific sub-"
"fields? Since it's visible that field number 7 is an array of maps, this "
"`for` loop will do the organizing:"
msgstr ""
"Информация подается бессистемно, поскольку по формату поле №7 содержит "
"рекомендованные имена и типы данных. Как же получить эти данные? "
"Поскольку очевидно, что поле №7 представляет собой ассоциативный массив, "
"цикл `for` проведет организацию данных:"

msgid ""
"tarantool> do\n"
"         >   local tuple_of_space = "
"box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."
msgstr ""
"tarantool> do\n"
"         >   local tuple_of_space = "
"box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."

msgid ""
"``_vuser`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_user <box_space-"
"user>`, but permissions for certain tuples are limited in accordance with"
" user privileges. ``_vuser`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vuser`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_user <box_space-user>`, но права доступа на определенные кортежи "
"ограничены в соответствии с правами пользователя. ``_vuser`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vuser`` match the contents of ``_user``. If the user has limited "
"access, ``_vuser`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vuser`` совпадает с содержимым ``_user``. Если же у "
"пользователя доступ ограничен, ``_vuser`` содержит только кортежи, "
"которые доступны текущему пользователю."

msgid ""
"To see how ``_vuser`` works, :ref:`connect to a Tarantool database "
"remotely <connecting-remotely>` via ``tarantoolctl`` and select all "
"tuples from the ``_user`` space, both when the 'guest' user *is* and *is "
"not* allowed to read from the database."
msgstr ""
"Чтобы посмотреть, как работать с ``_vuser``, :ref:`удаленно подключитесь "
"к базе данных Tarantool'а <connecting-remotely>` с помощью "
"``tarantoolctl`` и сделайте выборку кортежей из спейса ``_user`` в "
"следующих ситуациях: когда пользователь 'guest' *имеет* и когда он *не "
"имеет* права выполнять чтение данных из базы."

msgid ""
"First, start Tarantool and grant the 'guest' user with read, write and "
"execute privileges:"
msgstr ""
"Для начала запустите Tarantool и выдайте пользователю 'guest' права на "
"чтение, запись и выполнение:"

msgid ""
"tarantool> box.cfg{listen = 3301}\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen = 3301}\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')\n"
"---\n"
"..."

msgid ""
"Switch to the other terminal, connect to the Tarantool instance and "
"select all tuples from the ``_user`` space:"
msgstr ""
"Перейдите на другой терминал, подключитесь к экземпляру Tarantool'а и "
"произведите выборку всех кортежей из спейса ``_user``:"

msgid ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"  - [1, 1, 'admin', 'user', {}]\n"
"  - [2, 1, 'public', 'role', {}]\n"
"  - [3, 1, 'replication', 'role', {}]\n"
"  - [31, 1, 'super', 'role', {}]\n"
"..."
msgstr ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"  - [1, 1, 'admin', 'user', {}]\n"
"  - [2, 1, 'public', 'role', {}]\n"
"  - [3, 1, 'replication', 'role', {}]\n"
"  - [31, 1, 'super', 'role', {}]\n"
"..."

msgid ""
"This result contains the same set of users as if you made the request "
"from your Tarantool instance as 'admin'."
msgstr ""
"Результат включает в себя тот же набор пользователей, как если бы вы "
"выполнили запрос от пользователя 'admin' на своем экземпляре Tarantool'а."

msgid ""
"Switch to the first terminal and revoke the read privileges from the "
"'guest' user:"
msgstr ""
"Вернитесь в первый терминал и отмените права на чтение пользователю "
"'guest':"

msgid ""
"tarantool> box.schema.user.revoke('guest', 'read', 'universe')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.user.revoke('guest', 'read', 'universe')\n"
"---\n"
"..."

msgid ""
"Switch to the other terminal, stop the session (to stop ``tarantoolctl``,"
" type Ctrl+C or Ctrl+D) and repeat the ``box.space._user:select{}`` "
"request. The access is denied:"
msgstr ""
"Перейдите на другой терминал, остановите сессию (чтобы остановить "
"``tarantoolctl``, нажмите Ctrl+C или Ctrl+D) и повторите запрос "
"``box.space._user:select{}``. В доступе отказано:"

msgid ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- error: Read access to space '_user' is denied for user 'guest'\n"
"..."
msgstr ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- error: Read access to space '_user' is denied for user 'guest'\n"
"..."

msgid ""
"However, if you select from ``_vuser`` instead, the users' data available"
" for the 'guest' user is displayed:"
msgstr ""
"Тем не менее, если вместо этого произвести выборку из ``_vuser``, "
"отображаются данные пользователей, доступные пользователю 'guest':"

msgid ""
"localhost:3301> box.space._vuser:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"..."
msgstr ""
"localhost:3301> box.space._vuser:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"..."

msgid "``_vuser`` is a system view, so it allows only read requests."
msgstr ""
"``_vuser`` -- это виртуальное представление системы, поэтому допускаются "
"только запросы на чтение."

msgid ""
"While the ``_user`` space requires proper access privileges, any user can"
" always read from ``_vuser``."
msgstr ""
"Если спейс ``_user`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vuser``."

msgid ""
"``_collation`` is a system space with a list of :ref:`collations <index-"
"collation>`. There are over 270 built-in collations and users may add "
"more. Here is one example:"
msgstr ""

#, fuzzy
msgid ""
"localhost:3301> box.space._collation:select(239)\n"
"---\n"
"- - [239, 'unicode_uk_s2', 1, 'ICU', 'uk', {'strength': 'secondary'}]\n"
"..."
msgstr ""
"localhost:3301> box.space._vuser:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"..."

msgid ""
"Explanation of the fields in the example: id = 239 i.e. Tarantool's "
"primary key is 239, name = 'unicode_uk_s2' i.e. according to Tarantool's "
"naming convention this is a Unicode collation + it is for the uk locale +"
" it has secondary strength, owner = 1 i.e. :ref:`the admin user "
"<authentication-owners_privileges>`, type = 'ICU' i.e. the rules are "
"according to `International Components for Unicode <http://site.icu-"
"project.org/home>`_, locale = 'uk' i.e. `Ukrainian "
"<http://www.unicode.org/cldr/charts/29/collation/uk.html>`_, opts = "
"'strength:secondary' i.e. with this collation comparisons use both "
"primary and secondary `weights "
"<https://unicode.org/reports/tr10/#Weight_Level_Defn>`_."
msgstr ""

msgid ""
"``_vcollation`` is a system space with a list of :ref:`collations <index-"
"collation>`. The structure of its tuples is identical to that of "
":ref:`box.space._collation <box_space-collation>`, but permissions for "
"certain tuples are limited in accordance with user privileges."
msgstr ""

msgid ""
"``_session_settings`` is a temporary system space with a list of settings"
" that may affect behavior, particularly SQL behavior, for the current "
"session. It uses a special engine named 'service'. Every 'service' tuple "
"is created on the fly, that is, new tuples are made every time "
"``_session_settings`` is accessed. Every settings tuple has two fields: "
"``name`` (the primary key) and ``value``. The tuples' names and default "
"values are: |br| ``sql_default_engine``: default :ref:`storage engine "
"<engines-chapter>` for new SQL tables. Default = 'memtx'. |br| "
"``sql_defer_foreign_keys``: whether foreign-key checks can wait till "
"commit. Default = false. |br| ``sql_full_column_names``: no effect at "
"this time. Default = false. |br| ``sql_full_metadata``: whether :ref:`SQL"
" result set metadata <box-sql_result_sets>` will have more than just name"
" and type. Default = false. |br| ``sql_parser_debug``: whether to show "
"parser steps for following statements. Default = false. |br| "
"``sql_recursive_triggers``: whether a triggered statement can activate a "
":ref:`trigger <sql_create_trigger>`. Default = true. |br| "
"``sql_reverse_unordered_selects``: whether result rows are usually in "
"reverse order if there is no :ref:`ORDER BY clause <sql_order_by>`. "
"Default = false. |br| ``sql_select_debug``: whether to show execution "
"steps during :ref:`SELECT <sql_select>`. Default = false. |br| "
"``sql_vdbe_debug``: for use by Tarantool's developers. Default = false. "
"|br| Three requests are possible: :ref:`select <box_space-select>` and "
":ref:`get <box_space-get>` and :ref:`update <box_space-update>`. For "
"example, after ``s = box.space._session_settings``, "
"``s:select('sql_default_engine')`` probably returns "
"``{'sql_default_engine', 'memtx'}``, and ``s:update('sql_default_engine',"
" {{'=', 'value', 'vinyl'}})`` changes the default engine to 'vinyl'. |br|"
" Updating ``sql_parser_debug`` or ``sql_select_debug`` or "
"``sql_vdbe_debug`` has no effect unless Tarantool was built with "
"-DCMAKE_BUILD_TYPE=Debug. To check if this is so, look at "
"``require('tarantool').build.target``."
msgstr ""

msgid "Example: using data operations"
msgstr "Пример: использование операций с данными"

msgid ""
"This example demonstrates all legal scenarios -- as well as typical "
"errors -- for each :ref:`data operation <index-box_data-operations>` in "
"Tarantool: :ref:`INSERT <box_space-operations-insert>`, :ref:`DELETE "
"<box_space-operations-delete>`, :ref:`UPDATE <box_space-operations-"
"update>`, :ref:`UPSERT <box_space-operations-upsert>`, :ref:`REPLACE "
"<box_space-operations-replace>`, and :ref:`SELECT <box_space-operations-"
"select>`."
msgstr ""
"Пример ниже иллюстрирует все возможные сценарии -- а также типичные "
"ошибки -- для всех :ref:`операций с данными <index-box_data-operations>` "
"в Tarantool'е: :ref:`INSERT <box_space-operations-insert>`, :ref:`DELETE "
"<box_space-operations-delete>`, :ref:`UPDATE <box_space-operations-"
"update>`, :ref:`UPSERT <box_space-operations-upsert>`, :ref:`REPLACE "
"<box_space-operations-replace>` и :ref:`SELECT <box_space-operations-"
"select>`."

#, fuzzy
msgid ""
"-- Bootstrap the database --\n"
"box.cfg{}\n"
"format = {}\n"
"format[1] = {'field1', 'unsigned'}\n"
"format[2] = {'field2', 'unsigned'}\n"
"format[3] = {'field3', 'unsigned'}\n"
"s = box.schema.create_space('test', {format = format})\n"
"-- Create a primary index --\n"
"pk = s:create_index('pk', {parts = {{field = 'field1'}}})\n"
"-- Create a unique secondary index --\n"
"sk_uniq = s:create_index('sk_uniq', {parts = {{field = 'field2'}}})\n"
"-- Create a non-unique secondary index --\n"
"sk_non_uniq = s:create_index('sk_non_uniq', {parts = {{field = "
"'field3'}}, unique = false})"
msgstr ""
"-- Настройка базы данных --\n"
"box.cfg{}\n"
"format = {}\n"
"format[1] = {'field1', 'unsigned'}\n"
"format[2] = {'field2', 'unsigned'}\n"
"format[3] = {'field3', 'unsigned'}\n"
"s = box.schema.create_space('test', {format = format})\n"
"-- Создание первичного индекса --\n"
"pk = s:create_index('pk', {parts = {{'field1'}}})\n"
"-- Создание уникального вторичного индекса --\n"
"sk_uniq = s:create_index('sk_uniq', {parts = {{'field2'}}})\n"
"-- Создание неуникального вторичного индекса --\n"
"sk_non_uniq = s:create_index('sk_non_uniq', {parts = {{'field3'}}, unique"
" = false})"

msgid "INSERT"
msgstr "INSERT"

msgid ""
"``insert`` accepts a well-formatted tuple and checks all keys for "
"duplicates."
msgstr ""
"Операция ``insert`` (вставка) работает с кортежами с четким форматом и "
"проверяет все ключи на наличие совпадений."

msgid ""
"tarantool> -- Unique indexes: ok --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> -- Conflicting primary key: error --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'pk' in space 'test'\n"
"...\n"
"tarantool> -- Conflicting unique secondary key: error --\n"
"tarantool> s:insert({2, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> -- Key {1} exists in sk_non_uniq index, but it is not unique: "
"ok --\n"
"tarantool> s:insert({2, 2, 1})\n"
"---\n"
"- [2, 2, 1]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> -- Уникальные индексы: разрешено --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> -- Конфликт первичного ключа: ошибка --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'pk' in space 'test'\n"
"...\n"
"tarantool> -- Конфликт уникального вторичного ключа: ошибка --\n"
"tarantool> s:insert({2, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> -- Ключ {1} присутствует в индексе sk_non_uniq, но он не "
"уникален: разрешено --\n"
"tarantool> s:insert({2, 2, 1})\n"
"---\n"
"- [2, 2, 1]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

msgid "DELETE"
msgstr "DELETE"

msgid "``delete`` accepts a full key of any unique index."
msgstr ""
"``delete`` (удаление) работает с полными ключами любого уникального "
"индекса."

msgid "``space:delete`` is an alias for \"delete by primary key\"."
msgstr ""
"``space:delete`` -- это псевдоним для операции \"удалить по первичному "
"ключу\"."

msgid ""
"tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"tarantool> s:delete{4}\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a primary key: ok --\n"
"tarantool> s:delete{3}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly delete by a primary key: ok --\n"
"tarantool> s.index.pk:delete{6}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a unique secondary key: ok --\n"
"s.index.sk_uniq:delete{10}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a non-unique secondary index: error --\n"
"tarantool> s.index.sk_non_uniq:delete{14}\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> -- Вставить некоторые тестовые данные --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Здесь ничего не происходит: нет ключа {4} в индексе pk --\n"
"tarantool> s:delete{4}\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Удалить по первичному ключу: разрешено --\n"
"tarantool> s:delete{3}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Точно удалить по первичному ключу: разрешено --\n"
"tarantool> s.index.pk:delete{6}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Удалить по уникальному вторичному ключу: разрешено --\n"
"s.index.sk_uniq:delete{10}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> -- Удалить по неуникальному вторичному индексу: ошибка --\n"
"tarantool> s.index.sk_non_uniq:delete{14}\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

msgid "The key must be full: ``delete`` cannot work with partial keys."
msgstr ""
"Ключ должен быть полным: операция ``delete`` не работает с компонентами "
"ключа."

#, fuzzy
msgid ""
"tarantool> s2 = box.schema.create_space('test2')\n"
"---\n"
"...\n"
"tarantool> pk2 = s2:create_index('pk2', {parts = {{field = 1, type = "
"'unsigned'}, {field = 2, type = 'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s2:insert{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> -- Delete by a partial key: error --\n"
"tarantool> s2:delete{1}\n"
"---\n"
"- error: Invalid key part count in an exact match (expected 2, got 1)\n"
"...\n"
"tarantool> -- Delete by a full key: ok --\n"
"tarantool> s2:delete{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> s2:select{}\n"
"---\n"
"- []\n"
"...\n"
"tarantool> s2:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> s2 = box.schema.create_space('test2')\n"
"---\n"
"...\n"
"tarantool> pk2 = s2:create_index('pk2', {parts = {{1, 'unsigned'}, {2, "
"'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s2:insert{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> -- Удалить по компоненту ключа: ошибка --\n"
"tarantool> s2:delete{1}\n"
"---\n"
"- error: Invalid key part count in an exact match (expected 2, got 1)\n"
"...\n"
"tarantool> -- Удалить по ключу целиком: разрешено --\n"
"tarantool> s2:delete{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> s2:select{}\n"
"---\n"
"- []\n"
"...\n"
"tarantool> s2:drop()\n"
"---\n"
"..."

msgid "UPDATE"
msgstr "UPDATE"

msgid ""
"Similarly to ``delete``, ``update`` accepts a full key of any unique "
"index, and also the operations to execute."
msgstr ""
"Как и ``delete``, ``update`` работает с полными ключами любого "
"уникального индекса, а также выполняет операции."

msgid "``space:update`` is an alias for \"update by primary key\"."
msgstr ""
"``space:update`` -- это псевдоним для операции \"обновить по первичному "
"ключу\"."

msgid ""
"tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"s:update({4}, {{'=', 2, 400}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a primary key: ok --\n"
"tarantool> s:update({3}, {{'=', 2, 400}})\n"
"---\n"
"- [3, 400, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly update by a primary key: ok --\n"
"tarantool> s.index.pk:update({6}, {{'=', 2, 700}})\n"
"---\n"
"- [6, 700, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a unique secondary key: ok --\n"
"tarantool> s.index.sk_uniq:update({10}, {{'=', 2, 1000}})\n"
"---\n"
"- [9, 1000, 11]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a non-unique secondary key: error --\n"
"tarantool> s.index.sk_non_uniq:update({14}, {{'=', 2, 1300}})\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> -- Вставить некоторые тестовые данные --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Здесь ничего не происходит: нет ключа {4} в индексе pk --\n"
"s:update({4}, {{'=', 2, 400}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Обновить по первичному ключу: разрешено --\n"
"tarantool> s:update({3}, {{'=', 2, 400}})\n"
"---\n"
"- [3, 400, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Точно обновить по первичному ключу: разрешено --\n"
"tarantool> s.index.pk:update({6}, {{'=', 2, 700}})\n"
"---\n"
"- [6, 700, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Обновить по уникальному вторичному ключу: разрешено --\n"
"tarantool> s.index.sk_uniq:update({10}, {{'=', 2, 1000}})\n"
"---\n"
"- [9, 1000, 11]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Обновить по неуникальному вторичному ключу: ошибка --\n"
"tarantool> s.index.sk_non_uniq:update({14}, {{'=', 2, 1300}})\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

msgid "UPSERT"
msgstr "UPSERT"

msgid "``upsert`` accepts a well-formatted tuple and update operations."
msgstr ""
"``upsert`` (обновление и вставка) работает с кортежами с четким форматом "
"и выполняет операции обновления."

msgid ""
"If an old tuple is found by the primary key of the specified tuple, then "
"the update operations are applied to the old tuple, and the new tuple is "
"ignored."
msgstr ""
"Если найден старый кортеж по первичному ключу, то операции обновления "
"применяются к старому кортежу, а новый кортеж игнорируется."

msgid ""
"If no old tuple is found, then the new tuple is inserted, and the update "
"operations are **ignored**."
msgstr ""
"Если старый кортеж не найден, то происходит вставка нового кортежа, а "
"операции обновления **игнорируются**."

msgid "Indexes have no ``upsert`` method - this is a method of a space."
msgstr "Для индексов нет метода ``upsert`` -- это метод для спейса."

msgid ""
"tarantool> s.index.pk.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.index.sk_uniq.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.upsert ~= nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- As the first argument, upsert accepts --\n"
"tarantool> -- a well-formatted tuple, NOT a key! --\n"
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:upsert({1}, {{'=', 2, 200}})\n"
"---\n"
"- error: Tuple field count 1 is less than required by space format or "
"defined indexes\n"
"    (expected at least 3)\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:delete{1}\n"
"---\n"
"- [1, 2, 3]\n"
"..."
msgstr ""
"tarantool> s.index.pk.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.index.sk_uniq.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.upsert ~= nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- В качестве первого аргумента upsert принимает --\n"
"tarantool> -- кортеж с четким форматом, НЕ ключ! --\n"
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:upsert({1}, {{'=', 2, 200}})\n"
"---\n"
"- error: Tuple field count 1 is less than required by space format or "
"defined indexes\n"
"    (expected at least 3)\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:delete{1}\n"
"---\n"
"- [1, 2, 3]\n"
"..."

msgid ""
"``upsert`` turns into ``insert`` when no old tuple is found by the "
"primary key."
msgstr ""
"``upsert`` превращается в ``insert``, когда старый кортеж не найден по "
"первичному ключу."

msgid ""
"tarantool> s:upsert({1, 2, 3}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- As you can see, {1, 2, 3} were inserted, --\n"
"tarantool> -- and the update operations were not applied. --\n"
"s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> -- Performing another upsert with the same primary key, --\n"
"tarantool> -- but different values in the other fields. --\n"
"s:upsert({1, 20, 30}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- The old tuple was found by the primary key {1} --\n"
"tarantool> -- and update operations were applied. --\n"
"tarantool> -- The new tuple was ignored. --\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"..."
msgstr ""
"tarantool> s:upsert({1, 2, 3}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- Как можно увидеть, произошла вставка {1, 2, 3}, --\n"
"tarantool> -- а операции обновления не применились. --\n"
"s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> -- Еще одна операция upsert с тем же первичным ключом, --\n"
"tarantool> -- но другими значениями прочих полей. --\n"
"s:upsert({1, 20, 30}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- Старый кортеж был найден по первичному ключу {1}, --\n"
"tarantool> -- и применились операции обновления. --\n"
"tarantool> -- Новый кортеж игнорируется. --\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"..."

msgid ""
"``upsert`` searches for an old tuple by the primary index, NOT by a "
"secondary index. This can lead to a duplication error if the new tuple "
"ruins the uniqueness of a secondary index."
msgstr ""
"``upsert`` ищет старый кортеж по первичному индексу, НЕ по вторичному. "
"Это может привести к ошибкам с дубликатами, если новый кортеж нарушает "
"уникальность вторичного индекса."

msgid ""
"tarantool> s:upsert({2, 200, 3}, {{'=', 3, 300}})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"...\n"
"tarantool> -- But this works, when uniqueness is preserved. --\n"
"tarantool> s:upsert({2, 0, 0}, {{'=', 3, 300}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"  - [2, 0, 0]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> s:upsert({2, 200, 3}, {{'=', 3, 300}})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"...\n"
"tarantool> -- Но сработает, если сохраняется уникальность. --\n"
"tarantool> s:upsert({2, 0, 0}, {{'=', 3, 300}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"  - [2, 0, 0]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

msgid "REPLACE"
msgstr "REPLACE"

msgid ""
"``replace`` accepts a well-formatted tuple and searches for an old tuple "
"by the primary key of the new tuple."
msgstr ""
"``replace`` (замена) работает с кортежами с четким форматом и ищет старый"
" кортеж по первичному ключу нового кортежа."

msgid ""
"If the old tuple is found, then it is deleted, and the new tuple is "
"inserted."
msgstr ""
"Если найден старый кортеж, то происходит удаление старого кортежа и "
"вставка нового."

msgid "If the old tuple was not found, then just the new tuple is inserted."
msgstr "Если старый кортеж не найден, вставляется новый кортеж."

msgid ""
"tarantool> s:replace{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:replace{1, 3, 4}\n"
"---\n"
"- [1, 3, 4]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 3, 4]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> s:replace{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:replace{1, 3, 4}\n"
"---\n"
"- [1, 3, 4]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 3, 4]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

msgid "``replace`` can ruin unique constraints, like ``upsert`` does."
msgstr "Как и ``upsert``, ``replace`` может нарушить требования уникальности."

msgid ""
"tarantool> s:insert{1, 1, 1}\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> s:insert{2, 2, 2}\n"
"---\n"
"- [2, 2, 2]\n"
"...\n"
"tarantool> -- This replace fails, because if the new tuple {1, 2, 0} "
"replaces --\n"
"tarantool> -- the old tuple by the primary key from 'pk' index {1, 1, 1},"
" --\n"
"tarantool> -- this results in a duplicate unique secondary key in "
"'sk_uniq' index: --\n"
"tarantool> -- key {2} is used both in the new tuple and in {2, 2, 2}. --\n"
"tarantool> s:replace{1, 2, 0}\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> s:insert{1, 1, 1}\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> s:insert{2, 2, 2}\n"
"---\n"
"- [2, 2, 2]\n"
"...\n"
"tarantool> -- Такая замена не сработает, поскольку замена новым кортежем "
"{1, 2, 0} --\n"
"tarantool> -- старого кортежа по первичному ключу из индекса 'pk' {1, 1, "
"1}, --\n"
"tarantool> -- приведет к созданию дубликата уникального вторичного ключа "
"в индексе 'sk_uniq': --\n"
"tarantool> -- ключ {2} используется и в новом кортеже, и в {2, 2, 2}. --\n"
"tarantool> s:replace{1, 2, 0}\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

msgid "SELECT"
msgstr "SELECT"

msgid ""
"``select`` works with any indexes (primary/secondary) and with any keys "
"(unique/non-unique, full/partial)."
msgstr ""
"``select`` (выборка) работает с любыми индексами (первичными/вторичными) "
"и с любыми ключами (уникальными/неуникальными, полными/компонентами)."

msgid ""
"If a key is partial, then ``select`` searches by all keys, where the "
"prefix matches the specified key part."
msgstr ""
"Если задан компонент ключа, ``select`` выполняет поиск всех ключей, "
"префикс которых совпадает с указанным компонентом ключа."

msgid ""
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:insert{4, 5, 6}\n"
"---\n"
"- [4, 5, 6]\n"
"...\n"
"tarantool> s:insert{7, 8, 9}\n"
"---\n"
"- [7, 8, 9]\n"
"...\n"
"tarantool> s:insert{10, 11, 9}\n"
"---\n"
"- [10, 11, 9]\n"
"...\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"  - [4, 5, 6]\n"
"  - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"...\n"
"tarantool> s.index.pk:select{4}\n"
"---\n"
"- - [4, 5, 6]\n"
"...\n"
"tarantool> s.index.sk_uniq:select{8}\n"
"---\n"
"- - [7, 8, 9]\n"
"...\n"
"tarantool> s.index.sk_non_uniq:select{9}\n"
"---\n"
"- - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"..."
msgstr ""
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:insert{4, 5, 6}\n"
"---\n"
"- [4, 5, 6]\n"
"...\n"
"tarantool> s:insert{7, 8, 9}\n"
"---\n"
"- [7, 8, 9]\n"
"...\n"
"tarantool> s:insert{10, 11, 9}\n"
"---\n"
"- [10, 11, 9]\n"
"...\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"  - [4, 5, 6]\n"
"  - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"...\n"
"tarantool> s.index.pk:select{4}\n"
"---\n"
"- - [4, 5, 6]\n"
"...\n"
"tarantool> s.index.sk_uniq:select{8}\n"
"---\n"
"- - [7, 8, 9]\n"
"...\n"
"tarantool> s.index.sk_non_uniq:select{9}\n"
"---\n"
"- - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"..."
