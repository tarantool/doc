
msgid "space_object:create_index()"
msgstr "space_object:create_index()"

msgid "Create an :ref:`index <index-box_index>`."
msgstr "Создание :ref:`индекса <index-box_index>`."

msgid ""
"It is mandatory to create an index for a space before trying to insert "
"tuples into it or select tuples from it. The first created index will be "
"used as the primary-key index, so it must be unique."
msgstr ""
"Обязательным условием является создание индекса для спейса до вставки в "
"спейс кортежей или выборки кортежей из него. Первый созданный индекс, "
"который будет использоваться в качестве первичного индекса, должен быть "
"уникальным."

msgid "Parameters"
msgstr "Параметры"

msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ":ref:`ссылка на объект <app_server-object_reference>`"

msgid ""
"name of index, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя индекса, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

msgid "index options (see :ref:`index_opts <index_opts_object>`)"
msgstr ""

msgid "return"
msgstr "возвращает"

msgid "index object"
msgstr "объект индекса"

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "index_object"
msgstr "index_object"

msgid "**Possible errors:**"
msgstr "**Возможные ошибки:**"

#, fuzzy
msgid "too many parts"
msgstr "слишком много частей;"

#, fuzzy
msgid "index '...' already exists"
msgstr "индекс '...' уже существует;"

#, fuzzy
msgid "primary key must be unique"
msgstr "первичный ключ должен быть уникальным."

#, fuzzy
msgid ""
"Building or rebuilding a large index will cause occasional :ref:`yields "
"<app-cooperative_multitasking>` so that other requests will not be blocked. "
"If the other requests cause an illegal situation such as a duplicate key in "
"a unique index, building or rebuilding such index will fail."
msgstr ""
"Сборка или пересборка большого индекса будет периодически вызывать "
":ref:`передачу управления <atomic-cooperative_multitasking>`, чтобы не "
"блокировать другие запросы. А если другой запрос приведет к ошибке, например"
" повторяющийся ключ в уникальном индексе, сборка или пересборка такого "
"индекса не выполнится."

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"-- Create a space --\n"
"bands = box.schema.space.create('bands')\n"
"\n"
"-- Specify field names and types --\n"
"box.space.bands:format({\n"
"    { name = 'id', type = 'unsigned' },\n"
"    { name = 'band_name', type = 'string' },\n"
"    { name = 'year', type = 'unsigned' }\n"
"})\n"
"\n"
"-- Create a primary index --\n"
"box.space.bands:create_index('primary', { parts = { 'id' } })\n"
"\n"
"-- Create a unique secondary index --\n"
"box.space.bands:create_index('band', { parts = { 'band_name' } })\n"
"\n"
"-- Create a non-unique secondary index --\n"
"box.space.bands:create_index('year', { parts = { { 'year' } }, unique = false })\n"
"\n"
"-- Create a multi-part index --\n"
"box.space.bands:create_index('year_band', { parts = { { 'year' }, { 'band_name' } } })\n"
msgstr ""

#, fuzzy
msgid "index_opts"
msgstr "index_object"

msgid ""
"Index options that include the index name, type, identifiers of key fields, "
"and so on. These options are passed to the :ref:`space_object.create_index()"
" <box_space-create_index>` method."
msgstr ""

#, fuzzy
msgid ""
"These options are also passed to "
":doc:`/reference/reference_lua/box_index/alter`."
msgstr ""
"Параметры из вышеприведенной таблицы также могут использоваться в "
":doc:`/reference/reference_lua/box_index/alter`."

#, fuzzy
msgid "The :ref:`index type <index-types>`."
msgstr "Создание :ref:`индекса <index-box_index>`."

#, fuzzy
msgid "Type: string"
msgstr "string"

msgid "Default: ``TREE``"
msgstr ""

msgid "Possible values: ``TREE``, ``HASH``, ``RTREE``, ``BITSET``"
msgstr ""

msgid ""
"A unique numeric identifier of the index, which is generated automatically."
msgstr ""

#, fuzzy
msgid "Type: number"
msgstr "number"

#, fuzzy
msgid "Default: last index's ID + 1"
msgstr "идентификатор последнего индекса +1"

msgid ""
"Specify whether an index may be unique. When ``true``, the index cannot "
"contain the same key value twice."
msgstr ""

#, fuzzy
msgid "Type: boolean"
msgstr "boolean"

#, fuzzy
msgid "Default: ``true``"
msgstr "``true``"

msgid ""
"-- Create a non-unique secondary index --\n"
"box.space.bands:create_index('year', { parts = { { 'year' } }, unique = false })\n"
msgstr ""

msgid ""
"Specify whether to swallow an error on an attempt to create an index with a "
"duplicated name."
msgstr ""

#, fuzzy
msgid "Default: ``false``"
msgstr "``false``"

msgid "Specify the index's key parts."
msgstr ""

msgid "Type: a table of :ref:`key_part <key_part_object>` values"
msgstr ""

#, fuzzy
msgid "Default: ``{1, ‘unsigned’}``"
msgstr "``{1, 'unsigned'}``"

msgid ""
"-- Create a primary index --\n"
"box.space.bands:create_index('primary', { parts = { 'id' } })\n"
"\n"
"-- Create a unique secondary index --\n"
"box.space.bands:create_index('band', { parts = { 'band_name' } })\n"
"\n"
"-- Create a non-unique secondary index --\n"
"box.space.bands:create_index('year', { parts = { { 'year' } }, unique = false })\n"
"\n"
"-- Create a multi-part index --\n"
"box.space.bands:create_index('year_band', { parts = { { 'year' }, { 'band_name' } } })\n"
msgstr ""

msgid "**Alternative way to declare index parts**"
msgstr "**Другой способ объявления оператора parts**"

msgid ""
"Before version :doc:`2.7.1 </release/2.7.1>`, if an index consisted of a "
"single part and had some options like ``is_nullable`` or ``collation`` and "
"its definition was written as"
msgstr ""
"Если раньше (до версии :doc:`2.7.1 </release/2.7.1>`) индекс состоял из "
"одной части, содержал дополнительные параметры, например ``is_nullable`` или"
" ``collation``, и был описан так:"

msgid ""
"my_space:create_index('one_part_idx', {parts = {1, 'unsigned', "
"is_nullable=true}})"
msgstr ""
"my_space:create_index('one_part_idx', {parts = {1, 'unsigned', "
"is_nullable=true}})"

msgid "(with the only brackets) then options were ignored by Tarantool."
msgstr ""
"(с одинарными фигурными скобками), то Tarantool игнорировал эти параметры."

msgid ""
"Since version :doc:`2.7.1 </release/2.7.1>` it is allowed to omit extra "
"braces in an index definition and use both ways:"
msgstr ""
"Начиная с версии :doc:`2.7.1 </release/2.7.1>`, при описании индекса можно "
"не указывать дополнительные фигурные скобки, но допускаются оба варианта:"

msgid ""
"-- with extra braces\n"
"my_space:create_index('one_part_idx', {parts = {{1, 'unsigned', is_nullable=true}}})\n"
"\n"
"-- without extra braces\n"
"my_space:create_index('one_part_idx', {parts = {1, 'unsigned', is_nullable=true}})"
msgstr ""
"-- с дополнительными фигурными скобками\n"
"my_space:create_index('one_part_idx', {parts = {{1, 'unsigned', is_nullable=true}}})\n"
"\n"
"-- без дополнительных фигурных скобок\n"
"my_space:create_index('one_part_idx', {parts = {1, 'unsigned', is_nullable=true}})"

msgid "The RTREE index dimension."
msgstr ""

#, fuzzy
msgid "Default: 2"
msgstr "Значение по умолчанию"

msgid "The RTREE index distance type."
msgstr ""

msgid "Default: ``euclid``"
msgstr ""

msgid "Possible values: ``euclid``, ``manhattan``"
msgstr ""

#, fuzzy
msgid ""
"Create a generator for indexes using a sequence object. Learn more from "
":ref:`specifying a sequence in create_index() <box_schema-"
"sequence_create_index>`."
msgstr ""
"см. раздел об :ref:`указании последовательности для create_index() "
"<box_schema-sequence_create_index>`"

#, fuzzy
msgid "Type: string or number"
msgstr "строка или число"

#, fuzzy
msgid ""
"Specify the identifier of the :ref:`functional index <box_space-index_func>`"
" function."
msgstr ":ref:`функциональный индекс <box_space-index_func>`"

#, fuzzy
msgid "**Since:** :doc:`2.6.1 </release/2.6.1>`"
msgstr "hint (с версии :doc:`2.6.1 </release/2.6.1>`)"

msgid "Specify whether hint optimization is enabled for the TREE index:"
msgstr ""

msgid "If ``true``, the index works faster."
msgstr ""

msgid "If ``false``, the index size is reduced by half."
msgstr ""

#, fuzzy
msgid "**Vinyl only**"
msgstr "только для vinyl"

msgid "Specify the bloom filter's false positive rate."
msgstr ""

msgid "Default: :ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"
msgstr ""

msgid "Specify the size of a page used for read and write disk operations."
msgstr ""

msgid "Default: :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"
msgstr ""

msgid "Specify the default maximum range size (in bytes) for a vinyl index."
msgstr ""

msgid "Default: :ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"
msgstr ""

msgid "Specify the maximum number of runs per level in the LSM tree."
msgstr ""

msgid ""
"Default: :ref:`vinyl_run_count_per_level <cfg_storage-"
"vinyl_run_count_per_level>`"
msgstr ""

msgid ""
"Specify the ratio between the sizes of different levels in the LSM tree."
msgstr ""

msgid ""
"Default: :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"
msgstr ""

#, fuzzy
msgid "key_part"
msgstr "parts"

msgid ""
"A descriptor of a single part in a multipart key. A table of parts is passed"
" to the :ref:`index_opts.parts <index_opts_parts>` option."
msgstr ""

msgid "Specify the field number or name."
msgstr ""

msgid ""
"To create a key part by a field name, you need to specify "
":ref:`space_object:format() <box_space-format>` first."
msgstr ""

#, fuzzy
msgid ""
"**Examples:** :ref:`Creating an index using field names and numbers "
"<box_space-field_names>`"
msgstr ""
":ref:`Создание индекса с использованием имен полей вместо номеров полей "
"<box_space-field_names>`"

msgid ""
"Specify the field type. If the field type is specified in "
":ref:`space_object:format() <box_space-format>`, ``key_part.type`` inherits "
"this value."
msgstr ""

#, fuzzy
msgid "Default: ``scalar``"
msgstr "``scalar``"

msgid ""
"Possible values: listed in :ref:`Indexed field types <index-box_indexed-"
"field-types>`"
msgstr ""

msgid ""
"Specify the :ref:`collation <index-collation>` used to compare field values."
" If the field collation is specified in :ref:`space_object:format() "
"<box_space-format>`, ``key_part.collation`` inherits this value."
msgstr ""

msgid ""
"Possible values: listed in the :ref:`box.space._collation <box_space-"
"collation>` system space"
msgstr ""

msgid ""
"-- Create a space --\n"
"box.schema.space.create('tester')\n"
"\n"
"-- Use the 'unicode' collation --\n"
"box.space.tester:create_index('unicode', { parts = { { field = 1,\n"
"                                                        type = 'string',\n"
"                                                        collation = 'unicode' } } })\n"
"\n"
"-- Use the 'unicode_ci' collation --\n"
"box.space.tester:create_index('unicode_ci', { parts = { { field = 1,\n"
"                                                        type = 'string',\n"
"                                                        collation = 'unicode_ci' } } })\n"
"\n"
"-- Insert test data --\n"
"box.space.tester:insert { 'ЕЛЕ' }\n"
"box.space.tester:insert { 'елейный' }\n"
"box.space.tester:insert { 'ёлка' }\n"
"\n"
"-- Returns nil --\n"
"select_unicode = box.space.tester.index.unicode:select({ 'ЁлКа' })\n"
"-- Returns 'ёлка' --\n"
"select_unicode_ci = box.space.tester.index.unicode_ci:select({ 'ЁлКа' })\n"
msgstr ""

msgid ""
"Specify whether ``nil`` (or its equivalent such as ``msgpack.NULL``) can be "
"used as a field value. If the ``is_nullable`` option is specified in "
":ref:`space_object:format() <box_space-format>`, ``key_part.is_nullable`` "
"inherits this value."
msgstr ""

msgid "You can set this option to ``true`` if:"
msgstr ""

msgid "the index type is TREE"
msgstr ""

#, fuzzy
msgid "the index is not the primary index"
msgstr "Функциональные индексы не должны быть по первичному ключу."

#, fuzzy
msgid ""
"It is also legal to insert nothing at all when using trailing nullable "
"fields. Within indexes, such null values are always treated as equal to "
"other null values and are always treated as less than non-null values. Nulls"
" may appear multiple times even in a unique index."
msgstr ""
"Если ``is_nullable=true``, то можно вставить ``nil`` или его эквивалент, "
"например ``msgpack.NULL``. Если завершающие поля допускают null, в них можно"
" вообще ничего не вставлять. В индексах такие значения null всегда считают "
"равными другим значениям null и они всегда меньше, чем отличные от null "
"значения. Null может встречаться несколько раз даже в уникальном индексе. "
"Пример:"

#, fuzzy
msgid "Default: false"
msgstr "Значение по умолчанию"

msgid ""
"box.space.tester:create_index('I', {unique = true, parts = {{field = 2, type"
" = 'number', is_nullable = true}}})"
msgstr ""
"box.space.tester:create_index('I', {unique = true, parts = {{field = 2, type"
" = 'number', is_nullable = true}}})"

#, fuzzy
msgid ""
"It is legal to create multiple indexes for the same field with different "
"``is_nullable`` values or to call "
":doc:`/reference/reference_lua/box_space/format` with a different "
"``is_nullable`` value from what is used for an index. When there is a "
"contradiction, the rule is: null is illegal unless ``is_nullable=true`` for "
"every index and for the space format."
msgstr ""
"Можно создать несколько индексов для одного и того же поля с различными "
"значениями ``is_nullable`` или вызвать "
":doc:`/reference/reference_lua/box_space/format` со значением "
"``is_nullable``, отличным от значения, которое используется для индекса. При"
" наличии несоответствий правило такое: запрещается использовать null, кроме "
"случаев, когда ``is_nullable=true`` для всех индексов и формата спейса."

#, fuzzy
msgid "**Since:** :doc:`2.8.2 </release/2.8.2>`"
msgstr "``uuid`` (с версии :doc:`2.4.1 </release/2.4.1>`)"

msgid ""
"Specify whether an index can skip tuples with null at this key part. You can"
" set this option to ``true`` if:"
msgstr ""

#, fuzzy
msgid ""
"If ``exclude_null`` is set to ``true``, ``is_nullable`` is set to ``true`` "
"automatically. Note that this option can be changed dynamically. In this "
"case, the index is rebuilt."
msgstr ""
"Значение этого параметра по умолчанию — ``false``. Если включить "
"``exclude_null``, то ``is_nullable=true`` будет указано автоматически. Для "
"первичного ключа использовать этот параметр нельзя. Параметр можно изменять "
"динамически, и в этом случае индекс будет перестроен."

msgid ""
"Such indexes do not store filtered tuples at all, so indexing can be done "
"faster."
msgstr ""
"Такие индексы вообще не хранят отфильтрованные кортежи, поэтому "
"индексирование будет выполняться быстрее."

msgid "Specify the path string for a map field."
msgstr ""

msgid "See the examples below:"
msgstr ""

#, fuzzy
msgid ""
":ref:`Creating an index using the path option for map fields <box_space-"
"path>`"
msgstr ""
":ref:`Создание индекса с использованием пути для полей с ассоциативными "
"массивами (индексы по пути JSON) <box_space-path>`"

#, fuzzy
msgid ""
":ref:`Creating a multikey index using the path option with [*] <box_space-"
"path_multikey>`"
msgstr ""
":ref:`Создание индекса по массивам (multikey) с использованием опции path с "
"символом [*] <box_space-path_multikey>`"

msgid "Examples"
msgstr "Примеры"

#, fuzzy
msgid "Creating an index using field names and numbers"
msgstr "Создание индекса с использованием имен полей вместо номеров полей"

#, fuzzy
msgid ""
"``create_index()`` can use field names or field numbers to define key parts."
msgstr "Создание индекса с использованием имен полей вместо номеров полей"

#, fuzzy
msgid "**Example 1 (field names):**"
msgstr "**Пример:**"

msgid "**Example 2 (field numbers):**"
msgstr ""

msgid ""
"-- Create a primary index --\n"
"box.space.bands:create_index('primary', { parts = { 1 } })\n"
"\n"
"-- Create a unique secondary index --\n"
"box.space.bands:create_index('band', { parts = { 2 } })\n"
"\n"
"-- Create a non-unique secondary index --\n"
"box.space.bands:create_index('year', { parts = { { 3 } }, unique = false })\n"
"\n"
"-- Create a multi-part index --\n"
"box.space.bands:create_index('year_band', { parts = { 3, 2 } })\n"
msgstr ""

msgid ""
"Creating an index using the path option for map fields (JSON-path indexes)"
msgstr ""
"Создание индекса с использованием пути для полей с ассоциативными массивами "
"(индексы по пути JSON)"

msgid ""
"To create an index for a field that is a map (a path string and a scalar "
"value), specify the path string during index creation, like this:"
msgstr ""
"Чтобы создать индекс для поля, которое представляет собой ассоциативный "
"массив (строка с путем и скалярное значение), укажите строку c путем во "
"время создания индекса:"

msgid ""
":extsamp:`parts = {{*{field-number}*}, {*{'data-type'}*}, path = {*{'path-"
"name'}*}}`"
msgstr ""
":extsamp:`parts = {{*{field-number}*}, {*{'data-type'}*}, path = {*{'path-"
"name'}*}}`"

msgid ""
"The index type must be TREE or HASH and the contents of the field must "
"always be maps with the same path."
msgstr ""
"Тип индекса должен быть TREE или HASH, а содержимое поля — всегда "
"ассоциативный массив с одним и тем же путем."

msgid "**Example 1 -- The simplest use of path:**"
msgstr "**Пример 1 — Простое использование пути:**"

#, fuzzy
msgid ""
"box.schema.space.create('space1')\n"
"box.space.space1:create_index('primary', { parts = { { field = 1,\n"
"                                                       type = 'scalar',\n"
"                                                       path = 'age' } } })\n"
"box.space.space1:insert({ { age = 44 } })\n"
"box.space.space1:select(44)\n"
msgstr ""
"tarantool> box.schema.space.create('T')\n"
"tarantool> box.space.T:create_index('I',{parts = {{field = 1, type = 'scalar', path = 'age'}}})\n"
"tarantool> box.space.T:insert({{age = 44}})\n"
"tarantool> box.space.T:select(44)\n"
"---\n"
"- [{'age': 44}]"

msgid "**Example 2 -- path plus format() plus JSON syntax to add clarity:**"
msgstr ""
"**Пример 2 — для большей наглядности используем path вместе с format() и "
"JSON-синтаксисом:**"

msgid ""
"box.schema.space.create('space2')\n"
"box.space.space2:format({ { 'id', 'unsigned' }, { 'data', 'map' } })\n"
"box.space.space2:create_index('info', { parts = { { 'data.full_name[\"firstname\"]', 'str' },\n"
"                                                  { 'data.full_name[\"surname\"]', 'str' } } })\n"
"box.space.space2:insert({ 1, { full_name = { firstname = 'John', surname = 'Doe' } } })\n"
"box.space.space2:select { 'John' }\n"
msgstr ""

msgid "Creating a multikey index using the path option with [*]"
msgstr ""
"Создание индекса по массивам (multikey) с использованием опции path с "
"символом [*]"

msgid ""
"The string in a path option can contain ``[*]`` which is called **an array "
"index placeholder**. Indexes defined with this are useful for JSON documents"
" that all have the same structure."
msgstr ""
"Строка в параметре пути может содержать символ ``[*]``, который называется "
"**заменителем индекса массива**. Описанные так индексы используются для "
"JSON-документов, у которых одинаковая структура."

msgid ""
"For example, when creating an index on field#2 for a string document that "
"will start with ``{'data': [{'name': '...'}, {'name': '...'}]``, the parts "
"section in the ``create_index`` request could look like:"
msgstr ""
"Например, при создании индекса по полю №2 для документа со строками, который"
" будет начинаться с ``{'data': [{'name': '...'}, {'name': '...'}]``, раздел "
"parts в запросе на создание индекса будет выглядеть так:"

msgid "parts = {{field = 2, type = 'str', path = 'data[*].name'}}"
msgstr "parts = {{field = 2, type = 'str', path = 'data[*].name'}}"

msgid ""
"Then tuples containing names can be retrieved quickly with "
"``index_object:select({key-value})``."
msgstr ""
"Тогда кортежи с именами можно быстро получить с помощью "
"``index_object:select({key-value})``."

#, fuzzy
msgid ""
"A single field can have multiple keys, as in this example which retrieves "
"the same tuple twice because there are two keys 'A' and 'B' which both match"
" the request:"
msgstr ""
"На самом деле в одном поле может быть несколько ключей, как в примере ниже, "
"который выводит один и тот же кортеж дважды, потому что оба ключа 'A' и 'B' "
"соответствуют запросу:"

msgid ""
"my_space = box.schema.space.create('json_documents')\n"
"my_space:create_index('primary')\n"
"multikey_index = my_space:create_index('multikey', {parts = {{field = 2, type = 'str', path = 'data[*].name'}}})\n"
"my_space:insert({1,\n"
"         {data = {{name = 'A'},\n"
"                  {name = 'B'}},\n"
"          extra_field = 1}})\n"
"multikey_index:select({''}, {iterator = 'GE'})"
msgstr ""
"my_space = box.schema.space.create('json_documents')\n"
"my_space:create_index('primary')\n"
"multikey_index = my_space:create_index('multikey', {parts = {{field = 2, type = 'str', path = 'data[*].name'}}})\n"
"my_space:insert({1,\n"
"         {data = {{name = 'A'},\n"
"                  {name = 'B'}},\n"
"          extra_field = 1}})\n"
"multikey_index:select({''}, {iterator = 'GE'})"

msgid "The result of the select request looks like this:"
msgstr "Результат выборки будет выглядеть так:"

msgid ""
"tarantool> multikey_index:select({''},{iterator='GE'})\n"
"---\n"
"- - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"- [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"..."
msgstr ""
"tarantool> multikey_index:select({''},{iterator='GE'})\n"
"---\n"
"- - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"- [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"..."

#, fuzzy
msgid "The following restrictions exist:"
msgstr "Есть некоторые ограничения:"

msgid "``[*]`` must be alone or must be at the end of a name in the path."
msgstr "символ ``[*]`` должен стоять отдельно или в конце имени в пути."

msgid "``[*]`` must not appear twice in the path."
msgstr "символ ``[*]`` не должен повторяться в пути."

msgid ""
"If an index has a path with ``x[*]``, then no other index can have a path "
"with x.component."
msgstr ""
"Если в индексе есть путь с ``x[*]``, то в никаком другом индексе не может "
"быть пути с x.компонентом,"

msgid "``[*]`` must not appear in the path of a primary key."
msgstr "``[*]`` нельзя указывать в пути первичного ключа."

msgid ""
"If an index has ``unique=true`` and has a path with ``[*]``, then duplicate "
"keys from different tuples are disallowed, but duplicate keys for the same "
"tuple are allowed."
msgstr ""
"Если индекс должен быть уникальным (``unique=true``) и в нем есть путь с "
"символом ``[*]``, то запрещается использовать дублирующиеся ключи в разных "
"кортежах, но в в одном кортеже можно использовать дублирующиеся ключи."

msgid ""
"The field's value must have the same structure as in the path definition, or"
" be nil (nil is not indexed)."
msgstr ""
"Структура значения поля должна соответствовать стуктуре, заданной в "
"определении пути, или значение поля должно быть nil (nil не индексируется)."

msgid ""
"In a space with multikey indexes, any tuple cannot contain :ref:`more than "
"~8,000 elements <limitations_fields_in_tuple_multikey_index>` indexed that "
"way."
msgstr ""
"В спейсе с индексами по массивам можно хранить не более :ref:`~8000 "
"элементов <limitations_fields_in_tuple_multikey_index>`, проиндексированных "
"таким образом."

msgid "Creating a functional index"
msgstr "Создание функционального индекса"

msgid ""
"Functional indexes are indexes that call a user-defined function for forming"
" the index key, rather than depending entirely on the Tarantool default "
"formation. Functional indexes are useful for condensing or truncating or "
"reversing or any other way that users want to customize the index."
msgstr ""
"Функциональные индексы — это индексы, которые вызывают пользовательскую "
"функцию для формирования ключа индекса, в отличие от других типов индексов, "
"где ключ формирует сам Tarantool. Функциональные индексы используют для "
"сжатия, усечения или реверсирования или любого другого изменения индекса по "
"желанию пользователя."

msgid "There are several recommendations for building functional indexes:"
msgstr "Ниже приведены рекомендации по созданию функциональных индексов:"

#, fuzzy
msgid ""
"The function definition must expect a tuple, which has the contents of "
"fields at the time a data-change request happens, and must return a tuple, "
"which has the contents that will be put in the index."
msgstr ""
"Функция должна принимать кортеж с содержимым полей на момент запроса на "
"изменение данных и возвращать кортеж с содержимым, которое будет фактически "
"помещено в индекс."

#, fuzzy
msgid ""
"The ``create_index`` definition must include the specification of all key "
"parts, and the custom function must return a table that has the same number "
"of key parts with the same types."
msgstr ""
"Описание ``create_index`` должно включать в себя определение всех частей "
"ключа, а пользовательская функция должна возвращать таблицу, которая "
"содержит то же количество частей ключа с теми же типами."

msgid "The space must have a memtx engine."
msgstr "Спейс должен быть на движке memtx."

msgid ""
"The function must be persistent and deterministic (see :ref:`Creating a "
"function with body <box_schema-func_create_with-body>`)."
msgstr ""
"Функция должна быть персистентной и детерминированной (см. :ref:`Создание "
"функции с телом <box_schema-func_create_with-body>`)."

msgid "The key parts must not depend on JSON paths."
msgstr "Части ключа не должны зависеть от JSON-путей."

msgid "The function must access key-part values by index, not by field name."
msgstr ""
"Функция должна получать доступ к значениям частей ключа по индексу, а не по "
"имени поля."

msgid "Functional indexes must not be primary-key indexes."
msgstr "Функциональные индексы не должны быть по первичному ключу."

msgid ""
"Functional indexes cannot be altered and the function cannot be changed if "
"it is used for an index, so the only way to change them is to drop the index"
" and create it again."
msgstr ""
"Нельзя изменить ни функциональные индексы, ни функцию, если она используется"
" для индекса, то есть единственный способ изменить их — это удалить индекс и"
" создать его заново."

msgid ""
"Only :ref:`sandboxed <box_schema-func_create_with-body>` functions are "
"suitable for functional indexes."
msgstr ""
"Только функции, :ref:`запущенные из песочницы <box_schema-func_create_with-"
"body>`, могут использоваться в функциональных индексах."

msgid ""
"A function could make a key using only the first letter of a string field."
msgstr ""
"Функция может создать ключ, используя только первую букву строкового поля."

msgid ""
"Create a space. The space needs a primary-key field, which is not the field "
"that we will use for the functional index:"
msgstr ""
"Создайте спейс. В спейсе должно быть поле с первичным ключом, которое не "
"будет полем для функционального индекса:"

#, fuzzy
msgid ""
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('i', { parts = { { field = 1, type = 'string' } } })\n"
msgstr ""
"box.schema.space.create('tester', {engine = 'memtx'})\n"
"box.space.tester:create_index('i',{parts={{field = 1, type = 'string'}}})"

msgid ""
"Create a function. The function expects a tuple. In this example, it will "
"work on tuple[2] because the key source is field number 2 in what we will "
"insert. Use ``string.sub()`` from the ``string`` module to get the first "
"character:"
msgstr ""
"Создайте функцию. Функция принимает кортеж. В этом примере она работает на "
"кортеже tuple[2], поскольку источник ключа — поле номер 2, в которое мы "
"вставляем данные. Используйте ``string.sub()`` из модуля ``string``, чтобы "
"получить первый символ:"

#, fuzzy
msgid ""
"function_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]\n"
msgstr "lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]"

msgid ""
"Make the function persistent using the ``box.schema.func.create`` function:"
msgstr "Сделайте функцию персистентной с помощью ``box.schema.create``:"

#, fuzzy
msgid ""
"box.schema.func.create('my_func',\n"
"        { body = function_code, is_deterministic = true, is_sandboxed = true })\n"
msgstr ""
"box.schema.func.create('my_func',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})"

#, fuzzy
msgid ""
"Create a functional index. Specify the fields whose values will be passed to"
" the function. Specify the function:"
msgstr ""
"Создайте функциональный индекс. Укажите поля, значения которых будут "
"передаваться в функцию. Укажите функцию:"

#, fuzzy
msgid ""
"box.space.tester:create_index('func_index', { parts = { { field = 1, type = 'string' } },\n"
"                                              func = 'my_func' })\n"
msgstr ""
"box.space.tester:create_index('func_idx',{parts={{field = 1, type = "
"'string'}},func = 'my_func'})"

#, fuzzy
msgid ""
"Insert a few tuples. Select using only the first letter, it will work "
"because that is the key. Or, select using the same function as was used for "
"insertion:"
msgstr ""
"Проверьте, как это работает. Вставьте несколько кортежей. Сделайте выборку, "
"используя только первую букву, — сработает, потому что это и есть ключ. Или "
"выберите, используя ту же функцию, что была использована для вставки:"

#, fuzzy
msgid ""
"box.space.tester:insert({ 'a', 'wombat' })\n"
"box.space.tester:insert({ 'b', 'rabbit' })\n"
"box.space.tester.index.func_index:select('w')\n"
"box.space.tester.index.func_index:select(box.func.my_func:call({ { 'tester', 'wombat' } }))\n"
msgstr ""
"box.space.tester:insert({'a', 'wombat'})\n"
"box.space.tester:insert({'b', 'rabbit'})\n"
"box.space.tester.index.func_idx:select('w')\n"
"box.space.tester.index.func_idx:select(box.func.my_func:call({{'tester', 'wombat'}}));"

msgid "The results of the two ``select`` requests will look like this:"
msgstr "Результаты двух запросов ``select`` будут выглядеть так:"

#, fuzzy
msgid ""
"tarantool> box.space.tester.index.func_index:select('w')\n"
"---\n"
"- - ['a', 'wombat']\n"
"...\n"
"tarantool> box.space.tester.index.func_index:select(box.func.my_func:call({{'tester','wombat'}}));\n"
"---\n"
"- - ['a', 'wombat']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.func_idx:select('w')\n"
"---\n"
"- - ['a', 'wombat']\n"
"...\n"
"tarantool> box.space.tester.index.func_idx:select(box.func.my_func:call({{'tester','wombat'}}));\n"
"---\n"
"- - ['a', 'wombat']\n"
"..."

msgid "Here is the full code of the example:"
msgstr "Вот пример кода полностью:"

#, fuzzy
msgid ""
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('i', { parts = { { field = 1, type = 'string' } } })\n"
"function_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]\n"
"box.schema.func.create('my_func',\n"
"        { body = function_code, is_deterministic = true, is_sandboxed = true })\n"
"box.space.tester:create_index('func_index', { parts = { { field = 1, type = 'string' } },\n"
"                                              func = 'my_func' })\n"
"box.space.tester:insert({ 'a', 'wombat' })\n"
"box.space.tester:insert({ 'b', 'rabbit' })\n"
"box.space.tester.index.func_index:select('w')\n"
"box.space.tester.index.func_index:select(box.func.my_func:call({ { 'tester', 'wombat' } }))\n"
msgstr ""
"box.schema.space.create('tester', {engine = 'memtx'})\n"
"box.space.tester:create_index('i',{parts={{field = 1, type = 'string'}}})\n"
"lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]\n"
"box.schema.func.create('my_func',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})\n"
"box.space.tester:create_index('func_idx',{parts={{field = 1, type = 'string'}},func = 'my_func'})\n"
"box.space.tester:insert({'a', 'wombat'})\n"
"box.space.tester:insert({'b', 'rabbit'})\n"
"box.space.tester.index.func_idx:select('w')\n"
"box.space.tester.index.func_idx:select(box.func.my_func:call({{'tester', 'wombat'}}));"

msgid ""
"Functions for functional indexes can return **multiple keys**. Such "
"functions are called \"multikey\" functions."
msgstr ""
"Функции для функциональных индексов могут возвращать **множество ключей**. "
"Такие функции называют \"мультиключевыми\" (multikey)."

#, fuzzy
msgid ""
"To create a multikey function, the options of ``box.schema.func.create()`` "
"must include ``is_multikey = true``. The return value must be a table of "
"tuples. If a multikey function returns N tuples, then N keys will be added "
"to the index."
msgstr ""
"В таком случае в ``box.func.create`` надо включить ``opts = {is_multikey = "
"true}``. Возвращается таблица с кортежами. Если мультиключевая функция "
"возвращает N кортежей, то в индекс добавятся N ключей."

#, fuzzy
msgid ""
"tester = box.schema.space.create('withdata')\n"
"tester:format({ { name = 'name', type = 'string' },\n"
"                { name = 'address', type = 'string' } })\n"
"name_index = tester:create_index('name', { parts = { { field = 1, type = 'string' } } })\n"
"function_code = [[function(tuple)\n"
"       local address = string.split(tuple[2])\n"
"       local ret = {}\n"
"       for _, v in pairs(address) do\n"
"         table.insert(ret, {utf8.upper(v)})\n"
"       end\n"
"       return ret\n"
"     end]]\n"
"box.schema.func.create('address',\n"
"        { body = function_code,\n"
"          is_deterministic = true,\n"
"          is_sandboxed = true,\n"
"          is_multikey = true })\n"
"addr_index = tester:create_index('addr', { unique = false,\n"
"                                           func = 'address',\n"
"                                           parts = { { field = 1, type = 'string',\n"
"                                                  collation = 'unicode_ci' } } })\n"
"tester:insert({ \"James\", \"SIS Building Lambeth London UK\" })\n"
"tester:insert({ \"Sherlock\", \"221B Baker St Marylebone London NW1 6XE UK\" })\n"
"addr_index:select('Uk')\n"
msgstr ""
"s = box.schema.space.create('withdata')\n"
"s:format({{name = 'name', type = 'string'},\n"
"          {name = 'address', type = 'string'}})\n"
"pk = s:create_index('name', {parts = {{field = 1, type = 'string'}}})\n"
"lua_code = [[function(tuple)\n"
"               local address = string.split(tuple[2])\n"
"               local ret = {}\n"
"               for _, v in pairs(address) do\n"
"                 table.insert(ret, {utf8.upper(v)})\n"
"               end\n"
"               return ret\n"
"             end]]\n"
"box.schema.func.create('address',\n"
"                        {body = lua_code,\n"
"                         is_deterministic = true,\n"
"                         is_sandboxed = true,\n"
"                         opts = {is_multikey = true}})\n"
"idx = s:create_index('addr', {unique = false,\n"
"                              func = 'address',\n"
"                              parts = {{field = 1, type = 'string',\n"
"                                      collation = 'unicode_ci'}}})\n"
"s:insert({\"James\", \"SIS Building Lambeth London UK\"})\n"
"s:insert({\"Sherlock\", \"221B Baker St Marylebone London NW1 6XE UK\"})\n"
"idx:select('Uk')\n"
"-- Вернутся оба кортежа."

#~ msgid "On this page:"
#~ msgstr "На этой странице:"

#~ msgid ":ref:`create_index() description <box_space-create_index>`"
#~ msgstr ":ref:`Описание create_index() <box_space-create_index>`"

#~ msgid ""
#~ ":ref:`Details about index field types <details_about_index_field_types>`"
#~ msgstr ""
#~ ":ref:`Описание типов индексируемых полей <details_about_index_field_types>`"

#~ msgid ":ref:`Allowing null for an indexed key <box_space-is_nullable>`"
#~ msgstr ""
#~ ":ref:`Использование null для индексируемого ключа <box_space-is_nullable>`"

#~ msgid ":ref:`Creating a functional index <box_space-index_func>`"
#~ msgstr ":ref:`Создание функционального индекса <box_space-index_func>`"

#~ msgid "see \"Options for space_object:create_index()\", below"
#~ msgstr "см. \"Параметры для space_object:create_index()\" ниже"

#~ msgid "**Options for space_object:create_index()**"
#~ msgstr "**Параметры для space_object:create_index()**"

#~ msgid "Name"
#~ msgstr "Имя"

#~ msgid "Effect"
#~ msgstr "Описание"

#~ msgid "Type"
#~ msgstr "Тип"

#~ msgid "type"
#~ msgstr "type"

#~ msgid "type of index"
#~ msgstr "тип индекса"

#~ msgid ""
#~ "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE') Note re storage engine: "
#~ "vinyl only supports 'TREE'"
#~ msgstr ""
#~ "string ('HASH', или 'TREE', или 'BITSET', или 'RTREE') Примечание про движок"
#~ " базы данных: vinyl поддерживает только 'TREE'"

#~ msgid "'TREE'"
#~ msgstr "'TREE'"

#~ msgid "id"
#~ msgstr "id"

#~ msgid "unique identifier"
#~ msgstr "уникальный идентификатор"

#~ msgid "unique"
#~ msgstr "unique"

#~ msgid "index is unique"
#~ msgstr "индекс уникален"

#~ msgid "if_not_exists"
#~ msgstr "if_not_exists"

#~ msgid "no error if duplicate name"
#~ msgstr "ошибки нет, если имя дублируется"

#~ msgid "field-numbers  + types"
#~ msgstr "номера поля + типы"

#~ msgid ""
#~ "{field_no, ``'unsigned'`` or ``'string'`` or ``'integer'`` or ``'number'`` "
#~ "or ``'double'`` or ``'decimal'`` or ``'boolean'`` or ``'varbinary'`` or "
#~ "``'uuid'`` or ``'array'`` or ``'scalar'``, and optional collation or "
#~ "is_nullable value or path}"
#~ msgstr ""
#~ "{field_no, ``'unsigned'``, или ``'string'``, или ``'integer'``, или "
#~ "``'number'``, или ``'double'``, или ``'decimal'``, или ``'boolean'``, или "
#~ "``'varbinary'``, или ``'uuid'``, или ``'array'``, или ``'scalar'``, и "
#~ "дополнительная сортировка, или значение is_nullable, или путь}"

#~ msgid "dimension"
#~ msgstr "dimension"

#~ msgid "affects :ref:`RTREE <box_index-rtree>` only"
#~ msgstr "только для :ref:`RTREE <box_index-rtree>`"

#~ msgid "2"
#~ msgstr "2"

#~ msgid "distance"
#~ msgstr "distance"

#~ msgid "affects RTREE only"
#~ msgstr "только для RTREE"

#~ msgid "string ('euclid' or 'manhattan')"
#~ msgstr ""
#~ "строка ('euclid', то есть Евклидова метрика; или 'manhattan', то есть "
#~ "расстояние городских кварталов)"

#~ msgid "'euclid'"
#~ msgstr "'euclid'"

#~ msgid "bloom_fpr"
#~ msgstr "bloom_fpr"

#~ msgid "``vinyl_bloom_fpr``"
#~ msgstr "``vinyl_bloom_fpr``"

#~ msgid "page_size"
#~ msgstr "page_size"

#~ msgid "``vinyl_page_size``"
#~ msgstr "``vinyl_page_size``"

#~ msgid "range_size"
#~ msgstr "range_size"

#~ msgid "``vinyl_range_size``"
#~ msgstr "``vinyl_range_size``"

#~ msgid "run_count_per_level"
#~ msgstr "run_count_per_level"

#~ msgid "``vinyl_run_count_per_level``"
#~ msgstr "``vinyl_run_count_per_level``"

#~ msgid "run_size_ratio"
#~ msgstr "run_size_ratio"

#~ msgid "``vinyl_run_size_ratio``"
#~ msgstr "``vinyl_run_size_ratio``"

#~ msgid "sequence"
#~ msgstr "sequence"

#~ msgid "not present"
#~ msgstr "отсутствует"

#~ msgid "func"
#~ msgstr "func"

#~ msgid ""
#~ "affects TREE only. ``true`` makes an index work faster, ``false`` -- an "
#~ "index size is reduced by half"
#~ msgstr ""
#~ "только для TREE. ``true`` заставит индекс работать быстрее, ``false`` — "
#~ "размер индекса будет уменьшен наполовину"

#~ msgid ""
#~ "**Note re storage engine:** vinyl has extra options which by default are "
#~ "based on configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-"
#~ "vinyl_bloom_fpr>`, :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
#~ ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
#~ ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`, "
#~ "and :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- see "
#~ "the description of those parameters. The current values can be seen by "
#~ "selecting from :doc:`/reference/reference_lua/box_space/_index`."
#~ msgstr ""
#~ "**Примечание про движок базы данных:** в vinyl есть дополнительные "
#~ "параметры, которые по умолчанию основаны на конфигурационных параметрах "
#~ ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`, :ref:`vinyl_page_size "
#~ "<cfg_storage-vinyl_page_size>`, :ref:`vinyl_range_size <cfg_storage-"
#~ "vinyl_range_size>`, :ref:`vinyl_run_count_per_level <cfg_storage-"
#~ "vinyl_run_count_per_level>` и :ref:`vinyl_run_size_ratio <cfg_storage-"
#~ "vinyl_run_size_ratio>`, см. описание этих параметров. Текущие значения можно"
#~ " увидеть, сделав выборку из "
#~ ":doc:`/reference/reference_lua/box_space/_index`."

#~ msgid ""
#~ "tarantool> my_space = box.schema.space.create('tester')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> my_space:create_index('primary', {unique = true, parts = {\n"
#~ "         > {field = 1, type = 'unsigned'},\n"
#~ "         > {field = 2, type = 'string'}\n"
#~ "         > }})\n"
#~ "---\n"
#~ "- unique: true\n"
#~ "  parts:\n"
#~ "  - type: unsigned\n"
#~ "    is_nullable: false\n"
#~ "    fieldno: 1\n"
#~ "  - type: string\n"
#~ "    is_nullable: false\n"
#~ "    fieldno: 2\n"
#~ "  id: 0\n"
#~ "  space_id: 512\n"
#~ "  type: TREE\n"
#~ "  name: primary\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> my_space = box.schema.space.create('tester')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> my_space:create_index('primary', {unique = true, parts = {\n"
#~ "         > {field = 1, type = 'unsigned'},\n"
#~ "         > {field = 2, type = 'string'}\n"
#~ "         > }})\n"
#~ "---\n"
#~ "- unique: true\n"
#~ "  parts:\n"
#~ "  - type: unsigned\n"
#~ "    is_nullable: false\n"
#~ "    fieldno: 1\n"
#~ "  - type: string\n"
#~ "    is_nullable: false\n"
#~ "    fieldno: 2\n"
#~ "  id: 0\n"
#~ "  space_id: 512\n"
#~ "  type: TREE\n"
#~ "  name: primary\n"
#~ "..."

#~ msgid "Details about index field types"
#~ msgstr "Описание типов индексируемых полей"

#~ msgid ""
#~ "Index field types differ depending on what values are allowed, and what "
#~ "index types are allowed."
#~ msgstr ""
#~ "В зависимости от допустимых типов индексов и допустимых значений "
#~ "используются различные типы индексируемых полей."

#~ msgid "Index field type"
#~ msgstr "Тип поля для индексирования"

#~ msgid "What can be in it"
#~ msgstr "Чем может быть"

#~ msgid "Where it is legal"
#~ msgstr "Где использовать"

#~ msgid "``unsigned``"
#~ msgstr "``unsigned``"

#~ msgid ""
#~ "unsigned integers between 0 and 18446744073709551615, about 18 quintillion. "
#~ "May also be called 'uint' or 'num', but 'num' is deprecated"
#~ msgstr ""
#~ "беззнаковые целые числа от 0 до 18 446 744 073 709 551 615, то есть примерно"
#~ " 18 квинтиллионов. Также может называться 'uint' или 'num', но 'num' "
#~ "объявлен устаревшим"

#~ msgid "memtx TREE or HASH indexes;"
#~ msgstr "индексы типа TREE или HASH в memtx;"

#~ msgid "vinyl TREE indexes"
#~ msgstr "TREE-индексы в vinyl"

#~ msgid "123456"
#~ msgstr "123456"

#~ msgid "``string``"
#~ msgstr "``string``"

#~ msgid ""
#~ "any set of octets, up to the :ref:`maximum length "
#~ "<limitations_bytes_in_index_key>`. May also be called 'str'. A string may "
#~ "have a :ref:`collation <index-collation>`"
#~ msgstr ""
#~ "любая последовательность октетов до :ref:`максимальной длины "
#~ "<limitations_bytes_in_index_key>`. Также может называться 'str'. В строке "
#~ "может быть :ref:`сортировка <index-collation>`"

#~ msgid "memtx TREE or HASH or BITSET indexes;"
#~ msgstr "индексы типа TREE, HASH или BITSET в memtx;"

#~ msgid "'A B C'"
#~ msgstr "'A B C'"

#~ msgid "'\\\\65 \\\\66 \\\\67'"
#~ msgstr "'\\\\65 \\\\66 \\\\67'"

#~ msgid "``varbinary``"
#~ msgstr "``varbinary``"

#~ msgid ""
#~ "any set of octets, up to the :ref:`maximum length "
#~ "<limitations_bytes_in_index_key>`. A varbinary byte sequence does not have a"
#~ " :ref:`collation <index-collation>` because its contents are not UTF-8 "
#~ "characters"
#~ msgstr ""
#~ "любая последовательность октетов до :ref:`максимальной длины "
#~ "<limitations_bytes_in_index_key>`. Последовательность байтов varbinary не "
#~ "содержит символы UTF-8, поэтому в ней нет :ref:`сортировки <index-"
#~ "collation>`"

#~ msgid ""
#~ "memtx TREE, HASH or BITSET (since version :doc:`2.7.1 </release/2.7.1>`) "
#~ "indexes;"
#~ msgstr ""
#~ "индексы типа TREE, HASH или BITSET в memtx (начиная с версии :doc:`2.7.1 "
#~ "</release/2.7.1>`);"

#~ msgid "``integer``"
#~ msgstr "``integer``"

#~ msgid ""
#~ "integers between -9223372036854775808 and 18446744073709551615. May also be "
#~ "called 'int'"
#~ msgstr ""
#~ "целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615. "
#~ "Может также называться 'int'"

#~ msgid "-2^63"
#~ msgstr "-2^63"

#~ msgid "``number``"
#~ msgstr "``number``"

#~ msgid ""
#~ "integers between -9223372036854775808 and 18446744073709551615, single-"
#~ "precision floating point numbers, or double-precision floating point "
#~ "numbers, or exact numbers"
#~ msgstr ""
#~ "целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615, "
#~ "числа одинарной точности с плавающей запятой, числа двойной точности с "
#~ "плавающей запятой или точные числа"

#~ msgid "1.234"
#~ msgstr "1.234"

#~ msgid "-44"
#~ msgstr "-44"

#~ msgid "1.447e+44"
#~ msgstr "1.447e+44"

#~ msgid "``double``"
#~ msgstr "``double``"

#~ msgid "double-precision floating point numbers"
#~ msgstr "числа двойной точности с плавающей запятой"

#~ msgid "``boolean``"
#~ msgstr "``boolean``"

#~ msgid "true or false"
#~ msgstr "true или false"

#~ msgid "false"
#~ msgstr "false"

#~ msgid "``decimal``"
#~ msgstr "``decimal``"

#~ msgid ""
#~ "exact number returned from a function in the :ref:`decimal <decimal>` module"
#~ msgstr ""
#~ "точное число, которая возвращает функция из модуля :ref:`decimal <decimal>`"

#~ msgid "decimal.new(1.2)"
#~ msgstr "decimal.new(1.2)"

#~ msgid ""
#~ "a 128-bit quantity sequence of lower-case hexadecimal digits, representing "
#~ "Universally Unique Identifiers (UUID)"
#~ msgstr ""
#~ "128-разрядная последовательность шестнадцатеричных чисел нижнего регистра, "
#~ "которая представляет собой Универсальный уникальный идентификатор (UUID)"

#~ msgid "uuid.fromstr('64d22e4d-ac92-4a23-899a-e59f34af5479')"
#~ msgstr "uuid.fromstr('64d22e4d-ac92-4a23-899a-e59f34af5479')"

#~ msgid "``array``"
#~ msgstr "``array``"

#~ msgid "array of numbers"
#~ msgstr "массив чисел"

#~ msgid "memtx :ref:`RTREE <box_index-rtree>` indexes"
#~ msgstr "индексы типа :ref:`RTREE <box_index-rtree>` в memtx"

#~ msgid "{10, 11}"
#~ msgstr "{10, 11}"

#~ msgid "{3, 5, 9, 10}"
#~ msgstr "{3, 5, 9, 10}"

#~ msgid ""
#~ "null (input with ``msgpack.NULL`` or ``yaml.NULL`` or ``json.NULL``), "
#~ "booleans (true or false), or integers between -9223372036854775808 and "
#~ "18446744073709551615, or single-precision floating point numbers, or double-"
#~ "precision floating point numbers, or exact numbers, or strings, or "
#~ "(varbinary) byte arrays, or uuids. When there is a mix of types, the key "
#~ "order is: null, then booleans, then numbers, then strings, then byte arrays,"
#~ " then uuids."
#~ msgstr ""
#~ "null (вводится через ``msgpack.NULL``, ``yaml.NULL`` или ``json.NULL``), "
#~ "логические значения (``true`` или ``false``), целые числа от −9 223 372 036 "
#~ "854 775 808 до 18 446 744 073 709 551 615, числа одинарной и двойной "
#~ "точности с плавающей запятой, точные числа, строки, байтовые массивы "
#~ "(varbinary) или идентификаторы UUID. Если используется несколько типов, "
#~ "порядок ключей следующий: null, логические значения, числа, строки, байтовые"
#~ " массивы, идентификаторы UUID."

#~ msgid "null"
#~ msgstr "null"

#~ msgid "true"
#~ msgstr "true"

#~ msgid "-1"
#~ msgstr "-1"

#~ msgid "''"
#~ msgstr "''"

#~ msgid "'ру'"
#~ msgstr "'ру'"

#~ msgid "``nil``"
#~ msgstr "``nil``"

#~ msgid ""
#~ "Additionally, `nil` is allowed with any index field type if "
#~ ":ref:`is_nullable=true <box_space-is_nullable>` is specified"
#~ msgstr ""
#~ "Кроме того, допускается использовать `nil` с любым типом индексируемого "
#~ "поля, если указать :ref:`is_nullable=true <box_space-is_nullable>`"

#~ msgid "Allowing null for an indexed key"
#~ msgstr "Использование null в ключе индекса"

#~ msgid "is_nullable parts option"
#~ msgstr "is_nullable в операторе parts"

#~ msgid ""
#~ "If the index type is TREE, and the index is not the primary index, then the "
#~ "``parts={...}`` clause may include ``is_nullable=true`` or "
#~ "``is_nullable=false`` (the default)."
#~ msgstr ""
#~ "Если тип индекса — TREE, а индекс не является первичным, то в оператор "
#~ "``parts={...}`` можно включить ``is_nullable=true`` или "
#~ "``is_nullable=false`` (по умолчанию)."

#~ msgid "exclude_null parts option"
#~ msgstr "exclude_null в операторе parts"

#~ msgid ""
#~ "Since version 2.8.2 an index part definition may include option "
#~ "``exclude_null``, which allows an index to skip tuples with null at this "
#~ "part."
#~ msgstr ""
#~ "Начиная с версии 2.8.2, при описании индекса можно указать параметр "
#~ "``exclude_null``, чтобы индекс пропускал кортежи со значением null в этой "
#~ "части."

#~ msgid ""
#~ "``exclude_null`` and ``is_nullable`` are connected, so this table describes "
#~ "the result of combining them:"
#~ msgstr ""
#~ "``exclude_null`` и ``is_nullable`` взаимосвязаны, поэтому ниже приводится "
#~ "таблица допустимых сочетаний значений этих параметров:"

#~ msgid "**exclude_null/is_nullable**"
#~ msgstr "**exclude_null/is_nullable**"

#~ msgid "**false**"
#~ msgstr "**false**"

#~ msgid "**true**"
#~ msgstr "**true**"

#~ msgid "ok"
#~ msgstr "допускается"

#~ msgid "not allowed"
#~ msgstr "не допускается"

#~ msgid ""
#~ "``create_index()`` can use field names and/or field types described by the "
#~ "optional :doc:`/reference/reference_lua/box_space/format` clause."
#~ msgstr ""
#~ "``create_index()`` может использовать имена полей и / или номера полей, "
#~ "которые описаны в необязательном операторе "
#~ ":doc:`/reference/reference_lua/box_space/format`."

#~ msgid ""
#~ "In the following example, we show ``format()`` for a space that has two "
#~ "columns named 'x' and 'y', and then we show five variations of the "
#~ "``parts={}`` clause of ``create_index()``, first for the 'x' column, second "
#~ "for both the 'x' and 'y' columns. The variations include omitting the type, "
#~ "using numbers, and adding extra braces."
#~ msgstr ""
#~ "В следующем примере мы покажем использование ``format()`` для спейса с двумя"
#~ " столбцами 'x' и 'y', а затем — пять вариантов использования оператора "
#~ "``parts={}`` в ``create_index()`` сначала для столбца 'x', затем для "
#~ "столбцов 'x' и 'y'. Эти варианты включают в себя пропуск типа, использование"
#~ " чисел и дополнительных скобок."

#~ msgid ""
#~ "box.space.tester:format({{name = 'x', type = 'scalar'}, {name = 'y', type = 'integer'}})\n"
#~ "\n"
#~ "box.space.tester:create_index('I2', {parts = {{'x', 'scalar'}}})\n"
#~ "box.space.tester:create_index('I3', {parts = {{'x', 'scalar'}, {'y', 'integer'}}})\n"
#~ "\n"
#~ "box.space.tester:create_index('I4', {parts = {{1, 'scalar'}}})\n"
#~ "box.space.tester:create_index('I5', {parts = {{1, 'scalar'}, {2, 'integer'}}})\n"
#~ "\n"
#~ "box.space.tester:create_index('I6', {parts = {1}})\n"
#~ "box.space.tester:create_index('I7', {parts = {1, 2}})\n"
#~ "\n"
#~ "box.space.tester:create_index('I8', {parts = {'x'}})\n"
#~ "box.space.tester:create_index('I9', {parts = {'x', 'y'}})\n"
#~ "\n"
#~ "box.space.tester:create_index('I10', {parts = {{'x'}}})\n"
#~ "box.space.tester:create_index('I11', {parts = {{'x'}, {'y'}}})"
#~ msgstr ""
#~ "box.space.tester:format({{name = 'x', type = 'scalar'}, {name = 'y', type = 'integer'}})\n"
#~ "\n"
#~ "box.space.tester:create_index('I2', {parts = {{'x', 'scalar'}}})\n"
#~ "box.space.tester:create_index('I3', {parts = {{'x', 'scalar'}, {'y', 'integer'}}})\n"
#~ "\n"
#~ "box.space.tester:create_index('I4', {parts = {{1, 'scalar'}}})\n"
#~ "box.space.tester:create_index('I5', {parts = {{1, 'scalar'}, {2, 'integer'}}})\n"
#~ "\n"
#~ "box.space.tester:create_index('I6', {parts = {1}})\n"
#~ "box.space.tester:create_index('I7', {parts = {1, 2}})\n"
#~ "\n"
#~ "box.space.tester:create_index('I8', {parts = {'x'}})\n"
#~ "box.space.tester:create_index('I9', {parts = {'x', 'y'}})\n"
#~ "\n"
#~ "box.space.tester:create_index('I10', {parts = {{'x'}}})\n"
#~ "box.space.tester:create_index('I11', {parts = {{'x'}, {'y'}}})"

#~ msgid ""
#~ "tarantool> my_space = box.schema.space.create('T')\n"
#~ "tarantool> format = {{'id', 'unsigned'}, {'data', 'map'}}\n"
#~ "tarantool> my_space:format(format)\n"
#~ "tarantool> parts = {{'data.FIO[\"firstname\"]', 'str'}, {'data.FIO[\"surname\"]', 'str'}}\n"
#~ "tarantool> my_index = my_space:create_index('info', {parts = parts})\n"
#~ "tarantool> my_space:insert({1, {FIO = {firstname = 'Ahmed', surname = 'Xi'}}})\n"
#~ "---\n"
#~ "- [1, {'FIO': {'surname': 'Xi', 'firstname': 'Ahmed'}}]"
#~ msgstr ""
#~ "tarantool> my_space = box.schema.space.create('T')\n"
#~ "tarantool> format = {{'id', 'unsigned'}, {'data', 'map'}}\n"
#~ "tarantool> my_space:format(format)\n"
#~ "tarantool> parts = {{'data.FIO[\"firstname\"]', 'str'}, {'data.FIO[\"surname\"]', 'str'}}\n"
#~ "tarantool> my_index = my_space:create_index('info', {parts = parts})\n"
#~ "tarantool> my_space:insert({1, {FIO = {firstname = 'Ahmed', surname = 'Xi'}}})\n"
#~ "---\n"
#~ "- [1, {'FIO': {'surname': 'Xi', 'firstname': 'Ahmed'}}]"

#~ msgid ""
#~ "**Note re storage engine:** vinyl supports only the TREE index type, and "
#~ "vinyl secondary indexes must be created before tuples are inserted."
#~ msgstr ""
#~ "**Примечание про движок базы данных:** vinyl поддерживает только TREE-"
#~ "индексы, и следует создать в vinyl'е вторичные индексы до вставки кортежей."
