
msgid "space_object:create_index()"
msgstr ""

msgid "On this page:"
msgstr "На этой странице:"

msgid ":ref:`create_index() description <box_space-create_index>`"
msgstr ""

msgid ":ref:`Details about index field types <details_about_index_field_types>`"
msgstr ""

msgid ":ref:`Allowing null for an indexed key <box_space-is_nullable>`"
msgstr ""

msgid ":ref:`Using field names instead of field numbers <box_space-field_names>`"
msgstr ""

msgid ""
":ref:`Using the path option for map fields (JSON-indexes) <box_space-"
"path>`"
msgstr ""

msgid ":ref:`Using the path option with [*] <box_space-path_multikey>`"
msgstr ""

msgid ""
":ref:`Making a functional index with space_object:create_index() "
"<box_space-index_func>`"
msgstr ""

msgid "Create an :ref:`index <index-box_index>`."
msgstr ""

#, fuzzy
msgid ""
"It is mandatory to create an index for a space before trying to insert "
"tuples into it, or select tuples from it. The first created index will be"
" used as the primary-key index, so it must be unique."
msgstr ""
"Создание :ref:`индекса <index-box_index>`. Индекс обязательно должен "
"создаваться для спейса до вставки в него кортежей или выборки. Первый "
"созданный индекс, который будет использоваться в качестве первичного "
"индекса, должен быть уникальным."

msgid "Parameters"
msgstr "Параметры"

msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ":ref:`ссылка на объект <app_server-object_reference>`"

msgid ""
"name of index, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя индекса, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

msgid "see \"Options for space_object:create_index()\", below"
msgstr "см. \"Параметры для space_object:create_index()\" ниже"

msgid "return"
msgstr "возвращает"

msgid "index object"
msgstr "объект индекса"

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "index_object"
msgstr "объект индекса"

msgid "**Possible errors:**"
msgstr "**Возможные ошибки:**"

msgid "too many parts;"
msgstr "слишком много частей;"

msgid "index '...' already exists;"
msgstr "индекс '...' уже существует;"

msgid "primary key must be unique."
msgstr "первичный ключ должен быть уникальным."

msgid ""
"Building or rebuilding a large index will cause occasional :ref:`yields "
"<atomic-cooperative_multitasking>` so that other requests will not be "
"blocked. If the other requests cause an illegal situation such as a "
"duplicate key in a unique index, building or rebuilding such index will "
"fail."
msgstr ""

msgid "**Options for space_object:create_index()**"
msgstr "**Параметры для space_object:create_index()**"

msgid "Name"
msgstr "Имя"

msgid "Effect"
msgstr "Эффект"

msgid "Type"
msgstr "Тип"

msgid "Default"
msgstr "Значение по умолчанию"

msgid "type"
msgstr "type"

msgid "type of index"
msgstr "тип индекса"

msgid ""
"string ('HASH' or 'TREE' or 'BITSET' or 'RTREE') Note re storage engine: "
"vinyl only supports 'TREE'"
msgstr ""
"строка ('HASH' или 'TREE', или 'BITSET', или 'RTREE') Примечание про "
"движок базы данных: vinyl поддерживает только 'TREE'"

msgid "'TREE'"
msgstr "'TREE'"

msgid "id"
msgstr "id"

msgid "unique identifier"
msgstr "уникальный идентификатор"

msgid "number"
msgstr "число"

msgid "last index's id, +1"
msgstr "идентификатор последнего индекса +1"

msgid "unique"
msgstr "unique"

msgid "index is unique"
msgstr "индекс уникален"

msgid "boolean"
msgstr "boolean (логический)"

msgid "``true``"
msgstr "``true`` (правда)"

msgid "if_not_exists"
msgstr "if_not_exists (если отсутствует)"

msgid "no error if duplicate name"
msgstr "ошибки нет, если имя дублируется"

msgid "``false``"
msgstr "``false`` (ложь)"

msgid "parts"
msgstr "parts"

msgid "field-numbers  + types"
msgstr "номера поля + типы"

msgid ""
"{field_no, ``'unsigned'`` or ``'string'`` or ``'integer'`` or "
"``'number'`` or ``'double'`` or ``'decimal'`` or ``'boolean'`` or "
"``'varbinary'`` or ``'uuid'`` or ``'array'`` or ``'scalar'``, and "
"optional collation or is_nullable value or path}"
msgstr ""

msgid "``{1, 'unsigned'}``"
msgstr "``{1, 'unsigned'}``"

msgid "dimension"
msgstr "dimension"

msgid "affects :ref:`RTREE <box_index-rtree>` only"
msgstr "только для :ref:`RTREE <box_index-rtree>`"

msgid "2"
msgstr "2"

msgid "distance"
msgstr "distance"

msgid "affects RTREE only"
msgstr "только для RTREE"

msgid "string ('euclid' or 'manhattan')"
msgstr "строка ('euclid' или 'manhattan')"

msgid "'euclid'"
msgstr "'euclid' (Евклидова)"

msgid "bloom_fpr"
msgstr "bloom_fpr"

msgid "affects vinyl only"
msgstr "только для vinyl"

msgid "``vinyl_bloom_fpr``"
msgstr "``vinyl_bloom_fpr``"

msgid "page_size"
msgstr "page_size"

msgid "``vinyl_page_size``"
msgstr "``vinyl_page_size``"

msgid "range_size"
msgstr "range_size"

msgid "``vinyl_range_size``"
msgstr "``vinyl_range_size``"

msgid "run_count_per_level"
msgstr "run_count_per_level"

msgid "``vinyl_run_count_per_level``"
msgstr "``vinyl_run_count_per_level``"

msgid "run_size_ratio"
msgstr "run_size_ratio"

msgid "``vinyl_run_size_ratio``"
msgstr "``vinyl_run_size_ratio``"

msgid "sequence"
msgstr "sequence"

msgid ""
"see section regarding :ref:`specifying a sequence in create_index() "
"<box_schema-sequence_create_index>`"
msgstr ""
"см. раздел об :ref:`указании последовательности для create_index() "
"<box_schema-sequence_create_index>`"

msgid "string or number"
msgstr "строка или число"

msgid "not present"
msgstr "отсутствует"

msgid "func"
msgstr ""

msgid ":ref:`functional index <box_space-index_func>`"
msgstr ""

#, fuzzy
msgid "string"
msgstr "**string**"

msgid "hint"
msgstr ""

msgid ""
"affects TREE only. ``true`` makes an index work faster, ``false`` -- an "
"index size is reduced by half"
msgstr ""

#, fuzzy
msgid ""
"The options in the above chart are also applicable for "
":doc:`/reference/reference_lua/box_index/alter`."
msgstr ""
"Параметры в вышеуказанной таблице также применимы к "
":ref:`index_object:alter() <box_index-alter>`."

#, fuzzy
msgid ""
"**Note re storage engine:** vinyl has extra options which by default are "
"based on configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-"
"vinyl_bloom_fpr>`, :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`,"
" and :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- "
"see the description of those parameters. The current values can be seen "
"by selecting from :doc:`/reference/reference_lua/box_space/_index`."
msgstr ""
"**Примечание про движок базы данных:** в vinyl'е есть дополнительные "
"параметры, которые по умолчанию основаны на конфигурационных параметрах "
":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`, "
":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>` "
"и :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- см. "
"описание этих параметров. Текущие значения можно увидеть, сделав выборку "
"из :ref:`box.space._index <box_space-index>`."

#, fuzzy
msgid "**Example:**"
msgstr "Примеры"

msgid ""
"tarantool> s=box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {\n"
"         > {field = 1, type = 'unsigned'},\n"
"         > {field = 2, type = 'string'}\n"
"         > }})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  - type: string\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  id: 0\n"
"  space_id: 512\n"
"  type: TREE\n"
"  name: primary\n"
"..."
msgstr ""

#, fuzzy
msgid "Details about index field types"
msgstr "**Подробнее о типах полей индекса:**"

#, fuzzy
msgid ""
"Index field types differ depending on what values are allowed, and what "
"index types are allowed."
msgstr ""
"Семь типов полей индекса (unsigned | string | integer | number | boolean "
"| array | scalar) отличаются друг от друга возможными значениями и типами"
" индексов, где можно использовать такие поля."

msgid "Index field type"
msgstr "Тип поля для индексирования"

#, fuzzy
msgid "What can be it it"
msgstr "Чем может быть"

#, fuzzy
msgid "Where it is legal"
msgstr "Где может использоваться"

msgid "Examples"
msgstr "Примеры"

#, fuzzy
msgid "``unsigned``"
msgstr "``{1, 'unsigned'}``"

#, fuzzy
msgid ""
"unsigned integers between 0 and 18446744073709551615, about 18 "
"quintillion. May also be called 'uint' or 'num', but 'num' is deprecated"
msgstr ""
"**unsigned**: беззнаковые целые числа от 0 до 18 446 744 073 709 551 615,"
" т.е. около18 квинтиллионов. Также может называться 'uint' или 'num', но "
"'num' объявлен устаревшим. Используется в индексах типа TREE или HASH в "
"memtx'е, и в TREE-индексах в vinyl'е."

#, fuzzy
msgid "memtx TREE or HASH indexes;"
msgstr "RTREE-индексы в memtx'е"

msgid "vinyl TREE indexes"
msgstr ""

#, fuzzy
msgid "123456"
msgstr "123456 |br|"

#, fuzzy
msgid "``string``"
msgstr "**string**"

#, fuzzy
msgid ""
"any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. May also be called 'str'. A string may"
" have a :ref:`collation <index-collation>`"
msgstr ""
"**string**: строка, то есть любая последовательность октетов до "
":ref:`максимальной длины <limitations_bytes_in_index_key>`. Также может "
"называться 'str'. Используется в индексах типа TREE, HASH или BITSET в "
"memtx'е и в TREE-индексах в vinyl'е. В строке может быть :ref:`сортировка"
" <index-collation>`."

msgid "memtx TREE or HASH or BITSET indexes;"
msgstr ""

msgid "'A B C'"
msgstr ""

#, fuzzy
msgid "'\\\\65 \\\\66 \\\\67'"
msgstr "'A B C' |br| '\\\\65 \\\\66 \\\\67'"

#, fuzzy
msgid "``varbinary``"
msgstr "**array**"

msgid ""
"any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. A varbinary byte sequence does not "
"have a :ref:`collation <index-collation>` because its contents are not "
"UTF-8 characters"
msgstr ""

#, fuzzy
msgid "``integer``"
msgstr "**integer**"

#, fuzzy
msgid ""
"integers between -9223372036854775808 and 18446744073709551615. May also "
"be called 'int'"
msgstr "целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615"

#, fuzzy
msgid "-2^63"
msgstr "-2^63 |br|"

#, fuzzy
msgid "``number``"
msgstr "число"

#, fuzzy
msgid ""
"integers between -9223372036854775808 and 18446744073709551615, single-"
"precision floating point numbers, or double-precision floating point "
"numbers, or exact numbers"
msgstr ""
"целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615, "
"числа с плавающей запятой с одинарной точностью или с двойной точностью"

msgid "1.234"
msgstr ""

msgid "-44"
msgstr ""

msgid "1.447e+44"
msgstr ""

#, fuzzy
msgid "``double``"
msgstr "``true`` (правда)"

msgid "double-precision floating point numbers"
msgstr ""

#, fuzzy
msgid "``boolean``"
msgstr "boolean (логический)"

msgid "true or false"
msgstr "true или false"

#, fuzzy
msgid "false"
msgstr "``false`` (ложь)"

#, fuzzy
msgid "``decimal``"
msgstr "**scalar**"

msgid ""
"exact number returned from a function in the :ref:`decimal <decimal>` "
"module"
msgstr ""

msgid "decimal.new(1.2)"
msgstr ""

#, fuzzy
msgid "``uuid``"
msgstr "``true`` (правда)"

msgid ""
"a 128-bit quantity sequence of lower-case hexadecimal digits, "
"representing Universally Unique Identifiers (UUID)"
msgstr ""

msgid "uuid.fromstr('64d22e4d-ac92-4a23-899a-e59f34af5479')"
msgstr ""

msgid "``array``"
msgstr ""

#, fuzzy
msgid "array of numbers"
msgstr "строка или число"

#, fuzzy
msgid "memtx :ref:`RTREE <box_index-rtree>` indexes"
msgstr "только для :ref:`RTREE <box_index-rtree>`"

msgid "{10, 11}"
msgstr ""

#, fuzzy
msgid "{3, 5, 9, 10}"
msgstr "{10, 11} |br| {3, 5, 9, 10}"

#, fuzzy
msgid "``scalar``"
msgstr "``false`` (ложь)"

#, fuzzy
msgid ""
"null (input with ``msgpack.NULL`` or ``yaml.NULL`` or ``json.NULL``), "
"booleans (true or false), or integers between -9223372036854775808 and "
"18446744073709551615, or single-precision floating point numbers, or "
"double-precision floating-point numbers, or exact numbers, or strings, or"
" (varbinary) byte arrays. When there is a mix of types, the key order is:"
" null, then booleans, then numbers, then strings, then byte arrays"
msgstr ""
"**scalar**: логические значения (true или false), целые числа от integers"
" between -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615, числа "
"с плавающей запятой с одинарной точностью или с двойной точностью или "
"строки. При использовании нескольких типов, порядок ключей должен быть "
"следующим: логические значения, затем числа, затем строки. Используется в"
" индексах типа TREE или HASH в memtx'е и в TREE-индексах в vinyl'е."

msgid "null"
msgstr ""

#, fuzzy
msgid "true"
msgstr "``true`` (правда)"

msgid "-1"
msgstr ""

msgid "''"
msgstr ""

msgid "'ру'"
msgstr ""

#, fuzzy
msgid "``nil``"
msgstr "``false`` (ложь)"

#, fuzzy
msgid ""
"Additionally, `nil` is allowed with any index field type if "
":ref:`is_nullable=true <box_space-is_nullable>` is specified"
msgstr ""
"Кроме того, допускается нулевое значение `nil` для любого типа поля, если"
" указана такая возможность :ref:`is_nullable=true <box_space-"
"is_nullable>`."

msgid "Allowing null for an indexed key"
msgstr ""

#, fuzzy
msgid ""
"If the index type is TREE, and the index is not the primary index, then "
"the ``parts={...}`` clause may include ``is_nullable=true`` or "
"``is_nullable=false`` (the default). If ``is_nullable`` is true, then it "
"is legal to insert ``nil`` or an equivalent such as ``msgpack.NULL``. It "
"is also legal to insert nothing at all when using trailing nullable "
"fields. Within indexes, such \"null values\" are always treated as equal "
"to other null values, and are always treated as less than non-null "
"values. Nulls may appear multiple times even in a unique index. Example:"
msgstr ""
"**Разрешение использования нулевых значений для индексируемого ключа:** "
"/Если тип индекса -- TREE, и индекс не является первичным, то оператор "
"``parts={...}`` может включать в себя ``is_nullable=true`` или "
"``is_nullable=false`` (по умолчанию). Если значение параметра "
"``is_nullable`` -- true, то можно вставлять ``nil`` или аналогичное "
"значение, например ``msgpack.NULL`` (или можно не вставлять вообще ничего"
" в завершающие ненулевые поля). В рамках индекса такие нулевые значения "
"считаются равными другим нулевым значениям и всегда меньше ненулевых "
"значений. Нулевые значения могут встречаться несколько раз даже в "
"уникальном индексе. Например:"

#, fuzzy
msgid ""
"box.space.tester:create_index('I',{unique=true,parts={{field = 2, type = "
"'number', is_nullable = true}}})"
msgstr "box.space.tester:create_index('I',{unique=true,parts={{2,'number',is_nullable=true}}})"

#, fuzzy
msgid ""
"It is legal to create multiple indexes for the same field with different "
"``is_nullable`` values, or to call "
":doc:`/reference/reference_lua/box_space/format` with a different "
"``is_nullable`` value from what is used for an index. When there is a "
"contradiction, the rule is: null is illegal unless ``is_nullable=true`` "
"for every index and for the space format."
msgstr ""
"Можно создать множество индексов для одного и того же поля с различными "
"значениями ``is_nullable`` или вызвать :ref:`space_object:format() "
"<box_space-format>` со значением ``is_nullable``, отличным от "
"используемого для индекса. При наличии несоответствий правило такое: "
"запрещается использовать null кроме случаев, когда ``is_nullable=true`` "
"для всех индексов и формата спейса."

msgid "Using field names instead of field numbers"
msgstr ""

#, fuzzy
msgid ""
"``create_index()`` can use field names and/or field types described by "
"the optional :doc:`/reference/reference_lua/box_space/format` clause. In "
"the following example, we show ``format()`` for a space that has two "
"columns named 'x' and 'y', and then we show five variations of the "
"``parts={}`` clause of ``create_index()``, first for the 'x' column, "
"second for both the 'x' and 'y' columns. The variations include omitting "
"the type, using numbers, and adding extra braces."
msgstr ""
"**Использование имен полей вместо номеров полей:** в ``create_index()`` "
"можно использовать имена полей и/или типы полей, описанные в "
"необязательном операторе :ref:`space_object:format() <box_space-format>`."
" В следующем примере покажем ``format()`` для спейса с двумя столбцами "
"под названиями 'x' и 'y', а затем покажем пять вариантов оператора "
"``parts={}`` в ``create_index()``, сначала для столбца 'x', затем для "
"столбцов 'x' и 'y'. Варианты включают в себя пропуск типа, использование "
"номеров и добавление дополнительных фигурных скобок."

#, fuzzy
msgid ""
"box.space.tester:format({{name='x', type='scalar'}, {name='y', "
"type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x', 'scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})"
"\n"
"box.space.tester:create_index('I4',{parts={{1,'scalar'}}})\n"
"box.space.tester:create_index('I5',{parts={{1,'scalar'},{2,'integer'}}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"
msgstr ""
"box.space.tester:format({{name='x', type='scalar'}, {name='y', "
"type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x','scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})"
"\n"
"box.space.tester:create_index('I4',{parts={1,'scalar'}})\n"
"box.space.tester:create_index('I5',{parts={1,'scalar',2,'integer'}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"

msgid "Using the path option for map fields (JSON-indexes)"
msgstr ""

msgid ""
"To create an index for a field that is a map (a path string and a scalar "
"value), specify the path string during index_create, that is, "
":code:`parts={` :samp:`{field-number},'{data-type}',path = '{path-name}'`"
" :code:`}`. The index type must be ``'tree'`` or ``'hash'`` and the "
"field's contents must always be maps with the same path."
msgstr ""

msgid "**Example 1 -- The simplest use of path:**"
msgstr ""

msgid ""
"-- Result will be - - [{'age': 44}]\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('I',{parts={{field = 1, type = 'scalar', path = "
"'age'}}})\n"
"box.space.T:insert{{age=44}}\n"
"box.space.T:select(44)"
msgstr ""

msgid "**Example 2 -- path plus format() plus JSON syntax to add clarity:**"
msgstr ""

msgid ""
"-- Result will be: - [1, {'FIO': {'surname': 'Xi', 'firstname': "
"'Ahmed'}}]\n"
"s = box.schema.space.create('T')\n"
"format = {{'id', 'unsigned'}, {'data', 'map'}}\n"
"s:format(format)\n"
"parts = {{'data.FIO[\"firstname\"]', 'str'}, {'data.FIO[\"surname\"]', "
"'str'}}\n"
"i = s:create_index('info', {parts = parts})\n"
"s:insert({1, {FIO={firstname='Ahmed', surname='Xi'}}})"
msgstr ""

msgid ""
"**Note re storage engine:** vinyl supports only the TREE index type, and "
"vinyl secondary indexes must be created before tuples are inserted."
msgstr ""
"**Примечание про движок базы данных:** vinyl поддерживает только "
"TREE-индексы, и следует создать в vinyl'е вторичные индексы до вставки "
"кортежей."

msgid "Using the path option with [*]"
msgstr ""

msgid ""
"The string in a path option can contain '[*]' which is called an array "
"index placeholder. Indexes defined with this are useful for JSON "
"documents that all have the same structure."
msgstr ""

msgid ""
"For example, when creating an index on field#2 for a string document that"
" will start with ``{'data': [{'name': '...'}, {'name': '...'}]``, the "
"parts section in the create_index request could look like: ``parts = "
"{{field = 2, type = 'str', path = 'data[*].name'}}``. Then tuples "
"containing names can be retrieved quickly with ``index_object:select"
"({key-value})``."
msgstr ""

msgid ""
"In fact a single field can have multiple keys, as in this example which "
"retrieves the same tuple twice because there are two keys 'A' and 'B' "
"which both match the request:"
msgstr ""

msgid ""
"s = box.schema.space.create('json_documents')\n"
"s:create_index('primarykey')\n"
"i = s:create_index('multikey', {parts = {{field = 2, type = 'str', path ="
" 'data[*].name'}}})\n"
"s:insert({1,\n"
"         {data = {{name='A'},\n"
"                  {name='B'}},\n"
"          extra_field = 1}})\n"
"i:select({''},{iterator='GE'})"
msgstr ""

msgid "The result of the select request looks like this:"
msgstr ""

msgid ""
"tarantool> i:select({''},{iterator='GE'})\n"
"---\n"
"- - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"- [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"..."
msgstr ""

msgid "Some restrictions exist:"
msgstr ""

msgid "'[*]' must be alone or must be at the end of a name in the path"
msgstr ""

msgid "'[*]' must not appear twice in the path"
msgstr ""

msgid ""
"if an index has a path with x[*] then no other index can have a path with"
" x.component"
msgstr ""

msgid "'[*]' must not appear in the path of a primary-key"
msgstr ""

msgid ""
"if an index has ``unique=true`` and has a path with '[*]' then duplicate "
"keys from different tuples are disallowed but duplicate keys for the same"
" tuple are allowed"
msgstr ""

msgid ""
"as with :ref:`Using the path option for map fields <box_space-path>`, the"
" field's value must have the structure that the path definition implies, "
"or be nil (nil is not indexed)"
msgstr ""

#, fuzzy
msgid "Making a functional index with space_object:create_index()"
msgstr "**Параметры для space_object:create_index()**"

msgid ""
"Functional indexes are indexes that call a user-defined function for "
"forming the index key, rather than depending entirely on the Tarantool "
"default formation. Functional indexes are useful for condensing or "
"truncating or reversing or any other way that users want to customize the"
" index."
msgstr ""

msgid ""
"The function definition must expect a tuple (which has the contents of "
"fields at the time a data-change request happens) and must return a tuple"
" (which has the contents that will actually be put in the index)."
msgstr ""

msgid "The space must have a memtx engine."
msgstr ""

msgid ""
"The function must be :ref:`persistent <box_schema-func_create_with-body>`"
" and deterministic."
msgstr ""

msgid "The key parts must not depend on JSON paths."
msgstr ""

msgid ""
"The ``create_index`` definition must include specification of all key "
"parts, and the function must return a table which has the same number of "
"key parts with the same types."
msgstr ""

msgid "The function must access key-part values by index, not by field name."
msgstr ""

msgid "Functional indexes must not be primary-key indexes."
msgstr ""

msgid ""
"Functional indexes cannot be altered and the function cannot be changed "
"if it is used for an index, so the only way to change them is to drop the"
" index and create it again."
msgstr ""

msgid "Only sandboxed functions are suitable for functional indexes."
msgstr ""

msgid "A function could make a key using only the first letter of a string field."
msgstr ""

msgid ""
"Make a space. The space needs a primary-key field, which is not the field"
" that we will use for the functional index:"
msgstr ""

msgid ""
"box.schema.space.create('x', {engine = 'memtx'})\n"
"box.space.x:create_index('i',{parts={{field = 1, type = 'string'}}})"
msgstr ""

msgid ""
"Make a function. The function expects a tuple. In this example it will "
"work on tuple[2] because the key source is field number 2 in what we will"
" insert. Use ``string.sub()`` from the ``string`` module to get the first"
" character:"
msgstr ""

msgid "lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]"
msgstr ""

msgid ""
"Make the function persistent using the ``box.schema.func.create`` "
"function:"
msgstr ""

msgid ""
"box.schema.func.create('F',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})"
msgstr ""

msgid ""
"Make a functional index. Specify the fields whose values will be passed "
"to the function. Specify the function:"
msgstr ""

#, fuzzy
msgid ""
"box.space.x:create_index('j',{parts={{field = 1, type = 'string'}},func ="
" 'F'})"
msgstr "box.space.tester:create_index('I',{unique=true,parts={{2,'number',is_nullable=true}}})"

msgid ""
"Test. Insert a few tuples. Select using only the first letter, it will "
"work because that is the key. Or, select using the same function as was "
"used for insertion:"
msgstr ""

msgid ""
"box.space.x:insert{'a', 'wombat'}\n"
"box.space.x:insert{'b', 'rabbit'}\n"
"box.space.x.index.j:select('w')\n"
"box.space.x.index.j:select(box.func.F:call({{'x', 'wombat'}}));"
msgstr ""

msgid "The results of the two ``select`` requests will look like this:"
msgstr ""

msgid ""
"tarantool> box.space.x.index.j:select('w')\n"
"---\n"
"- - ['a', 'wombat']\n"
"...\n"
"tarantool> box.space.x.index.j:select(box.func.F:call({{'x','wombat'}}));"
"\n"
"---\n"
"- - ['a', 'wombat']\n"
"..."
msgstr ""

msgid "Here is the full code of the example:"
msgstr ""

msgid ""
"box.schema.space.create('x', {engine = 'memtx'})\n"
"box.space.x:create_index('i',{parts={{field = 1, type = 'string'}}})\n"
"lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]\n"
"box.schema.func.create('F',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})\n"
"box.space.x:create_index('j',{parts={{field = 1, type = 'string'}},func ="
" 'F'})\n"
"box.space.x:insert{'a', 'wombat'}\n"
"box.space.x:insert{'b', 'rabbit'}\n"
"box.space.x.index.j:select('w')\n"
"box.space.x.index.j:select(box.func.F:call({{'x', 'wombat'}}));"
msgstr ""

msgid ""
"Functions for functional indexes can return **multiple keys**. Such "
"functions are called \"multikey\" functions."
msgstr ""

msgid ""
"The ``box.func.create`` options must include ``opts = {is_multikey = "
"true}``. The return value must be a table of tuples. If a multikey "
"function returns N tuples, then N keys will be added to the index."
msgstr ""

msgid ""
"s = box.schema.space.create('withdata')\n"
"s:format({{name = 'name', type = 'string'},\n"
"          {name = 'address', type = 'string'}})\n"
"pk = s:create_index('name', {parts = {{field = 1, type = 'string'}}})\n"
"lua_code = [[function(tuple)\n"
"               local address = string.split(tuple[2])\n"
"               local ret = {}\n"
"               for _, v in pairs(address) do\n"
"                 table.insert(ret, {utf8.upper(v)})\n"
"               end\n"
"               return ret\n"
"             end]]\n"
"box.schema.func.create('address',\n"
"                        {body = lua_code,\n"
"                         is_deterministic = true,\n"
"                         is_sandboxed = true,\n"
"                         opts = {is_multikey = true}})\n"
"idx = s:create_index('addr', {unique = false,\n"
"                              func = 'address',\n"
"                              parts = {{field = 1, type = 'string',\n"
"                                      collation = 'unicode_ci'}}})\n"
"s:insert({\"James\", \"SIS Building Lambeth London UK\"})\n"
"s:insert({\"Sherlock\", \"221B Baker St Marylebone London NW1 6XE UK\"})\n"
"idx:select('Uk')\n"
"-- Both tuples will be returned."
msgstr ""

#~ msgid ""
#~ ":ref:`Index field types to use in "
#~ "space_object:create_index() <box_space-index_field_types>`"
#~ msgstr ""

#~ msgid ""
#~ "Building or rebuilding a large index "
#~ "will cause occasional :ref:`yields <atomic-"
#~ "cooperative_multitasking>` so that other "
#~ "requests will not be blocked. If "
#~ "the other requests cause an illegal "
#~ "situation such as a duplicate key "
#~ "in a unique index, the index "
#~ "building or rebuilding will fail."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> s = box.space.tester\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:create_index('primary', {unique = "
#~ "true, parts = { {field = 1, "
#~ "type = 'unsigned'}, {field = 2, "
#~ "type = 'string'}} })\n"
#~ "---\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> s = box.space.tester\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:create_index('primary', {unique = "
#~ "true, parts = { {field = 1, "
#~ "type = 'unsigned'}, {field = 2, "
#~ "type = 'string'}} })\n"
#~ "---\n"
#~ "..."

#~ msgid ""
#~ "**integer**: integers between -9223372036854775808"
#~ " and 18446744073709551615. May also be "
#~ "called 'int'. Legal in memtx TREE "
#~ "or HASH indexes, and in vinyl TREE"
#~ " indexes."
#~ msgstr ""
#~ "**integer**: целые числа от -9 223 "
#~ "372 036 854 775 808 до 18 "
#~ "446 744 073 709 551 615. Также "
#~ "может называться 'int'. Используется в "
#~ "индексах типа TREE или HASH в "
#~ "memtx'е и в TREE-индексах в vinyl'е."

#~ msgid ""
#~ "**number**: integers between -9223372036854775808"
#~ " and 18446744073709551615, single-precision "
#~ "floating point numbers, or double-"
#~ "precision floating point numbers, or "
#~ "exact numbers. Legal in memtx TREE "
#~ "or HASH indexes, and in vinyl TREE"
#~ " indexes."
#~ msgstr ""
#~ "**number**: целые числа от -9 223 "
#~ "372 036 854 775 808 до 18 "
#~ "446 744 073 709 551 615, числа "
#~ "с плавающей запятой с одинарной "
#~ "точностью или с двойной точностью. "
#~ "Используется в индексах типа TREE или"
#~ " HASH в memtx'е и в TREE-индексах "
#~ "в vinyl'е."

#~ msgid ""
#~ "**double**: double-precision floating point"
#~ " numbers. Legal in memtx TREE or "
#~ "HASH indexes, and in vinyl TREE "
#~ "indexes."
#~ msgstr ""
#~ "**boolean**: логическое значение, true "
#~ "(правда) или false (ложь). Используется "
#~ "в индексах типа TREE или HASH в"
#~ " memtx'е и в TREE-индексах в vinyl'е."

#~ msgid ""
#~ "**boolean**: true or false. Legal in "
#~ "memtx TREE or HASH indexes, and in"
#~ " vinyl TREE indexes."
#~ msgstr ""
#~ "**boolean**: логическое значение, true "
#~ "(правда) или false (ложь). Используется "
#~ "в индексах типа TREE или HASH в"
#~ " memtx'е и в TREE-индексах в vinyl'е."

#~ msgid ""
#~ "**decimal**: exact number returned from "
#~ "a function in the :ref:`decimal "
#~ "<decimal>` module. Legal in memtx TREE"
#~ " or HASH indexes, and in vinyl "
#~ "TREE indexes."
#~ msgstr ""

#~ msgid ""
#~ "**uuid**: stores a 128-bit quantity "
#~ "sequence of lower-case hexadecimal "
#~ "digits, representing Universally Unique "
#~ "Identifiers (UUID). Legal in memtx TREE"
#~ " or HASH indexes, and in vinyl "
#~ "TREE indexes."
#~ msgstr ""

#~ msgid ""
#~ "**varbinary**: any set of octets, up "
#~ "to the :ref:`maximum length "
#~ "<limitations_bytes_in_index_key>`. Legal in memtx"
#~ " TREE or HASH indexes, and in "
#~ "vinyl TREE indexes. A varbinary byte "
#~ "sequence does not have a :ref:`collation"
#~ " <index-collation>` because its contents"
#~ " are not UTF-8 characters."
#~ msgstr ""

#~ msgid ""
#~ "**array**: array of numbers. Legal in"
#~ " memtx :ref:`RTREE <box_index-rtree>` "
#~ "indexes."
#~ msgstr ""
#~ "**array**: массив чисел. Используется в "
#~ ":ref:`RTREE-индексах <box_index-rtree>` в "
#~ "memtx'е."

#~ msgid "**Index field types to use in space_object:create_index()**"
#~ msgstr ""
#~ "**Типы полей в индексах для "
#~ "использования в space_object:create_index()**"

#~ msgid "**unsigned**"
#~ msgstr "**unsigned**"

#~ msgid "integers between 0 and 18446744073709551615"
#~ msgstr "целые числа от 0 до 18 446 744 073 709 551 615"

#~ msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
#~ msgstr "индексы типа TREE или HASH в memtx'е, |br| TREE-индексы в vinyl'е"

#~ msgid "**string**"
#~ msgstr "**string**"

#~ msgid "strings -- any set of octets"
#~ msgstr "строки -- любой набор октетов"

#~ msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
#~ msgstr "индексы типа TREE или HASH в memtx'е |br| TREE-индексы в vinyl'е"

#~ msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
#~ msgstr "'A B C' |br| '\\\\65 \\\\66 \\\\67'"

#~ msgid "byte sequences -- any set of octets"
#~ msgstr "строки -- любой набор октетов"

#~ msgid "**number**"
#~ msgstr "**number**"

#~ msgid "1.234 |br| -44 |br| 1.447e+44"
#~ msgstr "1.234 |br| -44 |br| 1.447e+44"

#~ msgid "**double**"
#~ msgstr "**number**"

#~ msgid "**boolean**"
#~ msgstr "**boolean**"

#~ msgid "false |br| true"
#~ msgstr "false |br| true"

#~ msgid ""
#~ "exact numbers returned by a function "
#~ "in the :ref:`decimal <decimal>` module"
#~ msgstr ""

#~ msgid "decimal.new(1.2) |br|"
#~ msgstr ""

#~ msgid "**uuid**"
#~ msgstr "**unsigned**"

#~ msgid "values returned by :ref:`uuid.new() <uuid-new>`"
#~ msgstr ""

#~ msgid "uuid.fromstr('|br| 64d22e4d-ac92-4a |br| 23-899a-e59f34af5479')"
#~ msgstr ""

#~ msgid "**array**"
#~ msgstr "**array**"

#~ msgid "array of integers between -9223372036854775808 and 9223372036854775807"
#~ msgstr ""
#~ "массив целых чисел от -9 223 372"
#~ " 036 854 775 808 до 9 223 "
#~ "372 036 854 775 807"

#~ msgid "**scalar**"
#~ msgstr "**scalar**"

#~ msgid ""
#~ "null, booleans (true or false), integers"
#~ " between -9223372036854775808 and "
#~ "18446744073709551615, single-precision floating "
#~ "point numbers, double-precision floating "
#~ "point numbers, strings"
#~ msgstr ""
#~ "логические значения (true или false), "
#~ "целые числа от -9 223 372 036 "
#~ "854 775 808 до 18 446 744 "
#~ "073 709 551 615, числа с плавающей"
#~ " запятой с одинарной точностью или с"
#~ " двойной точностью, строки"

#~ msgid "null |br| true |br| -1 |br| 1.234 |br| '' |br| 'ру'"
#~ msgstr "true |br| -1 |br| 1.234 |br| '' |br| 'ру'"

#~ msgid ""
#~ "**Using the path option for map "
#~ "fields (JSON-indexes):** To create an"
#~ " index for a field that is a"
#~ " map (a path string and a "
#~ "scalar value), specify the path string"
#~ " during index_create, that is, "
#~ ":code:`parts={` :samp:`{field-number},'{data-"
#~ "type}',path = '{path-name}'` :code:`}`. "
#~ "The index type must be ``'tree'`` "
#~ "or ``'hash'`` and the field's contents"
#~ " must always be maps with the "
#~ "same path."
#~ msgstr ""

#~ msgid ""
#~ "-- Example 1 -- The simplest use of path:\n"
#~ "-- Result will be - - [{'age': 44}]\n"
#~ "box.schema.space.create('T')\n"
#~ "box.space.T:create_index('I',{parts={{field = 1, "
#~ "type = 'scalar', path = 'age'}}})\n"
#~ ""
#~ "box.space.T:insert{{age=44}}\n"
#~ "box.space.T:select(44)\n"
#~ "-- Example 2 -- path plus format() plus JSON syntax to add clarity\n"
#~ "-- Result will be: - [1, {'FIO':"
#~ " {'surname': 'Xi', 'firstname': 'Ahmed'}}]\n"
#~ ""
#~ "s = box.schema.space.create('T')\n"
#~ "format = {{'id', 'unsigned'}, {'data', 'map'}}\n"
#~ "s:format(format)\n"
#~ "parts = {{'data.FIO[\"firstname\"]', 'str'}, "
#~ "{'data.FIO[\"surname\"]', 'str'}}\n"
#~ "i = s:create_index('info', {parts = parts})\n"
#~ "s:insert({1, {FIO={firstname='Ahmed', surname='Xi'}}})"
#~ msgstr ""

#~ msgid ""
#~ "**Using the path option with [*]**  "
#~ "The string in a path option can"
#~ " contain '[*]' which is called an "
#~ "array index placeholder. Indexes defined "
#~ "with this are useful for JSON "
#~ "documents that all have the same "
#~ "structure. For example, when creating an"
#~ " index on field#2 for a string "
#~ "document that will start with ``{'data':"
#~ " [{'name': '...'}, {'name': '...'}]``, the"
#~ " parts section in the create_index "
#~ "request could look like: ``parts = "
#~ "{{field = 2, type = 'str', path"
#~ " = 'data[*].name'}}``. Then tuples "
#~ "containing names can be retrieved "
#~ "quickly with ``index_object:select({key-value})``."
#~ " In fact a single field can "
#~ "have multiple keys, as in this "
#~ "example which retrieves the same tuple"
#~ " twice because there are two keys "
#~ "'A' and 'B' which both match the"
#~ " request:"
#~ msgstr ""

#~ msgid ""
#~ "Some restrictions exist: () '[*]' must"
#~ " be alone or must be at the "
#~ "end of a name in the path; "
#~ "() '[*]' must not appear twice in"
#~ " the path; () if an index has"
#~ " a path with x[*] then no other"
#~ " index can have a path with "
#~ "x.component; () '[*]' must not appear"
#~ " in the path of a primary-key"
#~ " ; () if an index has "
#~ "``unique=true`` and has a path with "
#~ "'[*]' then duplicate keys from different"
#~ " tuples are disallowed but duplicate "
#~ "keys for the same tuple are "
#~ "allowed; () As with :ref:`Using the "
#~ "path option for map fields "
#~ "<box_space-path>`, the field's value must"
#~ " have the structure that the path "
#~ "definition implies, or be nil (nil "
#~ "is not indexed)."
#~ msgstr ""

#~ msgid ""
#~ "The space must have a memtx "
#~ "engine. |br| The function must be "
#~ ":ref:`persistent <box_schema-func_create_with-body>`"
#~ " and deterministic. |br| The key "
#~ "parts must not depend on JSON "
#~ "paths. |br| The ``create_index`` definition"
#~ " must include specification of all "
#~ "key parts, and the function must "
#~ "return a table which has the same"
#~ " number of key parts with the "
#~ "same types. |br| The function must "
#~ "access key-part values by index, "
#~ "not by field name. |br| Functional "
#~ "indexes must not be primary-key "
#~ "indexes. |br| Functional indexes cannot "
#~ "be altered and the function cannot "
#~ "be changed if it is used for "
#~ "an index, so the only way to "
#~ "change them is to drop the index"
#~ " and create it again. |br| Only "
#~ "sandboxed functions are suitable for "
#~ "functional indexes."
#~ msgstr ""

#~ msgid ""
#~ "-- Step 1: Make the space.\n"
#~ "-- The space needs a primary-key"
#~ " field, which is not the field "
#~ "that we\n"
#~ "-- will use for the functional index.\n"
#~ "box.schema.space.create('x', {engine = 'memtx'})\n"
#~ "box.space.x:create_index('i',{parts={{field = 1, type = 'string'}}})\n"
#~ "-- Step 2: Make the function.\n"
#~ "-- The function expects a tuple. "
#~ "In this example it will work on"
#~ " tuple[2]\n"
#~ "-- because the key source is field number 2 in what we will insert.\n"
#~ "-- Use string.sub() from the string "
#~ "module to get the first character.\n"
#~ ""
#~ "lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]\n"
#~ "-- Step 3: Make the function persistent.\n"
#~ "-- Use the box.schema.func.create function for this.\n"
#~ "box.schema.func.create('F',\n"
#~ "    {body = lua_code, is_deterministic = true, is_sandboxed = true})\n"
#~ "-- Step 4: Make the functional index.\n"
#~ "-- Specify the fields whose values will be passed to the function.\n"
#~ "-- Specify the function.\n"
#~ "box.space.x:create_index('j',{parts={{field = 1, "
#~ "type = 'string'}},func = 'F'})\n"
#~ "-- Step 5: Test.\n"
#~ "-- Insert a few tuples.\n"
#~ "-- Select using only the first "
#~ "letter, it will work because that "
#~ "is the key\n"
#~ "-- Or, select using the same function as was used for insertion\n"
#~ "box.space.x:insert{'a', 'wombat'}\n"
#~ "box.space.x:insert{'b', 'rabbit'}\n"
#~ "box.space.x.index.j:select('w')\n"
#~ "box.space.x.index.j:select(box.func.F:call({{'x', 'wombat'}}));"
#~ msgstr ""

#~ msgid ""
#~ "Functions for functional indexes can "
#~ "return multiple keys. |br| Such "
#~ "functions are called \"multikey\" functions."
#~ " |br| The ``box.func.create`` options must"
#~ " include ``opts = {is_multikey = "
#~ "true}``. |br| The return value must "
#~ "be a table of tuples. |br| If "
#~ "a multikey function returns N tuples,"
#~ " then N keys will be added to"
#~ " the index."
#~ msgstr ""
