
msgid "space_object:create_index()"
msgstr "space_object:create_index()"

msgid "On this page:"
msgstr "На этой странице:"

msgid ":ref:`create_index() description <box_space-create_index>`"
msgstr ":ref:`Описание create_index() <box_space-create_index>`"

msgid ""
":ref:`Details about index field types <details_about_index_field_types>`"
msgstr ""
":ref:`Описание типов индексируемых полей <details_about_index_field_types>`"

msgid ":ref:`Allowing null for an indexed key <box_space-is_nullable>`"
msgstr ""
":ref:`Использование null для индексируемого ключа <box_space-is_nullable>`"

msgid ""
":ref:`Creating an index using field names instead of field numbers "
"<box_space-field_names>`"
msgstr ""
":ref:`Создание индекса с использованием имен полей вместо номеров полей "
"<box_space-field_names>`"

msgid ""
":ref:`Creating an index using the path option for map fields (JSON-path "
"indexes) <box_space-path>`"
msgstr ""
":ref:`Создание индекса с использованием пути для полей с ассоциативными "
"массивами (индексы по пути JSON) <box_space-path>`"

msgid ""
":ref:`Creating an multikey index using the path option with [*] <box_space-"
"path_multikey>`"
msgstr ""
":ref:`Создание индекса по массивам (multikey) с использованием опции path с "
"символом [*] <box_space-path_multikey>`"

msgid ":ref:`Creating a functional index <box_space-index_func>`"
msgstr ":ref:`Создание функционального индекса <box_space-index_func>`"

msgid "Create an :ref:`index <index-box_index>`."
msgstr "Создание :ref:`индекса <index-box_index>`."

msgid ""
"It is mandatory to create an index for a space before trying to insert "
"tuples into it or select tuples from it. The first created index will be "
"used as the primary-key index, so it must be unique."
msgstr ""
"Обязательным условием является создание индекса для спейса до вставки в "
"спейс кортежей или выборки кортежей из него. Первый созданный индекс, "
"который будет использоваться в качестве первичного индекса, должен быть "
"уникальным."

msgid "Parameters"
msgstr "Параметры"

msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ":ref:`ссылка на объект <app_server-object_reference>`"

msgid ""
"name of index, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя индекса, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

msgid "see \"Options for space_object:create_index()\", below"
msgstr "см. \"Параметры для space_object:create_index()\" ниже"

msgid "return"
msgstr "возвращает"

msgid "index object"
msgstr "объект индекса"

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "index_object"
msgstr "index_object"

msgid "**Possible errors:**"
msgstr "**Возможные ошибки:**"

msgid "too many parts;"
msgstr "слишком много частей;"

msgid "index '...' already exists;"
msgstr "индекс '...' уже существует;"

msgid "primary key must be unique."
msgstr "первичный ключ должен быть уникальным."

msgid ""
"Building or rebuilding a large index will cause occasional :ref:`yields "
"<atomic-cooperative_multitasking>` so that other requests will not be "
"blocked. If the other requests cause an illegal situation such as a "
"duplicate key in a unique index, building or rebuilding such index will "
"fail."
msgstr ""
"Сборка или пересборка большого индекса будет периодически вызывать "
":ref:`передачу управления <atomic-cooperative_multitasking>`, чтобы не "
"блокировать другие запросы. А если другой запрос приведет к ошибке, например"
" повторяющийся ключ в уникальном индексе, сборка или пересборка такого "
"индекса не выполнится."

msgid "**Options for space_object:create_index()**"
msgstr "**Параметры для space_object:create_index()**"

msgid "Name"
msgstr "Имя"

msgid "Effect"
msgstr "Описание"

msgid "Type"
msgstr "Тип"

msgid "Default"
msgstr "Значение по умолчанию"

msgid "type"
msgstr "type"

msgid "type of index"
msgstr "тип индекса"

msgid ""
"string ('HASH' or 'TREE' or 'BITSET' or 'RTREE') Note re storage engine: "
"vinyl only supports 'TREE'"
msgstr ""
"string ('HASH', или 'TREE', или 'BITSET', или 'RTREE') Примечание про движок"
" базы данных: vinyl поддерживает только 'TREE'"

msgid "'TREE'"
msgstr "'TREE'"

msgid "id"
msgstr "id"

msgid "unique identifier"
msgstr "уникальный идентификатор"

msgid "number"
msgstr "number"

msgid "last index's id, +1"
msgstr "идентификатор последнего индекса +1"

msgid "unique"
msgstr "unique"

msgid "index is unique"
msgstr "индекс уникален"

msgid "boolean"
msgstr "boolean"

msgid "``true``"
msgstr "``true``"

msgid "if_not_exists"
msgstr "if_not_exists"

msgid "no error if duplicate name"
msgstr "ошибки нет, если имя дублируется"

msgid "``false``"
msgstr "``false``"

msgid "parts"
msgstr "parts"

msgid "field-numbers  + types"
msgstr "номера поля + типы"

msgid ""
"{field_no, ``'unsigned'`` or ``'string'`` or ``'integer'`` or ``'number'`` "
"or ``'double'`` or ``'decimal'`` or ``'boolean'`` or ``'varbinary'`` or "
"``'uuid'`` or ``'array'`` or ``'scalar'``, and optional collation or "
"is_nullable value or path}"
msgstr ""
"{field_no, ``'unsigned'``, или ``'string'``, или ``'integer'``, или "
"``'number'``, или ``'double'``, или ``'decimal'``, или ``'boolean'``, или "
"``'varbinary'``, или ``'uuid'``, или ``'array'``, или ``'scalar'``, и "
"дополнительная сортировка, или значение is_nullable, или путь}"

msgid "``{1, 'unsigned'}``"
msgstr "``{1, 'unsigned'}``"

msgid "dimension"
msgstr "dimension"

msgid "affects :ref:`RTREE <box_index-rtree>` only"
msgstr "только для :ref:`RTREE <box_index-rtree>`"

msgid "2"
msgstr "2"

msgid "distance"
msgstr "distance"

msgid "affects RTREE only"
msgstr "только для RTREE"

msgid "string ('euclid' or 'manhattan')"
msgstr ""
"строка ('euclid', то есть Евклидова метрика; или 'manhattan', то есть "
"расстояние городских кварталов)"

msgid "'euclid'"
msgstr "'euclid'"

msgid "bloom_fpr"
msgstr "bloom_fpr"

msgid "affects vinyl only"
msgstr "только для vinyl"

msgid "``vinyl_bloom_fpr``"
msgstr "``vinyl_bloom_fpr``"

msgid "page_size"
msgstr "page_size"

msgid "``vinyl_page_size``"
msgstr "``vinyl_page_size``"

msgid "range_size"
msgstr "range_size"

msgid "``vinyl_range_size``"
msgstr "``vinyl_range_size``"

msgid "run_count_per_level"
msgstr "run_count_per_level"

msgid "``vinyl_run_count_per_level``"
msgstr "``vinyl_run_count_per_level``"

msgid "run_size_ratio"
msgstr "run_size_ratio"

msgid "``vinyl_run_size_ratio``"
msgstr "``vinyl_run_size_ratio``"

msgid "sequence"
msgstr "sequence"

msgid ""
"see section regarding :ref:`specifying a sequence in create_index() "
"<box_schema-sequence_create_index>`"
msgstr ""
"см. раздел об :ref:`указании последовательности для create_index() "
"<box_schema-sequence_create_index>`"

msgid "string or number"
msgstr "строка или число"

msgid "not present"
msgstr "отсутствует"

msgid "func"
msgstr "func"

msgid ":ref:`functional index <box_space-index_func>`"
msgstr ":ref:`функциональный индекс <box_space-index_func>`"

msgid "string"
msgstr "string"

msgid "hint (since version :doc:`2.6.1 </release/2.6.1>`)"
msgstr "hint (с версии :doc:`2.6.1 </release/2.6.1>`)"

msgid ""
"affects TREE only. ``true`` makes an index work faster, ``false`` -- an "
"index size is reduced by half"
msgstr ""
"только для TREE. ``true`` заставит индекс работать быстрее, ``false`` — "
"размер индекса будет уменьшен наполовину"

msgid ""
"The options in the above chart are also applicable for "
":doc:`/reference/reference_lua/box_index/alter`."
msgstr ""
"Параметры из вышеприведенной таблицы также могут использоваться в "
":doc:`/reference/reference_lua/box_index/alter`."

msgid ""
"**Note re storage engine:** vinyl has extra options which by default are "
"based on configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-"
"vinyl_bloom_fpr>`, :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`, "
"and :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- see "
"the description of those parameters. The current values can be seen by "
"selecting from :doc:`/reference/reference_lua/box_space/_index`."
msgstr ""
"**Примечание про движок базы данных:** в vinyl есть дополнительные "
"параметры, которые по умолчанию основаны на конфигурационных параметрах "
":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`, :ref:`vinyl_page_size "
"<cfg_storage-vinyl_page_size>`, :ref:`vinyl_range_size <cfg_storage-"
"vinyl_range_size>`, :ref:`vinyl_run_count_per_level <cfg_storage-"
"vinyl_run_count_per_level>` и :ref:`vinyl_run_size_ratio <cfg_storage-"
"vinyl_run_size_ratio>`, см. описание этих параметров. Текущие значения можно"
" увидеть, сделав выборку из "
":doc:`/reference/reference_lua/box_space/_index`."

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"tarantool> my_space = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> my_space:create_index('primary', {unique = true, parts = {\n"
"         > {field = 1, type = 'unsigned'},\n"
"         > {field = 2, type = 'string'}\n"
"         > }})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  - type: string\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  id: 0\n"
"  space_id: 512\n"
"  type: TREE\n"
"  name: primary\n"
"..."
msgstr ""
"tarantool> my_space = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> my_space:create_index('primary', {unique = true, parts = {\n"
"         > {field = 1, type = 'unsigned'},\n"
"         > {field = 2, type = 'string'}\n"
"         > }})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  - type: string\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  id: 0\n"
"  space_id: 512\n"
"  type: TREE\n"
"  name: primary\n"
"..."

msgid "**Alternative way to declare index parts**"
msgstr "**Другой способ объявления оператора parts**"

msgid ""
"Before version :doc:`2.7.1 </release/2.7.1>`, if an index consisted of a "
"single part and had some options like ``is_nullable`` or ``collation`` and "
"its definition was written as"
msgstr ""
"Если раньше (до версии :doc:`2.7.1 </release/2.7.1>`) индекс состоял из "
"одной части, содержал дополнительные параметры, например ``is_nullable`` или"
" ``collation``, и был описан так:"

msgid ""
"my_space:create_index('one_part_idx', {parts = {1, 'unsigned', "
"is_nullable=true}})"
msgstr ""
"my_space:create_index('one_part_idx', {parts = {1, 'unsigned', "
"is_nullable=true}})"

msgid "(with the only brackets) then options were ignored by Tarantool."
msgstr ""
"(с одинарными фигурными скобками), то Tarantool игнорировал эти параметры."

msgid ""
"Since version :doc:`2.7.1 </release/2.7.1>` it is allowed to omit extra "
"braces in an index definition and use both ways:"
msgstr ""
"Начиная с версии :doc:`2.7.1 </release/2.7.1>`, при описании индекса можно "
"не указывать дополнительные фигурные скобки, но допускаются оба варианта:"

msgid ""
"-- with extra braces\n"
"my_space:create_index('one_part_idx', {parts = {{1, 'unsigned', is_nullable=true}}})\n"
"\n"
"-- without extra braces\n"
"my_space:create_index('one_part_idx', {parts = {1, 'unsigned', is_nullable=true}})"
msgstr ""
"-- с дополнительными фигурными скобками\n"
"my_space:create_index('one_part_idx', {parts = {{1, 'unsigned', is_nullable=true}}})\n"
"\n"
"-- без дополнительных фигурных скобок\n"
"my_space:create_index('one_part_idx', {parts = {1, 'unsigned', is_nullable=true}})"

msgid "Details about index field types"
msgstr "Описание типов индексируемых полей"

msgid ""
"Index field types differ depending on what values are allowed, and what "
"index types are allowed."
msgstr ""
"В зависимости от допустимых типов индексов и допустимых значений "
"используются различные типы индексируемых полей."

msgid "Index field type"
msgstr "Тип поля для индексирования"

msgid "What can be in it"
msgstr "Чем может быть"

msgid "Where it is legal"
msgstr "Где использовать"

msgid "Examples"
msgstr "Примеры"

msgid "``unsigned``"
msgstr "``unsigned``"

msgid ""
"unsigned integers between 0 and 18446744073709551615, about 18 quintillion. "
"May also be called 'uint' or 'num', but 'num' is deprecated"
msgstr ""
"беззнаковые целые числа от 0 до 18 446 744 073 709 551 615, то есть примерно"
" 18 квинтиллионов. Также может называться 'uint' или 'num', но 'num' "
"объявлен устаревшим"

msgid "memtx TREE or HASH indexes;"
msgstr "индексы типа TREE или HASH в memtx;"

msgid "vinyl TREE indexes"
msgstr "TREE-индексы в vinyl"

msgid "123456"
msgstr "123456"

msgid "``string``"
msgstr "``string``"

msgid ""
"any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. May also be called 'str'. A string may "
"have a :ref:`collation <index-collation>`"
msgstr ""
"любая последовательность октетов до :ref:`максимальной длины "
"<limitations_bytes_in_index_key>`. Также может называться 'str'. В строке "
"может быть :ref:`сортировка <index-collation>`"

msgid "memtx TREE or HASH or BITSET indexes;"
msgstr "индексы типа TREE, HASH или BITSET в memtx;"

msgid "'A B C'"
msgstr "'A B C'"

msgid "'\\\\65 \\\\66 \\\\67'"
msgstr "'\\\\65 \\\\66 \\\\67'"

msgid "``varbinary``"
msgstr "``varbinary``"

msgid ""
"any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. A varbinary byte sequence does not have a"
" :ref:`collation <index-collation>` because its contents are not UTF-8 "
"characters"
msgstr ""
"любая последовательность октетов до :ref:`максимальной длины "
"<limitations_bytes_in_index_key>`. Последовательность байтов varbinary не "
"содержит символы UTF-8, поэтому в ней нет :ref:`сортировки <index-"
"collation>`"

msgid ""
"memtx TREE, HASH or BITSET (since version :doc:`2.7.1 </release/2.7.1>`) "
"indexes;"
msgstr ""
"индексы типа TREE, HASH или BITSET в memtx (начиная с версии :doc:`2.7.1 "
"</release/2.7.1>`);"

msgid "``integer``"
msgstr "``integer``"

msgid ""
"integers between -9223372036854775808 and 18446744073709551615. May also be "
"called 'int'"
msgstr ""
"целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615. "
"Может также называться 'int'"

msgid "-2^63"
msgstr "-2^63"

msgid "``number``"
msgstr "``number``"

msgid ""
"integers between -9223372036854775808 and 18446744073709551615, single-"
"precision floating point numbers, or double-precision floating point "
"numbers, or exact numbers"
msgstr ""
"целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615, "
"числа одинарной точности с плавающей запятой, числа двойной точности с "
"плавающей запятой или точные числа"

msgid "1.234"
msgstr "1.234"

msgid "-44"
msgstr "-44"

msgid "1.447e+44"
msgstr "1.447e+44"

msgid "``double``"
msgstr "``double``"

msgid "double-precision floating point numbers"
msgstr "числа двойной точности с плавающей запятой"

msgid "``boolean``"
msgstr "``boolean``"

msgid "true or false"
msgstr "true или false"

msgid "false"
msgstr "false"

msgid "``decimal``"
msgstr "``decimal``"

msgid ""
"exact number returned from a function in the :ref:`decimal <decimal>` module"
msgstr ""
"точное число, которая возвращает функция из модуля :ref:`decimal <decimal>`"

msgid "decimal.new(1.2)"
msgstr "decimal.new(1.2)"

msgid "``uuid`` (since :doc:`2.4.1 </release/2.4.1>`)"
msgstr "``uuid`` (с версии :doc:`2.4.1 </release/2.4.1>`)"

msgid ""
"a 128-bit quantity sequence of lower-case hexadecimal digits, representing "
"Universally Unique Identifiers (UUID)"
msgstr ""
"128-разрядная последовательность шестнадцатеричных чисел нижнего регистра, "
"которая представляет собой Универсальный уникальный идентификатор (UUID)"

msgid "uuid.fromstr('64d22e4d-ac92-4a23-899a-e59f34af5479')"
msgstr "uuid.fromstr('64d22e4d-ac92-4a23-899a-e59f34af5479')"

msgid "``array``"
msgstr "``array``"

msgid "array of numbers"
msgstr "массив чисел"

msgid "memtx :ref:`RTREE <box_index-rtree>` indexes"
msgstr "индексы типа :ref:`RTREE <box_index-rtree>` в memtx"

msgid "{10, 11}"
msgstr "{10, 11}"

msgid "{3, 5, 9, 10}"
msgstr "{3, 5, 9, 10}"

msgid "``scalar``"
msgstr "``scalar``"

msgid ""
"null (input with ``msgpack.NULL`` or ``yaml.NULL`` or ``json.NULL``), "
"booleans (true or false), or integers between -9223372036854775808 and "
"18446744073709551615, or single-precision floating point numbers, or double-"
"precision floating point numbers, or exact numbers, or strings, or "
"(varbinary) byte arrays, or uuids. When there is a mix of types, the key "
"order is: null, then booleans, then numbers, then strings, then byte arrays,"
" then uuids."
msgstr ""
"null (вводится через ``msgpack.NULL``, ``yaml.NULL`` или ``json.NULL``), "
"логические значения (``true`` или ``false``), целые числа от −9 223 372 036 "
"854 775 808 до 18 446 744 073 709 551 615, числа одинарной и двойной "
"точности с плавающей запятой, точные числа, строки, байтовые массивы "
"(varbinary) или идентификаторы UUID. Если используется несколько типов, "
"порядок ключей следующий: null, логические значения, числа, строки, байтовые"
" массивы, идентификаторы UUID."

msgid "null"
msgstr "null"

msgid "true"
msgstr "true"

msgid "-1"
msgstr "-1"

msgid "''"
msgstr "''"

msgid "'ру'"
msgstr "'ру'"

msgid "``nil``"
msgstr "``nil``"

msgid ""
"Additionally, `nil` is allowed with any index field type if "
":ref:`is_nullable=true <box_space-is_nullable>` is specified"
msgstr ""
"Кроме того, допускается использовать `nil` с любым типом индексируемого "
"поля, если указать :ref:`is_nullable=true <box_space-is_nullable>`"

msgid "Allowing null for an indexed key"
msgstr "Использование null в ключе индекса"

msgid "is_nullable parts option"
msgstr "is_nullable в операторе parts"

msgid ""
"If the index type is TREE, and the index is not the primary index, then the "
"``parts={...}`` clause may include ``is_nullable=true`` or "
"``is_nullable=false`` (the default)."
msgstr ""
"Если тип индекса — TREE, а индекс не является первичным, то в оператор "
"``parts={...}`` можно включить ``is_nullable=true`` или "
"``is_nullable=false`` (по умолчанию)."

msgid ""
"If ``is_nullable`` is true, then it is legal to insert ``nil`` or an "
"equivalent such as ``msgpack.NULL``. It is also legal to insert nothing at "
"all when using trailing nullable fields. Within indexes, such null values "
"are always treated as equal to other null values, and are always treated as "
"less than non-null values. Nulls may appear multiple times even in a unique "
"index. Example:"
msgstr ""
"Если ``is_nullable=true``, то можно вставить ``nil`` или его эквивалент, "
"например ``msgpack.NULL``. Если завершающие поля допускают null, в них можно"
" вообще ничего не вставлять. В индексах такие значения null всегда считают "
"равными другим значениям null и они всегда меньше, чем отличные от null "
"значения. Null может встречаться несколько раз даже в уникальном индексе. "
"Пример:"

msgid ""
"box.space.tester:create_index('I', {unique = true, parts = {{field = 2, type"
" = 'number', is_nullable = true}}})"
msgstr ""
"box.space.tester:create_index('I', {unique = true, parts = {{field = 2, type"
" = 'number', is_nullable = true}}})"

msgid ""
"It is legal to create multiple indexes for the same field with different "
"``is_nullable`` values, or to call "
":doc:`/reference/reference_lua/box_space/format` with a different "
"``is_nullable`` value from what is used for an index. When there is a "
"contradiction, the rule is: null is illegal unless ``is_nullable=true`` for "
"every index and for the space format."
msgstr ""
"Можно создать несколько индексов для одного и того же поля с различными "
"значениями ``is_nullable`` или вызвать "
":doc:`/reference/reference_lua/box_space/format` со значением "
"``is_nullable``, отличным от значения, которое используется для индекса. При"
" наличии несоответствий правило такое: запрещается использовать null, кроме "
"случаев, когда ``is_nullable=true`` для всех индексов и формата спейса."

msgid "exclude_null parts option"
msgstr "exclude_null в операторе parts"

msgid ""
"Since version 2.8.2 an index part definition may include option "
"``exclude_null``, which allows an index to skip tuples with null at this "
"part."
msgstr ""
"Начиная с версии 2.8.2, при описании индекса можно указать параметр "
"``exclude_null``, чтобы индекс пропускал кортежи со значением null в этой "
"части."

msgid ""
"By default, the option is set to ``false``. When ``exclude_null`` is turned "
"on, the ``is_nullable=true`` option will be set automatically. It can't be "
"used for the primary key. This option can be changed dynamically: in this "
"case the index is rebuilt."
msgstr ""
"Значение этого параметра по умолчанию — ``false``. Если включить "
"``exclude_null``, то ``is_nullable=true`` будет указано автоматически. Для "
"первичного ключа использовать этот параметр нельзя. Параметр можно изменять "
"динамически, и в этом случае индекс будет перестроен."

msgid ""
"Such indexes do not store filtered tuples at all, so indexing can be done "
"faster."
msgstr ""
"Такие индексы вообще не хранят отфильтрованные кортежи, поэтому "
"индексирование будет выполняться быстрее."

msgid ""
"``exclude_null`` and ``is_nullable`` are connected, so this table describes "
"the result of combining them:"
msgstr ""
"``exclude_null`` и ``is_nullable`` взаимосвязаны, поэтому ниже приводится "
"таблица допустимых сочетаний значений этих параметров:"

msgid "**exclude_null/is_nullable**"
msgstr "**exclude_null/is_nullable**"

msgid "**false**"
msgstr "**false**"

msgid "**true**"
msgstr "**true**"

msgid "ok"
msgstr "допускается"

msgid "not allowed"
msgstr "не допускается"

msgid "Creating an index using field names instead of field numbers"
msgstr "Создание индекса с использованием имен полей вместо номеров полей"

msgid ""
"``create_index()`` can use field names and/or field types described by the "
"optional :doc:`/reference/reference_lua/box_space/format` clause."
msgstr ""
"``create_index()`` может использовать имена полей и / или номера полей, "
"которые описаны в необязательном операторе "
":doc:`/reference/reference_lua/box_space/format`."

msgid ""
"In the following example, we show ``format()`` for a space that has two "
"columns named 'x' and 'y', and then we show five variations of the "
"``parts={}`` clause of ``create_index()``, first for the 'x' column, second "
"for both the 'x' and 'y' columns. The variations include omitting the type, "
"using numbers, and adding extra braces."
msgstr ""
"В следующем примере мы покажем использование ``format()`` для спейса с двумя"
" столбцами 'x' и 'y', а затем — пять вариантов использования оператора "
"``parts={}`` в ``create_index()`` сначала для столбца 'x', затем для "
"столбцов 'x' и 'y'. Эти варианты включают в себя пропуск типа, использование"
" чисел и дополнительных скобок."

msgid ""
"box.space.tester:format({{name = 'x', type = 'scalar'}, {name = 'y', type = 'integer'}})\n"
"\n"
"box.space.tester:create_index('I2', {parts = {{'x', 'scalar'}}})\n"
"box.space.tester:create_index('I3', {parts = {{'x', 'scalar'}, {'y', 'integer'}}})\n"
"\n"
"box.space.tester:create_index('I4', {parts = {{1, 'scalar'}}})\n"
"box.space.tester:create_index('I5', {parts = {{1, 'scalar'}, {2, 'integer'}}})\n"
"\n"
"box.space.tester:create_index('I6', {parts = {1}})\n"
"box.space.tester:create_index('I7', {parts = {1, 2}})\n"
"\n"
"box.space.tester:create_index('I8', {parts = {'x'}})\n"
"box.space.tester:create_index('I9', {parts = {'x', 'y'}})\n"
"\n"
"box.space.tester:create_index('I10', {parts = {{'x'}}})\n"
"box.space.tester:create_index('I11', {parts = {{'x'}, {'y'}}})"
msgstr ""
"box.space.tester:format({{name = 'x', type = 'scalar'}, {name = 'y', type = 'integer'}})\n"
"\n"
"box.space.tester:create_index('I2', {parts = {{'x', 'scalar'}}})\n"
"box.space.tester:create_index('I3', {parts = {{'x', 'scalar'}, {'y', 'integer'}}})\n"
"\n"
"box.space.tester:create_index('I4', {parts = {{1, 'scalar'}}})\n"
"box.space.tester:create_index('I5', {parts = {{1, 'scalar'}, {2, 'integer'}}})\n"
"\n"
"box.space.tester:create_index('I6', {parts = {1}})\n"
"box.space.tester:create_index('I7', {parts = {1, 2}})\n"
"\n"
"box.space.tester:create_index('I8', {parts = {'x'}})\n"
"box.space.tester:create_index('I9', {parts = {'x', 'y'}})\n"
"\n"
"box.space.tester:create_index('I10', {parts = {{'x'}}})\n"
"box.space.tester:create_index('I11', {parts = {{'x'}, {'y'}}})"

msgid ""
"Creating an index using the path option for map fields (JSON-path indexes)"
msgstr ""
"Создание индекса с использованием пути для полей с ассоциативными массивами "
"(индексы по пути JSON)"

msgid ""
"To create an index for a field that is a map (a path string and a scalar "
"value), specify the path string during index creation, like this:"
msgstr ""
"Чтобы создать индекс для поля, которое представляет собой ассоциативный "
"массив (строка с путем и скалярное значение), укажите строку c путем во "
"время создания индекса:"

msgid ""
":extsamp:`parts = {{*{field-number}*}, {*{'data-type'}*}, path = {*{'path-"
"name'}*}}`"
msgstr ""
":extsamp:`parts = {{*{field-number}*}, {*{'data-type'}*}, path = {*{'path-"
"name'}*}}`"

msgid ""
"The index type must be TREE or HASH and the contents of the field must "
"always be maps with the same path."
msgstr ""
"Тип индекса должен быть TREE или HASH, а содержимое поля — всегда "
"ассоциативный массив с одним и тем же путем."

msgid "**Example 1 -- The simplest use of path:**"
msgstr "**Пример 1 — Простое использование пути:**"

msgid ""
"tarantool> box.schema.space.create('T')\n"
"tarantool> box.space.T:create_index('I',{parts = {{field = 1, type = 'scalar', path = 'age'}}})\n"
"tarantool> box.space.T:insert({{age = 44}})\n"
"tarantool> box.space.T:select(44)\n"
"---\n"
"- [{'age': 44}]"
msgstr ""
"tarantool> box.schema.space.create('T')\n"
"tarantool> box.space.T:create_index('I',{parts = {{field = 1, type = 'scalar', path = 'age'}}})\n"
"tarantool> box.space.T:insert({{age = 44}})\n"
"tarantool> box.space.T:select(44)\n"
"---\n"
"- [{'age': 44}]"

msgid "**Example 2 -- path plus format() plus JSON syntax to add clarity:**"
msgstr ""
"**Пример 2 — для большей наглядности используем path вместе с format() и "
"JSON-синтаксисом:**"

msgid ""
"tarantool> my_space = box.schema.space.create('T')\n"
"tarantool> format = {{'id', 'unsigned'}, {'data', 'map'}}\n"
"tarantool> my_space:format(format)\n"
"tarantool> parts = {{'data.FIO[\"firstname\"]', 'str'}, {'data.FIO[\"surname\"]', 'str'}}\n"
"tarantool> my_index = my_space:create_index('info', {parts = parts})\n"
"tarantool> my_space:insert({1, {FIO = {firstname = 'Ahmed', surname = 'Xi'}}})\n"
"---\n"
"- [1, {'FIO': {'surname': 'Xi', 'firstname': 'Ahmed'}}]"
msgstr ""
"tarantool> my_space = box.schema.space.create('T')\n"
"tarantool> format = {{'id', 'unsigned'}, {'data', 'map'}}\n"
"tarantool> my_space:format(format)\n"
"tarantool> parts = {{'data.FIO[\"firstname\"]', 'str'}, {'data.FIO[\"surname\"]', 'str'}}\n"
"tarantool> my_index = my_space:create_index('info', {parts = parts})\n"
"tarantool> my_space:insert({1, {FIO = {firstname = 'Ahmed', surname = 'Xi'}}})\n"
"---\n"
"- [1, {'FIO': {'surname': 'Xi', 'firstname': 'Ahmed'}}]"

msgid ""
"**Note re storage engine:** vinyl supports only the TREE index type, and "
"vinyl secondary indexes must be created before tuples are inserted."
msgstr ""
"**Примечание про движок базы данных:** vinyl поддерживает только TREE-"
"индексы, и следует создать в vinyl'е вторичные индексы до вставки кортежей."

msgid "Creating a multikey index using the path option with [*]"
msgstr ""
"Создание индекса по массивам (multikey) с использованием опции path с "
"символом [*]"

msgid ""
"The string in a path option can contain ``[*]`` which is called **an array "
"index placeholder**. Indexes defined with this are useful for JSON documents"
" that all have the same structure."
msgstr ""
"Строка в параметре пути может содержать символ ``[*]``, который называется "
"**заменителем индекса массива**. Описанные так индексы используются для "
"JSON-документов, у которых одинаковая структура."

msgid ""
"For example, when creating an index on field#2 for a string document that "
"will start with ``{'data': [{'name': '...'}, {'name': '...'}]``, the parts "
"section in the ``create_index`` request could look like:"
msgstr ""
"Например, при создании индекса по полю №2 для документа со строками, который"
" будет начинаться с ``{'data': [{'name': '...'}, {'name': '...'}]``, раздел "
"parts в запросе на создание индекса будет выглядеть так:"

msgid "parts = {{field = 2, type = 'str', path = 'data[*].name'}}"
msgstr "parts = {{field = 2, type = 'str', path = 'data[*].name'}}"

msgid ""
"Then tuples containing names can be retrieved quickly with "
"``index_object:select({key-value})``."
msgstr ""
"Тогда кортежи с именами можно быстро получить с помощью "
"``index_object:select({key-value})``."

msgid ""
"In fact a single field can have multiple keys, as in this example which "
"retrieves the same tuple twice because there are two keys 'A' and 'B' which "
"both match the request:"
msgstr ""
"На самом деле в одном поле может быть несколько ключей, как в примере ниже, "
"который выводит один и тот же кортеж дважды, потому что оба ключа 'A' и 'B' "
"соответствуют запросу:"

msgid ""
"my_space = box.schema.space.create('json_documents')\n"
"my_space:create_index('primary')\n"
"multikey_index = my_space:create_index('multikey', {parts = {{field = 2, type = 'str', path = 'data[*].name'}}})\n"
"my_space:insert({1,\n"
"         {data = {{name = 'A'},\n"
"                  {name = 'B'}},\n"
"          extra_field = 1}})\n"
"multikey_index:select({''}, {iterator = 'GE'})"
msgstr ""
"my_space = box.schema.space.create('json_documents')\n"
"my_space:create_index('primary')\n"
"multikey_index = my_space:create_index('multikey', {parts = {{field = 2, type = 'str', path = 'data[*].name'}}})\n"
"my_space:insert({1,\n"
"         {data = {{name = 'A'},\n"
"                  {name = 'B'}},\n"
"          extra_field = 1}})\n"
"multikey_index:select({''}, {iterator = 'GE'})"

msgid "The result of the select request looks like this:"
msgstr "Результат выборки будет выглядеть так:"

msgid ""
"tarantool> multikey_index:select({''},{iterator='GE'})\n"
"---\n"
"- - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"- [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"..."
msgstr ""
"tarantool> multikey_index:select({''},{iterator='GE'})\n"
"---\n"
"- - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"- [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"..."

msgid "Some restrictions exist:"
msgstr "Есть некоторые ограничения:"

msgid "``[*]`` must be alone or must be at the end of a name in the path."
msgstr "символ ``[*]`` должен стоять отдельно или в конце имени в пути."

msgid "``[*]`` must not appear twice in the path."
msgstr "символ ``[*]`` не должен повторяться в пути."

msgid ""
"If an index has a path with ``x[*]``, then no other index can have a path "
"with x.component."
msgstr ""
"Если в индексе есть путь с ``x[*]``, то в никаком другом индексе не может "
"быть пути с x.компонентом,"

msgid "``[*]`` must not appear in the path of a primary key."
msgstr "``[*]`` нельзя указывать в пути первичного ключа."

msgid ""
"If an index has ``unique=true`` and has a path with ``[*]``, then duplicate "
"keys from different tuples are disallowed, but duplicate keys for the same "
"tuple are allowed."
msgstr ""
"Если индекс должен быть уникальным (``unique=true``) и в нем есть путь с "
"символом ``[*]``, то запрещается использовать дублирующиеся ключи в разных "
"кортежах, но в в одном кортеже можно использовать дублирующиеся ключи."

msgid ""
"The field's value must have the same structure as in the path definition, or"
" be nil (nil is not indexed)."
msgstr ""
"Структура значения поля должна соответствовать стуктуре, заданной в "
"определении пути, или значение поля должно быть nil (nil не индексируется)."

msgid ""
"In a space with multikey indexes, any tuple cannot contain "
":ref:`more than ~8,000 elements <limitations_fields_in_tuple_multikey_index>` indexed that way."
msgstr ""
"В спейсе с индексами по массивам можно хранить не более "
":ref:`~8000 элементов <limitations_fields_in_tuple_multikey_index>`, "
"проиндексированных таким образом."

msgid "Creating a functional index"
msgstr "Создание функционального индекса"

msgid ""
"Functional indexes are indexes that call a user-defined function for forming"
" the index key, rather than depending entirely on the Tarantool default "
"formation. Functional indexes are useful for condensing or truncating or "
"reversing or any other way that users want to customize the index."
msgstr ""
"Функциональные индексы — это индексы, которые вызывают пользовательскую "
"функцию для формирования ключа индекса, в отличие от других типов индексов, "
"где ключ формирует сам Tarantool. Функциональные индексы используют для "
"сжатия, усечения или реверсирования или любого другого изменения индекса по "
"желанию пользователя."

msgid "There are several recommendations for building functional indexes:"
msgstr "Ниже приведены рекомендации по созданию функциональных индексов:"

msgid ""
"The function definition must expect a tuple, which has the contents of "
"fields at the time a data-change request happens and must return a tuple, "
"which has the contents that will actually be put in the index."
msgstr ""
"Функция должна принимать кортеж с содержимым полей на момент запроса на "
"изменение данных и возвращать кортеж с содержимым, которое будет фактически "
"помещено в индекс."

msgid ""
"The ``create_index`` definition must include specification of all key parts,"
" and the custom function must return a table which has the same number of "
"key parts with the same types."
msgstr ""
"Описание ``create_index`` должно включать в себя определение всех частей "
"ключа, а пользовательская функция должна возвращать таблицу, которая "
"содержит то же количество частей ключа с теми же типами."

msgid "The space must have a memtx engine."
msgstr "Спейс должен быть на движке memtx."

msgid ""
"The function must be persistent and deterministic (see :ref:`Creating a "
"function with body <box_schema-func_create_with-body>`)."
msgstr ""
"Функция должна быть персистентной и детерминированной (см. :ref:`Создание "
"функции с телом <box_schema-func_create_with-body>`)."

msgid "The key parts must not depend on JSON paths."
msgstr "Части ключа не должны зависеть от JSON-путей."

msgid "The function must access key-part values by index, not by field name."
msgstr ""
"Функция должна получать доступ к значениям частей ключа по индексу, а не по "
"имени поля."

msgid "Functional indexes must not be primary-key indexes."
msgstr "Функциональные индексы не должны быть по первичному ключу."

msgid ""
"Functional indexes cannot be altered and the function cannot be changed if "
"it is used for an index, so the only way to change them is to drop the index"
" and create it again."
msgstr ""
"Нельзя изменить ни функциональные индексы, ни функцию, если она используется"
" для индекса, то есть единственный способ изменить их — это удалить индекс и"
" создать его заново."

msgid ""
"Only :ref:`sandboxed <box_schema-func_create_with-body>` functions are "
"suitable for functional indexes."
msgstr ""
"Только функции, :ref:`запущенные из песочницы <box_schema-func_create_with-"
"body>`, могут использоваться в функциональных индексах."

msgid ""
"A function could make a key using only the first letter of a string field."
msgstr ""
"Функция может создать ключ, используя только первую букву строкового поля."

msgid ""
"Create a space. The space needs a primary-key field, which is not the field "
"that we will use for the functional index:"
msgstr ""
"Создайте спейс. В спейсе должно быть поле с первичным ключом, которое не "
"будет полем для функционального индекса:"

msgid ""
"box.schema.space.create('tester', {engine = 'memtx'})\n"
"box.space.tester:create_index('i',{parts={{field = 1, type = 'string'}}})"
msgstr ""
"box.schema.space.create('tester', {engine = 'memtx'})\n"
"box.space.tester:create_index('i',{parts={{field = 1, type = 'string'}}})"

msgid ""
"Create a function. The function expects a tuple. In this example, it will work "
"on tuple[2] because the key source is field number 2 in what we will insert."
" Use ``string.sub()`` from the ``string`` module to get the first character:"
msgstr ""
"Создайте функцию. Функция принимает кортеж. В этом примере она работает на "
"кортеже tuple[2], поскольку источник ключа — поле номер 2, в которое мы "
"вставляем данные. Используйте ``string.sub()`` из модуля ``string``, чтобы "
"получить первый символ:"

msgid "lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]"
msgstr "lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]"

msgid ""
"Make the function persistent using the ``box.schema.func.create`` function:"
msgstr "Сделайте функцию персистентной с помощью ``box.schema.create``:"

msgid ""
"box.schema.func.create('my_func',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})"
msgstr ""
"box.schema.func.create('my_func',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})"

msgid ""
"Make a functional index. Specify the fields whose values will be passed to "
"the function. Specify the function:"
msgstr ""
"Создайте функциональный индекс. Укажите поля, значения которых будут "
"передаваться в функцию. Укажите функцию:"

msgid ""
"box.space.tester:create_index('func_idx',{parts={{field = 1, type = "
"'string'}},func = 'my_func'})"
msgstr ""
"box.space.tester:create_index('func_idx',{parts={{field = 1, type = "
"'string'}},func = 'my_func'})"

msgid ""
"Test. Insert a few tuples. Select using only the first letter, it will work "
"because that is the key. Or, select using the same function as was used for "
"insertion:"
msgstr ""
"Проверьте, как это работает. Вставьте несколько кортежей. Сделайте выборку, "
"используя только первую букву, — сработает, потому что это и есть ключ. Или "
"выберите, используя ту же функцию, что была использована для вставки:"

msgid ""
"box.space.tester:insert({'a', 'wombat'})\n"
"box.space.tester:insert({'b', 'rabbit'})\n"
"box.space.tester.index.func_idx:select('w')\n"
"box.space.tester.index.func_idx:select(box.func.my_func:call({{'tester', 'wombat'}}));"
msgstr ""
"box.space.tester:insert({'a', 'wombat'})\n"
"box.space.tester:insert({'b', 'rabbit'})\n"
"box.space.tester.index.func_idx:select('w')\n"
"box.space.tester.index.func_idx:select(box.func.my_func:call({{'tester', 'wombat'}}));"

msgid "The results of the two ``select`` requests will look like this:"
msgstr "Результаты двух запросов ``select`` будут выглядеть так:"

msgid ""
"tarantool> box.space.tester.index.func_idx:select('w')\n"
"---\n"
"- - ['a', 'wombat']\n"
"...\n"
"tarantool> box.space.tester.index.func_idx:select(box.func.my_func:call({{'tester','wombat'}}));\n"
"---\n"
"- - ['a', 'wombat']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.func_idx:select('w')\n"
"---\n"
"- - ['a', 'wombat']\n"
"...\n"
"tarantool> box.space.tester.index.func_idx:select(box.func.my_func:call({{'tester','wombat'}}));\n"
"---\n"
"- - ['a', 'wombat']\n"
"..."

msgid "Here is the full code of the example:"
msgstr "Вот пример кода полностью:"

msgid ""
"box.schema.space.create('tester', {engine = 'memtx'})\n"
"box.space.tester:create_index('i',{parts={{field = 1, type = 'string'}}})\n"
"lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]\n"
"box.schema.func.create('my_func',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})\n"
"box.space.tester:create_index('func_idx',{parts={{field = 1, type = 'string'}},func = 'my_func'})\n"
"box.space.tester:insert({'a', 'wombat'})\n"
"box.space.tester:insert({'b', 'rabbit'})\n"
"box.space.tester.index.func_idx:select('w')\n"
"box.space.tester.index.func_idx:select(box.func.my_func:call({{'tester', 'wombat'}}));"
msgstr ""
"box.schema.space.create('tester', {engine = 'memtx'})\n"
"box.space.tester:create_index('i',{parts={{field = 1, type = 'string'}}})\n"
"lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]\n"
"box.schema.func.create('my_func',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})\n"
"box.space.tester:create_index('func_idx',{parts={{field = 1, type = 'string'}},func = 'my_func'})\n"
"box.space.tester:insert({'a', 'wombat'})\n"
"box.space.tester:insert({'b', 'rabbit'})\n"
"box.space.tester.index.func_idx:select('w')\n"
"box.space.tester.index.func_idx:select(box.func.my_func:call({{'tester', 'wombat'}}));"

msgid ""
"Functions for functional indexes can return **multiple keys**. Such "
"functions are called \"multikey\" functions."
msgstr ""
"Функции для функциональных индексов могут возвращать **множество ключей**. "
"Такие функции называют \"мультиключевыми\" (multikey)."

msgid ""
"The ``box.func.create`` options must include ``opts = {is_multikey = "
"true}``. The return value must be a table of tuples. If a multikey function "
"returns N tuples, then N keys will be added to the index."
msgstr ""
"В таком случае в ``box.func.create`` надо включить ``opts = {is_multikey = "
"true}``. Возвращается таблица с кортежами. Если мультиключевая функция "
"возвращает N кортежей, то в индекс добавятся N ключей."

msgid ""
"s = box.schema.space.create('withdata')\n"
"s:format({{name = 'name', type = 'string'},\n"
"          {name = 'address', type = 'string'}})\n"
"pk = s:create_index('name', {parts = {{field = 1, type = 'string'}}})\n"
"lua_code = [[function(tuple)\n"
"               local address = string.split(tuple[2])\n"
"               local ret = {}\n"
"               for _, v in pairs(address) do\n"
"                 table.insert(ret, {utf8.upper(v)})\n"
"               end\n"
"               return ret\n"
"             end]]\n"
"box.schema.func.create('address',\n"
"                        {body = lua_code,\n"
"                         is_deterministic = true,\n"
"                         is_sandboxed = true,\n"
"                         opts = {is_multikey = true}})\n"
"idx = s:create_index('addr', {unique = false,\n"
"                              func = 'address',\n"
"                              parts = {{field = 1, type = 'string',\n"
"                                      collation = 'unicode_ci'}}})\n"
"s:insert({\"James\", \"SIS Building Lambeth London UK\"})\n"
"s:insert({\"Sherlock\", \"221B Baker St Marylebone London NW1 6XE UK\"})\n"
"idx:select('Uk')\n"
"-- Both tuples will be returned."
msgstr ""
"s = box.schema.space.create('withdata')\n"
"s:format({{name = 'name', type = 'string'},\n"
"          {name = 'address', type = 'string'}})\n"
"pk = s:create_index('name', {parts = {{field = 1, type = 'string'}}})\n"
"lua_code = [[function(tuple)\n"
"               local address = string.split(tuple[2])\n"
"               local ret = {}\n"
"               for _, v in pairs(address) do\n"
"                 table.insert(ret, {utf8.upper(v)})\n"
"               end\n"
"               return ret\n"
"             end]]\n"
"box.schema.func.create('address',\n"
"                        {body = lua_code,\n"
"                         is_deterministic = true,\n"
"                         is_sandboxed = true,\n"
"                         opts = {is_multikey = true}})\n"
"idx = s:create_index('addr', {unique = false,\n"
"                              func = 'address',\n"
"                              parts = {{field = 1, type = 'string',\n"
"                                      collation = 'unicode_ci'}}})\n"
"s:insert({\"James\", \"SIS Building Lambeth London UK\"})\n"
"s:insert({\"Sherlock\", \"221B Baker St Marylebone London NW1 6XE UK\"})\n"
"idx:select('Uk')\n"
"-- Вернутся оба кортежа."
