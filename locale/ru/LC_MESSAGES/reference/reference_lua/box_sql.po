
msgid "Functions for SQL"
msgstr ""

msgid "The ``box`` module contains some functions related to SQL:"
msgstr ""

msgid ""
"``box.schema.func.create`` -- for making Lua functions callable from SQL "
"statements. See :ref:`Calling Lua routines from SQL <sql_calling_lua>` in"
" the :ref:`SQL Plus Lua <sql_plus_lua>` section."
msgstr ""

msgid ""
"``box.execute`` -- for making SQL statements callable from Lua functions."
" See the :ref:`SQL user guide <sql_user_guide>`."
msgstr ""

msgid "``box.prepare`` and ``box.unprepare``."
msgstr ""

msgid ""
"Some SQL statements are illustrated in the :ref:`SQL tutorial "
"<sql_tutorial>`."
msgstr ""

msgid "Execute the SQL statement contained in the sql-statement parameter."
msgstr ""

msgid "Parameters"
msgstr "Параметры"

#, fuzzy
msgid ""
"statement, which should conform to :ref:`the rules for SQL grammar "
"<sql_statements_and_clauses>`"
msgstr ""
"имя функции, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

msgid "optional table for placeholders in the statement"
msgstr ""

msgid "return"
msgstr "возвращается"

msgid "depends on statement"
msgstr ""

msgid "There are two ways to pass extra parameters for ``box.execute()``:"
msgstr ""

msgid ""
"The first way, which is the preferred way, is to put placeholders in the "
"string, and pass a second argument, an *extra-parameters* table. A "
"placeholder is either a question mark \"?\", or a colon \":\" followed by"
" a name. An extra parameter is any Lua expression. If placeholders are "
"question marks, then they will be replaced by extra-parameter values in "
"corresponding positions, that is, the first ? will be replaced by the "
"first extra parameter, the second ? will be replaced by the second extra "
"parameter, and so on. If placeholders are :names, then they will be "
"replaced by extra-parameter values with corresponding names. For example "
"this request which contains literal values 1 and 'x': |br| "
"``box.execute([[INSERT INTO tt VALUES (1, 'x');]]);`` |br| is the same as"
" this request which contains two question-mark placeholders (``?`` and "
"``?``) and a two-element extra-parameters table: |br| ``x = {1,'x'}`` "
"|br| ``box.execute([[INSERT INTO tt VALUES (?, ?);]], x);`` |br| and is "
"the same as this request which contains two :name placeholders (``:a`` "
"and ``:b``) and a two-element extra-parameters table with elements named "
"\"a\" and \"b\": |br| ``box.execute([[INSERT INTO tt VALUES (:a, :b);]], "
"{{[':a']=1},{[':b']='x'}})`` |br|"
msgstr ""

msgid ""
"The second way is to concatenate strings. For example, this Lua script "
"will insert 10 rows with different primary-key values into table t: |br| "
"``for i=1,10,1 do`` |br| |nbsp| |nbsp| ``box.execute(\"insert into t "
"values (\" .. i .. \")\")`` |br| ``end`` |br| When creating SQL "
"statements based on user input, application developers should beware of "
"`SQL injection <https://en.wikipedia.org/wiki/SQL_injection>`_."
msgstr ""

msgid ""
"Since ``box.execute()`` is an invocation of a Lua function, it either "
"causes an error message or returns a value."
msgstr ""

msgid ""
"For some statements the returned value will contain a field named "
"\"rowcount\". For example;"
msgstr ""

msgid ""
"tarantool> box.execute([[CREATE TABLE table1 (column1 INT PRIMARY key, "
"column2 VARCHAR(10));]])\n"
"---\n"
"- rowcount: 1\n"
"...\n"
"tarantool> box.execute([[INSERT INTO table1 VALUES (55,'Hello SQL "
"world!');]])\n"
"---\n"
"- rowcount: 1\n"
"..."
msgstr ""

msgid ""
"For statements that cause generation of values for PRIMARY KEY "
"AUTOINCREMENT columns, there will also be a field named "
"\"autoincrement_ids\"."
msgstr ""

msgid ""
"For SELECT or PRAGMA statements, the returned value will be a *result "
"set*, containing a field named \"metadata\" (a table with column names "
"and Tarantool/NoSQL type names) and a field named \"rows\" (a table with "
"the contents of each row)."
msgstr ""

msgid ""
"For example, for a statement ``SELECT \"x\" FROM t WHERE \"x\"=5;`` where"
" ``\"x\"`` is an INTEGER column and there is one row, a display on the "
"Tarantool client will look like this:"
msgstr ""

msgid ""
"tarantool> box.execute([[SELECT \"x\" FROM t WHERE \"x\"=5;]])\n"
"---\n"
"- metadata:\n"
"  - name: x\n"
"    type: integer\n"
"  rows:\n"
"  - [5]\n"
"..."
msgstr ""

msgid ""
"For a look at raw format of SELECT results, see :ref:`Binary protocol -- "
"responses for SQL <box_protocol-sql_protocol>`."
msgstr ""

msgid "The order of components within a map is not guaranteed."
msgstr ""

msgid ""
"If ``sql_full_metadata`` in the :ref:`_session_settings <box_space-"
"session_settings>` system table is TRUE, then result set metadata may "
"include these things in addition to ``name`` and ``type``:"
msgstr ""

msgid ""
"``collation`` (present only if COLLATE clause is specified for a STRING) "
"= :ref:`\"Collation\" <index-collation>`."
msgstr ""

msgid ""
"``is_nullable`` (present only if the :ref:`select list <sql_select_list>`"
" specified a base table column and nothing else) = false if column was "
"defined as :ref:`NOT NULL <sql_nulls>`, otherwise true. If this is not "
"present, that implies that nullability is unknown."
msgstr ""

msgid ""
"``is_autoincrement`` (present only if the select list specified a base "
"table column and nothing else) = true if column was defined as "
":ref:`PRIMARY KEY AUTOINCREMENT <sql_table_constraint_def>`, otherwise "
"false."
msgstr ""

msgid ""
"``span`` (always present) = the original expression in a select list, "
"which will often be the same as ``name`` if the select list specifies a "
"column name and nothing else, but otherwise will differ, for example "
"after ``SELECT x+55 AS x FROM t;`` the ``name`` is X and the ``span`` is "
"x+55. If ``span`` and ``name`` are the same then the content is MP_NIL."
msgstr ""

msgid ""
"Alternative: if you are using the Tarantool server as a client, you can "
"switch languages thus:"
msgstr ""

msgid ""
"\\set language sql\n"
"\\set delimiter ;"
msgstr ""

msgid ""
"Afterwards, you can enter any SQL statement directly without needing "
"``box.execute()``."
msgstr ""

msgid ""
"There is also an ``execute()`` function available via :ref:`module "
"net.box <net_box-module>`, for example after ``conn = net_box.connect"
"(url-string)`` one can say ``conn:execute(sql-statement])``."
msgstr ""

msgid ""
"Prepare the SQL statement contained in the sql-statement parameter. The "
"syntax and requirements for ``box.prepare`` are the same as for "
":ref:`box.execute <box-sql_box_execute>`."
msgstr ""

msgid "prepared_table, with id and methods and metadata"
msgstr ""

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "table"
msgstr "таблица"

msgid ""
"``box.prepare`` compiles an SQL statement into byte code and saves the "
"byte code in a cache. Since compiling takes a significant amount of time,"
" preparing a statement will enhance performance if the statement is "
"executed many times."
msgstr ""

msgid "If ``box.prepare`` succeeds, prepared_table contains:"
msgstr ""

msgid ""
"``stmt_id``: integer -- an identifier generated by a hash of the "
"statement string"
msgstr ""

msgid "``execute``: function"
msgstr ""

msgid "``params``: map [name : string, type : string] -- parameter descriptions"
msgstr ""

msgid "``unprepare``: function"
msgstr ""

msgid ""
"``metadata``: map [name : string, type : string] (This is present only "
"for SELECT or PRAGMA statements and has the same contents as the "
":ref:`result set metadata <box-sql_result_sets>` for ``box.execute``)"
msgstr ""

msgid "``param_count``: integer -- number of parameters"
msgstr ""

msgid ""
"This can be used by :ref:`prepared_table:execute() <box-"
"sql_box_execute_prepared_statement>` and by "
":ref:`prepared_table:unprepare() <box-"
"sql_box_unprepare_prepared_statement>`."
msgstr ""

msgid ""
"The prepared statement cache (which is also called the prepared statement"
" holder) is \"shared\", that is, there is one cache for all sessions. "
"However, session X cannot execute a statement prepared by session Y. |br|"
" For monitoring the cache, see :ref:`box.info().sql <box_introspection-"
"box_info>`. |br| For changing the cache, see :ref:`(Configuration "
"reference) sql_cache_size <cfg_basic-sql_cache_size>`."
msgstr ""

msgid ""
"Prepared statements will \"expire\" (become invalid) if any database "
"object is dropped or created or altered -- even if the object is not "
"mentioned in the SQL statement, even if the create or drop or alter is "
"rolled back, even if the create or drop or alter is done in a different "
"session."
msgstr ""

msgid ""
"Execute a statement that has been prepared with :ref:`box.prepare() <box-"
"sql_box_prepare>`."
msgstr ""

msgid ""
"Parameter ``prepared_table`` should be the result from ``box.prepare()``."
" |br| Parameter ``extra-parameters`` should be an optional table to match"
" :ref:`placeholders or named parameters <box-sql_extra_parameters>` in "
"the statement."
msgstr ""

msgid ""
"There are two ways to execute: with the method or with the statement id. "
"That is, :samp:`{prepared_table}:execute()` and "
":samp:`box.execute({prepared_table}.stmt_id)` do the same thing."
msgstr ""

msgid ""
"Example: here is a test. This function inserts a million rows in a table "
"using a prepared INSERT statement."
msgstr ""

msgid ""
"function f()\n"
"  local p, start_time\n"
"  box.execute([[DROP TABLE IF EXISTS t;]])\n"
"  box.execute([[CREATE TABLE t (s1 INTEGER PRIMARY KEY);]])\n"
"  start_time = os.time()\n"
"  p = box.prepare([[INSERT INTO t VALUES (?);]])\n"
"  for i=1,1000000 do p:execute({i}) end\n"
"  p:unprepare()\n"
"  end_time = os.time()\n"
"  box.execute([[COMMIT;]])\n"
"  print(end_time - start_time) -- elapsed time\n"
"end\n"
"f()"
msgstr ""

#, python-format
msgid ""
"Take note of the elapsed time. Now change the line with the loop to: |br|"
" ``for i=1,1000000 do box.execute([[INSERT INTO t VALUES (?);]], {i}) "
"end`` |br| Run the function again, and take note of the elapsed time "
"again. The function which executes the prepared statement will be about "
"15% faster, though of course this will vary depending on Tarantool "
"version and environment."
msgstr ""

msgid ""
"Undo the result of an earlier :ref:`box.prepare() <box-sql_box_prepare>` "
"request. This is equivalent to standard-SQL DEALLOCATE PREPARE."
msgstr ""

msgid "Parameter ``prepared_table`` should be the result from ``box.prepare()``."
msgstr ""

msgid ""
"There are two ways to unprepare: with the method or with the statement "
"id. That is, :samp:`{prepared_table}:unprepare()` and "
":samp:`box.unprepare({prepared_table}.stmt_id)` do the same thing."
msgstr ""

msgid ""
"Tarantool strongly recommends using ``unprepare`` as soon as the "
"immediate objective (executing a prepared statement multiple times) is "
"done, or whenever a prepared statement expires. There is no automatic "
"eviction policy, although automatic ``unprepare`` will happen when the "
"session disconnects (the session's prepared statements will be removed "
"from the prepared-statement cache)."
msgstr ""

#~ msgid "optional list for placeholders in the statement"
#~ msgstr ""

#~ msgid ""
#~ "The first way is to concatenate "
#~ "strings. For example, this Lua script"
#~ " will insert 10 rows with different"
#~ " primary-key values into table t:"
#~ msgstr ""

#~ msgid ""
#~ "for i=1,10,1 do\n"
#~ "  box.execute(\"insert into t values (\" .. i .. \")\")\n"
#~ "end"
#~ msgstr ""

#~ msgid ""
#~ "The second way is to put one "
#~ "or more placeholder \"?\" tokens inside"
#~ " the string, and pass a second "
#~ "argument, which must be a table "
#~ "containing values for each placeholder. "
#~ "For example these two requests are "
#~ "equivalent:"
#~ msgstr ""

#~ msgid ""
#~ "box.execute([[INSERT INTO tt VALUES (1,'x');]]);\n"
#~ "x = {1,'x'}; box.execute([[INSERT INTO tt VALUES (?,?);]], x);"
#~ msgstr ""

#~ msgid ""
#~ "For SELECT statements the returned value"
#~ " will contain a field named metadata"
#~ " (a table with column names and "
#~ "data types) and a field named "
#~ "\"rows\" (a table with the result "
#~ "set). For example:"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.execute([[SELECT * FROM table1 WHERE column1 > 0;]])\n"
#~ "---\n"
#~ "- metadata:\n"
#~ "  - name: COLUMN1\n"
#~ "    type: integer\n"
#~ "  - name: COLUMN2\n"
#~ "    type: string\n"
#~ "  rows:\n"
#~ "  - [55, 'Hello SQL world!']\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "The result structure contains Tarantool/NoSQL"
#~ " data type names in MsgPack format."
#~ " For example, for a statement SELECT"
#~ " \"x\" FROM t WHERE \"x\"=5; where"
#~ " \"x\" is an integer column and "
#~ "there is one row, the raw data "
#~ "for the result set will look like"
#~ " this:"
#~ msgstr ""

#~ msgid ""
#~ "If ``sql_full_metadata`` in the "
#~ ":ref:`_session_settings <box_space-session_settings>` "
#~ "system table is TRUE, then result "
#~ "set metadata may include these things"
#~ " in addition to ``name`` and "
#~ "``type``: |br| * ``collation`` (present "
#~ "only if COLLATE clause is specified "
#~ "for a STRING) = :ref:`\"Collation\" "
#~ "<index-collation>`. |br| In the common "
#~ "binary protocol this is encoded with "
#~ "IPROTO_FIELD_COLL (0x02). |br| * "
#~ "``is_nullable`` (present only if the "
#~ ":ref:`select list <sql_select_list>` specified "
#~ "a base table column and nothing "
#~ "else) = false if column was "
#~ "defined as :ref:`NOT NULL <sql_nulls>`, "
#~ "otherwise true. If this is not "
#~ "present, that implies that nullability "
#~ "is unknown. In the common binary "
#~ "protocol this is encoded with "
#~ "IPROTO_FIELD_IS_NULLABLE (0x03). |br| * "
#~ "``is_autoincrement`` (present only if the "
#~ "select list specified a base table "
#~ "column and nothing else) = true if"
#~ " column was defined as :ref:`PRIMARY "
#~ "KEY AUTOINCREMENT <sql_table_constraint_def>`, "
#~ "otherwise false. In the common binary"
#~ " protocol this is encoded with "
#~ "IPROTO_FIELD_IS_AUTOINCREMENT (0x04). |br| * "
#~ "``span`` (always present) = the original"
#~ " expression in a select list, which"
#~ " will often be the same as "
#~ "``name`` if the select list specifies"
#~ " a column name and nothing else, "
#~ "but otherwise will differ, for example"
#~ " after ``SELECT x+55 AS x FROM "
#~ "t;`` the ``name`` is X and the "
#~ "``span`` is x+55. In the common "
#~ "binary protocol this is encoded with "
#~ "IPROTO_FIELD_SPAN (0x05), but if ``span`` "
#~ "and ``name`` are the same then the"
#~ " content is MP_NIL."
#~ msgstr ""

#~ msgid ""
#~ "If ``box.prepare`` succeeds, prepared_table "
#~ "contains: |br| ``stmt_id``: integer -- "
#~ "an identifier generated by a hash "
#~ "of the statement string |br| "
#~ "``execute``: function |br| ``params``: map "
#~ "[name : string, type : integer] --"
#~ " parameter descriptions |br| ``unprepare``: "
#~ "function |br| ``metadata``: map [name :"
#~ " string, type : integer] |br| "
#~ "``param_count``: integer -- number of "
#~ "parameters |br| This can be used "
#~ "by :ref:`prepared_table:execute() <box-"
#~ "sql_box_execute_prepared_statement>` and by "
#~ ":ref:`prepared_table:unprepare() <box-"
#~ "sql_box_unprepare_prepared_statement>`."
#~ msgstr ""

#~ msgid ""
#~ "Parameter ``prepared_table`` should be the "
#~ "result from ``box.prepare()``. |br| Parameter"
#~ " ``extra-parameters`` should be an "
#~ "optional list for placeholders in the"
#~ " statement."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool strongly recommends using "
#~ "``unprepare`` as soon as the immediate"
#~ " objective (executing a prepared statement"
#~ " multiple times) is done, or whenever"
#~ " a prepared statement expires. There "
#~ "is no automatic eviction policy, "
#~ "although automatic ``unprepare`` will happen"
#~ " when the session disconnects (the "
#~ "session's prepared statements will be "
#~ "removed from the prepared-statment "
#~ "cache)."
#~ msgstr ""

#~ msgid ""
#~ "``box.schema.func.create`` -- for making Lua"
#~ " functions callable from SQL statements."
#~ " See :ref:`Calling Lua routines from "
#~ "SQL <sql_calling_lua>` in the :ref:`SQL "
#~ "Plus Lua <sql_sql_plus_lua>` section."
#~ msgstr ""

#~ msgid ""
#~ "``box.execute`` -- for making SQL "
#~ "statements callable from Lua functions. "
#~ "See the :ref:`SQL user guide "
#~ "<sql_sql_user_guide>`."
#~ msgstr ""

#~ msgid ""
#~ "The first way is to concatenate "
#~ "strings. For example, this Lua script"
#~ " will insert 10 rows with different"
#~ " primary-key values into table t: "
#~ "|br| ``for i=1,10,1 do`` |br| |nbsp| "
#~ "|nbsp| ``box.execute(\"insert into t values"
#~ " (\" .. i .. \")\")`` |br| "
#~ "``end``"
#~ msgstr ""

#~ msgid ""
#~ "The second way is to put "
#~ "placeholder ``?`` question-mark tokens "
#~ "inside the string, and pass a "
#~ "second argument *extra-parameters*, which "
#~ "must be a table containing values "
#~ "for each placeholder. For example these"
#~ " two requests are equivalent: |br| "
#~ "``box.execute([[INSERT INTO tt VALUES (1, "
#~ "'x');]]);`` |br| ``x = {1,'x'}; "
#~ "box.execute([[INSERT INTO tt VALUES (?, "
#~ "?);]], x);`` |br| Or, put parameter "
#~ "names inside the string. A parameter "
#~ "name must start with ``:`` colon "
#~ "and must match a named component "
#~ "of the *extra-parameters* table. For "
#~ "example, this request is also "
#~ "equivalent: |br| ``box.execute([[INSERT INTO "
#~ "tt VALUES (:a, :b);]], "
#~ "{{[':a']=1},{[':b']='x'}})``"
#~ msgstr ""

#~ msgid ""
#~ "For some statements the returned value"
#~ " will contain a field named rowcount."
#~ " For example;"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.execute([[INSERT INTO tt VALUES (8,8),(9,9);]])\n"
#~ "tarantool> box.execute([[CREATE TABLE table1 "
#~ "(column1 INT PRIMARY key, column2 "
#~ "VARCHAR(10));]])\n"
#~ "---\n"
#~ "- rowcount: 1\n"
#~ "...\n"
#~ "tarantool> box.execute([[INSERT INTO table1 "
#~ "VALUES (55,'Hello SQL world!');]])\n"
#~ "---\n"
#~ "- rowcount: 1\n"
#~ "..."
#~ msgstr ""

#~ msgid "The data for the result set, in MsgPack format, will look like this:"
#~ msgstr ""

#~ msgid ""
#~ "dd 00 00 00 01                  1-element array\n"
#~ "82                              2-element map (for metadata + rows)\n"
#~ "a8 6d 65 74 61 64 61 74 61      string = \"metadata\"\n"
#~ "91                              1-element array (for column count)\n"
#~ "82                              2-element map (for name + type)\n"
#~ "a4 6e 61 6d 65                  string = \"name\"\n"
#~ "a1 78                           string = \"x\"\n"
#~ "a4 74 79 70 6                   string = \"type\"\n"
#~ "a7 69 6e 74 65 67 65 72         string = \"integer\"\n"
#~ "a4 72 6f 77 73                  string = \"rows\"\n"
#~ "91                              1-element array (for row count)\n"
#~ "91                              1-element array (for field count)\n"
#~ "05                              contents"
#~ msgstr ""

#~ msgid ""
#~ "For a look at the raw format "
#~ "see :ref:`Binary protocol -- illustration "
#~ "<box_protocol-illustration>`."
#~ msgstr ""

#~ msgid ""
#~ "If ``sql_full_metadata`` in the "
#~ ":ref:`_session_settings <box_space-session_settings>` "
#~ "system table is TRUE, then result "
#~ "set metadata may include these things"
#~ " in addition to ``name`` and "
#~ "``type``: |br| * ``collation`` (present "
#~ "only if COLLATE clause is specified "
#~ "for a STRING) = :ref:`\"Collation\" "
#~ "<index-collation>`. |br| * ``is_nullable`` "
#~ "(present only if the :ref:`select list"
#~ " <sql_select_list>` specified a base table"
#~ " column and nothing else) = false "
#~ "if column was defined as :ref:`NOT "
#~ "NULL <sql_nulls>`, otherwise true. If "
#~ "this is not present, that implies "
#~ "that nullability is unknown. |br| * "
#~ "``is_autoincrement`` (present only if the "
#~ "select list specified a base table "
#~ "column and nothing else) = true if"
#~ " column was defined as :ref:`PRIMARY "
#~ "KEY AUTOINCREMENT <sql_table_constraint_def>`, "
#~ "otherwise false. |br| * ``span`` (always"
#~ " present) = the original expression "
#~ "in a select list, which will often"
#~ " be the same as ``name`` if the"
#~ " select list specifies a column name"
#~ " and nothing else, but otherwise will"
#~ " differ, for example after ``SELECT "
#~ "x+55 AS x FROM t;`` the ``name``"
#~ " is X and the ``span`` is x+55."
#~ " If ``span`` and ``name`` are the "
#~ "same then the content is MP_NIL."
#~ msgstr ""

#~ msgid ""
#~ "If ``box.prepare`` succeeds, prepared_table "
#~ "contains: |br| ``stmt_id``: integer -- "
#~ "an identifier generated by a hash "
#~ "of the statement string |br| "
#~ "``execute``: function |br| ``params``: map "
#~ "[name : string, type : string] --"
#~ " parameter descriptions |br| ``unprepare``: "
#~ "function |br| ``metadata``: map [name :"
#~ " string, type : string] (This is "
#~ "present only for SELECT or PRAGMA "
#~ "statements and has the same contents "
#~ "as the :ref:`result set metadata "
#~ "<box-sql_result_sets>` for ``box.execute``) |br|"
#~ " ``param_count``: integer -- number of "
#~ "parameters |br| This can be used "
#~ "by :ref:`prepared_table:execute() <box-"
#~ "sql_box_execute_prepared_statement>` and by "
#~ ":ref:`prepared_table:unprepare() <box-"
#~ "sql_box_unprepare_prepared_statement>`."
#~ msgstr ""
