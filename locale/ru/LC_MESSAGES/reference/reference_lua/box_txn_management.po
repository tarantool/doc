
msgid "Functions for transaction management"
msgstr "Управление экземплярами"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"For general information and examples, see section :ref:`Transaction "
"control <atomic-atomic_execution>`."
msgstr ""
"Чтобы получить общую информацию и взглянуть на примеры использования, см."
" раздел :ref:`Управление транзакциями <atomic-atomic_execution>`."

msgid "Observe the following rules when working with transactions:"
msgstr "Соблюдайте следующие правила в работе с транзакциями:"

msgid "Rule #1"
msgstr "Правило #1"

msgid ""
"The requests in a transaction must be sent to a server as a single block."
" It is not enough to enclose them between begin and commit or rollback. "
"To ensure they are sent as a single block: put them in a function, or put"
" them all on one line, or use a delimiter so that multi-line requests are"
" handled together."
msgstr ""
"Запросы в транзакции должны отправляться на сервер в виде единого блока. "
"Недостаточно просто размещать их между началом транзакции и коммитом или "
"откатом. Чтобы убедиться, что они отправляются в виде единого блока: "
"поместите их в функцию, поместите их на одну строку или используйте "
"символы-разделители, чтобы многостроковые запросы обрабатывались "
"совместно."

msgid "Rule #2"
msgstr "Правило #2"

msgid ""
"All database operations in a transaction should use the same storage "
"engine. It is not safe to access tuple sets that are defined with "
"``{engine='vinyl'}`` and also access tuple sets that are defined with "
"``{engine='memtx'}``, in the same transaction."
msgstr ""
"Все операции с базой данных в рамках транзакции должны работать с одним "
"движком баз данных. Небезопасно в рамках одной транзакции получать доступ"
" к наборам кортежей, которые определяются по ``{engine='vinyl'}``, а "
"также к наборам кортежей, которые определяются по ``{engine='memtx'}``."

msgid "Rule #3"
msgstr "Правило #3"

#, fuzzy
msgid ""
"Requests which cause changes to the data definition -- create, alter, "
"drop, truncate -- are only allowed with Tarantool version 2.1 or later. "
"Data-definition requests which change an index or change a format, such "
"as :ref:`space_object:create_index() <box_schema-sequence_create_index>` "
"and :ref:`space_object:format() <box_space-format>`, are not allowed "
"inside transactions except as the first request after ``box.begin()``."
msgstr ""
"Нельзя использовать запросы, которые могут приводить к изменению "
"определения данных -- создание, изменение, удаление, очистка."

msgid "Index"
msgstr "Индекс"

msgid "Below is a list of all functions for transaction management."
msgstr "Ниже приведен перечень всех функций для управления транзакциями."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Использование"

msgid ":ref:`box.begin() <box-begin>`"
msgstr ":ref:`box.begin() <box-begin>`"

msgid "Begin the transaction"
msgstr "Начало транзакции"

msgid ":ref:`box.commit() <box-commit>`"
msgstr ":ref:`box.commit() <box-commit>`"

msgid "End the transaction and save all changes"
msgstr "Окончание транзакции и сохранение всех изменений"

msgid ":ref:`box.rollback() <box-rollback>`"
msgstr ":ref:`box.rollback() <box-rollback>`"

msgid "End the transaction and discard all changes"
msgstr "Окончание транзакции и отмена всех изменений"

msgid ":ref:`box.savepoint() <box-savepoint>`"
msgstr ":ref:`box.savepoint() <box-savepoint>`"

msgid "Get a savepoint descriptor"
msgstr "Получение дескриптора точки сохранения"

msgid ":ref:`box.rollback_to_savepoint() <box-rollback_to_savepoint>`"
msgstr ":ref:`box.rollback_to_savepoint() <box-rollback_to_savepoint>`"

msgid "Do not end the transaction and discard all changes made after a savepoint"
msgstr ""
"Запрещение окончания транзакции и отмена всех изменений, сделанных после "
"точки сохранения"

msgid ":ref:`box.atomic() <box-atomic>`"
msgstr ":ref:`box.atomic() <box-atomic>`"

msgid "Execute a function, treating it as a transaction"
msgstr "Выполнение функции как транзакции"

msgid ":ref:`box.on_commit() <box-on_commit>`"
msgstr ":ref:`box.on_commit() <box-on_commit>`"

msgid "Define a trigger that will be activated by box.commit"
msgstr "Определение триггера, активируемого по ``box.commit``"

msgid ":ref:`box.on_rollback() <box-on_rollback>`"
msgstr ":ref:`box.on_rollback() <box-on_rollback>`"

msgid "Define a trigger that will be activated by box.rollback"
msgstr "Определение триггера, активируемого по ``box.rollback``"

msgid ":ref:`box.is_in_txn() <box-is_in_txn>`"
msgstr ":ref:`box.is_in_txn() <box-is_in_txn>`"

msgid "State whether a transaction is in progress"
msgstr "Обозначение наличия активной транзакции"

msgid ""
"Begin the transaction. Disable :ref:`implicit yields <atomic-implicit-"
"yields>` until the transaction ends. Signal that writes to the :ref"
":`write-ahead log <internals-wal>` will be deferred until the transaction"
" ends. In effect the fiber which executes ``box.begin()`` is starting an "
"\"active multi-request transaction\", blocking all other fibers."
msgstr ""
"Начало транзакции. Отключение :ref:`неявной передачи управления <atomic-"
"implicit-yields>` до окончания транзакции. Сигнал о записи в :ref:`журнал"
" упреждающей записи <internals-wal>` будет задержан до окончания "
"транзакции. Фактически файбер, который выполняет функцию ``box.begin()``,"
" начинает \"активную транзакцию со множеством запросов\" с блокировкой "
"всех остальных файберов."

msgid ""
"**Possible errors:** error if this operation is not permitted because "
"there"
msgstr ""
"**Возможные ошибки:** ошибка, если такая операция не допускается, потому "
"что"

msgid ""
"is already an active transaction. error if for some reason memory cannot "
"be allocated."
msgstr ""
"уже есть активная транзакция. ошибка, если по какой-либо причине нельзя "
"выделить память."

msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""
"Окончание транзакции и применение результатов всех операций по изменению "
"данных."

msgid ""
"**Possible errors:**  error and abort the transaction in case of a "
"conflict."
msgstr "**Возможные ошибки:** ошибка и прерывание транзакции в случае конфликта."

msgid ""
"error if the operation fails to write to disk. error if for some reason "
"memory cannot be allocated."
msgstr ""
"ошибка, если операция не может выполнить запись на диск. ошибка, если по "
"какой-либо причине нельзя выделить память."

msgid ""
"End the transaction, but cancel all its data-change operations. An "
"explicit call to functions outside ``box.space`` that always yield, such "
"as :ref:`fiber.sleep() <fiber-sleep>` or :ref:`fiber.yield() <fiber-"
"yield>`, will have the same effect."
msgstr ""
"Окончание транзакции, но отмена результатов всех операций по изменению "
"данных. Явный вызов функций не из модуля ``box.space``, которые всегда "
"передают управление, например :ref:`fiber.sleep() <fiber-sleep>` или "
":ref:`fiber.yield() <fiber-yield>`, приведет к тому же результату."

msgid ""
"Return a descriptor of a savepoint (type = table), which can be used "
"later by :ref:`box.rollback_to_savepoint(savepoint) <box-"
"rollback_to_savepoint>`. Savepoints can only be created while a "
"transaction is active, and they are destroyed when a transaction ends."
msgstr ""
"Возврат дескриптора точки сохранения (тип = таблица), который может затем"
" использоваться в :ref:`box.rollback_to_savepoint(savepoint) <box-"
"rollback_to_savepoint>`. Точки сохранения могут быть созданы, пока "
"активна транзакция, и удаляются после окончания транзакции."

msgid "return"
msgstr "возвращается"

msgid "savepoint table"
msgstr "таблица точки сохранения"

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "Lua object"
msgstr "Lua-объект"

msgid "error if the savepoint cannot be set in absence of active transaction."
msgstr ""
"ошибка, если точку сохранения нельзя указать в отсутствие активной "
"транзакции."

msgid "**Possible errors:** error if for some reason memory cannot be allocated."
msgstr ""
"**Возможные ошибки:** ошибка, если по какой-либо причине нельзя выделить "
"память."

msgid ""
"Do not end the transaction, but cancel all its data-change and "
":ref:`box.savepoint() <box-savepoint>` operations that were done after "
"the specified savepoint."
msgstr ""
"Запрещение окончания транзакции, но отмена всех изменений и операций "
":ref:`box.savepoint() <box-savepoint>`, сделанных после точки сохранения."

msgid "**Possible errors:** error if the savepoint does not exist."
msgstr "**Возможные ошибки:** ошибка, если отсутствует точка сохранения."

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"function f()\n"
"  box.begin()           -- start transaction\n"
"  box.space.t:insert{1} -- this will not be rolled back\n"
"  local s = box.savepoint()\n"
"  box.space.t:insert{2} -- this will be rolled back\n"
"  box.rollback_to_savepoint(s)\n"
"  box.commit()          -- end transaction\n"
"end"
msgstr ""
"function f()\n"
"  box.begin()           -- начало транзакции\n"
"  box.space.t:insert{1} -- это не отменится\n"
"  local s = box.savepoint()\n"
"  box.space.t:insert{2} -- это отменится\n"
"  box.rollback_to_savepoint(s)\n"
"  box.commit()          -- конец транзакции\n"
"end"

msgid ""
"Execute a function, acting as if the function starts with an implicit "
":ref:`box.begin() <box-begin>` and ends with an implicit "
":ref:`box.commit() <box-commit>` if successful, or ends with an implicit "
":ref:`box.rollback() <box-rollback>` if there is an error."
msgstr ""
"Выполнение функции так, как будто функция начинается с явного вызова "
":ref:`box.begin() <box-begin>` и заканчивается неявным вызовом "
":ref:`box.commit() <box-commit>` после успешного выполнения или же "
"заканчивается неявным вызовом :ref:`box.rollback() <box-rollback>` в "
"случае ошибки."

msgid "the result of the function passed to ``atomic()`` as an argument."
msgstr "результат функции передается в ``atomic()`` в качестве аргумента."

msgid "**Possible errors:** any error that :ref:`box.begin() <box-begin>` and"
msgstr ""
"**Возможные ошибки:** любая ошибка, которую могут вызвать "
":ref:`box.begin() <box-begin>`"

msgid ":ref:`box.commit() <box-commit>` can return."
msgstr "и :ref:`box.commit() <box-commit>`."

msgid ""
"Define a trigger for execution when a transaction ends due to an event "
"such as :ref:`box.commit <box-commit>`."
msgstr ""
"Определения триггера, выполняемого в случае окончания транзакции в связи "
"с :ref:`box.commit <box-commit>`."

msgid ""
"The trigger function may take an iterator parameter, as described in an "
"example for this section."
msgstr ""
"Функция с триггером может принимать параметр с итератором, как описано в "
"примере к данному разделу."

msgid "The trigger function should not access any database spaces."
msgstr "Функция с триггером не должна получать доступ к любым спейсам базы данных."

msgid ""
"If the trigger execution fails and raises an error, the effect is severe "
"and should be avoided -- use Lua's ``pcall()`` mechanism around code that"
" might fail."
msgstr ""
"Если триггер не сработает и выдаст ошибку, результат будет "
"неблагоприятным, чего следует избегать -- используйте Lua-механизм "
"``pcall()`` вокруг кода, который может не сработать."

msgid ""
"``box.on_commit()`` must be invoked within a transaction, and the trigger"
" ceases to exist when the transaction ends."
msgstr ""
"``box.on_commit()`` следует вызывать в пределах транзакции, и триггер "
"прекращает существование по окончании транзакции."

msgid "Parameters"
msgstr "Параметры"

msgid "function which will become the trigger function"
msgstr "функция, в которой будет триггер"

msgid "existing trigger function which will be replaced by trigger-function"
msgstr "существующая функция с триггером, которую заменит новая"

msgid "nil or function pointer"
msgstr "nil или указатель функции"

msgid ""
"If the parameters are ``(nil, old-trigger-function)``, then the old "
"trigger is deleted."
msgstr ""
"Если указаны параметры ``(nil, old-trigger-function)``, старый триггер "
"будет удален."

msgid ""
"Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""
"Подробная информация о характеристиках триггера находится в разделе "
":ref:`Триггеры <triggers-box_triggers>`."

msgid "**Simple and useless example:** this will display 'commit happened':"
msgstr "**Простой и бесполезный пример:** покажет, что произошел коммит:"

msgid ""
"function f()\n"
"function f() print('commit happened') end\n"
"box.begin() box.on_commit(f) box.commit()"
msgstr ""
"function f()\n"
"function f() print('commit happened') end\n"
"box.begin() box.on_commit(f) box.commit()"

msgid ""
"But of course there is more to it: the function parameter can be an "
"ITERATOR."
msgstr "Но, конечно, это еще не всё: параметр функции может быть ИТЕРАТОРОМ."

msgid ""
"The iterator goes through the effects of every request that changed a "
"space during the transaction."
msgstr ""
"Итератор проходит по результатам каждого запроса изменения спейса в "
"пределах транзакции."

msgid "The iterator will have:"
msgstr "Итератор будет содержать:"

msgid "an ordinal request number,"
msgstr "порядковый номер запроса,"

msgid ""
"the old value of the tuple before the request (this will be nil for an "
"insert request),"
msgstr ""
"старое значение кортежа до запроса (для запросов вставки это будет "
"нулевое значение nil),"

msgid ""
"the new value of the tuple after the request (this will be nil for a "
"delete request),"
msgstr ""
"новое значение кортежа после запроса (для запросов удаления это будет "
"нулевое значение nil),"

msgid "and the id of the space."
msgstr "и идентификатор спейса."

msgid ""
"**Less simple more useful example:** this will display the effects of two"
" replace requests:"
msgstr ""
"**Более сложный и более полезный пример:** покажет результат двух "
"запросов замены:"

msgid ""
"box.space.test:drop()\n"
"s = box.schema.space.create('test')\n"
"i = box.space.test:create_index('i')\n"
"function f(iterator)\n"
"  for request_number, old_tuple, new_tuple, space_id in iterator() do\n"
"    print('request_number ' .. tostring(request_number))\n"
"    print('  old_tuple ' .. tostring(old_tuple[1]) .. ' ' .. "
"old_tuple[2])\n"
"    print('  new_tuple ' .. tostring(new_tuple[1]) .. ' ' .. "
"new_tuple[2])\n"
"    print('  space_id ' .. tostring(space_id))\n"
"  end\n"
"end\n"
"s:insert{1,'-'}\n"
"box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f) "
"box.commit()"
msgstr ""
"box.space.test:drop()\n"
"s = box.schema.space.create('test')\n"
"i = box.space.test:create_index('i')\n"
"function f(iterator)\n"
"  for request_number, old_tuple, new_tuple, space_id in iterator() do\n"
"    print('request_number ' .. tostring(request_number))\n"
"    print('  old_tuple ' .. tostring(old_tuple[1]) .. ' ' .. "
"old_tuple[2])\n"
"    print('  new_tuple ' .. tostring(new_tuple[1]) .. ' ' .. "
"new_tuple[2])\n"
"    print('  space_id ' .. tostring(space_id))\n"
"  end\n"
"end\n"
"s:insert{1,'-'}\n"
"box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f) "
"box.commit()"

msgid "The result will look like this:"
msgstr "Результат будет выглядеть следующим образом:"

msgid ""
"tarantool> box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f)"
" box.commit()\n"
"request_number 1\n"
"  old_tuple 1 -\n"
"  new_tuple 1 x\n"
"  space_id 517\n"
"request_number 2\n"
"  old_tuple 1 x\n"
"  new_tuple 1 y\n"
"  space_id 517"
msgstr ""
"tarantool> box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f)"
" box.commit()\n"
"request_number 1\n"
"  old_tuple 1 -\n"
"  new_tuple 1 x\n"
"  space_id 517\n"
"request_number 2\n"
"  old_tuple 1 x\n"
"  new_tuple 1 y\n"
"  space_id 517"

msgid ""
"Define a trigger for execution when a transaction ends due to an event "
"such as :ref:`box.rollback <box-rollback>`."
msgstr ""
"Определение триггера, выполняемого по окончании транзакции в связи с "
":ref:`box.rollback <box-rollback>`."

msgid ""
"The parameters and warnings are exactly the same as for :ref:`box.on-"
"commit <box-on_commit>`."
msgstr ""
"Используются точно такие же параметры и предупреждения, как в :ref:`box"
".on-commit <box-on_commit>`."

msgid ""
"If a transaction is in progress (for example the user has called "
":ref:`box.begin <box-begin>` and has not yet called either "
":ref:`box.commit <box-commit>` or :ref:`box.rollback <box-rollback>`, "
"return ``true``. Otherwise return ``false``."
msgstr ""
"В процессе транзакции (например, пользователь вызвал :ref:`box.begin "
"<box-begin>` и еще не вызвал ни :ref:`box.commit <box-commit>`, ни "
":ref:`box.rollback <box-rollback>`) возвращается ``true``. В остальных "
"случаях возвращается ``false``."
