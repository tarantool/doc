msgid ""
msgstr ""
"Plural-Forms: nplurals=4; plural=((n%10==1 && n%100!=11) ? 0 : ((n%10 >= 2 && n%10 <=4 && (n%100 < 12 || n%100 > 14)) ? 1 : ((n%10 == 0 || (n%10 >= 5 && n%10 <=9)) || (n%100 >= 11 && n%100 <= 14)) ? 2 : 3));\n"
"X-Crowdin-Project: tarantool-docs\n"
"X-Crowdin-Project-ID: 442986\n"
"X-Crowdin-Language: ru\n"
"X-Crowdin-File: /en/reference/reference_lua/buffer.pot\n"
"X-Crowdin-File-ID: 1470\n"
"Project-Id-Version: tarantool-docs\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language-Team: Russian\n"
"Language: ru_RU\n"
"PO-Revision-Date: 2021-04-23 11:58\n"

msgid "Module `buffer`"
msgstr "Модуль `buffer`"

msgid "The ``buffer`` module returns a dynamically resizable buffer which is solely for optional use by methods of the :ref:`net.box module <net_box-module>` or the :ref:`msgpack module <msgpack-module>`."
msgstr "Модуль ``buffer`` возвращает буфер, допускающий динамическое изменение размера, который используется только в качестве опции для методов :ref:`модуля net.box <net_box-module>` или :ref:`модуля msgpack <msgpack-module>`."

msgid "Ordinarily the ``net.box`` methods return a Lua table. If a ``buffer`` option is used, then the ``net.box`` methods return a :ref:`raw MsgPack string <msgpack-definitions>`. This saves time on the server, if the client application has its own routine for decoding raw MsgPack strings."
msgstr "Как правило, модуль ``net.box`` возвращает Lua-таблицу. Если используется опция ``buffer``, то методы модуля ``net.box`` возвращают неформатированную строку :ref:`строку MsgPack <msgpack-definitions>`. Это экономит время работы на сервере, если в клиентском приложении есть собственная процедура декодирования MsgPack-строк."

msgid "The buffer uses four pointers to manage its capacity:"
msgstr "Буфер использует четыре указателя для управления его мощностью:"

msgid "``buf`` -- a pointer to the beginning of the buffer"
msgstr "``buf`` -- указатель на начало буфера"

msgid "``rpos`` -- a pointer to the beginning of the range; available for reading data (\"read position\")"
msgstr "``rpos`` -- указатель на начало участка памяти, доступного для чтения данных (\"read position\")"

msgid "``wpos`` -- a pointer to the end of the range; available for reading data, and to the beginning of the range for writing new data (\"write position\")"
msgstr "``wpos`` -- указатель на конец участка памяти для чтения и начало участка для записи данных (\"write position\")"

msgid "``epos`` -- a pointer to the end of the range; available for writing new data (\"end position\")"
msgstr "``epos`` -- указатель на конец участка для записи данных (\"end position\")"

msgid "Create a new buffer."
msgstr "Создать новый буфер."

msgid "**Example:**"
msgstr "**Пример:**"

msgid "In this example we will show that using buffer allows you to keep the data in the format that you get from the server. So if you get the data only for sending it somewhere else, buffer fastens this a lot."
msgstr "В этом примере мы покажем, что использование буфера позволит вам сохранить данные в том же формате, в котором они пришли с сервера. Так что если получить данные с сервера нужно только для отправки куда-то дальше, то с буфером это будет гораздо быстрее."

msgid "box.cfg{listen = 3301}\n"
"buffer = require('buffer')\n"
"net_box = require('net.box')\n"
"msgpack = require('msgpack')\n\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary')\n"
"box.space.tester:insert({1, 'ABCDE', 12345})\n\n"
"box.schema.user.create('usr1', {password = 'pwd1'})\n"
"box.schema.user.grant('usr1', 'read,write,execute', 'space', 'tester')\n\n"
"ibuf = buffer.ibuf()\n\n"
"conn = net_box.connect('usr1:pwd1@localhost:3301')\n"
"conn.space.tester:select({}, {buffer=ibuf})\n\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""

msgid "The result of the final request looks like this:"
msgstr "Результат последнего запроса выглядит следующим образом:"

msgid "tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."
msgstr "tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."

msgid "Before Tarantool version 1.7.7, the function to use for this case is ``msgpack.ibuf_decode(ibuf.rpos)``. Starting with Tarantool version 1.7.7, ``ibuf_decode`` is deprecated."
msgstr "До версии 1.7.7 Tarantool'а в данном случае следует использовать функцию ``msgpack.ibuf_decode(ibuf.rpos)``. Начиная с версии  1.7.7 Tarantool'а , ``ibuf_decode`` объявлена устаревшей."

msgid "Allocate ``size`` bytes for ``buffer_object``."
msgstr "Аллоцировать ``size`` байтов для ``buffer_object``'а."

msgid "Parameters"
msgstr "Параметры"

msgid "memory in bytes to allocate"
msgstr "количество байтов для аллоцирования"

msgid "return"
msgstr "возвращает"

msgid "``wpos``"
msgstr ""

msgid "Return the capacity of the ``buffer_object``."
msgstr "Вернуть мощность ``buffer_object``'а."

msgid "``epos - buf``"
msgstr ""

msgid "Check if ``size`` bytes are available for reading in ``buffer_object``."
msgstr "Проверить, доступно ли ``size`` байтов для чтения из ``buffer_object``'а."

msgid "memory in bytes to check"
msgstr "память в байтах для проверки"

msgid "``rpos``"
msgstr ""

msgid "Return the size of the range occupied by data."
msgstr "Вернуть размер участка, занятого данными."

msgid "``rpos - buf``"
msgstr ""

msgid "Read ``size`` bytes from buffer."
msgstr "Прочитать ``size`` байтов из буфера."

msgid "Clear the memory slots allocated by ``buffer_object``."
msgstr "Очистить слоты памяти, выделенные для ``buffer_object``'а."

msgid "tarantool> ibuf:recycle()\n"
"---\n"
"...\n"
"tarantool> ibuf.buf, ibuf.rpos, ibuf.wpos, ibuf.epos\n"
"---\n"
"- 'cdata<char *>: NULL'\n"
"- 'cdata<char *>: NULL'\n"
"- 'cdata<char *>: NULL'\n"
"- 'cdata<char *>: NULL'\n"
"..."
msgstr ""

msgid "Clear the memory slots used by ``buffer_object``. This method allows to keep the buffer but remove data from it. It is useful when you want to use the buffer further."
msgstr "Очистить слоты памяти, использованные ``buffer_object``'ом. Этот метод позволяет сохранить буфер, но убрать из него все данные. Это полезно, если вы собираетесь использовать буфер дальше."

msgid "tarantool> ibuf:reset()\n"
"---\n"
"...\n"
"tarantool> ibuf.buf, ibuf.rpos, ibuf.wpos, ibuf.epos\n"
"---\n"
"- 'cdata<char *>: 0x010cc28030'\n"
"- 'cdata<char *>: 0x010cc28030'\n"
"- 'cdata<char *>: 0x010cc28030'\n"
"- 'cdata<char *>: 0x010cc2c000'\n"
"..."
msgstr ""

msgid "Reserve memory for ``buffer_object``. Check if there is enough memory to write ``size`` bytes after ``wpos``. If not, ``epos`` shifts until ``size`` bytes will be available."
msgstr "Зарезервировать память для ``buffer_object``. Проверить, достаточно ли памяти, чтобы записать ``size`` байтов после ``wpos``. Если нет, ``epos`` будет сдвигаться, пока ``size`` байтов не будет доступно."

msgid "Return a range, available for reading data."
msgstr "Вернуть участок, доступный для чтения данных."

msgid "``wpos - rpos``"
msgstr ""

msgid "Return a range for writing data."
msgstr "Вернуть участок, доступный для записи данных."

msgid "``epos - wpos``"
msgstr ""

msgid "**Module buffer and skip_header**"
msgstr "**Модуль buffer и skip_header**"

msgid "The example in the previous section"
msgstr "В примере из предыдущего раздела"

msgid "showed that, ordinarily, the response from net.box includes a header -- 48 (hexadecimal 30) that is the :ref:`key <internals-unified_packet_structure>` for IPROTO_DATA. But in some situations, for example when passing the buffer to a C function that expects a MsgPack byte array without a header, the header can be skipped. This is done by specifying ``skip_header=true`` as an option to :ref:`conn.space.space-name:select{...} <conn-select>` or :ref:`conn.space.space-name:insert{...} <conn-insert>` or :ref:`conn.space.space-name:replace{...} <conn-replace>` or :ref:`conn.space.space-name:update{...} <conn-update>` or :ref:`conn.space.space-name:upsert{...} <conn-upsert>` or :ref:`conn.space.space-name:delete{...} <conn-delete>`. The default is ``skip_header=false``."
msgstr "было показано, что обычно net.box ответ включает в себя заголовок -- 48 (в шестнадцатиричной системе -- 30), который является :ref:`ключом <internals-unified_packet_structure>` для IPROTO_DATA. Но в некоторых ситуациях, например, при передаче буфера в функцию C, которая ожидает массив байт MsgPack без заголовка, заголовок можно пропустить. Это делается путем указания ``skip_header=true`` в качестве опции :ref:`conn.space.space-name:select{...} <conn-select>` или :ref:`conn.space.space-name:insert{...} <conn-insert>` или :ref:`conn.space.space-name:replace{...} <conn-replace>` или :ref:`conn.space.space-name:update{...} <conn-update>` или :ref:`conn.space.space-name:upsert{...} <conn-upsert>` или :ref:`conn.space.space-name:delete{...} <conn-delete>`. По умолчанию ``skip_header=false``."

msgid "Now here is the end of the same example, except that ``skip_header=true`` is used."
msgstr "Ниже приведен конец того же примера, но с использованием ``skip_header=true``."

msgid "ibuf = buffer.ibuf()\n\n"
"conn = net_box.connect('usr1:pwd1@localhost:3301')\n"
"conn.space.tester:select({}, {buffer=ibuf, skip_header=true})\n\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""

msgid "tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- [['ABCDE', 12345]]\n"
"- 'cdata<char *>: 0x7f8fd102803f'\n"
"..."
msgstr "tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."

msgid "Notice that the IPROTO_DATA header (48) is gone."
msgstr "Заметьте, что заголовок IPROTO_DATA (48) ушел."

msgid "The result is still inside an array, as is clear from the fact that it is shown inside square brackets. It is possible to skip the array header too, with :ref:`msgpack.decode_array_header() <msgpack-decode_array_header>`."
msgstr "Результат остается внутри массива, что видно из того, что он заключен в квадратные скобки. Пропустить заголовок массива можно и функцией ``msgpack.decode_array_header()``."

