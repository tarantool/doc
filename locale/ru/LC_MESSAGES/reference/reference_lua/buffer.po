# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-06 15:48+0000\n"
"PO-Revision-Date: 2019-12-06 16:16+0300\n"
"Last-Translator: \n"
"Language: ru\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

msgid "Module `buffer`"
msgstr "Модуль `buffer`"

msgid ""
"The ``buffer`` module returns a dynamically resizable buffer which is "
"solely for use as an option for methods of the :ref:`net.box module "
"<net_box-module>`."
msgstr ""
"Модуль ``buffer`` возвращает буфер, допускающий динамическое изменение "
"размера, который используется только в качестве опции для методов "
":ref:`модуля net.box <net_box-module>`."

msgid ""
"Ordinarily the ``net.box`` methods return a Lua table. If a ``buffer`` "
"option is used, then the ``net.box`` methods return a raw MsgPack_ "
"string. This saves time on the server, if the client application has its "
"own routine for decoding MsgPack strings."
msgstr ""
"Как правило, модуль ``net.box`` возвращает Lua-таблицу. Если используется"
" опция ``buffer``, то методы модуля ``net.box`` возвращают "
"неформатированную строку MsgPack_. Это экономит время работы на сервере, "
"если в клиентском приложении есть собственная процедура декодирования "
"MsgPack-строк."

msgid "return"
msgstr "возвращает"

msgid "a descriptor of a buffer."
msgstr "дескриптор буфера."

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "cdata"
msgstr "cdata."

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"Assume a Tarantool server is listening on farhost:3301. Assume it has a "
"space ``T`` with one tuple: ``'ABCDE', 12345``. In this example we start "
"up a server on localhost:3302 and then use ``net.box`` routines to "
"connect to farhost. Then we create a buffer, and use it as an option for "
"a ``conn.space...select()`` call. The result will be in MsgPack_ format. "
"To show this, we will use :ref:`msgpack.decode_unchecked() <msgpack-"
"decode_unchecked>` on ``ibuf.rpos`` (the \"read position\" of the "
"buffer). Thus we do not decode on the remote server, but we do decode on "
"the local server."
msgstr ""
"Предположим, что Tarantool-сервер настроен на прослушивание на "
"farhost:3301. Предположим, что на нем есть спейс ``T`` с одним кортежем: "
"``'ABCDE', 12345``. В данном примере запустим сервер на localhost:3302, а"
" затем используем процедуры ``net.box`` для подключения к farhost. Затем "
"создадим буфер и используем его как опцию для вызова "
"``conn.space...select()``. Результат получим в формате MsgPack_. Чтобы "
"показать это, используем :ref:`msgpack.decode_unchecked() <msgpack-"
"decode_unchecked>` на ``ibuf.rpos`` (\"позиция для чтения\" в буфере). "
"Таким образом, мы проведем декодирование не на удаленном сервере, а на "
"локальном."

msgid ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"

msgid "The result of the final request looks like this:"
msgstr "Результат последнего запроса выглядит следующим образом:"

msgid ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."
msgstr ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."

msgid ""
"Before Tarantool version 1.7.7, the function to use for this case is "
"``msgpack.ibuf_decode(ibuf.rpos)``. Starting with Tarantool version "
"1.7.7, ``ibuf_decode`` is deprecated."
msgstr ""
"До версии 1.7.7 Tarantool'а в данном случае следует использовать функцию "
"``msgpack.ibuf_decode(ibuf.rpos)``. Начиная с версии  1.7.7 Tarantool'а ,"
" ``ibuf_decode`` объявлена устаревшей."

msgid "**Module buffer and skip-header**"
msgstr ""

msgid "The example in the previous section"
msgstr ""

msgid ""
"showed that, ordinarily, the response from net.box includes a header -- "
"48 (hexadecimal 30) is the :ref:`key <internals-"
"unified_packet_structure>` for IPROTO_DATA. But in some situations, for "
"example when passing the buffer to a C function that expects a MsgPack "
"byte array without a header, the header can be skipped. This is done by "
"specifying ``skip-header=true`` as an option to :ref:`conn.space.space-"
"name:select{...} <conn-select>` or :ref:`conn.space.space-"
"name:insert{...} <conn-insert>` or :ref:`conn.space.space-"
"name:replace{...} <conn-replace>` or :ref:`conn.space.space-"
"name:update{...} <conn-update>` or :ref:`conn.space.space-"
"name:upsert{...} <conn-upsert>` or :ref:`conn.space.space-"
"name:delete{...} <conn-delete>`. The default is ``skip-header=false``."
msgstr ""

msgid "Now here is the same example, except that ``skip_header=true`` is used."
msgstr ""

#, fuzzy
msgid ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf, skip_header=true})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"

#, fuzzy
msgid ""
"tarantool>         msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- [['ABCDE', 12345]]\n"
"- 'cdata<char *>: 0x7f8fd102803f'\n"
"..."
msgstr ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."

msgid "Notice that the IPROTO_DATA header (48) is gone."
msgstr ""

msgid ""
"The result is still inside an array, as is clear from the fact that it is"
" shown inside square brackets. It is possible to skip the array header "
"too, with :ref:`msgpack.decode_array_header() <msgpack-"
"decode_array_header>`."
msgstr ""
