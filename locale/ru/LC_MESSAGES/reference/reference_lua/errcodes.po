
msgid "Database error codes"
msgstr "Коды ошибок базы данных"

msgid ""
"In the current version of the binary protocol, error messages, which are "
"normally more descriptive than error codes, are not present in server "
"responses. The actual message may contain a file name, a detailed reason "
"or operating system error code. All such messages, however, are logged in"
" the error log. Below are general descriptions of some popular codes. A "
"complete list of errors can be found in file `errcode.h`_ in the source "
"tree."
msgstr ""
"В текущей версии бинарного протокола в ответы сервера не включены "
"сообщения об ошибках, которые как правило, содержат больше информации, "
"чем коды ошибок. Само сообщение может содержать имя файла, подробное "
"описание причины или код ошибки операционной системы. Однако все такие "
"сообщения регистрируются в журнале ошибок. Ниже приведены общие описания "
"некоторых распространенных кодов. Полный список ошибок можно найти в "
"файле `errcode.h`_ в исходном дереве."

msgid "**List of error codes**"
msgstr "**Список кодов ошибок**"

msgid "ER_NONMASTER"
msgstr "ER_NONMASTER"

msgid ""
"(In replication) A server instance cannot modify data unless it is a "
"master."
msgstr ""
"(Репликация) Экземпляр сервера не может вносить изменения в данные, если "
"он не является мастером."

msgid "ER_ILLEGAL_PARAMS"
msgstr "ER_ILLEGAL_PARAMS"

msgid "Illegal parameters. Malformed protocol message."
msgstr "Недопустимые параметры. Некорректное протокольное сообщение."

msgid "ER_MEMORY_ISSUE"
msgstr "ER_MEMORY_ISSUE"

msgid ""
"Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has "
"been reached."
msgstr ""
"Нехватка оперативной памяти: достижение предела памяти :ref:`memtx_memory"
" <cfg_storage-memtx_memory>`."

msgid "ER_WAL_IO"
msgstr "ER_WAL_IO"

msgid ""
"Failed to write to disk. May mean: failed to record a change in the "
"write-ahead log. Some sort of disk error."
msgstr ""
"Запись на диск не удалась. Может означать, что не удалось записать "
"изменение в журнале упреждающей записи. Некоторая ошибка на диске."

msgid "ER_KEY_PART_COUNT"
msgstr "ER_KEY_PART_COUNT"

msgid "Key part count is not the same as index part count"
msgstr "Количество частей ключа не совпадает с количеством частей индекса"

msgid "ER_NO_SUCH_SPACE"
msgstr "ER_NO_SUCH_SPACE"

msgid "The specified space does not exist."
msgstr "Указанный спейс отсутствует."

msgid "ER_NO_SUCH_INDEX"
msgstr "ER_NO_SUCH_INDEX"

msgid "The specified index in the specified space does not exist."
msgstr "Указанного индекса нет в указанном спейсе."

msgid "ER_PROC_LUA"
msgstr "ER_PROC_LUA"

msgid "An error occurred inside a Lua procedure."
msgstr "Возникла ошибке в Lua-процедуре."

msgid "ER_FIBER_STACK"
msgstr "ER_FIBER_STACK"

msgid ""
"The recursion limit was reached when creating a new fiber. This usually "
"indicates that a stored procedure is recursively invoking itself too "
"often."
msgstr ""
"При создании нового файбера был достигнут предел рекурсии. Обычно это "
"указывает на то, что хранимая процедура слишком часто рекурсивно вызывает"
" себя."

msgid "ER_UPDATE_FIELD"
msgstr "ER_UPDATE_FIELD"

msgid "An error occurred during update of a field."
msgstr "Возникла ошибка во время обновления поля."

msgid "ER_TUPLE_FOUND"
msgstr "ER_TUPLE_FOUND"

msgid "A duplicate key exists in a unique index."
msgstr "В уникальном индексе есть повторяющийся ключ."

msgid "Handling errors"
msgstr "Обработка ошибок"

msgid ""
"Here are some procedures that can make Lua functions more robust when "
"there are errors, particularly database errors."
msgstr ""
"Ниже представлены несколько процедур для более надежного вызова "
"Lua-функций в случае ошибок, в частности, ошибок базы данных."

msgid "Invoke with pcall."
msgstr "Вызов с помощью pcall."

msgid ""
"Take advantage of Lua's mechanisms for `\"Error handling and exceptions\""
" <http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, "
"instead of simply invoking with"
msgstr ""
"Используйте механизмы Lua для `\"Обработки ошибок и исключений\" "
"<http://www.lua.org/pil/8.4.html>`_, в частности ``pcall``. То есть "
"вместо простого вызова функции с помощью"

msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ":samp:`box.space.{имя-спейса}:{имя-функции}()`"

msgid "say"
msgstr "выполните"

msgid ""
":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-"
"name}) ...`"
msgstr ""
":samp:`if pcall(box.space.{имя-спейса}.{имя-функции}, "
"box.space.{имя-спейса}) ...`"

msgid ""
"For some Tarantool box functions, pcall also returns error details "
"including a file-name and line-number within Tarantool's source code. "
"This can be seen by unpacking. For example:"
msgstr ""
"Для некоторых функций модуля box в Tarantool'е pcall также вернет "
"описание ошибки, включая имя файла и номер строки в исходном коде "
"Tarantool'а. Например:"

msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr "``x, y = pcall(function() box.schema.space.create('') end)``"

msgid "``y:unpack()``"
msgstr "``y:unpack()``"

msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""
"Чтобы увидеть применение pcall в приложении, см. практическое задание "
":ref:`Подсчет суммы по JSON-полям во всех кортежах <c_lua_tutorial-"
"sum_a_json_field>`."

msgid "Examine and raise with box.error."
msgstr "Проверка и вызов ошибки с помощью box.error."

msgid ""
"To make a new error and pass it on, the box.error module provides "
":doc:`box.error(code, errtext [, errtext ...]) "
"</reference/reference_lua/box_error/error>`."
msgstr ""
"В модуле box.error предусмотрена функция :doc:`box.error(code, errtext [,"
" errtext ...]) </reference/reference_lua/box_error/error>`, чтобы создать"
" ошибку и передать ее."

msgid ""
"To find the last error, the box.error module provides "
":doc:`/reference/reference_lua/box_error/last`. (There is also a way to "
"find the text of the last operating-system error for certain functions --"
" :ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""
"Чтобы найти последнюю ошибку, в модуле box.error предусмотрена функция "
":doc:`/reference/reference_lua/box_error/last`. (Также можно найти текст "
"последней ошибки операционной системы для определенной функции -- "
":ref:`errno.strerror([code]) <errno-strerror>`.)"

msgid "Log."
msgstr "Запись в журнал."

msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr "Записывайте сообщения в журнал с помощью :ref:`модуля log <log-module>`."

msgid ""
"And filter messages that are automatically generated, with the :ref:`log "
"<cfg_logging-log>` configuration parameter."
msgstr ""
"И отфильтровывайте автоматически созданные сообщения с помощью "
"конфигурационного параметра :ref:`log <cfg_logging-log>`."

msgid ""
"Generally, for Tarantool built-in functions which are designed to return "
"objects: the result will be an object, or nil, or `a Lua error "
"<https://www.lua.org/pil/8.3.html>`_. For example consider the "
":ref:`fio_read.lua <cookbook-fio_read>` program in our cookbook:"
msgstr ""
"Как правило, встроенные функции Tarantool'а, которые предназначены для "
"возврата объектов, вернут либо объект, либо нулевое значение nil, либо "
"`Lua-ошибку <https://www.lua.org/pil/8.3.html>`_. Например, рассмотрим "
"программу :ref:`fio_read.lua <cookbook-fio_read>` из рекомендаций по "
"разработке:"

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"

msgid ""
"After a function call that might fail, like fio.open() above, it is "
"common to see syntax like ``if not f then ...`` or ``if f == nil then "
"...``, which check for common failures. But if there had been a syntax "
"error, for example fio.opex instead of fio.open, then there would have "
"been a Lua error and f would not have been changed. If checking for such "
"an obvious error had been a concern, the programmer would probably have "
"used pcall()."
msgstr ""
"После вызова функции, который может не сработать, как fio.open() выше, "
"обычно можно увидеть такой синтаксис, как ``if not f then ...`` или ``if "
"f == nil then ...``, который проверяет на типичные отказы. Но если есть "
"ошибка синтаксиса, например, fio.opex вместо fio.open, то появится "
"Lua-ошибка, и f не изменится. Если речь идет о проверке таких очевидных "
"ошибок, программист вероятно будет использовать pcall()."

msgid ""
"All functions in Tarantool modules should work this way, unless the "
"manual explicitly says otherwise."
msgstr ""
"Все функции в модулях Tarantool'а должны работать таким образом, если в "
"руководстве явно не говорится об обратном."
