
msgid "Database error codes"
msgstr "Коды ошибок базы данных"

msgid ""
"In the current version of the binary protocol, error messages, which are "
"normally more descriptive than error codes, are not present in server "
"responses. The actual message may contain a file name, a detailed reason or "
"operating system error code. All such messages, however, are logged in the "
"error log. Below are general descriptions of some popular codes. A complete "
"list of errors can be found in file `errcode.h "
"<https://github.com/tarantool/tarantool/blob/master/src/box/errcode.h>`_ in the"
" source tree."
msgstr ""

msgid "**List of error codes**"
msgstr "**Список кодов ошибок**"

msgid "ER_NONMASTER"
msgstr "ER_NONMASTER"

msgid ""
"(In replication) A server instance cannot modify data unless it is a master."
msgstr ""
"(Репликация) Экземпляр сервера не может вносить изменения в данные, если он "
"не является мастером."

msgid "ER_ILLEGAL_PARAMS"
msgstr "ER_ILLEGAL_PARAMS"

msgid "Illegal parameters. Malformed protocol message."
msgstr "Недопустимые параметры. Некорректное протокольное сообщение."

msgid "ER_MEMORY_ISSUE"
msgstr "ER_MEMORY_ISSUE"

msgid ""
"Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has been"
" reached."
msgstr ""
"Нехватка оперативной памяти: достижение предела памяти :ref:`memtx_memory "
"<cfg_storage-memtx_memory>`."

msgid "ER_WAL_IO"
msgstr "ER_WAL_IO"

msgid ""
"Failed to write to disk. May mean: failed to record a change in the write-"
"ahead log. Some sort of disk error."
msgstr ""
"Запись на диск не удалась. Может означать, что не удалось записать изменение"
" в журнале упреждающей записи. Некоторая ошибка на диске."

msgid "ER_KEY_PART_COUNT"
msgstr "ER_KEY_PART_COUNT"

msgid "Key part count is not the same as index part count"
msgstr "Количество частей ключа не совпадает с количеством частей индекса"

msgid "ER_NO_SUCH_SPACE"
msgstr "ER_NO_SUCH_SPACE"

msgid "The specified space does not exist."
msgstr "Указанный спейс отсутствует."

msgid "ER_NO_SUCH_INDEX"
msgstr "ER_NO_SUCH_INDEX"

msgid "The specified index in the specified space does not exist."
msgstr "Указанного индекса нет в указанном спейсе."

msgid "ER_PROC_LUA"
msgstr "ER_PROC_LUA"

msgid "An error occurred inside a Lua procedure."
msgstr "Возникла ошибке в Lua-процедуре."

msgid "ER_FIBER_STACK"
msgstr "ER_FIBER_STACK"

msgid ""
"The recursion limit was reached when creating a new fiber. This usually "
"indicates that a stored procedure is recursively invoking itself too often."
msgstr ""
"При создании нового файбера был достигнут предел рекурсии. Обычно это "
"указывает на то, что хранимая процедура слишком часто рекурсивно вызывает "
"себя."

msgid "ER_UPDATE_FIELD"
msgstr "ER_UPDATE_FIELD"

msgid "An error occurred during update of a field."
msgstr "Возникла ошибка во время обновления поля."

msgid "ER_TUPLE_FOUND"
msgstr "ER_TUPLE_FOUND"

msgid "A duplicate key exists in a unique index."
msgstr "В уникальном индексе есть повторяющийся ключ."

msgid "Handling errors"
msgstr "Обработка ошибок"

msgid ""
"Here are some procedures that can make Lua functions more robust when there "
"are errors, particularly database errors."
msgstr ""
"Ниже представлены несколько процедур для более надежного вызова Lua-функций "
"в случае ошибок, в частности, ошибок базы данных."

msgid "Invoke with pcall."
msgstr "Вызов с помощью pcall."

msgid ""
"Take advantage of Lua's mechanisms for `\"Error handling and exceptions\" "
"<http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, "
"instead of simply invoking with"
msgstr ""
"Используйте механизмы Lua для `\"Обработки ошибок и исключений\" "
"<http://www.lua.org/pil/8.4.html>`_, в частности ``pcall``. То есть вместо "
"простого вызова функции с помощью"

msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ":samp:`box.space.{имя-спейса}:{имя-функции}()`"

msgid "say"
msgstr "выполните"

msgid ""
":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-"
"name}) ...`"
msgstr ""
":samp:`if pcall(box.space.{имя-спейса}.{имя-функции}, box.space.{имя-"
"спейса}) ...`"

msgid ""
"For some Tarantool box functions, pcall also returns error details including"
" a file-name and line-number within Tarantool's source code. This can be "
"seen by unpacking. For example:"
msgstr ""
"Для некоторых функций модуля box в Tarantool pcall также вернет описание "
"ошибки, включая имя файла и номер строки в исходном коде Tarantool. "
"Например:"

msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr "``x, y = pcall(function() box.schema.space.create('') end)``"

msgid "``y:unpack()``"
msgstr "``y:unpack()``"

msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""
"Чтобы увидеть применение pcall в приложении, см. практическое задание "
":ref:`Подсчет суммы по JSON-полям во всех кортежах <c_lua_tutorial-"
"sum_a_json_field>`."

msgid "Examine and raise with box.error."
msgstr "Проверка и вызов ошибки с помощью box.error."

msgid ""
"To make a new error and pass it on, the box.error module provides "
":doc:`box.error(code, errtext [, errtext ...]) "
"</reference/reference_lua/box_error/error>`."
msgstr ""
"В модуле box.error предусмотрена функция :doc:`box.error(code, errtext [, "
"errtext ...]) </reference/reference_lua/box_error/error>`, чтобы создать "
"ошибку и передать ее."

msgid ""
"To find the last error, the box.error module provides "
":doc:`/reference/reference_lua/box_error/last`. (There is also a way to find"
" the text of the last operating-system error for certain functions -- "
":ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""
"Чтобы найти последнюю ошибку, в модуле box.error предусмотрена функция "
":doc:`/reference/reference_lua/box_error/last`. (Также можно найти текст "
"последней ошибки операционной системы для определенной функции -- "
":ref:`errno.strerror([code]) <errno-strerror>`.)"

msgid "Log."
msgstr "Запись в журнал."

msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr ""
"Записывайте сообщения в журнал с помощью :ref:`модуля log <log-module>`."

msgid ""
"And filter messages that are automatically generated, with the :ref:`log "
"<cfg_logging-log>` configuration parameter."
msgstr ""
"И отфильтровывайте автоматически созданные сообщения с помощью "
"конфигурационного параметра :ref:`log <cfg_logging-log>`."

msgid ""
"Generally, for Tarantool built-in functions which are designed to return "
"objects: the result will be an object, or nil, or `a Lua error "
"<https://www.lua.org/pil/8.3.html>`_. For example consider the "
":ref:`fio_read.lua <cookbook-fio_read>` program in our cookbook:"
msgstr ""
"Как правило, встроенные функции Tarantool, которые предназначены для "
"возврата объектов, вернут либо объект, либо нулевое значение nil, либо `Lua-"
"ошибку <https://www.lua.org/pil/8.3.html>`_. Например, рассмотрим программу "
":ref:`fio_read.lua <cookbook-fio_read>` из рекомендаций по разработке:"

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"

msgid ""
"After a function call that might fail, like fio.open() above, it is common "
"to see syntax like ``if not f then ...`` or ``if f == nil then ...``, which "
"check for common failures. But if there had been a syntax error, for example"
" fio.opex instead of fio.open, then there would have been a Lua error and f "
"would not have been changed. If checking for such an obvious error had been "
"a concern, the programmer would probably have used pcall()."
msgstr ""
"После вызова функции, который может не сработать, как fio.open() выше, "
"обычно можно увидеть такой синтаксис, как ``if not f then ...`` или ``if f "
"== nil then ...``, который проверяет на типичные отказы. Но если есть ошибка"
" синтаксиса, например, fio.opex вместо fio.open, то появится Lua-ошибка, и f"
" не изменится. Если речь идет о проверке таких очевидных ошибок, программист"
" вероятно будет использовать pcall()."

msgid ""
"All functions in Tarantool modules should work this way, unless the manual "
"explicitly says otherwise."
msgstr ""
"Все функции в модулях Tarantool должны работать таким образом, если в "
"руководстве явно не говорится об обратном."
