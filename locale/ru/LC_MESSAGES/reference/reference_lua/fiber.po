
msgid "Module `fiber`"
msgstr "Модуль `fiber`"

msgid "Overview"
msgstr "Общие сведения"

msgid "With the ``fiber`` module, you can:"
msgstr "С помощью модуля ``fiber`` можно:"

msgid "create, run and manage :ref:`fibers <fiber-fibers>`,"
msgstr "создавать, запускать и управлять :ref:`файберами <fiber-fibers>`,"

msgid ""
"send and receive messages between different processes (i.e. different "
"connections, sessions, or fibers) via :ref:`channels <fiber_ipc-"
"channel>`, and"
msgstr ""
"отправлять и получать сообщения для различных процессов (например, разные"
" соединения, сессии или файберы) по :ref:`каналам <fiber_ipc-channel>`, а"
" также"

msgid ""
"use a :ref:`synchronization mechanism <fiber_ipc-cond_var>` for fibers, "
"similar to \"condition variables\" and similar to operating-system "
"functions such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
msgstr ""
"использовать :ref:`механизм синхронизации <fiber_ipc-cond_var>` для "
"файберов, аналогично работе \"условных переменных\" и функций "
"операционных систем, таких как ``pthread_cond_wait()`` плюс "
"``pthread_cond_signal()``."

msgid "Index"
msgstr "Указатель"

msgid "Below is a list of all ``fiber`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``fiber``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Назначение"

msgid ":ref:`fiber.create() <fiber-create>`"
msgstr ":ref:`fiber.create() <fiber-create>`"

msgid "Create and start a fiber"
msgstr "Создание и запуск файбера"

msgid ":ref:`fiber.new() <fiber-new>`"
msgstr ":ref:`fiber.new() <fiber-new>`"

msgid "Create but do not start a fiber"
msgstr "Создание файбера без запуска"

msgid ":ref:`fiber.self() <fiber-self>`"
msgstr ":ref:`fiber.self() <fiber-self>`"

msgid "Get a fiber object"
msgstr "Получение объекта файбера"

msgid ":ref:`fiber.find() <fiber-find>`"
msgstr ":ref:`fiber.find() <fiber-find>`"

msgid "Get a fiber object by ID"
msgstr "Получение объекта файбера по ID"

msgid ":ref:`fiber.sleep() <fiber-sleep>`"
msgstr ":ref:`fiber.sleep() <fiber-sleep>`"

msgid "Make a fiber go to sleep"
msgstr "Перевод файбера в режим ожидания"

msgid ":ref:`fiber.yield() <fiber-yield>`"
msgstr ":ref:`fiber.yield() <fiber-yield>`"

msgid "Yield control"
msgstr "Передача управления"

msgid ":ref:`fiber.status() <fiber-status>`"
msgstr ":ref:`fiber.status() <fiber-status>`"

msgid "Get the current fiber's status"
msgstr "Получение статуса активного файбера"

msgid ":ref:`fiber.info() <fiber-info>`"
msgstr ":ref:`fiber.info() <fiber-info>`"

msgid "Get information about all fibers"
msgstr "Получение информации о всех файберах"

msgid ":ref:`fiber.kill() <fiber-kill>`"
msgstr ":ref:`fiber.kill() <fiber-kill>`"

msgid "Cancel a fiber"
msgstr "Отмена файбера"

msgid ":ref:`fiber.testcancel() <fiber-testcancel>`"
msgstr ":ref:`fiber.testcancel() <fiber-testcancel>`"

msgid "Check if the current fiber has been cancelled"
msgstr "Проверка отмены действующего файбера"

msgid ":ref:`fiber_object:id() <fiber_object-id>`"
msgstr ":ref:`fiber_object:id() <fiber_object-id>`"

msgid "Get a fiber's ID"
msgstr "Получение ID файбера"

msgid ":ref:`fiber_object:name() <fiber_object-name_get>`"
msgstr ":ref:`fiber_object:name() <fiber_object-name_get>`"

msgid "Get a fiber's name"
msgstr "Получение имени файбера"

msgid ":ref:`fiber_object:name(name) <fiber_object-name_set>`"
msgstr ":ref:`fiber_object:name(name) <fiber_object-name_set>`"

msgid "Set a fiber's name"
msgstr "Назначение имени файбера"

msgid ":ref:`fiber_object:status() <fiber_object-status>`"
msgstr ":ref:`fiber_object:status() <fiber_object-status>`"

msgid "Get a fiber's status"
msgstr "Получение статуса файбера"

msgid ":ref:`fiber_object:cancel() <fiber_object-cancel>`"
msgstr ":ref:`fiber_object:cancel() <fiber_object-cancel>`"

msgid ":ref:`fiber_object.storage <fiber_object-storage>`"
msgstr ":ref:`fiber_object.storage <fiber_object-storage>`"

msgid "Local storage within the fiber"
msgstr "Локальное хранилище в пределах файбера"

msgid ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"
msgstr ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"

msgid "Make it possible for a new fiber to join"
msgstr "Создание возможности подключения нового файбера"

msgid ":ref:`fiber_object:join() <fiber_object-join>`"
msgstr ":ref:`fiber_object:join() <fiber_object-join>`"

msgid "Wait for a fiber's state to become 'dead'"
msgstr "Ожидание статуса 'dead' (недоступен) для файбера"

msgid ":ref:`fiber.time() <fiber-time>`"
msgstr ":ref:`fiber.time() <fiber-time>`"

msgid "Get the system time in seconds"
msgstr "Получение системного времени в секундах"

msgid ":ref:`fiber.time64() <fiber-time64>`"
msgstr ":ref:`fiber.time64() <fiber-time64>`"

msgid "Get the system time in microseconds"
msgstr "Получение системного времени в микросекундах"

msgid ":ref:`fiber.channel() <fiber-channel>`"
msgstr ":ref:`fiber.channel() <fiber-channel>`"

msgid "Create a communication channel"
msgstr "Создание канала связи"

msgid ":ref:`channel_object:put() <channel_object-put>`"
msgstr ":ref:`channel_object:put() <channel_object-put>`"

msgid "Send a message via a channel"
msgstr "Отправка сообщения по каналу связи"

msgid ":ref:`channel_object:close() <channel_object-close>`"
msgstr ":ref:`channel_object:close() <channel_object-close>`"

msgid "Close a channel"
msgstr "Закрытие канала"

msgid ":ref:`channel_object:get() <channel_object-get>`"
msgstr ":ref:`channel_object:get() <channel_object-get>`"

msgid "Fetch a message from a channel"
msgstr "Перехват сообщения из канала"

msgid ":ref:`channel_object:is_empty() <channel_object-is_empty>`"
msgstr ":ref:`channel_object:is_empty() <channel_object-is_empty>`"

msgid "Check if a channel is empty"
msgstr "Проверка пустоты канала"

msgid ":ref:`channel_object:count() <channel_object-count>`"
msgstr ":ref:`channel_object:count() <channel_object-count>`"

msgid "Count messages in a channel"
msgstr "Подсчет сообщений в канале"

msgid ":ref:`channel_object:is_full() <channel_object-is_full>`"
msgstr ":ref:`channel_object:is_full() <channel_object-is_full>`"

msgid "Check if a channel is full"
msgstr "Проверка заполненности канала"

msgid ":ref:`channel_object:has_readers() <channel_object-has_readers>`"
msgstr ":ref:`channel_object:has_readers() <channel_object-has_readers>`"

msgid "Check if an empty channel has any readers waiting"
msgstr "Проверка пустого канала на наличие читателей в состоянии ожидания"

msgid ":ref:`channel_object:has_writers() <channel_object-has_writers>`"
msgstr ":ref:`channel_object:has_writers() <channel_object-has_writers>`"

msgid "Check if a full channel has any writers waiting"
msgstr "Проверка полного канала на наличие писателей в состоянии ожидания"

msgid ":ref:`channel_object:is_closed() <channel_object-is_closed>`"
msgstr ":ref:`channel_object:is_closed() <channel_object-is_closed>`"

msgid "Check if a channel is closed"
msgstr "Проверка закрытия канала"

msgid ":ref:`fiber.cond() <fiber-cond>`"
msgstr ":ref:`fiber.cond() <fiber-cond>`"

msgid "Create a condition variable"
msgstr "Создание условной переменной"

msgid ":ref:`cond_object:wait() <cond_object-wait>`"
msgstr ":ref:`cond_object:wait() <cond_object-wait>`"

msgid "Make a fiber go to sleep until woken by another fiber"
msgstr "Перевод файбера в режим ожидания до пробуждения другим файбером"

msgid ":ref:`cond_object:signal() <cond_object-signal>`"
msgstr ":ref:`cond_object:signal() <cond_object-signal>`"

msgid "Wake up a single fiber"
msgstr "Пробуждение отдельного файбера"

msgid ":ref:`cond_object:broadcast() <cond_object-broadcast>`"
msgstr ":ref:`cond_object:broadcast() <cond_object-broadcast>`"

msgid "Wake up all fibers"
msgstr "Пробуждение всех файберов"

msgid "Fibers"
msgstr "Файберы"

msgid ""
"A **fiber** is a set of instructions which are executed with cooperative "
"multitasking. Fibers managed by the fiber module are associated with a "
"user-supplied function called the *fiber function*."
msgstr ""
"**Файбер** -- это набор инструкций, которые выполняются по принципу "
"кооперативной многозадачности. Файберы, управление которых происходит с "
"помощью модуля fiber, связаны с функцией под названием *функция для "
"файбера*, которую задает пользователь."

msgid ""
"A fiber has three possible states: **running**, **suspended** or "
"**dead**. When a fiber is created with :ref:`fiber.create() <fiber-"
"create>`, it is running. When a fiber is created with :ref:`fiber.new() "
"<fiber-new>` or yields control with :ref:`fiber.sleep() <fiber-sleep>`, "
"it is suspended. When a fiber ends (because the fiber function ends), it "
"is dead."
msgstr ""
"Существуют три возможных состояния файбера: **running** (активен), "
"**suspended** (приостановлен) или **dead** (недоступен). После создания "
"файбера с помощью :ref:`fiber.create() <fiber-create>` он сразу активен. "
"После создания файбера с помощью :ref:`fiber.new() <fiber-new>` или "
"передачи управления с помощью :ref:`fiber.sleep() <fiber-sleep>` файбер "
"будет приостановлен. По окончании работы (по причине окончания работы "
"соответствующей функции) файбер становится недоступен."

msgid ""
"All fibers are part of the fiber registry. This registry can be searched "
"with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a "
"numeric identifier."
msgstr ""
"Все файберы составляют часть реестра файберов. Можно производить поиск по"
" реестру с помощью :ref:`fiber.find() <fiber-find>` по ID файбера (fid), "
"который представляет собой числовой идентификатор."

msgid ""
"A runaway fiber can be stopped with :ref:`fiber_object.cancel "
"<fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-"
"cancel>` is advisory — it works only if the runaway fiber calls "
":ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*``"
" functions, such as :ref:`box.space...delete() <box_space-delete>` or "
":ref:`box.space...update() <box_space-update>`, do call "
":ref:`fiber.testcancel() <fiber-testcancel>` but "
":ref:`box.space...select{} <box_space-select>` does not. In practice, a "
"runaway fiber can only become unresponsive if it does many computations "
"and does not check whether it has been cancelled."
msgstr ""
"Неконтролируемый файбер можно остановить с помощью "
":ref:`fiber_object.cancel <fiber_object-cancel>`. Однако, функция "
":ref:`fiber_object.cancel <fiber_object-cancel>` консультативна, то есть "
"сработает только в том случае, если неконтролируемый файбер случайно "
"вызовет :ref:`fiber.testcancel() <fiber-testcancel>`. Большинство функций"
" типа ``box.*``, например :ref:`box.space...delete() <box_space-delete>` "
"или :ref:`box.space...update() <box_space-update>`, действительно "
"вызывают :ref:`fiber.testcancel() <fiber-testcancel>`, а "
":ref:`box.space...select{} <box_space-select>` не вызовет. В "
"действительности неконтролируемый файбер может перестать отвечать, если "
"он производит большое количество вычислений и не проверяет вероятность "
"отмены."

msgid ""
"The other potential problem comes from fibers which never get scheduled, "
"because they are not subscribed to any events, or because no relevant "
"events occur. Such morphing fibers can be killed with :ref:`fiber.kill() "
"<fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends "
"an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() "
"<fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""
"Другой потенциальной проблемой могут стать файберы, которые не включаются"
" в расписание, поскольку они не подписаны ни на какие события, или потому"
" что соответствующие события не происходят. Такие файберы можно в любое "
"принудительно остановить с помощью :ref:`fiber.kill() <fiber-kill>`, "
"потому что функция :ref:`fiber.kill() <fiber-kill>` отправляет "
"асинхронное событие пробуждения на файбер, а :ref:`fiber.testcancel() "
"<fiber-testcancel>` проверяет наступление такого события пробуждения."

msgid ""
"Like all Lua objects, dead fibers are garbage collected. The Lua garbage "
"collector frees pool allocator memory owned by the fiber, resets all "
"fiber data, and returns the fiber (now called a fiber carcass) to the "
"fiber pool. The carcass can be reused when another fiber is created."
msgstr ""
"Сборщик мусора собирает недоступные файберы так же, как и все "
"Lua-объекты: сборщик мусора в Lua освобождает память выделенного для "
"файбера пула, сбрасывает все данные файбера и возвращает файбер (который "
"теперь называется каркасом файбера) в пул файберов. Каркас можно "
"использовать повторно при создании другого файбера."

msgid ""
"A fiber has all the features of a Lua coroutine_ and all the programming "
"concepts that apply for Lua coroutines will apply for fibers as well. "
"However, Tarantool has made some enhancements for fibers and has used "
"fibers internally. So, although use of coroutines is possible and "
"supported, use of fibers is recommended."
msgstr ""
"У файбера есть все возможности сопрограммы (coroutine_) на языке Lua, и "
"все принципы программирования, которые применяются к сопрограммам на Lua,"
" применимы и к файберам. Однако Tarantool расширил возможности файберов "
"для внутреннего использования. Поэтому, несмотря на возможность и "
"поддержку использования сопрограмм, рекомендуется использовать файберы."

msgid ""
"Create and start a fiber. The fiber is created and begins to run "
"immediately."
msgstr ""
"Создание и запуск файбера. Происходит создание файбера, который "
"незамедлительно начинает работу."

msgid "Parameters"
msgstr "Параметры"

msgid "the function to be associated with the fiber"
msgstr "функция, которая будет связана с файбером"

msgid "what will be passed to function"
msgstr "что передается в функцию"

msgid "Return"
msgstr "Возвращается"

msgid "created fiber object"
msgstr "созданный объект файбера"

msgid "Rtype"
msgstr "Тип возвращаемого значения"

msgid "userdata"
msgstr "пользовательские данные"

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   print(\"I'm a fiber\")\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name); print(\"Fiber "
"started\")\n"
"I'm a fiber\n"
"Fiber started\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   print(\"I'm a fiber\")\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name); print(\"Fiber "
"started\")\n"
"I'm a fiber\n"
"Fiber started\n"
"---\n"
"..."

msgid ""
"Create but do not start a fiber: the fiber is created but does not begin "
"to run immediately -- it starts after the fiber creator (that is, the job"
" that is calling ``fiber.new()``) yields, under :ref:`transaction control"
" <atomic-atomic_execution>`. The initial fiber state is 'suspended'. Thus"
" ``fiber.new()`` differs slightly from :ref:`fiber.create() <fiber-"
"create>`."
msgstr ""
"Создание файбера без запуска: файбер создается, но не запускается сразу "
"же, а ожидает, пока создатель файбера (то есть задача, которая вызывает "
"``fiber.new()``) не передаст управление согласно правилам :ref:`контроля "
"транзакций <atomic-atomic_execution>`. Файбер создается со статусом "
"'suspended' (приостановлен). Таким образом, логика ``fiber.new()`` слегка"
" отличается от :ref:`fiber.create() <fiber-create>`."

msgid ""
"Ordinarily ``fiber.new()`` is used in conjunction with "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` and "
":ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""
"Как правило, ``fiber.new()`` используется вместе с "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` и "
":ref:`fiber_object:join() <fiber_object-join>`."

msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   print(\"I'm a fiber\")\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name); print(\"Fiber not "
"started yet\")\n"
"Fiber not started yet\n"
"---\n"
"...\n"
"tarantool> I'm a fiber\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   print(\"I'm a fiber\")\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name); print(\"Fiber not "
"started yet\")\n"
"Fiber not started yet\n"
"---\n"
"...\n"
"tarantool> I'm a fiber\n"
"---\n"
"..."

msgid "fiber object for the currently scheduled fiber."
msgstr "объект файбера для запланированного на данный момент файбера."

msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."

msgid "numeric identifier of the fiber."
msgstr "числовой идентификатор файбера."

msgid "fiber object for the specified fiber."
msgstr "объект файбера для указанного файбера."

msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."

msgid ""
"Yield control to the scheduler and sleep for the specified number of "
"seconds. Only the current fiber can be made to sleep."
msgstr ""
"Передача управления планировщику и переход в режим ожидания на указанное "
"количество секунд. Только текущий файбер можно перевести в режим "
"ожидания."

msgid "number of seconds to sleep."
msgstr "количество секунд в режиме ожидания."

msgid "Exception"
msgstr "Исключение"

msgid "see the :ref:`Example of yield failure <fiber-fail>`."
msgstr "см. :ref:`Пример неудачной передачи управления <fiber-fail>`"

msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."

msgid ""
"Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) "
"<fiber-sleep>`."
msgstr ""
"Передача управления планировщику. Работает аналогично "
":ref:`fiber.sleep(0) <fiber-sleep>`."

msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.yield()\n"
"---\n"
"..."

msgid ""
"Return the status of the current fiber. Or, if optional fiber_object is "
"passed, return the status of the specified fiber."
msgstr ""
"Возврат статуса текущего файбера. Или же, если передается необязательный "
"параметр fiber_object, возврат статуса указанного файбера."

msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""
"статус файбера: “dead” (недоступен), “suspended” (приостановлен) или "
"“running” (активен)."

msgid "string"
msgstr "строка"

msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."

msgid "Return information about all fibers."
msgstr "Возврат информации о всех файберах."

msgid ""
"number of context switches, backtrace, id, total memory, used memory, "
"name for each fiber."
msgstr ""
"количество переключений контекста, обратная трассировка, ID, общий объем "
"памяти, объем используемой памяти, имя каждого файбера."

msgid "table"
msgstr "таблица"

msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."

msgid ""
"Locate a fiber by its numeric id and cancel it. In other words, "
":ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-"
"find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""
"Поиск файбера по числовому идентификатору и его отмена. Другими словами, "
":ref:`fiber.kill() <fiber-kill>` объединяет в себе :ref:`fiber.find() "
"<fiber-find>` и :ref:`fiber_object:cancel() <fiber_object-cancel>`."

msgid "the id of the fiber to be cancelled."
msgstr "ID файбера для отмены."

msgid "the specified fiber does not exist or cancel is not permitted."
msgstr "указанный файбер отсутствует, или отмена невозможна."

msgid ""
"tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""
"tarantool> fiber.kill(fiber.id()) -- функция с self может вызвать "
"окончание программы\n"
"---\n"
"- error: fiber is cancelled\n"
"..."

msgid ""
"Check if the current fiber has been cancelled and throw an exception if "
"this is the case."
msgstr ""
"Проверка отмены действующего файбера и выдача исключения, если файбер "
"отменен."

msgid ""
"Even if you catch the exception, the fiber will remain cancelled. Most "
"types of calls will check ``fiber.testcancel()``. However, some functions"
" (``id``, ``status``, ``join`` etc.) will return no error. We recommend "
"application developers to implement occasional checks with "
":ref:`fiber.testcancel() <fiber-testcancel>` and to end fiber's execution"
" as soon as possible in case it has been cancelled."
msgstr ""
"Даже при исключении файбер будет отменен. Большинство вызовов проверяют "
"``fiber.testcancel()``. Однако некоторые функции (``id``, ``status``, "
"``join`` и т.д.) не вернут ошибку. Мы рекомендуем разработчикам "
"приложений реализовать случайные проверки :ref:`fiber.testcancel() "
"<fiber-testcancel>` и максимально быстро завершить выполнение файбера, "
"если он был отменен."

msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."

msgid ""
"generally this is an object referenced in the return from "
":ref:`fiber.create <fiber-create>` or :ref:`fiber.self <fiber-self>` or "
":ref:`fiber.find <fiber-find>`"
msgstr ""
"как правило, это объект, полученный в результате вызова "
":ref:`fiber.create <fiber-create>`, :ref:`fiber.self <fiber-self>` или "
":ref:`fiber.find <fiber-find>`"

msgid "id of the fiber."
msgstr "ID файбера."

msgid "number"
msgstr "число"

msgid "``fiber.self():id()`` can also be expressed as ``fiber.id()``."
msgstr "``fiber.self():id()`` может также быть выражен как ``fiber.id()``."

msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."

msgid "name of the fiber."
msgstr "имя файбера."

msgid "``fiber.self():name()`` can also be expressed as ``fiber.name()``."
msgstr "``fiber.self():name()`` может также быть выражен как ``fiber.name()``."

msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."

msgid ""
"Change the fiber name. By default a Tarantool server's interactive-mode "
"fiber is named 'interactive' and new fibers created due to "
":ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers "
"distinct names makes it easier to distinguish them when using "
":ref:`fiber.info <fiber-info>`. Max length is 32."
msgstr ""
"Изменение имени файбера. По умолчанию, файбер в интерактивном режиме "
"экземпляра Tarantool'а называется 'interactive', а новые файберы, "
"созданные с помощью :ref:`fiber.create <fiber-create>`, называются 'lua'."
" Переименование файберов позволяет легче различать их при использовании "
":ref:`fiber.info <fiber-info>`. Максимум 32 символа."

msgid "the new name of the fiber."
msgstr "новое имя файбера."

msgid ""
"* ``truncate=true`` -- truncates the name to the max length if it is   "
"too long. If this option is false (the default),   "
"``fiber.name(new_name)`` fails with an exception if a new name is   too "
"long."
msgstr ""
"``truncate=true`` -- усекает имя до максимальной длины, если оно слишком "
"длинное. Если эта опция установлена в ``false`` (по умолчанию) и имя "
"слишком длинное, то ``fiber.name(new_name)`` падает и выдает исключение."

msgid ""
"``truncate=true`` -- truncates the name to the max length if it is too "
"long. If this option is false (the default), ``fiber.name(new_name)`` "
"fails with an exception if a new name is too long."
msgstr ""
"``truncate=true`` -- усекает имя до максимальной длины, если оно слишком "
"длинное. Если эта опция установлена в ``false`` (по умолчанию) и имя "
"слишком длинное, то ``fiber.name(new_name)`` падает и выдает исключение."

msgid "nil"
msgstr "nil"

msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."

msgid "Return the status of the specified fiber."
msgstr "Возврат статуса указанного файбера."

msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""
"статус файбера: “dead” (недоступен), “suspended” (приостановлен) или "
"“running” (активен)."

msgid "``fiber.self():status(`` can also be expressed as ``fiber.status()``."
msgstr "``fiber.self():status(`` может также быть выражен как ``fiber.status()``."

msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."

msgid ""
"Cancel a fiber. Running and suspended fibers can be cancelled. After a "
"fiber has been cancelled, attempts to operate on it will cause errors, "
"for example :ref:`fiber_object:name() <fiber_object-name_get>` will cause"
" ``error: the fiber is dead``. But a dead fiber can still report its id "
"and status."
msgstr ""
"Отмена файбера. Активные и приостановленные файберы можно отменить. После"
" отмены файбера попытки работать с ним вызовут ошибку, например, вызов "
":ref:`fiber_object:name() <fiber_object-name_get>` вызовет ошибку с "
"указанием недоступности файбера ``error: the fiber is dead``. Тем не "
"менее, недоступный файбер может передавать свой ID и статус."

msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr "Возможные ошибки: нельзя отменить указанный объект файбера."

msgid ""
"tarantool> fiber.self():cancel() -- kill self, may make program end\n"
"---\n"
"...\n"
"tarantool> fiber.self():cancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"...\n"
"tarantool> fiber.self:id()\n"
"---\n"
"- 163\n"
"...\n"
"tarantool> fiber.self:status()\n"
"---\n"
"- dead\n"
"..."
msgstr ""
"tarantool> fiber.self():cancel() -- функция с self может вызвать "
"окончание программы\n"
"---\n"
"...\n"
"tarantool> fiber.self():cancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"...\n"
"tarantool> fiber.self:id()\n"
"---\n"
"- 163\n"
"...\n"
"tarantool> fiber.self:status()\n"
"---\n"
"- dead\n"
"..."

msgid ""
"Local storage within the fiber. It is a Lua table created when it is "
"first accessed. The storage can contain any number of named values, "
"subject to memory limitations. Naming may be done with "
":samp:`{fiber_object}.storage.{name}` or "
":samp:`{fiber_object}.storage['{name}'].` or with a number "
":samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or"
" strings."
msgstr ""

msgid ""
"``fiber.storage`` is destroyed when the fiber is finished, regardless of "
"how is it finished -- via :samp:`{fiber_object}:cancel()`, or the fiber's"
" function did 'return'. Moreover, from that moment the storage is cleaned"
" up even for pooled fibers used to serve IProto requests. Pooled fibers "
"never really die, but nonetheless their storage is cleaned up after each "
"request. That makes possible to use ``fiber.storage`` as a full featured "
"request-local storage."
msgstr ""

msgid ""
"This storage may be created for a fiber, no matter how the fiber itself "
"was created -- from C or from Lua. For example, a fiber can be created in"
" C using ``fiber_new()``, then it can insert into a space, which has Lua "
"``on_replace`` triggers, and one of the triggers can create "
"``fiber.storage``. That storage will be deleted when the fiber is "
"stopped."
msgstr ""

msgid ""
"``fiber.storage`` may be also used for the replication applier fiber. The"
" applier has a fiber from which it applies transactions from a remote "
"instance. In case the applier fiber somehow creates a ``fiber.storage`` "
"(for example, from a space trigger again), the storage won't be deleted "
"until the applier fiber is stopped."
msgstr ""

msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the "
"fiber is dead'\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the "
"fiber is dead'\n"
"..."

msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr "См. также :ref:`box.session.storage <box_session-storage>`."

msgid ""
"``fiber_object:set_joinable(true)`` makes a fiber joinable; "
"``fiber_object:set_joinable(false)`` makes a fiber not joinable; the "
"default is false."
msgstr ""
"``fiber_object:set_joinable(true)`` делает файбер доступным для "
"присоединения; ``fiber_object:set_joinable(false)`` делает файбер "
"недоступным для присоединения; по умолчанию, false."

msgid ""
"A joinable fiber can be waited for, with :ref:`fiber_object:join() "
"<fiber_object-join>`."
msgstr ""
"Присоединяемый файбер можно ожидать с помощью :ref:`fiber_object:join() "
"<fiber_object-join>`."

msgid ""
"Best practice is to call ``fiber_object:set_joinable()`` before the fiber"
" function begins to execute, because otherwise the fiber could become "
"'dead' before ``fiber_object:set_joinable()`` takes effect. The usual "
"sequence could be:"
msgstr ""
"Лучше всего вызвать ``fiber_object:set_joinable()`` до начала выполнения "
"функции с файбером, поскольку в противном случае файбер может стать "
"недоступен до того, как сработает ``fiber_object:set_joinable()``. "
"Правильная последовательность может быть такой:"

msgid ""
"Call ``fiber.new()`` instead of ``fiber.create()`` to create a new "
"fiber_object."
msgstr ""
"Вызов ``fiber.new()`` вместо ``fiber.create()`` для создания нового "
"объекта файбера fiber_object."

msgid ""
"Do not yield at this point, because that will cause the fiber function to"
" begin."
msgstr ""
"Не передавать управление, поскольку это приведет к началу работы функции "
"с файбером."

msgid ""
"Call ``fiber_object:set_joinable(true)`` to make the new fiber_object "
"joinable."
msgstr ""
"Вызов ``fiber_object:set_joinable(true)``, чтобы сделать новый объект "
"файбера fiber_object присоединяемым."

msgid "Now it is safe to yield."
msgstr "Сейчас можно передать управление."

msgid "Call ``fiber_object:join()``."
msgstr "Вызов ``fiber_object:join()``."

msgid ""
"Usually ``fiber_object:join()`` should be called, otherwise the fiber's "
"status may become 'suspended' when the fiber function ends, instead of "
"'dead'."
msgstr ""
"Как правило, следует вызвать ``fiber_object:join()``, в противном случае,"
" статус файбера может перейти в 'suspended' (приостановлен) после "
"выполнения функции, а не 'dead' (недоступен)."

msgid "the boolean value that changes the ``set_joinable`` flag"
msgstr "логическое значение, которое изменяет флаг ``set_joinable``"

msgid "The result of the following sequence of requests is:"
msgstr "Результат следующего ряда запросов:"

msgid ""
"the global variable ``d`` will be 6 (which proves that the function was "
"not executed until after ``d`` was set to 1, when ``fiber.sleep(1)`` "
"caused a yield);"
msgstr ""
"глобальная переменная ``d`` получит значение 6 (что доказывает, что "
"функция не выполнялась до тех пор, пока значение ``d`` не стало 1, когда "
"``fiber.sleep(1)`` вызвал передачу управления);"

msgid ""
"``fiber.status(fi2)`` will be 'suspended' (which proves that after the "
"function was executed the fiber status did not change to 'dead')."
msgstr ""
"``fiber.status(fi2)`` будет приостановлен 'suspended' (что доказывает, "
"что после выполнения функции статус файбера не изменился на недоступный "
"'dead')."

msgid ""
"fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"
msgstr ""
"fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"

msgid ""
"\"Join\" a joinable fiber. That is, let the fiber's function run and wait"
" until the fiber's status is 'dead' (normally a status becomes 'dead' "
"when the function execution finishes). Joining will cause a yield, "
"therefore, if the fiber is currently in a suspended state, execution of "
"its fiber function will resume."
msgstr ""
"\"Присоединение\" присоединяемого файбера. То есть возможность запуска "
"функции с файбером и ожидание перехода файбера в статус недоступности "
"'dead' (как правило, статус переходит в 'dead', когда заканчивается "
"выполнение функции). Присоединение вызовет передачу управления, таким "
"образом, если файбер находится в приостановленном состоянии, выполнение "
"функции файбера возобновится."

msgid ""
"This kind of waiting is more convenient than going into a loop and "
"periodically checking the status; however, it works only if the fiber was"
" created with :ref:`fiber.new() <fiber-new>` and was made joinable with "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."
msgstr ""
"Такое ожидание более удобно, чем переход в цикл с периодической проверкой"
" статуса; тем не менее, это работает, только если файбер был создан с "
"помощью :ref:`fiber.new() <fiber-new>` и стал доступным для присоединения"
" путем :ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."

msgid ""
"two values. The first value is boolean. If the first value is true, then "
"the join succeeded because the fiber's function ended normally and the "
"second result has the return value from the fiber's function. If the "
"first value is false, then the join succeeded because the fiber's "
"function ended abnormally and the second result has the details about the"
" error, which one can unpack in the same way that one unpacks :ref:`a "
"pcall result <error_handling>`."
msgstr ""
"два значения. Первое значение логическое. Если первое значение = true "
"(правда), значит присоединение прошло успешно, поскольку функция файбера "
"была выполнена нормально, а второй результат -- это возвращаемое значение"
" функции файбера. Если же первое значение = false (ложь), значит "
"присоединение не было осуществлено, поскольку выполнение функции файбера "
"было прервано, а второй результат содержит подробную информацию об "
"ошибке, которую можно распаковать так же, как :ref:`результат вызова "
"pcall <error_handling>`."

msgid "boolean +result type, or boolean + struct error"
msgstr ""
"логическое значение +тип результата, или логическое значение + ошибка "
"структуры"

msgid "the first ``fiber.status()`` call returns 'suspended',"
msgstr "первый вызов ``fiber.status()`` возвращает 'suspended' (приостановлен),"

msgid "the ``join()`` call returns true,"
msgstr "вызов ``join()`` возвращает true (правда),"

msgid "the elapsed time is usually 5 seconds, and"
msgstr "как правило, проходит 5 секунд, и"

msgid "the second ``fiber.status()`` call returns 'dead'."
msgstr "второй вызов ``fiber.status()`` возвращает 'dead' (недоступен)."

msgid ""
"This proves that the ``join()`` does not return until the function -- "
"which sleeps 5 seconds -- is 'dead'."
msgstr ""
"Это доказывает, что ``join()`` не возвращает результат, пока функция, "
"которая находится в режиме ожидания в течение 5 секунд, недоступна "
"('dead')."

msgid ""
"fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"
msgstr ""
"fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"

msgid ""
"current system time (in seconds since the epoch) as a Lua number. The "
"time is taken from the event loop clock, which makes this call very "
"cheap, but still useful for constructing artificial tuple keys."
msgstr ""
"текущее системное время (в секундах с начала отсчета) в виде Lua-числа. "
"Время берется из часов событийного цикла, поэтому вызов полезен лишь для "
"создания искусственных ключей кортежа."

msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."

msgid ""
"current system time (in microseconds since the epoch) as a 64-bit "
"integer. The time is taken from the event loop clock."
msgstr ""
"текущее системное время (в микросекундах с начала отсчета) в виде "
"64-битного целого числа. Время берется из часов событийного цикла."

msgid "cdata"
msgstr "cdata"

msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."

msgid "Example"
msgstr "Пример"

msgid ""
"Make the function which will be associated with the fiber. This function "
"contains an infinite loop. Each iteration of the loop adds 1 to a global "
"variable named gvar, then goes to sleep for 2 seconds. The sleep causes "
"an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""
"Создание функции, которая будет связана с файбером. Такая функция "
"содержит бесконечный цикл. Каждая итерация цикла прибавляет 1 к "
"глобальной переменной под названием ``gvar``, а затем уходит в режим "
"ожидания на 2 секунды. Ожидание вызывает неявную передачу управления "
":ref:`fiber.yield() <fiber-yield>`."

msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."

msgid ""
"Make a fiber, associate function_x with the fiber, and start function_x. "
"It will immediately \"detach\" so it will be running independently of the"
" caller."
msgstr ""
"Создание файбера, ассоциация функции function_x с файбером и запуск "
"function_x. Она сразу же \"отсоединится\", то есть будет работать "
"отдельно от вызывающего метода."

msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."

msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr "Получение ID файбера (fid) для последующего вывода."

msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."

msgid ""
"Pause for a while, while the detached function runs. Then ... Display the"
" fiber id, the fiber status, and gvar (gvar will have gone up a bit "
"depending how long the pause lasted). The status is suspended because the"
" fiber spends almost all its time sleeping or yielding."
msgstr ""
"Небольшая остановка, пока работает отсоединенная функция. Затем ... "
"Отображение идентификатора файбера, статуса файбера и переменной gvar "
"(значение gvar немного увеличится в зависимости от длительности паузы). "
"Статус будет \"suspended\" (приостановлен), потому что файбер практически"
" всё время проводит в режиме ожидания или передачи управления."

msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."

msgid ""
"Pause for a while, while the detached function runs. Then ... Cancel the "
"fiber. Then, once again ... Display the fiber id, the fiber status, and "
"gvar (gvar will have gone up a bit more depending how long the pause "
"lasted). This time the status is dead because the cancel worked."
msgstr ""
"Небольшая остановка, пока работает отсоединенная функция. Затем ... "
"Отмена файбера. Затем снова отображение идентификатора файбера, статуса "
"файбера и переменной gvar (значение gvar немного увеличится в зависимости"
" от длительности паузы). На этот раз статус будет \"dead\" (недоступен), "
"потому что произошла отмена."

msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."

msgid "Example of yield failure"
msgstr "Пример неудачной передачи управления"

msgid ""
"Warning: :ref:`yield() <fiber-yield>` and any function which implicitly "
"yields (such as :ref:`sleep() <fiber-sleep>`) can fail (raise an "
"exception)."
msgstr ""
"Предупреждение: функция :ref:`yield() <fiber-yield>` и любая функция, "
"которая неявно передает управление (например, :ref:`sleep() <fiber-"
"sleep>`), может упасть (выдать исключение)."

msgid ""
"For example, this function has a loop which repeats until :ref:`cancel() "
"<fiber_object-cancel>` happens. The last thing that it will print is "
"'before yield', which demonstrates that ``yield()`` failed, the loop did "
"not continue until :ref:`testcancel() <fiber-testcancel>` failed."
msgstr ""
"Например, в этой функции есть цикл, который повторяется до тех пор, пока "
"не произойдет :ref:`cancel() <fiber_object-cancel>`. Последнее, что она "
"выведет, это ``before yield``, что свидетельствует о том, что функция "
"``yield()`` не сработала, цикл не продолжался до тех пор, пока не "
"сработала функция :ref:`testcancel() <fiber-testcancel>`."

msgid ""
"fiber = require('fiber')\n"
"function function_name()\n"
"  while true do\n"
"    print('before testcancel')\n"
"    fiber.testcancel()\n"
"    print('before yield')\n"
"    fiber.yield()\n"
"  end\n"
"end\n"
"fiber_object = fiber.create(function_name)\n"
"fiber.sleep(.1)\n"
"fiber_object:cancel()"
msgstr ""

msgid "Channels"
msgstr "Каналы"

msgid ""
"Call ``fiber.channel()`` to allocate space and get a channel object, "
"which will be called channel for examples in this section."
msgstr ""
"Вызов ``fiber.channel()`` для выделения спейса и получение объекта "
"канала, который будет называться \"channel\" в примерах данного раздела."

msgid ""
"Call the other routines, via channel, to send messages, receive messages,"
" or check channel status."
msgstr ""
"Вызов других процедур по каналу для отправки сообщений, получения "
"сообщений или проверки статуса канала."

msgid ""
"Message exchange is synchronous. The Lua garbage collector will mark or "
"free the channel when no one is using it, as with any other Lua object. "
"Use object-oriented syntax, for example ``channel:put(message)`` rather "
"than ``fiber.channel.put(message)``."
msgstr ""
"Обмен сообщения происходит синхронно. Сборщик мусора в Lua отмечает или "
"освобождает канал, когда его никто не использует, как и любой другой "
"Lua-объект. Используйте объектно-ориентированный синтаксис, например "
"``channel:put(message)``, а не ``fiber.channel.put(message)``."

msgid "Create a new communication channel."
msgstr "Создание нового канала связи."

msgid ""
"the maximum number of slots (spaces for ``channel:put`` messages) that "
"can be in use at once. The default is 0."
msgstr ""
"максимальное количество слотов (спейсы для сообщений ``channel:put``), "
"которые можно использовать одновременно. По умолчанию, 0."

msgid "return"
msgstr "возвращает"

msgid "new channel."
msgstr "новый канал."

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "userdata, possibly including the string \"channel ...\"."
msgstr "пользовательские данные, возможно включая строку \"channel ...\"."

msgid ""
"Send a message using a channel. If the channel is full, ``channel:put()``"
" waits until there is a free slot in the channel."
msgstr ""
"Отправка сообщения по каналу связи. Если канал заполнен, "
"``channel:put()`` ожидает, пока не освободится слот в канале."

msgid "what will be sent, usually a string or number or table"
msgstr "то, что отправляется, как правило, строка, число или таблица"

msgid "maximum number of seconds to wait for a slot to become free"
msgstr "максимальное количество секунд ожидания, чтобы слот освободился"

msgid ""
"If timeout is specified, and there is no free slot in the channel for the"
" duration of the timeout, then the return value is ``false``. If the "
"channel is closed, then the return value is ``false``. Otherwise, the "
"return value is ``true``, indicating success."
msgstr ""
"Если указан параметр времени ожидания timeout, и в канале нет свободного "
"слота в течение указанного времени, возвращается значение ``false`` "
"(ложь). Если канал закрыт, возвращается значение ``false``. В остальных "
"случаях возвращается значение ``true`` (правда), которое указывает на "
"успешную отправку."

msgid "boolean"
msgstr "boolean (логический)"

msgid ""
"Close the channel. All waiters in the channel will stop waiting. All "
"following ``channel:get()`` operations will return ``nil``, and all "
"following ``channel:put()`` operations will return ``false``."
msgstr ""
"Закрытие канала. Все, кто находится в режиме ожидания в канале, "
"отключаются. Все последующие операции ``channel:get()`` вернут нулевое "
"значение ``nil``, а все последующие операции ``channel:put()`` вернут "
"``false`` (ложь)."

msgid ""
"Fetch and remove a message from a channel. If the channel is empty, "
"``channel:get()`` waits for a message."
msgstr ""
"Перехват и удаление сообщения из канала. Если канал пуст, "
"``channel:get()`` будет ожидать сообщения."

msgid "maximum number of seconds to wait for a message"
msgstr "максимальное количество секунд ожидания сообщения"

msgid ""
"If timeout is specified, and there is no message in the channel for the "
"duration of the timeout, then the return value is ``nil``. If the channel"
" is closed, then the return value is ``nil``. Otherwise, the return value"
" is the message placed on the channel by ``channel:put()``."
msgstr ""
"Если указан параметр времени ожидания timeout, и в канале нет сообщения в"
" течение указанного времени, возвращается нулевое значение ``nil``. Если "
"канал закрыт, возвращается значение ``nil``. В остальных случаях "
"возвращается сообщение, отправленное на канал с помощью "
"``channel:put()``."

msgid "usually string or number or table, as determined by ``channel:put``"
msgstr "как правило, строка, число или таблица, как определяет ``channel:put()``"

msgid "Check whether the channel is empty (has no messages)."
msgstr "Проверка пустоты канала (отсутствие сообщений)."

msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr "``true`` (правда), если канал пуст. В противном случае, ``false`` (ложь)."

msgid "Find out how many messages are in the channel."
msgstr "Определение количества сообщений в канале."

msgid "the number of messages."
msgstr "количество сообщений."

msgid "Check whether the channel is full."
msgstr "Проверка заполненности канала."

msgid ""
"``true`` if the channel is full (the number of messages in the channel "
"equals the number of slots so there is no room for a new message). "
"Otherwise ``false``."
msgstr ""
"``true`` (правда), если канал заполнен (количество сообщений в канале "
"равно количеству слотов, то есть нет места для новых сообщений). В "
"противном случае, ``false`` (ложь)."

msgid ""
"Check whether readers are waiting for a message because they have issued "
"``channel:get()`` and the channel is empty."
msgstr ""
"Проверка пустого канала на наличие читателей в состоянии ожидания "
"сообщения после отправки запросов ``channel:get()``."

msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""
"``true`` (правда), если на канале есть читатели в ожидании сообщения. В "
"противном случае, ``false`` (ложь)."

msgid ""
"Check whether writers are waiting because they have issued "
"``channel:put()`` and the channel is full."
msgstr ""
"Проверка полного канала на наличие писателей в состоянии ожидания после "
"отправки запросов ``channel:put()``."

msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""
"``true`` (правда), если на канале есть писатели в состоянии ожидании. В "
"противном случае, ``false`` (ложь)."

msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""
"``true`` (правда), если канал уже закрыт. В противном случае, ``false`` "
"(ложь)."

msgid ""
"This example should give a rough idea of what some functions for fibers "
"should look like. It's assumed that the functions would be referenced in "
":ref:`fiber.create() <fiber-create>`."
msgstr ""
"В данном примере дается примерное представление о том, как должны "
"выглядеть функции для файберов. Предполагается, что на функции ссылается "
":ref:`fiber.create() <fiber-create>`."

msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""
"fiber = require('fiber')\n"
" channel = fiber.channel(10)\n"
" function consumer_fiber()\n"
"     while true do\n"
"         local task = channel:get()\n"
"         ...\n"
"     end\n"
" end\n"
" \n"
" function consumer2_fiber()\n"
"     while true do\n"
"         -- 10 секунд\n"
"         local task = channel:get(10)\n"
"         if task ~= nil then\n"
"             ...\n"
"         else\n"
"             -- время ожидания\n"
"         end\n"
"     end\n"
" end\n"
" \n"
" function producer_fiber()\n"
"     while true do\n"
"         task = box.space...:select{...}\n"
"         ...\n"
"         if channel:is_empty() then\n"
"             -- канал пуст\n"
"         end\n"
" \n"
"         if channel:is_full() then\n"
"             -- канал полон\n"
"         end\n"
" \n"
"         ...\n"
"         if channel:has_readers() then\n"
"             -- есть файберы\n"
"             -- которые ожидают данные\n"
"         end\n"
"         ...\n"
" \n"
"         if channel:has_writers() then\n"
"             -- есть файберы\n"
"             -- которые ожидают читателей\n"
"         end\n"
"         channel:put(task)\n"
"     end\n"
" end\n"
" \n"
" function producer2_fiber()\n"
"     while true do\n"
"         task = box.space...select{...}\n"
"         -- 10 секунд\n"
"         if channel:put(task, 10) then\n"
"             ...\n"
"         else\n"
"             -- время ожидания\n"
"         end\n"
"     end\n"
" end"

msgid "Condition variables"
msgstr "Условные переменные"

msgid ""
"Call ``fiber.cond()`` to create a named condition variable, which will be"
" called 'cond' for examples in this section."
msgstr ""
"Вызов ``fiber.cond()`` используется для создания именованной условной "
"переменной, которая будет называться 'cond' для примеров данного раздела."

msgid ""
"Call ``cond:wait()`` to make a fiber wait for a signal via a condition "
"variable."
msgstr ""
"Вызов ``cond:wait()`` используется, чтобы заставить файбер ожидать "
"сигнал, с помощью условной переменной."

msgid ""
"Call ``cond:signal()`` to send a signal to wake up a single fiber that "
"has executed ``cond:wait()``."
msgstr ""
"Вызов ``cond:signal()`` используется, чтобы отправить сигнал для "
"пробуждения отдельного файбера, который выполнил запрос ``cond:wait()``."

msgid ""
"Call ``cond:broadcast()`` to send a signal to all fibers that have "
"executed ``cond:wait()``."
msgstr ""
"Вызов ``cond:broadcast()`` используется для отправки сигнала всем "
"файберам, которые выполнили ``cond:wait()``."

msgid "Create a new condition variable."
msgstr "Создание новой условной переменной."

msgid "new condition variable."
msgstr "новая условная переменная."

msgid "Lua object"
msgstr "Lua-объект"

msgid ""
"Make the current fiber go to sleep, waiting until another fiber invokes "
"the ``signal()`` or ``broadcast()`` method on the cond object. The sleep "
"causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""
"Перевод файбера в режим ожидания до пробуждения другим файбером с помощью"
" метода ``signal()`` или ``broadcast()``. Переход в режим ожидания "
"вызывает неявную передачу управления :ref:`fiber.yield() <fiber-yield>`."

msgid "number of seconds to wait, default = forever."
msgstr "количество секунд ожидания, по умолчанию = всегда."

msgid ""
"If timeout is provided, and a signal doesn't happen for the duration of "
"the timeout, ``wait()`` returns false. If a signal or broadcast happens, "
"``wait()`` returns true."
msgstr ""
"Если указан параметр времени ожидания timeout, и сигнал не передается в "
"течение указанного времени, ``wait()`` вернет значение false (ложь). Если"
" передается ``signal()`` или ``broadcast()``, ``wait()`` вернет true "
"(правда)."

msgid ""
"Wake up a single fiber that has executed ``wait()`` for the same "
"variable. Does not yield."
msgstr ""
"Пробуждение отдельного файбера, который выполнил ``wait()`` для той же "
"переменной. Не выполняет передачу управления (yield)."

msgid ""
"Wake up all fibers that have executed ``wait()`` for the same variable. "
"Does not yield."
msgstr ""
"Пробуждение всех файберов, которые выполнили ``wait()`` для той же "
"переменной. Не выполняет передачу управления (yield)."

msgid ""
"Assume that a tarantool instance is running and listening for connections"
" on localhost port 3301. Assume that guest users have privileges to "
"connect. We will use the tarantoolctl utility to start two clients."
msgstr ""
"Предположим, что запущен экземпляр Tarantool'а на прослушивание на "
"localhost по порту 3301. Предположим, что у пользователя guest есть права"
" на подключение. Используем утилиту tarantoolctl для запуска двух "
"клиентов."

msgid "On terminal #1, say"
msgstr "В первом терминале введите:"

msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"

msgid ""
"The job will hang because ``cond:wait()`` -- without an optional timeout "
"argument -- will go to sleep until the condition variable changes."
msgstr ""
"Задача повиснет, поскольку ``cond:wait()`` -- без дополнительного "
"аргумента времени ожидания timeout -- уйдет в режим ожидания до изменения"
" условной переменной."

msgid "On terminal #2, say"
msgstr "Во втором терминале введите:"

msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"

msgid ""
"Now look again at terminal #1. It will show that the waiting stopped, and"
" the ``cond:wait()`` function returned ``true``."
msgstr ""
"Теперь снова взгляните на терминал №1. Он покажет, что ожидание "
"прекратилось, и функция ``cond:wait()`` вернула значение ``true``."

msgid ""
"This example depended on the use of a global conditional variable with "
"the arbitrary name ``cond``. In real life, programmers would make sure to"
" use different conditional variable names for different applications."
msgstr ""
"В данном примере показана зависимость от использования глобальной "
"условной переменной с произвольным именем ``cond``. В реальной жизни "
"разработчики следят за использованием различных имен для условных "
"переменных в разных приложениях."
