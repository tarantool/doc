
msgid "Module `fiber`"
msgstr "Модуль `fiber`"

msgid "Overview"
msgstr "Общие сведения"

msgid "With the ``fiber`` module, you can:"
msgstr "С помощью модуля ``fiber`` можно:"

msgid "create, run and manage :ref:`fibers <fiber-fibers>`,"
msgstr "создавать, запускать и управлять :ref:`файберами <fiber-fibers>`,"

msgid ""
"send and receive messages between different processes (i.e. different "
"connections, sessions, or fibers) via :ref:`channels <fiber_ipc-channel>`, "
"and"
msgstr ""
"отправлять и получать сообщения для различных процессов (например, разные "
"соединения, сессии или файберы) по :ref:`каналам <fiber_ipc-channel>`, а "
"также"

msgid ""
"use a :ref:`synchronization mechanism <fiber_ipc-cond_var>` for fibers, "
"similar to \"condition variables\" and similar to operating-system functions"
" such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
msgstr ""
"использовать :ref:`механизм синхронизации <fiber_ipc-cond_var>` для "
"файберов, аналогично работе \"условных переменных\" и функций операционных "
"систем, таких как ``pthread_cond_wait()`` плюс ``pthread_cond_signal()``."

msgid "Index"
msgstr "Указатель"

msgid "Below is a list of all ``fiber`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``fiber``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Назначение"

msgid "**Fibers**"
msgstr ""

msgid ":ref:`fiber.create() <fiber-create>`"
msgstr ":ref:`fiber.create() <fiber-create>`"

msgid "Create and start a fiber"
msgstr "Создание и запуск файбера"

msgid ":ref:`fiber.new() <fiber-new>`"
msgstr ":ref:`fiber.new() <fiber-new>`"

msgid "Create but do not start a fiber"
msgstr "Создание файбера без запуска"

msgid ":ref:`fiber.self() <fiber-self>`"
msgstr ":ref:`fiber.self() <fiber-self>`"

msgid "Get a fiber object"
msgstr "Получение объекта файбера"

msgid ":ref:`fiber.find() <fiber-find>`"
msgstr ":ref:`fiber.find() <fiber-find>`"

msgid "Get a fiber object by ID"
msgstr "Получение объекта файбера по ID"

msgid ":ref:`fiber.sleep() <fiber-sleep>`"
msgstr ":ref:`fiber.sleep() <fiber-sleep>`"

msgid "Make a fiber go to sleep"
msgstr "Перевод файбера в режим ожидания"

msgid ":ref:`fiber.yield() <fiber-yield>`"
msgstr ":ref:`fiber.yield() <fiber-yield>`"

msgid "Yield control"
msgstr "Передача управления"

msgid ":ref:`fiber.status() <fiber-status>`"
msgstr ":ref:`fiber.status() <fiber-status>`"

msgid "Get the current fiber's status"
msgstr "Получение статуса активного файбера"

msgid ":ref:`fiber.info() <fiber-info>`"
msgstr ":ref:`fiber.info() <fiber-info>`"

msgid "Get information about all fibers"
msgstr "Получение информации о всех файберах"

msgid ":ref:`fiber.top() <fiber-top>`"
msgstr ":ref:`fiber.top() <fiber-top>`"

msgid "Return a table of alive fibers and show their CPU consumption"
msgstr ""
"Возврат таблицы с активными файберами и отображение статистики потребления "
"ресурсов ЦП"

msgid ":ref:`fiber.kill() <fiber-kill>`"
msgstr ":ref:`fiber.kill() <fiber-kill>`"

msgid "Cancel a fiber"
msgstr "Отмена файбера"

msgid ":ref:`fiber.testcancel() <fiber-testcancel>`"
msgstr ":ref:`fiber.testcancel() <fiber-testcancel>`"

msgid "Check if the current fiber has been cancelled"
msgstr "Проверка отмены действующего файбера"

msgid ":ref:`fiber.time() <fiber-time>`"
msgstr ":ref:`fiber.time() <fiber-time>`"

msgid "Get the system time in seconds"
msgstr "Получение системного времени в секундах"

msgid ":ref:`fiber.time64() <fiber-time64>`"
msgstr ":ref:`fiber.time64() <fiber-time64>`"

msgid "Get the system time in microseconds"
msgstr "Получение системного времени в микросекундах"

msgid ":ref:`fiber.clock() <fiber-clock>`"
msgstr ":ref:`fiber.clock() <fiber-clock>`"

msgid "Get the monotonic time in seconds"
msgstr "Получение монотонного времени в секундах"

msgid ":ref:`fiber.clock64() <fiber-clock64>`"
msgstr ":ref:`fiber.clock64() <fiber-clock64>`"

msgid "Get the monotonic time in microseconds"
msgstr "Получение монотонного времени в микросекундах"

msgid "**Fiber object**"
msgstr ""

msgid ":ref:`fiber_object:id() <fiber_object-id>`"
msgstr ":ref:`fiber_object:id() <fiber_object-id>`"

msgid "Get a fiber's ID"
msgstr "Получение ID файбера"

msgid ":ref:`fiber_object:name() <fiber_object-name_get>`"
msgstr ":ref:`fiber_object:name() <fiber_object-name_get>`"

msgid "Get a fiber's name"
msgstr "Получение имени файбера"

msgid ":ref:`fiber_object:name(name) <fiber_object-name_set>`"
msgstr ":ref:`fiber_object:name(name) <fiber_object-name_set>`"

msgid "Set a fiber's name"
msgstr "Назначение имени файбера"

msgid ":ref:`fiber_object:status() <fiber_object-status>`"
msgstr ":ref:`fiber_object:status() <fiber_object-status>`"

msgid "Get a fiber's status"
msgstr "Получение статуса файбера"

msgid ":ref:`fiber_object:cancel() <fiber_object-cancel>`"
msgstr ":ref:`fiber_object:cancel() <fiber_object-cancel>`"

msgid ":ref:`fiber_object.storage <fiber_object-storage>`"
msgstr ":ref:`fiber_object.storage <fiber_object-storage>`"

msgid "Local storage within the fiber"
msgstr "Локальное хранилище в пределах файбера"

msgid ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"
msgstr ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"

msgid "Make it possible for a new fiber to join"
msgstr "Создание возможности подключения нового файбера"

msgid ":ref:`fiber_object:join() <fiber_object-join>`"
msgstr ":ref:`fiber_object:join() <fiber_object-join>`"

msgid "Wait for a fiber's state to become 'dead'"
msgstr "Ожидание статуса 'dead' (недоступен) для файбера"

msgid ":ref:`Examples <fiber-example>`"
msgstr ""

msgid "Some useful examples"
msgstr "Несколько полезных примеров"

msgid "**Channels**"
msgstr ""

msgid ":ref:`fiber.channel() <fiber-channel>`"
msgstr ":ref:`fiber.channel() <fiber-channel>`"

msgid "Create a communication channel"
msgstr "Создание канала связи"

msgid ":ref:`channel_object:put() <channel_object-put>`"
msgstr ":ref:`channel_object:put() <channel_object-put>`"

msgid "Send a message via a channel"
msgstr "Отправка сообщения по каналу связи"

msgid ":ref:`channel_object:close() <channel_object-close>`"
msgstr ":ref:`channel_object:close() <channel_object-close>`"

msgid "Close a channel"
msgstr "Закрытие канала"

msgid ":ref:`channel_object:get() <channel_object-get>`"
msgstr ":ref:`channel_object:get() <channel_object-get>`"

msgid "Fetch a message from a channel"
msgstr "Перехват сообщения из канала"

msgid ":ref:`channel_object:is_empty() <channel_object-is_empty>`"
msgstr ":ref:`channel_object:is_empty() <channel_object-is_empty>`"

msgid "Check if a channel is empty"
msgstr "Проверка пустоты канала"

msgid ":ref:`channel_object:count() <channel_object-count>`"
msgstr ":ref:`channel_object:count() <channel_object-count>`"

msgid "Count messages in a channel"
msgstr "Подсчет сообщений в канале"

msgid ":ref:`channel_object:is_full() <channel_object-is_full>`"
msgstr ":ref:`channel_object:is_full() <channel_object-is_full>`"

msgid "Check if a channel is full"
msgstr "Проверка заполненности канала"

msgid ":ref:`channel_object:has_readers() <channel_object-has_readers>`"
msgstr ":ref:`channel_object:has_readers() <channel_object-has_readers>`"

msgid "Check if an empty channel has any readers waiting"
msgstr "Проверка пустого канала на наличие читателей в состоянии ожидания"

msgid ":ref:`channel_object:has_writers() <channel_object-has_writers>`"
msgstr ":ref:`channel_object:has_writers() <channel_object-has_writers>`"

msgid "Check if a full channel has any writers waiting"
msgstr "Проверка полного канала на наличие писателей в состоянии ожидания"

msgid ":ref:`channel_object:is_closed() <channel_object-is_closed>`"
msgstr ":ref:`channel_object:is_closed() <channel_object-is_closed>`"

msgid "Check if a channel is closed"
msgstr "Проверка закрытия канала"

msgid ":ref:`Example <channel_object-example>`"
msgstr ""

msgid "A useful example about channels"
msgstr ""

msgid "**Condition variables**"
msgstr ""

msgid ":ref:`fiber.cond() <fiber-cond>`"
msgstr ":ref:`fiber.cond() <fiber-cond>`"

msgid "Create a condition variable"
msgstr "Создание условной переменной"

msgid ":ref:`cond_object:wait() <cond_object-wait>`"
msgstr ":ref:`cond_object:wait() <cond_object-wait>`"

msgid "Make a fiber go to sleep until woken by another fiber"
msgstr "Перевод файбера в режим ожидания до пробуждения другим файбером"

msgid ":ref:`cond_object:signal() <cond_object-signal>`"
msgstr ":ref:`cond_object:signal() <cond_object-signal>`"

msgid "Wake up a single fiber"
msgstr "Пробуждение отдельного файбера"

msgid ":ref:`cond_object:broadcast() <cond_object-broadcast>`"
msgstr ":ref:`cond_object:broadcast() <cond_object-broadcast>`"

msgid "Wake up all fibers"
msgstr "Пробуждение всех файберов"

msgid ":ref:`Example <cond_object-example>`"
msgstr ""

msgid "A useful example about condition variables"
msgstr ""

msgid "Fibers"
msgstr "Файберы"

msgid ""
"A **fiber** is a set of instructions which are executed with
:ref:`cooperative multitasking <atomic-cooperative_multitasking>`.
(Learn more about `transactions <atomic-threads_fibers_yields>` in Tarantool.)
Fibers managed by the fiber module are associated with
a user-supplied function called the *fiber function*. "
msgstr ""
"**Файбер** -- это набор инструкций, которые выполняются по принципу "
":ref:`кооперативной многозадачности <atomic-cooperative_multitasking>`. "
"(О том, как устроены транзакции в Tarantool, можно прочитать "
"в разделе `Транзакции <atomic-threads_fibers_yields>`.) "
"Файберы, управление которыми происходит с "
"помощью модуля fiber, связаны с *функцией для "
"файбера*, которую задает пользователь."

msgid ""
"A fiber has three possible states: **running**, **suspended** or **dead**. "
"When a fiber is created with :ref:`fiber.create() <fiber-create>`, it is "
"running. When a fiber is created with :ref:`fiber.new() <fiber-new>` or "
"yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is suspended. "
"When a fiber ends (because the fiber function ends), it is dead."
msgstr ""
"Существуют три возможных состояния файбера: **running** (активен), "
"**suspended** (приостановлен) или **dead** (недоступен). После создания "
"файбера с помощью :ref:`fiber.create() <fiber-create>` он сразу активен. "
"После создания файбера с помощью :ref:`fiber.new() <fiber-new>` или передачи"
" управления с помощью :ref:`fiber.sleep() <fiber-sleep>` файбер будет "
"приостановлен. По окончании работы (по причине окончания работы "
"соответствующей функции) файбер становится недоступен."

msgid ""
"All fibers are part of the fiber registry. This registry can be searched "
"with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a "
"numeric identifier."
msgstr ""
"Все файберы составляют часть реестра файберов. Можно производить поиск по "
"реестру с помощью :ref:`fiber.find() <fiber-find>` по ID файбера (fid), "
"который представляет собой числовой идентификатор."

msgid ""
"A runaway fiber can be stopped with :ref:`fiber_object.cancel <fiber_object-"
"cancel>`. However, :ref:`fiber_object.cancel <fiber_object-cancel>` is "
"advisory — it works only if the runaway fiber calls :ref:`fiber.testcancel()"
" <fiber-testcancel>` occasionally. Most ``box.*`` functions, such as "
":ref:`box.space...delete() <box_space-delete>` or :ref:`box.space...update()"
" <box_space-update>`, do call :ref:`fiber.testcancel() <fiber-testcancel>` "
"but :ref:`box.space...select{} <box_space-select>` does not. In practice, a "
"runaway fiber can only become unresponsive if it does many computations and "
"does not check whether it has been cancelled."
msgstr ""
"Неконтролируемый файбер можно остановить с помощью :ref:`fiber_object.cancel"
" <fiber_object-cancel>`. Однако, функция :ref:`fiber_object.cancel "
"<fiber_object-cancel>` консультативна, то есть сработает только в том "
"случае, если неконтролируемый файбер случайно вызовет "
":ref:`fiber.testcancel() <fiber-testcancel>`. Большинство функций типа "
"``box.*``, например :ref:`box.space...delete() <box_space-delete>` или "
":ref:`box.space...update() <box_space-update>`, действительно вызывают "
":ref:`fiber.testcancel() <fiber-testcancel>`, а :ref:`box.space...select{} "
"<box_space-select>` не вызовет. В действительности неконтролируемый файбер "
"может перестать отвечать, если он производит большое количество вычислений и"
" не проверяет вероятность отмены."

msgid ""
"The other potential problem comes from fibers which never get scheduled, "
"because they are not subscribed to any events, or because no relevant events"
" occur. Such morphing fibers can be killed with :ref:`fiber.kill() <fiber-"
"kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends an "
"asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() <fiber-"
"testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""
"Другой потенциальной проблемой могут стать файберы, которые не включаются в "
"расписание, поскольку они не подписаны ни на какие события, или потому что "
"соответствующие события не происходят. Такие файберы можно в любое "
"принудительно остановить с помощью :ref:`fiber.kill() <fiber-kill>`, потому "
"что функция :ref:`fiber.kill() <fiber-kill>` отправляет асинхронное событие "
"пробуждения на файбер, а :ref:`fiber.testcancel() <fiber-testcancel>` "
"проверяет наступление такого события пробуждения."

msgid ""
"Like all Lua objects, dead fibers are garbage collected. The Lua garbage "
"collector frees pool allocator memory owned by the fiber, resets all fiber "
"data, and returns the fiber (now called a fiber carcass) to the fiber pool. "
"The carcass can be reused when another fiber is created."
msgstr ""
"Сборщик мусора собирает недоступные файберы так же, как и все Lua-объекты: "
"сборщик мусора в Lua освобождает память выделенного для файбера пула, "
"сбрасывает все данные файбера и возвращает файбер (который теперь называется"
" каркасом файбера) в пул файберов. Каркас можно использовать повторно при "
"создании другого файбера."

msgid ""
"A fiber has all the features of a Lua `coroutine "
"<http://www.lua.org/pil/contents.html#9>`_ and all the programming concepts "
"that apply for Lua coroutines will apply for fibers as well. However, "
"Tarantool has made some enhancements for fibers and has used fibers "
"internally. So, although use of coroutines is possible and supported, use of"
" fibers is recommended."
msgstr ""
"У файбера есть все возможности сопрограммы (`coroutine "
"<http://www.lua.org/pil/contents.html#9>`_) на языке Lua, и все принципы "
"программирования, которые применяются к сопрограммам на Lua, применимы и к "
"файберам. Однако Tarantool расширил возможности файберов для внутреннего "
"использования. Поэтому, несмотря на возможность и поддержку использования "
"сопрограмм, рекомендуется использовать файберы."

msgid ""
"Create and start a fiber. The fiber is created and begins to run "
"immediately."
msgstr ""
"Создание и запуск файбера. Происходит создание файбера, который "
"незамедлительно начинает работу."

msgid "Parameters"
msgstr "Параметры"

msgid "the function to be associated with the fiber"
msgstr "функция, которая будет связана с файбером"

msgid "what will be passed to function"
msgstr "что передается в функцию"

msgid "return"
msgstr "возвращает"

msgid "created fiber object"
msgstr "созданный объект файбера"

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "userdata"
msgstr "пользовательские данные"

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   print(\"I'm a fiber\")\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name); print(\"Fiber started\")\n"
"I'm a fiber\n"
"Fiber started\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   print(\"I'm a fiber\")\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name); print(\"Fiber started\")\n"
"I'm a fiber\n"
"Fiber started\n"
"---\n"
"..."

msgid ""
"Create but do not start a fiber: the fiber is created but does not begin to "
"run immediately -- it starts after the fiber creator (that is, the job that "
"is calling ``fiber.new()``) yields, under :ref:`transaction control <atomic-"
"atomic_execution>`. The initial fiber state is 'suspended'. Thus "
"``fiber.new()`` differs slightly from :ref:`fiber.create() <fiber-create>`."
msgstr ""
"Создание файбера без запуска: файбер создается, но не запускается сразу же, "
"а ожидает, пока создатель файбера (то есть задача, которая вызывает "
"``fiber.new()``) не передаст управление согласно правилам :ref:`контроля "
"транзакций <atomic-atomic_execution>`. Файбер создается со статусом "
"'suspended' (приостановлен). Таким образом, логика ``fiber.new()`` слегка "
"отличается от :ref:`fiber.create() <fiber-create>`."

msgid ""
"Ordinarily ``fiber.new()`` is used in conjunction with "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` and "
":ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""
"Как правило, ``fiber.new()`` используется вместе с "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` и "
":ref:`fiber_object:join() <fiber_object-join>`."

msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   print(\"I'm a fiber\")\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name); print(\"Fiber not started yet\")\n"
"Fiber not started yet\n"
"---\n"
"...\n"
"tarantool> I'm a fiber\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   print(\"I'm a fiber\")\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name); print(\"Fiber not started yet\")\n"
"Fiber not started yet\n"
"---\n"
"...\n"
"tarantool> I'm a fiber\n"
"---\n"
"..."

msgid "fiber object for the currently scheduled fiber."
msgstr "объект файбера для запланированного на данный момент файбера."

msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."

msgid "numeric identifier of the fiber."
msgstr "числовой идентификатор файбера."

msgid "fiber object for the specified fiber."
msgstr "объект файбера для указанного файбера."

msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."

msgid ""
"Yield control to the scheduler and sleep for the specified number of "
"seconds. Only the current fiber can be made to sleep."
msgstr ""
"Передача управления планировщику и переход в режим ожидания на указанное "
"количество секунд. Только текущий файбер можно перевести в режим ожидания."

msgid "number of seconds to sleep."
msgstr "количество секунд в режиме ожидания."

msgid "Exception"
msgstr "Исключение"

msgid "see the :ref:`Example of yield failure <fiber-fail>`."
msgstr "см. :ref:`Пример неудачной передачи управления <fiber-fail>`"

msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."

msgid ""
"Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) <fiber-"
"sleep>`."
msgstr ""
"Передача управления планировщику. Работает аналогично :ref:`fiber.sleep(0) "
"<fiber-sleep>`."

msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.yield()\n"
"---\n"
"..."

msgid ""
"Return the status of the current fiber. Or, if optional fiber_object is "
"passed, return the status of the specified fiber."
msgstr ""
"Возврат статуса текущего файбера. Или же, если передается необязательный "
"параметр fiber_object, возврат статуса указанного файбера."

msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""
"статус файбера: “dead” (недоступен), “suspended” (приостановлен) или "
"“running” (активен)."

msgid "string"
msgstr "строка"

msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."

msgid "Return information about all fibers."
msgstr "Возврат информации о всех файберах."

msgid ""
"number of context switches (``csw``), backtrace, id, total memory, used memory, name "
"of each fiber."
msgstr ""
"количество переключений контекста (``csw``), обратная трассировка, ID, общий объем "
"памяти, объем используемой памяти, имя каждого файбера."

msgid "table"
msgstr "таблица"

msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."

msgid "Show all alive fibers and their CPU consumption."
msgstr "Отображение всех активных файберов и потребляемых ими ресурсов ЦП."

msgid "a table with two entries: ``cpu`` and ``cpu_misses``"
msgstr "таблица с двумя записями:``cpu`` и ``cpu_misses``"

msgid ""
"``cpu`` itself is a table whose keys are strings containing fiber ids and "
"names. The three metrics available for each fiber are:"
msgstr ""
"``cpu`` это ещё одна таблица, в которой ключами являются строки с ID и "
"именами файберов. Для каждого файбера доступны 3 метрики:"

msgid ""
"``instant`` (in per cent), which indicates the share of time the fiber was "
"executing during the previous event loop iteration."
msgstr ""
"``instant`` (в процентах) показывает долю времени выполнения файбера во "
"время предыдущей итерации цикла событий."

msgid ""
"``average`` (in per cent), which is calculated as an exponential moving "
"average of instant values over all the previous event loop iterations."
msgstr ""
"``average`` (в процентах) рассчитывается как экспоненциальное скользящее "
"среднее мгновенных значений по всем предыдущим итерациям цикла событий."

msgid ""
"``time`` (in seconds), which estimates how much CPU time each fiber spent "
"processing during its lifetime."
msgstr ""
"``time`` (в секундах) определяет процессорное время, потраченное на "
"обработку каждого файбера за время его существования."

msgid ""
"The ``time`` entry is also added to each fiber's output in ``fiber.info()`` "
"(it duplicates the ``time`` entry from ``fiber.top().cpu`` per fiber)."
msgstr ""
"Запись ``time`` также добавляется к выводу информации о файбере с помощью "
"``fiber.info()`` (дублируется запись ``time`` из ``fiber.top().cpu`` для "
"каждого файбера)."

msgid "Note that ``time`` is only counted while ``fiber.top()`` is enabled."
msgstr ""
"Обратите внимание, что подсчет ``time`` ведется, только если активна функция"
" ``fiber.top()``."

msgid ""
"``cpu_misses`` indicates the number of times the TX thread detected it was "
"rescheduled on a different CPU core during the last event loop iteration. "
"``fiber.top()`` uses the CPU timestamp counter to measure each fiber's "
"execution time. However, each CPU core may have its own counter value (you "
"can only rely on counter deltas if both measurements were taken on the same "
"core, otherwise the delta may even get negative). When the TX thread is "
"rescheduled to a different CPU core, Tarantool just assumes the CPU delta "
"was zero for the latest measurement. This lowers the precision of our "
"computations, so the bigger ``cpu misses`` value the lower the precision of "
"``fiber.top()`` results."
msgstr ""
"``cpu_misses`` показывает число раз, когда поток TX регистрировал перенос "
"файбера на другое ядро процессора во время последней итерации цикла "
"обработки событий. ``fiber.top()`` использует счетчик меток времени для "
"измерения времени выполнения каждого файбера. Однако в разных ядрах могут "
"быть разные значения счетчика, поэтому полагаться на разность показаний "
"счетчика можно только в том случае, если оба измерения были проведены на "
"одном и том же ядре; в противном случае разность показаний может даже быть "
"отрицательной. Когда поток TX переносится на другое ядро процессора, "
"Tarantool просто предполагает, что разность показаний была нулевой для "
"последнего измерения. Это снижает точность вычислений, поэтому больше "
"значение ``cpu misses``, тем ниже точность результатов ``fiber.top()``."

msgid "Let's take a look at the example:"
msgstr "Возьмем такой пример:"

msgid ""
"tarantool> fiber.top()\n"
"---\n"
"- cpu:\n"
"    107/lua:\n"
"      instant: 30.967324490456\n"
"      time: 0.351821993\n"
"      average: 25.582738345233\n"
"    104/lua:\n"
"      instant: 9.6473633128437\n"
"      time: 0.110869897\n"
"      average: 7.9693406131877\n"
"    101/on_shutdown:\n"
"      instant: 0\n"
"      time: 0\n"
"      average: 0\n"
"    103/lua:\n"
"      instant: 9.8026528631511\n"
"      time: 0.112641118\n"
"      average: 18.138387232255\n"
"    106/lua:\n"
"      instant: 20.071174377224\n"
"      time: 0.226901357\n"
"      average: 17.077908441831\n"
"    102/interactive:\n"
"      instant: 0\n"
"      time: 9.6858e-05\n"
"      average: 0\n"
"    105/lua:\n"
"      instant: 9.2461986412164\n"
"      time: 0.10657528\n"
"      average: 7.7068458630827\n"
"    1/sched:\n"
"      instant: 20.265286315108\n"
"      time: 0.237095335\n"
"      average: 23.141537169257\n"
"  cpu_misses: 0\n"
"..."
msgstr ""
"tarantool> fiber.top()\n"
"---\n"
"- cpu:\n"
"    107/lua:\n"
"      instant: 30.967324490456\n"
"      time: 0.351821993\n"
"      average: 25.582738345233\n"
"    104/lua:\n"
"      instant: 9.6473633128437\n"
"      time: 0.110869897\n"
"      average: 7.9693406131877\n"
"    101/on_shutdown:\n"
"      instant: 0\n"
"      time: 0\n"
"      average: 0\n"
"    103/lua:\n"
"      instant: 9.8026528631511\n"
"      time: 0.112641118\n"
"      average: 18.138387232255\n"
"    106/lua:\n"
"      instant: 20.071174377224\n"
"      time: 0.226901357\n"
"      average: 17.077908441831\n"
"    102/interactive:\n"
"      instant: 0\n"
"      time: 9.6858e-05\n"
"      average: 0\n"
"    105/lua:\n"
"      instant: 9.2461986412164\n"
"      time: 0.10657528\n"
"      average: 7.7068458630827\n"
"    1/sched:\n"
"      instant: 20.265286315108\n"
"      time: 0.237095335\n"
"      average: 23.141537169257\n"
"  cpu_misses: 0\n"
"..."

msgid ""
"Notice that by default new fibers created due to :ref:`fiber.create <fiber-"
"create>` are named 'lua' so it is better to set their names explicitly via "
":ref:`fiber_object:name('name') <fiber_object-name_set>`."
msgstr ""

msgid ""
"There are several system fibers in ``fiber.top()`` output that might be "
"useful:"
msgstr ""

msgid ""
"``sched`` is a special system fiber. It schedules tasks to other fibers, if "
"any, and also handles some ``libev`` events."
msgstr ""

msgid ""
"It can have high ``instant`` and ``average`` values in ``fiber.top()`` "
"output in two cases:"
msgstr ""

msgid ""
"The instance has almost no load - then practically only ``sched`` is "
"executing, and the other fibers are sleeping. So relative to the other "
"fibers, ``sched`` may have almost 100% load."
msgstr ""

msgid ""
"``sched`` handles a large number of system events. This should not cause "
"performance problems."
msgstr ""

msgid ""
"``main`` fibers process requests that come over the network (iproto "
"requests). There are several such fibers, and new ones are created if "
"needed. When a new request comes in, a free fiber takes it and executes it. "
"The request can be a typical ``select``/``replace``/``delete``/``insert`` or"
" a function call. For example, :ref:`conn:eval() <net_box-eval>` or "
":ref:`conn:call() <net_box-call>`."
msgstr ""

msgid ""
"Enabling ``fiber.top()`` slows down fiber switching by about 15%, so it is "
"disabled by default. To enable it, say ``fiber.top_enable()``. To disable it"
" after you finished debugging, with ``fiber.top_disable()``."
msgstr ""
"Выполнение ``fiber.top()`` замедляет переключение файберов примерно на 15%, "
"поэтому по умолчанию функция отключена. Чтобы включить ее, выполните команду"
" ``fiber.top_enable()``. Чтобы отключить ее по окончании отладки, выполните "
"``fiber.top_disable()``."

msgid ""
"Locate a fiber by its numeric id and cancel it. In other words, "
":ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-find>` "
"and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""
"Поиск файбера по числовому идентификатору и его отмена. Другими словами, "
":ref:`fiber.kill() <fiber-kill>` объединяет в себе :ref:`fiber.find() "
"<fiber-find>` и :ref:`fiber_object:cancel() <fiber_object-cancel>`."

msgid "the id of the fiber to be cancelled."
msgstr "ID файбера для отмены."

msgid "the specified fiber does not exist or cancel is not permitted."
msgstr "указанный файбер отсутствует, или отмена невозможна."

msgid ""
"tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""
"tarantool> fiber.kill(fiber.id()) -- функция с self может вызвать окончание программы\n"
"---\n"
"- error: fiber is cancelled\n"
"..."

msgid ""
"Check if the current fiber has been cancelled and throw an exception if this"
" is the case."
msgstr ""
"Проверка отмены действующего файбера и выдача исключения, если файбер "
"отменен."

msgid ""
"Even if you catch the exception, the fiber will remain cancelled. Most types"
" of calls will check ``fiber.testcancel()``. However, some functions "
"(``id``, ``status``, ``join`` etc.) will return no error. We recommend "
"application developers to implement occasional checks with "
":ref:`fiber.testcancel() <fiber-testcancel>` and to end fiber's execution as"
" soon as possible in case it has been cancelled."
msgstr ""
"Даже при исключении файбер будет отменен. Большинство вызовов проверяют "
"``fiber.testcancel()``. Однако некоторые функции (``id``, ``status``, "
"``join`` и т.д.) не вернут ошибку. Мы рекомендуем разработчикам приложений "
"реализовать случайные проверки :ref:`fiber.testcancel() <fiber-testcancel>` "
"и максимально быстро завершить выполнение файбера, если он был отменен."

msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."

msgid ""
"current system time (in seconds since the epoch) as a Lua number. The time "
"is taken from the event loop clock, which makes this call very cheap, but "
"still useful for constructing artificial tuple keys."
msgstr ""
"текущее системное время (в секундах с начала отсчета) в виде Lua-числа. "
"Время берется из часов событийного цикла, поэтому вызов полезен лишь для "
"создания искусственных ключей кортежа."

msgid "number"
msgstr "число"

msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."

msgid ""
"current system time (in microseconds since the epoch) as a 64-bit integer. "
"The time is taken from the event loop clock."
msgstr ""
"текущее системное время (в микросекундах с начала отсчета) в виде 64-битного"
" целого числа. Время берется из часов событийного цикла."

msgid "cdata"
msgstr "cdata"

msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."

msgid ""
"Get the monotonic time in seconds. It is better to use ``fiber.clock()`` for"
" calculating timeouts instead of :ref:`fiber.time() <fiber-time>` because "
"``fiber.time()`` reports real time so it is affected by system time changes."
msgstr ""
"Получение монотонного времени в секундах. Для вычисления таймаутов лучше "
"использовать ``fiber.clock()``, поскольку :ref:`fiber.time() <fiber-time>` "
"сообщает системное время, а оно может меняться при изменениях в системе."

msgid ""
"a floating-point number of seconds, representing elapsed wall-clock time "
"since some time in the past that is guaranteed not to change during the life"
" of the process"
msgstr ""
"количество секунд в виде числа с плавающей точкой, представляющего собой "
"время с некоторого момента в прошлом, которое гарантированно не изменится в "
"течение всего времени процесса"

msgid ""
"tarantool> start = fiber.clock()\n"
"---\n"
"...\n"
"tarantool> print(start)\n"
"248700.58805\n"
"---\n"
"...\n"
"tarantool> print(fiber.time(), fiber.time()-start)\n"
"1600785979.8291 1600537279.241\n"
"---\n"
"..."
msgstr ""
"tarantool> start = fiber.clock()\n"
"---\n"
"...\n"
"tarantool> print(start)\n"
"248700.58805\n"
"---\n"
"...\n"
"tarantool> print(fiber.time(), fiber.time()-start)\n"
"1600785979.8291 1600537279.241\n"
"---\n"
"..."

msgid "Same as :ref:`fiber.clock() <fiber-clock>` but in microseconds."
msgstr "То же, что и :ref:`fiber.clock() <fiber-clock>`, но в микросекундах."

msgid ""
"a number of seconds as 64-bit integer, representing elapsed wall-clock time "
"since some time in the past that is guaranteed not to change during the life"
" of the process"
msgstr ""
"количество секунд в виде 64-битного целого числа, представляющего собой "
"время с некоторого момента в прошлом, которое гарантированно не изменится в "
"течение всего времени процесса"

msgid ""
"generally this is an object referenced in the return from :ref:`fiber.create"
" <fiber-create>` or :ref:`fiber.self <fiber-self>` or :ref:`fiber.find "
"<fiber-find>`"
msgstr ""
"как правило, это объект, полученный в результате вызова :ref:`fiber.create "
"<fiber-create>`, :ref:`fiber.self <fiber-self>` или :ref:`fiber.find <fiber-"
"find>`"

msgid "id of the fiber."
msgstr "ID файбера."

msgid "``fiber.self():id()`` can also be expressed as ``fiber.id()``."
msgstr "``fiber.self():id()`` может также быть выражен как ``fiber.id()``."

msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."

msgid "name of the fiber."
msgstr "имя файбера."

msgid "``fiber.self():name()`` can also be expressed as ``fiber.name()``."
msgstr ""
"``fiber.self():name()`` может также быть выражен как ``fiber.name()``."

msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."

msgid ""
"Change the fiber name. By default a Tarantool server's interactive-mode "
"fiber is named 'interactive' and new fibers created due to "
":ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers distinct "
"names makes it easier to distinguish them when using :ref:`fiber.info "
"<fiber-info>` and :ref:`fiber.top() <fiber-top>`. Max length is 255."
msgstr ""

msgid "the new name of the fiber."
msgstr "новое имя файбера."

msgid ""
"* ``truncate=true`` -- truncates the name to the max length if it is   too "
"long. If this option is false (the default),   ``fiber.name(new_name)`` "
"fails with an exception if a new name is   too long. The name length limit "
"is ``255``   (since version :doc:`2.4.1 </release/2.4.1>`)."
msgstr ""

msgid ""
"``truncate=true`` -- truncates the name to the max length if it is too long."
" If this option is false (the default), ``fiber.name(new_name)`` fails with "
"an exception if a new name is too long. The name length limit is ``255`` "
"(since version :doc:`2.4.1 </release/2.4.1>`)."
msgstr ""

msgid "nil"
msgstr "nil"

msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."

msgid "Return the status of the specified fiber."
msgstr "Возврат статуса указанного файбера."

msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""
"статус файбера: “dead” (недоступен), “suspended” (приостановлен) или "
"“running” (активен)."

msgid "``fiber.self():status(`` can also be expressed as ``fiber.status()``."
msgstr ""
"``fiber.self():status(`` может также быть выражен как ``fiber.status()``."

msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."

msgid ""
"Cancel a fiber. Running and suspended fibers can be cancelled. After a fiber"
" has been cancelled, attempts to operate on it will cause errors, for "
"example :ref:`fiber_object:name() <fiber_object-name_get>` will cause "
"``error: the fiber is dead``. But a dead fiber can still report its id and "
"status."
msgstr ""
"Отмена файбера. Отменить можно активные и приостановленные файберы. Любые "
"попытки использовать файбер после его отмены вызовут ошибку, например, "
":ref:`fiber_object:name() <fiber_object-name_get>` вызовет ``error: the "
"fiber is dead``. Тем не менее, недоступный файбер может передавать свой ID и"
" статус."

msgid ""
"Possible errors: cancel is not permitted for the specified fiber object."
msgstr "Возможные ошибки: нельзя отменить указанный объект файбера."

msgid ""
"tarantool> fiber.self():cancel() -- kill self, may make program end\n"
"---\n"
"...\n"
"tarantool> fiber.self():cancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"...\n"
"tarantool> fiber.self:id()\n"
"---\n"
"- 163\n"
"...\n"
"tarantool> fiber.self:status()\n"
"---\n"
"- dead\n"
"..."
msgstr ""
"tarantool> fiber.self():cancel() -- завершение работы файбера, может вызвать окончание программы\n"
"---\n"
"...\n"
"tarantool> fiber.self():cancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"...\n"
"tarantool> fiber.self:id()\n"
"---\n"
"- 163\n"
"...\n"
"tarantool> fiber.self:status()\n"
"---\n"
"- dead\n"
"..."

msgid ""
"Local storage within the fiber. It is a Lua table created when it is first "
"accessed. The storage can contain any number of named values, subject to "
"memory limitations. Naming may be done with "
":samp:`{fiber_object}.storage.{name}` or "
":samp:`{fiber_object}.storage['{name}'].` or with a number "
":samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or "
"strings."
msgstr ""
"Локальное хранилище в пределах файбера. Представляет собой Lua-таблицу, "
"создаваемую при первом обращении к ней. Хранилище может содержать любое "
"количество именованных значений при соблюдении ограничений памяти. Правила "
"именования: :samp:`{объект_файбера}.storage.{имя}`, либо "
":samp:`{объект_файбера}.storage['{имя}'].`, либо с числом "
":samp:`{объект_файбера}.storage[{число}]`. Значения могут быть числовыми или"
" строковыми."

msgid ""
"``fiber.storage`` is destroyed when the fiber is finished, regardless of how"
" is it finished -- via :samp:`{fiber_object}:cancel()`, or the fiber's "
"function did 'return'. Moreover, the storage is cleaned up even for pooled "
"fibers used to serve IProto requests. Pooled fibers never really die, but "
"nonetheless their storage is cleaned up after each request. That makes "
"possible to use ``fiber.storage`` as a full featured request-local storage. "
"This behavior is implemented in versions :doc:`2.2.3 </release/2.2.3>`, "
":doc:`2.3.2 </release/2.3.2>`, :doc:`2.4.1 </release/2.4.1>`, and all later "
"versions."
msgstr ""

msgid ""
"This storage may be created for a fiber, no matter how the fiber itself was "
"created -- from C or from Lua. For example, a fiber can be created in C "
"using ``fiber_new()``, then it can insert into a space, which has Lua "
"``on_replace`` triggers, and one of the triggers can create "
"``fiber.storage``. That storage will be deleted when the fiber is stopped."
msgstr ""
"Хранилище можно создать для файбера, созданного как из C, так и из Lua. "
"Например, файбер был создан из C с помощью ``fiber.new``, произвел вставку в"
" спейс, в котором есть Lua-триггеры ``on_replace``, и один из триггеров "
"может создать ``fiber.storage``. Это хранилище будет удалено, когда файбер "
"остановится."

msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the fiber is dead'\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the fiber is dead'\n"
"..."

msgid "See also :doc:`/reference/reference_lua/box_session/storage`."
msgstr "См. также :doc:`/reference/reference_lua/box_session/storage`."

msgid ""
"``fiber_object:set_joinable(true)`` makes a fiber joinable; "
"``fiber_object:set_joinable(false)`` makes a fiber not joinable; the default"
" is false."
msgstr ""
"``fiber_object:set_joinable(true)`` делает файбер доступным для "
"присоединения; ``fiber_object:set_joinable(false)`` делает файбер "
"недоступным для присоединения; по умолчанию, false."

msgid ""
"A joinable fiber can be waited for, with :ref:`fiber_object:join() "
"<fiber_object-join>`."
msgstr ""
"Присоединяемый файбер можно ожидать с помощью :ref:`fiber_object:join() "
"<fiber_object-join>`."

msgid ""
"Best practice is to call ``fiber_object:set_joinable()`` before the fiber "
"function begins to execute, because otherwise the fiber could become 'dead' "
"before ``fiber_object:set_joinable()`` takes effect. The usual sequence "
"could be:"
msgstr ""
"Лучше всего вызвать ``fiber_object:set_joinable()`` до начала выполнения "
"функции с файбером, поскольку в противном случае файбер может стать "
"недоступен до того, как сработает ``fiber_object:set_joinable()``. "
"Правильная последовательность может быть такой:"

msgid ""
"Call ``fiber.new()`` instead of ``fiber.create()`` to create a new "
"fiber_object."
msgstr ""
"Вызов ``fiber.new()`` вместо ``fiber.create()`` для создания нового объекта "
"файбера fiber_object."

msgid ""
"Do not yield at this point, because that will cause the fiber function to "
"begin."
msgstr ""
"Не передавать управление, поскольку это приведет к началу работы функции с "
"файбером."

msgid ""
"Call ``fiber_object:set_joinable(true)`` to make the new fiber_object "
"joinable."
msgstr ""
"Вызов ``fiber_object:set_joinable(true)``, чтобы сделать новый объект "
"файбера fiber_object присоединяемым."

msgid "Now it is safe to yield."
msgstr "Сейчас можно передать управление."

msgid "Call ``fiber_object:join()``."
msgstr "Вызов ``fiber_object:join()``."

msgid ""
"Usually ``fiber_object:join()`` should be called, otherwise the fiber's "
"status may become 'suspended' when the fiber function ends, instead of "
"'dead'."
msgstr ""
"Как правило, следует вызвать ``fiber_object:join()``, в противном случае, "
"статус файбера может перейти в 'suspended' (приостановлен) после выполнения "
"функции, а не 'dead' (недоступен)."

msgid "the boolean value that changes the ``set_joinable`` flag"
msgstr "логическое значение, которое изменяет флаг ``set_joinable``"

msgid "The result of the following sequence of requests is:"
msgstr "Результат следующего ряда запросов:"

msgid ""
"the global variable ``d`` will be 6 (which proves that the function was not "
"executed until after ``d`` was set to 1, when ``fiber.sleep(1)`` caused a "
"yield);"
msgstr ""
"глобальная переменная ``d`` получит значение 6 (что означает, что функция "
"не выполнялась до тех пор, пока значение ``d`` не стало 1, когда "
"``fiber.sleep(1)`` вызвал передачу управления);"

msgid ""
"``fiber.status(fi2)`` will be 'suspended' (which proves that after the "
"function was executed the fiber status did not change to 'dead')."
msgstr ""
"``fiber.status(fi2)`` будет приостановлен 'suspended' (что означает, что "
"после выполнения функции статус файбера не изменился на недоступный 'dead')."

msgid ""
"fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"
msgstr ""
"fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"

msgid ""
"\"Join\" a joinable fiber. That is, let the fiber's function run and wait "
"until the fiber's status is 'dead' (normally a status becomes 'dead' when "
"the function execution finishes). Joining will cause a yield, therefore, if "
"the fiber is currently in a suspended state, execution of its fiber function"
" will resume."
msgstr ""
"\"Присоединение\" присоединяемого файбера. То есть возможность запуска "
"функции с файбером и ожидание перехода файбера в статус недоступности 'dead'"
" (как правило, статус переходит в 'dead', когда заканчивается выполнение "
"функции). Присоединение вызовет передачу управления, таким образом, если "
"файбер находится в приостановленном состоянии, выполнение функции файбера "
"возобновится."

msgid ""
"This kind of waiting is more convenient than going into a loop and "
"periodically checking the status; however, it works only if the fiber was "
"created with :ref:`fiber.new() <fiber-new>` and was made joinable with "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."
msgstr ""
"Такое ожидание более удобно, чем переход в цикл с периодической проверкой "
"статуса; тем не менее, это работает, только если файбер был создан с помощью"
" :ref:`fiber.new() <fiber-new>` и стал доступным для присоединения путем "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."

msgid ""
"two values. The first value is boolean. If the first value is true, then the"
" join succeeded because the fiber's function ended normally and the second "
"result has the return value from the fiber's function. If the first value is"
" false, then the join succeeded because the fiber's function ended "
"abnormally and the second result has the details about the error, which one "
"can unpack in the same way that one unpacks :ref:`a pcall result "
"<error_handling>`."
msgstr ""
"два значения. Первое значение логическое. Если первое значение = true "
"(истина), значит присоединение прошло успешно, поскольку функция файбера "
"была выполнена нормально, а второй результат -- это возвращаемое значение "
"функции файбера. Если же первое значение = false (ложь), значит "
"присоединение не было осуществлено, поскольку выполнение функции файбера "
"было прервано, а второй результат содержит подробную информацию об ошибке, "
"которую можно распаковать так же, как :ref:`результат вызова pcall "
"<error_handling>`."

msgid "boolean +result type, or boolean + struct error"
msgstr ""
"логическое значение +тип результата, или логическое значение + ошибка "
"структуры"

msgid "the first ``fiber.status()`` call returns 'suspended',"
msgstr ""
"первый вызов ``fiber.status()`` возвращает 'suspended' (приостановлен),"

msgid "the ``join()`` call returns true,"
msgstr "вызов ``join()`` возвращает true,"

msgid "the elapsed time is usually 5 seconds, and"
msgstr "как правило, проходит 5 секунд, и"

msgid "the second ``fiber.status()`` call returns 'dead'."
msgstr "второй вызов ``fiber.status()`` возвращает 'dead' (недоступен)."

msgid ""
"This proves that the ``join()`` function blocks the execution "
"of the fiber that called it until the ``fi2`` fiber becomes 'dead'."
msgstr ""
"Как видно, функция ``join()`` блокирует исполнение файбера, из которого она была вызвана, "
"пока файбер ``fi2`` не завершит работу."

msgid ""
"fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"
msgstr ""
"fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"

msgid "Example"
msgstr "Пример"

msgid ""
"Make the function which will be associated with the fiber. This function "
"contains an infinite loop. Each iteration of the loop adds 1 to a global "
"variable named gvar, then goes to sleep for 2 seconds. The sleep causes an "
"implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""
"Создание функции, которая будет связана с файбером. Такая функция содержит "
"бесконечный цикл. Каждая итерация цикла прибавляет 1 к глобальной переменной"
" под названием ``gvar``, а затем уходит в режим ожидания на 2 секунды. "
"Ожидание вызывает неявную передачу управления :ref:`fiber.yield() <fiber-"
"yield>`."

msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."

msgid ""
"Make a fiber, associate function_x with the fiber, and start function_x. It "
"will immediately \"detach\" so it will be running independently of the "
"caller."
msgstr ""
"Создание файбера, ассоциация функции function_x с файбером и запуск "
"function_x. Она сразу же \"отсоединится\", то есть будет работать отдельно "
"от вызывающего метода."

msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."

msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr "Получение ID файбера (fid) для последующего вывода."

msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."

msgid ""
"Pause for a while, while the detached function runs. Then ... Display the "
"fiber id, the fiber status, and gvar (gvar will have gone up a bit depending"
" how long the pause lasted). The status is suspended because the fiber "
"spends almost all its time sleeping or yielding."
msgstr ""
"Небольшая остановка, пока работает отсоединенная функция. Затем ... "
"Отображение идентификатора файбера, статуса файбера и переменной gvar "
"(значение gvar немного увеличится в зависимости от длительности паузы). "
"Статус будет \"suspended\" (приостановлен), потому что файбер практически "
"всё время проводит в режиме ожидания или передачи управления."

msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."

msgid ""
"Pause for a while, while the detached function runs. Then ...  cancel the "
"fiber. Then, once again ... Display the fiber id, the fiber status, and gvar"
" (gvar will have gone up a bit more depending how long the pause lasted). "
"This time the status is dead because the cancel worked."
msgstr ""

msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."

msgid "Example of yield failure"
msgstr "Пример неудачной передачи управления"

msgid ""
"Warning: :ref:`yield() <fiber-yield>` and any function which implicitly "
"yields (such as :ref:`sleep() <fiber-sleep>`) can fail (raise an exception)."
msgstr ""
"Предупреждение: функция :ref:`yield() <fiber-yield>` и любая функция, "
"которая неявно передает управление (например, :ref:`sleep() <fiber-sleep>`),"
" может упасть (выдать исключение)."

msgid ""
"For example, this function has a loop which repeats until :ref:`cancel() "
"<fiber_object-cancel>` happens. The last thing that it will print is 'before"
" yield', which demonstrates that ``yield()`` failed, the loop did not "
"continue until :ref:`testcancel() <fiber-testcancel>` failed."
msgstr ""
"Например, в этой функции есть цикл, который повторяется до тех пор, пока не "
"произойдет :ref:`cancel() <fiber_object-cancel>`. Последнее, что она "
"выведет, это ``before yield``, что свидетельствует о том, что функция "
"``yield()`` не сработала, цикл не продолжался до тех пор, пока не сработала "
"функция :ref:`testcancel() <fiber-testcancel>`."

msgid ""
"fiber = require('fiber')\n"
"function function_name()\n"
"  while true do\n"
"    print('before testcancel')\n"
"    fiber.testcancel()\n"
"    print('before yield')\n"
"    fiber.yield()\n"
"  end\n"
"end\n"
"fiber_object = fiber.create(function_name)\n"
"fiber.sleep(.1)\n"
"fiber_object:cancel()"
msgstr ""
"fiber = require('fiber')\n"
"function function_name()\n"
"  while true do\n"
"    print('before testcancel')\n"
"    fiber.testcancel()\n"
"    print('before yield')\n"
"    fiber.yield()\n"
"  end\n"
"end\n"
"fiber_object = fiber.create(function_name)\n"
"fiber.sleep(.1)\n"
"fiber_object:cancel()"

msgid "Channels"
msgstr "Каналы"

msgid ""
"Call ``fiber.channel()`` to allocate space and get a channel object, which "
"will be called channel for examples in this section."
msgstr ""
"Вызов ``fiber.channel()`` для выделения спейса и получение объекта канала, "
"который будет называться \"channel\" в примерах данного раздела."

msgid ""
"Call the other routines, via channel, to send messages, receive messages, or"
" check channel status."
msgstr ""
"Вызов других процедур по каналу для отправки сообщений, получения сообщений "
"или проверки статуса канала."

msgid ""
"Message exchange is synchronous. The Lua garbage collector will mark or free"
" the channel when no one is using it, as with any other Lua object. Use "
"object-oriented syntax, for example ``channel:put(message)`` rather than "
"``fiber.channel.put(message)``."
msgstr ""
"Обмен сообщения происходит синхронно. Сборщик мусора в Lua отмечает или "
"освобождает канал, когда его никто не использует, как и любой другой Lua-"
"объект. Используйте объектно-ориентированный синтаксис, например "
"``channel:put(message)``, а не ``fiber.channel.put(message)``."

msgid "Create a new communication channel."
msgstr "Создание нового канала связи."

msgid ""
"the maximum number of slots (spaces for ``channel:put`` messages) that can "
"be in use at once. The default is 0."
msgstr ""
"максимальное количество слотов (спейсы для сообщений ``channel:put``), "
"которые можно использовать одновременно. По умолчанию, 0."

msgid "new channel."
msgstr "новый канал."

msgid "userdata, possibly including the string \"channel ...\"."
msgstr "пользовательские данные, возможно включая строку \"channel ...\"."

msgid ""
"Send a message using a channel. If the channel is full, ``channel:put()`` "
"waits until there is a free slot in the channel."
msgstr ""
"Отправка сообщения по каналу связи. Если канал заполнен, ``channel:put()`` "
"ожидает, пока не освободится слот в канале."

msgid "what will be sent, usually a string or number or table"
msgstr "то, что отправляется, как правило, строка, число или таблица"

msgid "maximum number of seconds to wait for a slot to become free. Default: infinity."
msgstr "максимальное количество секунд ожидания, чтобы слот освободился. Значение по умолчанию: бесконечность."

msgid ""
"If timeout is specified, and there is no free slot in the channel for the "
"duration of the timeout, then the return value is ``false``. If the channel "
"is closed, then the return value is ``false``. Otherwise, the return value "
"is ``true``, indicating success."
msgstr ""
"Если указан параметр времени ожидания timeout, и в канале нет свободного "
"слота в течение указанного времени, возвращается значение ``false`` (ложь). "
"Если канал закрыт, возвращается значение ``false``. В остальных случаях "
"возвращается значение ``true`` (истина), которое указывает на успешную "
"отправку."

msgid "boolean"
msgstr "boolean (логический)"

msgid ""
"Close the channel. All waiters in the channel will stop waiting. All "
"following ``channel:get()`` operations will return ``nil``, and all "
"following ``channel:put()`` operations will return ``false``."
msgstr ""
"Закрытие канала. Все, кто находится в режиме ожидания в канале, отключаются."
" Все последующие операции ``channel:get()`` вернут нулевое значение ``nil``,"
" а все последующие операции ``channel:put()`` вернут ``false`` (ложь)."

msgid ""
"Fetch and remove a message from a channel. If the channel is empty, "
"``channel:get()`` waits for a message."
msgstr ""
"Перехват и удаление сообщения из канала. Если канал пуст, ``channel:get()`` "
"будет ожидать сообщения."

msgid "maximum number of seconds to wait for a message. Default: infinity."
msgstr "максимальное количество секунд ожидания сообщения. Значение по умолчанию: бесконечность."

msgid ""
"If timeout is specified, and there is no message in the channel for the "
"duration of the timeout, then the return value is ``nil``. If the channel is"
" closed, then the return value is ``nil``. Otherwise, the return value is "
"the message placed on the channel by ``channel:put()``."
msgstr ""
"Если указан параметр времени ожидания timeout, и в канале нет сообщения в "
"течение указанного времени, возвращается нулевое значение ``nil``. Если "
"канал закрыт, возвращается значение ``nil``. В остальных случаях "
"возвращается сообщение, отправленное на канал с помощью ``channel:put()``."

msgid "usually string or number or table, as determined by ``channel:put``"
msgstr ""
"как правило, строка, число или таблица, как определяет ``channel:put()``"

msgid "Check whether the channel is empty (has no messages)."
msgstr "Проверка пустоты канала (отсутствие сообщений)."

msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr ""
"``true`` (истина), если канал пуст. В противном случае, ``false`` (ложь)."

msgid "Find out how many messages are in the channel."
msgstr "Определение количества сообщений в канале."

msgid "the number of messages."
msgstr "количество сообщений."

msgid "Check whether the channel is full."
msgstr "Проверка заполненности канала."

msgid ""
"``true`` if the channel is full (the number of messages in the channel "
"equals the number of slots so there is no room for a new message). Otherwise"
" ``false``."
msgstr ""
"``true`` (истина), если канал заполнен (количество сообщений в канале равно "
"количеству слотов, то есть нет места для новых сообщений). В противном "
"случае, ``false`` (ложь)."

msgid ""
"Check whether readers are waiting for a message because they have issued "
"``channel:get()`` and the channel is empty."
msgstr ""
"Проверка пустого канала на наличие читателей в состоянии ожидания сообщения "
"после отправки запросов ``channel:get()``."

msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""
"``true`` (истина), если на канале есть читатели в ожидании сообщения. В "
"противном случае, ``false`` (ложь)."

msgid ""
"Check whether writers are waiting because they have issued ``channel:put()``"
" and the channel is full."
msgstr ""
"Проверка полного канала на наличие писателей в состоянии ожидания после "
"отправки запросов ``channel:put()``."

msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""
"``true`` (истина), если на канале есть писатели в состоянии ожидании. В "
"противном случае, ``false`` (ложь)."

msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""
"``true`` (истина), если канал уже закрыт. В противном случае, ``false`` "
"(ложь)."

msgid ""
"This example should give a rough idea of what some functions for fibers "
"should look like. It's assumed that the functions would be referenced in "
":ref:`fiber.create() <fiber-create>`."
msgstr ""
"В данном примере дается примерное представление о том, как должны выглядеть "
"функции для файберов. Предполагается, что на функции ссылается "
":ref:`fiber.create() <fiber-create>`."

msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""
"fiber = require('fiber')\n"
" channel = fiber.channel(10)\n"
" function consumer_fiber()\n"
"     while true do\n"
"         local task = channel:get()\n"
"         ...\n"
"     end\n"
" end\n"
" \n"
" function consumer2_fiber()\n"
"     while true do\n"
"         -- 10 секунд\n"
"         local task = channel:get(10)\n"
"         if task ~= nil then\n"
"             ...\n"
"         else\n"
"             -- время ожидания\n"
"         end\n"
"     end\n"
" end\n"
" \n"
" function producer_fiber()\n"
"     while true do\n"
"         task = box.space...:select{...}\n"
"         ...\n"
"         if channel:is_empty() then\n"
"             -- канал пуст\n"
"         end\n"
" \n"
"         if channel:is_full() then\n"
"             -- канал полон\n"
"         end\n"
" \n"
"         ...\n"
"         if channel:has_readers() then\n"
"             -- есть файберы\n"
"             -- которые ожидают данные\n"
"         end\n"
"         ...\n"
" \n"
"         if channel:has_writers() then\n"
"             -- есть файберы\n"
"             -- которые ожидают читателей\n"
"         end\n"
"         channel:put(task)\n"
"     end\n"
" end\n"
" \n"
" function producer2_fiber()\n"
"     while true do\n"
"         task = box.space...select{...}\n"
"         -- 10 секунд\n"
"         if channel:put(task, 10) then\n"
"             ...\n"
"         else\n"
"             -- время ожидания\n"
"         end\n"
"     end\n"
" end"

msgid "Condition variables"
msgstr "Условные переменные"

msgid ""
"Call ``fiber.cond()`` to create a named condition variable, which will be "
"called 'cond' for examples in this section."
msgstr ""
"Вызов ``fiber.cond()`` используется для создания именованной условной "
"переменной, которая будет называться 'cond' для примеров данного раздела."

msgid ""
"Call ``cond:wait()`` to make a fiber wait for a signal via a condition "
"variable."
msgstr ""
"Вызов ``cond:wait()`` используется, чтобы заставить файбер ожидать сигнал, с"
" помощью условной переменной."

msgid ""
"Call ``cond:signal()`` to send a signal to wake up a single fiber that has "
"executed ``cond:wait()``."
msgstr ""
"Вызов ``cond:signal()`` используется, чтобы отправить сигнал для пробуждения"
" отдельного файбера, который выполнил запрос ``cond:wait()``."

msgid ""
"Call ``cond:broadcast()`` to send a signal to all fibers that have executed "
"``cond:wait()``."
msgstr ""
"Вызов ``cond:broadcast()`` используется для отправки сигнала всем файберам, "
"которые выполнили ``cond:wait()``."

msgid "Create a new condition variable."
msgstr "Создание новой условной переменной."

msgid "new condition variable."
msgstr "новая условная переменная."

msgid "Lua object"
msgstr "Lua-объект"

msgid ""
"Make the current fiber go to sleep, waiting until another fiber invokes the "
"``signal()`` or ``broadcast()`` method on the cond object. The sleep causes "
"an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""
"Перевод файбера в режим ожидания до пробуждения другим файбером с помощью "
"метода ``signal()`` или ``broadcast()``. Переход в режим ожидания вызывает "
"неявную передачу управления :ref:`fiber.yield() <fiber-yield>`."

msgid "number of seconds to wait, default = forever."
msgstr "количество секунд ожидания, по умолчанию = всегда."

msgid ""
"If timeout is provided, and a signal doesn't happen for the duration of the "
"timeout, ``wait()`` returns false. If a signal or broadcast happens, "
"``wait()`` returns true."
msgstr ""
"Если указан параметр времени ожидания timeout, и сигнал не передается в "
"течение указанного времени, ``wait()`` вернет значение false (ложь). Если "
"передается ``signal()`` или ``broadcast()``, ``wait()`` вернет true "
"(истина)."

msgid ""
"Wake up a single fiber that has executed ``wait()`` for the same variable. "
"Does not yield."
msgstr ""
"Пробуждение отдельного файбера, который выполнил ``wait()`` для той же "
"переменной. Не выполняет передачу управления (yield)."

msgid ""
"Wake up all fibers that have executed ``wait()`` for the same variable. Does"
" not yield."
msgstr ""
"Пробуждение всех файберов, которые выполнили ``wait()`` для той же "
"переменной. Не выполняет передачу управления (yield)."

msgid ""
"Assume that a tarantool instance is running and listening for connections on"
" localhost port 3301. Assume that guest users have privileges to connect. We"
" will use the tarantoolctl utility (a utility for administrators) to start "
"two clients."
msgstr ""
"Предположим, что экземпляр Tarantool работает и прослушивает порт 3301 на "
"localhost в ожидании соединений. Также предположим, что пользователи уровня "
"guest имеют права на подключение. Воспользуемся утилитой tarantoolctl "
"(утилитой для администраторов), чтобы запустить два клиента."

msgid "On terminal #1, say"
msgstr "В первом терминале введите:"

msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"

msgid ""
"The job will hang because ``cond:wait()`` -- without an optional timeout "
"argument -- will go to sleep until the condition variable changes."
msgstr ""
"Задача повиснет, поскольку ``cond:wait()`` -- без дополнительного аргумента "
"времени ожидания timeout -- уйдет в режим ожидания до изменения условной "
"переменной."

msgid "On terminal #2, say"
msgstr "Во втором терминале введите:"

msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"

msgid ""
"Now look again at terminal #1. It will show that the waiting stopped, and "
"the ``cond:wait()`` function returned ``true``."
msgstr ""
"Теперь снова взгляните на терминал №1. Он покажет, что ожидание "
"прекратилось, и функция ``cond:wait()`` вернула значение ``true``."

msgid ""
"This example depended on the use of a global conditional variable with the "
"arbitrary name ``cond``. In real life, programmers would make sure to use "
"different conditional variable names for different applications."
msgstr ""
"В данном примере показана зависимость от использования глобальной условной "
"переменной с произвольным именем ``cond``. В реальной жизни разработчики "
"следят за использованием различных имен для условных переменных в разных "
"приложениях."
