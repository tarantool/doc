
msgid "Module http"
msgstr "Модуль http"

#, fuzzy
msgid ""
"The ``http`` module, specifically the ``http.client`` submodule, provides "
"the functionality of an HTTP client with support for HTTPS and keepalive. "
"The HTTP client uses the `libcurl <https://curl.haxx.se/libcurl/>`_ library "
"under the hood and takes into account the `environment variables "
"<https://curl.haxx.se/libcurl/c/libcurl-env.html>`_ libcurl understands."
msgstr ""
"Модуль ``http``, в частности вложенный модуль ``http.client`` , обеспечивает"
" функциональные возможности HTTP-клиента с поддержкой HTTPS и механизмом "
"поддержания в активном состоянии keepalive. Модуль использует процедуры из "
"библиотеки `libcurl <https://curl.haxx.se/libcurl/>`_."

msgid "Creating a client"
msgstr ""

#, fuzzy
msgid ""
"To create an HTTP client, call the :ref:`http.client.new() <http-new>` "
"function:"
msgstr ":ref:`http.client.new() <http-new>`"

#, fuzzy
msgid "local http_client = require('http.client').new()\n"
msgstr ""
"tarantool> http_client = require('http.client').new({max_connections = 5})\n"
"---\n"
"..."

msgid ""
"Optionally, this function can accept specific client configuration options."
msgstr ""

msgid "Making requests"
msgstr ""

msgid ""
"After :ref:`creating the client <creating_client>`, you can make HTTP "
"requests."
msgstr ""

msgid "HTTP method"
msgstr ""

msgid ""
"The main way of making HTTP requests is the :ref:`request <client_object-"
"request>` method, which accepts the following arguments:"
msgstr ""

msgid "An HTTP method, such as ``GET``, ``POST``, ``PUT``, and so on."
msgstr ""

msgid ""
"A request URL. You can use the :ref:`uri <uri-module>` module to construct a"
" URL from its components."
msgstr ""

msgid ""
"(Optional) a request body for the ``POST``, ``PUT``, and ``PATCH`` methods."
msgstr ""

msgid ""
"(Optional) request options, such as request headers, SSL settings, and so "
"on."
msgstr ""

msgid ""
"The example below shows how to make the ``GET`` request to the "
"``https://httpbin.org/get`` URL:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:request('GET', 'https://httpbin.org/get')\n"
msgstr ""

msgid ""
"In addition to ``request``, the HTTP client provides the API for particular "
"HTTP methods: :ref:`get <client_object-get>`, :ref:`post <client_object-"
"post>`, :ref:`put <client_object-put>`, and so on. For example, you can "
"replace the request above by calling ``get`` as follows:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:get('https://httpbin.org/get')\n"
msgstr ""

#, fuzzy
msgid "Query parameters"
msgstr "Параметры"

msgid ""
"To add query string parameters, use the :ref:`params <request_options-"
"params>` option exposed by the :ref:`request_options <request_options>` "
"object:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:get('https://httpbin.org/get', {\n"
"    params = { page = 1 },\n"
"})\n"
"print('URL: '..response.url)\n"
msgstr ""

msgid ""
"In the example above, the requested URL is "
"``https://httpbin.org/get?page=1``."
msgstr ""

msgid ""
"If a parameter name or value contains a reserved character (for example, "
"``&`` or ``=``), the HTTP client `encodes "
"<https://en.wikipedia.org/wiki/URL_encoding>`_ a query string."
msgstr ""

msgid "Headers"
msgstr ""

msgid ""
"To add headers to the request, use the :ref:`headers <request_options-"
"headers>` option:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:get('https://httpbin.org/headers', {\n"
"    headers = {\n"
"        ['User-Agent'] = 'Tarantool HTTP client',\n"
"        ['Authorization'] = 'Bearer abc123'\n"
"    }\n"
"})\n"
"print('Authorization: '..response:decode()['headers']['Authorization'])\n"
msgstr ""

msgid "Cookies"
msgstr ""

msgid ""
"You can add cookies to the request using the :ref:`headers <request_options-"
"headers>` option:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:get('https://httpbin.org/cookies', {\n"
"    headers = {\n"
"        ['Cookie'] = 'session_id=abc123; csrftoken=u32t4o;',\n"
"    }\n"
"})\n"
"print(response.body)\n"
msgstr ""

msgid ""
"To learn how to obtain cookies passed in the ``Set-Cookie`` response header,"
" see :ref:`Response cookies <response_cookies>`."
msgstr ""

msgid "Body"
msgstr ""

msgid "Serialization"
msgstr ""

msgid ""
"The HTTP client automatically serializes the content in a specific format "
"when sending a request based on the specified ``Content-Type`` header. By "
"default, the client uses the ``application/json`` content type and sends "
"data serialized as JSON:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:post('https://httpbin.org/anything', {\n"
"    user_id = 123,\n"
"    user_name = 'John Smith'\n"
"})\n"
"print('Posted data: '..response:decode()['data'])\n"
msgstr ""

msgid "The body for the request above might look like this:"
msgstr ""

msgid ""
"{\n"
"    \"user_id\": 123,\n"
"    \"user_name\": \"John Smith\"\n"
"}"
msgstr ""

msgid ""
"To send data in the YAML or MsgPack format, set the ``Content-Type`` header "
"explicitly to ``application/yaml`` or ``application/msgpack``, for example:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:post('https://httpbin.org/anything', {\n"
"    user_id = 123,\n"
"    user_name = 'John Smith'\n"
"}, {\n"
"    headers = {\n"
"        ['Content-Type'] = 'application/yaml',\n"
"    }\n"
"})\n"
"print('Posted data:\\n'..response:decode()['data'])\n"
msgstr ""

msgid "In this case, the request body is serialized to YAML:"
msgstr ""

msgid ""
"user_id: 123\n"
"user_name: John Smith"
msgstr ""

#, fuzzy
msgid "Form parameters"
msgstr "Параметры"

msgid ""
"To send form parameters using the ``application/x-www-form-urlencoded`` "
"type, use the :ref:`params <request_options-params>` option:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:post('https://httpbin.org/anything', nil, {\n"
"    params = { user_id = 123, user_name = 'John Smith' },\n"
"})\n"
"print('User ID: '..response:decode()['form']['user_id'])\n"
msgstr ""

msgid "Streaming upload"
msgstr ""

msgid ""
"The HTTP client supports chunked writing of request data. This can be "
"achieved as follows:"
msgstr ""

msgid ""
"Set the :ref:`chunked <request_options-chunked>` option to ``true``. In this"
" case, a request method returns :ref:`io_object <io_object>` instead of "
":ref:`response_object <response_object>`."
msgstr ""

msgid ""
"Use the :ref:`io_object.write() <io_object-write>` method to write a chunk "
"of data."
msgstr ""

msgid ""
"Call the :ref:`io_object.finish() <io_object-finish>` method to finish "
"writing data and make a request."
msgstr ""

msgid "The example below shows how to upload data in two chunks:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local json = require('json')\n"
"\n"
"local io = http_client:post('https://httpbin.org/anything', nil, {chunked = true})\n"
"io:write('Data part 1')\n"
"io:write('Data part 2')\n"
"io:finish()\n"
"response = io:read('\\r\\n')\n"
"decoded_data = json.decode(response)\n"
"print('Posted data: '..decoded_data['data'])\n"
msgstr ""

msgid "Receiving responses"
msgstr ""

msgid ""
"All methods that are used to :ref:`make an HTTP request <making_requests>` "
"(``request``, ``get``, ``post``, etc.) receive :ref:`response_object "
"<response_object>`. ``response_object`` exposes the API required to get a "
"response body and obtain response parameters, such as a status code, "
"headers, and so on."
msgstr ""

msgid "Status code"
msgstr ""

msgid ""
"To get a response's status code and text, use the "
":ref:`response_object.status <response_object-status>` and "
":ref:`response_object.reason <response_object-reason>` options, "
"respectively:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:get('https://httpbin.org/get')\n"
"print('Status: '..response.status..' '.. response.reason)\n"
msgstr ""

msgid ""
"The :ref:`response_object.headers <response_object-headers>` option returns "
"a set of response headers. The example below shows how to obtain the "
"``ETag`` header value:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:get('https://httpbin.org/etag/7c876b7e')\n"
"print('ETag header value: '..response.headers['etag'])\n"
msgstr ""

msgid ""
"To obtain response cookies, use :ref:`response_object.cookies "
"<response_object-cookies>`. This option returns a Lua table where a cookie "
"name is the key. The value is an array of two elements where the first one "
"is the cookie value and the second one is an array with the cookie's "
"options."
msgstr ""

msgid "The example below shows how to obtain the ``session_id`` cookie value:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:get('https://httpbin.org/cookies/set?session_id=abc123&csrftoken=u32t4o&', {follow_location = false})\n"
"print(\"'session_id' cookie value: \"..response.cookies['session_id'][1])\n"
msgstr ""

#, fuzzy
msgid "Response body"
msgstr "``body`` -- тело сообщения-ответа"

msgid "Deserialization"
msgstr ""

msgid ""
"The HTTP client can deserialize response data to a Lua object based on the "
"``Content-Type`` response header value. To deserialize data, call the "
":ref:`response_object.decode() <response_object-decode>` method. In the "
"example below, the JSON response is deserialized into a Lua object:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:get('https://httpbin.org/json')\n"
"local document = response:decode()\n"
"print(\"'title' value: \"..document['slideshow']['title'])\n"
msgstr ""

msgid "The following content types are supported out of the box:"
msgstr ""

msgid "``application/json``"
msgstr ""

msgid "``application/msgpack``"
msgstr ""

msgid "``application/yaml``"
msgstr ""

msgid ""
"If the response doesn't have the ``Content-Type`` header, the client uses "
"``application/json``."
msgstr ""

msgid ""
"To deserialize other content types, you need to provide a custom "
"deserializer using the :ref:`client_object.decoders <client_object-"
"decoders>` property. In the example below, ``application/xml`` responses are"
" decoded using the ``luarapidxml`` library:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local xml = require(\"luarapidxml\")\n"
"\n"
"http_client.decoders = {\n"
"    ['application/xml'] = function(body, _content_type)\n"
"        return xml.decode(body)\n"
"    end,\n"
"}\n"
"\n"
"local response = http_client:get('https://httpbin.org/xml')\n"
"local document = response:decode()\n"
"print(\"'title' value: \"..document['attr']['title'])\n"
msgstr ""

msgid "The output for the code sample above should look as follows:"
msgstr ""

msgid "'title' value: Sample Slide Show"
msgstr ""

msgid "Decompressing"
msgstr ""

msgid ""
"The HTTP client can automatically decompress a response body based on the "
"``Content-Encoding`` header value. To enable this capability, pass the "
"required formats using the :ref:`request_options.accept_encoding "
"<request_options-accept_encoding>` option:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:get('https://httpbin.org/gzip', {accept_encoding = \"br, gzip, deflate\"})\n"
"print('Is response gzipped: '..tostring(response:decode()['gzipped']))\n"
msgstr ""

msgid "Streaming download"
msgstr ""

msgid ""
"The HTTP client supports chunked reading of request data. This can be "
"achieved as follows:"
msgstr ""

msgid ""
"Use the :ref:`io_object.read() <io_object-read>` method to read data in "
"chunks of a specified length or up to a specific delimiter."
msgstr ""

msgid ""
"Call the :ref:`io_object.finish() <io_object-finish>` method to finish "
"reading data."
msgstr ""

msgid ""
"The example below shows how to get chunks of a JSON response sequentially "
"instead of waiting for the entire response:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local json = require('json')\n"
"\n"
"local io = http_client:get('https://httpbin.org/stream/5', {chunked = true})\n"
"local chunk_ids = ''\n"
"while data ~= '' do\n"
"    local data = io:read('\\n')\n"
"    if data == '' then break end\n"
"    local decoded_data = json.decode(data)\n"
"    chunk_ids = chunk_ids..decoded_data['id']..' '\n"
"end\n"
"print('IDs of received chunks: '..chunk_ids)\n"
"io:finish()\n"
msgstr ""

msgid "Redirects"
msgstr ""

msgid ""
"By default, the HTTP client redirects to a URL provided in the ``Location`` "
"header of a ``3xx`` response. If required, you can disable redirection using"
" the :ref:`follow_location <request_options-follow_location>` option:"
msgstr ""

msgid ""
"local http_client = require('http.client').new()\n"
"local response = http_client:get('https://httpbin.org/cookies/set?session_id=abc123&csrftoken=u32t4o&', {follow_location = false})\n"
msgstr ""

msgid "API Reference"
msgstr ""

msgid "**Functions**"
msgstr ""

msgid ":ref:`http.client.new() <http-new>`"
msgstr ":ref:`http.client.new() <http-new>`"

msgid "Create an HTTP client instance"
msgstr "Создание экземпляра HTTP-клиента"

msgid "**Objects**"
msgstr ""

#, fuzzy
msgid ":ref:`client_options <client_options>`"
msgstr ":ref:`client_object:stat() <client_object-stat>`"

msgid "Configuration options of the client"
msgstr ""

#, fuzzy
msgid ":ref:`client_object <client_object>`"
msgstr ":ref:`client_object:stat() <client_object-stat>`"

#, fuzzy
msgid "An HTTP client instance"
msgstr "новый экземпляр HTTP-клиента"

msgid ":ref:`request_options <request_options>`"
msgstr ""

msgid "Options passed to a request"
msgstr ""

#, fuzzy
msgid ":ref:`response_object <response_object>`"
msgstr ":ref:`client_object:stat() <client_object-stat>`"

msgid "A response object"
msgstr ""

#, fuzzy
msgid ":ref:`io_object <io_object>`"
msgstr ":ref:`client_object:stat() <client_object-stat>`"

msgid "An IO object used to read/write data in chunks"
msgstr ""

#, fuzzy
msgid "http.client.new()"
msgstr ":ref:`http.client.new() <http-new>`"

#, fuzzy
msgid "Create an HTTP client instance."
msgstr "Создание экземпляра HTTP-клиента"

msgid "Parameters"
msgstr "Параметры"

msgid ""
"configuration options of the client (see :ref:`client_options "
"<client_options>`)"
msgstr ""

msgid "return"
msgstr "возвращает"

#, fuzzy
msgid "a new HTTP client instance (see :ref:`client_object <client_object>`)"
msgstr ":ref:`client_object:stat() <client_object-stat>`"

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "userdata"
msgstr "пользовательские данные"

msgid "**Example**"
msgstr "**Пример:**"

msgid "client_options"
msgstr ""

msgid ""
"Configuration options of the client. These options can be passed to the "
":ref:`http.client.new() <http-new>` function."
msgstr ""

#, fuzzy
msgid ""
"Specifies the maximum number of entries in the cache. This option affects "
"libcurl `CURLMOPT_MAXCONNECTS "
"<https://curl.haxx.se/libcurl/c/CURLMOPT_MAXCONNECTS.html>`_. The default is"
" ``-1``."
msgstr ""
"``max_connections`` -- это максимальное количество записей в кэше, которое "
"влияет на `CURLMOPT_MAXCONNECTS "
"<https://curl.haxx.se/libcurl/c/CURLMOPT_MAXCONNECTS.html>`_ в libcurl. По "
"умолчанию -1."

#, fuzzy
msgid "local http_client = require('http.client').new({max_connections = 5})"
msgstr ""
"tarantool> http_client = require('http.client').new({max_connections = 5})\n"
"---\n"
"..."

msgid "**Note**"
msgstr ""

msgid ""
"Do not set ``max_connections`` to less than ``max_total_connections`` unless"
" you are confident about your actions. If ``max_connections`` is less than "
"``max_total_connections``, libcurl doesn't reuse sockets in some cases for "
"requests that go to the same host. If the limit is reached and a new request"
" occurs, then libcurl creates a new socket first, sends the request, waits "
"for the first connection to be free, and closes it to avoid exceeding the "
"``max_connections`` cache size. In the worst case, libcurl creates a new "
"socket for every request, even if all requests go to the same host."
msgstr ""

#, fuzzy
msgid ""
"Specifies the maximum number of active connections. This option affects "
"libcurl `CURLMOPT_MAX_TOTAL_CONNECTIONS "
"<https://curl.haxx.se/libcurl/c/CURLMOPT_MAX_TOTAL_CONNECTIONS.html>`_."
msgstr ""
"``max_connections`` -- это максимальное количество записей в кэше, которое "
"влияет на `CURLMOPT_MAXCONNECTS "
"<https://curl.haxx.se/libcurl/c/CURLMOPT_MAXCONNECTS.html>`_ в libcurl. По "
"умолчанию -1."

#, fuzzy
msgid ""
"You may want to control the maximum number of sockets that a particular HTTP"
" client uses simultaneously. If a system passes many requests to distinct "
"hosts, then libcurl cannot reuse sockets. In this case, setting "
"``max_total_connections`` may be useful since it causes curl to avoid "
"creating too many sockets, which would not be used anyway."
msgstr ""
"1. Возможно, вы захотите регулировать максимальное количество сокетов, "
"которые конкретный http-клиент использует одновременно. Если система "
"передает много запросов различным хостам, то libcurl не может повторно "
"использовать сокеты. В этом случае важен параметр``max_total_connections``, "
"поскольку он запретит curl создавать слишком большое количество сокетов, "
"которые все равно не будут использоваться."

msgid "client_object"
msgstr ""

msgid ""
"An HTTP client instance that exposes the API for :ref:`making requests "
"<making_requests>`. To create the client, call :ref:`http.client.new() "
"<http-new>`."
msgstr ""

msgid "Make an HTTP request and receive a response."
msgstr ""

msgid ""
"a request HTTP method. Possible values: ``GET``, ``POST``, ``PUT``, "
"``PATCH``, ``OPTIONS``, ``HEAD``, ``DELETE``, ``TRACE``, ``CONNECT``."
msgstr ""

msgid "a request URL, for example, ``https://httpbin.org/get``"
msgstr ""

msgid "a request body (see :ref:`Body <request_body>`)"
msgstr ""

msgid "request options (see :ref:`request_options <request_options>`)"
msgstr ""

msgid "This method returns one of the following objects:"
msgstr ""

msgid ""
":ref:`io_object <io_object>` if :ref:`request_options.chunked "
"<request_options-chunked>` is set to ``true``"
msgstr ""

msgid "table"
msgstr "таблица"

msgid ""
"**See also:** :ref:`Making requests <making_requests>`, :ref:`Receiving "
"responses <receiving_responses>`"
msgstr ""

msgid "Make a ``GET`` request and receive a response."
msgstr ""

msgid "This method might return one of the following objects:"
msgstr ""

msgid "Make a ``POST`` request and receive a response."
msgstr ""

msgid "a request URL, for example, ``https://httpbin.org/post``"
msgstr ""

msgid "Make a ``PUT`` request and receive a response."
msgstr ""

msgid "a request URL, for example, ``https://httpbin.org/put``"
msgstr ""

msgid "Make a ``PATCH`` request and receive a response."
msgstr ""

msgid "a request URL, for example, ``https://httpbin.org/patch``"
msgstr ""

msgid "Make a ``DELETE`` request and receive a response."
msgstr ""

msgid "a request URL, for example, ``https://httpbin.org/delete``"
msgstr ""

msgid "Make a ``HEAD`` request and receive a response."
msgstr ""

msgid "Make an ``OPTIONS`` request and receive a response."
msgstr ""

msgid "Make a ``TRACE`` request and receive a response."
msgstr ""

msgid "Make a ``CONNECT`` request and receive a response."
msgstr ""

msgid "a request URL, for example, ``server.example.com:80``"
msgstr ""

#, fuzzy
msgid "Get a table with statistics for the HTTP client:"
msgstr "Получение таблицы со статистикой"

#, fuzzy
msgid "``active_requests`` -- the number of currently executing requests"
msgstr "``active_requests`` -- количество активно выполняемых запросов"

#, fuzzy
msgid ""
"``sockets_added`` -- the total number of sockets added into an event loop"
msgstr ""
"``sockets_added`` -- общее количество сокетов, добавленных в событийный цикл"

#, fuzzy
msgid "``sockets_deleted`` -- the total number of sockets from an event loop"
msgstr ""
"``sockets_deleted`` -- общее количество сокетов, удаленных из событийного "
"цикла"

#, fuzzy
msgid "``total_requests`` -- the total number of requests"
msgstr "``total_requests`` -- общее количество запросов"

#, fuzzy
msgid ""
"``http_200_responses`` -- the total number of requests that returned HTTP "
"``200 OK`` responses"
msgstr ""
"``http_200_responses`` -- общее количество запросов, которые вернули код "
"состояния HTTP 200"

#, fuzzy
msgid ""
"``http_other_responses`` -- the total number of requests that returned "
"non-``200 OK`` responses"
msgstr ""
"``http_other_responses`` -- общее количество запросов, которые не вернули "
"код состояния HTTP 200"

#, fuzzy
msgid ""
"``failed_requests`` -- the total number of failed requests, including "
"system, curl, and HTTP errors"
msgstr ""
"``failed_requests`` -- общее количество невыполненных запросов, включая "
"системные ошибки, ошибки curl и HTTP-ошибки"

msgid "**Since:** :doc:`2.11.0 </release/2.11.0>`"
msgstr ""

msgid ""
"Decoders used to deserialize response data based on the ``Content-Type`` "
"header value. Learn more from :ref:`Deserialization "
"<response_deserialization>`."
msgstr ""

msgid "request_options"
msgstr ""

msgid ""
"Options passed to a request method (:ref:`request <client_object-request>`, "
":ref:`get <client_object-get>`, :ref:`post <client_object-post>`, and so "
"on)."
msgstr ""

msgid "**See also:** :ref:`Making requests <making_requests>`"
msgstr ""

#, fuzzy
msgid "The path to an SSL certificate file to verify the peer with."
msgstr ""
"``ca_file`` -- путь к SSL-сертификату для проверки подключенного узла."

msgid "string"
msgstr ""

#, fuzzy
msgid ""
"The path to a directory holding one or more certificates to verify the peer "
"with."
msgstr ""
"``ca_path`` -- путь к директории, где хранятся один или более сертификатов "
"для проверки подключенного узла."

msgid ""
"Specifies whether an HTTP client should return the full response "
"(:ref:`response_object <response_object>`) or an IO object (:ref:`io_object "
"<io_object>`) used for streaming download/upload."
msgstr ""

msgid "boolean"
msgstr ""

msgid ""
"**See also:** :ref:`Streaming download <response_streaming_download>`, "
":ref:`Streaming upload <request_streaming_upload>`"
msgstr ""

msgid "A table of :ref:`HTTP headers <request_headers>` passed to a request."
msgstr ""

msgid ""
"A table of parameters passed to a request. The behavior of this option "
"depends on the request type, for example:"
msgstr ""

msgid ""
"For a :ref:`GET <client_object-get>` request, this option specifies "
":ref:`query string parameters <request_query_parameters>`."
msgstr ""

msgid ""
"For a :ref:`POST <client_object-post>` request, this option specifies "
":ref:`form parameters <request_form_parameters>` to be sent using the "
"``application/x-www-form-urlencoded`` type."
msgstr ""

msgid ""
"A delay (in seconds) the operating system waits while the connection is idle"
" before sending keepalive probes."
msgstr ""

msgid "integer"
msgstr ""

msgid ""
"**See also:** `CURLOPT_TCP_KEEPIDLE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_, "
":ref:`keepalive_interval <request_options-keepalive_interval>`"
msgstr ""

msgid ""
"The interval (in seconds) the operating system waits between sending "
"keepalive probes. If both :ref:`keepalive_idle <request_options-"
"keepalive_idle>` and ``keepalive_interval`` are set, then Tarantool also "
"sets the HTTP keepalive headers: ``Connection:Keep-Alive`` and ``Keep-"
"Alive:timeout=<keepalive_idle>``. Otherwise, Tarantool sends "
"``Connection:close``."
msgstr ""

msgid ""
"**See also:** `CURLOPT_TCP_KEEPINTVL "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_"
msgstr ""

#, fuzzy
msgid ""
"The average transfer speed in bytes per second that the transfer should be "
"below during \"low speed time\" seconds for the library to consider it to be"
" too slow and abort."
msgstr ""
"``low_speed_limit`` -- установка \"предела низкой скорости\" -- средней "
"скорости передачи в байтах в секунду, ниже которой должна быть скорость "
"передачи, чтобы библиотека посчитала работу слишком медленной и завершила "
"ее. См. также    `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_."

#, fuzzy
msgid ""
"**See also:** `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"
msgstr ""
"``ssl_cert`` -- путь к файлу клиентского SSL-сертификата. См. также    "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_."

#, fuzzy
msgid ""
"The time that the transfer speed should be below the \"low speed limit\" for"
" the library to consider it too slow and abort."
msgstr ""
"``low_speed_time`` -- установка \"времени работы с низкой скоростью\" -- "
"времени, в течение которого скорость передачи должна быть ниже \"предела "
"низкой скорости\", чтобы библиотека посчитала работу слишком медленной и "
"завершила ее. См. также    `CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_."

#, fuzzy
msgid ""
"**See also:** `CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"
msgstr ""
"``ssl_cert`` -- путь к файлу клиентского SSL-сертификата. См. также    "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_."

#, fuzzy
msgid ""
"The maximum length of a header name. If a header name length exceeds this "
"value, it is truncated to this length. The default value is ``32``."
msgstr ""
"``max_header_name_len`` -- максимальная длина имени заголовка. Если имя "
"заголовка больше данного значения, оно усекается до такой длины. По "
"умолчанию, ``32``."

msgid ""
"Specify whether the HTTP client follows redirect URLs provided in the "
"``Location`` header for ``3xx`` responses. When a non-``3xx`` response is "
"received, the client returns it as a result. If you set this option to "
"``false``, the client returns the first ``3xx`` response."
msgstr ""

msgid "**See also:** :ref:`Redirects <response_redirect>`"
msgstr ""

msgid ""
"A comma-separated list of hosts that do not require proxies, or ``*``, or "
"``''``."
msgstr ""

msgid ""
"Set :samp:`no_proxy = {host} [, {host} ...]` to specify hosts that can be "
"reached without requiring a proxy, even if ``proxy`` is set to a non-blank "
"value and/or if a proxy-related environment variable has been set."
msgstr ""

msgid ""
"Set ``no__proxy = '*'`` to specify that all hosts can be reached without "
"requiring a proxy, which is equivalent to setting ``proxy=''``."
msgstr ""

msgid ""
"Set ``no_proxy = ''`` to specify that no hosts can be reached without "
"requiring a proxy, even if a proxy-related environment variable "
"(``HTTP_PROXY``) is used."
msgstr ""

msgid ""
"If ``no_proxy`` is not set, then a proxy-related environment variable "
"(``HTTP_PROXY``) may be used."
msgstr ""

#, fuzzy
msgid ""
"**See also:** `CURLOPT_NOPROXY "
"<https://curl.haxx.se/libcurl/c/CURLOPT_NOPROXY.html>`_"
msgstr ""
"``ssl_cert`` -- путь к файлу клиентского SSL-сертификата. См. также    "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_."

msgid "A proxy server host or IP address, or ``''``."
msgstr ""

msgid ""
"If ``proxy`` is a host or IP address, then it may begin with a scheme, for "
"example, ``https://`` for an HTTPS proxy or ``http://`` for an HTTP proxy."
msgstr ""

msgid ""
"If ``proxy`` is set to ``''`` an empty string, then proxy use is disabled, "
"and no proxy-related environment variable is used."
msgstr ""

msgid ""
"If ``proxy`` is not set, then a proxy-related environment variable may be "
"used, such as ``HTTP_PROXY`` or ``HTTPS_PROXY`` or ``FTP_PROXY``, or "
"``ALL_PROXY`` if the protocol can be any protocol."
msgstr ""

#, fuzzy
msgid ""
"**See also:** `CURLOPT_PROXY "
"<https://curl.haxx.se/libcurl/c/CURLOPT_PROXY.html>`_"
msgstr ""
"``ssl_cert`` -- путь к файлу клиентского SSL-сертификата. См. также    "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_."

msgid ""
"A proxy server port. The default is ``443`` for an HTTPS proxy and ``1080`` "
"for a non-HTTPS proxy."
msgstr ""

#, fuzzy
msgid ""
"**See also:** `CURLOPT_PROXYPORT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_PROXYPORT.html>`_"
msgstr ""
"``ssl_cert`` -- путь к файлу клиентского SSL-сертификата. См. также    "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_."

msgid ""
"A proxy server username and password. This option might have one of the "
"following formats:"
msgstr ""

msgid ":samp:`proxy_user_pwd = {user_name}:`"
msgstr ""

msgid ":samp:`proxy_user_pwd = :{password}`"
msgstr ""

msgid ":samp:`proxy_user_pwd = {user_name}:{password}`"
msgstr ""

#, fuzzy
msgid ""
"**See also:** `CURLOPT_USERPWD "
"<https://curl.haxx.se/libcurl/c/CURLOPT_USERPWD.html>`_"
msgstr ""
"``ssl_cert`` -- путь к файлу клиентского SSL-сертификата. См. также    "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_."

#, fuzzy
msgid "A path to an SSL client certificate file."
msgstr ""
"``ca_file`` -- путь к SSL-сертификату для проверки подключенного узла."

#, fuzzy
msgid ""
"**See also:** `CURLOPT_SSLCERT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_"
msgstr ""
"``ssl_cert`` -- путь к файлу клиентского SSL-сертификата. См. также    "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_."

msgid "A path to a private key file for a TLS and SSL client certificate."
msgstr ""

#, fuzzy
msgid ""
"**See also:** `CURLOPT_SSLKEY "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_"
msgstr ""
"``ssl_cert`` -- путь к файлу клиентского SSL-сертификата. См. также    "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_."

#, fuzzy
msgid ""
"The number of seconds to wait for a curl API read request before timing out."
" The default timeout is set to infinity (``36586400100`` seconds)."
msgstr ""
"``timeout`` -- количество секунд ожидания API-запроса curl на чтение до "
"превышения времени ожидания. Значение по умолчанию -- бесконечность "
"(36586400100 секунд)."

msgid ""
"A socket name to use instead of an Internet address for a local connection."
msgstr ""

#, fuzzy
msgid "**Example:** ``/tmp/unix_domain_socket.sock``"
msgstr "box.cfg{listen='/tmp/unix_domain_socket.sock'}"

#, fuzzy
msgid "Turn on/off a verbose mode."
msgstr ""
"``verbose`` -- включение/отключение режима отображения подробной информации."

msgid ""
"Enable verification of the certificate's name (CN) against the specified "
"host."
msgstr ""

#, fuzzy
msgid ""
"**See also:** `CURLOPT_SSL_VERIFYHOST "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_"
msgstr ""
"``verify_host`` -- включение/отключение проверки имени сертификата (CN) для "
"хоста. См. также    `CURLOPT_SSL_VERIFYHOST "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_."

msgid "Set on/off verification of the peer's SSL certificate."
msgstr ""

#, fuzzy
msgid ""
"**See also:** `CURLOPT_SSL_VERIFYPEER "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_"
msgstr ""
"``verify_peer`` --  включение/отключение проверки SSL-сертификата "
"подключенного узла. См. также `CURLOPT_SSL_VERIFYPEER "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_."

msgid ""
"Enable :ref:`decompression <response_decompressing>` of an HTTP response "
"data based on the specified ``Accept-Encoding`` request header. You can pass"
" the following values to this option:"
msgstr ""

msgid ""
"``''`` -- if an empty string is passed, the ``Accept-Encoding`` contains all"
" the supported encodings (``identity``, ``deflate``, ``gzip``, and ``br``)."
msgstr ""

msgid ""
"``br, gzip, deflate`` -- a comma-separated list of encodings passed in "
"``Accept-Encoding``."
msgstr ""

#, fuzzy
msgid ""
"**See also:** `CURLOPT_ACCEPT_ENCODING "
"<https://curl.haxx.se/libcurl/c/CURLOPT_ACCEPT_ENCODING.html>`_"
msgstr ""
"``ssl_cert`` -- путь к файлу клиентского SSL-сертификата. См. также    "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_."

msgid "response_object"
msgstr ""

msgid ""
"A response object returned by a request method (:ref:`request "
"<client_object-request>`, :ref:`get <client_object-get>`, :ref:`post "
"<client_object-post>`, and so on)."
msgstr ""

msgid "**See also:** :ref:`io_object <io_object>`"
msgstr ""

#, fuzzy
msgid "A response status code."
msgstr "``reason`` -- текст статуса HTTP-ответа"

msgid "**See also:** :ref:`Status code <response_status_code>`"
msgstr ""

#, fuzzy
msgid "A response status text."
msgstr "``reason`` -- текст статуса HTTP-ответа"

msgid "Response headers."
msgstr ""

msgid "**See also:** :ref:`Headers <response_headers>`"
msgstr ""

msgid ""
"Response cookies. The value is an array of two elements where the first one "
"is the cookie value and the second one is an array with the cookie's "
"options."
msgstr ""

msgid "**See also:** :ref:`Cookies <response_cookies>`"
msgstr ""

msgid ""
"A response body. Use :ref:`decode <response_object-decode>` to decode the "
"response body."
msgstr ""

msgid "**See also:** :ref:`Response body <response_body>`"
msgstr ""

#, fuzzy
msgid "An HTTP protocol version."
msgstr "``proto`` -- версия протокола"

msgid "Decode the response body to a Lua object based on the content type."
msgstr ""

msgid "a decoded body"
msgstr ""

msgid "**See also:** :ref:`Deserialization <response_deserialization>`"
msgstr ""

msgid "io_object"
msgstr ""

msgid ""
"An IO object used to read or write data in chunks. To get an IO object "
"instead of the full response (:ref:`response_object <response_object>`), you"
" need to set the :ref:`chunked <request_options-chunked>` request option to "
"``true``."
msgstr ""

msgid ""
"Read request data in chunks of a specified length or up to a specific "
"delimiter."
msgstr ""

msgid "the maximum number of bytes to read"
msgstr ""

msgid "the delimiter used to stop reading data"
msgstr ""

msgid "the number of seconds to wait. The default is ``10``."
msgstr ""

msgid ""
"A chunk of read data. Returns an empty string if there is nothing more to "
"read."
msgstr ""

msgid "**See also:** :ref:`Streaming download <response_streaming_download>`"
msgstr ""

msgid "Write the specified chunk of data."
msgstr ""

msgid "data to be written"
msgstr ""

msgid "**See also:** :ref:`Streaming upload <request_streaming_upload>`"
msgstr ""

msgid "Finish reading or writing data."
msgstr ""

#~ msgid "Overview"
#~ msgstr "Общие сведения"

#~ msgid "Index"
#~ msgstr "Указатель"

#~ msgid "Below is a list of all ``http`` functions."
#~ msgstr "Ниже приведен перечень всех функций модуля ``http``."

#~ msgid "Name"
#~ msgstr "Имя"

#~ msgid "Use"
#~ msgstr "Назначение"

#~ msgid ":ref:`client_object:request() <client_object-request>`"
#~ msgstr ":ref:`client_object:request() <client_object-request>`"

#~ msgid "Perform an HTTP request"
#~ msgstr "Выполнение HTTP-запроса"

#~ msgid "Construct a new HTTP client instance."
#~ msgstr "Создание нового экземпляра HTTP-клиента."

#~ msgid "integer settings which are passed to libcurl."
#~ msgstr "настройки целочисленных значений, которые передаются в libcurl."

#~ msgid ""
#~ "The two possible options are ``max_connections`` and "
#~ "``max_total_connections``."
#~ msgstr ""
#~ "Доступны два параметра: ``max_connections`` и ``max_total_connections``."

#~ msgid ""
#~ "``max_total_connections`` is the maximum number of active connections. It "
#~ "affects libcurl  `CURLMOPT_MAX_TOTAL_CONNECTIONS "
#~ "<https://curl.haxx.se/libcurl/c/CURLMOPT_MAX_TOTAL_CONNECTIONS.html>`_. It "
#~ "is ignored if the curl version is less than 7.30. The default is 0, which "
#~ "allows libcurl to scale accordingly to easily handles count."
#~ msgstr ""

#~ msgid ""
#~ "The default option values are usually good enough but in rare cases it might"
#~ " be good to set them. In that case here are two tips."
#~ msgstr ""
#~ "Обычно значений параметров по умолчанию будет достаточно, но в редких "
#~ "случаях может понадобиться их настройка. На этот случай два совета."

#~ msgid ""
#~ "Do not set ``max_connections`` less than ``max_total_connections`` unless "
#~ "you are confident about your actions. When ``max_connections`` is less then "
#~ "``max_total_connections``, in some cases libcurl will not reuse sockets for "
#~ "requests that are going to the same host. If the limit is reached and a new "
#~ "request occurs, then libcurl will first create a new socket, send the "
#~ "request, wait for the first connection to be free, and close it, in order to"
#~ " avoid exceeding the ``max_connections`` cache size. In the worst case, "
#~ "libcurl will create a new socket for every request, even if all requests are"
#~ " going to the same host. See `this Tarantool issue on github "
#~ "<https://github.com/tarantool/tarantool/issues/3945>`_ for details."
#~ msgstr ""

#~ msgid "**Example:**"
#~ msgstr "**Пример:**"

#~ msgid ""
#~ "If ``http_client`` is an HTTP client instance, ``http_client:request()`` "
#~ "will perform an HTTP request and, if there is a successful connection, will "
#~ "return a table with connection information."
#~ msgstr ""
#~ "Если ``http_client`` -- это экземпляр HTTP-клиента, "
#~ "``http_client:request()`` выполнит HTTP-запрос, и в случае успешного "
#~ "подключения вернет таблицу с информацией о подключении."

#~ msgid "HTTP method, for example 'GET' or 'POST' or 'PUT'"
#~ msgstr "HTTP-метод, например 'GET', 'POST' или 'PUT'"

#~ msgid "location, for example 'https://tarantool.org/doc'"
#~ msgstr "расположение, например 'https://tarantool.org/doc'"

#~ msgid "optional initial message, for example 'My text string!'"
#~ msgstr "необязательное начальное сообщение, например 'My text string!'"

#~ msgid ""
#~ "table of connection options, with any of these components:   * ``ca_file`` "
#~ "-- path to an SSL certificate file to verify the peer with.  * ``ca_path`` "
#~ "-- path to a directory holding one or more certificates to    verify the "
#~ "peer with.  * ``headers`` -- table of HTTP headers.  * ``keepalive_idle`` --"
#~ " delay, in seconds, that the operating system    will wait while the "
#~ "connection is idle before sending keepalive    probes. See also    "
#~ "`CURLOPT_TCP_KEEPIDLE "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_    and the note"
#~ " below about keepalive_interval.  * ``keepalive_interval`` -- the interval, "
#~ "in seconds, that the operating    system will wait between sending keepalive"
#~ " probes. See also    `CURLOPT_TCP_KEEPINTVL "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_.    If both "
#~ "``keepalive_idle`` and ``keepalive_interval`` are set, then    Tarantool "
#~ "will also set HTTP keepalive headers: ``Connection:Keep-Alive``    and "
#~ "``Keep-Alive:timeout=<keepalive_idle>``.    Otherwise Tarantool will send "
#~ "``Connection:close``  * ``low_speed_limit`` -- set the \"low speed limit\" "
#~ "-- the average    transfer speed in bytes per second that the transfer "
#~ "should be below    during \"low speed time\" seconds for the library to "
#~ "consider it to be    too slow and abort. See also    "
#~ "`CURLOPT_LOW_SPEED_LIMIT "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * "
#~ "``low_speed_time`` -- set the \"low speed time\" -- the time that the    "
#~ "transfer speed should be below the \"low speed limit\" for the library    to"
#~ " consider it too slow and abort. See also    `CURLOPT_LOW_SPEED_TIME "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * "
#~ "``max_header_name_len`` -- the maximal length of a header name. If a header"
#~ "    name is bigger than this value, it is truncated to this length.    The "
#~ "default value is '32'.  * ``follow_location`` -- when the option is set to "
#~ "``true`` (default)    and the response has a 3xx code, the HTTP client will "
#~ "automatically issue    another request to a location that a server sends in "
#~ "the ``Location``    header. If the new response is 3xx again, the HTTP "
#~ "client will    issue still another request and so on in a loop until a "
#~ "non-3xx response    will be received. This last response will be returned as"
#~ " a result.    Setting this option to ``false`` allows to disable this "
#~ "behavior.    In this case, the HTTP client will return a 3xx response "
#~ "itself.  * ``no_proxy`` -- a comma-separated list of hosts that do not "
#~ "require proxies, or '*', or ''.    Set :samp:`no_proxy = {host} [, {host} "
#~ "...]` to specify    hosts that can be reached without requiring a proxy, "
#~ "even if ``proxy`` has    been set to a non-blank value and/or if a proxy-"
#~ "related environment variable    has been set.    Set ``no__proxy = '*'`` to "
#~ "specify that all hosts can be reached    without requiring a proxy, which is"
#~ " equivalent to setting ``proxy=''``.    Set ``no_proxy = ''`` to specify "
#~ "that no hosts can be reached    without requiring a proxy, even if a proxy-"
#~ "related environment variable    (HTTP_PROXY) is used.    If ``no_proxy`` is "
#~ "not set, then a proxy-related environment variable    (HTTP_PROXY) may be "
#~ "used. See also    `CURLOPT_NOPROXY "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_NOPROXY.html>`_  * ``proxy`` -- a "
#~ "proxy server host or IP address, or ''.    If ``proxy`` is a host or IP "
#~ "address, then it may begin with a scheme,    for example ``https://`` for an"
#~ " https proxy or ``http://`` for an http proxy.    If ``proxy`` is set to '' "
#~ "-- an empty string, then proxy use is disabled,    and no proxy-related "
#~ "environment variable will be used.    If ``proxy`` is not set, then a proxy-"
#~ "related environment variable may be used, such as    HTTP_PROXY or "
#~ "HTTPS_PROXY or FTP_PROXY, or ALL_PROXY if the    protocol can be any "
#~ "protocol. See also    `CURLOPT_PROXY "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_PROXY.html>`_  * ``proxy_port`` -- a"
#~ " proxy server port.    The default is 443 for an https proxy and 1080 for a "
#~ "non-https proxy.    See also    `CURLOPT_PROXYPORT "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_PROXYPORT.html>`_  * "
#~ "``proxy_user_pwd`` -- a proxy server user name and/or password.    Format: "
#~ ":samp:`proxy_user_pwd = {user_name}:`    or :samp:`proxy_user_pwd = "
#~ ":{password}`    or :samp:`proxy_user_pwd = {user_name}:{password}`. See also"
#~ "    `CURLOPT_USERPWD <https://curl.haxx.se/libcurl/c/CURLOPT_USERPWD.html>`_"
#~ "  * ``ssl_cert`` -- path to a SSL client certificate file. See also    "
#~ "`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_  * "
#~ "``ssl_key`` -- path to a private key file for a TLS and SSL client    "
#~ "certificate. See also    `CURLOPT_SSLKEY "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_  * ``timeout`` -- "
#~ "number of seconds to wait for a curl API read request    before timing out. "
#~ "The default timeout is set to infinity (36586400100 seconds).* "
#~ "``unix_socket`` -- a socket name to use instead of an Internet address,    "
#~ "for a local connection. The Tarantool server must be built with    "
#~ "``libcurl`` 7.40 or later. See the :ref:`second example <http-example2>`    "
#~ "later in this section.  * ``verbose`` -- set on/off verbose mode.  * "
#~ "``verify_host`` -- set on/off verification of the certificate's name    (CN)"
#~ " against host. See also    `CURLOPT_SSL_VERIFYHOST "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_  * "
#~ "``verify_peer`` -- set on/off verification of the peer's SSL    certificate."
#~ " See also    `CURLOPT_SSL_VERIFYPEER "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_  * "
#~ "``accept_encoding`` -- enables automatic decompression of HTTP responses    "
#~ "by setting the contents of the `Accept-Encoding: header` sent in an    HTTP "
#~ "request and enabling decoding of a response when the `Content-Encoding: "
#~ "header`    is received. This option specifies what encoding to use.    It "
#~ "can be an empty string which means the `Accept-Encoding: header` will    "
#~ "contain all supported built-in encodings. Four encodings are supported: "
#~ "`identity`,    meaning non-compressed, `deflate` which requests the server "
#~ "to compress its    response using the zlib algorithm, `gzip` which requests "
#~ "the gzip algorithm and `br`    which is brotli. Provide them in the string "
#~ "as a comma-separated list of accepted    encodings, like: ``\"br, gzip, "
#~ "deflate\"``.    For details of the option, refer to `CURLOPT_ACCEPT_ENCODING"
#~ " <https://curl.haxx.se/libcurl/c/CURLOPT_ACCEPT_ENCODING.html>`_"
#~ msgstr ""

#~ msgid "table of connection options, with any of these components:"
#~ msgstr ""
#~ "таблица с параметрами подключения, которые могут содержать любые из "
#~ "следующих компонентов:"

#~ msgid "``headers`` -- table of HTTP headers."
#~ msgstr "``headers`` -- таблица HTTP-заголовков."

#~ msgid ""
#~ "``keepalive_idle`` -- delay, in seconds, that the operating system will wait"
#~ " while the connection is idle before sending keepalive probes. See also "
#~ "`CURLOPT_TCP_KEEPIDLE "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_ and the note "
#~ "below about ``keepalive_interval``."
#~ msgstr ""
#~ "``keepalive_idle`` -- время задержки в секундах, в течение которого "
#~ "операционная система находится в режиме ожидания подключения до отправки "
#~ "сообщений для поддержания в активном состоянии keepalive. См. также "
#~ "`CURLOPT_TCP_KEEPIDLE "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_ и примечание "
#~ "ниже к ``keepalive_interval``."

#~ msgid ""
#~ "``keepalive_interval`` -- the interval, in seconds, that the operating "
#~ "system will wait between sending keepalive probes. See also "
#~ "`CURLOPT_TCP_KEEPINTVL "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_. If both "
#~ "``keepalive_idle`` and ``keepalive_interval`` are set, then Tarantool will "
#~ "also set HTTP keepalive headers: ``Connection:Keep-Alive`` and ``Keep-"
#~ "Alive:timeout=<keepalive_idle>``. Otherwise, Tarantool will send "
#~ "``Connection:close``."
#~ msgstr ""

#~ msgid ""
#~ "``follow_location`` -- when the option is set to ``true`` (default) and the "
#~ "response has a 3xx code, the HTTP client will automatically issue another "
#~ "request to a location that a server sends in the ``Location`` header. If the"
#~ " new response is 3xx again, the HTTP client will issue still another request"
#~ " and so on in a loop until a non-3xx response will be received. This last "
#~ "response will be returned as a result. Setting this option to ``false`` "
#~ "allows to disable this behavior. In this case, the HTTP client will return a"
#~ " 3xx response itself."
#~ msgstr ""

#~ msgid ""
#~ "``no_proxy`` -- a comma-separated list of hosts that do not require proxies,"
#~ " or '*', or ''. Set :samp:`no_proxy = {host} [, {host} ...]` to specify "
#~ "hosts that can be reached without requiring a proxy, even if ``proxy`` has "
#~ "been set to a non-blank value and/or if a proxy-related environment variable"
#~ " has been set. Set ``no__proxy = '*'`` to specify that all hosts can be "
#~ "reached without requiring a proxy, which is equivalent to setting "
#~ "``proxy=''``. Set ``no_proxy = ''`` to specify that no hosts can be reached "
#~ "without requiring a proxy, even if a proxy-related environment variable "
#~ "(``HTTP_PROXY``) is used. If ``no_proxy`` is not set, then a proxy-related "
#~ "environment variable (``HTTP_PROXY``) may be used. See also `CURLOPT_NOPROXY"
#~ " <https://curl.haxx.se/libcurl/c/CURLOPT_NOPROXY.html>`_."
#~ msgstr ""

#~ msgid ""
#~ "``proxy`` -- a proxy server host or IP address, or ''. If ``proxy`` is a "
#~ "host or IP address, then it may begin with a scheme, for example "
#~ "``https://`` for an https proxy or ``http://`` for an http proxy. If "
#~ "``proxy`` is set to '' -- an empty string, then proxy use is disabled, and "
#~ "no proxy-related environment variable will be used. If ``proxy`` is not set,"
#~ " then a proxy-related environment variable may be used, such as "
#~ "``HTTP_PROXY`` or ``HTTPS_PROXY`` or ``FTP_PROXY``, or ``ALL_PROXY`` if the "
#~ "protocol can be any protocol. See also `CURLOPT_PROXY "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_PROXY.html>`_."
#~ msgstr ""

#~ msgid ""
#~ "``proxy_port`` -- a proxy server port. The default is ``443`` for an https "
#~ "proxy and ``1080`` for a non-https proxy. See also `CURLOPT_PROXYPORT "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_PROXYPORT.html>`_."
#~ msgstr ""

#~ msgid ""
#~ "``proxy_user_pwd`` -- a proxy server user name and/or password. Format: "
#~ ":samp:`proxy_user_pwd = {user_name}:` or :samp:`proxy_user_pwd = "
#~ ":{password}` or :samp:`proxy_user_pwd = {user_name}:{password}`. See also "
#~ "`CURLOPT_USERPWD <https://curl.haxx.se/libcurl/c/CURLOPT_USERPWD.html>`_."
#~ msgstr ""

#~ msgid ""
#~ "``ssl_key`` -- path to a private key file for a TLS and SSL client "
#~ "certificate. See also `CURLOPT_SSLKEY "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_."
#~ msgstr ""
#~ "``ssl_key`` -- путь к файлу закрытого ключа для клиентского TSL-сертификата "
#~ "и SSL-сертификата. См. также `CURLOPT_SSLKEY "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_."

#~ msgid ""
#~ "``unix_socket`` -- a socket name to use instead of an Internet address, for "
#~ "a local connection. The Tarantool server must be built with ``libcurl`` 7.40"
#~ " or later. See the :ref:`second example <http-example2>` later in this "
#~ "section."
#~ msgstr ""
#~ "``unix_socket`` -- имя сокета, которое используется вместо адреса в сети "
#~ "Интернет,    для локального соединения. Сборка сервера Tarantool должна "
#~ "осуществляться с помощью ``libcurl`` 7.40 или более поздней версии. См. "
#~ ":ref:`второй пример <http-example2>` далее в разделе."

#~ msgid ""
#~ "``accept_encoding`` -- enables automatic decompression of HTTP responses by "
#~ "setting the contents of the `Accept-Encoding: header` sent in an HTTP "
#~ "request and enabling decoding of a response when the `Content-Encoding: "
#~ "header` is received. This option specifies what encoding to use. It can be "
#~ "an empty string which means the `Accept-Encoding: header` will contain all "
#~ "supported built-in encodings. Four encodings are supported: `identity`, "
#~ "meaning non-compressed, `deflate` which requests the server to compress its "
#~ "response using the zlib algorithm, `gzip` which requests the gzip algorithm "
#~ "and `br` which is brotli. Provide them in the string as a comma-separated "
#~ "list of accepted encodings, like: ``\"br, gzip, deflate\"``. For details of "
#~ "the option, refer to `CURLOPT_ACCEPT_ENCODING "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_ACCEPT_ENCODING.html>`_."
#~ msgstr ""

#~ msgid "connection information, with all of these components:"
#~ msgstr "информация о подключении со всеми следующими компонентами:"

#~ msgid "``status`` -- HTTP response status"
#~ msgstr "``status`` -- статус HTTP-ответа"

#~ msgid "``headers`` -- a Lua table with normalized HTTP headers"
#~ msgstr "``headers`` -- Lua-таблица с нормализованными HTTP-заголовками"

#~ msgid ""
#~ "The ``cookies`` component contains a Lua table where the key is a cookie "
#~ "name. The value is an array of two elements where the first one is the "
#~ "cookie value and the second one is an array with the cookie’s options. "
#~ "Possible options are: \"Expires\", \"Max-Age\", \"Domain\", \"Path\", "
#~ "\"Secure\", \"HttpOnly\", \"SameSite\". Note that an option is a string with"
#~ " '=' splitting the option's name and its value. `Here "
#~ "<https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies>`_ you can find "
#~ "more info."
#~ msgstr ""
#~ "Компонент ``cookies`` содержит Lua-таблицу, ключом в которой является имя "
#~ "файла cookie. Значением же является массив из двух элементов: первый элемент"
#~ " представляет собой значение данных cookie, а второй -- массив с параметрами"
#~ " файла cookie. Возможные параметры: \"Expires\", \"Max-Age\", \"Domain\", "
#~ "\"Path\", \"Secure\", \"HttpOnly\", \"SameSite\". Обратите внимание, что "
#~ "параметр представляет собой строку, в которой знак '=' разделяет имя "
#~ "параметра и его значение. Дополнительную информацию можно получить `здесь "
#~ "<https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies>`_."

#~ msgid "You can use cookies information like this:"
#~ msgstr "Информацию по файлам cookies можно использовать следующим образом:"

#~ msgid ""
#~ "tarantool> require('http.client').get('https://www.tarantool.io/en/').cookies\n"
#~ "---\n"
#~ "- csrftoken:\n"
#~ "  - bWJVkBybvX9LdJ8uLPOTVrit5P3VbRjE3potYVOuUnsSjYT5ahghDV06tXRkfnOl\n"
#~ "  - - Max-Age=31449600\n"
#~ "    - Path=/\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> cookies = require('http.client').get('https://www.tarantool.io/en/').cookies\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> options = cookies['csrftoken'][2]\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> for _, option in ipairs(options) do\n"
#~ "         > if option:startswith('csrftoken cookie's Max-Age = ') then\n"
#~ "         > print(option)\n"
#~ "         > end\n"
#~ "         > end\n"
#~ "\n"
#~ "csrftoken cookie's Max-Age = 31449600\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool>"
#~ msgstr ""
#~ "tarantool> require('http.client').get('https://www.tarantool.io/en/').cookies\n"
#~ "---\n"
#~ "- csrftoken:\n"
#~ "  - bWJVkBybvX9LdJ8uLPOTVrit5P3VbRjE3potYVOuUnsSjYT5ahghDV06tXRkfnOl\n"
#~ "  - - Max-Age=31449600\n"
#~ "    - Path=/\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> cookies = require('http.client').get('https://www.tarantool.io/en/').cookies\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> options = cookies['csrftoken'][2]\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> for _, option in ipairs(options) do\n"
#~ "         > if option:startswith('csrftoken cookie's Max-Age = ') then\n"
#~ "         > print(option)\n"
#~ "         > end\n"
#~ "         > end\n"
#~ "\n"
#~ "csrftoken cookie's Max-Age = 31449600\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool>"

#~ msgid "The following \"shortcuts\" exist for requests:"
#~ msgstr "Для запросов существуют следующие ускоренные методы:"

#~ msgid ""
#~ "``http_client:get(url, options)`` -- shortcut for "
#~ "``http_client:request(\"GET\", url, nil, opts)``"
#~ msgstr ""
#~ "``http_client:get(url, options)`` -- вспомогательный метод для "
#~ "``http_client:request(\"GET\", url, nil, opts)``"

#~ msgid ""
#~ "``http_client:post (url, body, options)`` -- shortcut for "
#~ "``http_client:request(\"POST\", url, body, opts)``"
#~ msgstr ""
#~ "``http_client:post (url, body, options)`` -- ускоренный метод для "
#~ "``http_client:request(\"POST\", url, body, opts)``"

#~ msgid ""
#~ "``http_client:put(url, body, options)`` -- shortcut for "
#~ "``http_client:request(\"PUT\", url, body, opts)``"
#~ msgstr ""
#~ "``http_client:put(url, body, options)`` -- ускоренный метод для "
#~ "``http_client:request(\"PUT\", url, body, opts)``"

#~ msgid ""
#~ "``http_client:patch(url, body, options)`` -- shortcut for "
#~ "``http_client:request(\"PATCH\", url, body, opts)``"
#~ msgstr ""
#~ "``http_client:patch(url, body, options)`` -- ускоренный метод для "
#~ "``http_client:request(\"PATCH\", url, body, opts)``"

#~ msgid ""
#~ "``http_client:options(url, options)`` -- shortcut for "
#~ "``http_client:request(\"OPTIONS\", url, nil, opts)``"
#~ msgstr ""
#~ "``http_client:options(url, options)`` -- ускоренный метод для "
#~ "``http_client:request(\"OPTIONS\", url, nil, opts)``"

#~ msgid ""
#~ "``http_client:head(url, options)`` -- shortcut for "
#~ "``http_client:request(\"HEAD\", url, nil, opts)``"
#~ msgstr ""
#~ "``http_client:head(url, options)`` -- ускоренный метод для "
#~ "``http_client:request(\"HEAD\", url, nil, opts)``"

#~ msgid ""
#~ "``http_client:delete(url, options)`` -- shortcut for "
#~ "``http_client:request(\"DELETE\", url, nil, opts)``"
#~ msgstr ""
#~ "``http_client:delete(url, options)`` -- ускоренный метод для "
#~ "``http_client:request(\"DELETE\", url, nil, opts)``"

#~ msgid ""
#~ "``http_client:trace(url, options)`` -- shortcut for "
#~ "``http_client:request(\"TRACE\", url, nil, opts)``"
#~ msgstr ""
#~ "``http_client:trace(url, options)`` -- ускоренный метод для "
#~ "``http_client:request(\"TRACE\", url, nil, opts)``"

#~ msgid ""
#~ "``http_client:connect(url, options)`` -- shortcut for "
#~ "``http_client:request(\"CONNECT\", url, nil, opts)``"
#~ msgstr ""
#~ "``http_client:connect(url, options)`` -- ускоренный метод для "
#~ "``http_client:request(\"CONNECT\", url, nil, opts)``"

#~ msgid ""
#~ "Requests may be influenced by environment variables, for example users can "
#~ "set up an http proxy by setting :samp:`HTTP_PROXY={proxy}` before initiating"
#~ " any requests, unless a ``proxy`` connection option has priority. See the "
#~ "web page document `Environment variables libcurl understands "
#~ "<https://curl.haxx.se/libcurl/c/libcurl-env.html>`_."
#~ msgstr ""

#~ msgid "The ``http_client:stat()`` function returns a table with statistics:"
#~ msgstr ""
#~ "Функция ``http_client:stat()`` возвращает таблицу со статистическими "
#~ "данными:"

#~ msgid "**Example 1:**"
#~ msgstr "**Пример 1:**"

#~ msgid ""
#~ "Connect to an HTTP server, look at the size of the response for a 'GET' "
#~ "request, and look at the statistics for the session."
#~ msgstr ""
#~ "Подключение к HTTP-серверу, просмотр размера ответа на 'GET'-запрос и "
#~ "просмотр статистики по сессии."

#~ msgid ""
#~ "tarantool> http_client = require('http.client').new()\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> r = http_client:request('GET','http://tarantool.org')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> string.len(r.body)\n"
#~ "---\n"
#~ "- 21725\n"
#~ "...\n"
#~ "tarantool> http_client:stat()\n"
#~ "---\n"
#~ "- total_requests: 1\n"
#~ "  sockets_deleted: 2\n"
#~ "  failed_requests: 0\n"
#~ "  active_requests: 0\n"
#~ "  http_other_responses: 0\n"
#~ "  http_200_responses: 1\n"
#~ "  sockets_added: 2"
#~ msgstr ""
#~ "tarantool> http_client = require('http.client').new()\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> r = http_client:request('GET','http://tarantool.org')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> string.len(r.body)\n"
#~ "---\n"
#~ "- 21725\n"
#~ "...\n"
#~ "tarantool> http_client:stat()\n"
#~ "---\n"
#~ "- total_requests: 1\n"
#~ "  sockets_deleted: 2\n"
#~ "  failed_requests: 0\n"
#~ "  active_requests: 0\n"
#~ "  http_other_responses: 0\n"
#~ "  http_200_responses: 1\n"
#~ "  sockets_added: 2"

#~ msgid "**Example 2:**"
#~ msgstr "**Пример 2:**"

#~ msgid "Start two Tarantool instances on the same computer."
#~ msgstr "Запустите два экземпляра Tarantool на одном компьютере."

#~ msgid "On the first Tarantool instance, listen on a Unix socket:"
#~ msgstr "В первом экземпляре Tarantool включите прослушивание Unix-сокета:"

#~ msgid "On the second Tarantool instance, send via ``http_client``:"
#~ msgstr "На втором экземпляре Tarantool отправьте с помощью ``http_client``:"

#~ msgid ""
#~ "box.cfg{}\n"
#~ "http_client = require('http.client').new({5})\n"
#~ "http_client:put('http://localhost/','body',{unix_socket = '/tmp/unix_domain_socket.sock'})"
#~ msgstr ""
#~ "box.cfg{}\n"
#~ "http_client = require('http.client').new({5})\n"
#~ "http_client:put('http://localhost/','body',{unix_socket = '/tmp/unix_domain_socket.sock'})"

#~ msgid ""
#~ "Terminal #1 will show an error message: \"Invalid MsgPack\". This is not "
#~ "useful but demonstrates the syntax and demonstrates that was sent was "
#~ "received."
#~ msgstr ""
#~ "Терминал №1 покажет сообщение об ошибке: \"Invalid MsgPack\". Данный пример "
#~ "бесполезен, но наглядно демонстрирует синтаксис и получение отправленного "
#~ "сообщения."
