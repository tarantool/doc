
msgid "JSON paths"
msgstr ""

msgid "Overview"
msgstr ""

msgid ""
"Since version 2.3 Tarantool supports JSON path updates. Now you can "
"update/upsert formatted :doc:`tuple "
"</reference/reference_lua/box_tuple/update>` / :ref:`space <box_space-"
"update>` / :doc:`index </reference/reference_lua/box_index/update>` "
"fields by name (not only by field number). Updates of nested structures "
"are also supported."
msgstr ""
"Начиная с версии 2.3, Tarantool поддерживает обновление с помощью "
"JSON-пути. Теперь можно делать обновление/обновление со вставкой "
"отформатированных полей :doc:`кортежа "
"</reference/reference_lua/box_tuple/update>` /:ref:`спейса <box_space-"
"update>` /:doc:`индекса </reference/reference_lua/box_index/update>` по "
"имени (а не только по номеру поля). Обновления вложенных структур также "
"поддерживаются."

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"tarantool> box.cfg{};\n"
"         > format = {};\n"
"         > format[1] = {'field1', 'unsigned'};\n"
"         > format[2] = {'field2', 'map'};\n"
"         > format[3] = {'field3', 'array'};\n"
"         > format[4] = {'field4', 'string', is_nullable = true}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.create_space('test', {format = format});\n"
"         > _ = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> t = {\n"
"         >     1,\n"
"         >     {\n"
"         >         key1 = 'value',\n"
"         >         key2 = 10\n"
"         >     },\n"
"         >     {\n"
"         >         2,\n"
"         >         3,\n"
"         >         {key3 = 20}\n"
"         >     }\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> t = s:replace(t)\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 'field2.key1', 'new_value'}})\n"
"---\n"
"- [1, {'key1': 'new_value', 'key2': 10}, [2, 3, {'key3': 20}]]\n"
"...\n"
"tarantool> t:update({{'+', 'field3[2]', 1}})\n"
"---\n"
"- [1, {'key1': 'value', 'key2': 10}, [2, 4, {'key3': 20}]]\n"
"...\n"
"tarantool> s:update({1}, {{'!', 'field4', 'inserted value'}})\n"
"---\n"
"- [1, {'key1': 'value', 'key2': 10}, [2, 3, {'key3': 20}], 'inserted "
"value']\n"
"...\n"
"tarantool> s:update({1}, {{'#', '[2].key2', 1}, {'=', '[3][3].key4', "
"'value4'}})\n"
"---\n"
"- [1, {'key1': 'value'}, [2, 3, {'key3': 20, 'key4': 'value4'}], "
"'inserted value']\n"
"...\n"
"tarantool> s:upsert({1, {k = 'v'}, {}}, {{'#', '[2].key1', 1}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, {}, [2, 3, {'key3': 20, 'key4': 'value4'}], 'inserted value']\n"
"..."
msgstr ""

msgid ""
"Notice that field names that look like JSON paths are processed similarly"
" to :doc:`accessing tuple fields by JSON "
"</reference/reference_lua/box_tuple/field_path>`: first, the whole path "
"is interpreted as a field name; if such a name does not exist, then it is"
" treated as a path."
msgstr ""
"Обратите внимание, что имена полей, которые выглядят как JSON-пути, "
"обрабатываются аналогично :doc:`доступу к полям кортежа через JSON "
"</reference/reference_lua/box_tuple/field_path>`: сначала весь путь "
"интерпретируется как имя поля; если такого имени не существует, то оно "
"обрабатывается как путь."

msgid "For example, for a field name ``field.name.like.json``, this update"
msgstr "Например, для имя поля ``field.name.like.json``, это обновление"

msgid ":samp:`{object-name}:update({..., 'field.name.like.json', ...})`"
msgstr ""

msgid ""
"will update this field instead of keys ``field`` -> ``name`` -> ``like`` "
"-> ``json``. If you need such a name as part of a bigger path, then you "
"should wrap it in quotes ``\"\"`` and brackets ``[]``:"
msgstr ""
"обновит именно это поле целиком, а не ключи ``field`` -> ``name`` -> "
"``like`` -> ``json``. Если это имя нужно вам как часть большего пути, то "
"его нужно обернутьв кавычки ``\"\"`` или квадратные скобки ``[]``:"

msgid ""
":samp:`{object-name}:update({..., "
"'[\"field.name.like.json\"].next.fields', ...})`"
msgstr ""

msgid "**There are some rules for JSON updates:**"
msgstr "**Есть несколько правил для обновления через JSON:**"

msgid ""
"Operation ``'!'`` can't be used to create all intermediate nodes of a "
"path. For example, ``{'!', 'field1[1].field3', ...}`` can't create fields"
" ``'field1'`` and ``'[1]'``, they should exist."
msgstr ""
"Операция ``'!'`` не может быть использована для создания всех "
"промежуточных узлов пути.Например, ``{'!', 'field1[1].field3', ...}`` не "
"может создать поля ``'field1'`` и ``'[1]'``, они должны существовать."

msgid ""
"Operation ``'#'``, when applied to maps, can't delete more than one key "
"at once. That is, its argument should be always 1 for maps."
msgstr ""
"Операция ``'#'``, при применении к ассоциативным массивам, не может "
"удалить сразу несколько ключей. Поэтому для ассоциативных массивов ее "
"аргумент всегда должен быть 1."

msgid "``{'#', 'field1.field2', 1}`` is allowed;"
msgstr "``{'#', 'field1.field2', 1}`` -- разрешено;"

msgid "``{'#', 'field1.field2', 10}`` is not."
msgstr "``{'#', 'field1.field2', 10}`` -- не разрешено."

msgid ""
"This limitation originates from the problem that keys in a map are not "
"ordered anyhow, and ``'#'`` with more than 1 key would lead to undefined "
"behavior."
msgstr ""
"Это ограничение возникает из-за проблемы, что ключи на ассоциативном "
"массиве все равно не упорядочены, а ``'#'`` с более чем 1 ключом приведет"
" к неопределенному поведению."

msgid "Operation ``'!'`` on maps can't create a key, if it exists already."
msgstr ""
"Операция ``'!'`` на ассоциативных массивах не может создать ключ, если он"
" уже существует."

msgid ""
"If a map contains non-string keys (booleans, numbers, maps, arrays - "
"anything), then these keys can't be updated via JSON paths. But it is "
"still allowed to update string keys in such a map."
msgstr ""
"Если ассоциативный массив содержит нестроковые ключи (булеаны, цифры, "
"ассоциативные массивы, массивы - все что угодно), то эти ключи не могут "
"быть обновлены с помощью JSON-путей. Но в таком ассоциативном массиве все"
" равно разрешено обновлять строковые ключи."

msgid ""
"**Why JSON updates are good, and should be preferred when only a part of "
"a tuple needs to be updated:**"
msgstr ""
"**Почему обновления с помощью JSON-путей хороши, и их следует "
"предпочитать, когда нужно обновить только часть кортежа:**"

msgid ""
"They consume less space in WAL, because for an update only its keys, "
"operations, and arguments are stored. It is cheaper to store an update of"
" one deep field than of the whole tuple."
msgstr ""
"Они расходуют меньше места в WAL, потому что для обновления хранятся "
"только ключи, операции и аргументы. Обновление одного труднодоступного "
"поля дешевле, чем всего обновление всего кортежа."

msgid ""
"They are faster. Firstly, this is because they are implemented in C, and "
"have no problems with Lua GC and dynamic typing. Secondly, some cases of "
"JSON paths are highly optimized. For example, an update with a single "
"JSON path costs O(1) memory regardless of how deep that path goes (not "
"counting update arguments)."
msgstr ""
"Они быстрее. Во-первых, это потому, что они реализованы на C, и у них нет"
" проблем с Lua GC и динамическим набором текста. Во-вторых, некоторые "
"случаи использования JSON-путей хорошо оптимизированы. Например, "
"обновление одним JSON-путем стоит O(1) памяти, независимо от того, "
"насколько глубоко этот путь проходит (не считая аргументов обновления)."

msgid ""
"They are available from remote clients, as well as any other DML. Before "
"JSON updates became available in Tarantool, to update one deep part of a "
"tuple, it was necessary to download that tuple, update it in memory, and "
"send it back -- 2 network hops. With JSON paths, it can be 1 hop when the"
" update can be described in paths."
msgstr ""
"Они доступны с удаленных клиентов, а также с любого другого DML. До того,"
" как обновления с помощью JSON-путей стали доступны в Tarantool, чтобы "
"обновить одну глубокую часть кортежа, нужно было скачать этот кортеж, "
"обновить его в памяти и отправить обратно - 2 сетевых скачка. С помощью "
"JSON-путей, это может быть 1 скачок, когда обновление может быть описано "
"в путях."
