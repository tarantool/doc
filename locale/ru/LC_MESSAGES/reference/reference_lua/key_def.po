
msgid "Module `key_def`"
msgstr "Модуль `key_def`"

msgid ""
"The `key_def` module has a function for making a definition of the field "
"numbers and types of a tuple. The definition is usually used in conjunction "
"with an index definition to extract or compare the index key values."
msgstr ""
"В модуле `key_def` есть функция, чтобы создавать определения номеров и типов"
" полей кортежа. Это определение обычно используется вместе с определением "
"индекса для извлечения или сравнения значений ключей индекса."

msgid "Create a new key_def instance."
msgstr "Создает новый экземпляр key_def."

msgid "Parameters"
msgstr "Параметры"

msgid ""
"field numbers and types. There must be at least one part and it must have at"
" least ``fieldno`` and ``type``."
msgstr ""
"типы и номера полей. Должна быть хотя бы одна часть, и у нее обязательно "
"должны быть определены атрибуты ``fieldno`` и ``type``."

msgid "returns"
msgstr "возвращает"

msgid "key_def-object :ref:`a key_def object <key_def-object>`"
msgstr ":ref:`объект key_def <key_def-object>`"

msgid ""
"The parts table has components which are the same as the ``parts`` option in"
" :ref:`Options for space_object:create_index() <box_space-create_index-"
"options>`."
msgstr ""
"У таблицы table есть компоненты, которые такие же, как параметр ``parts`` из"
" :ref:`параметров для space_object:create_index() <box_space-create_index-"
"options>`."

msgid ""
"``fieldno`` (integer) for example ``fieldno = 1``. It is legal to use "
"``field`` instead of ``fieldno``."
msgstr ""
"``fieldno`` (целое число), например ``fieldno = 1``. Вместо ``fieldno`` "
"можно использовать ``field``."

msgid "``type`` (string) for example ``type = 'string'``."
msgstr "``type`` (строка), например ``type = 'string'``."

msgid "Other components are optional."
msgstr "Остальные компоненты необязательны."

msgid "Example: ``key_def.new({{type = 'unsigned', fieldno = 1}})``"
msgstr "Пример: ``key_def.new({{type = 'unsigned', fieldno = 1}})``"

msgid ""
"Example: ``key_def.new({{type = 'string', collation = 'unicode', field = "
"2}})``"
msgstr ""
"Пример: ``key_def.new({{type = 'string', collation = 'unicode', field = "
"2}})``"

msgid ""
"A key_def object is an object returned by :ref:`key_def.new() <key_def-"
"new>`. It has methods :ref:`extract_key() <key_def-extract_key>`, "
":ref:`compare() <key_def-compare>`, :ref:`compare_with_key() <key_def-"
"compare_with_key>`, :ref:`merge() <key_def-merge>`, :ref:`totable() "
"<key_def-totable>`."
msgstr ""
"Объект key_def --- объект, возвращаемый функцией :ref:`key_def.new() "
"<key_def-new>`. У него есть следующие методы: :ref:`extract_key() <key_def-"
"extract_key>`, :ref:`compare() <key_def-compare>`, :ref:`compare_with_key() "
"<key_def-compare_with_key>`, :ref:`merge() <key_def-merge>`, :ref:`totable()"
" <key_def-totable>`."

msgid "Return a tuple containing only the fields of the ``key_def`` object."
msgstr "Возвращает кортеж, содержащий только поля объекта ``key_def``."

msgid "tuple or Lua table with field contents"
msgstr "кортеж или Lua-таблица с содержимым поля"

msgid "return"
msgstr "возвращает"

msgid "the fields that were defined for the ``key_def`` object"
msgstr "поля, определенные для объекта ``key_def``,"

msgid "**Example #1:**"
msgstr "**Пример №1:**"

msgid ""
"-- Suppose that an item has five fields\n"
"-- 1, 99.5, 'X', nil, 99.5\n"
"-- and the fields that we care about are\n"
"-- #3 (a string) and #1 (an integer).\n"
"-- We can define those fields with k = key_def.new\n"
"-- and extract the values with k:extract_key.\n"
"\n"
"tarantool> key_def = require('key_def')\n"
"---\n"
"...\n"
"\n"
"tarantool> k = key_def.new({{type = 'string', fieldno = 3},\n"
">                           {type = 'unsigned', fieldno = 1}})\n"
"---\n"
"...\n"
"\n"
"tarantool> k:extract_key({1, 99.5, 'X', nil, 99.5})\n"
"---\n"
"- ['X', 1]\n"
"..."
msgstr ""
"--  Предположим, что у некоторого элемента пять полей:\n"
"-- 1, 99.5, 'X', nil, 99.5\n"
"-- и нас интересуют только два из них:\n"
"-- третье (строка) и первое (целое число).\n"
"-- Мы можем определить эти поля инструкцией k = key_def.new\n"
"--  и извлечь значения командой k:extract_key.\n"
"\n"
"tarantool> key_def = require('key_def')\n"
"---\n"
"...\n"
"\n"
"tarantool> k = key_def.new({{type = 'string', fieldno = 3},\n"
">                           {type = 'unsigned', fieldno = 1}})\n"
"---\n"
"...\n"
"\n"
"tarantool> k:extract_key({1, 99.5, 'X', nil, 99.5})\n"
"---\n"
"- ['X', 1]\n"
"..."

msgid "**Example #2**"
msgstr "**Пример №2**"

msgid ""
"-- Now suppose that the item is a tuple in a space which\n"
"-- has an index on field #3 plus field #1.\n"
"-- We can use key_def.new with the index definition\n"
"-- instead of filling it out as we did with Example #1.\n"
"-- The result will be the same.\n"
"key_def = require('key_def')\n"
"box.schema.space.create('T')\n"
"i = box.space.T:create_index('I', {parts={3, 'string', 1, 'unsigned'}})\n"
"box.space.T:insert{1, 99.5, 'X', nil, 99.5}\n"
"k = key_def.new(i.parts)\n"
"k:extract_key(box.space.T:get({'X', 1}))"
msgstr ""
"-- Теперь предположим, что элемент является кортежем в спейсе.\n"
"-- У спейса есть составной индекс, использующий поля №3 и №1.\n"
"-- Мы можем использовать key_def.new с определением индекса,\n"
"-- а не заполнять его, как мы делали в примере №1.\n"
"-- Результат будет тот же самый.\n"
"key_def = require('key_def')\n"
"box.schema.space.create('T')\n"
"i = box.space.T:create_index('I', {parts={3, 'string', 1, 'unsigned'}})\n"
"box.space.T:insert{1, 99.5, 'X', nil, 99.5}\n"
"k = key_def.new(i.parts)\n"
"k:extract_key(box.space.T:get({'X', 1}))"

msgid "**Example #3**"
msgstr "**Пример №3**"

msgid ""
"-- Iterate through the tuples in a secondary non-unique index.\n"
"-- extracting the tuples' primary-key values so they can be deleted\n"
"-- using a unique index. This code should be part of a Lua function.\n"
"local key_def_lib = require('key_def')\n"
"local s = box.schema.space.create('test')\n"
"local pk = s:create_index('pk')\n"
"local sk = s:create_index('test', {unique = false, parts = {\n"
"    {2, 'number', path = 'a'}, {2, 'number', path = 'b'}}})\n"
"s:insert{1, {a = 1, b = 1}}\n"
"s:insert{2, {a = 1, b = 2}}\n"
"local key_def = key_def_lib.new(pk.parts)\n"
"for _, tuple in sk:pairs({1})) do\n"
"    local key = key_def:extract_key(tuple)\n"
"    pk:delete(key)\n"
"end"
msgstr ""
"--  Итерация по всем кортежам во вторичном неуникальном индексе.\n"
"-- извлечение значений первичного ключа кортежей, чтобы их можно было удалить,\n"
"-- используя уникальный индекс. Этот код должен быть частью Lua-функции.\n"
"local key_def_lib = require('key_def')\n"
"local s = box.schema.space.create('test')\n"
"local pk = s:create_index('pk')\n"
"local sk = s:create_index('test', {unique = false, parts = {\n"
"    {2, 'number', path = 'a'}, {2, 'number', path = 'b'}}})\n"
"s:insert{1, {a = 1, b = 1}}\n"
"s:insert{2, {a = 1, b = 2}}\n"
"local key_def = key_def_lib.new(pk.parts)\n"
"for _, tuple in sk:pairs({1})) do\n"
"    local key = key_def:extract_key(tuple)\n"
"    pk:delete(key)\n"
"end"

msgid ""
"Compare the key fields of ``tuple_1`` to the key fields of ``tuple_2``. This"
" is a tuple-by-tuple comparison so users do not have to write code which "
"compares a field at a time. Each field's type and collation will be taken "
"into account. In effect it is a comparison of ``extract_key(tuple_1)`` with "
"``extract_key(tuple_2)``."
msgstr ""
"Сравнивает все ключевые поля кортежей ``tuple_1`` и ``tuple_2``, так что "
"пользователю не приходится писать код для сравнения полей по отдельности. "
"Тип поля и параметры сортировки принимаются во внимание. На самом деле "
"сравниваются значения ``extract_key(tuple_1)`` и ``extract_key(tuple_2)``."

msgid ""
"> 0 if tuple_1 key fields > tuple_2 key fields, = 0 if tuple_1 key fields = "
"tuple_2 key fields, < 0 if tuple_1 key fields < tuple_2 key fields"
msgstr ""
"> 0, если ключевые поля кортежа tuple_1 больше ключевых полей кортежа "
"tuple_2; = 0, если они равны; < 0, если ключевые поля кортежа tuple_1 меньше"
" ключевых полей кортежа tuple_2"

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3, collation = 'unicode_ci'},\n"
"                 {type = 'unsigned', fieldno = 1}})\n"
"k:compare({1, 99.5, 'X', nil, 99.5}, {1, 99.5, 'x', nil, 99.5})"
msgstr ""
"-- Результат этого кода будет 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3, collation = 'unicode_ci'},\n"
"                 {type = 'unsigned', fieldno = 1}})\n"
"k:compare({1, 99.5, 'X', nil, 99.5}, {1, 99.5, 'x', nil, 99.5})"

msgid ""
"Compare the key fields of ``tuple_1`` to all the fields of ``tuple_2``. This"
" is the same as :ref:`key_def_object:compare() <key_def-compare>` except "
"that ``tuple_2`` contains only the key fields. In effect it is a comparison "
"of ``extract_key(tuple_1)`` with ``tuple_2``."
msgstr ""
"Сравниваются ключевые поля кортежа ``tuple_1`` со всеми полями кортежа "
"``tuple_2``. Это почти то же самое, что :ref:`key_def_object:compare() "
"<key_def-compare>`, отличие в том, что в ``tuple_2`` есть только ключевые "
"поля. На самом деле это сравнение ``extract_key(tuple_1)`` с ``tuple_2``."

msgid ""
"> 0 if tuple_1 key fields > tuple_2 fields, = 0 if tuple_1 key fields = "
"tuple_2 fields, < 0 if tuple_1 key fields < tuple_2 fields"
msgstr ""
"> 0, если ключевые поля кортежа tuple_1 больше полей кортежа tuple_2; = 0, "
"если они равны; < 0, если ключевые поля кортежа tuple_1 меньше полей кортежа"
" tuple_2"

msgid ""
"-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3, collation = 'unicode_ci'},\n"
"                 {type = 'unsigned', fieldno = 1}})\n"
"k:compare_with_key({1, 99.5, 'X', nil, 99.5}, {'x', 1})"
msgstr ""
"-- Это вернет 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3, collation = 'unicode_ci'},\n"
"                 {type = 'unsigned', fieldno = 1}})\n"
"k:compare_with_key({1, 99.5, 'X', nil, 99.5}, {'x', 1})"

msgid ""
"Combine the main ``key_def_object`` with ``other_key_def_object``. The "
"return value is a new ``key_def_object`` containing all the fields of the "
"main ``key_def_object``, then all the fields of ``other_key_def_object`` "
"which are not in the main ``key_def_object``."
msgstr ""
"Объединяет основной объект ``key_def_object`` с другим объектом "
"``other_key_def_object``. Возвращает новый объект ``key_def_object`` "
"содержащий сначала все поля основного объекта ``key_def_object``, а потом те"
" поля объекта ``other_key_def_object``, которых не было в основном объекте "
"``key_def_object``."

msgid "definition of fields to add"
msgstr "определение полей для добавления"

msgid "key_def_object"
msgstr "key_def_object"

msgid ""
"-- This will return a key definition with fieldno = 3 and fieldno = 1.\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k2= key_def.new({{type = 'unsigned', fieldno = 1},\n"
"                 {type = 'string', fieldno = 3}})\n"
"k:merge(k2)"
msgstr ""
"-- Это вернет 0 определение ключа для полей с fieldno = 3 и fieldno = 1.\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k2= key_def.new({{type = 'unsigned', fieldno = 1},\n"
"                 {type = 'string', fieldno = 3}})\n"
"k:merge(k2)"

msgid ""
"Return a table containing what is in the ``key_def_object``. This is the "
"reverse of ``key_def.new()``:"
msgstr ""
"Возвращает таблицу, содержащую то, что находится в ``key_def_object``. Это "
"противоположность функции ``key_def.new()``:"

msgid "``key_def.new()`` takes a table and returns a ``key_def`` object,"
msgstr ""
"``key_def.new()`` возвращает объект ``key_def``, соответствующий таблице,"

msgid ""
"``key_def_object:totable()`` takes a ``key_def`` object and returns a table."
msgstr ""
"``key_def_object:totable()`` возвращает таблицу, соответствующую объекту "
"``key_def``."

msgid "This is useful for input to ``_serialize`` methods."
msgstr ""
"Это полезно для подготовки входных данных для методов сериализации "
"(``_serialize``)."

msgid "table"
msgstr "таблица"

msgid ""
"-- This will return a table with type = 'string', fieldno = 3\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k:totable()"
msgstr ""
"-- Это вернет таблицу с type = 'string', fieldno = 3\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k:totable()"
