
#, fuzzy
msgid "Module `key_def`"
msgstr "Модуль `socket`"

msgid ""
"The `key_def` module has a function for making a definition of the field "
"numbers and types of a tuple. The definition is usually used in "
"conjunction with an index definition to extract or compare the index key "
"values."
msgstr ""

#, fuzzy
msgid "Create a new key_def instance."
msgstr "Создание экземпляра iconv"

msgid "Parameters"
msgstr "Параметры"

msgid ""
"field numbers and types. There must be at least one part and it must have"
" at least fieldno and type."
msgstr ""

msgid "returns"
msgstr "возвращает"

msgid "key_def-object :ref:`a key_def object <key_def-object>`"
msgstr ""

#, fuzzy
msgid ""
"The parts table has components which are the same as the ``parts`` option"
" in :ref:`Options for space_object:create_index() <box_space-"
"create_index-options>`."
msgstr ""
"Если ``vinyl_range_size`` содержит не нулевое значение nil и не 0, это "
"значение используется в качестве значения по умолчанию для параметра "
"``range_size`` в таблице :ref:`Параметры space_object:create_index() "
"<box_space-create_index>`."

msgid ""
"fieldno (integer) for example fieldno = 1. It is legal to say field "
"instead of fieldno."
msgstr ""

msgid "type (string) for example type = 'string'."
msgstr ""

msgid "Other components are optional."
msgstr ""

msgid "Example: ``key_def.new({{type = 'unsigned', fieldno = 1}})``"
msgstr ""

msgid ""
"Example: ``key_def.new({{type = 'string', collation = 'unicode', field = "
"2}})``"
msgstr ""

msgid ""
"A key_def object is an object returned by :ref:`key_def.new() <key_def-"
"new>`. It has methods :ref:`extract_key() <key_def-extract_key>`, "
":ref:`compare() <key_def-compare>`, :ref:`compare_with_key() <key_def-"
"compare_with_key>`, :ref:`merge() <key_def-merge>`, :ref:`totable() "
"<key_def-totable>`."
msgstr ""

msgid "Return a tuple containing only the fields of the key_def object."
msgstr ""

msgid "tuple or Lua table with field contents"
msgstr ""

msgid "return"
msgstr "возвращает"

msgid "the fields that were defined for the key_def object"
msgstr ""

#, fuzzy
msgid "**Example #1:**"
msgstr "**Пример 1:**"

msgid ""
"-- Suppose that an item has five fields\n"
"-- 1, 99.5, 'X', nil, 99.5\n"
"-- and the fields that we care about are\n"
"-- #3 (a string) and #1 (an integer).\n"
"-- We can define those fields with k = key_def.new\n"
"-- and extract the values with k:extract_key.\n"
"\n"
"tarantool> key_def = require('key_def')\n"
"---\n"
"...\n"
"\n"
"tarantool> k = key_def.new({{type = 'string', fieldno = 3},\n"
">                           {type = 'unsigned', fieldno =1 }})\n"
"---\n"
"...\n"
"\n"
"tarantool> k:extract_key({1, 99.5, 'X', nil, 99.5})\n"
"---\n"
"- ['X', 1]\n"
"..."
msgstr ""

#, fuzzy
msgid "**Example #2**"
msgstr "**Пример 2:**"

msgid ""
"-- Now suppose that the item is a tuple in a space which\n"
"-- has an index on field #3 plus field #1.\n"
"-- We can use key_def.new with the index definition\n"
"-- instead of filling it out as we did with Example #1.\n"
"-- The result will be the same.\n"
"key_def = require('key_def')\n"
"box.schema.space.create('T')\n"
"i = box.space.T:create_index('I',{parts={3,'string',1,'unsigned'}})\n"
"box.space.T:insert{1, 99.5, 'X', nil, 99.5}\n"
"k = key_def.new(i.parts)\n"
"k:extract_key(box.space.T:get({'X', 1}))"
msgstr ""

#, fuzzy
msgid "**Example #3**"
msgstr "**Пример 2:**"

msgid ""
"-- Iterate through the tuples in a secondary non-unique index.\n"
"-- extracting the tuples' primary-key values so they can be deleted\n"
"-- using a unique index. This code should be part of a Lua function.\n"
"local key_def_lib = require('key_def')\n"
"local s = box.schema.space.create('test')\n"
"local pk = s:create_index('pk')\n"
"local sk = s:create_index('test', {unique = false, parts = {\n"
"    {2, 'number', path = 'a'}, {2, 'number', path = 'b'}}})\n"
"s:insert{1, {a = 1, b = 1}}\n"
"s:insert{2, {a = 1, b = 2}}\n"
"local key_def = key_def_lib.new(pk.parts)\n"
"for _, tuple in sk:pairs({1})) do\n"
"    local key = key_def:extract_key(tuple)\n"
"    pk:delete(key)\n"
"end"
msgstr ""

msgid ""
"Compare the key fields of tuple_1 to the key fields of tuple_2. This is a"
" tuple-by-tuple comparison so users do not have to write code which "
"compares a field at a time. Each field's type and collation will be taken"
" into account. In effect it is a comparison of extract_key(tuple_1) with "
"extract_key(tuple_2)."
msgstr ""

msgid ""
"> 0 if tuple_1 key fields > tuple_2 key fields, = 0 if tuple_1 key fields"
" = tuple_2 key fields, < 0 if tuple_1 key fields < tuple_2 key fields"
msgstr ""

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare({1, 99.5, 'X', nil, 99.5}, {1, 99.5, 'x', nil, 99.5})"
msgstr ""

msgid ""
"Compare the key fields of tuple_1 to all the fields of tuple_2. This is "
"the same as :ref:`key_def_object:compare() <key_def-compare>` except that"
" tuple_2 contains only the key fields. In effect it is a comparison of "
"extract_key(tuple_1) with tuple_2."
msgstr ""

msgid ""
"> 0 if tuple_1 key fields > tuple_2 fields, = 0 if tuple_1 key fields = "
"tuple_2 fields, < 0 if tuple_1 key fields < tuple_2 fields"
msgstr ""

msgid ""
"-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare_with_key({1, 99.5, 'X', nil, 99.5}, {'x', 1})"
msgstr ""

msgid ""
"Combine the main key_def_object with other_key_def_object. The return "
"value is a new key_def_object containing all the fields of the main "
"key_def_object, then all the fields of other_key_def_object which are not"
" in the main key_def_object."
msgstr ""

msgid "definition of fields to add"
msgstr ""

#, fuzzy
msgid "key_def_object"
msgstr "объект"

msgid ""
"-- This will return a key definition with fieldno=3 and fieldno=1.\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k2= key_def.new({{type = 'unsigned', fieldno = 1},\n"
"                 {type = 'string', fieldno = 3}})\n"
"k:merge(k2)"
msgstr ""

msgid ""
"Return a table containing what is in the key_def_object. This is the "
"reverse of ``key_def.new()``:"
msgstr ""

msgid "``key_def.new()`` takes a table and returns a key_def object,"
msgstr ""

msgid "``key_def_object:totable()`` takes a key_def object and returns a table."
msgstr ""

msgid "This is useful for input to ``_serialize`` methods."
msgstr ""

msgid "table"
msgstr "таблица"

msgid ""
"-- This will return a table with type='string', fieldno=3\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k:totable()"
msgstr ""

#~ msgid ""
#~ "Compare the key fields of tuple_1 "
#~ "to the key fields of tuple_2. This"
#~ " is a tuple-by-tuple comparison "
#~ "so users do not have to write "
#~ "code which compares a field at a"
#~ " time. Each field's type and "
#~ "collation wll be taken into account. "
#~ "In effect it is a comparison of"
#~ " extract_key(tuple_1) with extract_key(tuple_2)."
#~ msgstr ""
