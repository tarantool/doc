
msgid "Module key_def"
msgstr "Модуль key_def"

msgid ""
"The `key_def` module has a function for defining the field numbers and types"
" of a tuple. The definition is usually used with an index definition to "
"extract or compare the index key values."
msgstr ""
"В модуле `key_def` есть функция, позволяющая создавать определение номеров и"
" типов полей кортежа. Это определение обычно используется вместе с "
"определением индекса, чтобы извлекать или сравнивать значения ключей "
"индекса."

msgid "Create a new key_def instance."
msgstr "Создание нового экземпляра key_def."

msgid "Parameters"
msgstr "Параметры"

msgid ""
"field numbers and types. There must be at least one part. Every part must "
"contain the attributes ``type`` and ``fieldno``/``field``. Other attributes "
"are optional."
msgstr ""
"типы и номера полей. В таблице ``parts`` должен быть хотя бы один элемент. "
"Для каждого элемента обязательны только атрибуты ``type`` и "
"``fieldno``/``field``."

msgid "returns"
msgstr "возвращает"

msgid ":ref:`a key_def object <key_def-object>`"
msgstr ":ref:`объект key_def <key_def-object>`"

#, fuzzy
msgid ""
"The parts table has components which are the same as the ``parts`` option in"
" :ref:`Options for space_object:create_index() <index_opts_object>`."
msgstr ""
"Таблица parts содержит компоненты, аналогичные тем, что указываются в "
"параметре ``parts`` :ref:`при создании объекта space_object:create_index() "
"<box_space-create_index-options>`:"

msgid ""
"``fieldno`` (integer), for example, ``fieldno = 1``. It is legal to use "
"``field`` instead of ``fieldno``."
msgstr ""
"``fieldno`` (целое число), например ``fieldno = 1``. Вместо ``fieldno`` "
"можно использовать ``field``."

msgid "``type`` (string), for example, ``type = 'string'``."
msgstr "``type`` (строка), например ``type = 'string'``."

msgid "Other components are optional."
msgstr "Остальные компоненты необязательны."

msgid "Example: ``key_def.new({{type = 'unsigned', fieldno = 1}})``"
msgstr "Пример №1: ``key_def.new({{type = 'unsigned', fieldno = 1}})``"

msgid ""
"Example: ``key_def.new({{type = 'string', collation = 'unicode', field = "
"2}})``"
msgstr ""
"Пример №2: ``key_def.new({{type = 'string', collation = 'unicode', field = "
"2}})``"

msgid ""
"A key_def object is an object returned by :ref:`key_def.new() <key_def-"
"new>`. It has methods :ref:`extract_key() <key_def-extract_key>`, "
":ref:`compare() <key_def-compare>`, :ref:`compare_with_key() <key_def-"
"compare_with_key>`, :ref:`merge() <key_def-merge>`, :ref:`totable() "
"<key_def-totable>`."
msgstr ""
"Объект key_def возвращается функцией :ref:`key_def.new() <key_def-new>`. У "
"него есть следующие методы: :ref:`extract_key() <key_def-extract_key>`, "
":ref:`compare() <key_def-compare>`, :ref:`compare_with_key() <key_def-"
"compare_with_key>`, :ref:`merge() <key_def-merge>`, :ref:`totable() "
"<key_def-totable>`."

msgid "Return a tuple containing only the fields of the ``key_def`` object."
msgstr "Получение кортежа, содержащего только поля объекта ``key_def``."

msgid "tuple or Lua table with field contents"
msgstr "кортеж или Lua-таблица с содержимым поля"

msgid "return"
msgstr "возвращает"

msgid "the fields defined for the ``key_def`` object"
msgstr "поля, определенные для объекта ``key_def``,"

msgid "**Example #1:**"
msgstr "**Пример №1:**"

msgid ""
"-- Suppose an item has five fields\n"
"-- 1, 99.5, 'X', nil, 99.5\n"
"-- and the fields that we care about are\n"
"-- #3 (a string) and #1 (an integer).\n"
"-- We can define those fields with k = key_def.new\n"
"-- and extract the values with k:extract_key.\n"
"\n"
"tarantool> key_def = require('key_def')\n"
"---\n"
"...\n"
"\n"
"tarantool> k = key_def.new({{type = 'string', fieldno = 3},\n"
">                           {type = 'unsigned', fieldno = 1}})\n"
"---\n"
"...\n"
"\n"
"tarantool> k:extract_key({1, 99.5, 'X', nil, 99.5})\n"
"---\n"
"- ['X', 1]\n"
"..."
msgstr ""
"--  Предположим, что у некоторого элемента пять полей:\n"
"-- 1, 99.5, 'X', nil, 99.5\n"
"-- Нас интересуют только два из них:\n"
"-- третье (строка) и первое (целое число).\n"
"-- Мы можем определить эти поля инструкцией k = key_def.new\n"
"--  и извлечь значения командой k:extract_key.\n"
"\n"
"tarantool> key_def = require('key_def')\n"
"---\n"
"...\n"
"\n"
"tarantool> k = key_def.new({{type = 'string', fieldno = 3},\n"
">                           {type = 'unsigned', fieldno = 1}})\n"
"---\n"
"...\n"
"\n"
"tarantool> k:extract_key({1, 99.5, 'X', nil, 99.5})\n"
"---\n"
"- ['X', 1]\n"
"..."

msgid "**Example #2**"
msgstr "**Пример №2**"

msgid ""
"-- Now suppose the item is a tuple in a space with\n"
"-- an index on field #3 plus field #1.\n"
"-- We can use key_def.new with the index definition\n"
"-- instead of filling it out (Example #1).\n"
"-- The result will be the same.\n"
"key_def = require('key_def')\n"
"box.schema.space.create('T')\n"
"i = box.space.T:create_index('I', {parts={3, 'string', 1, 'unsigned'}})\n"
"box.space.T:insert{1, 99.5, 'X', nil, 99.5}\n"
"k = key_def.new(i.parts)\n"
"k:extract_key(box.space.T:get({'X', 1}))"
msgstr ""
"-- Теперь предположим, что элемент является кортежем в спейсе.\n"
"-- У спейса есть составной индекс, построенный по полям 3 и 1.\n"
"-- Мы можем передать определение индекса в качестве аргумента функции key_def.new,\n"
"-- а не заполнять определение, как в примере №1.\n"
"-- Результат будет тот же.\n"
"key_def = require('key_def')\n"
"box.schema.space.create('T')\n"
"i = box.space.T:create_index('I', {parts={3, 'string', 1, 'unsigned'}})\n"
"box.space.T:insert{1, 99.5, 'X', nil, 99.5}\n"
"k = key_def.new(i.parts)\n"
"k:extract_key(box.space.T:get({'X', 1}))"

msgid "**Example #3**"
msgstr "**Пример №3**"

msgid ""
"-- Iterate through the tuples in a secondary non-unique index\n"
"-- extracting the tuples' primary-key values, so they could be deleted\n"
"-- using a unique index. This code should be a part of a Lua function.\n"
"local key_def_lib = require('key_def')\n"
"local s = box.schema.space.create('test')\n"
"local pk = s:create_index('pk')\n"
"local sk = s:create_index('test', {unique = false, parts = {\n"
"    {2, 'number', path = 'a'}, {2, 'number', path = 'b'}}})\n"
"s:insert{1, {a = 1, b = 1}}\n"
"s:insert{2, {a = 1, b = 2}}\n"
"local key_def = key_def_lib.new(pk.parts)\n"
"for _, tuple in sk:pairs({1})) do\n"
"    local key = key_def:extract_key(tuple)\n"
"    pk:delete(key)\n"
"end"
msgstr ""
"-- Проходим по всем кортежам во вторичном неуникальном индексе\n"
"-- и извлекаем из них значения по первичному ключу.\n"
"-- Затем удаляем значения, используя уникальный индекс.\n"
"-- Этот код должен входить в Lua-функцию.\n"
"local key_def_lib = require('key_def')\n"
"local s = box.schema.space.create('test')\n"
"local pk = s:create_index('pk')\n"
"local sk = s:create_index('test', {unique = false, parts = {\n"
"    {2, 'number', path = 'a'}, {2, 'number', path = 'b'}}})\n"
"s:insert{1, {a = 1, b = 1}}\n"
"s:insert{2, {a = 1, b = 2}}\n"
"local key_def = key_def_lib.new(pk.parts)\n"
"for _, tuple in sk:pairs({1})) do\n"
"    local key = key_def:extract_key(tuple)\n"
"    pk:delete(key)\n"
"end"

msgid ""
"Compare the key fields of ``tuple_1`` with the key fields of ``tuple_2``. It"
" is a tuple-by-tuple comparison so users do not have to write code that "
"compares one field at a time. Each field's type and collation will be taken "
"into account. In effect it is a comparison of ``extract_key(tuple_1)`` with "
"``extract_key(tuple_2)``."
msgstr ""
"Сравнение полей кортежей ``tuple_1`` и ``tuple_2`` по определённому ключу. "
"Пользователю не нужно писать код для сравнения отдельных полей. Учитываются "
"типы полей и параметры сортировки. Фактически сравниваются значения "
"``extract_key(tuple_1)`` и ``extract_key(tuple_2)``."

msgid ""
"> 0 if tuple_1 key fields > tuple_2 key fields, = 0 if tuple_1 key fields = "
"tuple_2 key fields, < 0 if tuple_1 key fields < tuple_2 key fields"
msgstr ""
"положительное число, если значения полей tuple_1 больше значений полей "
"tuple_2 по ключу; 0, если они равны; отрицательное число, если значения "
"полей tuple_1 меньше значений полей tuple_2 по ключу"

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3, collation = 'unicode_ci'},\n"
"                 {type = 'unsigned', fieldno = 1}})\n"
"k:compare({1, 99.5, 'X', nil, 99.5}, {1, 99.5, 'x', nil, 99.5})"
msgstr ""
"-- Результат этого кода будет 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3, collation = 'unicode_ci'},\n"
"                 {type = 'unsigned', fieldno = 1}})\n"
"k:compare({1, 99.5, 'X', nil, 99.5}, {1, 99.5, 'x', nil, 99.5})"

msgid ""
"Compare the key fields of ``tuple_1`` with all the fields of ``tuple_2``. "
"This is the same as :ref:`key_def_object:compare() <key_def-compare>` except"
" that ``tuple_2`` contains only the key fields. In effect it is a comparison"
" of ``extract_key(tuple_1)`` with ``tuple_2``."
msgstr ""
"Сравнение полей кортежей ``tuple_1`` с полями кортежа ``tuple_2`` по "
"заданному ключу. Аналогично :ref:`key_def_object:compare() <key_def-"
"compare>`, за исключением того, что ``tuple_2`` содержит только поля ключа. "
"Фактически это сравнение ``extract_key(tuple_1)`` с ``tuple_2``."

msgid ""
"> 0 if tuple_1 key fields > tuple_2 fields, = 0 if tuple_1 key fields = "
"tuple_2 fields, < 0 if tuple_1 key fields < tuple_2 fields"
msgstr ""
"положительное число, если значения полей tuple_1 больше значений полей "
"tuple_2 по ключу; 0, если они равны; отрицательное число, если значения "
"полей tuple_1 меньше значений полей tuple_2 по ключу"

msgid ""
"-- Returns 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3, collation = 'unicode_ci'},\n"
"                 {type = 'unsigned', fieldno = 1}})\n"
"k:compare_with_key({1, 99.5, 'X', nil, 99.5}, {'x', 1})"
msgstr ""
"-- Результат этого кода будет 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3, collation = 'unicode_ci'},\n"
"                 {type = 'unsigned', fieldno = 1}})\n"
"k:compare_with_key({1, 99.5, 'X', nil, 99.5}, {'x', 1})"

msgid ""
"Combine the main ``key_def_object`` with ``other_key_def_object``. The "
"return value is a new ``key_def_object`` containing all the fields of the "
"main ``key_def_object``, then all the fields of ``other_key_def_object`` "
"which are not in the main ``key_def_object``."
msgstr ""
"Объединение основного объекта ``key_def_object`` с другим объектом "
"``other_key_def_object``. Возвращает новый объект ``key_def_object``, "
"содержащий сначала все поля основного объекта ``key_def_object``, а потом те"
" поля объекта ``other_key_def_object``, которых не было в основном объекте "
"``key_def_object``."

msgid "definition of fields to add"
msgstr "определение полей, которые нужно добавить"

msgid "key_def_object"
msgstr "key_def_object"

msgid ""
"-- Returns a key definition with fieldno = 3 and fieldno = 1.\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k2= key_def.new({{type = 'unsigned', fieldno = 1},\n"
"                 {type = 'string', fieldno = 3}})\n"
"k:merge(k2)"
msgstr ""
"-- Результатом этого кода будет определение ключа\n"
"-- по полям с fieldno = 3 и fieldno = 1\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k2= key_def.new({{type = 'unsigned', fieldno = 1},\n"
"                 {type = 'string', fieldno = 3}})\n"
"k:merge(k2)"

msgid ""
"Returns a table containing the fields of the ``key_def_object``. This is the"
" reverse of ``key_def.new()``:"
msgstr ""
"Возвращает таблицу с содержимым ``key_def_object``. Функция противоположна "
"функции ``key_def.new()``:"

msgid "``key_def.new()`` takes a table and returns a ``key_def`` object,"
msgstr "``key_def.new()`` принимает таблицу, а возвращает объект ``key_def``."

msgid ""
"``key_def_object:totable()`` takes a ``key_def`` object and returns a table."
msgstr ""
"``key_def_object:totable()`` принимает объект ``key_def``, а возвращает "
"таблицу."

msgid "This is useful for input to ``_serialize`` methods."
msgstr ""
"Это удобно при подготовке входных данных для методов сериализации "
"(``_serialize``)."

msgid "table"
msgstr "таблица"

msgid ""
"-- Returns a table with type = 'string', fieldno = 3\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k:totable()"
msgstr ""
"-- Результатом этого кода будет таблица с type = 'string', fieldno = 3\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k:totable()"
