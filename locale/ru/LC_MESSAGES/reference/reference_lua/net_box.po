
msgid "Module `net.box`"
msgstr "Модуль `net.box`"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"The ``net.box`` module contains connectors to remote database systems. "
"One variant, to be discussed later, is for connecting to MySQL or MariaDB"
" or PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). "
"The other variant, which is discussed in this section, is for connecting "
"to Tarantool server instances via a network."
msgstr ""
"Модуль ``net.box`` включает в себя коннекторы для удаленных систем с "
"базами данных. Одним из вариантов, который рассматривается позднее, "
"является подключение к MySQL, MariaDB или PostgreSQL (см. справочник по "
":ref:`Модулям  СУБД SQL <dbms_modules>`). Другим вариантом, который "
"рассматривается в данном разделе, является подключение к экземплярам "
"Tarantool-сервера по сети."

msgid "You can call the following methods:"
msgstr "Можно вызвать следующие методы:"

msgid ""
"``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for"
" examples in this section),"
msgstr ""
"``require('net.box')`` для получения объекта ``net.box`` (который "
"называется ``net_box`` для примеров в данном разделе),"

msgid ""
"``net_box.connect()`` to connect and get a connection object (named "
"``conn`` for examples in this section),"
msgstr ""
"``net_box.connect()`` для подключения и получения объекта подключения "
"(который называется ``conn`` для примеров в данном разделе),"

msgid ""
"other ``net.box()`` routines, passing ``conn:``, to execute requests on "
"the remote database system,"
msgstr ""
"другие процедуры ``net.box()``, передающие ``conn:`` для выполнения "
"запросов в удаленной системе базы данных,"

msgid "``conn:close`` to disconnect."
msgstr "``conn:close`` для отключения."

msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and "
"use the same connection object across multiple concurrent fibers. In fact"
" that is perhaps the best programming practice with Tarantool. When "
"multiple fibers use the same connection, all requests are pipelined "
"through the same network socket, but each fiber gets back a correct "
"response. Reducing the number of active sockets lowers the overhead of "
"system calls and increases the overall server performance. However for "
"some cases a single connection is not enough —- for example, when it is "
"necessary to prioritize requests or to use different authentication IDs."
msgstr ""
"Все методы ``net.box`` безопасны для файберов, то есть можно безопасно "
"обмениваться и использовать один и тот же объект подключения в нескольких"
" файберах одновременно. Фактически так лучше всего работать в "
"Tarantool'е. Когда несколько файберов используют одно соединение, все "
"запросы передаются по одному сетевому сокету, но каждый файбер получает "
"правильный ответ. Уменьшение количества активных сокетов снижает затрату "
"ресурсов на системные вызовы и увеличивает общую производительность "
"сервера. Однако, в некоторых случаях отдельного соединения недостаточно "
"-- например, когда необходимо отдавать приоритет разным запросам или "
"использовать различные идентификаторы при аутентификации."

msgid ""
"Most ``net.box`` methods allow a final ``{options}`` argument, which can "
"be:"
msgstr ""
"В большинстве методов ``net.box`` можно использовать заключительный "
"аргумент ``{options}``, который может быть:"

msgid ""
"``{timeout=...}``. For example, a method whose final argument is "
"``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although"
" this does not guarantee that execution will stop on the remote server "
"node."
msgstr ""
"``{timeout=...}``. Например, метод с заключительным аргументом "
"``{timeout=1.5}`` остановится через 1,5 секунды на локальном узле, хотя "
"это не гарантирует, что выполнение остановится на удаленном сервере."

msgid "``{buffer=...}``. For an example see :ref:`buffer module <buffer-module>`."
msgstr "``{buffer=...}``. Например, см. :ref:`модуль buffer <buffer-module>`."

msgid ""
"``{is_async=...}``. For example, a method whose final argument is "
"``{is_async=true}`` will not wait for the result of a request. See the "
":ref:`is_async <net_box-is_async>` description."
msgstr ""
"``{is_async=...}``. Например, метод с заключительным аргументом "
"``{is_async=true}`` не будет ждать результата выполнения запроса. См. "
"описание :ref:`is_async <net_box-is_async>`."

msgid ""
"``{on_push=... on_push_ctx=...}``. For receiving out-of-band messages. "
"See the :doc:`/reference/reference_lua/box_session/push` description."
msgstr ""
"``{on_push=... on_push_ctx=...}``. Для получения внеполосных сообщений. "
"См. описание :doc:`/reference/reference_lua/box_session/push`."

msgid "The diagram below shows possible connection states and transitions:"
msgstr ""
"На диаграмме ниже представлены возможные состояния и варианты перехода из"
" одного состояния в другое:"

msgid "On this diagram:"
msgstr "На этой диаграмме:"

msgid "The state machine starts in the 'initial' state."
msgstr "Работа начинается с начального состояния 'initial'."

msgid ""
"``net_box.connect()`` method changes the state to 'connecting' and spawns"
" a worker fiber."
msgstr ""
"Выполнение метода ``net_box.connect()`` переводит состояние в "
"'connecting', создается рабочий файбер."

msgid ""
"If authentication and schema upload are required, it's possible later on "
"to re-enter the 'fetch_schema' state from 'active' if a request fails due"
" to a schema version mismatch error, so schema reload is triggered."
msgstr ""
"Если требуются аутентификация и загрузка схемы, можно позднее повторно "
"войти в состояние загрузки схемы 'fetch_schema' из активного 'active', "
"если запрос не будет выполнен из-за ошибки несовпадения версий схемы, то "
"есть будет вызвана перезагрузка схемы."

msgid ""
"``conn.close()`` method sets the state to 'closed' and kills the worker. "
"If the transport is already in the 'error' state, ``close()`` does "
"nothing."
msgstr ""
"Метод ``conn.close()`` изменяет состояние на закрытое 'closed' и "
"отключает рабочий процесс. Если транспорт уже находится в состоянии "
"ошибки 'error', ``close()`` не делает ничего."

msgid "Index"
msgstr "Указатель"

msgid "Below is a list of all ``net.box`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``net.box``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Назначение"

msgid ""
":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() "
"<net_box-new>` |br| :ref:`net_box.self <net_box-self>`"
msgstr ""
":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() "
"<net_box-new>` |br| :ref:`net_box.self <net_box-self>`"

msgid "Create a connection"
msgstr "Создание подключения"

msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ":ref:`conn:ping() <conn-ping>`"

msgid "Execute a PING command"
msgstr "Выполнение команды проверки состояния PING"

msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ":ref:`conn:wait_connected() <conn-wait_connected>`"

msgid "Wait for a connection to be active or closed"
msgstr "Ожидание активности или закрытия подключения"

msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ":ref:`conn:is_connected() <conn-is_connected>`"

msgid "Check if a connection is active or closed"
msgstr "Проверка активности или закрытия подключения"

msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ":ref:`conn:wait_state() <conn-wait_state>`"

msgid "Wait for a target state"
msgstr "Ожидание нужного состояния"

msgid ":ref:`conn:close() <conn-close>`"
msgstr ":ref:`conn:close() <conn-close>`"

msgid "Close a connection"
msgstr "Закрытие подключения"

msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ":ref:`conn.space.space-name:select{field-value} <conn-select>`"

msgid "Select one or more tuples"
msgstr "Выбор одного или нескольких кортежей"

msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ":ref:`conn.space.space-name:get{field-value} <conn-get>`"

msgid "Select a tuple"
msgstr "Выбор кортежа"

msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"

msgid "Insert a tuple"
msgstr "Вставка кортежа"

msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"

msgid "Insert or replace a tuple"
msgstr "Вставка или замена кортежа"

msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ":ref:`conn.space.space-name:update{field-value} <conn-update>`"

msgid "Update a tuple"
msgstr "Обновление кортежа"

msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"

msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"

msgid "Delete a tuple"
msgstr "Удаление кортежа"

msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ":ref:`conn:eval() <net_box-eval>`"

msgid "Evaluate and execute the expression in a string"
msgstr "Оценка и выполнение выражения в строке"

msgid ":ref:`conn:call() <net_box-call>`"
msgstr ":ref:`conn:call() <net_box-call>`"

msgid "Call a stored procedure"
msgstr "Вызов хранимой процедуры"

msgid ":ref:`conn:timeout() <conn-timeout>`"
msgstr ":ref:`conn:timeout() <conn-timeout>`"

msgid "Set a timeout"
msgstr "Установка времени ожидания"

msgid ":ref:`conn:on_connect() <net_box-on_connect>`"
msgstr ":ref:`conn:on_connect() <net_box-on_connect>`"

msgid "Define a connect trigger"
msgstr "Определение триггера на подключение"

msgid ":ref:`conn:on_disconnect() <net_box-on_disconnect>`"
msgstr ":ref:`conn:on_disconnect() <net_box-on_disconnect>`"

msgid "Define a disconnect trigger"
msgstr "Определение триггера на отключение"

msgid ":ref:`conn:on_schema_reload() <net_box-on_schema_reload>`"
msgstr ":ref:`conn:on_schema_reload() <net_box-on_schema_reload>`"

msgid "Define a trigger when schema is modified"
msgstr "Определение триггера при изменении схемы"

msgid ""
"The names ``connect()`` and ``new()`` are synonyms: ``connect()`` is "
"preferred; ``new()`` is retained for backward compatibility."
msgstr ""
"Имена ``connect()`` и ``new()`` являются синонимами: предпочтительным "
"будет ``connect()``, а ``new()`` обеспечивает поддержку обратной "
"совместимости."

msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It can be re-established automatically after a"
" disconnect (see ``reconnect_after`` option below). The returned ``conn``"
" object supports methods for making remote requests, such as select, "
"update or delete."
msgstr ""
"Создание нового подключения. Подключение устанавливается по требованию во"
" время первого запроса. Можно повторно установить подключение "
"автоматически после отключения (см. ниже опцию ``reconnect_after``). "
"Возвращается объект ``conn``, который поддерживает методы создание "
"удаленных запросов, таких как select, update или delete."

msgid "Possible options:"
msgstr "Возможные опции:"

msgid ""
"`user/password`: you have two ways to connect to a remote host: using "
":ref:`URI <index-uri>` or using the options `user` and `password`. For "
"example, instead of ``connect('username:userpassword@localhost:33301')`` "
"you can write ``connect('localhost:33301', {user = 'username', "
"password='userpassword'})``."
msgstr ""
"`user/password`: есть два способа подключения к удаленному хосту: с "
"использованием :ref:`URI <index-uri>` или параметров `user` "
"(пользователь) и `password` (пароль). Например, вместо "
"``connect('username:userpassword@localhost:33301')`` можно ввести "
"``connect('localhost:33301', {user = 'имя-пользователя', "
"password='пароль-пользователя'})``."

msgid ""
"`wait_connected`: by default, connection creation is blocked until the "
"connection is established, but passing ``wait_connected=false`` makes it "
"return immediately. Also, passing a timeout makes it wait before "
"returning (e.g. ``wait_connected=1.5`` makes it wait at most 1.5 "
"seconds)."
msgstr ""
"`wait_connected`: по умолчанию, создание подключения блокируется до тех "
"пор, пока подключение не будет установлено, но передача "
"``wait_connected=false`` заставит метод сразу же вернуться. Передача "
"времени ожидания заставит метод ждать до возвращения (например, "
"``wait_connected=1.5`` заставит ожидать подключения максимум 1,5 "
"секунды)."

msgid ""
"If ``reconnect_after`` is greater than zero, then ``wait_connected`` "
"ignores transient failures. The wait completes once the connection is "
"established or is closed explicitly."
msgstr ""
"Если присутствует ``reconnect_after``, ``wait_connected`` проигнорирует "
"неустойчивые отказы. Ожидание заканчивается, когда подключение "
"установлено или явным образом закрыто."

msgid ""
"`reconnect_after`: if ``reconnect_after`` is greater than zero, then a "
"``net.box`` instance will try to reconnect if a connection is broken or "
"if a connection attempt fails. This makes transient network failures "
"become transparent to the application. Reconnect happens automatically in"
" the background, so requests that initially fail due to connectivity loss"
" are transparently retried. The number of retries is unlimited, "
"connection attempts are made after each specified interval (for example "
"``reconnect_after=5`` means try to reconnect every 5 seconds). When a "
"connection is explicitly closed, or when the Lua garbage collector "
"removes it, then reconnect attempts stop. The default value of "
"``reconnect_after``, as with other ``connect`` options, is ``nil``."
msgstr ""
"`reconnect_after`: ``net.box`` автоматически подключается повторно в "
"случае разрыва соединения или провала попытки подключения. В таком случае"
" неустойчивые сетевые отказы становятся очевидными. Повторное подключение"
" выполняется автоматически в фоновом режиме, поэтому запросы/обращения, "
"не выполненные по причине потери соединения, явным образом выполняются "
"повторно. Количество повторов не ограничено, попытки подключения "
"выполняются в течение указанного времени ожидания (например, "
"``reconnect_after=5`` -- 5 секунд). После явного закрытия подключения или"
" удаления сборщиком мусора в Lua попытки соединения повторно не "
"выполняются. Значение по умолчанию для параметра ``reconnect_after``, как"
" и для других ``connect`` опций, равно ``nil``."

msgid ""
"`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with "
"a new binary protocol command for CALL, which is not backward compatible "
"with previous versions. The new CALL no longer restricts a function to "
"returning an array of tuples and allows returning an arbitrary "
"MsgPack/JSON result, including scalars, nil and void (nothing). The old "
"CALL is left intact for backward compatibility. It will be removed in the"
" next major release. All programming language drivers will be gradually "
"changed to use the new CALL. To connect to a Tarantool instance that uses"
" the old CALL, specify ``call_16=true``."
msgstr ""
"`call_16`: [с 1.7.2] по умолчанию, подключения ``net.box`` соответствуют "
"команде CALL нового бинарного протокола, который не поддерживает обратную"
" совместимость с предыдущими версиями. Команда нового бинарного протокола"
" для вызова CALL больше не ограничивает функцию в возврате массива "
"кортежей и позволяет возвращать произвольный результат в формате "
"MsgPack/JSON, включая scalar (скалярные значения), nil (нулевые значения)"
" и void (пусто). Старый метод CALL оставлен нетронутым для обратной "
"совместимости. В следующей основной версии он будет удален. Все драйверы "
"для языков программирования будут постепенно переведены на использование "
"нового метода CALL. Для подключения к экземпляру Tarantool'а, в котором "
"используется старый метод CALL, укажите ``call_16=true``."

msgid ""
"`console`: depending on the option's value, the connection supports "
"different methods (as if instances of different classes were returned). "
"With ``console = true``, you can use ``conn`` methods ``close()``, "
"``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both "
"binary and Lua console network protocols are supported). With ``console ="
" false`` (default), you can also use ``conn`` database methods (in this "
"case, only the binary protocol is supported). Deprecation notice: "
"``console = true`` is deprecated, users should use "
":ref:`console.connect() <console-connect>` instead."
msgstr ""
"`console`: в зависимости от значения параметра поддерживаются различные "
"методы (как если бы возвращались экземпляры разных классов). Если "
"``console = true``, можно использовать методы ``conn``: ``close()``, "
"``is_connected()``, ``wait_state()``, ``eval()`` (в этом случае "
"поддерживаются и бинарный сетевой протокол, и протокол Lua-консоли). Если"
" ``console = false`` (по умолчанию), также можно использовать методы "
"``conn`` для работы с базой данных (в этом случае поддерживается только "
"бинарный протокол). Устарел: ``console = true`` объявлен устаревшим, "
"вместо него следует использовать :ref:`console.connect() <console-"
"connect>`."

msgid ""
"`connect_timeout`: number of seconds to wait before returning \"error: "
"Connection timed out\"."
msgstr ""
"`connect_timeout`: количество секунд ожидания до возврата ошибки \"error:"
" Connection timed out\"."

msgid "Parameters"
msgstr "Параметры"

msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ":ref:`URI <index-uri>` объекта подключения"

msgid ""
"possible options are `user`, `password`, `wait_connected`, "
"`reconnect_after`, `call_16`, `console` and `connect_timeout`"
msgstr ""
"возможные опции: `user`, `password`, `wait_connected`, `reconnect_after`,"
" `call_16`, `console` и `connect_timeout`"

msgid "return"
msgstr "возвращает"

msgid "conn object"
msgstr "объект подключения"

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "userdata"
msgstr "пользовательские данные"

msgid "**Examples:**"
msgstr "**Примеры:**"

msgid ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = "
"true})"
msgstr ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = "
"true})"

msgid ""
"For a local Tarantool server, there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`."
msgstr ""
"Для локального Tarantool-сервера есть заданный объект всегда "
"установленного подключения под названием :samp:`{net_box}.self`. Он "
"создан с целью облегчить полиморфное использование API модуля "
"``net_box``. Таким образом, :samp:`conn = "
"{net_box}.connect('localhost:3301')` можно заменить на :samp:`conn = "
"{net_box}.self`."

msgid ""
"However, there is an important difference between the embedded connection"
" and a remote one:"
msgstr "Однако, есть важно отличие встроенного подключения от удаленного:"

msgid ""
"With the embedded connection, requests which do not modify data do not "
"yield. When using a remote connection, due to :ref:`the implicit rules "
"<atomic-implicit-yields>` any request can yield, and the database state "
"may have changed by the time it regains control."
msgstr ""
"При встроенном подключении запросы без изменения данных не передают "
"управление. При использовании удаленного подключения любой запрос может "
"передавать управление исходя из :ref:`правил неявной передачи управления "
"<atomic-implicit-yields>`, и состояние базы данных может измениться к "
"тому времени, как управление вернется."

msgid ""
"All the options passed to a request (as ``is_async``, ``on_push``, "
"``timeout``) will be ignored."
msgstr ""
"Не учитывается ни один параметр, передаваемый в запросе (``is_async``, "
"``on_push``, ``timeout``)."

msgid "Execute a PING command."
msgstr "Выполнение команды проверки состояния PING."

msgid "the supported option is :samp:`timeout={seconds}`"
msgstr "поддерживается опция :samp:`timeout={секунды}`"

msgid "true on success, false on error"
msgstr "true (правда), если выполнено, false (ложь) в случае ошибки"

msgid "boolean"
msgstr "boolean (логический)"

msgid "**Example:**"
msgstr "**Пример:**"

msgid "net_box.self:ping({timeout = 0.5})"
msgstr "net_box.self:ping({timeout = 0.5})"

msgid "Wait for connection to be active or closed."
msgstr "Ожидание активности или закрытия подключения."

msgid "in seconds"
msgstr "в секундах"

msgid "true when connected, false on failure."
msgstr "true (правда) при подключении, false (ложь), если не выполнено."

msgid "net_box.self:wait_connected()"
msgstr "net_box.self:wait_connected()"

msgid "Show whether connection is active or closed."
msgstr "Проверка активности или закрытия подключения."

msgid "true if connected, false on failure."
msgstr "true (правда) при подключении, false (ложь), если не выполнено."

msgid "net_box.self:is_connected()"
msgstr "net_box.self:is_connected()"

msgid "[since 1.7.2] Wait for a target state."
msgstr "[с 1.7.2] Ожидание нужного состояния."

msgid "target states"
msgstr "необходимое состояние"

msgid ""
"true when a target state is reached, false on timeout or connection "
"closure"
msgstr ""
"true (правда) при подключении, false (ложь) при окончании времени "
"ожидания или закрытии подключения"

msgid ""
"-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""
"-- бесконечное ожидание состояния 'active':\n"
"conn:wait_state('active')\n"
"\n"
"-- ожидание в течение максимум 1,5 секунд:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- бесконечное ожидание состояния `active` или `fetch_schema`:\n"
"conn:wait_state({active=true, fetch_schema=true})"

msgid "Close a connection."
msgstr "Закрытие подключения."

msgid ""
"Connection objects are destroyed by the Lua garbage collector, just like "
"any other objects in Lua, so an explicit destruction is not mandatory. "
"However, since close() is a system call, it is good programming practice "
"to close a connection explicitly when it is no longer needed, to avoid "
"lengthy stalls of the garbage collector."
msgstr ""
"Объекты подключения удаляются сборщиком мусора в Lua, как и любой другой "
"Lua-объект, поэтому удалять их явным образом необязательно. Однако, "
"поскольку close() представляет собой системный вызов, лучше всего закрыть"
" соединение явным образом, когда оно больше не используется, с целью "
"ускорения работы сборщика мусора."

msgid "conn:close()"
msgstr "conn:close()"

msgid ""
":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-"
"name}:select`:code:`{...}` (:ref:`see details <box_space-select>`). For "
"an additional option see :ref:`Module buffer and skip-header <buffer-"
"module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:select`:code:`({...})` -- это удаленный "
"вызов, аналогичный локальному вызову "
":samp:`box.space.{имя-спейса}:select`:code:`{...}` (:ref:`детали "
"<box_space-select>`). В дополнение см. :ref:`Модуль buffer и skip-header "
"<buffer-module_and_skip_header>`."

msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr "conn.space.testspace:select({1,'B'}, {timeout=1})"

msgid ""
"Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local "
":samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does "
"yield, so global variables or database tuples data may change when a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""
"Исходя из :ref:`правил неявной передачи управления <atomic-implicit-"
"yields>`, локальный запрос "
":samp:`box.space.{имя-спейса}:select`:code:`{...}` не передает "
"управление, а удаленный "
":samp:`conn.space.{имя-спейса}:select`:code:`{...}` передаст, поэтому "
"глобальные переменные или кортежи в базе данных могут измениться во время"
" удаленного :samp:`conn.space.{имя-спейса}:select`:code:`{...}`."

msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:get(...)` (:ref:`see "
"details <box_space-get>`)."
msgstr ""
":samp:`conn.space.{имя-спейса}:get(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:get(...)` "
"(:ref:`детали <box_space-get>`)."

msgid "conn.space.testspace:get({1})"
msgstr "conn.space.testspace:get({1})"

msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:insert(...)` (:ref:`see "
"details <box_space-insert>`). For an additional option see :ref:`Module "
"buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:insert(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:insert(...)` "
"(:ref:`детали <box_space-insert>`). В дополнение см. :ref:`Модуль buffer "
"и skip-header <buffer-module_and_skip_header>`."

msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"

msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-name}:replace(...)` "
"(:ref:`see details <box_space-replace>`). For an additional option see "
":ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:replace(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:replace(...)`"
" (:ref:`детали <box_space-replace>`). В дополнение см. :ref:`Модуль "
"buffer и skip-header <buffer-module_and_skip_header>`."

msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr "conn.space.testspace:replace({5,6,7,8})"

msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:update(...)` (:ref:`see "
"details <box_space-update>`). For an additional option see :ref:`Module "
"buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:update(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:update(...)`."

msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"

msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:upsert(...)`. (:ref:`see"
" details <box_space-upsert>`) For an additional option see :ref:`Module "
"buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:upsert(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:upsert(...)` "
"(:ref:`детали <box_space-upsert>`). В дополнение см. :ref:`Модуль buffer "
"и skip-header <buffer-module_and_skip_header>`."

msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:delete(...)` (:ref:`see "
"details <box_space-delete>`). For an additional option see :ref:`Module "
"buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:delete(...)` -- это удаленный вызов, "
"аналогичный локальному вызову "
":samp:`box.space.{имя-спейса}:delete(...)`.(:ref:`детали <box_space-"
"delete>`). В дополнение см. :ref:`Модуль buffer и skip-header <buffer-"
"module_and_skip_header>`."

msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in "
"Lua-string, which may be any statement or series of statements. An "
":ref:`execute privilege <authentication-owners_privileges>` is required; "
"if the user does not have it, an administrator may grant it with "
":samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""
":samp:`conn:eval({Lua-строка})` оценивает и выполняет выражение в "
"Lua-строке, которое может представлять собой любое выражение или "
"несколько выражений. Требуются :ref:`права на выполнение <authentication-"
"owners_privileges>`; если у пользователя таких прав нет, администратор "
"может их выдать с помощью "
":samp:`box.schema.user.grant({имя-пользователя}, 'execute', 'universe')`."

msgid ""
"To ensure that the return from ``conn:eval`` is whatever the Lua "
"expression returns, begin the Lua-string with the word \"return\"."
msgstr ""
"Чтобы гарантировать, что ``conn:eval`` вернет то, что возвращает "
"выражение на Lua, начните Lua-строку со слова \"return\" (вернуть)."

msgid ""
"tarantool> --Lua-string\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-string, {arguments}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-string, {arguments}, {options}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."
msgstr ""
"tarantool> --Lua-строка\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-строка, {аргументы}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-строка, {аргументы}, {парметры}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."

msgid ""
"``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of "
"``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-"
"procedure call. The return from ``conn:call`` is whatever the function "
"returns."
msgstr ""
"``conn:call('func', {'1', '2', '3'})`` -- это удаленный вызов, "
"аналогичный ``func('1', '2', '3')``. Таким образом, ``conn:call`` "
"представляет собой удаленный вызов хранимой процедуры. ``conn:call`` "
"возвращает то, что возвращает функция."

msgid ""
"Limitation: the called function cannot return a function, for example if "
"``func2`` is defined as ``function func2 () return func end`` then "
"``conn:call(func2)`` will return \"error: unsupported Lua type "
"'function'\"."
msgstr ""
"Ограничение: вызванная функция не может вернуть функцию, например, если "
"``func2`` определяется как ``function func2 () return func end``, то "
"``conn:call(func2)`` вернет ошибку \"error: unsupported Lua type "
"'function'\"."

msgid ""
"tarantool> -- create 2 functions with conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- call first function with no parameters and no options\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- call second function with two parameters and one option\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."
msgstr ""
"tarantool> -- создание 2 функций с conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- вызов первой функции без параметров и опций\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- вызов второй функции с двумя параметрами и одной опцией\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."

msgid ""
"``timeout(...)`` is a wrapper which sets a timeout for the request that "
"follows it. Since version 1.7.4 this method is deprecated -- it is better"
" to pass a timeout value for a method's ``{options}`` parameter."
msgstr ""
"``timeout(...)`` -- это надстройка, которая определяет время ожидания для"
" запроса. С версии 1.7.4 этот метод объявлен устаревшим -- лучше передать"
" значение времени ожидания с помощью параметра ``{options}``."

msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"

msgid ""
"Although ``timeout(...)`` is deprecated, all remote calls support its "
"use. Using a wrapper object makes the remote connection API compatible "
"with the local one, removing the need for a separate ``timeout`` "
"argument, which the local version would ignore. Once a request is sent, "
"it cannot be revoked from the remote server even if a timeout expires: "
"the timeout expiration only aborts the wait for the remote server "
"response, not the request itself."
msgstr ""
"Хотя ``timeout(...)`` объявлен устаревшим, все удаленные вызовы "
"поддерживают его. Использование надстройки обеспечивает совместимость API"
" удаленного соединения с локальным, поэтому отпадает необходимость в "
"отдельном аргументе ``timeout``, который проигнорирует локальная версия. "
"После отправки запроса его нельзя отменить с удаленного сервера даже по "
"истечении времени задержки: окончание времени задержки прерывает только "
"ожидание ответа от удаленного сервера, а не сам запрос."

msgid ""
"``{is_async=true|false}`` is an option which is applicable for all "
"``net_box`` requests including ``conn:call``, ``conn:eval``, and the "
"``conn.space.space-name`` requests."
msgstr ""
"``{is_async=true|false}`` -- это опция, которую можно применить во всех "
"запросах ``net_box``, включая ``conn:call``, ``conn:eval`` и запросы "
"``conn.space.space-name``."

msgid ""
"The default is ``is_async=false``, meaning requests are synchronous for "
"the fiber. The fiber is blocked, waiting until there is a reply to the "
"request or until timeout expires. Before Tarantool version 1.10, the only"
" way to make asynchronous requests was to put them in separate fibers."
msgstr ""
"По умолчанию, ``is_async=false``, что означает, что запросы будут "
"синхронными для файбера. Файбер блокируется в ожидании ответа на запрос "
"или до истечения времени ожидания. До версии Tarantool'а 1.10 "
"единственным способом выполнения асинхронных запросов было использование "
"отдельных файберов."

msgid ""
"The non-default is ``is_async=true``, meaning requests are asynchronous "
"for the fiber. The request causes a yield but there is no waiting. The "
"immediate return is not the result of the request, instead it is an "
"object that the calling program can use later to get the result of the "
"request."
msgstr ""
"``is_async=true`` означает, что запросы будут асинхронными для файбера. "
"Запрос вызывает передачу управления, но файбер не входит в режим "
"ожидания. Сразу же возвращается результат, но это будет не результат "
"запроса, а объект, который может использовать вызывающая программа для "
"получения результат запроса."

msgid ""
"This immediately-returned object, which we'll call \"future\", has its "
"own methods:"
msgstr ""
"У такого сразу же возвращаемого объекта, который мы называем \"future\" "
"(будущий), есть собственные методы:"

msgid ""
"``future:is_ready()`` which will return true when the result of the "
"request is available,"
msgstr ""
"``future:is_ready()`` вернет true (правда), если доступен результат "
"запроса,"

msgid ""
"``future:result()`` to get the result of the request (returns the "
"response or **nil** in case it's not ready yet or there has been an "
"error),"
msgstr ""
"``future:result()`` используется для получения результата запроса "
"(возвращает ответ на запрос или **nil** в случае, если ответ еще не готов"
" или произошла какая-либо ошибка),"

msgid ""
"``future:wait_result(timeout)`` to wait until the result of the request "
"is available and then get it, or throw an error if there is no result "
"after the timeout exceeded,"
msgstr ""
"``future:wait_result(timeout)`` будет ждать, когда результат запроса "
"будет доступен, а затем получит его или выдаст ошибку, если по истечении "
"времени ожидания результат не получен."

msgid "``future:discard()`` to abandon the object."
msgstr "``future:discard()`` откажется от объекта."

msgid ""
"Typically a user would say ``future=request-name(...{is_async=true})``, "
"then either loop checking ``future:is_ready()`` until it is true and then"
" say ``request_result=future:result()``, or say "
"``request_result=future:wait_result(...)``. Alternatively the client "
"could check for \"out-of-band\" messages from the server by calling "
"``pairs()`` in a loop -- see "
":doc:`/reference/reference_lua/box_session/push`."
msgstr ""
"В обычной ситуации пользователь введет команду "
"``future=имя-запроса(...{is_async=true})``, а затем либо цикл с проверкой"
" ``future:is_ready()`` до тех пор, пока он не вернет true, и получением "
"результата с помощью  ``request_result=future:result()``, либо же команду"
" ``request_result=future:wait_result(...)``. Возможен вариант, когда "
"клиент проверяет наличие внеполосных сообщений от сервера, вызывая в "
"цикле ``pairs()`` -- см. "
":doc:`/reference/reference_lua/box_session/push`."

msgid ""
"A user would say ``future:discard()`` to make a connection forget about "
"the response -- if a response for a discarded object is received then it "
"will be ignored, so that the size of the requests table will be reduced "
"and other requests will be faster."
msgstr ""
"Можно использовать ``future:discard()``, чтобы соединение забыло об "
"ответе -- если получен ответ для отброшенного объекта, то он будет "
"проигнорирован, так что размер таблицы запросов будет уменьшен, а другие "
"запросы будут выполняться быстрее."

msgid ""
"tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."
msgstr ""
"tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."

msgid ""
"Typically ``{is_async=true}`` is used only if the load is large (more "
"than 100,000 requests per second) and latency is large (more than 1 "
"second), or when it is necessary to send multiple requests in parallel "
"then collect responses (sometimes called a \"map-reduce\" scenario)."
msgstr ""
"Как правило, ``{is_async=true}`` используется только при большой загрузке"
" (более 100 000 запросов в секунду) и большой задержке чтения (более 1 "
"секунды), или же при необходимости отправки нескольких одновременных "
"запросов, которые собирают ответы (что иногда называется "
"\"отображение-свертка\")."

msgid ""
"Although the final result of an async request is the same as the result "
"of a sync request, it is structured differently: as a table, instead of "
"as the unpacked values."
msgstr ""
"Хотя окончательный результат асинхронного запроса не отличается от "
"результата синхронного запроса, у него другая структура: таблица, а не "
"неупакованные значения."

msgid "Triggers"
msgstr "Триггеры"

msgid ""
"With the ``net.box`` module, you can use the following :ref:`triggers "
"<triggers-box_triggers>`:"
msgstr ""
"В модуле ``net.box`` можно использовать следующие :ref:`триггеры "
"<triggers-box_triggers>`:"

msgid ""
"Define a trigger for execution when a new connection is established, and "
"authentication and schema fetch are completed due to an event such as "
"``net_box.connect``. If the trigger execution fails and an exception "
"happens, the connection's state changes to 'error'. In this case, the "
"connection is terminated, regardless of the ``reconnect_after`` option's "
"value. Can be called as many times as reconnection happens, if "
"``reconnect_after`` is greater than zero."
msgstr ""
"Определение триггера, исполняемого, когда устанавливается новое "
"соединение (и при условии, что аутентификация и сборка схемы завершены) "
"при таком событии, как ``net_box.connect``. Если триггер не срабатывает и"
" выкидывает исключение, статус подключения меняется на 'error'.В таком "
"случае соединение прерывается, независимо от значения опции "
"``reconnect_after``. Может вызываться столько раз, сколько раз происходит"
" переподключение, если значение параметра ``reconnect_after`` больше "
"нуля."

msgid ""
"function which will become the trigger function. Takes the ``conn`` "
"object as the first argument"
msgstr ""
"функция, в которой будет триггер. В качестве первого аргумента берет "
"объект ``conn``"

msgid "existing trigger function which will be replaced by trigger-function"
msgstr "существующая функция с триггером, которую заменит новая"

msgid "nil or function pointer"
msgstr "nil или указатель функции"

msgid ""
"Define a trigger for execution after a connection is closed. If the "
"trigger function causes an error, the error is logged but otherwise is "
"ignored. Execution stops after a connection is explicitly closed, or once"
" the Lua garbage collector removes it."
msgstr ""
"Определение триггера, исполняемого после закрытия соединения. Если "
"функция с триггером вызывает ошибку, то ошибка записывается в журнал, в "
"противном случае записей не будет. Выполнение прекращается после явного "
"закрытия соединения или удаления сборщиком мусора в Lua."

msgid ""
"Define a trigger executed when some operation has been performed on the "
"remote server after schema has been updated. So, if a server request "
"fails due to a schema version mismatch error, schema reload is triggered."
msgstr ""
"Определение триггера, исполняемого во время выполнения определенной "
"операции на удаленном сервере после обновления схемы. Другими словами, "
"если запрос к серверу не выполняется из-за ошибки несовпадения версии "
"схемы, происходит перезагрузка схемы."

msgid ""
"If the parameters are ``(nil, old-trigger-function)``, then the old "
"trigger is deleted."
msgstr ""
"Если указаны параметры ``(nil, old-trigger-function)``, старый триггер "
"будет удален."

msgid ""
"If both parameters are omitted, then the response is a list of existing "
"trigger functions."
msgstr ""
"Если не указан ни один параметр, ответом будет список существующих "
"функций с триггером."

msgid ""
"Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""
"Подробная информация о характеристиках триггера находится в разделе "
":ref:`Триггеры <triggers-box_triggers>`."

msgid "Example"
msgstr "Пример"

msgid "This example shows the use of most of the ``net.box`` methods."
msgstr "Ниже приводится пример использования большинства методов ``net.box``."

msgid "The sandbox configuration for this example assumes that:"
msgstr "Данный пример сработает на конфигурации из песочницы, предполагается, что:"

msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr "экземпляр Tarantool'а запущен на ``localhost 127.0.0.1:3301``,"

msgid ""
"there is a space named ``tester`` with a numeric primary key and with a "
"tuple that contains a key value = 800,"
msgstr ""
"создан спейс под названием ``tester`` с первичным числовым ключом и "
"кортежем, в котором есть ключ со значением= 800,"

msgid "the current user has read, write and execute privileges."
msgstr "у текущего пользователя есть права на чтение, запись и выполнение."

msgid "Here are commands for a quick sandbox setup:"
msgstr "Ниже приведены команды для быстрой настройки песочницы:"

msgid ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"

msgid "And here starts the example:"
msgstr "А здесь приведен пример:"

msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
