
msgid "Module net.box"
msgstr "Модуль net.box"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"The ``net.box`` module contains connectors to remote database systems. One "
"variant, to be discussed later, is for connecting to MySQL or MariaDB or "
"PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). The other"
" variant, which is discussed in this section, is for connecting to Tarantool"
" server instances via a network. For a quick start with ``net.box``, refer "
"to the :ref:`tutorial <getting_started_net_box>`."
msgstr ""
"Модуль ``net.box`` включает в себя коннекторы для удаленных систем с базами "
"данных. Одним из вариантов, который рассматривается позднее, является "
"подключение к MySQL, MariaDB или PostgreSQL (см. справочник по :ref:`Модулям"
"  СУБД SQL <dbms_modules>`). Другим вариантом, который рассматривается в "
"данном разделе, является подключение к экземплярам Tarantool-сервера по "
"сети. Для быстрого знакомства с ``net.box`` вы можете обратиться к разделу "
":ref:`Начало работы с net.box <getting_started_net_box>`."

msgid "You can call the following methods:"
msgstr "Можно вызвать следующие методы:"

msgid ""
"``require('net.box')`` -- to get a ``net.box`` object (named ``net_box`` for"
" examples in this section)"
msgstr ""
"``require('net.box')`` -- для получения объекта ``net.box`` (который "
"называется ``net_box`` для примеров в данном разделе);"

msgid ""
"``net_box.connect()`` -- to connect and get a connection object (named "
"``conn`` for examples in this section)"
msgstr ""
"``net_box.connect()`` -- для подключения и получения объекта подключения "
"(который называется ``conn`` для примеров в данном разделе);"

msgid ""
"other ``net.box()`` routines, passing ``conn:``, to execute requests on the "
"remote database system"
msgstr ""
"другие процедуры ``net.box()``, передающие ``conn:`` для выполнения запросов"
" в удаленной системе базы данных;"

msgid "``conn:close`` -- to disconnect"
msgstr "``conn:close`` -- для отключения."

msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and use"
" the same connection object across multiple concurrent fibers. In fact that "
"is perhaps the best programming practice with Tarantool. When multiple "
"fibers use the same connection, all requests are pipelined through the same "
"network socket, but each fiber gets back a correct response. Reducing the "
"number of active sockets lowers the overhead of system calls and increases "
"the overall server performance. However for some cases a single connection "
"is not enough -- for example, when it is necessary to prioritize requests or"
" to use different authentication IDs."
msgstr ""
"Все методы ``net.box`` безопасны для файберов, то есть можно безопасно "
"обмениваться и использовать один и тот же объект подключения в нескольких "
"файберах одновременно. Фактически так лучше всего работать в Tarantool. "
"Когда несколько файберов используют одно соединение, все запросы передаются "
"по одному сетевому сокету, но каждый файбер получает правильный ответ. "
"Уменьшение количества активных сокетов снижает затрату ресурсов на системные"
" вызовы и увеличивает общую производительность сервера. Однако, в некоторых "
"случаях отдельного соединения недостаточно --- например, когда необходимо "
"отдавать приоритет разным запросам или использовать различные идентификаторы"
" при аутентификации."

msgid ""
"Most ``net.box`` methods accept the last ``{options}`` argument, which can "
"be:"
msgstr ""
"В большинстве методов ``net.box`` можно использовать последний аргумент "
"``{options}``, который может быть следующим:"

msgid ""
"``{timeout=...}``. For example, a method whose last argument is "
"``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although "
"this does not guarantee that execution will stop on the remote server node."
msgstr ""
"``{timeout=...}``. Например, метод с последним аргументом ``{timeout=1.5}`` "
"остановится через 1,5 секунды на локальном узле, хотя это не гарантирует, "
"что выполнение остановится на удаленном сервере."

msgid ""
"``{buffer=...}``. For an example, see the :ref:`buffer module <buffer-"
"module>`."
msgstr "``{buffer=...}``. Например, см. :ref:`модуль buffer <buffer-module>`."

msgid ""
"``{is_async=...}``. For example, a method whose last argument is "
"``{is_async=true}`` will not wait for the result of a request. See the "
":ref:`is_async <net_box-is_async>` description."
msgstr ""
"``{is_async=...}``. Например, метод с заключительным аргументом "
"``{is_async=true}`` не будет ждать результата выполнения запроса. См. "
"описание :ref:`is_async <net_box-is_async>`."

msgid ""
"``{on_push=... on_push_ctx=...}``. For receiving out-of-band messages. See "
"the :doc:`/reference/reference_lua/box_session/push` description."
msgstr ""
"``{on_push=... on_push_ctx=...}``. Для получения внеполосных сообщений. См. "
"описание :doc:`/reference/reference_lua/box_session/push`."

msgid ""
"``{return_raw=...}`` (since version 2.10.0). If set to ``true``, net.box "
"returns response data wrapped in a :ref:`MsgPack object <msgpack-object-"
"info>` instead of decoding it to Lua. The default value is ``false``. For an"
" example, see option description :ref:`below <net_box-return_raw>`."
msgstr ""

msgid "The diagram below shows possible connection states and transitions:"
msgstr ""
"На диаграмме ниже представлены возможные состояния и варианты перехода из "
"одного состояния в другое:"

#, fuzzy
msgid "net_states.png"
msgstr "net_states.svg"

msgid "On this diagram:"
msgstr "На этой диаграмме:"

msgid ""
"``net_box.connect()`` method spawns a worker fiber, which will establish the"
" connection and start the state machine."
msgstr ""
"Метод ``net_box.connect()`` запускает рабочий файбер, который устанавливает "
"соединение и запускает рабочий процесс."

#, fuzzy
msgid "The state machine goes to the ``initial`` state."
msgstr "Работа начинается с начального состояния 'initial'."

#, fuzzy
msgid ""
"Authentication and schema upload. It is possible later on to re-enter the "
"``fetch_schema`` state from ``active`` to trigger schema reload."
msgstr ""
"Процесс аутентификации и загрузки схемы. Позднее можно повторно войти в "
"состояние загрузки схемы 'fetch_schema' из активного 'active', чтобы вызвать"
" перезагрузку схемы."

msgid ""
"The state changes to the ``graceful_shutdown`` state when the state machine "
"receives a :ref:`box.shutdown <system-events_box-shutdown>` event from the "
"remote host (see :ref:`conn:on_shutdown() <net_box-on_shutdown>`). Once all "
"pending requests are completed, the state machine switches to the ``error`` "
"(``error_reconnect``) state."
msgstr ""

#, fuzzy
msgid ""
"The transport goes to the ``error`` state in case of an error. It can "
"happen, for example, if the server closed the connection. If the "
"``reconnect_after`` option is set, instead of the ‘error’ state, the "
"transport goes to the ``error_reconnect`` state."
msgstr ""
"Если возникнет ошибка, транспорт перейдет в состояние ошибки 'error'. Ошибка"
" происходит, например, если сервер закрыл соединение. Если настроена опция "
"``reconnect_after``, вместо состояния ошибки 'error' транспорт перейдет в "
"состояние 'error_reconnect' — повторного подключения в случае возникновения "
"ошибки."

#, fuzzy
msgid ""
"``conn.close()`` method sets the state to ``closed`` and kills the worker. "
"If the transport is already in the ``error`` state, ``close()`` does "
"nothing."
msgstr ""
"Метод ``conn.close()`` изменяет состояние на закрытое 'closed' и отключает "
"рабочий процесс. Если транспорт уже находится в состоянии ошибки 'error', "
"``close()`` не делает ничего."

msgid "Index"
msgstr "Указатель"

msgid "Below is a list of all ``net.box`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``net.box``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Назначение"

msgid ""
":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() "
"<net_box-new>` |br| :ref:`net_box.self <net_box-self>`"
msgstr ""
":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() "
"<net_box-new>` |br| :ref:`net_box.self <net_box-self>`"

msgid "Create a connection"
msgstr "Создание подключения"

msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ":ref:`conn:ping() <conn-ping>`"

msgid "Execute a PING command"
msgstr "Выполнение команды проверки состояния PING"

msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ":ref:`conn:wait_connected() <conn-wait_connected>`"

msgid "Wait for a connection to be active or closed"
msgstr "Ожидание активности или закрытия подключения"

msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ":ref:`conn:is_connected() <conn-is_connected>`"

msgid "Check if a connection is active or closed"
msgstr "Проверка активности или закрытия подключения"

msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ":ref:`conn:wait_state() <conn-wait_state>`"

msgid "Wait for a target state"
msgstr "Ожидание нужного состояния"

msgid ":ref:`conn:close() <conn-close>`"
msgstr ":ref:`conn:close() <conn-close>`"

msgid "Close a connection"
msgstr "Закрытие подключения"

msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ":ref:`conn.space.space-name:select{field-value} <conn-select>`"

msgid "Select one or more tuples"
msgstr "Выбор одного или нескольких кортежей"

msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ":ref:`conn.space.space-name:get{field-value} <conn-get>`"

msgid "Select a tuple"
msgstr "Выбор кортежа"

msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"

msgid "Insert a tuple"
msgstr "Вставка кортежа"

msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"

msgid "Insert or replace a tuple"
msgstr "Вставка или замена кортежа"

msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ":ref:`conn.space.space-name:update{field-value} <conn-update>`"

msgid "Update a tuple"
msgstr "Обновление кортежа"

msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"

msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"

msgid "Delete a tuple"
msgstr "Удаление кортежа"

msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ":ref:`conn:eval() <net_box-eval>`"

msgid "Evaluate the expression in a string and execute it"
msgstr "Оценка и выполнение выражения в строке"

msgid ":ref:`conn:call() <net_box-call>`"
msgstr ":ref:`conn:call() <net_box-call>`"

msgid "Call a stored procedure"
msgstr "Вызов хранимой процедуры"

msgid ":ref:`conn:timeout() <conn-timeout>`"
msgstr ":ref:`conn:timeout() <conn-timeout>`"

msgid "Set a timeout"
msgstr "Установка времени ожидания"

#, fuzzy
msgid ":ref:`conn:watch() <conn-watch>`"
msgstr ":ref:`conn:wait_state() <conn-wait_state>`"

msgid "Subscribe to events broadcast by a remote host"
msgstr ""

msgid ":ref:`conn:on_connect() <net_box-on_connect>`"
msgstr ":ref:`conn:on_connect() <net_box-on_connect>`"

msgid "Define a connect trigger"
msgstr "Определение триггера на подключение"

msgid ":ref:`conn:on_disconnect() <net_box-on_disconnect>`"
msgstr ":ref:`conn:on_disconnect() <net_box-on_disconnect>`"

msgid "Define a disconnect trigger"
msgstr "Определение триггера на отключение"

#, fuzzy
msgid ":ref:`conn:on_shutdown() <net_box-on_shutdown>`"
msgstr ":ref:`conn:on_connect() <net_box-on_connect>`"

#, fuzzy
msgid "Define a shutdown trigger"
msgstr "Определение триггера на подключение"

msgid ":ref:`conn:on_schema_reload() <net_box-on_schema_reload>`"
msgstr ":ref:`conn:on_schema_reload() <net_box-on_schema_reload>`"

msgid "Define a trigger when schema is modified"
msgstr "Определение триггера при изменении схемы"

#, fuzzy
msgid ":ref:`conn:new_stream() <conn-new_stream>`"
msgstr ":ref:`conn:wait_state() <conn-wait_state>`"

msgid "Create a stream"
msgstr ""

msgid ":ref:`stream:begin() <net_box-stream_begin>`"
msgstr ""

msgid "Begin a stream transaction"
msgstr ""

#, fuzzy
msgid ":ref:`stream:commit() <net_box-stream_commit>`"
msgstr ":ref:`conn:eval() <net_box-eval>`"

msgid "Commit a stream transaction"
msgstr ""

#, fuzzy
msgid ":ref:`stream:rollback() <net_box-stream_rollback>`"
msgstr ":ref:`conn:call() <net_box-call>`"

msgid "Rollback a stream transaction"
msgstr ""

msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It can be re-established automatically after a "
"disconnect (see ``reconnect_after`` option below). The returned ``conn`` "
"object supports methods for making remote requests, such as select, update "
"or delete."
msgstr ""
"Создание нового подключения. Подключение устанавливается по требованию во "
"время первого запроса. Можно повторно установить подключение автоматически "
"после отключения (см. ниже опцию ``reconnect_after``). Возвращается объект "
"``conn``, который поддерживает методы создания удаленных запросов, таких как"
" select, update или delete."

msgid "Parameters"
msgstr "Параметры"

msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ":ref:`URI <index-uri>` объекта подключения"

msgid ""
"the supported options are shown below:  *   ``user/password``: two options "
"to connect to a remote host other than through     :ref:`URI <index-uri>`. "
"For example, instead of ``connect('username:userpassword@localhost:3301')``"
"     you can write ``connect('localhost:3301', {user = 'username', "
"password='userpassword'})``.  *   ``wait_connected``: a connection timeout. "
"By default, the connection is blocked until the connection     is "
"established, but if you specify ``wait_connected=false``, the connection "
"returns immediately.     If you specify this timeout, it will wait before "
"returning (``wait_connected=1.5`` makes it wait at most 1.5 seconds).      "
".. NOTE::           If ``reconnect_after`` is greater than zero, then "
"``wait_connected`` ignores transient failures.          The wait completes "
"once the connection is established or is closed explicitly.   *   "
"``reconnect_after``: a number of seconds to wait before reconnecting.     "
"The default value, as with the other ``connect`` options, is ``nil``. If "
"``reconnect_after``     is greater than zero, then a ``net.box`` instance "
"will attempt to reconnect if a connection     is lost or a connection "
"attempt fails. This makes transient network failures transparent to the "
"application.     Reconnection happens automatically in the background, so "
"requests that initially fail due to connection drops     fail, are "
"transparently retried. The number of retries is unlimited, connection "
"retries are made after     any specified interval (for example, "
"``reconnect_after=5`` means that reconnect attempts are made every 5 "
"seconds).     When a connection is explicitly closed or when the Lua garbage"
" collector removes it, then reconnect attempts stop.   *   ``call_16``: "
"[since 1.7.2] a new binary protocol command for CALL in ``net.box`` "
"connections by default.     The new CALL is not backward compatible with "
"previous versions. It no longer restricts a function to     returning an "
"array of tuples and allows returning an arbitrary MsgPack/JSON result,     "
"including scalars, nil and void (nothing). The old CALL is left intact for "
"backward compatibility.     It will not be present in the next major "
"release. All programming language drivers will gradually be switched     to "
"the new CALL. To connect to a Tarantool instance that uses the old CALL, "
"specify ``call_16=true``.  *   ``connect_timeout``: a number of seconds to "
"wait before returning \"error: Connection timed out\".  *   "
"``fetch_schema``: a boolean option that controls fetching schema changes "
"from the server. Default: ``true``.     If you don't operate with remote "
"spaces, for example, run only ``call`` or ``eval``, set ``fetch_schema`` to"
"     ``false`` to avoid fetching schema changes which is not needed in this "
"case.      .. important::          In connections with ``fetch_schema == "
"false``, remote spaces are unavailable         and the "
":ref:`on_schema_reload <net_box-on_schema_reload>` triggers don't work.  *"
"   ``required_protocol_version``: a minimum version of the :ref:`IPROTO "
"protocol <box_protocol-id>`     supported by the server. If the version of "
"the :ref:`IPROTO protocol <box_protocol-id>` supported     by the server is "
"lower than specified, the connection will fail with an error message.     "
"With ``required_protocol_version = 1``, all connections fail where the "
":ref:`IPROTO protocol <box_protocol-id>`     version is lower than ``1``.  *"
"   ``required_protocol_features``: specified :ref:`IPROTO protocol features "
"<box_protocol-id>` supported by the server.     You can specify one or more "
"``net.box`` features from the table below. If the server does not     "
"support the specified features, the connection will fail with an error "
"message.     With ``required_protocol_features = {'transactions'}``, all "
"connections fail where the     server has ``transactions: false``."
msgstr ""

msgid "the supported options are shown below:"
msgstr ""

#, fuzzy
msgid ""
"``user/password``: two options to connect to a remote host other than "
"through :ref:`URI <index-uri>`. For example, instead of "
"``connect('username:userpassword@localhost:3301')`` you can write "
"``connect('localhost:3301', {user = 'username', password='userpassword'})``."
msgstr ""
"`user/password`: есть два способа подключения к удаленному хосту: с "
"использованием :ref:`URI <index-uri>` или параметров `user` (пользователь) и"
" `password` (пароль). Например, вместо "
"``connect('username:userpassword@localhost:33301')`` можно ввести "
"``connect('localhost:33301', {user = 'имя-пользователя', password='пароль-"
"пользователя'})``."

#, fuzzy
msgid ""
"``wait_connected``: a connection timeout. By default, the connection is "
"blocked until the connection is established, but if you specify "
"``wait_connected=false``, the connection returns immediately. If you specify"
" this timeout, it will wait before returning (``wait_connected=1.5`` makes "
"it wait at most 1.5 seconds)."
msgstr ""
"`wait_connected`: по умолчанию, создание подключения блокируется до тех пор,"
" пока подключение не будет установлено, но передача ``wait_connected=false``"
" заставит метод сразу же вернуться. Передача времени ожидания заставит метод"
" ждать до возвращения (например, ``wait_connected=1.5`` заставит ожидать "
"подключения максимум 1,5 секунды)."

msgid ""
"If ``reconnect_after`` is greater than zero, then ``wait_connected`` ignores"
" transient failures. The wait completes once the connection is established "
"or is closed explicitly."
msgstr ""
"Если присутствует ``reconnect_after``, ``wait_connected`` проигнорирует "
"неустойчивые отказы. Ожидание заканчивается, когда подключение установлено "
"или явным образом закрыто."

#, fuzzy
msgid ""
"``reconnect_after``: a number of seconds to wait before reconnecting. The "
"default value, as with the other ``connect`` options, is ``nil``. If "
"``reconnect_after`` is greater than zero, then a ``net.box`` instance will "
"attempt to reconnect if a connection is lost or a connection attempt fails. "
"This makes transient network failures transparent to the application. "
"Reconnection happens automatically in the background, so requests that "
"initially fail due to connection drops fail, are transparently retried. The "
"number of retries is unlimited, connection retries are made after any "
"specified interval (for example, ``reconnect_after=5`` means that reconnect "
"attempts are made every 5 seconds). When a connection is explicitly closed "
"or when the Lua garbage collector removes it, then reconnect attempts stop."
msgstr ""
"`reconnect_after`: ``net.box`` автоматически подключается повторно в случае "
"разрыва соединения или провала попытки подключения. В таком случае точечные "
"сетевые проблемы не влияют на работу приложения. Повторное подключение "
"выполняется автоматически в фоновом режиме, поэтому запросы/обращения, не "
"выполненные по причине потери соединения, явным образом выполняются "
"повторно. Количество повторов не ограничено, попытки подключения выполняются"
" в течение указанного времени ожидания (например, ``reconnect_after=5`` -- 5"
" секунд). После явного закрытия подключения или удаления сборщиком мусора в "
"Lua попытки соединения повторно не выполняются. Значение по умолчанию для "
"параметра ``reconnect_after``, как и для других ``connect`` опций, равно "
"``nil``."

#, fuzzy
msgid ""
"``call_16``: [since 1.7.2] a new binary protocol command for CALL in "
"``net.box`` connections by default. The new CALL is not backward compatible "
"with previous versions. It no longer restricts a function to returning an "
"array of tuples and allows returning an arbitrary MsgPack/JSON result, "
"including scalars, nil and void (nothing). The old CALL is left intact for "
"backward compatibility. It will not be present in the next major release. "
"All programming language drivers will gradually be switched to the new CALL."
" To connect to a Tarantool instance that uses the old CALL, specify "
"``call_16=true``."
msgstr ""
"`call_16`: [с 1.7.2] по умолчанию, подключения ``net.box`` соответствуют "
"команде CALL нового бинарного протокола, который не поддерживает обратную "
"совместимость с предыдущими версиями. Команда нового бинарного протокола для"
" вызова CALL больше не ограничивает функцию в возврате массива кортежей и "
"позволяет возвращать произвольный результат в формате MsgPack/JSON, включая "
"scalar (скалярные значения), nil (нулевые значения) и void (пусто). Старый "
"метод CALL оставлен нетронутым для обратной совместимости. В следующей "
"основной версии он будет удален. Все драйверы для языков программирования "
"будут постепенно переведены на использование нового метода CALL. Для "
"подключения к экземпляру Tarantool, в котором используется старый метод "
"CALL, укажите ``call_16=true``."

#, fuzzy
msgid ""
"``connect_timeout``: a number of seconds to wait before returning \"error: "
"Connection timed out\"."
msgstr ""
"`connect_timeout`: количество секунд ожидания до возврата ошибки \"error: "
"Connection timed out\"."

msgid ""
"``fetch_schema``: a boolean option that controls fetching schema changes "
"from the server. Default: ``true``. If you don't operate with remote spaces,"
" for example, run only ``call`` or ``eval``, set ``fetch_schema`` to "
"``false`` to avoid fetching schema changes which is not needed in this case."
msgstr ""

msgid ""
"In connections with ``fetch_schema == false``, remote spaces are unavailable"
" and the :ref:`on_schema_reload <net_box-on_schema_reload>` triggers don't "
"work."
msgstr ""

msgid ""
"``required_protocol_version``: a minimum version of the :ref:`IPROTO "
"protocol <box_protocol-id>` supported by the server. If the version of the "
":ref:`IPROTO protocol <box_protocol-id>` supported by the server is lower "
"than specified, the connection will fail with an error message. With "
"``required_protocol_version = 1``, all connections fail where the "
":ref:`IPROTO protocol <box_protocol-id>` version is lower than ``1``."
msgstr ""

msgid ""
"``required_protocol_features``: specified :ref:`IPROTO protocol features "
"<box_protocol-id>` supported by the server. You can specify one or more "
"``net.box`` features from the table below. If the server does not support "
"the specified features, the connection will fail with an error message. With"
" ``required_protocol_features = {'transactions'}``, all connections fail "
"where the server has ``transactions: false``."
msgstr ""

msgid "net.box feature"
msgstr ""

msgid "IPROTO feature ID"
msgstr ""

msgid "IPROTO versions supporting the feature"
msgstr ""

msgid "``streams``"
msgstr ""

msgid "Requires streams support on the server"
msgstr ""

msgid "IPROTO_FEATURE_STREAMS"
msgstr ""

msgid "1 and newer"
msgstr ""

msgid "``transactions``"
msgstr ""

msgid "Requires transactions support on the server"
msgstr ""

msgid "IPROTO_FEATURE_TRANSACTIONS"
msgstr ""

msgid "``error_extension``"
msgstr ""

msgid ""
"Requires support for :ref:`MP_ERROR <msgpack_ext-error>` MsgPack extension "
"on the server"
msgstr ""

msgid "IPROTO_FEATURE_ERROR_EXTENSION"
msgstr ""

msgid "2 and newer"
msgstr ""

msgid "``watchers``"
msgstr ""

msgid "Requires remote :ref:`watchers <conn-watch>` support on the server"
msgstr ""

msgid "IPROTO_FEATURE_WATCHERS"
msgstr ""

msgid "3 and newer"
msgstr ""

msgid ""
"To learn more about IPROTO features, see :ref:`IPROTO_ID <box_protocol-id>` "
"and the :ref:`IPROTO_FEATURES <internals-iproto-keys-features>` key."
msgstr ""

msgid "return"
msgstr "возвращает"

msgid "conn object"
msgstr "объект подключения"

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "userdata"
msgstr "пользовательские данные"

msgid "**Examples:**"
msgstr "**Примеры:**"

#, fuzzy
msgid ""
"net_box = require('net.box')\n"
"\n"
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = true})\n"
"conn = net_box.connect('127.0.0.1:3304', {required_protocol_version = 4, required_protocol_features = {'transactions', 'streams'}, })"
msgstr ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = true})"

msgid ""
"``new()`` is a synonym for ``connect()``. It is retained for backward "
"compatibility. For more information, see the description of "
":ref:`net_box.connect() <net_box-connect>`."
msgstr ""

msgid ""
"For a local Tarantool server, there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`."
msgstr ""
"Для локального Tarantool-сервера есть заданный объект всегда установленного "
"подключения под названием :samp:`{net_box}.self`. Он создан с целью "
"облегчить полиморфное использование API модуля ``net_box``. Таким образом, "
":samp:`conn = {net_box}.connect('localhost:3301')` можно заменить на "
":samp:`conn = {net_box}.self`."

msgid ""
"However, there is an important difference between the embedded connection "
"and a remote one:"
msgstr "Однако, есть важно отличие встроенного подключения от удаленного:"

#, fuzzy
msgid ""
"With the embedded connection, requests which do not modify data do not "
"yield. When using a remote connection, due to :ref:`the implicit rules <app-"
"implicit-yields>` any request can yield, and the database state may have "
"changed by the time it regains control."
msgstr ""
"При встроенном подключении запросы без изменения данных не передают "
"управление. При использовании удаленного подключения любой запрос может "
"передавать управление исходя из :ref:`правил неявной передачи управления "
"<atomic-implicit-yields>`, и состояние базы данных может измениться к тому "
"времени, как управление вернется."

msgid ""
"All the options passed to a request (as ``is_async``, ``on_push``, "
"``timeout``) will be ignored."
msgstr ""
"Не учитывается ни один параметр, передаваемый в запросе (``is_async``, "
"``on_push``, ``timeout``)."

msgid "Execute a PING command."
msgstr "Выполнение команды проверки состояния PING."

msgid "the supported option is :samp:`timeout={seconds}`"
msgstr "поддерживается опция :samp:`timeout={секунды}`"

msgid "true on success, false on error"
msgstr "true (правда), если выполнено, false (ложь) в случае ошибки"

msgid "boolean"
msgstr "boolean (логический)"

msgid "**Example:**"
msgstr "**Пример:**"

msgid "net_box.self:ping({timeout = 0.5})"
msgstr "net_box.self:ping({timeout = 0.5})"

msgid "Wait for connection to be active or closed."
msgstr "Ожидание активности или закрытия подключения."

msgid "in seconds"
msgstr "в секундах"

msgid "true when connected, false on failure."
msgstr "true (правда) при подключении, false (ложь), если не выполнено."

msgid "net_box.self:wait_connected()"
msgstr "net_box.self:wait_connected()"

msgid "Show whether connection is active or closed."
msgstr "Проверка активности или закрытия подключения."

msgid "true if connected, false on failure."
msgstr "true (правда) при подключении, false (ложь), если не выполнено."

msgid "net_box.self:is_connected()"
msgstr "net_box.self:is_connected()"

msgid "[since 1.7.2] Wait for a target state."
msgstr "[с 1.7.2] Ожидание нужного состояния."

msgid "target states"
msgstr "необходимое состояние"

msgid ""
"true when a target state is reached, false on timeout or connection closure"
msgstr ""
"true (правда) при подключении, false (ложь) при окончании времени ожидания "
"или закрытии подключения"

msgid ""
"-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""
"-- бесконечное ожидание состояния 'active':\n"
"conn:wait_state('active')\n"
"\n"
"-- ожидание в течение максимум 1,5 секунд:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- бесконечное ожидание состояния `active` или `fetch_schema`:\n"
"conn:wait_state({active=true, fetch_schema=true})"

msgid "Close a connection."
msgstr "Закрытие подключения."

msgid ""
"Connection objects are destroyed by the Lua garbage collector, just like any"
" other objects in Lua, so an explicit destruction is not mandatory. However,"
" since close() is a system call, it is good programming practice to close a "
"connection explicitly when it is no longer needed, to avoid lengthy stalls "
"of the garbage collector."
msgstr ""
"Объекты подключения удаляются сборщиком мусора в Lua, как и любой другой "
"Lua-объект, поэтому удалять их явным образом необязательно. Однако, "
"поскольку close() представляет собой системный вызов, лучше всего закрыть "
"соединение явным образом, когда оно больше не используется, с целью "
"ускорения работы сборщика мусора."

msgid "conn:close()"
msgstr "conn:close()"

msgid ""
":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-"
"name}:select`:code:`{...}` (:ref:`see details <box_space-select>`). For an "
"additional option see :ref:`Module buffer and skip-header <buffer-"
"module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:select`:code:`({...})` -- это удаленный "
"вызов, аналогичный локальному вызову :samp:`box.space.{имя-"
"спейса}:select`:code:`{...}` (:ref:`детали <box_space-select>`). В "
"дополнение см. :ref:`Модуль buffer и skip-header <buffer-"
"module_and_skip_header>`."

msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr "conn.space.testspace:select({1,'B'}, {timeout=1})"

#, fuzzy
msgid ""
"Due to :ref:`the implicit yield rules <app-implicit-yields>` a local "
":samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does yield, "
"so global variables or database tuples data may change when a remote "
":samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""
"Исходя из :ref:`правил неявной передачи управления <atomic-implicit-"
"yields>`, локальный запрос :samp:`box.space.{имя-"
"спейса}:select`:code:`{...}` не передает управление, а удаленный "
":samp:`conn.space.{имя-спейса}:select`:code:`{...}` передаст, поэтому "
"глобальные переменные или кортежи в базе данных могут измениться во время "
"удаленного :samp:`conn.space.{имя-спейса}:select`:code:`{...}`."

msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:get(...)` (:ref:`see details "
"<box_space-get>`)."
msgstr ""
":samp:`conn.space.{имя-спейса}:get(...)` -- это удаленный вызов, аналогичный"
" локальному вызову :samp:`box.space.{имя-спейса}:get(...)` (:ref:`детали "
"<box_space-get>`)."

msgid "conn.space.testspace:get({1})"
msgstr "conn.space.testspace:get({1})"

msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:insert(...)` (:ref:`see "
"details <box_space-insert>`). For an additional option see :ref:`Module "
"buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:insert(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:insert(...)` "
"(:ref:`детали <box_space-insert>`). В дополнение см. :ref:`Модуль buffer и "
"skip-header <buffer-module_and_skip_header>`."

msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"

msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent "
"of the local call :samp:`box.space.{space-name}:replace(...)` (:ref:`see "
"details <box_space-replace>`). For an additional option see :ref:`Module "
"buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:replace(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:replace(...)` "
"(:ref:`детали <box_space-replace>`). В дополнение см. :ref:`Модуль buffer и "
"skip-header <buffer-module_and_skip_header>`."

msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr "conn.space.testspace:replace({5,6,7,8})"

msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:update(...)` (:ref:`see "
"details <box_space-update>`). For an additional option see :ref:`Module "
"buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:update(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:update(...)`."

msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"

#, fuzzy
msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:upsert(...)`. (:ref:`see "
"details <box_space-upsert>`). For an additional option see :ref:`Module "
"buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:upsert(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:upsert(...)` "
"(:ref:`детали <box_space-upsert>`). В дополнение см. :ref:`Модуль buffer и "
"skip-header <buffer-module_and_skip_header>`."

msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:delete(...)` (:ref:`see "
"details <box_space-delete>`). For an additional option see :ref:`Module "
"buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""
":samp:`conn.space.{имя-спейса}:delete(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-"
"спейса}:delete(...)`.(:ref:`детали <box_space-delete>`). В дополнение см. "
":ref:`Модуль buffer и skip-header <buffer-module_and_skip_header>`."

msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in "
"Lua-string, which may be any statement or series of statements. An "
":ref:`execute privilege <authentication-owners_privileges>` is required; if "
"the user does not have it, an administrator may grant it with "
":samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""
":samp:`conn:eval({Lua-строка})` оценивает и выполняет выражение в Lua-"
"строке, которое может представлять собой любое выражение или несколько "
"выражений. Требуются :ref:`права на выполнение <authentication-"
"owners_privileges>`; если у пользователя таких прав нет, администратор может"
" их выдать с помощью :samp:`box.schema.user.grant({имя-пользователя}, "
"'execute', 'universe')`."

msgid ""
"To ensure that the return from ``conn:eval`` is whatever the Lua expression "
"returns, begin the Lua-string with the word \"return\"."
msgstr ""
"Чтобы гарантировать, что ``conn:eval`` вернет то, что возвращает выражение "
"на Lua, начните Lua-строку со слова \"return\" (вернуть)."

msgid ""
"tarantool> --Lua-string\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-string, {arguments}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-string, {arguments}, {options}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."
msgstr ""
"tarantool> --Lua-строка\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-строка, {аргументы}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-строка, {аргументы}, {парметры}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."

msgid ""
"``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of "
"``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-procedure"
" call. The return from ``conn:call`` is whatever the function returns."
msgstr ""
"``conn:call('func', {'1', '2', '3'})`` -- это удаленный вызов, аналогичный "
"``func('1', '2', '3')``. Таким образом, ``conn:call`` представляет собой "
"удаленный вызов хранимой процедуры. ``conn:call`` возвращает то, что "
"возвращает функция."

msgid ""
"Limitation: the called function cannot return a function, for example if "
"``func2`` is defined as ``function func2 () return func end`` then "
"``conn:call(func2)`` will return \"error: unsupported Lua type 'function'\"."
msgstr ""
"Ограничение: вызванная функция не может вернуть функцию, например, если "
"``func2`` определяется как ``function func2 () return func end``, то "
"``conn:call(func2)`` вернет ошибку \"error: unsupported Lua type "
"'function'\"."

msgid ""
"tarantool> -- create 2 functions with conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- call first function with no parameters and no options\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- call second function with two parameters and one option\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."
msgstr ""
"tarantool> -- создание 2 функций с conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- вызов первой функции без параметров и опций\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- вызов второй функции с двумя параметрами и одной опцией\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."

msgid "Subscribe to events broadcast by a remote host."
msgstr ""

msgid "a key name of an event to subscribe to"
msgstr ""

msgid "a callback to invoke when the key value is updated"
msgstr ""

msgid ""
"a watcher handle. The handle consists of one method -- ``unregister()``, "
"which unregisters the watcher."
msgstr ""

msgid ""
"To read more about watchers, see the :ref:`Functions for watchers <box-"
"watchers>` section."
msgstr ""

msgid ""
"The method has the same syntax as the :doc:`box.watch() "
"</reference/reference_lua/box_events/broadcast>` function, which is used for"
" subscribing to events locally."
msgstr ""

msgid ""
"Watchers survive reconnection (see the ``reconnect_after`` connection "
":ref:`option <net_box-connect>`). All registered watchers are automatically "
"resubscribed when the connection is reestablished."
msgstr ""

msgid ""
"If a remote host supports watchers, the ``watchers`` key will be set in the "
"connection ``peer_protocol_features``. For details, check the :ref:`net.box "
"features table <net_box-connect>`."
msgstr ""

msgid ""
"Keep in mind that garbage collection of a watcher handle doesn't lead to the"
" watcher's destruction. In this case, the watcher remains registered. It is "
"okay to discard the result of ``watch`` function if the watcher will never "
"be unregistered."
msgstr ""

msgid "Server:"
msgstr ""

msgid ""
"-- Broadcast value 42 for the 'foo' key.\n"
"box.broadcast('foo', 42)"
msgstr ""

msgid "Client:"
msgstr ""

#, python-format
msgid ""
"conn = net.box.connect(URI)\n"
"local log = require('log')\n"
"-- Subscribe to updates of the 'foo' key.\n"
"w = conn:watch('foo', function(key, value)\n"
"    assert(key == 'foo')\n"
"    log.info(\"The box.id value is '%d'\", value)\n"
"end)"
msgstr ""

msgid ""
"If you don't need the watcher anymore, you can unregister it using the "
"command below:"
msgstr ""

msgid "w:unregister()"
msgstr ""

msgid ""
"``{is_async=true|false}`` is an option which is applicable for all "
"``net_box`` requests including ``conn:call``, ``conn:eval``, and the "
"``conn.space.space-name`` requests."
msgstr ""
"``{is_async=true|false}`` -- это опция, которую можно применить во всех "
"запросах ``net_box``, включая ``conn:call``, ``conn:eval`` и запросы "
"``conn.space.space-name``."

msgid ""
"The default is ``is_async=false``, meaning requests are synchronous for the "
"fiber. The fiber is blocked, waiting until there is a reply to the request "
"or until timeout expires. Before Tarantool version 1.10, the only way to "
"make asynchronous requests was to put them in separate fibers."
msgstr ""
"По умолчанию, ``is_async=false``, что означает, что запросы будут "
"синхронными для файбера. Файбер блокируется в ожидании ответа на запрос или "
"до истечения времени ожидания. До версии Tarantool 1.10 единственным "
"способом выполнения асинхронных запросов было использование отдельных "
"файберов."

msgid ""
"The non-default is ``is_async=true``, meaning requests are asynchronous for "
"the fiber. The request causes a yield but there is no waiting. The immediate"
" return is not the result of the request, instead it is an object that the "
"calling program can use later to get the result of the request."
msgstr ""
"``is_async=true`` означает, что запросы будут асинхронными для файбера. "
"Запрос вызывает передачу управления, но файбер не входит в режим ожидания. "
"Сразу же возвращается результат, но это будет не результат запроса, а "
"объект, который может использовать вызывающая программа для получения "
"результат запроса."

msgid ""
"This immediately-returned object, which we'll call \"future\", has its own "
"methods:"
msgstr ""
"У такого сразу же возвращаемого объекта, который мы называем \"future\" "
"(будущий), есть собственные методы:"

msgid ""
"``future:is_ready()`` which will return true when the result of the request "
"is available,"
msgstr ""
"``future:is_ready()`` вернет true (правда), если доступен результат запроса,"

msgid ""
"``future:result()`` to get the result of the request (returns the response "
"or **nil** in case it's not ready yet or there has been an error),"
msgstr ""
"``future:result()`` используется для получения результата запроса "
"(возвращает ответ на запрос или **nil** в случае, если ответ еще не готов "
"или произошла какая-либо ошибка),"

msgid ""
"``future:wait_result(timeout)`` to wait until the result of the request is "
"available and then get it, or throw an error if there is no result after the"
" timeout exceeded,"
msgstr ""
"``future:wait_result(timeout)`` будет ждать, когда результат запроса будет "
"доступен, а затем получит его или выдаст ошибку, если по истечении времени "
"ожидания результат не получен."

msgid "``future:discard()`` to abandon the object."
msgstr "``future:discard()`` откажется от объекта."

msgid ""
"Typically a user would say ``future=request-name(...{is_async=true})``, then"
" either loop checking ``future:is_ready()`` until it is true and then say "
"``request_result=future:result()``, or say "
"``request_result=future:wait_result(...)``. Alternatively the client could "
"check for \"out-of-band\" messages from the server by calling ``pairs()`` in"
" a loop -- see :doc:`/reference/reference_lua/box_session/push`."
msgstr ""
"В обычной ситуации пользователь введет команду ``future=имя-"
"запроса(...{is_async=true})``, а затем либо цикл с проверкой "
"``future:is_ready()`` до тех пор, пока он не вернет true, и получением "
"результата с помощью  ``request_result=future:result()``, либо же команду "
"``request_result=future:wait_result(...)``. Возможен вариант, когда клиент "
"проверяет наличие внеполосных сообщений от сервера, вызывая в цикле "
"``pairs()`` -- см. :doc:`/reference/reference_lua/box_session/push`."

msgid ""
"A user would say ``future:discard()`` to make a connection forget about the "
"response -- if a response for a discarded object is received then it will be"
" ignored, so that the size of the requests table will be reduced and other "
"requests will be faster."
msgstr ""
"Можно использовать ``future:discard()``, чтобы соединение забыло об ответе "
"-- если получен ответ для отброшенного объекта, то он будет проигнорирован, "
"так что размер таблицы запросов будет уменьшен, а другие запросы будут "
"выполняться быстрее."

msgid ""
"-- Insert a tuple asynchronously --\n"
"tarantool> future = conn.space.bands:insert({10, 'Queen', 1970}, {is_async=true})\n"
"---\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [10, 'Queen', 1970]\n"
"...\n"
"\n"
"-- Iterate through a space with 10 records to get data in chunks of 3 records --\n"
"tarantool> while true do\n"
"               future = conn.space.bands:select({}, {limit=3, after=position, fetch_pos=true, is_async=true})\n"
"               result = future:wait_result()\n"
"               tuples = result[1]\n"
"               position = result[2]\n"
"               if position == nil then\n"
"                   break\n"
"               end\n"
"               print('Chunk size: '..#tuples)\n"
"           end\n"
"Chunk size: 3\n"
"Chunk size: 3\n"
"Chunk size: 3\n"
"Chunk size: 1\n"
"---\n"
"..."
msgstr ""

msgid ""
"Typically ``{is_async=true}`` is used only if the load is large (more than "
"100,000 requests per second) and latency is large (more than 1 second), or "
"when it is necessary to send multiple requests in parallel then collect "
"responses (sometimes called a \"map-reduce\" scenario)."
msgstr ""
"Как правило, ``{is_async=true}`` используется только при большой загрузке "
"(более 100 000 запросов в секунду) и большой задержке чтения (более 1 "
"секунды), или же при необходимости отправки нескольких одновременных "
"запросов, которые собирают ответы (что иногда называется \"отображение-"
"свертка\")."

msgid ""
"Although the final result of an async request is the same as the result of a"
" sync request, it is structured differently: as a table, instead of as the "
"unpacked values."
msgstr ""
"Хотя окончательный результат асинхронного запроса не отличается от "
"результата синхронного запроса, у него другая структура: таблица, а не "
"неупакованные значения."

msgid "``{return_raw=true}`` is ignored for:"
msgstr ""

msgid ""
"Methods that return ``nil``: ``begin``, ``commit``, ``rollback``, "
"``upsert``, ``prepare``."
msgstr ""

msgid "``index.count`` (returns number)."
msgstr ""

msgid ""
"For ``execute``, the option is applied only to data (`rows`). Metadata is "
"decoded even if ``{return_raw=true}``."
msgstr ""

msgid ""
"local c = require('net.box').connect(uri)\n"
"local mp = c.eval('eval ...', {1, 2, 3}, {return_raw = true})\n"
"mp:decode() -- {1, 2, 3}"
msgstr ""

msgid ""
"The option can be useful if you want to pass a response through without "
"decoding or with partial decoding. The usage of :ref:`MsgPack object "
"<msgpack-object-info>` can reduce pressure on the Lua garbage collector."
msgstr ""

msgid "Create a stream."
msgstr ""

msgid ""
"-- Start a server to create a new stream\n"
"local conn = net_box.connect('localhost:3301')\n"
"local conn_space = conn.space.test\n"
"local stream = conn:new_stream()\n"
"local stream_space = stream.space.test"
msgstr ""

msgid ""
"Begin a stream transaction. Instead of the direct method, you can also use "
"the ``call``, ``eval`` or execute methods with SQL transaction."
msgstr ""

msgid ":ref:`transaction isolation level <txn_mode_mvcc-options>`"
msgstr ""

msgid ""
"Commit a stream transaction. Instead of the direct method, you can also use "
"the ``call``, ``eval`` or execute methods with SQL transaction."
msgstr ""

msgid ""
"-- Begin stream transaction\n"
"stream:begin()\n"
"-- In the previously created ``accounts`` space with the primary key ``test``, modify the fields 2 and 3\n"
"stream.space.accounts:update(test_1, {{'-', 2, 370}, {'+', 3, 100}})\n"
"-- Commit stream transaction\n"
"stream:commit()"
msgstr ""

msgid ""
"Rollback a stream transaction. Instead of the direct method, you can also "
"use the ``call``, ``eval`` or execute methods with SQL transaction."
msgstr ""

msgid ""
"-- Test rollback for memtx space\n"
"space:replace({1})\n"
"-- Select return tuple that was previously inserted, because this select belongs to stream transaction\n"
"space:select({})\n"
"stream:rollback()\n"
"-- Select is empty, stream transaction rollback\n"
"space:select({})"
msgstr ""

msgid "Triggers"
msgstr "Триггеры"

msgid ""
"With the ``net.box`` module, you can use the following :ref:`triggers "
"<triggers-box_triggers>`:"
msgstr ""
"В модуле ``net.box`` можно использовать следующие :ref:`триггеры <triggers-"
"box_triggers>`:"

msgid ""
"Define a trigger for execution when a new connection is established, and "
"authentication and schema fetch are completed due to an event such as "
"``net_box.connect``."
msgstr ""

msgid ""
"If a trigger function issues ``net_box`` requests, they must be "
":ref:`asynchronous <net_box-is_async>` (``{is_async = true}``). An attempt "
"to wait for request completion with ``future:pairs()`` or "
"``future:wait_result()`` in the trigger function will result in an error."
msgstr ""

#, fuzzy
msgid ""
"If the trigger execution fails and an exception happens, the connection's "
"state changes to 'error'. In this case, the connection is terminated, "
"regardless of the ``reconnect_after`` option's value. Can be called as many "
"times as reconnection happens, if ``reconnect_after`` is greater than zero."
msgstr ""
"Определение триггера, исполняемого, когда устанавливается новое соединение "
"(и при условии, что аутентификация и сборка схемы завершены) при таком "
"событии, как ``net_box.connect``. Если триггер не срабатывает и выкидывает "
"исключение, статус подключения меняется на 'error'.В таком случае соединение"
" прерывается, независимо от значения опции ``reconnect_after``. Может "
"вызываться столько раз, сколько раз происходит переподключение, если "
"значение параметра ``reconnect_after`` больше нуля."

#, fuzzy
msgid "the trigger function. Takes the ``conn`` object as the first argument."
msgstr ""
"функция, в которой будет триггер. В качестве первого аргумента берет объект "
"``conn``"

#, fuzzy
msgid "an existing trigger function to replace with ``trigger-function``"
msgstr "существующая функция с триггером, которую заменит новая"

msgid "nil or function pointer"
msgstr "nil или указатель функции"

msgid ""
"Define a trigger for execution after a connection is closed. If the trigger "
"function causes an error, the error is logged but otherwise is ignored. "
"Execution stops after a connection is explicitly closed, or once the Lua "
"garbage collector removes it."
msgstr ""
"Определение триггера, исполняемого после закрытия соединения. Если функция с"
" триггером вызывает ошибку, то ошибка записывается в журнал, в противном "
"случае записей не будет. Выполнение прекращается после явного закрытия "
"соединения или удаления сборщиком мусора в Lua."

#, fuzzy
msgid "the trigger function. Takes the ``conn`` object as the first argument"
msgstr ""
"функция, в которой будет триггер. В качестве первого аргумента берет объект "
"``conn``"

msgid ""
"Define a trigger for shutdown when a :ref:`box.shutdown <system-events_box-"
"shutdown>` event is received."
msgstr ""

msgid ""
"The trigger starts in a new fiber. While the ``on_shutdown()`` trigger is "
"running, the connection stays active. It means that the trigger callback is "
"allowed to send new requests."
msgstr ""

msgid ""
"After the trigger return, the ``net.box`` connection goes to the "
"``graceful_shutdown`` state (check :ref:`the state diagram <net_box-"
"state_diagram>` for details). In this state, no new requests are allowed. "
"The connection waits for all pending requests to be completed."
msgstr ""

msgid ""
"Once all in-progress requests have been processed, the connection is closed."
" The state changes to ``error`` or ``error_reconnect`` (if the "
"``reconnect_after`` option is defined)."
msgstr ""

msgid ""
"Servers that do not support the ``box.shutdown`` event or :ref:`IPROTO_WATCH"
" <box_protocol-watch>` just close the connection abruptly. In this case, the"
" ``on_shutdown()`` trigger is not executed."
msgstr ""

msgid ""
"Define a trigger executed when some operation has been performed on the "
"remote server after schema has been updated. So, if a server request fails "
"due to a schema version mismatch error, schema reload is triggered."
msgstr ""
"Определение триггера, исполняемого во время выполнения определенной операции"
" на удаленном сервере после обновления схемы. Другими словами, если запрос к"
" серверу не выполняется из-за ошибки несовпадения версии схемы, происходит "
"перезагрузка схемы."

msgid ""
"If the parameters are ``(nil, old-trigger-function)``, then the old trigger "
"is deleted."
msgstr ""
"Если указаны параметры ``(nil, old-trigger-function)``, старый триггер будет"
" удален."

msgid ""
"If both parameters are omitted, then the response is a list of existing "
"trigger functions."
msgstr ""
"Если не указан ни один параметр, ответом будет список существующих функций с"
" триггером."

#, fuzzy
msgid ""
"Find the detailed information about triggers in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""
"Подробная информация о характеристиках триггера находится в разделе "
":ref:`Триггеры <triggers-box_triggers>`."

#~ msgid ""
#~ "The names ``connect()`` and ``new()`` are synonyms: ``connect()`` is "
#~ "preferred; ``new()`` is retained for backward compatibility."
#~ msgstr ""
#~ "Имена ``connect()`` и ``new()`` являются синонимами: предпочтительным будет "
#~ "``connect()``, а ``new()`` обеспечивает поддержку обратной совместимости."

#~ msgid "Possible options:"
#~ msgstr "Возможные опции:"

#~ msgid ""
#~ "`console`: depending on the option's value, the connection supports "
#~ "different methods (as if instances of different classes were returned). With"
#~ " ``console = true``, you can use ``conn`` methods ``close()``, "
#~ "``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both binary "
#~ "and Lua console network protocols are supported). With ``console = false`` "
#~ "(default), you can also use ``conn`` database methods (in this case, only "
#~ "the binary protocol is supported). Deprecation notice: ``console = true`` is"
#~ " deprecated, users should use :ref:`console.connect() <console-connect>` "
#~ "instead."
#~ msgstr ""
#~ "`console`: в зависимости от значения параметра поддерживаются различные "
#~ "методы (как если бы возвращались экземпляры разных классов). Если ``console "
#~ "= true``, можно использовать методы ``conn``: ``close()``, "
#~ "``is_connected()``, ``wait_state()``, ``eval()`` (в этом случае "
#~ "поддерживаются и бинарный сетевой протокол, и протокол Lua-консоли). Если "
#~ "``console = false`` (по умолчанию), также можно использовать методы ``conn``"
#~ " для работы с базой данных (в этом случае поддерживается только бинарный "
#~ "протокол). Устарел: ``console = true`` объявлен устаревшим, вместо него "
#~ "следует использовать :ref:`console.connect() <console-connect>`."

#~ msgid ""
#~ "possible options are `user`, `password`, `wait_connected`, "
#~ "`reconnect_after`, `call_16`, `console` and `connect_timeout`"
#~ msgstr ""
#~ "возможные опции: `user`, `password`, `wait_connected`, `reconnect_after`, "
#~ "`call_16`, `console` и `connect_timeout`"

#~ msgid ""
#~ "``timeout(...)`` is a wrapper which sets a timeout for the request that "
#~ "follows it. Since version 1.7.4 this method is deprecated -- it is better to"
#~ " pass a timeout value for a method's ``{options}`` parameter."
#~ msgstr ""
#~ "``timeout(...)`` -- это надстройка, которая определяет время ожидания для "
#~ "запроса. С версии 1.7.4 этот метод объявлен устаревшим -- лучше передать "
#~ "значение времени ожидания с помощью параметра ``{options}``."

#~ msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
#~ msgstr "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"

#~ msgid ""
#~ "Although ``timeout(...)`` is deprecated, all remote calls support its use. "
#~ "Using a wrapper object makes the remote connection API compatible with the "
#~ "local one, removing the need for a separate ``timeout`` argument, which the "
#~ "local version would ignore. Once a request is sent, it cannot be revoked "
#~ "from the remote server even if a timeout expires: the timeout expiration "
#~ "only aborts the wait for the remote server response, not the request itself."
#~ msgstr ""
#~ "Хотя ``timeout(...)`` объявлен устаревшим, все удаленные вызовы поддерживают"
#~ " его. Использование надстройки обеспечивает совместимость API удаленного "
#~ "соединения с локальным, поэтому отпадает необходимость в отдельном аргументе"
#~ " ``timeout``, который проигнорирует локальная версия. После отправки запроса"
#~ " его нельзя отменить с удаленного сервера даже по истечении времени "
#~ "задержки: окончание времени задержки прерывает только ожидание ответа от "
#~ "удаленного сервера, а не сам запрос."

#~ msgid ""
#~ "tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> future\n"
#~ "---\n"
#~ "- method: insert\n"
#~ "  response: [900]\n"
#~ "  cond: cond\n"
#~ "  on_push_ctx: []\n"
#~ "  on_push: 'function: builtin#91'\n"
#~ "...\n"
#~ "tarantool> future:is_ready()\n"
#~ "---\n"
#~ "- true\n"
#~ "...\n"
#~ "tarantool> future:result()\n"
#~ "---\n"
#~ "- [900]\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> future\n"
#~ "---\n"
#~ "- method: insert\n"
#~ "  response: [900]\n"
#~ "  cond: cond\n"
#~ "  on_push_ctx: []\n"
#~ "  on_push: 'function: builtin#91'\n"
#~ "...\n"
#~ "tarantool> future:is_ready()\n"
#~ "---\n"
#~ "- true\n"
#~ "...\n"
#~ "tarantool> future:result()\n"
#~ "---\n"
#~ "- [900]\n"
#~ "..."
