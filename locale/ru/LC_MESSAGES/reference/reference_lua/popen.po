
msgid "Module `popen`"
msgstr "Модуль `popen`"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"Since version :doc:`2.4.1 </release/2.4.1>`, Tarantool has the ``popen`` "
"built-in module that supports execution of external programs. It is similar "
"to Python's `subprocess() "
"<https://docs.python.org/3.8/library/subprocess.html>`_ or Ruby's `Open3 "
"<https://docs.ruby-lang.org/en/2.0.0/Open3.html>`_. However, Tarantool's "
"``popen`` module does not have all the helpers that those languages provide,"
" it provides only basic functions. ``popen`` uses the `vfork() "
"<https://pubs.opengroup.org/onlinepubs/009695399/functions/vfork.html>`_ "
"system call to create an object, so the caller thread is blocked until "
"execution of a child process begins."
msgstr ""
"Начиная с версии :doc:`2.4.1 </release/2.4.1>` в Tarantool есть встроенный "
"модуль ``popen``, предназначенный для выполнения внешних программ. Он "
"работает аналогично модулю `subprocess() "
"<https://docs.python.org/3.8/library/subprocess.html>`_ в Python или `Open3 "
"<https://docs.ruby-lang.org/en/2.0.0/Open3.html>`_ в Ruby. Однако в "
"``popen`` нет вспомогательных средств, которые предоставляют эти языки; он "
"предоставляет только базовые функции. Для создания объекта ``popen`` "
"использует системный вызов `vfork() "
"<https://pubs.opengroup.org/onlinepubs/009695399/functions/vfork.html>`_, "
"поэтому вызывающий поток блокируется до тех пор, пока не начинается "
"выполнение дочернего процесса."

msgid ""
"The ``popen`` module provides two functions to create the popen object:"
msgstr "В модуле ``popen`` есть две функции для создания объекта popen:"

msgid ""
":ref:`popen.shell <popen-shell>` which is similar to the libc `popen "
"<https://www.gnu.org/software/libc/manual/html_node/Pipe-to-a-"
"Subprocess.html>`_ syscall"
msgstr ""
":ref:`popen.shell <popen-shell>`, аналогичная системному вызову `popen "
"<https://www.gnu.org/software/libc/manual/html_node/Pipe-to-a-"
"Subprocess.html>`_ из libc;"

msgid ""
":ref:`popen.new <popen-new>` to create a popen object with more specific "
"options"
msgstr ""
":ref:`popen.new <popen-new>` для создания объекта popen с более "
"специфическими параметрами."

msgid ""
"Either function returns a handle which we will call ``popen_handle`` or "
"``ph``. With the handle one can execute methods."
msgstr ""
"Обе функции возвращают дескриптор, который мы будем называть "
"``popen_handle`` или ``ph``. Через дескриптор вы можете выполнять методы."

msgid "Index"
msgstr "Указатель"

msgid "Below is a list of all ``popen`` functions and handle methods."
msgstr ""
"Ниже приведен перечень всех функций ``popen`` и методов дескриптора ``ph``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Назначение"

msgid ":ref:`popen.shell() <popen-shell>`"
msgstr ":ref:`popen.shell() <popen-shell>`"

msgid "Execute a shell command"
msgstr "Выполнение shell-команды"

msgid ":ref:`popen.new() <popen-new>`"
msgstr ":ref:`popen.new() <popen-new>`"

msgid "Execute a child program in a new process"
msgstr "Выполнение дочерней программы в новом процессе"

msgid ":ref:`popen_handle:read() <popen-read>`"
msgstr ":ref:`popen_handle:read() <popen-read>`"

msgid "Read data from a child peer"
msgstr "Считывание данных из дочернего процесса"

msgid ":ref:`popen_handle:write() <popen-write>`"
msgstr ":ref:`popen_handle:write() <popen-write>`"

msgid "Write a string to stdin stream of a child process"
msgstr "Запись строки в поток stdin дочернего процесса"

msgid ":ref:`popen_handle:shutdown() <popen-shutdown>`"
msgstr ":ref:`popen_handle:shutdown() <popen-shutdown>`"

msgid "Close parent's ends of std* fds"
msgstr "Закрытие канала с std* со стороны родителя"

msgid ":ref:`popen_handle:terminate() <popen-terminate>`"
msgstr ":ref:`popen_handle:terminate() <popen-terminate>`"

msgid "Send SIGTERM signal to a child process"
msgstr "Отправка сигнала SIGTERM дочернему процессу"

msgid ":ref:`popen_handle:kill() <popen-kill>`"
msgstr ":ref:`popen_handle:kill() <popen-kill>`"

msgid "Send SIGKILL signal to a child process"
msgstr "Отправка сигнала SIGKILL дочернему процессу"

msgid ":ref:`popen_handle:signal() <popen-signal>`"
msgstr ":ref:`popen_handle:signal() <popen-signal>`"

msgid "Send signal to a child process"
msgstr "Отправка сигнала дочернему процессу"

msgid ":ref:`popen_handle:info() <popen-info>`"
msgstr ":ref:`popen_handle:info() <popen-info>`"

msgid "Return information about the popen handle"
msgstr "Получение информации о дескрипторе popen"

msgid ":ref:`popen_handle:wait() <popen-wait>`"
msgstr ":ref:`popen_handle:wait() <popen-wait>`"

msgid "Wait until a child process gets exited or signaled"
msgstr "Ожидание, пока дочерний процесс не завершится или не получит сигнал"

msgid ":ref:`popen_handle:close() <popen-close>`"
msgstr ":ref:`popen_handle:close() <popen-close>`"

msgid "Close a popen handle"
msgstr "Закрытие дескриптора popen"

msgid ":ref:`Module constants <popen-constants>`"
msgstr ":ref:`Константы модуля <popen-constants>`"

msgid "Module constants"
msgstr "Константы модуля"

msgid ":ref:`Handle fields <popen-handle_fields>`"
msgstr ":ref:`Поля дескриптора <popen-handle_fields>`"

msgid "Handle fields"
msgstr "Поля дескриптора"

msgid "Execute a shell command."
msgstr "Выполнение shell-команды."

msgid "Parameters"
msgstr "Параметры"

msgid "a command to run, mandatory"
msgstr "имя выполняемой команды, обязательно"

msgid "communication mode, optional"
msgstr "режим передачи данных, необязательно"

msgid "return"
msgstr "возвращает"

msgid ""
"(if success) a popen handle, which we will call ``popen_handle`` or ``ph``"
msgstr ""
"(при успешном выполнении) дескриптор объекта popen, который мы будем "
"называть ``popen_handle`` или ``ph``"

msgid "(if failure) ``nil, err``"
msgstr "(при неудачном выполнении) ``nil, err``"

msgid ""
"Possible errors: if a parameter is incorrect, the result is IllegalParams: "
"incorrect type or value of a parameter. For other possible errors, see "
":ref:`popen.new() <popen-new>`."
msgstr ""
"Возможные ошибки: если один из параметров задан некорректно, функция "
"возвращает IllegalParams: неправильно задан тип или значение параметра. "
"Другие возможные ошибки смотрите в разделе :ref:`popen.new() <popen-new>`."

msgid "The possible ``mode`` values are:"
msgstr "Возможные значения режима передачи данных ``mode``:"

msgid "``'w'``    which enables :ref:`popen_handle:write() <popen-write>`"
msgstr "``'w'`` --- разрешает :ref:`popen_handle:write() <popen-write>`"

msgid "``'r'``    which enables :ref:`popen_handle:read() <popen-read>`"
msgstr "``'r'`` --- разрешает :ref:`popen_handle:read() <popen-read>`"

msgid ""
"``'R'``    which enables :ref:`popen_handle:read({stderr = true}) <popen-"
"read>`"
msgstr ""
"``'R'`` --- разрешает :ref:`popen_handle:read({stderr = true}) <popen-read>`"

msgid "``'nil'``    which means inherit parent's std* file descriptors"
msgstr ""
"``'nil'`` --- означает наследование родительских std*-дескрипторов файла"

msgid ""
"Several mode characters can be set together, for example ``'rw'``, "
"``'rRw'``."
msgstr ""
"Разные значения режима передачи данных можно использовать вместе, например "
"``'rw'``, ``'rRw'``."

msgid ""
"The ``shell`` function is just a shortcut for :ref:`popen.new({command}, "
"opts) <popen-new>` with ``opts.shell.setsid`` and "
"``opts.shell.group_signal`` both set to `true`, and with ``opts.stdin`` and "
"``opts.stdout`` and ``opts.stderr`` all set based on the ``mode`` parameter."
msgstr ""
"Функция ``shell`` --- это сокращение для :ref:`popen.new({command}, opts) "
"<popen-new>` с ``opts.shell.setsid`` и ``opts.shell.group_signal``, "
"установленными в `true`, и значениями ``opts.stdin``, ``opts.stdout`` и "
"``opts.stderr``, установленными на основе параметра ``mode``."

msgid ""
"All std* streams are inherited from the parent by default unless it is "
"changed using mode: ``'r'`` for stdout, ``'R'`` for stderr, or ``'w'`` for "
"stdin."
msgstr ""
"Все потоки std* по умолчанию наследуются от родительских, если не задано "
"значение режима передачи данных (mode): ``'r'`` для stdout, ``'R'`` для "
"stderr или ``'w'`` для stdin."

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"This is the equivalent of the ``sh -c date`` command. It starts a process, "
"runs ``'date'``, reads the output, and closes the popen object (``ph``)."
msgstr ""
"В этом примере выполняется аналог команды ``sh -c date``. Происходит запуск "
"процесса, выполняется ``'date'``, считывается результат и объект popen "
"(``ph``) закрывается."

msgid ""
"local popen = require('popen')\n"
"-- Run the program and save its handle.\n"
"local ph = popen.shell('date', 'r')\n"
"-- Read program's output, strip trailing newline.\n"
"local date = ph:read():rstrip()\n"
"-- Free resources. The process is killed (but 'date'\n"
"-- exits itself anyway).\n"
"ph:close()\n"
"print(date)"
msgstr ""
"local popen = require('popen')\n"
"-- Запуск программы и сохранение ее дескриптора.\n"
"local ph = popen.shell('date', 'r')\n"
"-- Считывание вывода программы и удаление следующей строки.\n"
"local date = ph:read():rstrip()\n"
"-- Освобождение ресурсов. Процесс принудительно завершается (но 'date'\n"
"-- все равно завершает работу).\n"
"ph:close()\n"
"print(date)"

msgid ""
"Unix defines a text file as a sequence of lines. Each line is terminated by "
"a newline (``\\\\n``) symbol. The same convention is usually applied for "
"text output of a command. So, when it is redirected to a file, the file will"
" be correct."
msgstr ""
"Unix определяет текстовый файл как последовательность строк. Каждая строка "
"заканчивается символом новой строки (``\\\\n``). Аналогичные правила обычно "
"применяются к выводу команды. Поэтому при перенаправлении вывода команды в "
"файл его содержимое будет корректным."

msgid ""
"However, internally an application usually operates on strings, which are "
"*not* terminated by newline (for example literals for error messages). The "
"newline is usually added just before a string is written for the outside "
"world (stdout, console or log). That is why the example above contains "
"``rstrip()``."
msgstr ""
"Однако внутри приложение обычно работает со строками, которые *не* "
"завершаются символом новой строки (например, строки сообщений об ошибках). "
"Символ новой строки обычно добавляется прямо перед записью строки в stdout, "
"консоль или лог. Поэтому в примере выше был использован метод ``rstrip()``."

msgid "Execute a child program in a new process."
msgstr "Выполнение дочерней программы в новом процессе."

msgid ""
"an array of a program to run with command line options, mandatory; absolute "
"path to the program is required when ``opts.shell`` is false (default)"
msgstr ""
"массив, состоящий из запускаемой программы и параметров командной строки, "
"обязательный аргумент; если поле ``opts.shell`` установлено в false (по "
"умолчанию), то необходимо задать абсолютный путь к программе"

msgid "table of options, optional"
msgstr "таблица параметров, необязательно"

msgid "Possible raised errors are:"
msgstr "Возможные ошибки:"

msgid "IllegalParams: incorrect type or value of a parameter"
msgstr "IllegalParams: некорректный тип или значение параметра"

msgid "IllegalParams: group signal is set, while setsid is not"
msgstr "IllegalParams: групповой сигнал задан, а setsid --- нет"

msgid "Possible error reasons when ``nil, err`` is returned are:"
msgstr "Возможные причины ошибок, когда возвращается ``nil, err``:"

msgid ""
"SystemError: dup(), fcntl(), pipe(), vfork() or close() fails in the parent "
"process"
msgstr ""
"SystemError: dup(), fcntl(), pipe(), vfork() или close() завершились с "
"ошибкой в родительском процессе"

msgid ""
"SystemError: (temporary restriction) the parent process has closed stdin, "
"stdout or stderr"
msgstr ""
"SystemError: (временное ограничение) родительский процесс закрыл stdin, "
"stdout или stderr"

msgid "OutOfMemory: unable to allocate the handle or a temporary buffer"
msgstr ""
"OutOfMemory: невозможно выделить память для дескриптора или временного "
"буфера"

msgid "Possible ``opts`` items are:"
msgstr "Возможные элементы ``opts``:"

msgid "``opts.stdin`` (action on STDIN_FILENO)"
msgstr "``opts.stdin`` (действие над STDIN_FILENO)"

msgid "``opts.stdout`` (action on STDOUT_FILENO)"
msgstr "``opts.stdout`` (действие над STDOUT_FILENO)"

msgid "``opts.stderr`` (action on STDERR_FILENO)"
msgstr "``opts.stderr`` (действие над STDERR_FILENO)"

msgid "The ``opts`` table file descriptor actions may be:"
msgstr "Возможные действия файлового дескриптора в таблице ``opts``:"

msgid ""
"``popen.opts.INHERIT`` (== ``'inherit'``) [default] inherit the fd from the "
"parent"
msgstr ""
"``popen.opts.INHERIT`` (== ``'inherit'``) [default] унаследовать файловый "
"дескриптор от родительского процесса"

msgid "``popen.opts.DEVNULL`` (== ``'devnull'``) open /dev/null on the fd"
msgstr ""
"``popen.opts.DEVNULL`` (== ``'devnull'``) открыть /dev/null для файлового "
"дескриптора"

msgid "``popen.opts.CLOSE`` (== ``'close'``) close the fd"
msgstr "``popen.opts.CLOSE`` (== ``'close'``) закрыть файловый дескриптор"

msgid ""
"``popen.opts.PIPE`` (== ``'pipe'``) feed data from fd to parent, or from "
"parent to fd, using a pipe"
msgstr ""
"``popen.opts.PIPE`` (== ``'pipe'``) перенаправить данные из файлового "
"дескриптора в родительский процесс или из родительского процесса в файловый "
"дескриптор через канал (pipe)"

msgid ""
"The ``opts`` table may contain an ``env`` table of environment variables to "
"be used inside a process. Each ``opts.env`` item may be a key-value pair "
"(key is a variable name, value is a variable value)."
msgstr ""
"Таблица ``opts`` может содержать таблицу ``env`` переменных среды для "
"использования внутри процесса. Каждый элемент ``opts.env`` может быть парой "
"ключ-значение (где ключ --- имя переменной, а значение --- значение "
"переменной)."

msgid "If ``opts.env`` is not set then the current environment is inherited."
msgstr "Если ``opts.env`` не установлено, то наследуется текущая среда."

msgid ""
"If ``opts.env`` is an empty table, then the environment will be dropped."
msgstr "Если ``opts.env`` является пустой таблицей, то среда будет сброшена."

msgid ""
"If ``opts.env`` is set to a non-empty table, then the environment will be "
"replaced."
msgstr ""
"Если ``opts.env`` является непустой таблицей, то среда будет заменена."

msgid "The ``opts`` table may contain these boolean items:"
msgstr "Таблица ``opts`` может содержать следующие элементы типа boolean:"

msgid "Default"
msgstr "Значение по умолчанию"

msgid "opts.shell"
msgstr "opts.shell"

msgid "false"
msgstr "false"

msgid ""
"If true, then run a child process via ``sh -c \"${opts.argv}\"``. If false, "
"then call the executable directly."
msgstr ""
"При значении true выполняется запуск дочернего процесса через ``sh -c "
"\"${opts.argv}\"``. При значении false исполняемый процесс вызывается "
"напрямую."

msgid "opts.setsid"
msgstr "opts.setsid"

msgid ""
"If true, then run the program in a new session. If false, then run the "
"program in the Tarantool instance's session and process group."
msgstr ""
"При значении true программа запускается в новой сессии. При значении false "
"программа запускается в сессии и группе процессов экземпляра Tarantool."

msgid "opts.close_fds"
msgstr "opts.close_fds"

msgid "true"
msgstr "true"

msgid ""
"If true, then close all inherited fds from the parent. If false, then do not"
" close all inherited fds from the parent."
msgstr ""
"При значении true закрываются все унаследованные родительские файловые "
"дескрипторы. При значении false унаследованные родительские файловые "
"дескрипторы не закрываются."

msgid "opts.restore_signals"
msgstr "opts.restore_signals"

msgid ""
"If true, then reset all signal actions modified in the parent's process. If "
"false, then inherit all signal actions modified in the parent's process."
msgstr ""
"При значении true сбрасываются все действия сигналов, измененные в "
"родительском процессе. При значении false все действия сигналов, измененные "
"в родительском процессе, наследуются."

msgid "opts.group_signal"
msgstr "opts.group_signal"

msgid ""
"If true, then send signal to a child process group, if and only if "
"``opts.setsid`` is enabled. If false, then send signal to a child process "
"only."
msgstr ""
"При значении true отправляется сигнал в группу дочерних процессов, но только"
" при условии, что установлено поле ``opts.setsid``. При значении false "
"сигнал отправляется только одному дочернему процессу."

msgid "opts.keep_child"
msgstr "opts.keep_child"

msgid ""
"If true, then do not send SIGKILL to a child process (or to a process group "
"if ``opts.group_signal`` true). If false, then do send SIGKILL to a child "
"process (or to a process group if ``opts.group_signal`` is true) at "
":ref:`popen_handle:close() <popen-close>` or when Lua GC collects the "
"handle."
msgstr ""
"При значении true дочернему процессу (или группе процессов, если поле "
"``opts.group_signal`` установлено в true) не отправляется сигнал SIGKILL. "
"При значении false дочернему процессу (или группе процессов, если поле "
"``opts.group_signal`` установлено в true) отправляется сигнал SIGKILL при "
"выполнении :ref:`popen_handle:close() <popen-close>` или когда Lua GC "
"собирает дескрипторы."

msgid ""
"The returned ``ph`` handle provides a :ref:`popen_handle:close() <popen-"
"close>` method for explicitly releasing all occupied resources, including "
"the child process itself if ``opts.keep_child`` is not set). However, if the"
" ``close()`` method is not called for a handle during its lifetime, the Lua "
"GC will trigger the same freeing actions."
msgstr ""
"Возвращаемый дескриптор ``ph`` дает доступ к методу "
":ref:`popen_handle:close() <popen-close>` для явного освобождения всех "
"занятых ресурсов, включая сам дочерний процесс, если не установлено поле "
"``opts.keep_child``. Однако, если метод ``close()`` не вызывается для "
"дескриптора в течение его жизни, Lua GC запустит то же самое действие по "
"освобождению ресурсов."

msgid ""
"Tarantool recommends using ``opts.setsid`` plus ``opts.group_signal`` if a "
"child process may spawn its own children and if they should all be killed "
"together."
msgstr ""
"Tarantool рекомендует использовать ``opts.setsid`` вместе с "
"``opts.group_signal``, если дочерний процесс может создать собственные "
"дочерние процессы и их все нужно будет завершить одновременно."

msgid ""
"A signal will not be sent if the child process is already dead. Otherwise we"
" might kill another process that occupies the same PID later. This means "
"that if the child process dies before its own children die, then the "
"function will not send a signal to the process group even when "
"``opts.setsid`` and ``opts.group_signal`` are set."
msgstr ""
"Сигнал не будет отправлен, если дочерний процесс уже был завершен. В "
"противном случае мы можем случайно завершить другой процесс, который имеет "
"тот же идентификатор процесса после освобождения его предыдущим. Это "
"означает, что если дочерний процесс завершается до того, как завершаются его"
" дочерние процессы, то функция не будет отправлять сигнал группе процессов, "
"даже когда установлены ``opts.setsid`` и ``opts.group_signal``."

msgid ""
"Use :ref:`os.environ() <os-environ>` to pass a copy of the current "
"environment with several replacements (see example 2 below)."
msgstr ""
"Используйте :ref:`os.environ() <os-environ>`, чтобы передать копию текущей "
"среды с несколькими заменами (см. Пример 2 ниже)."

msgid "**Example 1**"
msgstr "**Пример 1**"

msgid ""
"This is the equivalent of the ``sh -c date`` command. It starts a process, "
"runs 'date', reads the output, and closes the popen object (``ph``)."
msgstr ""
"В этом примере выполняется аналог команды ``sh -c date``. Происходит запуск "
"процесса, выполняется ``'date'``, считывается результат и объект popen "
"(``ph``) закрывается."

msgid ""
"local popen = require('popen')\n"
"\n"
"local ph = popen.new({'/bin/date'}, {\n"
"    stdout = popen.opts.PIPE,\n"
"})\n"
"local date = ph:read():rstrip()\n"
"ph:close()\n"
"print(date) -- e.g. Thu 16 Apr 2020 01:40:56 AM MSK"
msgstr ""
"local popen = require('popen')\n"
"\n"
"local ph = popen.new({'/bin/date'}, {\n"
"    stdout = popen.opts.PIPE,\n"
"})\n"
"local date = ph:read():rstrip()\n"
"ph:close()\n"
"print(date) -- например, Thu 16 Apr 2020 01:40:56 AM MSK"

msgid "**Example 2**"
msgstr "**Пример 2**"

msgid ""
"Example 2 is quite similar to Example 1, but sets an environment variable "
"and uses the shell builtin ``'echo'`` to show it."
msgstr ""
"Пример 2 во многом похож на Пример 1. Отличие в том, что в нем задается "
"переменная среды и используется встроенная команда оболочки ``'echo'`` для "
"ее отображения."

msgid ""
"local popen = require('popen')\n"
"local env = os.environ()\n"
"env['FOO'] = 'bar'\n"
"local ph = popen.new({'echo \"${FOO}\"'}, {\n"
"    stdout = popen.opts.PIPE,\n"
"    shell = true,\n"
"    env = env,\n"
"})\n"
"local res = ph:read():rstrip()\n"
"ph:close()\n"
"print(res) -- bar"
msgstr ""
"local popen = require('popen')\n"
"local env = os.environ()\n"
"env['FOO'] = 'bar'\n"
"local ph = popen.new({'echo \"${FOO}\"'}, {\n"
"    stdout = popen.opts.PIPE,\n"
"    shell = true,\n"
"    env = env,\n"
"})\n"
"local res = ph:read():rstrip()\n"
"ph:close()\n"
"print(res) -- bar"

msgid "**Example 3**"
msgstr "**Пример 3**"

msgid "Example 3 demonstrates how to capture a child's stderr."
msgstr "Пример 3 показывает, как перехватить дочерний поток stderr."

msgid ""
"local popen = require('popen')\n"
"local ph = popen.new({'echo hello >&2'}, { -- !!\n"
"    stderr = popen.opts.PIPE,              -- !!\n"
"    shell = true,\n"
"})\n"
"local res = ph:read({stderr = true}):rstrip()\n"
"ph:close()\n"
"print(res) -- hello"
msgstr ""
"local popen = require('popen')\n"
"local ph = popen.new({'echo hello >&2'}, { -- !!\n"
"    stderr = popen.opts.PIPE,              -- !!\n"
"    shell = true,\n"
"})\n"
"local res = ph:read({stderr = true}):rstrip()\n"
"ph:close()\n"
"print(res) -- hello"

msgid "**Example 4**"
msgstr "**Пример 4**"

msgid ""
"Example 4 demonstrates how to run a stream program (like ``grep``, ``sed`` "
"and so on), write to its stdin and read from its stdout."
msgstr ""
"Пример 4 показывает, как запустить потоковую программу (например, ``grep``, "
"``sed`` и т.д.), записать данные в ее поток stdin и считать данные из "
"stdout."

msgid ""
"The example assumes that input data are small enough to fit in a pipe buffer"
" (typically 64 KiB, but this depends on the platform and its configuration)."
msgstr ""
"В этом примере предполагается, что входные данные достаточно малы, чтобы "
"поместиться в буфер канала (обычно его размер равен 64 КиБ, но это зависит "
"от конкретной платформы и ее конфигурации)."

msgid ""
"If a process writes lengthy data, it will get stuck in "
":ref:`popen_handle:write() <popen-write>`. To handle this case: call "
":ref:`popen_handle:read() <popen-read>` in a loop in another fiber (start it"
" before the first ``:write()``)."
msgstr ""
"Если процесс записывает большое количество данных, он приостановится при "
"выполнении :ref:`popen_handle:write() <popen-write>`. Для разрешения этой "
"проблемы вызывайте :ref:`popen_handle:read() <popen-read>` в цикле в другом "
"файбере (запустите его перед первым вызовом ``:write()``)."

msgid ""
"If a process writes lengthy text to stderr, it may get stick in ``write()`` "
"because the stderr pipe buffer becomes full. To handle this case: read "
"stderr in a separate fiber."
msgstr ""
"Если процесс записывает длинный текст в stderr, он может приостановиться при"
" выполнении ``write()``, потому что буфер канала stderr заполнился. Для "
"решения этой проблемы считывайте из stderr в отдельном файбере."

msgid ""
"local function call_jq(input, filter)\n"
"    -- Start jq process, connect to stdin, stdout and stderr.\n"
"    local jq_argv = {'/usr/bin/jq', '-M', '--unbuffered', filter}\n"
"    local ph, err = popen.new(jq_argv, {\n"
"        stdin = popen.opts.PIPE,\n"
"        stdout = popen.opts.PIPE,\n"
"        stderr = popen.opts.PIPE,\n"
"    })\n"
"    if ph == nil then return nil, err end\n"
"    -- Write input data to child's stdin and send EOF.\n"
"    local ok, err = ph:write(input)\n"
"    if not ok then return nil, err end\n"
"    ph:shutdown({stdin = true})\n"
"    -- Read everything until EOF.\n"
"    local chunks = {}\n"
"    while true do\n"
"        local chunk, err = ph:read()\n"
"        if chunk == nil then\n"
"            ph:close()\n"
"            return nil, err\n"
"        end\n"
"        if chunk == '' then break end -- EOF\n"
"        table.insert(chunks, chunk)\n"
"    end\n"
"    -- Read diagnostics from stderr if any.\n"
"    local err = ph:read({stderr = true})\n"
"    if err ~= '' then\n"
"        ph:close()\n"
"        return nil, err\n"
"    end\n"
"    -- Glue all chunks, strip trailing newline.\n"
"    return table.concat(chunks):rstrip()\n"
"end"
msgstr ""
"local function call_jq(input, filter)\n"
"    -- Запуск процесса jq, соединение с stdin, stdout и stderr.\n"
"    local jq_argv = {'/usr/bin/jq', '-M', '--unbuffered', filter}\n"
"    local ph, err = popen.new(jq_argv, {\n"
"        stdin = popen.opts.PIPE,\n"
"        stdout = popen.opts.PIPE,\n"
"        stderr = popen.opts.PIPE,\n"
"    })\n"
"    if ph == nil then return nil, err end\n"
"    -- Запись входных данных в дочерний stdin и отправка EOF.\n"
"    local ok, err = ph:write(input)\n"
"    if not ok then return nil, err end\n"
"    ph:shutdown({stdin = true})\n"
"    -- Считывание всех данных до EOF.\n"
"    local chunks = {}\n"
"    while true do\n"
"        local chunk, err = ph:read()\n"
"        if chunk == nil then\n"
"            ph:close()\n"
"            return nil, err\n"
"        end\n"
"        if chunk == '' then break end -- EOF\n"
"        table.insert(chunks, chunk)\n"
"    end\n"
"    -- Считывание данных диагностики из stderr (при наличии).\n"
"    local err = ph:read({stderr = true})\n"
"    if err ~= '' then\n"
"        ph:close()\n"
"        return nil, err\n"
"    end\n"
"    -- Соединение всех частей вместе, обрезка символа конца строки.\n"
"    return table.concat(chunks):rstrip()\n"
"end"

msgid "popen handle methods"
msgstr "методы дескриптора popen"

msgid "Read data from a child peer."
msgstr "Считывание данных из дочернего процесса."

msgid ""
"handle of a child process created with :ref:`popen.new() <popen-new>` or "
":ref:`popen.shell() <popen-shell>`"
msgstr ""
"дескриптор дочернего процесса, созданный через :ref:`popen.new() <popen-"
"new>` или :ref:`popen.shell() <popen-shell>`"

msgid "options"
msgstr "параметры"

msgid ""
"Possible errors, raised on incorrect parameters or when the fiber is "
"cancelled:"
msgstr ""
"Возможные ошибки при некорректно заданных параметрах или при отмене файбера:"

msgid "IllegalParams:    incorrect type or value of a parameter"
msgstr "IllegalParams:    некорректный тип или значение параметра"

msgid "IllegalParams:    called on a closed handle"
msgstr "IllegalParams:    вызов дескриптора, который уже был закрыт"

msgid "IllegalParams:    opts.stdout and opts.stderr are both set"
msgstr "IllegalParams:    одновременно установлены opts.stdout и opts.stderr"

msgid ""
"IllegalParams:    a requested IO operation is not supported by the handle "
"(stdout / stderr is not piped)"
msgstr ""
"IllegalParams:    запрашиваемая операция ввода-вывода не поддерживается "
"дескриптором (вывод stdout / stderr не перенаправлен)"

msgid "IllegalParams:    attempt to operate on a closed file descriptor"
msgstr ""
"IllegalParams:    попытка произвести операцию над закрытым файловым "
"дескриптором"

msgid "FiberIsCancelled: cancelled by an outside code"
msgstr "FiberIsCancelled: файбер отменен во внешней программе"

msgid "``true`` on success, ``false`` on error"
msgstr "``true`` при успешном выполнении, ``false`` при ошибке"

msgid "rtype"
msgstr "возвращаемое значение"

msgid "(if success) string with read value, empty string if EOF"
msgstr ""
"(при успешном выполнении) строка со считанным значением, пустая строка при "
"EOF"

msgid ""
"``opts.stdout`` (boolean, default ``true``, if ``true`` then read from "
"stdout)"
msgstr ""
"``opts.stdout`` (boolean, значение по умолчанию --- ``true``, при значении "
"``true`` выполняется считывание из stdout)"

msgid ""
"``opts.stderr`` (boolean, default ``false``, if ``true`` then read from "
"stderr)"
msgstr ""
"``opts.stderr`` (boolean, значение по умолчанию --- ``false``, при значении "
"``true`` выполняется считывание из stderr)"

msgid "``opts.timeout`` (number, default 100 years, time quota in seconds)"
msgstr ""
"``opts.timeout`` (число, значение по умолчанию --- 100 лет, временная квота "
"в секундах)"

msgid ""
"In other words: by default ``read()`` reads from stdout, but reads from "
"stderr if one sets ``opts.stderr`` to ``true`` (it is not legal to set both "
"``opts.stdout`` and ``opts.stderr`` to ``true``)."
msgstr ""
"Другими словами: по умолчанию ``read()`` выполняет считывание из stdout, но "
"если установить ``opts.stderr`` в ``true``, то считывание происходит из "
"stderr (нельзя одновременно установить ``opts.stdout`` и ``opts.stderr`` в "
"``true``)."

msgid "SocketError: an IO error occurs at read()"
msgstr "SocketError: ошибка ввода-вывода при выполнении read()"

msgid "TimedOut:    exceeded the opts.timeout quota"
msgstr "TimedOut:    превышение квоты opts.timeout"

msgid "OutOfMemory: no memory space for a buffer to read into"
msgstr "OutOfMemory: недостаточно памяти для считывания в буфер"

msgid "LuajitError: (\"not enough memory\"): no memory space for the Lua string"
msgstr "LuajitError: (\"not enough memory\"): недостаточно памяти для строки Lua"

msgid "Write string ``str`` to stdin stream of a child process."
msgstr "Запись строки ``str`` в поток stdin дочернего процесса."

msgid "string to write"
msgstr "строка для записи"

msgid "(if success) boolean = true"
msgstr "(при успешном выполнении) boolean = true"

msgid ""
"Possible ``opts`` items are: ``opts.timeout`` (number, default 100 years, "
"time quota in seconds)."
msgstr ""
"Возможные элементы ``opts``: ``opts.timeout`` (число, значение по умолчанию "
"--- 100 лет, временная квота в секундах)."

msgid "IllegalParams:    string length is greater then SSIZE_MAX"
msgstr "IllegalParams:    длина строки превышает SSIZE_MAX"

msgid ""
"IllegalParams:    a requested IO operation is not supported by the handle "
"(stdin is not piped)"
msgstr ""
"IllegalParams:    запрашиваемая операция ввода-вывода не поддерживается "
"дескриптором (вывод stdin не перенаправлен)"

msgid "SocketError: an IO error occurs at write()"
msgstr "SocketError: ошибка ввода-вывода при выполнении write()"

msgid "TimedOut:    exceeded opts.timeout quota"
msgstr "TimedOut:    превышение квоты opts.timeout"

msgid ""
"``write()`` may yield forever if the child process does not read data from "
"stdin and a pipe buffer becomes full. The size of this pipe buffer depends "
"on the platform. Set ``opts.timeout`` when unsure."
msgstr ""
"``write()`` может передать управление (yield) и заблокировать файбер, если "
"дочерний процесс не считывает данные из stdin и буфер канала заполнился. "
"Размер буфера зависит от платформы. Если сомневаетесь, обратите внимание на "
"опцию ``opts.timeout``."

msgid ""
"When ``opts.timeout`` is not set, the ``write()`` blocks (yields the fiber) "
"until all data is written or an error happens."
msgstr ""
"Когда опция ``opts.timeout`` не установлена, ``write()`` блокирует файбер до"
" момента полной записи данных или возникновения ошибки записи."

msgid "Close parent's ends of std* fds."
msgstr "Закрытие канала с std* со стороны родителя."

msgid "``opts.stdin`` (boolean) close parent's end of stdin"
msgstr "``opts.stdin`` (boolean) закрыть stdin со стороны родителя"

msgid "``opts.stdout`` (boolean) close parent's end of stdout"
msgstr "``opts.stdout`` (boolean) закрыть stdout со стороны родителя"

msgid "``opts.stderr`` (boolean) close parent's end of stderr"
msgstr "``opts.stderr`` (boolean) закрыть stderr со стороны родителя"

msgid "We may use the term std* to mean any one of these items."
msgstr ""
"Мы можем использовать термин std* для указания на любой из этих элементов."

msgid "IllegalParams:  an incorrect handle parameter"
msgstr "IllegalParams:  некорректный параметр дескриптора"

msgid "IllegalParams:  called on a closed handle"
msgstr "IllegalParams:  вызов дескриптора, который уже был закрыт"

msgid "IllegalParams:  neither stdin, stdout nor stderr is chosen"
msgstr "IllegalParams:  не выбран ни один из потоков stdin, stdout или stderr"

msgid ""
"IllegalParams:  a requested IO operation is not supported by the handle (one"
" of std* is not piped)"
msgstr ""
"IllegalParams:  запрашиваемая операция ввода-вывода не поддерживается "
"дескриптором (один из потоков std* не перенаправлен)"

msgid ""
"The main reason to use ``shutdown()`` is to send EOF to a child's stdin. "
"However the parent's end of stdout / stderr may be closed too."
msgstr ""
"Основная цель использования ``shutdown()`` --- отправка EOF в дочерний поток"
" stdin. Однако stdout / stderr может быть уже закрыт со стороны "
"родительского процесса."

msgid ""
"``shutdown()`` does not fail on already closed fds (idempotence). However, "
"it fails on an attempt to close the end of a pipe that never existed. In "
"other words, only those ``std*`` options that were set to "
"``popen.opts.PIPE`` during handle creation may be used here (for "
":ref:`popen.shell() <popen-shell>`: ``'r'`` corresponds to stdout, ``'R'`` "
"to stderr and ``'w'`` to stdin)."
msgstr ""
"``shutdown()`` не выдает ошибку при выполнении над уже закрытыми файловыми "
"дескрипторами (идемпотентность). Однако ошибка возникнет при попытке закрыть"
" канал, которого никогда не существовало. Другими словами, здесь можно "
"использовать только те опции ``std*`` , которые были заданы для "
"``popen.opts.PIPE`` при создании дескриптора (для :ref:`popen.shell() "
"<popen-shell>`: ``'r'`` соответствует stdout, ``'R'`` --- stderr, а ``'w'`` "
"--- stdin)."

msgid ""
"``shutdown()`` does not close any fds on a failure: either all requested fds"
" are closed or none of them."
msgstr ""
"``shutdown()`` не закрывает никакие файловые дескрипторы при завершении с "
"ошибкой: либо закрываются все запрашиваемые дескрипторы (при успешном "
"выполнении), либо ни один из них."

msgid ""
"local popen = require('popen')\n"
"local ph = popen.shell('sed s/foo/bar/', 'rw')\n"
"ph:write('lorem foo ipsum')\n"
"ph:shutdown({stdin = true})\n"
"local res = ph:read()\n"
"ph:close()\n"
"print(res) -- lorem bar ipsum"
msgstr ""
"local popen = require('popen')\n"
"local ph = popen.shell('sed s/foo/bar/', 'rw')\n"
"ph:write('lorem foo ipsum')\n"
"ph:shutdown({stdin = true})\n"
"local res = ph:read()\n"
"ph:close()\n"
"print(res) -- lorem bar ipsum"

msgid "Send SIGTERM signal to a child process."
msgstr "Отправка сигнала SIGTERM дочернему процессу."

msgid ""
"see :ref:`popen_handle:signal() <popen-signal>` for errors and return values"
msgstr ""
"для получения информации об ошибках и возвращаемых значениях смотрите "
":ref:`popen_handle:signal() <popen-signal>`"

msgid ""
"``terminate()`` only sends a SIGTERM signal. It does *not* free any "
"resources (such as popen handle memory and file descriptors)."
msgstr ""
"``terminate()`` просто отправляет сигнал SIGTERM. Он *не* освобождает "
"никакие ресурсы (такие как память для дескрипторов popen и файловые "
"дескрипторы)."

msgid "Send SIGKILL signal to a child process."
msgstr "Отправка сигнала SIGKILL дочернему процессу."

msgid ""
"``kill()`` only sends a SIGKILL signal. It does *not* free any resources "
"(such as popen handle memory and file descriptors)."
msgstr ""
"``kill()`` просто отправляет сигнал SIGKILL. Он *не* освобождает никакие "
"ресурсы (такие как память для дескрипторов popen и файловые дескрипторы)."

msgid "Send signal to a child process."
msgstr "Отправка сигнала дочернему процессу."

msgid "signal to send"
msgstr "отправляемый сигнал"

msgid "(if success) `true` (signal is sent)"
msgstr "(при успешном выполнении) `true` (сигнал отправлен)"

msgid "Possible raised errors:"
msgstr "Возможные ошибки:"

msgid "IllegalParams:    an incorrect handle parameter"
msgstr "IllegalParams:    некорректный параметр дескриптора"

msgid "Possible error values for ``nil, err``:"
msgstr "Возможные значения ошибок при возвращении ``nil, err``:"

msgid ""
"SystemError: a process does not exists any more (this may also be returned "
"for a zombie process or when all processes in a group are zombies (but see "
"note re Mac OS below)"
msgstr ""
"SystemError: процесс больше не существует (также может возвращаться для "
"зомби-процессов или когда все процессы в группе являются зомби-процессами "
"(но см. примечание для Mac OS ниже)"

msgid "SystemError: invalid signal number"
msgstr "SystemError: неправильный номер сигнала"

msgid ""
"SystemError: no permission to send a signal to a process or a process group "
"(this is returned on Mac OS when a signal is sent to a process group, where "
"a group leader is a zombie (or when all processes in it are zombies, details"
" re uncertain) (this may also appear due to other reasons, details are "
"uncertain)"
msgstr ""
"SystemError: нет разрешения на отправку сигнала процессу или группе "
"процессов (возвращается на Mac OS, когда сигнал отправляется группе "
"процессов, где лидер группы является зомби-процессом (или все процессы "
"являются зомби-процессами, детали неясны) (эта ошибка также может возникнуть"
" по другим причинам, детали неясны)"

msgid ""
"If ``opts.setsid`` and ``opts.group_signal`` are set for the handle, the "
"signal is sent to the process group rather than to the process. See "
":ref:`popen.new() <popen-new>` for details about group signaling. Warning: "
"On Mac OS it is possible that a process in the group will not receive the "
"signal, particularly if the process has just been forked (this may be due to"
" a race condition)."
msgstr ""
"Если для дескриптора установлены ``opts.setsid`` и ``opts.group_signal``, "
"сигнал отправляется группе процессов, а не отдельному процессу. Для "
"подробной информации по групповым сигналам смотрите :ref:`popen.new() "
"<popen-new>`. Внимание: на Mac OS процесс в группе может не получить сигнал,"
" особенно если он только что был разветвлен (возможно это происходит из-за "
"состояния гонки)."

msgid ""
"Note: The module offers ``popen.signal.SIG*`` constants, because some "
"signals have different numbers on different platforms."
msgstr ""
"Примечание: Некоторые сигналы имеют разные номера на разных платформах. "
"Поэтому в этом модуле мы предлагаем константы ``popen.signal.SIG*``."

msgid "Return information about the popen handle."
msgstr "Получение информации о дескрипторе popen."

msgid "(if success) formatted result"
msgstr "(при успешном выполнении) отформатированный результат"

msgid "res"
msgstr "res"

msgid "IllegalParams: an incorrect handle parameter"
msgstr "IllegalParams: некорректный параметр дескриптора"

msgid "IllegalParams: called on a closed handle"
msgstr "IllegalParams: вызов дескриптора, который уже был закрыт"

msgid "The result format is:"
msgstr "Результат выводится в следующем формате:"

msgid ""
"{\n"
"    pid = <number> or <nil>,\n"
"    command = <string>,\n"
"    opts = <table>,\n"
"    status = <table>,\n"
"    stdin = one-of(\n"
"        popen.stream.OPEN   (== 'open'),\n"
"        popen.stream.CLOSED (== 'closed'),\n"
"        nil,\n"
"    ),\n"
"    stdout = one-of(\n"
"        popen.stream.OPEN   (== 'open'),\n"
"        popen.stream.CLOSED (== 'closed'),\n"
"        nil,\n"
"    ),\n"
"    stderr = one-of(\n"
"        popen.stream.OPEN   (== 'open'),\n"
"        popen.stream.CLOSED (== 'closed'),\n"
"        nil,\n"
"    ),\n"
"}"
msgstr ""
"{\n"
"    pid = <number> or <nil>,\n"
"    command = <string>,\n"
"    opts = <table>,\n"
"    status = <table>,\n"
"    stdin = one-of(\n"
"        popen.stream.OPEN   (== 'open'),\n"
"        popen.stream.CLOSED (== 'closed'),\n"
"        nil,\n"
"    ),\n"
"    stdout = one-of(\n"
"        popen.stream.OPEN   (== 'open'),\n"
"        popen.stream.CLOSED (== 'closed'),\n"
"        nil,\n"
"    ),\n"
"    stderr = one-of(\n"
"        popen.stream.OPEN   (== 'open'),\n"
"        popen.stream.CLOSED (== 'closed'),\n"
"        nil,\n"
"    ),\n"
"}"

msgid ""
"``pid`` is a process id of the process when it is alive, otherwise ``pid`` "
"is nil."
msgstr ""
"``pid`` --- это идентификатор процесса, когда тот находится в рабочем "
"состоянии; для завершенного процесса ``pid`` имеет значение nil."

msgid ""
"``command`` is a concatenation of space-separated arguments that were passed"
" to ``execve()``. Multiword arguments are quoted. Quotes inside arguments "
"are not escaped."
msgstr ""
"``command`` --- это конкатенация аргументов, разделенных пробелами, которые "
"были переданы в ``execve()``. Аргументы, состоящие из нескольких слов, "
"заключаются в кавычки. Кавычки внутри аргументов не экранируются."

msgid ""
"``opts`` is a table of handle options as in the :ref:`popen.new() <popen-"
"new>` ``opts`` parameter. ``opts.env`` is not shown here, because the "
"environment variables map is not stored in a handle."
msgstr ""
"``opts`` -- это таблица параметров дескриптора, описанная в разделе ``opts``"
" функции :ref:`popen.new() <popen-new>`. ``opts.env`` здесь не отображается,"
" потому что карта переменных среды не хранится в дескрипторе."

msgid ""
"``status`` is a table that represents a process status in the following "
"format:"
msgstr ""
"``status`` --- это таблица, отображающая состояние процесса в следующем "
"формате:"

msgid ""
"{\n"
"    state = one-of(\n"
"        popen.state.ALIVE    (== 'alive'),\n"
"        popen.state.EXITED   (== 'exited'),\n"
"        popen.state.SIGNALED (== 'signaled'),\n"
"    )\n"
"    -- Present when `state` is 'exited'.\n"
"    exit_code = <number>,\n"
"    -- Present when `state` is 'signaled'.\n"
"    signo = <number>,\n"
"    signame = <string>,\n"
"}"
msgstr ""
"{\n"
"    state = one-of(\n"
"        popen.state.ALIVE    (== 'alive'),\n"
"        popen.state.EXITED   (== 'exited'),\n"
"        popen.state.SIGNALED (== 'signaled'),\n"
"    )\n"
"    -- Отображается при состоянии процесса 'завершенный'.\n"
"    exit_code = <number>,\n"
"    -- Отображается при состоянии процесса 'принимающий сигнал'.\n"
"    signo = <number>,\n"
"    signame = <string>,\n"
"}"

msgid ""
"``stdin``, ``stdout``, and ``stderr`` reflect the status of the parent's end"
" of a piped stream. If a stream is not piped, the field is not present "
"(``nil``). If it is piped, the status may be either ``popen.stream.OPEN`` "
"(== ``'open'``) or ``popen.stream.CLOSED`` (== ``'closed'``). The status may"
" be changed from ``'open'`` to ``'closed'`` by a "
":ref:`popen_handle:shutdown({std... = true}) <popen-shutdown>` call."
msgstr ""
"``stdin``, ``stdout`` и ``stderr`` отражают состояние канала cо стороны "
"процесса-родителя. Если поток не перенаправлен, это поле отсутствует "
"(``nil``). Если же перенаправлен, состояние может быть либо "
"``popen.stream.OPEN`` (== ``'open'``), либо ``popen.stream.CLOSED`` (== "
"``'closed'``). Состояние можно изменить с ``'open'`` на ``'closed'`` вызовом"
" :ref:`popen_handle:shutdown({std... = true}) <popen-shutdown>`."

msgid "(on Tarantool console)"
msgstr "(в консоли Tarantool)"

msgid ""
"tarantool> require('popen').new({'/usr/bin/touch', '/tmp/foo'})\n"
"---\n"
"- command: /usr/bin/touch /tmp/foo\n"
"  status:\n"
"    state: alive\n"
"  opts:\n"
"    stdout: inherit\n"
"    stdin: inherit\n"
"    group_signal: false\n"
"    keep_child: false\n"
"    close_fds: true\n"
"    restore_signals: true\n"
"    shell: false\n"
"    setsid: false\n"
"    stderr: inherit\n"
"  pid: 9499\n"
"..."
msgstr ""
"tarantool> require('popen').new({'/usr/bin/touch', '/tmp/foo'})\n"
"---\n"
"- command: /usr/bin/touch /tmp/foo\n"
"  status:\n"
"    state: alive\n"
"  opts:\n"
"    stdout: inherit\n"
"    stdin: inherit\n"
"    group_signal: false\n"
"    keep_child: false\n"
"    close_fds: true\n"
"    restore_signals: true\n"
"    shell: false\n"
"    setsid: false\n"
"    stderr: inherit\n"
"  pid: 9499\n"
"..."

msgid ""
"tarantool> require('popen').shell('grep foo', 'wrR')\n"
"---\n"
"- stdout: open\n"
"  command: sh -c 'grep foo'\n"
"  stderr: open\n"
"  status:\n"
"    state: alive\n"
"  stdin: open\n"
"  opts:\n"
"    stdout: pipe\n"
"    stdin: pipe\n"
"    group_signal: true\n"
"    keep_child: false\n"
"    close_fds: true\n"
"    restore_signals: true\n"
"    shell: true\n"
"    setsid: true\n"
"    stderr: pipe\n"
"  pid: 10497\n"
"..."
msgstr ""
"tarantool> require('popen').shell('grep foo', 'wrR')\n"
"---\n"
"- stdout: open\n"
"  command: sh -c 'grep foo'\n"
"  stderr: open\n"
"  status:\n"
"    state: alive\n"
"  stdin: open\n"
"  opts:\n"
"    stdout: pipe\n"
"    stdin: pipe\n"
"    group_signal: true\n"
"    keep_child: false\n"
"    close_fds: true\n"
"    restore_signals: true\n"
"    shell: true\n"
"    setsid: true\n"
"    stderr: pipe\n"
"  pid: 10497\n"
"..."

msgid "Wait until a child process gets exited or signaled."
msgstr "Ожидание, пока дочерний процесс не завершится или не получит сигнал."

msgid ""
"The formatted result is a process status table (the same as the ``status`` "
"component of the table returned by :ref:`popen_handle:info() <popen-info>`)."
msgstr ""
"Отформатированный результат представляет собой таблицу состояний процесса "
"(аналогично компоненту ``status`` таблицы, возвращаемой через "
":ref:`popen_handle:info() <popen-info>`)."

msgid "Close a popen handle."
msgstr "Закрытие дескриптора popen."

msgid "(if success) true"
msgstr "(при успешном выполнении) true"

msgid ""
"Possible diagnostics when ``nil, err`` is returned (do not consider them as "
"errors):"
msgstr ""
"Возможные результаты диагностики, когда возвращается ``nil, err`` (не "
"рассматривайте эти случаи как ошибки):"

msgid ""
"SystemError: no permission to send a signal to a process or a process group "
"(This diagnostic may appear due to Mac OS behavior on zombies when "
"``opts.group_signal`` is set, see :ref:`popen_handle:signal() <popen-"
"signal>`. It may appear for other reasons, details are unclear.)"
msgstr ""
"SystemError: нет разрешения на отправку сигнала процессу или группе "
"процессов (это сообщение диагностики может появиться из-за особенностей "
"обработки зомби-процессов в Mac OS, когда установлен ``opts.group_signal``, "
"см. :ref:`popen_handle:signal() <popen-signal>`. Оно также может появиться "
"по другим причинам, детали неясны)."

msgid ""
"The return is always ``true`` when a process is known to be dead (for "
"example, after :ref:`popen_handle:wait() <popen-wait>` no signal will be "
"sent, so no 'failure' may appear)."
msgstr ""
"Если известно, что процесс был завершен, то в результате всегда возвращается"
" ``true`` (например, после выполнения :ref:`popen_handle:wait() <popen-"
"wait>` не будет отправлено никакого сигнала, так что никакой ошибки не может"
" возникнуть)."

msgid ""
"``close()`` kills a process using SIGKILL and releases all resources "
"associated with the popen handle."
msgstr ""
"``close()`` принудительно завершает процесс через SIGKILL и освобождает все "
"ресурсы, связанные с дескриптором popen."

msgid "Details about signaling:"
msgstr "Подробная информация об отправке сигналов:"

msgid "The signal is sent only when opts.keep_child is not set."
msgstr "Сигнал отправляется только когда поле opts.keep_child не установлено."

msgid ""
"The signal is sent only when a process is alive according to the information"
" available on current event loop iteration. (There is a gap here: a zombie "
"may be signaled; it is harmless.)"
msgstr ""
"Сигнал отправляется только когда процесс находится в рабочем состоянии "
"согласно информации, доступной на текущей итерации цикла событий. (Здесь "
"есть слабое место: сигнал может быть отправлен зомби-процессу, но это не "
"представляет никакой угрозы)."

msgid ""
"The signal is sent to a process or a process group depending on "
"``opts.group_signal``. (See :ref:`popen.new() <popen-new>` for details of "
"group signaling)."
msgstr ""
"Сигнал отправляется процессу или группе процессов в зависимости от "
"``opts.group_signal``. (Для подробной информации о групповых сигналах "
"смотрите :ref:`popen.new() <popen-new>`)."

msgid ""
"Resources are released regardless whether or not a signal sending succeeds: "
"fds are closed, memory is released, the handle is marked as closed."
msgstr ""
"Ресурсы освобождаются вне зависимости от того, успешно ли отправился сигнал:"
" дескрипторы файлов закрываются, память освобождается, а дескриптор popen "
"помечается как закрытый."

msgid ""
"No operation is possible on a closed handle except ``close()``, which is "
"always successful on a closed handle (idempotence)."
msgstr ""
"Над закрытым дескриптором невозможно выполнять никакие операции кроме "
"``close()``, которая всегда выполняется успешно над закрытым дескриптором "
"(идемпотентность)."

msgid ""
"``close()`` may return ``true`` or ``nil, err``, but it always frees the "
"handle resources. So any return value usually means success for a caller. "
"The return values are purely informational: they are for logging or some "
"kind of reporting."
msgstr ""
"``close()`` может вернуть ``true`` или ``nil, err``, но она всегда "
"освобождает ресурсы дескриптора. Поэтому для того, кто отправил сигнал, "
"любое возвращаемое значение означает успешное выполнение. Возвращаемые "
"значения только дают информацию для логирования или составления отчетов."

msgid "**Handle fields**"
msgstr "**Поля дескриптора**"

msgid ""
"popen_handle.pid\n"
"popen_handle.command\n"
"popen_handle.opts\n"
"popen_handle.status\n"
"popen_handle.stdin\n"
"popen_handle.stdout\n"
"popen_handle.stderr"
msgstr ""
"popen_handle.pid\n"
"popen_handle.command\n"
"popen_handle.opts\n"
"popen_handle.status\n"
"popen_handle.stdin\n"
"popen_handle.stdout\n"
"popen_handle.stderr"

msgid "See :ref:`popen_handle:info() <popen-info>` for details."
msgstr ""
"За более подробной информацией обратитесь к :ref:`popen_handle:info() "
"<popen-info>`."

msgid "**Module constants**"
msgstr "**Константы модуля**"

msgid ""
"- popen.opts\n"
"  - INHERIT (== 'inherit')\n"
"  - DEVNULL (== 'devnull')\n"
"  - CLOSE   (== 'close')\n"
"  - PIPE    (== 'pipe')\n"
"\n"
"- popen.signal\n"
"  - SIGTERM (== 9)\n"
"  - SIGKILL (== 15)\n"
"  - ...\n"
"\n"
"- popen.state\n"
"  - ALIVE    (== 'alive')\n"
"  - EXITED   (== 'exited')\n"
"  - SIGNALED (== 'signaled')\n"
"\n"
"- popen.stream\n"
"  - OPEN    (== 'open')\n"
"  - CLOSED  (== 'closed')"
msgstr ""
"- popen.opts\n"
"  - INHERIT (== 'inherit')\n"
"  - DEVNULL (== 'devnull')\n"
"  - CLOSE   (== 'close')\n"
"  - PIPE    (== 'pipe')\n"
"\n"
"- popen.signal\n"
"  - SIGTERM (== 9)\n"
"  - SIGKILL (== 15)\n"
"  - ...\n"
"\n"
"- popen.state\n"
"  - ALIVE    (== 'alive')\n"
"  - EXITED   (== 'exited')\n"
"  - SIGNALED (== 'signaled')\n"
"\n"
"- popen.stream\n"
"  - OPEN    (== 'open')\n"
"  - CLOSED  (== 'closed')"
