
msgid "Module `socket`"
msgstr "Модуль `socket`"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"The ``socket`` module allows exchanging data via BSD sockets with a local"
" or remote host in connection-oriented (TCP) or datagram-oriented (UDP) "
"mode. Semantics of the calls in the ``socket`` API closely follow "
"semantics of the corresponding POSIX calls."
msgstr ""
"Модуль ``socket`` позволяет обмениваться данными с локальным или "
"удаленным хостом по BSD-сокетам в режиме с установлением соединений (TCP)"
" или на основе датаграмм (UDP). Семантика вызовов в API модуля ``socket``"
" точно соответствует семантике соответствующих вызовов в POSIX."

msgid ""
"The functions for setting up and connecting are ``socket``, "
"``sysconnect``, ``tcp_connect``. The functions for sending data are "
"``send``, ``sendto``, ``write``, ``syswrite``. The functions for "
"receiving data are ``recv``, ``recvfrom``, ``read``. The functions for "
"waiting before sending/receiving data are ``wait``, ``readable``, "
"``writable``. The functions for setting flags are ``nonblock``, "
"``setsockopt``. The functions for stopping and disconnecting are "
"``shutdown``, ``close``. The functions for error checking are ``errno``, "
"``error``."
msgstr ""
"Функции для настройки и подключения: ``socket``, ``sysconnect``, "
"``tcp_connect``. Функции для отправки данных: ``send``, ``sendto``, "
"``write``, ``syswrite``. Функции для получения данных: ``recv``, "
"``recvfrom``, ``read``. Функции для ожидания отправки/получения данных: "
"``wait``, ``readable``, ``writable``. Функции для установки флагов: "
"``nonblock``, ``setsockopt``. Функции для остановки и отключения: "
"``shutdown``, ``close``. Функции для проверки ошибок: ``errno``, "
"``error``."

msgid "Index"
msgstr "Указатель"

msgid "Below is a list of all ``socket`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``socket``."

msgid "Name"
msgstr "Имя"

msgid "Use"
msgstr "Назначение"

msgid ":ref:`socket() <socket-socket>`"
msgstr ":ref:`socket() <socket-socket>`"

msgid "Create a socket"
msgstr "Создание сокета"

msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ":ref:`socket.tcp_connect() <socket-tcp_connect>`"

msgid "Connect a socket to a remote host"
msgstr "Подключение к удаленному хосту с помощью сокета"

msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"

msgid "Get information about a remote site"
msgstr "Получение информации об удаленном узле"

msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ":ref:`socket.tcp_server() <socket-tcp_server>`"

msgid "Make Tarantool act as a TCP server"
msgstr "Использование Tarantool'а в качестве TCP-сервера"

#, fuzzy
msgid ":ref:`socket.bind() <socket-bind_non_object>`"
msgstr ":ref:`socket_object:bind() <socket-bind>`"

msgid "Bind a socket to the given host/port"
msgstr "Привязка сокета к данному хосту/порту"

msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ":ref:`socket_object:sysconnect() <socket-sysconnect>`"

msgid ""
":ref:`socket_object:send() <socket-send>` |br| "
":ref:`socket_object:write() <socket-send>`"
msgstr ""
":ref:`socket_object:send() <socket-send>` |br| "
":ref:`socket_object:write() <socket-send>`"

msgid "Send data over a connected socket"
msgstr "Отправка данных по подключенному сокету"

msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ":ref:`socket_object:syswrite() <socket-syswrite>`"

msgid "Write data to the socket buffer if non-blocking"
msgstr "Запись данных в буфер сокета без блокировки"

msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ":ref:`socket_object:recv() <socket-recv>`"

msgid "Read from a connected socket"
msgstr "Чтение с подключенного сокета"

msgid ":ref:`socket_object:sysread() <socket-sysread>`"
msgstr ":ref:`socket_object:sysread() <socket-sysread>`"

msgid "Read data from the socket buffer if non-blocking"
msgstr "Чтение данных из буфера сокета без блокировки"

msgid ":ref:`socket_object:bind() <socket-bind>`"
msgstr ":ref:`socket_object:bind() <socket-bind>`"

msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ":ref:`socket_object:listen() <socket-listen>`"

msgid "Start listening for incoming connections"
msgstr "Начало прослушивания входящих соединений"

msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ":ref:`socket_object:accept() <socket-accept>`"

msgid "Accept a client connection + create a connected socket"
msgstr "Принятие запроса клиента на соединение + создание подключенного сокета"

msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ":ref:`socket_object:sendto() <socket-sendto>`"

msgid "Send a message on a UDP socket to a specified host"
msgstr "Отправка сообщения по UDP-сокету на указанный хост"

msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ":ref:`socket_object:recvfrom() <socket-recvfrom>`"

msgid "Receive a message on a UDP socket"
msgstr "Получение сообщения по UDP-сокету"

msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ":ref:`socket_object:shutdown() <socket-shutdown>`"

msgid "Shut down a reading end, a writing end, or both"
msgstr "Отключение передачи данных на чтение, на запись или в обоих направлениях"

msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ":ref:`socket_object:close() <socket-close>`"

msgid "Close a socket"
msgstr "Закрытие сокета"

msgid ""
":ref:`socket_object:error() <socket-error>` |br| "
":ref:`socket_object:errno() <socket-error>`"
msgstr ""
":ref:`socket_object:error() <socket-error>` |br| "
":ref:`socket_object:errno() <socket-error>`"

msgid "Get information about the last error on a socket"
msgstr "Получение информации о последней ошибке на сокете"

msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ":ref:`socket_object:setsockopt() <socket-setsockopt>`"

msgid "Set socket flags"
msgstr "Определение флагов сокета"

msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ":ref:`socket_object:getsockopt() <socket-getsockopt>`"

msgid "Get socket flags"
msgstr "Получение флагов сокета"

msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ":ref:`socket_object:linger() <socket-linger>`"

msgid "Set/clear the SO_LINGER flag"
msgstr "Установить/убрать флаг SO_LINGER"

msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ":ref:`socket_object:nonblock() <socket-nonblock>`"

msgid "Set/get the flag value"
msgstr "Определить/получить значение флага"

msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ":ref:`socket_object:readable() <socket-readable>`"

msgid "Wait until something is readable"
msgstr "Ожидание доступности чего-либо для чтения"

msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ":ref:`socket_object:writable() <socket-writable>`"

msgid "Wait until something is writable"
msgstr "Ожидание доступности чего-либо для записи"

msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ":ref:`socket_object:wait() <socket-wait>`"

msgid "Wait until something is either readable or writable"
msgstr "Ожидание доступности чего-либо для чтения или записи"

msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ":ref:`socket_object:name() <socket-name>`"

msgid "Get information about the connection's near side"
msgstr "Получение информации о ближней стороне соединения"

msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ":ref:`socket_object:peer() <socket-peer>`"

msgid "Get information about the connection's far side"
msgstr "Получение информации о дальней стороне соединения"

msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ":ref:`socket.iowait() <socket-iowait>`"

msgid "Wait for read/write activity"
msgstr "Ожидание активности чтения/записи"

msgid ":ref:`LuaSocket wrapper functions <socket-luasocket>`"
msgstr ""

msgid "Several methods for emulating the LuaSocket API"
msgstr "Несколько методов эмуляции LuaSocket API"

msgid ""
"Typically a socket session will begin with the setup functions, will set "
"one or more flags, will have a loop with sending and receiving functions,"
" will end with the teardown functions -- as an example at the end of this"
" section will show. Throughout, there may be error-checking and waiting "
"functions for synchronization. To prevent a fiber containing socket "
"functions from \"blocking\" other fibers, the :ref:`implicit yield rules "
"<atomic-implicit-yields>` will cause a yield so that other processes may "
"take over, as is the norm for :ref:`cooperative multitasking <atomic-"
"cooperative_multitasking>`."
msgstr ""
"Как правило, сессия сокета начинается с функций настройки, определяет "
"один или более флагов, запустит цикл с функциями отправки и получения и "
"закончится функциями завершения -- как в примере в конце данного раздела."
" В течение сессии может быть проверка на ошибки и ожидание синхронизации "
"функции. Чтобы файбер с сокетом не блокировал другие файберы, "
":ref:`правила неявной передачи управления <atomic-implicit-yields>` "
"заставят его передать управление другим процессам в рамках "
":ref:`кооперативной многозадачности <atomic-cooperative_multitasking>`."

msgid ""
"For all examples in this section the socket name will be sock and the "
"function invocations will look like ``sock:function_name(...)``."
msgstr ""
"Для всех примеров в данном разделе имя сокета будет sock, а вызов функции"
" будет выглядеть как ``sock:имя_функции(...)``."

msgid ""
"Create a new TCP or UDP socket. The argument values are the same as in "
"the `Linux socket(2) man page <http://man7.org/linux/man-"
"pages/man2/socket.2.html>`_."
msgstr ""
"Создание нового TCP-сокета или UDP-сокета. Значения аргумента остаются "
"теми же, что и на `странице socket(2) руководства по Linux "
"<http://man7.org/linux/man-pages/man2/socket.2.html>`_."

msgid "return"
msgstr "возвращает"

msgid "an unconnected socket, or nil."
msgstr "неподключенный сокет или nil."

msgid "rtype"
msgstr "тип возвращаемого значения"

msgid "userdata"
msgstr "пользовательские данные"

msgid "**Example:**"
msgstr "**Пример:**"

msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr "socket('AF_INET', 'SOCK_STREAM', 'tcp')"

msgid "Connect a socket to a remote host."
msgstr "Подключение к удаленному хосту с помощью сокета."

msgid "Parameters"
msgstr "Параметры"

msgid "URL or IP address"
msgstr "URL или IP-адрес"

msgid "port number"
msgstr "номер порта"

msgid "timeout"
msgstr "время ожидания"

msgid "(if error) {nil, error-message-string}. (if no error) a new socket object."
msgstr ""

msgid "socket object, which may be viewed as a table"
msgstr ""

#, fuzzy
msgid ""
"sock, e = socket.tcp_connect('127.0.0.1', 3301)\n"
"if sock == nil then print(e) end"
msgstr "socket.tcp_connect('127.0.0.1', 3301)"

msgid ""
"The ``socket.getaddrinfo()`` function is useful for finding information "
"about a remote site so that the correct arguments for "
"``sock:sysconnect()`` can be passed. This function may use the "
":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>` configuration "
"parameter."
msgstr ""
"Функция ``socket.getaddrinfo()`` используется для поиска информации об "
"удаленном узле, чтобы можно было передать правильные аргументы для "
"``sock:sysconnect()``. Эта функция может использовать конфигурационный "
"параметр :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`."

msgid "port number or a string pointing to a port"
msgstr "номер порта или строка, указывающая на порт"

msgid "maximum number of seconds to wait"
msgstr "количество секунд ожидания"

msgid ""
"* ``type`` -- preferred socket type * ``family`` -- desired address "
"family for the   returned addresses * ``protocol`` * ``flags`` -- "
"additional options (see details `here <https://man7.org/linux/man-"
"pages/man3/getaddrinfo.3.html>`_)"
msgstr ""

msgid "``type`` -- preferred socket type"
msgstr "``type`` -- предпочтительный тип сокета"

msgid "``family`` -- desired address family for the returned addresses"
msgstr "``family`` -- предпочтительное семейство адресов"

msgid "``protocol``"
msgstr "``protocol``"

msgid ""
"``flags`` -- additional options (see details `here "
"<https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>`_)"
msgstr ""
"``flags`` -- дополнительные опции (подробнее о них `здесь "
"<https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>`_)"

#, fuzzy
msgid ""
"(if error) {nil, error-message-string}. (if no error) A table containing "
"these fields: \"host\", \"family\", \"type\", \"protocol\", \"port\"."
msgstr ""
"Таблица со следующими полями: \"host\", \"family\", \"type\", "
"\"protocol\", \"port\"."

msgid "table"
msgstr "таблица"

msgid ""
"tarantool> socket.getaddrinfo('tarantool.org', 'http')\n"
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"...\n"
"-- To find the available values for the options use the following:\n"
"tarantool> socket.internal.AI_FLAGS -- or SO_TYPE, or DOMAIN\n"
"---\n"
"- AI_ALL: 256\n"
"  AI_PASSIVE: 1\n"
"  AI_NUMERICSERV: 4096\n"
"  AI_NUMERICHOST: 4\n"
"  AI_V4MAPPED: 2048\n"
"  AI_ADDRCONFIG: 1024\n"
"  AI_CANONNAME: 2\n"
"..."
msgstr ""

msgid ""
"The ``socket.tcp_server()`` function makes Tarantool act as a server that"
" can accept connections. Usually the same objective is accomplished with "
":ref:`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""
"Функция ``socket.tcp_server()`` заставляет Tarantool выступать в качестве"
" сервера для принятия подключений. Обычно для этой же цели используется "
":ref:`box.cfg{listen=...} <cfg_basic-listen>`."

msgid "host name or IP"
msgstr "имя или IP хоста"

msgid "host port, may be 0"
msgstr "порт хоста, может быть 0"

msgid "what to execute when a connection occurs"
msgstr "что выполнить после подключения"

msgid "number of seconds to wait before timing out"
msgstr "количество секунд ожидания"

msgid ""
"The handler-function-or-table parameter may be simply a function name / "
"function declaration: :code:`handler_function`. Or it may be a table: "
":code:`{handler =` :samp:`{handler_function} [, prepare = "
"{prepare_function}] [, name = {name}]` :code:`}`. ``handler_function`` is"
" mandatory; it may have a parameter = the socket; it is executed once "
"after accept() happens (once per connection); it is for continuous "
"operation after the connection is made. ``prepare_function`` is optional;"
" it may have parameters = the socket object and a table with client "
"information; it should return either a backlog value or nothing; it is "
"executed only once before bind() on the listening socket (not once per "
"connection). Examples:"
msgstr ""
"Параметр handler-function-or-table может представлять собой просто имя "
"функции или объявление функции: :code:`handler_function`. Или же может "
"быть таблицей: :code:`{handler =` :samp:`{handler_function} [, prepare = "
"{prepare_function}] [, name = {name}]` :code:`}`. Функция "
"``handler_function`` является обязательной, в ней может быть только один "
"параметр = сокет (используется для непрерывной работы после установки "
"соединения), выполняется  один раз за соединение после того, как "
"произойдет accept(). Функция ``prepare_function`` необязательна; она "
"выполняется однократно перед установкой соединения (``bind()``) на "
"слушающем сокете и должна возвращать либо значение бэклога, либо ничего. "
"Например:"

msgid ""
"socket.tcp_server('localhost', 3302, function (s) loop_loop() end)\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, name='name'})\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, prepare=pfunc})"
msgstr ""
"socket.tcp_server('localhost', 3302, function (s) loop_loop() end)\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, name='name'})\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, prepare=pfunc})"

msgid ""
"For fuller examples see :ref:`Use tcp_server to accept file contents sent"
" with socat <socket_socat>` and :ref:`Use tcp_server with handler and "
"prepare <socket_handler_prepare>`."
msgstr ""
"Более полный пример см. в разделе :ref:`Использование tcp_server для "
"получения содержимого файла, отправленного по socat <socket_socat>` и "
":ref:`Использование tcp_server с handler и prepare "
"<socket_handler_prepare>`."

msgid ""
"Bind a socket to the given host/port. This is equivalent to "
":ref:`socket_object:bind() <socket-bind>`, but is done on the result of "
"``require('socket')``, rather than on the socket object."
msgstr ""

msgid ""
"(if error) {nil, error-message-string}. (if no error) A table which may "
"have information about the bind result."
msgstr ""

msgid ""
"Connect an existing socket to a remote host. The argument values are the "
"same as in :ref:`tcp_connect() <socket-tcp_connect>`. The host must be an"
" IP address."
msgstr ""
"Подключение к удаленному хосту с помощью существующего сокета. Значения "
"аргументов будут такие же, как в :ref:`tcp_connect() <socket-"
"tcp_connect>`. Хост должен представлять собой IP-адрес."

msgid "Parameters:"
msgstr "Параметры:"

msgid "Either:"
msgstr "Либо:"

msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr "host -- строковое представление IPv4 адреса или IPv6 адреса;"

msgid "port - a number."
msgstr "port -- число."

msgid "Or:"
msgstr "Либо:"

msgid "host - a string containing \"unix/\";"
msgstr "host -- строка, которая содержит \"unix/\";"

msgid "port - a string containing a path to a unix socket."
msgstr "port -- строка, которая содержит путь к Unix-сокету."

msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr "host -- число, 0 (ноль), что означает \"все локальные интерфейсы\";"

msgid ""
"port - a number. If a port number is 0 (zero), the socket will be bound "
"to a random local port."
msgstr ""
"port -- число. Если номер порта -- 0 (ноль), сокет будет привязан к "
"случайному локальному порту."

msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""
"значение объекта сокета может изменяться, если будет выполнена функция "
"sysconnect()."

msgid "boolean"
msgstr "boolean (логический)"

msgid ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"

msgid "Send data over a connected socket."
msgstr "Отправка данных по подключенному сокету."

msgid "what is to be sent"
msgstr "что отправляется"

msgid "the number of bytes sent."
msgstr "количество отправляемых байтов."

msgid "number"
msgstr "число"

msgid "Possible errors: nil on error."
msgstr "Возможные ошибки: nil в случае ошибки."

msgid ""
"Write as much data as possible to the socket buffer if non-blocking. "
"Rarely used. For details see `this description`_."
msgstr ""
"Запись максимально возможного количества данных в буфер сокета без "
"блокировки. Используется редко. Для получения подробной информации см. "
"`описание <https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."

msgid ""
"Read ``size`` bytes from a connected socket. An internal read-ahead "
"buffer is used to reduce the cost of this call."
msgstr ""
"Чтение количества байтов, определенного в ``size``, из подключенного "
"сокета. Внутренний буфер опережающего считывания используется для "
"уменьшения использования ресурсов на вызов."

msgid ""
"maximum number of bytes to receive. See :ref:`Recommended size <socket-"
"recommended>`."
msgstr ""
"максимальное количество получаемых байтов. См. :ref:`Рекомендованный "
"размер <socket-recommended>`."

msgid "a string of the requested length on success."
msgstr "строка запрошенной длины, если выполнено."

msgid "string"
msgstr "строка"

msgid ""
"Possible errors: On error, returns an empty string, followed by status, "
"errno, errstr. In case the writing side has closed its end, returns the "
"remainder read from the socket (possibly an empty string), followed by "
"\"eof\" status."
msgstr ""
"Возможные ошибки: В случае ошибки возвращается пустая строка, после чего "
"статус, errno, errstr. Если передача данных на запись закрыта с другой "
"стороны, возвращаются оставшиеся для чтения данные из сокета (возможно, "
"пустая строка), после чего идет статус \"eof\" (конец файла)."

msgid ""
"Read from a connected socket until some condition is true, and return the"
" bytes that were read. Reading goes on until ``limit`` bytes have been "
"read, or a delimiter has been read, or a timeout has expired. Unlike "
"``socket_object:recv`` (which uses an internal read-ahead buffer), "
"``socket_object:read`` depends on the socket's buffer."
msgstr ""
"Чтение данных из подключенного сокета до выполнения какого-либо условия и"
" возврат прочтенных байтов. Производится чтения количества байтов, "
"которое указано в параметре ``limit``, либо до символа-разделителя, либо "
"до истечения времени ожидания. В отличие от ``socket_object:recv`` (где "
"используется внутренний буфер опережающего считывания), "
"``socket_object:read`` зависит от буфера сокета."

msgid ""
"maximum number of bytes to read, for example 50 means \"stop after 50 "
"bytes\""
msgstr ""
"максимальное количество байтов для чтения, например, 50 означает "
"\"остановиться на 50 байтах\""

msgid "separator for example '?' means \"stop after a question mark\""
msgstr "разделитель, например, '?' означает \"остановиться после знака вопроса\""

msgid ""
"maximum number of seconds to wait, for example 50 means \"stop after 50 "
"seconds\"."
msgstr ""
"максимальное количество секунд ожидания, например, 50 означает "
"\"остановиться через 50 секунд\"."

msgid ""
":samp:`chunk={limit}` and/or :samp:`delimiter={delimiter}`, for example "
":code:`{chunk=5,delimiter='x'}`."
msgstr ""
":samp:`chunk={предел}` и/или :samp:`delimiter={разделитель}`, например, "
":code:`{chunk=5,delimiter='x'}`."

msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``limit`` bytes long, which may include the "
"bytes that matched the ``delimiter`` expression."
msgstr ""
"пустая строка, если нет данных для чтения, либо нулевое значение nil в "
"случае ошибки, либо строка, ограниченная количеством байтов в ``limit``, "
"которая может включать в себя байты, совпадающие с выражением "
"``delimiter``."

msgid ""
"Return data from the socket buffer if non-blocking. In case the socket is"
" blocking, ``sysread()`` can block the calling process. Rarely used. For "
"details, see also `this description "
"<https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."
msgstr ""
"Возврат данных из буфера сокета без блокировки.Если сокет с блокировкой, "
"``sysread()`` может блокировать процесс вызова. Используется редко. Для "
"получения подробной информации, см. `описание  "
"<https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."

msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``size`` bytes long."
msgstr ""
"пустая строка, если нет данных для чтения, либо нулевое значение nil в "
"случае ошибки, либо строка, ограниченная количеством байтов в ``size``."

msgid ""
"Bind a socket to the given host/port. A UDP socket after binding can be "
"used to receive data (see :ref:`socket_object.recvfrom <socket-"
"recvfrom>`). A TCP socket can be used to accept new connections, after it"
" has been put in listen mode."
msgstr ""
"Привязка сокета к данному хосту/порту. UDP-сокет после привязки может "
"использоваться для получения данных (см. :ref:`socket_object.recvfrom "
"<socket-recvfrom>`). TCP-сокет может использоваться для принятия новых "
"соединений после перевода в режим прослушивания."

msgid ""
"true for success, false for error. If return is false, use "
":ref:`socket_object:errno() <socket-error>` or "
":ref:`socket_object:error() <socket-error>` to see details."
msgstr ""
"true (правда), если выполнено, false (ложь) в случае ошибки. Если "
"возвращается false, используйте :ref:`socket_object:errno() <socket-"
"error>` или :ref:`socket_object:error() <socket-error>` для получения "
"подробной информации."

msgid "Start listening for incoming connections."
msgstr "Начало прослушивания входящих соединений."

msgid ""
"on Linux the listen ``backlog`` backlog may be from "
"``/proc/sys/net/core/somaxconn``, on BSD the backlog may be "
"``SOMAXCONN``."
msgstr ""
"в Linux очередь запросов ``backlog`` может быть в "
"``/proc/sys/net/core/somaxconn``, в BSD очередь запросов может "
"представлять собой ``SOMAXCONN``."

msgid "true for success, false for error."
msgstr "true (правда), если выполнено, false (ложь) в случае ошибки."

msgid "boolean."
msgstr "boolean (логический)."

msgid ""
"Accept a new client connection and create a new connected socket. It is "
"good practice to set the socket's blocking mode explicitly after "
"accepting."
msgstr ""
"Принятие нового клиентского соединения и создание нового подключенного "
"сокета. Установка блокирующего режима на сокете явным образом после "
"принятия соединения приведет к эффективной работе."

msgid "new socket if success."
msgstr "новый сокет, если выполнено."

msgid "Possible errors: nil."
msgstr "Возможные ошибки: nil."

msgid "Send a message on a UDP socket to a specified host."
msgstr "Отправка сообщения по UDP-сокету на указанный хост."

msgid ""
"Possible errors: on error, returns nil and may return status, errno, "
"errstr."
msgstr ""
"Возможные ошибки: в случае ошибки возвращает nil, а также может вернуть "
"статус, errno, errstr."

msgid "Receive a message on a UDP socket."
msgstr "Получение сообщения по UDP-сокету."

msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr "сообщение, таблица с полями \"host\", \"family\" и \"port\"."

msgid "string, table"
msgstr "строка, таблица"

msgid "Possible errors: on error, returns status, errno, errstr."
msgstr "Возможные ошибки: в случае ошибки возвращает nil, статус, errno, errstr."

msgid ""
"After ``message_content, message_sender = recvfrom(1)`` the value of "
"``message_content`` might be a string containing 'X' and the value of "
"``message_sender`` might be a table containing"
msgstr ""
"После ``message_content, message_sender = recvfrom(1)`` значением "
"``message_content`` может быть строка, которая содержит 'X', а значением "
"``message_sender`` может быть таблица, которая содержит"

msgid ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"

msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr "Отключение передачи данных на чтение, на запись или в обоих направлениях."

msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."

msgid "true or false."
msgstr "true (правда) или false (ложь)."

msgid ""
"Close (destroy) a socket. A closed socket should not be used any more. A "
"socket is closed automatically when the Lua garbage collector removes its"
" user data."
msgstr ""
"Закрытие (удаление) сокета. Закрытый сокет больше не должен "
"использоваться. Сокет будет закрыт автоматически, когда сборщик мусора "
"Lua удалит данные."

msgid ""
"true on success, false on error. For example, if sock is already closed, "
"sock:close() returns false."
msgstr ""
"true (правда), если выполнено, false (ложь) в случае ошибки. Например, "
"если сокет sock уже закрыт, sock:close() вернет false."

msgid ""
"Retrieve information about the last error that occurred on a socket, if "
"any. Errors do not cause throwing of exceptions so these functions are "
"usually necessary."
msgstr ""
"Получение информации о последней ошибке на сокете, если таковая была. "
"Ошибки не выдают исключения, поэтому данные функции необходимы."

msgid ""
"result for ``sock:errno()``, result for ``sock:error()``. If there is no "
"error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""
"результат ``sock:errno()``, результат ``sock:error()``. Если ошибки нет, "
"то ``sock:errno()`` вернет 0 и ``sock:error()``."

msgid "number, string"
msgstr "число, строка"

msgid ""
"Set socket flags. The argument values are the same as in the `Linux "
"getsockopt(2) man page <http://man7.org/linux/man-"
"pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""
"Определение флагов сокета. Значения аргумента будут такими же, что и на "
"`странице getsockopt(2) руководства по Linux <http://man7.org/linux/man-"
"pages/man2/setsockopt.2.html>`_. Tarantool принимает следующие:"

msgid "SO_ACCEPTCONN"
msgstr "SO_ACCEPTCONN"

msgid "SO_BINDTODEVICE"
msgstr "SO_BINDTODEVICE"

msgid "SO_BROADCAST"
msgstr "SO_BROADCAST"

msgid "SO_DEBUG"
msgstr "SO_DEBUG"

msgid "SO_DOMAIN"
msgstr "SO_DOMAIN"

msgid "SO_ERROR"
msgstr "SO_ERROR"

msgid "SO_DONTROUTE"
msgstr "SO_DONTROUTE"

msgid "SO_KEEPALIVE"
msgstr "SO_KEEPALIVE"

msgid "SO_MARK"
msgstr "SO_MARK"

msgid "SO_OOBINLINE"
msgstr "SO_OOBINLINE"

msgid "SO_PASSCRED"
msgstr "SO_PASSCRED"

msgid "SO_PEERCRED"
msgstr "SO_PEERCRED"

msgid "SO_PRIORITY"
msgstr "SO_PRIORITY"

msgid "SO_PROTOCOL"
msgstr "SO_PROTOCOL"

msgid "SO_RCVBUF"
msgstr "SO_RCVBUF"

msgid "SO_RCVBUFFORCE"
msgstr "SO_RCVBUFFORCE"

msgid "SO_RCVLOWAT"
msgstr "SO_RCVLOWAT"

msgid "SO_SNDLOWAT"
msgstr "SO_SNDLOWAT"

msgid "SO_RCVTIMEO"
msgstr "SO_RCVTIMEO"

msgid "SO_SNDTIMEO"
msgstr "SO_SNDTIMEO"

msgid "SO_REUSEADDR"
msgstr "SO_REUSEADDR"

msgid "SO_SNDBUF"
msgstr "SO_SNDBUF"

msgid "SO_SNDBUFFORCE"
msgstr "SO_SNDBUFFORCE"

msgid "SO_TIMESTAMP"
msgstr "SO_TIMESTAMP"

msgid "SO_TYPE"
msgstr "SO_TYPE"

msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""
"Установка флага SO_LINGER осуществляется с помощью "
"``sock:linger(active)``."

msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""
"Получение флагов сокета. Список возможных флагов см. с помощью "
"``sock:setsockopt()``."

msgid ""
"Set or clear the SO_LINGER flag. For a description of the flag, see the "
"`Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""
"Установить или убрать флаг SO_LINGER. Описание флага см. в `руководстве "
"по Linux <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."

msgid "new active and timeout values."
msgstr "новые значения active и timeout."

msgid "``sock:nonblock()`` returns the current flag value."
msgstr "``sock:nonblock()`` возвращает текущее значение флага."

msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr "``sock:nonblock(false)`` устанавливает флаг на false и возвращает false."

msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr "``sock:nonblock(true)`` устанавливает флаг на true и возвращает true."

msgid ""
"This function may be useful before invoking a function which might "
"otherwise block indefinitely."
msgstr ""
"Эту функцию можно использовать до вызова функции, которая в противном "
"случае будет блокировать бесконечно."

msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""
"Ожидание доступности чего-либо для чтения или до истечения времени "
"ожидания."

msgid "true if the socket is now readable, false if timeout expired;"
msgstr "true, если сокет доступен для чтения, false, если истекло время ожидания;"

msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""
"Ожидание доступности чего-либо для записи или до истечения времени "
"ожидания."

msgid "true if the socket is now writable, false if timeout expired;"
msgstr "true, если сокет доступен для записи, false, если истекло время ожидания;"

msgid ""
"Wait until something is either readable or writable, or until a timeout "
"value expires."
msgstr ""
"Ожидание доступности чего-либо для чтения или записи, или до истечения "
"времени ожидания."

msgid ""
"'R' if the socket is now readable, 'W' if the socket is now writable, "
"'RW' if the socket is now both readable and writable, '' (empty string) "
"if timeout expired;"
msgstr ""
"'R', если сокет доступен для чтения, 'W', если сокет доступен для записи,"
" 'RW', если сокет доступен и для чтения, и для записи, '' (пустая "
"строка), если истекло время ожидания;"

msgid ""
"The ``sock:name()`` function is used to get information about the near "
"side of the connection. If a socket was bound to ``xyz.com:45``, then "
"``sock:name`` will return information about ``[host:xyz.com, port:45]``. "
"The equivalent POSIX function is ``getsockname()``."
msgstr ""
"Функция ``sock:name()`` используется для получения информации о ближней "
"стороне соединения. Если сокет привязан к ``xyz.com:45``, то "
"``sock:name`` вернет информацию о ``[host:xyz.com, port:45]``. "
"Аналогичная функция в POSIX -- ``getsockname()``."

msgid ""
"A table containing these fields: \"host\", \"family\", \"type\", "
"\"protocol\", \"port\"."
msgstr ""
"Таблица со следующими полями: \"host\", \"family\", \"type\", "
"\"protocol\", \"port\"."

msgid ""
"The ``sock:peer()`` function is used to get information about the far "
"side of a connection. If a TCP connection has been made to a distant host"
" ``tarantool.org:80``, ``sock:peer()`` will return information about "
"``[host:tarantool.org, port:80]``. The equivalent POSIX function is "
"``getpeername()``."
msgstr ""
"Функция ``sock:peer()`` используется для получения информации о дальней "
"стороне соединения. Если TCP-соединение установлено с удаленным хостом "
"``tarantool.org:80``, то ``sock:peer()`` вернет информацию о "
"``[host:tarantool.org, port:80]``. Аналогичная функция в POSIX --  "
"``getpeername()``."

msgid ""
"The ``socket.iowait()`` function is used to wait until read-or-write "
"activity occurs for a file descriptor."
msgstr ""
"Функция ``socket.iowait()`` используется для ожидания, пока дескриптор "
"файла не будет активен для чтения или записи."

msgid "file descriptor"
msgstr "дескриптор файла"

msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr "'R' или 1 = чтение, 'W' или 2 = запись, 'RW' или 3 = чтение|запись."

msgid "number of seconds to wait"
msgstr "количество секунд ожидания"

msgid ""
"If the fd parameter is nil, then there will be a sleep until the timeout."
" If the timeout parameter is nil or unspecified, then timeout is "
"infinite."
msgstr ""
"Если значение параметра fd -- nil, то будет режим ожидания до истечения "
"времени, указанного в параметре timeout. Если timeout -- nil или не "
"указан, время ожидания считается бесконечным."

msgid ""
"Ordinarily the return value is the activity that occurred ('R' or 'W' or "
"'RW' or 1 or 2 or 3). If the timeout period goes by without any reading "
"or writing, the return is an error = ETIMEDOUT."
msgstr ""
"Как правило, возвращается значение совершенного действия ('R' или 'W', "
"или 'RW', или 1, или 2, или 3). Если время ожидания в timeout проходит "
"без действий чтения или записи, возвращается ошибка = ETIMEDOUT."

msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr "Пример: ``socket.iowait(sock:fd(), 'r', 1.11)``"

msgid "LuaSocket wrapper functions"
msgstr "Функции обертки LuaSocket"

#, fuzzy
msgid ""
"The LuaSocket API has functions that are equivalent to the ones described"
" above, with different names and parameters, for example ``connect()`` "
"rather than ``tcp_connect()``. Tarantool supports these functions so that"
" third-party packages which depend on them will work."
msgstr ""
"LuaSocket API имеет функции, эквивалентные описанным выше, с различными "
"именами и параметрами, например ``connect()``, а не ``tcp_connect()``, а "
"также ``getpeername``, ``getsockname``, ``setoption``, ``settimeout``. "
"Tarantool поддерживает эти функции, так что сторонние пакеты, зависящие "
"от них, будут работать."

msgid ""
"The LuaSocket project is on `github "
"<https://github.com/diegonehab/luasocket>`_. The API description is in "
"the `LuaSocket manual <http://w3.impa.br/~diego/software/luasocket/>`_ "
"(click the \"introduction\" and \"reference\" links at the bottom of the "
"manual's main page)."
msgstr ""
"Проект LuaSocket находится на `github "
"<https://github.com/diegonehab/luasocket>`_. Описание API находится в "
"`руководстве по LuaSocket "
"<http://w3.impa.br/~diego/software/luasocket/>`_ (нажмите на ссылки "
"\"введение\" и \"ссылка\" внизу главной страницы руководства)."

msgid ""
"A Tarantool example is :ref:`Use of a socket with LuaSocket wrapper "
"functions <socket-wrapper>`."
msgstr ""
"Пример для Tarantool - :ref:`Использование сокета с функциями обертки "
"LuaSocket <socket-wrapper>`."

msgid "Recommended size"
msgstr "Рекомендованный размер"

msgid ""
"For ``recv`` and ``recvfrom``: use the optional ``size`` parameter to "
"limit the number of bytes to receive. A fixed size such as 512 is often "
"reasonable; a pre-calculated size that depends on context -- such as the "
"message format or the state of the network -- is often better. For "
"``recvfrom``, be aware that a size greater than the `Maximum Transmission"
" Unit <https://en.wikipedia.org/wiki/Maximum_transmission_unit>`_ can "
"cause inefficient transport. For Mac OS X, be aware that the size can be "
"tuned by changing ``sysctl net.inet.udp.maxdgram``."
msgstr ""
"Для ``recv`` и ``recvfrom``: используйте необязательный параметр "
"``size``, чтобы ограничить количество получаемых байтов. Часто "
"используется заданный размер, такой как 512; но во многих случаях лучше "
"использовать предварительно рассчитанный размер, который зависит от "
"контекста -- как формат сообщения или состояние сети. Что касается "
"``recvfrom``, следует помнить, что размер больше максимального размера "
"полезного блока данных одного пакета (`Maximum Transmission Unit "
"<https://en.wikipedia.org/wiki/Maximum_transmission_unit>`_) может "
"вызвать низкоэффективную передачу данных. Что касается Mac OS X, следует "
"отметить, что размер можно настроить с помощью ``sysctl "
"net.inet.udp.maxdgram``."

msgid ""
"If ``size`` is not stated: Tarantool will make an extra call to calculate"
" how many bytes are necessary. This extra call takes time, therefore not "
"stating ``size`` may be inefficient."
msgstr ""
"Если размер ``size`` не задан: Tarantool сделает дополнительный вызов для"
" расчет необходимого количества байтов. Такой дополнительный вызов "
"занимает время, поэтому во избежание низкой эффективности лучше указать "
"``size``."

msgid ""
"If ``size`` is stated: on a UDP socket, excess bytes are discarded. On a "
"TCP socket, excess bytes are not discarded and can be received by the "
"next call."
msgstr ""
"Если размер ``size`` задан: в UDP-сокете лишние байты отбрасываются; в "
"TCP-сокете лишние байты не отбрасываются, их можно получить при следующем"
" вызове."

msgid "Examples"
msgstr "Примеры"

msgid "Use of a TCP socket over the Internet"
msgstr "Использование TCP-сокета в интернете"

msgid ""
"In this example a connection is made over the internet between a "
"Tarantool instance and tarantool.org, then an HTTP \"head\" message is "
"sent, and a response is received: \"``HTTP/1.1 200 OK``\" or something "
"else if the site has moved. This is not a useful way to communicate with "
"this particular site, but shows that the system works."
msgstr ""
"В данном примере устанавливается соединение по интернету между "
"экземпляром Tarantool'а и tarantool.org, затем отправляется "
"HTTP-сообщение заголовка \"head\" и возвращается ответ: \"``HTTP/1.1 200 "
"OK``\" или что-то другое, если сайт перемещен. Так не слишком удобно "
"взаимодействовать с определенным сайтом, но пример показывает работу "
"системы."

msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: "
"tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: "
"tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."

msgid "Use of a socket with LuaSocket wrapper functions"
msgstr "Использование сокета с функциями обертки LuaSocket"

msgid ""
"This is a variation of the earlier example \"Use of a TCP socket over the"
" Internet\". It uses :ref:`LuaSocket wrapper functions <socket-"
"luasocket>`, with a too-short timeout so that a \"Connection timed out\" "
"error is likely. The more common way to specify timeout is with an option"
" of :ref:`tcp_connect() <socket-tcp_connect>`."
msgstr ""
"Это вариант более раннего примера \"Использование TCP-подключения через "
"Интернет\". В нем используются :ref:`функции обертки LuaSocket <socket-"
"luasocket>`, с слишком коротким временем ожидания, так что, скорее всего,"
" произойдет ошибка \"Connection timed out\" (Таймаут соединения). Более "
"распространенным способом определения таймаута является использование "
"функции :ref:`tcp_connect() <socket-tcp_connect>`."

msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> sock:settimeout(0.001)\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: "
"tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:receive(17)\n"
"---\n"
"- null\n"
"- Connection timed out\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- 1\n"
"..."
msgstr ""

msgid "Use of a UDP socket on localhost"
msgstr "Использование UDP-сокета на localhost"

msgid ""
"Here is an example with datagrams. Set up two connections on 127.0.0.1 "
"(localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message "
"to ``sock_1``. Using ``sock_1``, receive a message. Display the received "
"message. Close both connections. |br| This is not a useful way for a "
"computer to communicate with itself, but shows that the system works."
msgstr ""
"Ниже приведен пример с датаграммами. Устанавливается два соединения с "
"127.0.0.1 (localhost): ``sock_1`` и ``sock_2``. С помощью ``sock_2`` "
"отправляется сообщение на ``sock_1``. С помощью ``sock_1`` получается "
"сообщение. Отображается полученное сообщение. Оба соединения закрываются."
" |br| Компьютеру так не слишком удобно взаимодействовать с самим собой, "
"но пример показывает работу системы."

msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> message = sock_1:recvfrom(512)\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> message = sock_1:recvfrom(512)\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."

msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""
"Использование tcp_server для получения содержимого файла, отправленного "
"по socat"

msgid ""
"Here is an example of the tcp_server function, reading strings from the "
"client and printing them. On the client side, the Linux socat utility "
"will be used to ship a whole file for the tcp_server function to read."
msgstr ""
"Ниже приведен пример функции ``tcp_server``, которая читает строки с "
"клиента и выводит результат. На клиентской стороне утилита ``socat`` в "
"Linux будет использоваться для отправки целого файла на чтение функции "
"``tcp_server``."

msgid ""
"Start two shells. The first shell will be a server instance. The second "
"shell will be the client."
msgstr ""
"Запустите две оболочки. Первая оболочка будет экземпляром сервера. Вторая"
" оболочка будет клиентом."

msgid "On the first shell, start Tarantool and say:"
msgstr "В первой оболочке запустите Tarantool и выполните:"

msgid ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302,\n"
"{\n"
"  handler = function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end,\n"
"  prepare = function()\n"
"    print('Initialized')\n"
"  end\n"
"}\n"
")"
msgstr ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302,\n"
"{\n"
"  handler = function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end,\n"
"  prepare = function()\n"
"    print('Initialized')\n"
"  end\n"
"}\n"
")"

msgid "The above code means:"
msgstr "Вышеуказанный код означает:"

msgid "Use ``tcp_server()`` to wait for a connection from any host on port 3302."
msgstr ""
"Использовать ``tcp_server()`` для ожидания подключения с любого хоста по "
"порту 3302."

msgid ""
"When it happens, enter a loop that reads on the socket and prints what it"
" reads. The \"delimiter\" for the read function is \"\\\\n\" so each "
"``read()`` will read a string as far as the next line feed, including the"
" line feed."
msgstr ""
"Когда это произойдет, ввести цикл, который читает по сокету и выводит "
"результат чтения. Разделителем для функции чтения будет \"\\\\n\", "
"поэтому каждое выполнение ``read()`` выполнит чтение строки до перевода "
"строки, включая перевод строки."

msgid ""
"On the second shell, create a file that contains a few lines. The "
"contents don't matter. Suppose the first line contains A, the second line"
" contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""
"Во второй оболочке создайте файл, который содержит несколько строк. "
"Содержимое не имеет значения. Предположим, что первая строка содержит A, "
"вторая строка содержит B, третья строка содержит C. Назовите этот файл "
"\"tmp.txt\"."

msgid ""
"On the second shell, use the socat utility to ship the tmp.txt file to "
"the server instance's host and port:"
msgstr ""
"Во второй оболочке используйте утилиту socat для отправки файла tmp.txt "
"на экземпляр сервера по хосту и порту:"

msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr "$ socat TCP:localhost:3302 ./tmp.txt"

msgid ""
"Now watch what happens on the first shell. The strings \"A\", \"B\", "
"\"C\" are printed."
msgstr ""
"Теперь смотрите, что происходит в первой оболочке. Выводятся строки "
"\"A\", \"B\", \"C\"."

msgid "Use tcp_server with handler and prepare"
msgstr "Использование tcp_server с handler и prepare"

msgid ""
"Here is an example of the tcp_server function using ``handler`` and "
"``prepare``."
msgstr ""
"Ниже приведен пример функции tcp_server с использованием ``handler`` и "
"``prepare``."

msgid ""
"box.cfg{}\n"
"socket = require('socket')\n"
"sock = socket.tcp_server(\n"
"  '0.0.0.0',\n"
"  3302,\n"
"  {prepare =\n"
"     function(sock)\n"
"       print('listening on socket ' .. sock:fd())\n"
"       sock:setsockopt('SOL_SOCKET','SO_REUSEADDR',true)\n"
"       return 5\n"
"     end,\n"
"   handler =\n"
"    function(sock, from)\n"
"      print('accepted connection from: ')\n"
"      print('  host: ' .. from.host)\n"
"      print('  family: ' .. from.family)\n"
"      print('  port: ' .. from.port)\n"
"    end\n"
"  }\n"
")"
msgstr ""

msgid ""
"Specify that there will be an initial call to ``prepare`` which displays "
"something about the server, then calls "
"``setsockopt(...'SO_REUSEADDR'...)`` (this is the same option that "
"Tarantool would set if there was no ``prepare``), and then returns 5 "
"(this is a rather low backlog queue size)."
msgstr ""
"Указать, что будет первый вызов ``prepare``, который покажет что-то о "
"сервере, затем вызовет ``setsockopt(...'SO_REUSEADDR'...)`` (это та же "
"самая опция, которую Тарантул бы установил, если бы не было ``prepare``),"
" а затем вернет 5 (это довольно низкий размер очереди бэклога). "

msgid ""
"Specify that there will be per-connection calls to ``handler`` which "
"display something about the client."
msgstr ""
"Указать, что будут вызовы ``handler`` по каждому соединению, которые "
"будут отображать что-то о клиенте."

msgid ""
"Now watch what happens on the first shell. The display will include "
"something like 'listening on socket 12'."
msgstr ""
"Теперь смотрите, что происходит в первой оболочке. Выведется что-то вроде"
" 'listening on socket 12'."

msgid "On the second shell, start Tarantool and say:"
msgstr "Во второй оболочке запустите Tarantool и выполните:"

msgid ""
"box.cfg{}\n"
"require('socket').tcp_connect('127.0.0.1', 3302)"
msgstr ""

msgid ""
"Now watch what happens on the first shell. The display will include "
"something like 'accepted connection from host: 127.0.0.1 family: AF_INET "
"port: 37186'."
msgstr ""
"Теперь смотрите, что происходит на первой оболочке. На дисплее появится "
"что-то вроде 'accepted connection from host: 127.0.0.1 family: AF_INET "
"port: 37186'."

#~ msgid "a connected socket, if no error."
#~ msgstr "подключенный сокет, если нет ошибки."
