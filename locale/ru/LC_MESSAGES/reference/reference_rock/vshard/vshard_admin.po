
msgid "Administration"
msgstr "Администрирование"

msgid "Installation"
msgstr "Установка"

msgid ""
"The ``vshard`` module is distributed separately from the main Tarantool "
"package. To install it, say this:"
msgstr ""

msgid "$ tarantoolctl rocks install vshard"
msgstr "$ tarantoolctl rocks install vshard"

msgid ""
"The ``vshard`` module requires Tarantool version 1.9+, `Tarantool "
"development package "
"<https://www.tarantool.io/en/doc/1.10/tutorials/c_tutorial/#c-stored-"
"procedures>`_, ``git``, ``cmake`` and ``gcc`` packages installed."
msgstr ""

msgid "Configuration"
msgstr ""

msgid "Any viable sharded cluster consists of:"
msgstr ""

msgid ""
"one or more replica sets, each containing two or more :ref:`storage "
"<vshard-storage>` instances,"
msgstr ""

msgid "one or more :ref:`router <vshard-router>` instances."
msgstr ""

msgid ""
"The number of ``storage`` instances in a replica set defines the "
"redundancy factor of the data. The recommended value is 3 or more. The "
"number of ``router`` instances is not limited, because routers are "
"completely stateless. We recommend increasing the number of routers when "
"an existing ``router`` instance becomes CPU or I/O bound."
msgstr ""
"Количество хранилищ в наборе реплик определяет коэффициент избыточности "
"данных. Рекомендуемое значение: 3 или более. Количество роутеров не "
"ограничено, потому что у роутеров нет состояния. Рекомендуем увеличивать "
"количество роутеров, если существующий экземпляр роутера ограничен "
"возможностями процессора или ввода-вывода."

msgid ""
"``vshard`` supports multiple ``router`` instances on a single Tarantool "
"instance. Each ``router`` can be connected to any ``vshard`` cluster. "
"Multiple ``router`` instances can be connected to the same cluster."
msgstr ""
"``vshard`` поддерживает работу с несколькими роутерами в отдельном "
"экземпляре Tarantool'а. Каждый роутер может подключиться к любому "
"кластеру ``vshard``. Несколько роутеров могут быть подключены к одному "
"кластеру."

msgid ""
"As the ``router`` and ``storage`` applications perform completely "
"different sets of functions, they should be deployed to different "
"Tarantool instances. Although it is technically possible to place the "
"router application on every ``storage`` node, this approach is highly "
"discouraged and should be avoided on production deployments."
msgstr ""
"Поскольку приложения роутера (``router``) и хранилища (``storage``) "
"выполняют совершенно разные наборы функций, их следует разворачивать на "
"различных экземплярах Tarantool'а. Хотя технически возможно разместить "
"приложение роутера на каждом узле типа хранилища, такой подход крайне не "
"рекомендуется, и его следует избегать при развертывании в "
"производственной среде."

msgid ""
"All ``storage`` instances can be deployed using identical instance "
"(configuration) files."
msgstr ""
"Все хранилища можно развернуть, используя один набор файлов экземпляра "
"(конфигурационных файлов)."

msgid "Self-identification is currently performed using ``tarantoolctl``:"
msgstr ""
"Самоопределение в настоящий момент осуществляется с помощью "
"``tarantoolctl``:"

msgid "$ tarantoolctl instance_name"
msgstr "$ tarantoolctl имя_экземпляра"

msgid ""
"All ``router`` instances can also be deployed using identical instance "
"(configuration) files."
msgstr ""
"Все роутеры также можно развернуть, используя один набор файлов "
"экземпляра (конфигурационных файлов)."

msgid ""
"All cluster nodes must share a common topology. An administrator must "
"ensure that the configurations are identical. We suggest using a "
"configuration management tool like Ansible or Puppet to deploy the "
"cluster."
msgstr ""
"Топология всех узлов кластера должна быть одинаковой. Администратор "
"должен убедиться, что конфигурации совпадают. Рекомендуем использовать "
"инструмент управления конфигурациями, такой как Ansible или Puppet, во "
"время развертывания кластера."

msgid ""
"Sharding is not integrated into any system for centralized configuration "
"management. It is expected that the application itself is responsible for"
" interacting with such a system and passing the sharding parameters."
msgstr ""
"Шардинг не интегрирован ни в одну систему для централизованного "
"управления конфигурациями. Предполагается, что само приложение отвечает "
"за взаимодействие с такой системой и передачу параметров шардинга."

msgid ""
"The configuration example of a simple sharded cluster is available "
":ref:`here <vshard-config-cluster-example>`."
msgstr ""

msgid "Replica weights"
msgstr "Вес реплики"

msgid ""
"The ``router`` sends all read-write requests to the master instance only."
" Setting replica weights allows sending read-only requests not only to "
"the master instance, but to any available replica that is the 'nearest' "
"to the ``router``. Weights are used to define distances between replicas "
"within a replica set."
msgstr ""

msgid ""
"Weights can be used, for example, to define the physical distance between"
" the ``router`` and each replica in each replica set. In this case read "
"requests are sent to the nearest replica (with the lowest weight)."
msgstr ""

msgid ""
"Setting weights can also help to define the most powerful replicas: the "
"ones that can process the largest number of requests per second."
msgstr ""
"Кроме того, можно задать вес реплик, чтобы определить наиболее мощную "
"реплику, которая может обрабатывать наибольшее количество запросов в "
"секунду."

msgid ""
"The idea is to specify the zone for every ``router`` and every replica, "
"therefore filling a matrix of relative zone weights. This approach allows"
" setting different weights in different zones for the same replica set."
msgstr ""
"Основная идея состоит в том, чтобы указать зону для каждого ``роутера`` и"
" каждой реплики, и таким образом составить матрицу относительных весов "
"зоны. Этот подход позволяет устанавливать разный вес в разных зонах для "
"одного набора реплик."

msgid ""
"To set weights, use the zone attribute for each replica during "
"configuration:"
msgstr ""
"Чтобы задать вес, используйте атрибут zone (зона) для каждой реплики во "
"время конфигурации:"

msgid ""
"local cfg = {\n"
"   sharding = {\n"
"      ['...replicaset_uuid...'] = {\n"
"         replicas = {\n"
"            ['...replica_uuid...'] = {\n"
"                 ...,\n"
"                 zone = <number or string>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"
msgstr ""
"local cfg = {\n"
"   sharding = {\n"
"      ['...uuid_набора_реплик...'] = {\n"
"         replicas = {\n"
"            ['...uuid_реплики...'] = {\n"
"                 ...,\n"
"                 zone = <число или строка>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"

msgid ""
"Then, specify relative weights for each zone pair in the ``weights`` "
"parameter of ``vshard.router.cfg``. For example:"
msgstr ""

msgid ""
"weights = {\n"
"    [1] = {\n"
"        [2] = 1, -- Routers of the 1st zone see the weight of the 2nd "
"zone as 1.\n"
"        [3] = 2, -- Routers of the 1st zone see the weight of the 3rd "
"zone as 2.\n"
"        [4] = 3, -- ...\n"
"    },\n"
"    [2] = {\n"
"        [1] = 10,\n"
"        [2] = 0,\n"
"        [3] = 10,\n"
"        [4] = 20,\n"
"    },\n"
"    [3] = {\n"
"        [1] = 100,\n"
"        [2] = 200, -- Routers of the 3rd zone see the weight of the 2nd "
"zone as 200.\n"
"                   -- Mind that it is not equal to the weight of the 2nd "
"zone visible\n"
"                   -- from the 1st zone (= 1).\n"
"        [4] = 1000,\n"
"    }\n"
"}\n"
"\n"
"local cfg = vshard.router.cfg({weights = weights, sharding = ...})"
msgstr ""

msgid "Replica set weights"
msgstr "Вес набора реплик"

msgid ""
"A replica set weight is not the same as the replica weight. The weight of"
" a replica set defines the capacity of the replica set: the larger the "
"weight, the more buckets the replica set can store. The total size of all"
" sharded spaces in the replica set is also its capacity metric."
msgstr ""
"Вес набора реплик не равноценен весу реплики. Вес набора реплик "
"определяет производительность набора реплик: чем больше вес, тем больше "
"сегментов может хранить набор реплик. Общий размер всех сегментированных "
"спейсов в наборе реплик также определяет его производительность."

msgid ""
"You can consider replica set weights as the relative amount of data "
"within a replica set. For example, if ``replicaset_1 = 100``, and "
"``replicaset_2 = 200``, the second replica set stores twice as many "
"buckets as the first one. By default, all weights of all replica sets are"
" equal."
msgstr ""
"Вес набора реплик можно рассматривать как относительный объем данных в "
"наборе реплик. Например, если ``replicaset_1 = 100``, и ``replicaset_2 = "
"200``, второй набор реплик хранит в два раза больше сегментов, чем "
"первый. По умолчанию веса всех наборов реплик равны."

msgid ""
"You can use weights, for example, to store the prevailing amount of data "
"on a replica set with more memory space."
msgstr ""
"Вес можно использовать, к примеру, чтобы хранить преобладающий объем "
"данных в наборе реплик с большим объемом памяти."

msgid "Rebalancing process"
msgstr "Процесс балансировки"

msgid ""
"There is an **etalon number** of buckets for a replica set. (Etalon in "
"this context means \"ideal\".) If there is no deviation from this number "
"in the whole replica set, then the buckets are distributed evenly."
msgstr ""
"Существует **эталонное число** сегментов в наборе реплик (\"эталонный\" в"
" данном случае значит идеальный). Если во всем наборе реплик это число "
"остается неизменным, то сегменты распределяются равномерно."

msgid ""
"The etalon number is calculated automatically considering the number of "
"buckets in the cluster and weights of the replica sets."
msgstr ""
"Эталонное число рассчитывается автоматически с учетом количества "
"сегментов в кластере и веса наборов реплик."

msgid ""
"Rebalancing starts if the **disbalance threshold of a replica set** "
"exceeds the disbalance threshold :ref:`specified in the configuration "
"<cfg_basic-rebalancer_disbalance_threshold>`."
msgstr ""

msgid "The disbalance threshold of a replica set is calculated as follows:"
msgstr ""

msgid "|etalon_bucket_number - real_bucket_number| / etalon_bucket_number * 100"
msgstr ""
"|эталонное_число_сегментов - текущее_число_сегментов| / "
"эталонное_число_сегментов * 100"

msgid ""
"For example: The user specified the number of buckets is 3000, and "
"weights of 3 replica sets are 1, 0.5, and 1.5. The resulting etalon "
"numbers of buckets for the replica sets are: 1st replica set – 1000, 2nd "
"replica set – 500, 3rd replica set – 1500."
msgstr ""
"Например: Пользователь указал, что количество сегментов = 3000, а вес 3 "
"наборов реплик составляет 1, 0,5 и 1,5. В результате получаем следующее "
"эталонное число сегментов для наборов реплик: 1 набор реплик – 1000, 2 "
"набор реплик – 500, 3 набор реплик – 1500."

msgid ""
"This approach allows assigning a zero weight to a replica set, which "
"initiates migration of its buckets to the remaining cluster nodes. It "
"also allows adding a new zero-load replica set, which initiates migration"
" of the buckets from the loaded replica sets to the zero-load replica "
"set."
msgstr ""
"Такой подход позволяет назначить нулевой вес для набора реплик, который "
"запускает миграцию сегментов на оставшиеся узлы кластера. Это также "
"позволяет добавить новый набор реплик с нулевой нагрузкой, который "
"запускает миграцию сегментов из загруженных наборов реплик в набор реплик"
" с нулевой нагрузкой."

msgid ""
"A new zero-load replica set should be assigned a weight for rebalancing "
"to start."
msgstr ""
"Новому набору реплик с нулевой нагрузкой следует присвоить вес, чтобы "
"начать процесс балансировки."

msgid "When a new shard is added, the configuration can be updated dynamically:"
msgstr "При добавлении нового шарда конфигурацию можно обновить динамически:"

msgid ""
"The configuration should be updated on all the ``routers`` first, and "
"then on all the ``storages``."
msgstr ""
"Конфигурацию следует сначала обновить на всех роутерах, а затем на всех "
"хранилищах."

msgid "The new shard becomes available for rebalancing in the ``storage`` layer."
msgstr "Новый шард становится доступен для балансирования на уровне хранилища."

msgid "As a result of rebalancing, buckets are migrated to the new shard."
msgstr "В результате балансировки происходит миграция сегментов на новый шард."

msgid ""
"If a migrated bucket is requested, ``router`` receives an error code "
"containing information about the new location of the bucket."
msgstr ""
"Если происходит запрос к перемещенному сегменту, ``роутер`` получает код "
"ошибки с информацией о новом местонахождении сегмента."

msgid ""
"At this time, the new shard is already present in the ``router``'s pool "
"of connections, so redirection is transparent for the application."
msgstr ""
"В это время новый шард уже включен в пул соединений ``роутера``, поэтому "
"переадресация видима для приложения."

msgid "Parallel rebalancing"
msgstr ""

msgid ""
"Originally, ``vshard`` had quite a simple ``rebalancer`` – one process on"
" one node that calculated *routes* which should send buckets, how many, "
"and to whom. The nodes applied these routes one by one sequentially."
msgstr ""

msgid ""
"Unfortunately, such a simple schema worked not fast enough, especially "
"for Vinyl, where costs of reading disk were comparable with network "
"costs. In fact, with Vinyl the ``rebalancer`` routes applier was sleeping"
" most of the time."
msgstr ""

msgid ""
"Now each node can send multiple buckets in parallel in a round-robin "
"manner to multiple destinations, or to just one."
msgstr ""

msgid ""
"To set the degree of parallelism, a new option was added -- "
":ref:`rebalancer_max_sending <cfg_basic-rebalancer_max_sending>`. You can"
" specify it in a storage configuration in the root table:"
msgstr ""

msgid ""
"cfg.rebalancer_max_sending = 5\n"
"vshard.storage.cfg(cfg, box.info.uuid)"
msgstr ""

msgid "In routers, this option is ignored."
msgstr ""

msgid ""
"Specifying ``cfg.rebalancer_max_sending = N`` probably won't give N times"
" speed up. It depends on network, disk, number of other fibers in the "
"system."
msgstr ""

msgid "**Example #1:**"
msgstr ""

msgid ""
"You have 10 replica sets and a new one is added. Now all the 10 replica "
"sets will try to send buckets to the new one."
msgstr ""

msgid ""
"Assume that each replica set can send up to 5 buckets at once. In that "
"case, the new replica set will experience a rather big load of 50 buckets"
" being downloaded at once. If the node needs to do some other work, "
"perhaps such a big load is undesirable. Also too many parallel buckets "
"can cause timeouts in the rebalancing process itself."
msgstr ""

msgid ""
"To fix the problem, you can set a lower value for "
"``rebalancer_max_sending`` for old replica sets, or decrease "
"``rebalancer_max_receiving`` for the new one. In the latter case some "
"workers on old nodes will be throttled, and you will see that in the "
"logs."
msgstr ""

msgid ""
"``rebalancer_max_sending`` is important, if you have restrictions for the"
" maximal number of buckets that can be read-only at once in the cluster. "
"As you remember, when a bucket is being sent, it does not accept new "
"write requests."
msgstr ""

msgid "**Example #2:**"
msgstr ""

#, python-format
msgid ""
"You have 100000 buckets and each bucket stores ~0.001% of your data. The "
"cluster has 10 replica sets. And you never can afford > 0.1% of data "
"locked on write. Then you should not set ``rebalancer_max_sending`` > 10 "
"on these nodes. It guarantees that the rebalancer won't send more than "
"100 buckets at once in the whole cluster."
msgstr ""

msgid ""
"If ``max_sending`` is too high and ``max_receiving`` is too low, then "
"some buckets will try to get relocated – and will fail with that. This "
"problem will consume network resources and time. It is important to "
"configure these parameters to not conflict with each other."
msgstr ""

msgid "Replica set lock and bucket pin"
msgstr "Блокировка набора реплик и закрепление корзины"

msgid ""
"A replica set lock makes a replica set invisible to the ``rebalancer``: a"
" locked replica set can neither receive new buckets nor migrate its own "
"buckets."
msgstr ""
"Блокировка набора реплик делает набор реплик невидимым для "
"балансировщика: заблокированный набор реплик не может ни принимать новые "
"сегменты, ни мигрировать собственные сегменты."

msgid ""
"A bucket pin blocks a specific bucket from migrating: a pinned bucket "
"stays on the replica set to which it is pinned, until it is unpinned."
msgstr ""
"В результате закрепления сегмента определенный сегмент блокируется для "
"миграции: закрепленный сегмент остается в наборе реплик, в котором он "
"закреплен, до отмены закрепления."

msgid ""
"Pinning all replica set buckets is not equivalent to locking a replica "
"set. Even if you pin all buckets, a non-locked replica set can still "
"receive new buckets."
msgstr ""
"Закрепление всех сегментов в наборе реплик не означает блокирование "
"набора реплик. Даже после закрепления всех сегментов незаблокированный "
"набор реплик может принимать новые сегменты."

msgid ""
"Replica set lock is helpful, for example, to separate a replica set from "
"production replica sets for testing, or to preserve some application "
"metadata that must not be sharded for a while. A bucket pin is used for "
"similar cases but in a smaller scope."
msgstr ""
"Блокировка набора реплик используется, к примеру, чтобы выделить для "
"тестирования набор реплик из наборов реплик, используемых в производстве,"
" или чтобы сохранить некоторые метаданные приложения, которые в течение "
"некоторого времени не должны быть сегментированы. Закрепление сегмента "
"используется в похожих случаях, но в меньшем масштабе."

msgid ""
"By both locking a replica set and pinning all buckets, one can isolate an"
" entire replica set."
msgstr ""
"Блокировка набора реплик и закрепление всех сегментов означает изоляцию "
"целого набора реплик."

msgid ""
"Locked replica sets and pinned buckets affect the rebalancing algorithm "
"as the ``rebalancer`` must ignore locked replica sets and consider pinned"
" buckets when attempting to reach the best possible balance."
msgstr ""
"Заблокированные наборы реплик и закрепленные сегменты влияют на алгоритм "
"балансировки, так как ``балансировщик`` должен игнорировать "
"заблокированные наборы реплик и учитывать закрепленные сегменты при "
"попытке достичь наилучшего возможного баланса."

msgid ""
"The issue is not trivial as a user can pin too many buckets to a replica "
"set, so a perfect balance becomes unreachable. For example, consider the "
"following cluster (assume all replica set weights are equal to 1)."
msgstr ""
"Это нетривиальная задача, поскольку пользователь может закрепить слишком "
"много сегментов в наборе реплик, так что становится невозможным "
"достижение идеального баланса. Например, рассмотрим следующий кластер "
"(предположим, что все веса наборов реплик равны 1)."

msgid "The initial configuration:"
msgstr "Начальная конфигурация:"

msgid ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120"
msgstr ""
"rs1: bucket_count = 150 -- число сегментов\n"
"rs2: bucket_count = 150, pinned_count = 120 -- число сегментов, число "
"закрепленных сегментов"

msgid "Adding a new replica set:"
msgstr "Добавление нового набора реплик:"

msgid ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"
msgstr ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"

msgid ""
"The perfect balance would be ``100 - 100 - 100``, which is impossible "
"since the ``rs2`` replica set has 120 pinned buckets. The best possible "
"balance here is the following:"
msgstr ""
"Идеальным балансом было бы ``100 - 100 - 100``, чего невозможно достичь, "
"поскольку набор реплик ``rs2`` содержит 120 закрепленных сегментов. The "
"best possible balance here is the following:"

msgid ""
"rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"
msgstr ""
"rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"

msgid ""
"The ``rebalancer`` moved as many buckets as possible from ``rs2`` to "
"decrease the disbalance. At the same time it respected equal weights of "
"``rs1`` and ``rs3``."
msgstr ""
"``Балансировщик`` переместил максимально возможное количество сегментов "
"из ``rs2``, чтобы уменьшить дисбаланс. В то же время он учел одинаковый "
"вес respected ``rs1`` и ``rs3``."

msgid ""
"The algorithms for implementing locks and pins are completely different, "
"although they look similar in terms of functionality."
msgstr ""
"Алгоритмы реализации блокировки и закрепления совершенно разные, хотя с "
"точки зрения функций они похожи."

msgid "Replica set lock and rebalancing"
msgstr "Заблокированный набор реплик и балансировка"

msgid ""
"Locked replica sets simply do not participate in rebalancing. This means "
"that even if the actual total number of buckets is not equal to the "
"etalon number, the disbalance cannot be fixed due to the lock. When the "
"rebalancer detects that one of the replica sets is locked, it "
"recalculates the etalon number of buckets of the non-locked replica sets "
"as if the locked replica set and its buckets did not exist at all."
msgstr ""
"Заблокированные наборы реплик просто не участвуют в балансировке. Это "
"означает, что даже если фактическое общее количество сегментов не равно "
"эталонному числу, дисбаланс нельзя исправить из-за блокировки. Когда "
"балансировщик обнаруживает, что один из наборов реплик заблокирован, он "
"пересчитывает эталонное число сегментов неблокированных наборов реплик, "
"как если бы заблокированный набор реплик и его сегменты вообще не "
"существовали."

msgid "Bucket pin and rebalancing"
msgstr "Закрепленный набор реплик и балансировка"

msgid ""
"Rebalancing replica sets with pinned buckets requires a more complex "
"algorithm. Here ``pinned_count[o]`` is the number of pinned buckets, and "
"``etalon_count`` is the etalon number of buckets for a replica set:"
msgstr ""

msgid ""
"The ``rebalancer`` calculates the etalon number of buckets as if all "
"buckets were not pinned. Then the rebalancer checks each replica set and "
"compares the etalon number of buckets with the number of pinned buckets "
"in a replica set. If ``pinned_count < etalon_count``, non-locked replica "
"sets (at this point all locked replica sets already are filtered out) "
"with pinned buckets can receive new buckets."
msgstr ""
"Балансировщик рассчитывает эталонное число сегментов, как если бы все "
"сегменты не были закреплены. Затем балансировщик проверяет каждый набор "
"реплик и сопоставляет эталонное число сегментов с числом закрепленных "
"сегментов в наборе реплик. Если ``pinned_count < etalon_count``, "
"незаблокированные наборы реплик (на данном этапе все заблокированные "
"наборы реплик уже отфильтрованы) с закрепленными сегментами могут "
"получать новые сегменты."

msgid ""
"If ``pinned_count > etalon_count``, the disbalance cannot be fixed, as "
"the ``rebalancer`` cannot move pinned buckets out of this replica set. In"
" such a case the etalon number is updated and set equal to the number of "
"pinned buckets. The replica sets with ``pinned_count > etalon_count`` are"
" not processed by the ``rebalancer``, and the number of pinned buckets is"
" subtracted from the total number of buckets. The rebalancer tries to "
"move out as many buckets as possible from such replica sets."
msgstr ""
"Если же ``pinned_count > etalon_count``, дисбаланс исправить нельзя, так "
"как балансировщик не может вывести закрепленные сегменты из этого набора "
"реплик. В таком случае эталонное число обновляется как равное числу "
"закрепленных сегментов. Наборы реплик с ``pinned_count > etalon_count`` "
"не обрабатываются балансировщиком`, а число закрепленных сегментов "
"вычитается из общего числа сегментов. Балансировщик пытается вывести как "
"можно больше сегментов из таких наборов реплик."

msgid ""
"This procedure is restarted from step 1 for replica sets with "
"``pinned_count >= etalon_count`` until ``pinned_count <= etalon_count`` "
"on all replica sets. The procedure is also restarted when the total "
"number of buckets is changed."
msgstr ""
"Эта процедура перезапускается с шага 1 для наборов реплик с "
"``pinned_count >= etalon_count`` до тех пор, пока не будет выполнено "
"условие ``pinned_count <= etalon_count`` для всех наборов реплик. "
"Процедура также перезапускается при изменении общего числа сегментов."

msgid "Here is the pseudocode for the algorithm:"
msgstr "Псевдокод для данного алгоритма будет следующим:"

msgid ""
"function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- rebalance the buckets using weights of the still viable "
"replica sets --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"
msgstr ""
"function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- балансировка сегментов с использованием веса рабочих наборов "
"реплик --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"

msgid ""
"The complexity of the algorithm is ``O(N^2)``, where N is the number of "
"replica sets. On each step, the algorithm either finishes the "
"calculation, or ignores at least one new replica set overloaded with the "
"pinned buckets, and updates the etalon number of buckets on other replica"
" sets."
msgstr ""
"Сложность алгоритма составляет ``O(N^2)``, где N -- количество наборов "
"реплик. На каждом шаге алгоритм либо завершает вычисление, либо "
"игнорирует хотя бы один новый набор реплик, перегруженный закрепленными "
"сегментами, и обновляет эталонное число сегментов в других наборах "
"реплик."

msgid "Bucket ref"
msgstr "Ссылка в сегменте"

msgid ""
"Bucket ref is an in-memory counter that is similar to the :ref:`bucket "
"pin <vshard-lock-pin>`, but has the following differences:"
msgstr ""
"Ссылка в сегменте -- это счетчик в оперативной памяти, который похож на "
":ref:`закрепление сегмента <vshard-lock-pin>` со следующими отличиями:"

msgid ""
"Bucket ref is not persistent. Refs are intended for forbidding bucket "
"transfer during request execution, but on restart all requests are "
"dropped."
msgstr ""
"Ссылка в сегменте никогда не сохраняется. Ссылки предназначены для "
"запрета передачи сегментов во время выполнения запроса, но при "
"перезапуске все запросы отбрасываются."

msgid "There are two types of bucket refs: read-only (RO) and read-write (RW)."
msgstr "Есть 2 типа ссылок в сегменте: только чтение (RO) и чтение-запись (RW)."

msgid ""
"If a bucket has RW refs, it cannot be moved. However, when the rebalancer"
" needs it to be sent, it locks the bucket for new write requests, waits "
"until all current requests are finished, and then sends the bucket."
msgstr ""

msgid ""
"If a bucket has RO refs, it can be sent, but cannot be dropped. Such a "
"bucket can even enter GARBAGE or SENT state, but its data is kept until "
"the last reader is gone."
msgstr ""
"Если в сегменте есть ссылки типа RO, его можно отправить, но нельзя "
"удалить. Такой сегмент может даже перейти в статус мусора GARBAGE или "
"отправки SENT, но его данные сохраняются до тех пор, пока не уйдет "
"последний читатель."

msgid "A single bucket can have both RO and RW refs."
msgstr "В одном сегменте могут быть ссылки как типа RO, так и типа RW."

msgid "Bucket ref is countable."
msgstr "Ссылки в сегменте исчисляются."

msgid ""
"The :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` "
"methods are called automatically when :ref:`vshard.router.call() "
"<router_api-call>` or :ref:`vshard.storage.call() <storage_api-call>` is "
"used. For raw API like ``r = vshard.router.route() r:callro/callrw`` you "
"should explicitly call the ``bucket_ref()`` method inside the function. "
"Also, make sure that you call ``bucket_unref()`` after ``bucket_ref()``, "
"otherwise the bucket cannot be moved from the storage until the instance "
"restart."
msgstr ""
"Методы :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` "
"вызываются автоматически при использовании :ref:`vshard.router.call() "
"<router_api-call>` или :ref:`vshard.storage.call() <storage_api-call>`. "
"При использовании API, например ``r = vshard.router.route() "
"r:callro/callrw``, следует дополнительно вызвать метод ``bucket_ref()`` в"
" рамках функции. Кроме того, следует убедиться, что после "
"``bucket_ref()`` вызывается ``bucket_unref()``, иначе сегмент нельзя "
"перемещать из хранилища до перезапуска экземпляра."

msgid ""
"To see how many refs there are for a bucket, use "
":ref:`vshard.storage.buckets_info([bucket_id]) <storage_api-"
"buckets_info>` (the ``bucket_id`` parameter is optional)."
msgstr ""
"Чтобы узнать количество ссылок в сегменте, используйте "
":ref:`vshard.storage.buckets_info([идентификатор_сегмента]) <storage_api-"
"buckets_info>` (параметр ``идентификатор_сегмента`` необязателен)."

msgid "For example:"
msgstr "Пример:"

msgid ""
"vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"
msgstr ""
"vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"

msgid "Defining spaces"
msgstr "Определение спейса"

msgid ""
"Database Schema is stored on ``storages``, while ``routers`` know nothing"
" about spaces and tuples."
msgstr ""

msgid ""
"Spaces should be defined within a storage application using "
"``box.once()``. For example:"
msgstr ""
"В приложении хранилища следует определить спейсы с помощью "
"``box.once()``. Например:"

msgid ""
"box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique "
"= false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', "
"'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"
msgstr ""
"box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique "
"= false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', "
"'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"

msgid ""
"Every space you plan to shard must have a field with :ref:`bucket id "
"<vshard-vbuckets>` numbers, indexed by the :ref:`shard index <cfg_basic-"
"shard_index>`."
msgstr ""

msgid "Adding data"
msgstr ""

msgid ""
"All DML operations with data should be performed via ``router``. The only"
" operation supported by ``router`` is `CALL` via ``bucket_id``:"
msgstr ""

msgid "result = vshard.router.call(bucket_id, mode, func, args)"
msgstr ""

msgid ""
"``vshard.router.call()`` routes ``result = func(unpack(args))`` call to a"
" shard which serves ``bucket_id``."
msgstr ""

msgid ""
"``bucket_id`` is just a regular number in the range "
"``1..``:ref:`bucket_count<cfg_basic-bucket_count>`. This number can be "
"assigned in an arbitrary way by the client application. A sharded "
"Tarantool cluster uses this number as an opaque unique identifier to "
"distribute data across replica sets. It is guaranteed that all records "
"with the same ``bucket_id`` will be stored on the same replica set."
msgstr ""

msgid "Bootstrapping and restarting a storage"
msgstr "Настройка и перезапуск хранилища"

msgid "If a replica set master fails, it is recommended to:"
msgstr "В случае отказа мастера в наборе реплик рекомендуется:"

msgid ""
"Switch one of the replicas into the master mode. This allows the new "
"master to process all the incoming requests."
msgstr ""
"Переключить одну из реплик в режим мастера, что позволит новому мастеру "
"обрабатывать все входящие запросы."

msgid ""
"Update the configuration of all the cluster members. This forwards all "
"the requests to the new master."
msgstr ""
"Обновить конфигурацию всех членов кластера, в результате чего все запросы"
" будут перенаправлены на новый мастер."

msgid ""
"Monitoring the master and switching the instance modes can be handled by "
"any external utility."
msgstr ""
"Мониторинг состояния мастера и переключение режимов экземпляров можно "
"осуществлять с помощью внешней утилиты."

msgid ""
"To perform a scheduled downtime of a replica set master, it is "
"recommended to:"
msgstr ""
"Для проведения запланированного остановки мастера в наборе реплик "
"рекомендуется:"

msgid ""
"Update the configuration of the master and wait for the replicas to get "
"into sync. All the requests then are forwarded to a new master."
msgstr ""
"Обновить конфигурацию мастера и подождать синхронизации всех реплик, в "
"результате чего все запросы будут перенаправлены на новый мастер."

msgid "Switch another instance into the master mode."
msgstr "Переключить другой экземпляр в режим мастера."

msgid "Update the configuration of all the nodes."
msgstr "Обновить конфигурацию всех узлов."

msgid "Shut down the old master."
msgstr "Отключить старый мастер."

msgid "To perform a scheduled downtime of a replica set, it is recommended to:"
msgstr "Для проведения запланированной остановки набора реплик рекомендуется:"

msgid "Migrate all the buckets to the other cluster storages."
msgstr "Произвести миграцию всех сегментов в другие хранилища кластера."

msgid "Shut down the replica set."
msgstr "Отключить набор реплик."

msgid ""
"In case a whole replica set fails, some part of the dataset becomes "
"inaccessible. Meanwhile, the ``router`` tries to reconnect to the master "
"of the failed replica set. This way, once the replica set is up and "
"running again, the cluster is automatically restored."
msgstr ""
"В случае отказа всего набора реплик некоторая часть набора данных "
"становится недоступной. Тем временем ``роутер`` пытается повторно "
"подключиться к мастеру отказавшего набора реплик. Таким образом, после "
"того, как набор реплик снова запущен, кластер автоматически "
"восстанавливается."

msgid "Fibers"
msgstr "Файберы"

msgid ""
"Searches for buckets, buckets recovery, and buckets rebalancing are "
"performed automatically and do not require manual intervention."
msgstr ""

msgid ""
"Technically, there are multiple fibers responsible for different types of"
" operations:"
msgstr ""
"С технической точки зрения есть несколько файберов, которые отвечают за "
"различные типы действий:"

msgid ""
"a **discovery** fiber on the ``router`` searches for buckets in the "
"background"
msgstr ""
"файбер **обнаружения** на ``роутере`` выполняет поиск сегментов в фоновом"
" режиме"

msgid "a **failover** fiber on the ``router`` maintains replica connections"
msgstr ""
"файбер **восстановления после отказа** на ``роутере`` поддерживает "
"соединения с репликами"

msgid ""
"a **garbage collector** fiber on each master ``storage`` removes the "
"contents of buckets that were moved"
msgstr ""
"файбер **сборки мусора** на каждом мастер-хранилище удаляет содержимое "
"перемещенных сегментов"

msgid ""
"a **bucket recovery** fiber on each master ``storage`` recovers buckets "
"in the SENDING and RECEIVING states in case of reboot"
msgstr ""
"файбер **восстановления сегмента** на каждом мастер-хранилище "
"восстанавливает сегменты в статусах отправки SENDING и получения "
"RECEIVING в случае перезагрузки"

msgid ""
"a **rebalancer** on a single master ``storage`` among all replica sets "
"executes the rebalancing process."
msgstr ""
"**балансировщик** на отдельном мастер-хранилище среди множества наборов "
"реплик выполняет процесс балансировки."

msgid ""
"See the :ref:`Rebalancing process <vshard-rebalancing>` and "
":ref:`Migration of buckets <vshard-migrate-buckets>` sections for "
"details."
msgstr ""

msgid "Garbage collector"
msgstr "Сборщик мусора"

msgid ""
"A **garbage collector** fiber runs in the background on the master "
"storages of each replica set. It starts deleting the contents of the "
"bucket in the GARBAGE state part by part. Once the bucket is empty, its "
"record is deleted from the ``_bucket`` system space."
msgstr ""
"Файбер **сборщик мусора** работает в фоновом режиме на мастер-хранилищах "
"в каждом наборе реплик. Он начинает удалять содержимое сегмента в "
"состоянии мусора GARBAGE по частям. Когда сегмент пуст, запись о нем "
"удаляется из системного спейса ``_bucket``."

msgid "Bucket recovery"
msgstr "Восстановление сегмента"

msgid ""
"A **bucket recovery** fiber runs on the master storages. It helps to "
"recover buckets in the SENDING and RECEIVING states in case of reboot."
msgstr ""
"Файбер **восстановления сегмента** работает на мастер-хранилищах. Он "
"помогает восстановить сегменты в статусах отправки SENDING и получения "
"RECEIVING в случае перезагрузки."

msgid "Buckets in the SENDING state are recovered as follows:"
msgstr "Сегменты в статусе SENDING восстанавливаются следующим образом:"

msgid "The system first searches for buckets in the SENDING state."
msgstr "Сначала система ищет сегменты в статусе SENDING."

msgid ""
"If such a bucket is found, the system sends a request to the destination "
"replica set."
msgstr ""
"Если такой сегмент обнаружен, система отправляет запрос в целевой набор "
"реплик."

msgid ""
"If the bucket on the destination replica set is ACTIVE, the original "
"bucket is deleted from the source node."
msgstr ""
"Если сегмент в целевом наборе реплик находится в активном статусе ACTIVE,"
" исходный сегмент удаляется из исходного узла."

msgid "Buckets in the RECEIVING state are deleted without extra checks."
msgstr "Сегменты в статусе RECEIVING удаляются без дополнительных проверок."

msgid "Failover"
msgstr "Восстановление после отказа"

msgid ""
"A **failover** fiber runs on every ``router``. If a master of a replica "
"set becomes unavailable, the failover fiber redirects read requests to "
"the replicas. Write requests are rejected with an error until the master "
"becomes available."
msgstr ""
"Файбер **восстановления после отказа** работает на каждом роутере. Если "
"мастер набора реплик становится недоступным, файбер перенаправляет "
"запросы на чтение к репликам. Запросы на запись отклоняются с ошибкой до "
"тех пор, пока мастер не будет доступен."
