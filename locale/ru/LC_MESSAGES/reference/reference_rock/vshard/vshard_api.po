
#, fuzzy
msgid "API Reference"
msgstr "Справочник по API"

#, fuzzy
msgid ""
"This section represents public and internal API for the :ref:`router "
"<vshard-architecture-router>` and the :ref:`storage <vshard-architecture-"
"storage>`."
msgstr ""
"В этом разделе представлен общедоступный и внутренний API для :ref:`роутера "
"<vshard-router>` и для :ref:`хранилища <vshard-storage>`."

#~ msgid "Subsection"
#~ msgstr "Раздел"

#~ msgid "Methods"
#~ msgstr "Методы"

#~ msgid ":ref:`Router public API <vshard_api_reference-router_public_api>`"
#~ msgstr ""
#~ ":ref:`Общедоступный API роутера <vshard_api_reference-router_public_api>`"

#~ msgid ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"
#~ msgstr ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"

#~ msgid ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"
#~ msgstr ""

#~ msgid ":ref:`vshard.router.new(name, cfg) <router_api-new>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list}, "
#~ "{options}) <router_api-call>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, "
#~ "{options}) <router_api-callro>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, "
#~ "{options}) <router_api-callrw>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, "
#~ "{options}) <router_api-callre>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, "
#~ "{options}) <router_api-callbro>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, "
#~ "{options}) <router_api-callbre>`"
#~ msgstr ""

#~ msgid ":ref:`vshard.router.route(bucket_id) <router_api-route>`"
#~ msgstr ""

#~ msgid ":ref:`vshard.router.routeall() <router_api-routeall>`"
#~ msgstr ":ref:`vshard.router.routeall() <router_api-routeall>`"

#~ msgid ""
#~ ":ref:`vshard.router.bucket_id_strcrc32(key) <router_api-bucket_id_strcrc32>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.router.bucket_id_mpcrc32(key) <router_api-bucket_id_mpcrc32>`"
#~ msgstr ""

#~ msgid ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"
#~ msgstr ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"

#~ msgid ":ref:`vshard.router.sync(timeout) <router_api-sync>`"
#~ msgstr ""

#~ msgid ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"
#~ msgstr ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"

#~ msgid ":ref:`vshard.router.discovery_set() <router_api-discovery_set>`"
#~ msgstr ":ref:`vshard.router.discovery_set() <router_api-discovery_set>`"

#~ msgid ":ref:`vshard.router.info() <router_api-info>`"
#~ msgstr ":ref:`vshard.router.info() <router_api-info>`"

#~ msgid ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"
#~ msgstr ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"

#~ msgid ":ref:`replicaset_object:call() <router_api-replicaset_call>`"
#~ msgstr ""

#~ msgid ":ref:`replicaset_object:callro() <router_api-replicaset_callro>`"
#~ msgstr ""

#~ msgid ":ref:`replicaset_object:callrw() <router_api-replicaset_callrw>`"
#~ msgstr ""

#~ msgid ":ref:`replicaset_object:callre() <router_api-replicaset_callre>`"
#~ msgstr ""

#~ msgid ":ref:`Router internal API <vshard_api_reference-router_internal_api>`"
#~ msgstr ""
#~ ":ref:`Внутренний API роутера <vshard_api_reference-router_internal_api>`"

#~ msgid ""
#~ ":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-"
#~ "bucket_discovery>`"
#~ msgstr ""

#~ msgid ":ref:`Storage public API <vshard-storage_public_api>`"
#~ msgstr ":ref:`Общедоступный API хранилища <vshard-storage_public_api>`"

#~ msgid ":ref:`vshard.storage.cfg(cfg, name) <storage_api-cfg>`"
#~ msgstr ""

#~ msgid ":ref:`vshard.storage.info() <storage_api-info>`"
#~ msgstr ":ref:`vshard.storage.info() <storage_api-info>`"

#~ msgid ""
#~ ":ref:`vshard.storage.call(bucket_id, mode, function_name, {argument_list}) "
#~ "<storage_api-call>`"
#~ msgstr ""

#~ msgid ":ref:`vshard.storage.sync(timeout) <storage_api-sync>`"
#~ msgstr ""

#~ msgid ":ref:`vshard.storage.bucket_pin(bucket_id) <storage_api-bucket_pin>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.storage.bucket_unpin(bucket_id) <storage_api-bucket_unpin>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.storage.bucket_ref(bucket_id, mode) <storage_api-bucket_ref>`"
#~ msgstr ""

#~ msgid ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"
#~ msgstr ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"

#~ msgid ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"
#~ msgstr ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"

#~ msgid ""
#~ ":ref:`vshard.storage.bucket_unref(bucket_id, mode) <storage_api-"
#~ "bucket_unref>`"
#~ msgstr ""

#~ msgid ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"
#~ msgstr ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"

#~ msgid ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"
#~ msgstr ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"

#~ msgid ""
#~ ":ref:`vshard.storage.find_garbage_bucket(bucket_index, control) "
#~ "<storage_api-find_garbage_bucket>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.storage.rebalancer_disable() <storage_api-rebalancer_disable>`"
#~ msgstr ""
#~ ":ref:`vshard.storage.rebalancer_disable() <storage_api-rebalancer_disable>`"

#~ msgid ""
#~ ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"
#~ msgstr ""
#~ ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"

#~ msgid ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"
#~ msgstr ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"

#~ msgid ""
#~ ":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-"
#~ "rebalancing_is_in_progress>`"
#~ msgstr ""
#~ ":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-"
#~ "rebalancing_is_in_progress>`"

#~ msgid ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"
#~ msgstr ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"

#~ msgid ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"
#~ msgstr ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"

#~ msgid ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"
#~ msgstr ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"

#~ msgid ":ref:`Storage internal API <vshard-storage_internal_api>`"
#~ msgstr ":ref:`Внутренний API хранилища <vshard-storage_internal_api>`"

#~ msgid ":ref:`vshard.storage.bucket_stat(bucket_id) <storage_api-bucket_stat>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.storage.bucket_recv(bucket_id, from, data) <storage_api-"
#~ "bucket_recv>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.storage.bucket_delete_garbage(bucket_id) <storage_api-"
#~ "bucket_delete_garbage>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.storage.bucket_collect(bucket_id) <storage_api-bucket_collect>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.storage.bucket_force_create(first_bucket_id, count) "
#~ "<storage_api-bucket_force_create>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.storage.bucket_force_drop(bucket_id, to) <storage_api-"
#~ "bucket_force_drop>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.storage.bucket_send(bucket_id, to) <storage_api-bucket_send>`"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"
#~ msgstr ""
#~ ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"

#~ msgid ""
#~ ":ref:`vshard.storage.rebalancer_request_state() <storage_api-"
#~ "rebalancer_request_state>`"
#~ msgstr ""
#~ ":ref:`vshard.storage.rebalancer_request_state() <storage_api-"
#~ "rebalancer_request_state>`"

#~ msgid "Router public API"
#~ msgstr "Общедоступный API роутера"

#~ msgid ""
#~ "Perform the initial cluster bootstrap and distribute all buckets across the "
#~ "replica sets."
#~ msgstr ""
#~ "Инициализация кластера и распределение всех сегментов по наборам реплик."

#~ msgid "Parameters"
#~ msgstr "Параметры"

#~ msgid ""
#~ "a number of seconds before ending a bootstrap attempt as unsuccessful. "
#~ "Recreate the cluster in case of bootstrap timeout."
#~ msgstr ""
#~ "количество секунд ожидания до признания попытки инициализации неуспешной. "
#~ "Пересоздайте кластер в случае блокировки инициализации по истечении времени "
#~ "ожидания."

#~ msgid ""
#~ "by default is set to ``false`` that means raise an error, when the cluster "
#~ "is already bootstrapped. ``True`` means consider an already bootstrapped "
#~ "cluster a success."
#~ msgstr ""
#~ "По умолчанию ``false``, то есть \"вызвать ошибку, если кластер уже был "
#~ "инициализирован\". ``True`` значит \"если кластер уже был инициализирован, "
#~ "то ничего не делать.\""

#~ msgid "**Example:**"
#~ msgstr "**Пример:**"

#~ msgid "vshard.router.bootstrap({timeout = 4, if_not_bootstrapped = true})"
#~ msgstr ""

#~ msgid ""
#~ "To detect whether a cluster is bootstrapped, ``vshard`` looks for at least "
#~ "one bucket in the whole cluster. If the cluster was bootstrapped only "
#~ "partially (for example, due to an error during the first bootstrap), then it"
#~ " will be considered a bootstrapped cluster on a next bootstrap call with "
#~ "``if_not_bootstrapped``. So this is still a bad practice. Avoid calling "
#~ "``bootstrap()`` multiple times."
#~ msgstr ""
#~ "Чтобы определить, инициализирован ли кластер , vshard ищет по крайней мере "
#~ "один сегмент во всем кластере. Если кластер был инициализирован частично "
#~ "(например, из-за ошибки при первой инициализации),то он все равно будет "
#~ "считаться инициализированным при следующей попытке инициализации с флагом "
#~ "``if_not_bootstrapped``. Поэтому лучше избегать вызова ``bootstrap()`` "
#~ "несколько раз."

#~ msgid ""
#~ "Configure the database and start sharding for the specified ``router`` "
#~ "instance. See the :ref:`sample configuration <vshard-config-cluster-"
#~ "example>`."
#~ msgstr ""
#~ "Настройка базы данных и начало шардинга указанного ``роутера``. См. "
#~ ":ref:`образец конфигурации<vshard-config-cluster-example>`."

#~ msgid "a configuration table"
#~ msgstr "конфигурационная таблица"

#~ msgid ""
#~ "Create a new router instance. ``vshard`` supports multiple routers in a "
#~ "single Tarantool instance. Each router can be connected to any ``vshard`` "
#~ "cluster, and multiple routers can be connected to the same cluster."
#~ msgstr ""
#~ "Создание нового экземпляра роутера. ``vshard`` поддерживает работу "
#~ "нескольких роутеров в отдельном экземпляре Tarantool. Каждый роутер может "
#~ "подключаться к любом кластеру ``vshard``, несколько роутеров могут "
#~ "подключаться к одному кластеру."

#~ msgid ""
#~ "A router created via ``vshard.router.new()`` works in the same way as a "
#~ "static router, but the method name is preceded by a colon "
#~ "(``vshard.router:method_name(...)``), while for a static router the method "
#~ "name is preceded by a period (``vshard.router.method_name(...)``)."
#~ msgstr ""
#~ "Роутер, созданный с помощью ``vshard.router.new()``, работает так же, как и "
#~ "статичный роутер, но перед его методами указывается двоеточие "
#~ "(``vshard.router:имя_метода(...)``), а перед методами статичного роутера -- "
#~ "точка (``vshard.router.имя_метода(...)``)."

#~ msgid ""
#~ "A static router can be obtained via the ``vshard.router.static()`` method "
#~ "and then used like a router created via the ``vshard.router.new()`` method."
#~ msgstr ""
#~ "Статичный роутер можно получить при помощи метода "
#~ "``vshard.router.static()``, а затем использовать его как роутер, созданный с"
#~ " помощью метода ``vshard.router.new()``."

#~ msgid "``box.cfg`` is shared among all the routers of a single instance."
#~ msgstr "``box.cfg`` используется всеми роутерами одного экземпляра."

#~ msgid ""
#~ "a router instance name. This name is used as a prefix in logs of the router "
#~ "and must be unique within the instance"
#~ msgstr ""
#~ "имя экземпляра роутера, которое используется в качестве префикса в журналах "
#~ "роутера и должно быть уникальным в пределах экземпляра"

#~ msgid ""
#~ "a configuration table. See the :ref:`sample configuration <vshard-config-"
#~ "cluster-example>`."
#~ msgstr ""
#~ "конфигурационная таблица. См. :ref:`образец конфигурации <vshard-config-"
#~ "cluster-example>`."

#~ msgid "Return"
#~ msgstr "Возвращается"

#~ msgid ""
#~ "a router instance, if created successfully; otherwise, nil and an error "
#~ "object"
#~ msgstr "экземпляр роутера, если он создан; в противном случае, nil и ошибка"

#~ msgid ""
#~ "Call the function identified by function-name on the shard storing the "
#~ "bucket identified by bucket_id. See the :ref:`Processing requests <vshard-"
#~ "process-requests>` section for details on function operation."
#~ msgstr ""
#~ "Вызов функции по имени функции (function-name) на шарде, где хранится "
#~ "сегмент с указанным идентификатором (bucket_id). Для получения подробной "
#~ "информации о работе функции см. раздел :ref:`Обработка запросов <vshard-"
#~ "process-requests>`."

#~ msgid "a bucket identifier"
#~ msgstr "идентификатор сегмента"

#~ msgid ""
#~ "either a string = 'read'|'write', or a map with mode='read'|'write' and/or "
#~ "prefer_replica=true|false and/or balance=true|false."
#~ msgstr ""
#~ "либо строка = 'read'|'write' (чтение|запись), либо ассоциативный массив с "
#~ "параметром mode ='read'|'write' (чтение|запись) и/или "
#~ "prefer_replica=true|false (правда|ложь), и/или balance=true|false "
#~ "(правда|ложь)."

#~ msgid "a function to execute"
#~ msgstr "выполняемая функция"

#~ msgid "an array of the function's arguments"
#~ msgstr "массив аргументов функции"

#~ msgid ""
#~ "* ``timeout`` – a request timeout, in seconds. If the ``router`` cannot "
#~ "identify a   shard with the specified ``bucket_id``, the operation will be "
#~ "repeated until the   timeout is reached.  * other :ref:`net.box options "
#~ "<net_box-options>`, such as ``is_async``,   ``buffer``, ``on_push`` are also"
#~ " supported."
#~ msgstr ""
#~ "* ``timeout`` -- время ожидания запроса в секундах. Если ``роутер`` не может"
#~ " определить шард с идентификатором сегмента, операция повторяется до "
#~ "истечения времени ожидания."

#~ msgid ""
#~ "``timeout`` – a request timeout, in seconds. If the ``router`` cannot "
#~ "identify a shard with the specified ``bucket_id``, the operation will be "
#~ "repeated until the timeout is reached."
#~ msgstr ""
#~ "``timeout`` -- время ожидания запроса в секундах. Если ``роутер`` не может "
#~ "определить шард с указанным идентификатором сегмента ``bucket_id``, операция"
#~ " повторяется до истечения времени ожидания."

#~ msgid ""
#~ "other :ref:`net.box options <net_box-options>`, such as ``is_async``, "
#~ "``buffer``, ``on_push`` are also supported."
#~ msgstr ""
#~ "другие :ref:`net.box опции <net_box-options>`, такие как ``is_async``, "
#~ "``buffer``, ``on_push`` также поддерживаются."

#~ msgid ""
#~ "The mode parameter has two possible forms: a string or a map. Examples of "
#~ "the string form are: ``'read'``, ``'write'``. Examples of the map form are: "
#~ "``{mode='read'}``, ``{mode='write'}``, ``{mode='read', "
#~ "prefer_replica=true}``, ``{mode='read', balance=true}``, ``{mode='read', "
#~ "prefer_replica=true, balance=true}``."
#~ msgstr ""
#~ "У параметра режима mode есть две доступные формы: строка или ассоциативный "
#~ "массив. Примеры строки: ``'read'`` (чтение), ``'write'`` (запись). Примеры "
#~ "ассоциативного массива: ``{mode='read'}``, ``{mode='write'}``, "
#~ "``{mode='read', prefer_replica=true}``, ``{mode='read', balance=true}``, "
#~ "``{mode='read', prefer_replica=true, balance=true}``."

#~ msgid "If ``'write'`` is specified then the target is the master."
#~ msgstr "Если указать значение ``'write'`` (запись), то целью будет мастер."

#~ msgid ""
#~ "If ``prefer_replica=true`` is specified then the preferred target is one of "
#~ "the replicas, but the target is the master if there is no conveniently "
#~ "available replica."
#~ msgstr ""
#~ "Если указать ``prefer_replica=true``, то предпочитаемая цель -- одна из "
#~ "реплик; если же доступной реплики нет, то целью будет мастер."

#~ msgid ""
#~ "It may be good to specify prefer_replica=true for functions which are "
#~ "expensive in terms of resource use, to avoid slowing down the master."
#~ msgstr ""
#~ "Удобно указать ``prefer_replica=true`` для ресурсозатратных функций во "
#~ "избежание замедления работы мастера."

#~ msgid ""
#~ "If ``balance=true`` then there is load balancing -- reads are distributed "
#~ "over all the nodes in the replica set in round-robin fashion, with a "
#~ "preference for replicas if prefer_replica=true is also set."
#~ msgstr ""
#~ "Если задать ``balance=true``, добавится балансировка нагрузки -- запросы на "
#~ "чтение распределяются по всем узлам набора реплик по кругу, предпочтение "
#~ "отдается репликам, если также задано ``prefer_replica=true``."

#~ msgid ""
#~ "The original return value of the executed function, or ``nil`` and error "
#~ "object. The error object has a type attribute equal to ``ShardingError`` or "
#~ "one of the regular Tarantool errors (``ClientError``, ``OutOfMemory``, "
#~ "``SocketError``, etc.)."
#~ msgstr ""
#~ "Исходное возвращаемое значение выполняемой функции или ``nil`` и ошибка. "
#~ "Объект ошибки содержит атрибут типа, который равен ``ShardingError`` или "
#~ "одной из стандартных ошибок Tarantool(``ClientError``, ``OutOfMemory``, "
#~ "``SocketError`` и т.д.)."

#~ msgid ""
#~ "``ShardingError`` is returned on errors specific for sharding: the master is"
#~ " missing, wrong bucket id, etc. It has an attribute code containing one of "
#~ "the values from the ``vshard.error.code.*`` LUA table, an optional attribute"
#~ " containing a message with the human-readable error description, and other "
#~ "attributes specific for the error code."
#~ msgstr ""
#~ "``ShardingError`` возвращается в случае ошибок шардинга: отсутствует мастер,"
#~ " неверный идентификатор сегмента и т.д. Такая ошибка содержит код с одним из"
#~ " значений из Lua-таблицы ``vshard.error.code.*``, необязательный атрибут "
#~ "сообщения с удобным для восприятия описанием ошибки и другие атрибуты, "
#~ "специфичные для данного кода ошибки."

#~ msgid "**Examples:**"
#~ msgstr "**Примеры:**"

#~ msgid "To call ``customer_add`` function from ``vshard/example``, say:"
#~ msgstr ""
#~ "Для вызова функции ``customer_add`` из ``vshard/example`` выполните команду:"

#~ msgid ""
#~ "vshard.router.call(100,\n"
#~ "                   'write',\n"
#~ "                   'customer_add',\n"
#~ "                   {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}},\n"
#~ "                   {timeout = 5})\n"
#~ "-- or, the same thing but with a map for the second argument\n"
#~ "vshard.router.call(100,\n"
#~ "                   {mode='write'},\n"
#~ "                   'customer_add',\n"
#~ "                   {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}},\n"
#~ "                   {timeout = 5})"
#~ msgstr ""

#~ msgid ""
#~ "Call the function identified by function-name on the shard storing the "
#~ "bucket identified by bucket_id, in read-only mode (similar to calling "
#~ "vshard.router.call with mode='read'). See the :ref:`Processing requests "
#~ "<vshard-process-requests>` section for details on function operation."
#~ msgstr ""
#~ "Вызов функции по имени функции (function-name) на шарде, где хранится "
#~ "сегмент с указанным идентификатором (bucket_id) в режиме только для чтения "
#~ "(аналогично вызову vshard.router.call в режиме mode='read'). Для получения "
#~ "подробной информации о работе функции см. раздел :ref:`Обработка запросов "
#~ "<vshard-process-requests>`."

#~ msgid ""
#~ "* ``timeout`` – a request timeout, in seconds. In case the ``router`` cannot"
#~ " identify a   shard with the bucket id, the operation will be repeated until"
#~ " the   timeout is reached.  * other :ref:`net.box options <net_box-"
#~ "options>`, such as ``is_async``,   ``buffer``, ``on_push`` are also "
#~ "supported."
#~ msgstr ""
#~ "* ``timeout`` -- время ожидания запроса в секундах. Если ``роутер`` не может"
#~ " определить шард с идентификатором сегмента, операция повторяется до "
#~ "истечения времени ожидания."

#~ msgid ""
#~ "``timeout`` – a request timeout, in seconds. In case the ``router`` cannot "
#~ "identify a shard with the bucket id, the operation will be repeated until "
#~ "the timeout is reached."
#~ msgstr ""
#~ "``timeout`` -- время ожидания запроса в секундах. Если ``роутер`` не может "
#~ "определить шард с идентификатором сегмента, операция повторяется до "
#~ "истечения времени ожидания."

#~ msgid ""
#~ "``ShardingError`` is returned on errors specific for sharding: the replica "
#~ "set is not available, the master is missing, wrong bucket id, etc. It has an"
#~ " attribute code containing one of the values from the "
#~ "``vshard.error.code.*`` LUA table, an optional attribute containing a "
#~ "message with the human-readable error description, and other attributes "
#~ "specific for this error code."
#~ msgstr ""
#~ "``ShardingError`` возвращается в случае ошибок шардинга: набор реплик "
#~ "недоступен, отсутствует мастер, неверный идентификатор сегмента и т.д. Такая"
#~ " ошибка сб.одержит код с одним из значений из Lua-таблицы "
#~ "``vshard.error.code.*``, необязательный атрибут сообщения с удобным для "
#~ "восприятия описанием ошибки и другие атрибуты, специфичные для данного кода "
#~ "ошибки."

#~ msgid ""
#~ "Call the function identified by function-name on the shard storing the "
#~ "bucket identified by bucket_id, in read-write mode (similar to calling "
#~ "vshard.router.call with mode='write'). See the :ref:`Processing requests "
#~ "<vshard-process-requests>` section for details on function operation."
#~ msgstr ""
#~ "Вызов функции по имени функции (function-name) на шарде, где хранится "
#~ "сегмент с указанным идентификатором (bucket_id) в режиме чтения и записи "
#~ "(аналогично вызову vshard.router.call в режиме mode='write'). Для получения "
#~ "подробной информации о работе функции см. раздел :ref:`Обработка запросов "
#~ "<vshard-process-requests>`."

#~ msgid ""
#~ "Call the function identified by function-name on the shard storing the "
#~ "bucket identified by bucket_id, in read-only mode (similar to calling "
#~ "``vshard.router.call`` with ``mode='read'``), with preference for a replica "
#~ "rather than a master (similar to calling ``vshard.router.call`` with "
#~ "``prefer_replica = true``). See the :ref:`Processing requests <vshard-"
#~ "process-requests>` section for details on function operation."
#~ msgstr ""
#~ "Вызов функции по имени функции (function-name) на шарде, где хранится "
#~ "сегмент с указанным идентификатором (bucket_id) в режиме только для чтения "
#~ "(аналогично вызову ``vshard.router.call`` в режиме чтения ``mode='read'``), "
#~ "когда предпочтение отдается реплике, а не мастеру (аналогично вызову "
#~ "``vshard.router.call`` с параметром ``prefer_replica = true``). Для "
#~ "получения подробной информации о работе функции см. раздел :ref:`Обработка "
#~ "запросов <vshard-process-requests>`."

#~ msgid ""
#~ "This has the same effect as :ref:`vshard.router.call() <router_api-call>` "
#~ "with mode parameter = ``{mode='read', balance=true}``."
#~ msgstr ""
#~ "Эквивалент :ref:`vshard.router.call() <router_api-call>` с параметром mode ="
#~ " ``{mode='read', balance=true}``."

#~ msgid ""
#~ "This has the same effect as :ref:`vshard.router.call() <router_api-call>` "
#~ "with mode parameter = ``{mode='read', balance=true, prefer_replica=true}``."
#~ msgstr ""
#~ "Эквивалент :ref:`vshard.router.call() <router_api-call>` с параметром режима"
#~ " mode = ``{mode='read', balance=true, prefer_replica=true}``."

#~ msgid ""
#~ "Return the replica set object for the bucket with the specified bucket id "
#~ "value."
#~ msgstr ""
#~ "Возврат объекта набора реплик для сегмента с указанным значением "
#~ "идентификатора сегмента (bucket id)."

#~ msgid "a replica set object"
#~ msgstr "объект набора реплик"

#~ msgid "replicaset = vshard.router.route(123)"
#~ msgstr "replicaset = vshard.router.route(123)"

#~ msgid "Return all available replica set objects."
#~ msgstr "Возврат всех доступных объектов наборов реплик."

#~ msgid "a map of the following type: ``{UUID = replicaset}``"
#~ msgstr "ассоциативный массив следующего вида: ``{UUID = replicaset}``"

#~ msgid "Rtype"
#~ msgstr "Тип возвращаемого значения"

#~ msgid "a map of replica set objects"
#~ msgstr "ассоциативный массив объектов набора реплик"

#~ msgid ""
#~ "function selectall()\n"
#~ "    local resultset = {}\n"
#~ "    shards, err = vshard.router.routeall()\n"
#~ "    if err ~= nil then\n"
#~ "        error(err)\n"
#~ "    end\n"
#~ "    for uid, replica in pairs(shards) do\n"
#~ "        local set = replica:callro('box.space.*space-name*:select', {{}, {limit=10}}, {timeout=5})\n"
#~ "        for _, item in ipairs(set) do\n"
#~ "            table.insert(resultset, item)\n"
#~ "        end\n"
#~ "    end\n"
#~ "    table.sort(resultset, function(a, b) return a[1] < b[1] end)\n"
#~ "    return resultset\n"
#~ "end"
#~ msgstr ""

#~ msgid ""
#~ "**Deprecated**. Logs a warning when used because it is not consistent for "
#~ "cdata numbers."
#~ msgstr ""
#~ "**Объявлено устаревшим**. Записывает в журнал предупреждение при "
#~ "использовании, так как не согласуется с числами cdata."

#~ msgid ""
#~ "In particular, it returns 3 different values for normal Lua numbers like "
#~ "123, for unsigned long long cdata (like ``123ULL``, or ``ffi.cast('unsigned "
#~ "long long',123)``), and for signed long long cdata (like ``123LL``, or "
#~ "``ffi.cast('long long', 123)``). And it is important."
#~ msgstr ""
#~ "В частности, возвращает 3 различных значения для обычных чисел Lua, таких "
#~ "как 123, для unsigned long long cdata (например ``123ULL``, или "
#~ "``ffi.cast('unsigned long long',123))``, и для signed long long cdata "
#~ "(например ``123LL``, или ``ffi.cast('long long', 123)``). И это важно."

#~ msgid ""
#~ "vshard.router.bucket_id(123)\n"
#~ "vshard.router.bucket_id(123LL)\n"
#~ "vshard.router.bucket_id(123ULL)"
#~ msgstr ""

#~ msgid ""
#~ "For float and double cdata (``ffi.cast('float', number)``, "
#~ "``ffi.cast('double', number)``) these functions return different values even"
#~ " for the same numbers of the same floating point type. This is because "
#~ "``tostring()`` on a floating point cdata number returns not the number, but "
#~ "a pointer at it. Different on each call."
#~ msgstr ""
#~ "Для float и double cdata (``ffi.cast('float', number)``, "
#~ "``ffi.cast('double', number)``) эти функции возвращают разные значения даже "
#~ "для тех же чисел того же типа с плавающей точкой. Это связано с тем, что "
#~ "функция  ``tostring()`` для числа cdata с плавающей точкой возвращает не "
#~ "число, а указатель на него. Разное при каждом вызове."

#~ msgid ""
#~ "``vshard.router.bucket_id_strcrc32()`` behaves exactly the same, but does "
#~ "not log a warning. In case you need that behavior."
#~ msgstr ""
#~ "``vshard.router.bucket_id_strcrc32()`` имеет такое же поведение, но не "
#~ "записывает предупреждение. Для случаев, когда такое поведение действительно "
#~ "необходимо."

#~ msgid "Calculate the bucket id using a simple built-in hash function."
#~ msgstr ""
#~ "Вычисление идентификатора сегмента с помощью простой встроенной хеш-функции."

#~ msgid "a hash key. This can be any Lua object (number, table, string)."
#~ msgstr "хеш-ключ. Это может быть любой Lua-объект (число, таблица, строка)."

#~ msgid "number"
#~ msgstr "число"

#~ msgid ""
#~ "tarantool> vshard.router.bucket_count()\n"
#~ "---\n"
#~ "- 3000\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> vshard.router.bucket_id_strcrc32(\"18374927634039\")\n"
#~ "---\n"
#~ "- 2032\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> vshard.router.bucket_id_strcrc32(18374927634039)\n"
#~ "---\n"
#~ "- 2032\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> vshard.router.bucket_id_strcrc32(\"test\")\n"
#~ "---\n"
#~ "- 1216\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> vshard.router.bucket_id_strcrc32(\"other\")\n"
#~ "---\n"
#~ "- 2284\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "Remember that it is not safe. See details in :ref:`bucket_id() <router_api-"
#~ "bucket_id>`"
#~ msgstr ""
#~ "Помните, что это небезопасно. См. :ref:`bucket_id() <router_api-bucket_id>`"

#~ msgid ""
#~ "This function is safer than ``bucket_id_strcrc32``. It takes a CRC32 from a "
#~ "MessagePack encoded value. That is, bucket id of integers does not depend on"
#~ " their Lua type. In case of a string key, it does not encode it into "
#~ "MessagePack, but takes a hash right from the string."
#~ msgstr ""
#~ "Эта функция безопаснее, чем bucket_id_strc32. Она берет CRC32 из "
#~ "кодированного значения MessagePack. То есть bucket id целых чисел не зависит"
#~ " от их типа Lua. В случае строкового ключа, он не кодирует его в "
#~ "MessagePack, а берет хэш прямо из строки."

#~ msgid ""
#~ "However it still may return different values for not equal floating point "
#~ "types. That is, ``ffi.cast('float', number)`` may be reflected into a bucket"
#~ " id not equal to ``ffi.cast('double', number)``. This can't be fixed, "
#~ "because a float value, even being casted to double, may have a garbage tail "
#~ "in its fraction."
#~ msgstr ""
#~ "Однако он все равно может возвращать разные значения для не одинакового типа"
#~ " с плавающей точкой. То есть, ``ffi.cast('float', number)`` может быть "
#~ "отражено в bucket id, не равном ``ffi.cast('double', number)``. Это не может"
#~ " быть исправлено, так как значение с плавающей точкой, даже будучи "
#~ "приведенным к double, может иметь мусор в своей дробной части."

#~ msgid ""
#~ "Floating point keys should not be used to calculate a bucket id, usually."
#~ msgstr ""
#~ "Ключи с плавающей точкой обычно не должны использоваться для вычисления "
#~ "идентификатора сегмента."

#~ msgid ""
#~ "Be very careful in case you store floating point types in a space. When data"
#~ " is returned from a space, it is cast to Lua number. And if that value had "
#~ "an empty fraction part, it will be treated as an integer by "
#~ "``bucket_id_mpcrc32()``. So you need to do explicit casts in such cases. "
#~ "Here is an example of the problem:"
#~ msgstr ""
#~ "Будьте очень осторожны, если вы храните типы с плавающей точкой в спейсе. "
#~ "Когда данные возвращаются из спейса, они приводятся к Lua числам. А если это"
#~ " значение имело пустую дробную часть, то оно будет обработано как целое "
#~ "число функцией ``bucket_id_mpcrc32()``. Поэтому в таких случаях необходимо "
#~ "выполнять явное приведение. Приведем пример проблемы:"

#~ msgid ""
#~ "tarantool> s = box.schema.create_space('test', {format = {{'id', 'double'}}}); _ = s:create_index('pk')\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> inserted = ffi.cast('double', 1)\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "-- Value is stored as double\n"
#~ "tarantool> s:replace({inserted})\n"
#~ "---\n"
#~ "- [1]\n"
#~ "...\n"
#~ "\n"
#~ "-- But when returned to Lua, stored as Lua number, not cdata.\n"
#~ "tarantool> returned = s:get({inserted}).id\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> type(returned), returned\n"
#~ "---\n"
#~ "- number\n"
#~ "- 1\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> vshard.router.bucket_id_mpcrc32(inserted)\n"
#~ "---\n"
#~ "- 1411\n"
#~ "...\n"
#~ "tarantool> vshard.router.bucket_id_mpcrc32(returned)\n"
#~ "---\n"
#~ "- 1614\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "Return the total number of buckets specified in ``vshard.router.cfg()``."
#~ msgstr ""
#~ "Возврат общего количества сегментов, указанных в `vshard.router.cfg()``."

#~ msgid "the total number of buckets"
#~ msgstr "общее количество сегментов"

#~ msgid ""
#~ "tarantool> vshard.router.bucket_count()\n"
#~ "---\n"
#~ "- 10000\n"
#~ "..."
#~ msgstr ""

#~ msgid "Wait until the dataset is synchronized on replicas."
#~ msgstr "Ожидание синхронизации набора данных на репликах."

#~ msgid "a timeout, in seconds"
#~ msgstr "время ожидания в секундах"

#~ msgid "return"
#~ msgstr "возвращает"

#~ msgid ""
#~ "``true`` if the dataset was synchronized successfully; or ``nil`` and "
#~ "``err`` explaining why the dataset cannot be synchronized."
#~ msgstr ""
#~ "``true`` (правда), если выполнена синхронизация набора данных; или же "
#~ "``nil`` и ошибка ``err`` с объяснением причины невозможности синхронизации "
#~ "набора данных."

#~ msgid "Force wakeup of the bucket discovery fiber."
#~ msgstr "Принудительный запуск файбера обнаружения сегментов."

#~ msgid ""
#~ "Turn on/off the background discovery fiber used by the router to find "
#~ "buckets."
#~ msgstr ""
#~ "Запуск/выключение фонового файбера, используемого роутером для обнаружения "
#~ "сегментов."

#~ msgid ""
#~ "working mode of a discovery fiber. There are three modes: ``on``, ``off`` "
#~ "and ``once``"
#~ msgstr ""
#~ "режим работы файбера обнаружения. Существует три режима: ``on``, ``off`` и "
#~ "``once``"

#~ msgid ""
#~ "When the mode is ``on`` (default), the discovery fiber works during all the "
#~ "lifetime of the router. Even after all buckets are discovered, it will still"
#~ " come to storages and download their buckets with some big period "
#~ "(`DISCOVERY_IDLE_INTERVAL "
#~ "<https://github.com/tarantool/vshard/blob/master/vshard/consts.lua>`_). This"
#~ " is useful if the bucket topology changes often and the number of buckets is"
#~ " not big. The router will keep its route table up to date even when no "
#~ "requests are processed."
#~ msgstr ""
#~ "В режиме ``on`` (по умолчанию) файбер обнаружения работает в течение всего "
#~ "жизненного цикла роутера. Даже после того, как все сегменты были найдены, он"
#~ " продолжает проверять хранилища и загружать сегменты с некоторой большой "
#~ "периодичностью (`DISCOVERY_IDLE_INTERVAL "
#~ "<https://github.com/tarantool/vshard/blob/master/vshard/consts.lua>`_). Это "
#~ "полезно, если топология сегментов часто меняется, а их число небольшое. "
#~ "Роутер будет поддерживать свою таблицу маршрутов в актуальном состоянии даже"
#~ " тогда, когда никакие запросы не обрабатываются."

#~ msgid "When the mode is ``off``, discovery is disabled completely."
#~ msgstr "В режиме ``off`` обнаружение сегментов не производится."

#~ msgid ""
#~ "When the mode is ``once``, discovery starts and finds the locations of all "
#~ "buckets, and then the discovery fiber is terminated. This is good for a "
#~ "large bucket count and for clusters, where rebalancing is rare."
#~ msgstr ""
#~ "В режиме ``once`` файбер обнаружения найдет локации всех сегментов, а затем "
#~ "ликвидируется. Это полезно для большого числа сегментов и для кластеров, в "
#~ "которых редко происходит балансировка."

#~ msgid ""
#~ "The method is good to enable/disable discovery after the router is already "
#~ "started, but discovery is enabled by default. You may want to never enable "
#~ "it even for a short time -- then specify the ``discovery_mode`` option in "
#~ "the :ref:`configuration <cfg_basic-discovery_mode>`. It takes the same "
#~ "values as :samp:`vshard.router.discovery_set({mode})`."
#~ msgstr ""
#~ "Этот метод подойдет для включения/выключения обнаружения после того, как "
#~ "роутер уже запущен, но по умолчанию обнаружение включено. Возможно, вы "
#~ "захотите никогда не включать его даже на короткое время -- тогда задайте "
#~ "значение опции ``discovery_mode`` при :ref:`конфигурации <cfg_basic-"
#~ "discovery_mode>`. Она принимает те же значения, что и "
#~ ":samp:`vshard.router.discovery_set({mode})`."

#~ msgid ""
#~ "You may decide to turn off discovery or make it ``once`` if you have many "
#~ "routers, or tons of buckets (hundreds of thousands and more), and you see "
#~ "that the discovery process consumes notable CPU % on routers and storages. "
#~ "In that case it may be wise to turn off the discovery when there is no "
#~ "rebalancing in the cluster. And turn it on for new routers, as well as for "
#~ "all routers when rebalancing is started."
#~ msgstr ""
#~ "Вы можете решить, что лучше отключить обнаружение или осуществить его в "
#~ "режиме ``once``, если у вас много роутеров или очень много сегментов (сотни "
#~ "тысяч и более), и вы видите, что процесс обнаружения потребляет заметное "
#~ "количество ресурса CPU на роутерах и хранилищах. В этом случае, возможно, "
#~ "было бы разумно отключить обнаружение, когда в кластере нет балансировки. И "
#~ "включать его для новых роутеров, а также для всех роутеров, когда начинается"
#~ " балансировка."

#~ msgid "Return information about each instance."
#~ msgstr "Возврат информации по каждому экземпляру."

#~ msgid "Replica set parameters:"
#~ msgstr "Параметры набора реплик:"

#~ msgid "replica set uuid"
#~ msgstr "UUID набора реплик"

#~ msgid "master instance parameters"
#~ msgstr "параметры мастер-экземпляра"

#~ msgid "replica instance parameters"
#~ msgstr "параметры реплики"

#~ msgid "Instance parameters:"
#~ msgstr "Параметры экземпляра:"

#~ msgid "``uri`` — URI of the instance"
#~ msgstr "``uri`` -- URI экземпляра"

#~ msgid "``uuid`` — UUID of the instance"
#~ msgstr "``uuid`` -- UUID экземпляра"

#~ msgid ""
#~ "``status`` – status of the instance (``available``, ``unreachable``, "
#~ "``missing``)"
#~ msgstr ""
#~ "``status`` -- статус экземпляра: ``available`` (доступный), ``unreachable`` "
#~ "(недоступный), ``missing`` (отсутствующий)"

#~ msgid ""
#~ "``network_timeout`` – a timeout for the request. The value is updated "
#~ "automatically on each 10th successful request and each 2nd failed request."
#~ msgstr ""
#~ "``network_timeout`` -- время ожидания запроса. Данное значение обновляется "
#~ "автоматически на каждом 10 выполненном запросе и на каждом 2 невыполненном "
#~ "запросе."

#~ msgid "Bucket parameters:"
#~ msgstr "Параметры сегмента:"

#~ msgid ""
#~ "``available_ro`` – the number of buckets known to the ``router`` and "
#~ "available for read requests"
#~ msgstr ""
#~ "``available_ro`` -- количество сегментов, известных роутеру и доступных для "
#~ "запросов чтения"

#~ msgid ""
#~ "``available_rw`` – the number of buckets known to the ``router`` and "
#~ "available for read and write requests"
#~ msgstr ""
#~ "``available_rw`` -- количество сегментов, известных роутеру и доступных для "
#~ "запросов чтения и записи"

#~ msgid ""
#~ "``unavailable`` – the number of buckets known to the ``router`` but "
#~ "unavailable for any requests"
#~ msgstr ""
#~ "``unavailable`` -- количество сегментов, известных роутеру, но недоступных "
#~ "для любых запросов"

#~ msgid ""
#~ "``unreachable`` – the number of buckets whose replica sets are not known to "
#~ "the ``router``"
#~ msgstr ""
#~ "``unreachable``-- количество сегментов, для которых роутер не знает "
#~ "соответствующие наборы реплик"

#~ msgid ""
#~ "tarantool> vshard.router.info()\n"
#~ "---\n"
#~ "- replicasets:\n"
#~ "    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
#~ "      replica: &0\n"
#~ "        network_timeout: 0.5\n"
#~ "        status: available\n"
#~ "        uri: storage@127.0.0.1:3303\n"
#~ "        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
#~ "      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
#~ "      master: *0\n"
#~ "    cbf06940-0790-498b-948d-042b62cf3d29:\n"
#~ "      replica: &1\n"
#~ "        network_timeout: 0.5\n"
#~ "        status: available\n"
#~ "        uri: storage@127.0.0.1:3301\n"
#~ "        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
#~ "      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
#~ "      master: *1\n"
#~ "  bucket:\n"
#~ "    unreachable: 0\n"
#~ "    available_ro: 0\n"
#~ "    unknown: 0\n"
#~ "    available_rw: 3000\n"
#~ "  status: 0\n"
#~ "  alerts: []\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> vshard.router.info()\n"
#~ "---\n"
#~ "- replicasets:\n"
#~ "    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
#~ "      replica: &0\n"
#~ "        network_timeout: 0.5\n"
#~ "        status: available\n"
#~ "        uri: storage@127.0.0.1:3303\n"
#~ "        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
#~ "      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
#~ "      master: *0\n"
#~ "    cbf06940-0790-498b-948d-042b62cf3d29:\n"
#~ "      replica: &1\n"
#~ "        network_timeout: 0.5\n"
#~ "        status: available\n"
#~ "        uri: storage@127.0.0.1:3301\n"
#~ "        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
#~ "      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
#~ "      master: *1\n"
#~ "  bucket:\n"
#~ "    unreachable: 0\n"
#~ "    available_ro: 0\n"
#~ "    unknown: 0\n"
#~ "    available_rw: 3000\n"
#~ "  status: 0\n"
#~ "  alerts: []\n"
#~ "..."

#~ msgid ""
#~ "Return information about each bucket. Since a bucket map can be huge, only "
#~ "the required range of buckets can be specified."
#~ msgstr ""
#~ "Возврат информации по каждому сегменту. Поскольку массив сегментов может "
#~ "быть огромен, можно указать только необходимый ряд сегментов."

#~ msgid "the offset in a bucket map of the first bucket to show"
#~ msgstr "начальное значение выборки сегментов"

#~ msgid "the maximum number of buckets to show"
#~ msgstr "максимальное количество показываемых сегментов"

#~ msgid ""
#~ "a map of the following type: ``{bucket_id = 'unknown'/replicaset_uuid}``"
#~ msgstr ""
#~ "ассоциативный массив следующего вида: ``{bucket_id = "
#~ "'unknown'/replicaset_uuid}``"

#~ msgid ""
#~ "tarantool> vshard.router.buckets_info()\n"
#~ "---\n"
#~ "- - uuid: aaaaaaaa-0000-4000-a000-000000000000\n"
#~ "    status: available_rw\n"
#~ "  - uuid: aaaaaaaa-0000-4000-a000-000000000000\n"
#~ "    status: available_rw\n"
#~ "  - uuid: aaaaaaaa-0000-4000-a000-000000000000\n"
#~ "    status: available_rw\n"
#~ "  - uuid: bbbbbbbb-0000-4000-a000-000000000000\n"
#~ "    status: available_rw\n"
#~ "  - uuid: bbbbbbbb-0000-4000-a000-000000000000\n"
#~ "    status: available_rw\n"
#~ "  - uuid: bbbbbbbb-0000-4000-a000-000000000000\n"
#~ "    status: available_rw\n"
#~ "  - uuid: bbbbbbbb-0000-4000-a000-000000000000\n"
#~ "    status: available_rw\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "Call a function on a nearest available master (distances are defined using "
#~ "``replica.zone`` and ``cfg.weights`` matrix) with specified arguments."
#~ msgstr ""
#~ "Вызов функции с указанными аргументами на ближайшем доступном мастере "
#~ "(расстояние определяется с помощью матрицы ``replica.zone`` и "
#~ "``cfg.weights``)."

#~ msgid ""
#~ "The ``replicaset_object:call`` method is similar to "
#~ "``replicaset_object:callrw``."
#~ msgstr ""
#~ "Метод ``replicaset_object:call`` аналогичен ``replicaset_object:callrw``."

#~ msgid "function to execute"
#~ msgstr "выполняемая функция"

#~ msgid "array of the function's arguments"
#~ msgstr "массив аргументов функции"

#~ msgid "result of ``function_name`` on success"
#~ msgstr "результат вызываемой функции при успехе"

#~ msgid "nil, err otherwise"
#~ msgstr "nil, err иначе"

#~ msgid ""
#~ "Call a function on a nearest available master (distances are defined using "
#~ "``replica.zone`` and ``cfg.weights`` matrix) with a specified arguments."
#~ msgstr ""
#~ "Вызов функции с указанными аргументами на ближайшем доступном мастере "
#~ "(расстояние определяется с помощью матрицы ``replica.zone`` и "
#~ "``cfg.weights``)."

#~ msgid ""
#~ "The ``replicaset_object:callrw`` method is similar to "
#~ "``replicaset_object:call``."
#~ msgstr ""
#~ "Метод ``replicaset_object:callrw`` аналогичен ``replicaset_object:call``."

#~ msgid ""
#~ "tarantool> local bucket = 1; return vshard.router.callrw(\n"
#~ "         >     bucket,\n"
#~ "         >     'box.space.actors:insert',\n"
#~ "         >     {{\n"
#~ "         >         1, bucket, 'Renata Litvinova',\n"
#~ "         >         {theatre=\"Moscow Art Theatre\"}\n"
#~ "         >     }},\n"
#~ "         >     {timeout=5}\n"
#~ "         > )"
#~ msgstr ""

#~ msgid ""
#~ "Call a function on the nearest available replica (distances are defined "
#~ "using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments."
#~ " It is recommended to use ``replicaset_object:callro()`` for calling only "
#~ "read-only functions, as the called functions can be executed not only on a "
#~ "master, but also on replicas."
#~ msgstr ""
#~ "Вызов функции с указанными аргументами на ближайшей доступной реплике "
#~ "(расстояние определяется с помощью матрицы ``replica.zone`` и "
#~ "``cfg.weights``). С помощью ``replicaset_object:callro()`` рекомендуется "
#~ "вызывать исключительно функции, доступные только для чтения. поскольку такие"
#~ " функции можно выполнять не только на мастере, но и на репликах."

#~ msgid ""
#~ "Call a function on the nearest available replica (distances are defined "
#~ "using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments,"
#~ " with preference for a replica rather than a master (similar to calling "
#~ "``vshard.router.call`` with ``prefer_replica = true``). It is recommended to"
#~ " use ``replicaset_object:callre()`` for calling only read-only functions, as"
#~ " the called function can be executed not only on a master, but also on "
#~ "replicas."
#~ msgstr ""
#~ "Вызов функции с указанными аргументами на ближайшей доступной реплике "
#~ "(расстояние определяется с помощью матрицы ``replica.zone`` и "
#~ "``cfg.weights``), предпочтение отдается реплике, а не мастеру (аналогично "
#~ "вызову vshard.router.call с параметром prefer_replica = true). С помощью "
#~ "``replicaset_object:callre()`` рекомендуется вызывать исключительно функции,"
#~ " доступные только для чтения, поскольку такие функции можно выполнять не "
#~ "только на мастере, но и на репликах."

#~ msgid "Router internal API"
#~ msgstr "Внутренний API роутера"

#~ msgid ""
#~ "Search for the bucket in the whole cluster. If the bucket is not found, it "
#~ "is likely that it does not exist. The bucket might also be moved during "
#~ "rebalancing and currently is in the RECEIVING state."
#~ msgstr ""
#~ "Поиск сегмента по всему кластеру. Если сегмент не обнаружен, скорее всего, "
#~ "он не существует. Также сегмент также может быть перемещен во время "
#~ "балансировки и в данный момент находится в статусе получения RECEIVING."

#~ msgid "Storage public API"
#~ msgstr "Общедоступный API хранилища"

#~ msgid ""
#~ "Configure the database and start sharding for the specified ``storage`` "
#~ "instance."
#~ msgstr ""
#~ "Конфигурация базы данных и начало шардинга на указанном экземпляре "
#~ "хранилища."

#~ msgid "a ``storage`` configuration"
#~ msgstr "конфигурация хранилища"

#~ msgid "UUID of the instance"
#~ msgstr "UUID экземпляра"

#~ msgid "Return information about the storage instance in the following format:"
#~ msgstr "Возврат информации по экземпляру хранилища в следующем формате:"

#~ msgid ""
#~ "tarantool> vshard.storage.info()\n"
#~ "---\n"
#~ "- buckets:\n"
#~ "    2995:\n"
#~ "      status: active\n"
#~ "      id: 2995\n"
#~ "    2997:\n"
#~ "      status: active\n"
#~ "      id: 2997\n"
#~ "    2999:\n"
#~ "      status: active\n"
#~ "      id: 2999\n"
#~ "  replicasets:\n"
#~ "    2dd0a343-624e-4d3a-861d-f45efc571cd3:\n"
#~ "      uuid: 2dd0a343-624e-4d3a-861d-f45efc571cd3\n"
#~ "      master:\n"
#~ "        state: active\n"
#~ "        uri: storage:storage@127.0.0.1:3301\n"
#~ "        uuid: 2ec29309-17b6-43df-ab07-b528e1243a79\n"
#~ "    c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1:\n"
#~ "      uuid: c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1\n"
#~ "      master:\n"
#~ "        state: active\n"
#~ "        uri: storage:storage@127.0.0.1:3303\n"
#~ "        uuid: 810d85ef-4ce4-4066-9896-3c352fec9e64\n"
#~ "..."
#~ msgstr ""

#~ msgid "Call the specified function on the current ``storage`` instance."
#~ msgstr "Вызов указанной функции на текущем экземпляре хранилища."

#~ msgid "a type of the function: 'read' or 'write'"
#~ msgstr "тип функции: 'read' или 'write' (чтение или запись)"

#~ msgid ""
#~ "The original return value of the executed function, or ``nil`` and error "
#~ "object."
#~ msgstr ""
#~ "Исходное возвращаемое значение выполняемой функции или ``nil`` и ошибка."

#~ msgid ""
#~ "Pin a bucket to a replica set. A pinned bucket cannot be moved even if it "
#~ "breaks the cluster balance."
#~ msgstr ""
#~ "Закрепление сегмента в наборе реплик. Закрепленный сегмент нельзя "
#~ "перемещать, даже если это нарушает баланс в кластере."

#~ msgid ""
#~ "``true`` if the bucket is pinned successfully; or ``nil`` and ``err`` "
#~ "explaining why the bucket cannot be pinned"
#~ msgstr ""
#~ "``true`` (правда), если выполнено закрепление сегмента; или же ``nil`` и "
#~ "ошибка ``err`` с объяснением причины невозможности закрепления сегмента"

#~ msgid "Return a pinned bucket back into the active state."
#~ msgstr "Возврат закрепленного сегмента в активное состояние."

#~ msgid ""
#~ "``true`` if the bucket is unpinned successfully; or ``nil`` and ``err`` "
#~ "explaining why the bucket cannot be unpinned"
#~ msgstr ""
#~ "``true`` (правда), если выполнено открепление сегмента; или же ``nil`` и "
#~ "ошибка ``err`` с объяснением причины невозможности открепления сегмента"

#~ msgid "Create an RO or RW :ref:`ref <vshard-ref>`."
#~ msgstr "Создание :ref:`ссылки <vshard-ref>` типа RO или RW."

#~ msgid "'read' or 'write'"
#~ msgstr "'read' или 'write' (чтение или запись)"

#~ msgid ""
#~ "``true`` if the bucket ref is created successfully; or ``nil`` and ``err`` "
#~ "explaining why the ref cannot be created"
#~ msgstr ""
#~ "``true`` (правда), если выполнено создание ссылки; или же ``nil`` и ошибка "
#~ "``err`` с объяснением причины невозможности создания ссылки"

#~ msgid ""
#~ "An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in "
#~ "the RO mode."
#~ msgstr ""
#~ "Псевдоним для :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` в "
#~ "режиме только чтения."

#~ msgid ""
#~ "An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in "
#~ "the RW mode."
#~ msgstr ""
#~ "Псевдоним для :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` в "
#~ "режиме чтения и записи."

#~ msgid "Remove a RO/RW :ref:`ref <vshard-ref>`."
#~ msgstr "Удаление :ref:`ссылки <vshard-ref>` RO/RW."

#~ msgid ""
#~ "``true`` if the bucket ref is removed successfully; or ``nil`` and ``err`` "
#~ "explaining why the ref cannot be removed"
#~ msgstr ""
#~ "``true`` (правда), если выполнено удаление ссылки; или же ``nil`` и ошибка "
#~ "``err`` с объяснением причины невозможности удаления ссылки"

#~ msgid ""
#~ "An alias for :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` "
#~ "in the RO mode."
#~ msgstr ""
#~ "Псевдоним для :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` "
#~ "в режиме только чтения."

#~ msgid ""
#~ "An alias for :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` "
#~ "in the RW mode."
#~ msgstr ""
#~ "Псевдоним для :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` "
#~ "в режиме чтения и записи."

#~ msgid ""
#~ "Find a bucket which has data in a space but is not stored in a ``_bucket`` "
#~ "space; or is in a GARBAGE state."
#~ msgstr ""
#~ "Поиск сегмента, который хранит данные в спейсе, но не указан в спейсе "
#~ "``_bucket``, или находится в статусе мусора (GARBAGE)."

#~ msgid "index of a space with the part of a bucket id"
#~ msgstr "индекс спейса с частью идентификатора спейса"

#~ msgid ""
#~ "a garbage collector controller. If there is an increased buckets generation,"
#~ " then the search should be interrupted."
#~ msgstr ""
#~ "контроллер сборщика мусора. Если увеличивается масштаб создания сегментов, "
#~ "поиск следует прервать."

#~ msgid ""
#~ "an identifier of the bucket in the garbage state, if found; otherwise, nil"
#~ msgstr ""
#~ "идентификатор сегмента в статусе мусора, если таковой обнаружен; в противном"
#~ " случае, nil"

#~ msgid "Return information about each bucket located in storage. For example:"
#~ msgstr ""
#~ "Возврат информации по каждому сегменту, расположенному в хранилище. "
#~ "Например:"

#~ msgid ""
#~ "tarantool> vshard.storage.buckets_info(1)\n"
#~ "---\n"
#~ "- 1:\n"
#~ "    status: active\n"
#~ "    ref_rw: 1\n"
#~ "    ref_ro: 1\n"
#~ "    ro_lock: true\n"
#~ "    rw_lock: true\n"
#~ "    id: 1"
#~ msgstr ""

#~ msgid "Return the number of buckets located in storage."
#~ msgstr "Возврат количества сегментов, расположенных в хранилище."

#~ msgid "Immediately wake up a recovery fiber, if it exists."
#~ msgstr "Немедленный запуск файбера восстановления, если такой есть."

#~ msgid ""
#~ "Return a flag indicating whether rebalancing is in progress. The result is "
#~ "true if the node is currently applying routes received from a rebalancer "
#~ "node in the special fiber."
#~ msgstr ""
#~ "Возврат флага, указывающего на ход процесса балансировки. Результатом будет "
#~ "true (правда), если в данный момент узел применяет маршруты, полученные от "
#~ "узла балансировки в специальном файбере."

#~ msgid ""
#~ "Return a flag indicating whether storage is invisible to the rebalancer."
#~ msgstr ""
#~ "Возврат флага, указывающего на недоступность хранилища для балансировщика."

#~ msgid ""
#~ "Disable rebalancing. A disabled rebalancer sleeps until it is enabled again "
#~ "with vshard.storage.rebalancer_enable()."
#~ msgstr ""
#~ "Отключение балансировки. Отключенный балансировщик находится в режиме "
#~ "ожидания до повторного запуска с помощью vshard.storage.rebalancer_enable()."

#~ msgid "Enable rebalancing."
#~ msgstr "Запуск балансировки."

#~ msgid ""
#~ "Show the spaces that are visible to rebalancer and garbage collector fibers."
#~ msgstr ""
#~ "Отображение спейсов, которые доступны балансировщику и файберам сборщика "
#~ "мусора."

#~ msgid ""
#~ "tarantool> vshard.storage.sharded_spaces()\n"
#~ "---\n"
#~ "- 513:\n"
#~ "    engine: memtx\n"
#~ "    before_replace: 'function: 0x010e50e738'\n"
#~ "    field_count: 0\n"
#~ "    id: 513\n"
#~ "    on_replace: 'function: 0x010e50e700'\n"
#~ "    temporary: false\n"
#~ "    index:\n"
#~ "      0: &0\n"
#~ "        unique: true\n"
#~ "        parts:\n"
#~ "        - type: number\n"
#~ "          fieldno: 1\n"
#~ "          is_nullable: false\n"
#~ "        id: 0\n"
#~ "        type: TREE\n"
#~ "        name: primary\n"
#~ "        space_id: 513\n"
#~ "      1: &1\n"
#~ "        unique: false\n"
#~ "        parts:\n"
#~ "        - type: number\n"
#~ "          fieldno: 2\n"
#~ "          is_nullable: false\n"
#~ "        id: 1\n"
#~ "        type: TREE\n"
#~ "        name: bucket_id\n"
#~ "        space_id: 513\n"
#~ "      primary: *0\n"
#~ "      bucket_id: *1\n"
#~ "    is_local: false\n"
#~ "    enabled: true\n"
#~ "    name: actors\n"
#~ "    ck_constraint: []\n"
#~ "..."
#~ msgstr ""

#~ msgid "Storage internal API"
#~ msgstr "Внутренний API хранилища"

#~ msgid "Receive a bucket identified by bucket id from a remote replica set."
#~ msgstr ""
#~ "Получение сегмента по идентификатору сегмента (bucket id) из удаленного "
#~ "набора реплик."

#~ msgid "UUID of source replica set"
#~ msgstr "UUID исходного набора реплик"

#~ msgid ""
#~ "data logically stored in a bucket identified by bucket_id, in the same "
#~ "format as the return value from ``bucket_collect() <storage_api-"
#~ "bucket_collect>``"
#~ msgstr ""
#~ "данные, которые хранятся логически в сегменте, определенном по "
#~ "идентификатору сегмента (bucket_id), в том же формате, что и возвращаемое "
#~ "значение метода ``bucket_collect() <storage_api-bucket_collect>``"

#~ msgid "Return information about the bucket id:"
#~ msgstr "Возврат информации об идентификаторе сегмента (bucket id):"

#~ msgid ""
#~ "tarantool> vshard.storage.bucket_stat(1)\n"
#~ "---\n"
#~ "- 0\n"
#~ "- status: active\n"
#~ "  id: 1\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> vshard.storage.bucket_stat(1)\n"
#~ "---\n"
#~ "- 0\n"
#~ "- status: active\n"
#~ "  id: 1\n"
#~ "..."

#~ msgid ""
#~ "Force garbage collection for the bucket identified by bucket_id in case the "
#~ "bucket was transferred to a different replica set."
#~ msgstr ""
#~ "Принудительная сборка мусора для сегмента, найденного по идентификатору "
#~ "(bucket_id), если сегмент был перемещен в другой набор реплик."

#~ msgid ""
#~ "Collect all the data that is logically stored in the bucket identified by "
#~ "bucket_id:"
#~ msgstr ""
#~ "Сбор всех данных, которые хранятся логически в сегменте, найденном по "
#~ "идентификатору (bucket_id):"

#~ msgid ""
#~ "tarantool> vshard.storage.bucket_collect(1)\n"
#~ "---\n"
#~ "- 0\n"
#~ "- - - 514\n"
#~ "    - - [10, 1, 1, 100, 'Account 10']\n"
#~ "      - [11, 1, 1, 100, 'Account 11']\n"
#~ "      - [12, 1, 1, 100, 'Account 12']\n"
#~ "      - [50, 5, 1, 100, 'Account 50']\n"
#~ "      - [51, 5, 1, 100, 'Account 51']\n"
#~ "      - [52, 5, 1, 100, 'Account 52']\n"
#~ "  - - 513\n"
#~ "    - - [1, 1, 'Customer 1']\n"
#~ "      - [5, 1, 'Customer 5']\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> vshard.storage.bucket_collect(1)\n"
#~ "---\n"
#~ "- 0\n"
#~ "- - - 514\n"
#~ "    - - [10, 1, 1, 100, 'Account 10']\n"
#~ "      - [11, 1, 1, 100, 'Account 11']\n"
#~ "      - [12, 1, 1, 100, 'Account 12']\n"
#~ "      - [50, 5, 1, 100, 'Account 50']\n"
#~ "      - [51, 5, 1, 100, 'Account 51']\n"
#~ "      - [52, 5, 1, 100, 'Account 52']\n"
#~ "  - - 513\n"
#~ "    - - [1, 1, 'Customer 1']\n"
#~ "      - [5, 1, 'Customer 5']\n"
#~ "..."

#~ msgid ""
#~ "Force creation of the buckets (single or multiple) on the current replica "
#~ "set. Use only for manual emergency recovery or for initial bootstrap."
#~ msgstr ""
#~ "Принудительное создание сегментов (одного или нескольких) в текущем наборе "
#~ "реплик. Используется только для ручного аварийного восстановления или для "
#~ "начальной настройки."

#~ msgid "an identifier of the first bucket in a range"
#~ msgstr "идентификатор первого сегмента в диапазоне"

#~ msgid "the number of buckets to insert (default = 1)"
#~ msgstr "количество вставляемых сегментов (по умолчанию, 1)"

#~ msgid "Drop a bucket manually for tests or emergency cases."
#~ msgstr "Удаление сегмента вручную для тестирования или в аварийной ситуации."

#~ msgid ""
#~ "Send a specified bucket from the current replica set to a remote replica "
#~ "set."
#~ msgstr ""
#~ "Отправка указанного сегмента из текущего набора реплик в удаленный набор "
#~ "реплик."

#~ msgid "bucket identifier"
#~ msgstr "идентификатор сегмента"

#~ msgid "UUID of a remote replica set"
#~ msgstr "UUID удаленного набора реплик"

#~ msgid ""
#~ "Check all buckets of the host storage that have the SENT or ACTIVE state, "
#~ "return the number of active buckets."
#~ msgstr ""
#~ "Проверка всех сегментов хост-хранилища в статусе отправки SENT или активном "
#~ "статусе ACTIVE, возврат количества активных сегментов."

#~ msgid "the number of buckets in the active state, if found; otherwise, nil"
#~ msgstr ""
#~ "количество сегментов в активном статусе, если таковые обнаружены; в "
#~ "противном случае, nil"

#~ msgid "Collect an array of active bucket identifiers for discovery."
#~ msgstr "Сбор массива идентификаторов активных сегментов для обнаружения."
