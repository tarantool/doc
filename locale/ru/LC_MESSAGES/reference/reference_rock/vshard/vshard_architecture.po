
msgid "Architecture"
msgstr "Архитектура"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"Consider a distributed Tarantool cluster that consists of subclusters called"
" **shards**, each storing some part of data. Each shard, in its turn, "
"constitutes a **replica set** consisting of several **replicas**, one of "
"which serves as a master node that processes all read and write requests."
msgstr ""
"Рассмотрим распределенный Tarantool-кластер, состоящий из подкластеров под "
"названием **шарды**, в каждом из которых хранится некоторая часть данных. "
"Каждый шард, в свою очередь, представляет собой **набор реплик**, одна из "
"которых служит ведущим узлом, обрабатывающим все запросы на чтение и запись."

msgid ""
"The whole dataset is logically partitioned into a predefined number of "
":ref:`virtual buckets <vshard-vbuckets>` (further just **buckets**), each "
"assigned a unique number ranging from 1 to N, where N is the total number of"
" buckets. The number of buckets is specifically chosen to be several orders "
"of magnitude larger than the potential number of cluster nodes, even given "
"future cluster scaling. For example, with M projected nodes the dataset may "
"be split into 100 * M or even 1,000 * M buckets. Care should be taken when "
"picking the number of buckets: if too large, it may require extra memory for"
" storing the routing information; if too small, it may decrease the "
"granularity of rebalancing."
msgstr ""
"Весь набор данных при шардинге распределяется на заданное количество "
":ref:`виртуальных сегментов <vshard-vbuckets>` (далее по тексту просто "
"**сегменты**). Каждому из них присваивается уникальный номер от 1 до N, где "
"N -- это общее количество сегментов. Специально выбирается количество "
"сегментов на несколько порядков больше, чем потенциальное количество "
"кластерных узлов даже с учетом будущего масштабирования кластера. Например, "
"если предполагается M узлов, набор данных может быть разделен на 100 * M или"
" даже 1000 * M сегментов. Особое внимание следует уделить выбору количества "
"сегментов: слишком большое число может потребовать дополнительную память для"
" хранения информации о маршрутизации; слишком маленькое может привести к "
"снижению степени детализации балансировки."

msgid ""
"Each shard stores a unique subset of buckets, which means that a bucket "
"cannot belong to several shards at once, as illustrated below:"
msgstr ""
"Каждый шард хранит уникальное подмножество сегментов. Один сегмент не может "
"относиться к нескольким шардам одновременно, как показано на схеме ниже:"

msgid ""
"This shard-to-bucket mapping is stored in a table in one of Tarantool’s "
"system spaces, with each shard holding only a specific part of the mapping "
"that covers those buckets that were assigned to this shard."
msgstr ""
"Такая схема распределения сегментов по шардам хранится в таблице в одном из "
"системных пространств Tarantool’а, при этом в каждом шарде содержится только"
" определенную часть схемы, которая покрывает присвоенные этому шарду "
"сегменты."

msgid ""
"Apart from the mapping table, the **bucket id** is also stored in a special "
"field of every tuple of every table participating in sharding."
msgstr ""
"Помимо таблицы, **идентификатор сегмента** также хранится в специальном поле"
" каждого кортежа каждой таблицы, участвующей в шардинге."

msgid ""
"Once a shard receives any request (except for SELECT) from an application, "
"this shard checks the bucket id specified in the request against the table "
"of bucket ids that belong to a given node. If the specified bucket id is "
"invalid, the request gets terminated with the following error: “wrong "
"bucket”. Otherwise the request is executed, and all the data created in the "
"process is assigned the bucket id specified in the request. Note that the "
"request should only modify the data that has the same bucket id as the "
"request itself."
msgstr ""
"Как только шард получает любой запрос (за исключением SELECT) от приложения,"
" этот шард сверяет идентификатор сегмента, указанный в запросе, с таблицей "
"идентификаторов сегментов, которые принадлежат данному узлу. Если указанный "
"идентификатор сегмента недействителен, то запрос завершается со следующей "
"ошибкой: \"wrong bucket” (неверный сегмент). В противном случае запрос "
"выполняется, и всем создаваемым данным присваивается указанный в запросе "
"идентификатор сегмента. Обратите внимание, что запрос должен изменять только"
" данные с тем же идентификатором сегмента, что и в запросе."

msgid ""
"Storing bucket ids both in the data itself and the mapping table ensures "
"data consistency regardless of the application logic and makes rebalancing "
"transparent for the application. Storing the mapping table in a system space"
" ensures sharding is performed consistently in case of a failover, as all "
"the replicas in a shard share a common table state."
msgstr ""
"Хранение идентификаторов сегментов как в самих данных, так и в таблице "
"обеспечивает согласованность данных независимо от логики приложения и "
"прозрачность балансировки для приложения. Хранение таблицы соответствий в "
"системном спейсе обеспечивает последовательность шардинга в случае "
"восстановления после отказа, так как у всех реплик в шарде будет одно "
"исходное состояние таблицы."

msgid "Virtual buckets"
msgstr "Виртуальные сегменты"

msgid ""
"The sharded dataset is partitioned into a large number of abstract nodes "
"called **virtual buckets** (further just **buckets**)."
msgstr ""
"Набор данных при шардинге распределяется на большое количество абстрактных "
"узлов, которые называются **виртуальные сегменты** (далее по тексту просто "
"**сегменты**)."

msgid ""
"The dataset is partitioned using the sharding key (or **bucket id**, in "
"Tarantool terminology). Bucket id is a number from 1 to N, where N is the "
"total number of buckets."
msgstr ""
"Секционирование набора данных происходит с помощью сегментного ключа (или "
"**идентификатора сегмента** (bucket id) в терминах Tarantool). "
"Идентификатор сегмента -- это число от 1 до N, где N -- это общее количество"
" сегментов."

msgid ""
"Each replica set stores a unique subset of buckets. One bucket cannot belong"
" to multiple replica sets at a time."
msgstr ""
"В каждом наборе реплик есть уникальное подмножество сегментов. Один сегмент "
"не может относиться к нескольким наборам реплик одновременно."

msgid ""
"The total number of buckets is determined by the administrator who sets up "
"the initial cluster configuration."
msgstr ""
"Общее количество сегментов определяет администратор, который настраивает "
"первоначальную конфигурацию кластера."

msgid ""
"Every space you plan to shard must have a numeric field containing bucket "
"id-s. This field must comply with the following requirements:"
msgstr ""
"В каждом спейсе, который будет разделен на шарды, должно быть числовое поле "
"с идентификаторами сегментов. Это поле должно соответствовать следующим "
"требованиям:"

msgid "The field's data type can be: unsigned, number or integer."
msgstr ""
"Тип данных поля может быть: unsigned (без знака), number (число) или integer"
" (целое число)."

msgid "The field must be not nullable."
msgstr "Поле не должно быть нулевым."

msgid ""
"The field must be indexed by the :ref:`shard_index <cfg_basic-shard_index>`."
" The default name for this index is ``bucket_id``."
msgstr ""
"Поле должно быть проиндексировано с помощью :ref:`shard_index <cfg_basic-"
"shard_index>`. Имя по умолчанию для этого индекса: ``bucket_id``."

msgid "See the :ref:`configuration example <vshard-define-spaces>`."
msgstr "См. :ref:`пример конфигурации <vshard-define-spaces>`."

msgid "Structure"
msgstr "Структура"

msgid "A sharded cluster in Tarantool consists of:"
msgstr "Сегментированный кластер в Tarantool состоит из:"

msgid "storages,"
msgstr "хранилищ,"

msgid "routers,"
msgstr "роутеров"

msgid "and a rebalancer."
msgstr "и балансировщика."

msgid "Storage"
msgstr "Хранилище"

msgid ""
"**Storage** is a node storing a subset of the dataset. Multiple replicated "
"(for redundancy) storages comprise a **replica set** (also called "
"**shard**)."
msgstr ""
"**Хранилище** (storage) -- это узел, который хранит подмножество набора "
"данных. Несколько реплицируемых (для резерва) хранилищ составляют **набор "
"реплик** (также называемый **шардом**)."

msgid ""
"Each storage in a replica set has a role, **master** or **replica**. A "
"master processes read and write requests. A replica processes read requests "
"but cannot process write requests."
msgstr ""
"У каждого хранилища в наборе реплик есть роль: **мастер** или **реплика**. "
"Мастер обрабатывает запросы на чтение и запись. Реплика обрабатывает запросы"
" на чтение, но не может обрабатывать запросы на запись."

msgid "Router"
msgstr "Роутер"

msgid ""
"**Router** is a standalone software component that routes read and write "
"requests from the client application to shards."
msgstr ""
"**Роутер** (router) -- это автономный компонент ПО, который обеспечивает "
"маршрутизацию запросов чтения и записи от клиентского приложения к шардам."

msgid ""
"All requests from the application come to the sharded cluster through a "
"``router``. The ``router`` keeps the topology of a sharded cluster "
"transparent for the application, thus keeping the application unaware of:"
msgstr ""
"Все запросы из приложения приходят в сегментированный кластер через роутер "
"(``router``). Роутер сохраняет топологию сегментированного кластера "
"прозрачной для приложения, не сообщая приложению:"

msgid "the number and location of shards,"
msgstr "номер и местоположение шардов,"

msgid "data rebalancing process,"
msgstr "процесс балансировки данных,"

msgid ""
"the fact and the process of a failover that occurred after a replica's "
"failure."
msgstr "наличие отказа и восстановление после отказа реплики."

msgid ""
"A router can also calculate a bucket id on its own provided that the "
"application clearly defines rules for calculating a bucket id based on the "
"request data. To do it, a router needs to be aware of the data schema."
msgstr ""
"Роутер также может самостоятельно вычислить идентификатор сегмента при "
"условии, что приложение четко определяет правила вычисления идентификатора "
"сегмента на основе данных запроса. Для этого роутеру необходимо знать схему "
"данных."

msgid ""
"The ``router`` does not have a persistent state, nor does it store the "
"cluster topology or balance the data. The ``router`` is a standalone "
"software component that can run in the storage layer or application layer "
"depending on the application features."
msgstr ""
"У роутера нет постоянного статуса, он не хранит топологию кластера и не "
"выполняет балансировку данных. Роутер -- это автономный компонент ПО, "
"который может работать на уровне хранилища или на уровне приложения в "
"зависимости от функций приложения."

msgid ""
"A router maintains a constant pool of connections to all the storages that "
"is created at startup. Creating it this way helps avoid configuration "
"errors. Once a pool is created, a router caches the current state of the "
"``_vbucket`` table to speed up the routing. In case a bucket id is moved to "
"another storage as a result of data rebalancing, or one of the shards fails "
"over to a replica, a router updates the routing table in a way that's "
"transparent for the application."
msgstr ""
"Роутер поддерживает постоянный пул соединений со всеми хранилищами, "
"созданными при запуске, что помогает избежать ошибок конфигурации. После "
"создания пула роутер кэширует текущее состояние таблицы ``_vbucket``, чтобы "
"ускорить маршрутизацию. Если сегмент был перемещен в другое хранилище в "
"результате балансировки, или же один из шардов переключается на реплику, "
"роутер обновит таблицу маршрутизации так, чтобы это было понятно приложению."

msgid ""
"Sharding is not integrated into any centralized configuration storage "
"system. It is assumed that the application itself handles all the "
"interactions with such systems and passes sharding parameters. That said, "
"the configuration can be changed dynamically - for example, when adding or "
"deleting one or several shards:"
msgstr ""
"Шардинг не интегрирован ни в одну систему централизованного хранения "
"конфигураций. Предполагается, что само приложение обрабатывает "
"взаимодействие с такой системой и передает параметры шардинга. При этом "
"конфигурацию можно изменить динамически, например, при добавлении или "
"удалении одного или нескольких шардов:"

msgid ""
"To add a new shard to the cluster, a system administrator first changes the "
"configuration of all the routers and then the configuration of all the "
"storages."
msgstr ""
"Чтобы добавить новый шард в кластер, системный администратор сначала "
"изменяет конфигурацию всех роутеров, а затем конфигурацию всех хранилищ."

msgid "The new shard becomes available to the storage layer for rebalancing."
msgstr "Новый шард становится доступен для балансировки на уровне хранилища."

msgid ""
"As a result of rebalancing, one of the vbuckets is moved to the new shard."
msgstr ""
"В результате балансировки один из виртуальных сегментов перемещается на "
"новый шард."

msgid ""
"When trying to access the vbucket, a router receives a special error code "
"that specifies the new vbucket location."
msgstr ""
"При попытке доступа к виртуальному сегменту роутер получает специальный код "
"ошибки, который указывает новое местоположение сегмента."

msgid "CRUD (create, read, update, delete) operations"
msgstr ""
"CRUD-операции: create, read, update, delete (создание, чтение, изменение, "
"удаление)"

msgid "CRUD operations can be:"
msgstr "CRUD-операции могут:"

msgid "executed in a stored procedure inside a storage, or"
msgstr "либо выполняться в рамках хранимой процедуры в хранилище,"

msgid "initialized by the application."
msgstr "либо запускаться приложением."

msgid ""
"In any case, the application must include the operation bucket id in a "
"request. When executing an INSERT request, the operation bucket id is stored"
" in a newly created tuple. In other cases, it is checked if the specified "
"operation bucket id matches the bucket id of a tuple being modified."
msgstr ""
"В любом случае приложение должно включать идентификатор рабочего сегмента в "
"запрос. При выполнении запроса вставки INSERT идентификатор сегмента "
"хранится в созданном кортеже. В других случаях проверяется, совпадает ли "
"указанный идентификатор рабочего сегмента с идентификатором сегмента "
"кортежа, в который вносятся изменения."

msgid "SELECT requests"
msgstr "SELECT-запросы"

msgid ""
"Since a storage is not aware of the mapping between a bucket id and a "
"primary key, all the SELECT requests executed in stored procedures inside a "
"storage are only executed locally. Those SELECT requests that were "
"initialized by the application are forwarded to a router. Then, if the "
"application has passed a bucket id, a router uses it for shard calculation."
msgstr ""
"Поскольку хранилище не знает о соответствии идентификатора сегмента и "
"первичного ключа, все запросы выборки SELECT в хранимых процедурах внутри "
"хранилища выполняются только локально. SELECT-запросы, которые были "
"инициализированы приложением, направляются на роутер. И если приложение "
"передало идентификатор сегмента, роутер использует его для вычисления шарда."

msgid "Calling stored procedures"
msgstr "Вызов хранимых процедур"

msgid ""
"There are several ways of calling stored procedures in cluster replica sets."
" Stored procedures can be called:"
msgstr ""
"Существует несколько способов вызвать хранимые процедуры в наборах реплик "
"кластера. Хранимые процедуры можно вызвать:"

msgid ""
"on a specific vbucket located in a replica set (in this case, it is "
"necessary to differentiate between read and write procedures, as write "
"procedures are not applicable to vbuckets that are being migrated), or"
msgstr ""
"либо на определенном виртуальном сегменте, расположенном в наборе реплик (в "
"этом случае необходимо различать процедуры чтения и записи, так как "
"процедуры записи не применимы к перемещаемым сегментам),"

msgid "without specifying any particular vbucket."
msgstr "либо без указания определенного сегмента."

msgid ""
"All the routing validity checks performed for sharded DML operations hold "
"true for vbucket-bound stored procedures as well."
msgstr ""
"Все проверки правильности маршрутизации, выполняемые для шардированных DML-"
"операций, распространяются и на хранимые процедуры, связанные с сегментами."

msgid "Rebalancer"
msgstr "Балансировщик"

msgid ""
"**Rebalancer** is a background rebalancing process that ensures an even "
"distribution of buckets across the shards. During rebalancing, buckets are "
"being migrated among replica sets."
msgstr ""
"**Балансировщик** представляет собой фоновый процесс балансировки, который "
"обеспечивает равномерное распределение сегментов по шардам. Во время "
"балансировки происходит миграция сегментов по наборам реплик."

msgid ""
"The rebalancer \"wakes up\" periodically and redistributes data from the "
"most loaded nodes to less loaded nodes. Rebalancing starts if the "
"**disbalance threshold** of a replica set exceeds a disbalance threshold "
"specified in the configuration."
msgstr ""
"Балансировщик периодически \"просыпается\" и перераспределяет данные из "
"наиболее загруженных узлов в менее загруженные узлы. Балансировка "
"начинается, когда **предел дисбаланса** в наборе реплик превышает предел "
"дисбаланса, указанный в конфигурации."

msgid "The disbalance threshold is calculated as follows:"
msgstr "Предел дисбаланса рассчитывается следующим образом:"

msgid ""
"|etalon_bucket_number - real_bucket_number| / etalon_bucket_number * 100"
msgstr ""
"|эталонное_число_сегментов - текущее_число_сегментов| / "
"эталонное_число_сегментов * 100"

msgid "Migration of buckets"
msgstr "Миграция сегментов"

msgid ""
"A replica set from which the bucket is being migrated is called a **source**"
" ; a target replica set to which the bucket is being migrated is called a "
"**destination**."
msgstr ""
"Набор реплик, из которого переносится сегмент, называется **исходный** "
"(source); а набор реплик, куда переносится сегмент, называется **целевой** "
"(destination)."

msgid ""
"A **replica set lock** makes a replica set invisible to the rebalancer. A "
"locked replica set can neither receive new buckets nor migrate its own "
"buckets."
msgstr ""
"**Блокировка набора реплик** позволяет набору реплик оставаться невидимым "
"для балансировщика. Набор реплик с блокировкой не может ни принимать новые "
"сегменты, ни мигрировать свои собственные."

msgid "While a bucket is being migrated, it can have different states:"
msgstr "Во время миграции у сегмента могут быть разные статусы:"

msgid "ACTIVE – the bucket is available for read and write requests."
msgstr "ACTIVE (активный) -- сегмент доступен для запросов чтения и записи."

msgid ""
"PINNED – the bucket is locked for migrating to another replica set. "
"Otherwise pinned buckets are similar to buckets in the ACTIVE state."
msgstr ""
"PINNED (закрепленный) -- сегмент заблокирован для миграции в другой набор "
"реплик. Во всем остальном закрепленные сегменты аналогичны активным "
"сегментам."

msgid ""
"SENDING – the bucket is currently being copied to the destination replica "
"set; read requests to the source replica set are still processed."
msgstr ""
"SENDING (отправляемый) -- в настоящий момент сегмент копируется в целевой "
"набор реплик; запросы на чтение в исходный набор реплик обрабатываются."

msgid ""
"RECEIVING – the bucket is currently being filled; all requests to it are "
"rejected."
msgstr ""
"RECEIVING (принимающий) -- происходит наполнение сегмента; все запросы "
"отклоняются."

msgid ""
"SENT – the bucket was migrated to the destination replica set. The `router` "
"uses the SENT state to calculate the new location of the bucket. A bucket in"
" the SENT state goes to the GARBAGE state automatically after "
"BUCKET_SENT_GARBAGE_DELAY seconds, which by default is :ref:`0.5 seconds "
"<cfg_basic-collect_bucket_garbage_interval>`."
msgstr ""
"SENT (отправленный) -- сегмент был перенесен в целевой набор реплик. Роутер "
"использует статус SENT, чтобы определить новое местонахождение сегмента. "
"Сегмент в статусе SENT переходит в статус мусора GARBAGE автоматически через"
" количество секунд, указанное в BUCKET_SENT_GARBAGE_DELAY, по умолчанию "
"равное :ref:`0,5 секунды <cfg_basic-collect_bucket_garbage_interval>`."

msgid ""
"GARBAGE – the bucket was already migrated to the destination replica set "
"during rebalancing; or the bucket was initially in the RECEIVING state, but "
"some error occurred during the migration."
msgstr ""
"GARBAGE (мусор) -- произошла миграция сегмента в целевой набор реплик во "
"время балансировки; или же принимающий сегмент был в статусе RECEIVING, но "
"произошла ошибка во время миграции."

msgid "Buckets in the GARBAGE state are deleted by the garbage collector."
msgstr "Сегменты в статусе мусора GARBAGE удаляются сборщиком мусора."

msgid "Migration is performed as follows:"
msgstr "Миграция происходит следующим образом:"

msgid ""
"At the destination replica set, a new bucket is created and assigned the "
"RECEIVING state, the data copying starts, and the bucket rejects all "
"requests."
msgstr ""
"В целевом наборе реплик создается новый сегмент, который получает статус "
"RECEIVING (принимающий), начинается копирование данных, и сегмент отклоняет "
"все запросы."

msgid ""
"The source bucket in the source replica set is assigned the SENDING state, "
"and the bucket continues to process read requests."
msgstr ""
"Отправляемый сегмент в исходном наборе реплик получает статус SENDING и "
"продолжает обрабатывать запросы на чтение."

msgid ""
"Once the data is copied, the bucket on the source replica set is assigned "
"the SENT and it starts rejecting all requests."
msgstr ""
"После копирования данных сегмент в исходном наборе реплик получает статус "
"отправленного (SENT) и перестает принимать запросы."

msgid ""
"The bucket on the destination replica set is assigned the ACTIVE state and "
"starts accepting all requests."
msgstr ""
"Сегмент в целевом наборе реплик переходит в активный статус (ACTIVE) и "
"начинает принимать все запросы."

msgid ""
"There is a specific error ``vshard.error.code.TRANSFER_IS_IN_PROGRESS`` that"
" returns in case a request tries to perform an action not applicable to a "
"bucket which is being relocated. You need to retry the request in this case."
msgstr ""
"Есть специальная ошибка ``vshard.error.code.TRANSFER_IS_IN_PROGRESS``, "
"которая возвращается в том случае, если запрос пытается выполнить действие, "
"неприменимое к перемещаемому сегменту. В этом случае необходимо повторить "
"попытку выполнения запроса."

msgid "The `_bucket` system space"
msgstr "Системный спейс `_bucket`"

msgid ""
"The ``_bucket`` system space of each replica set stores the ids of buckets "
"present in the replica set. The space contains the following fields:"
msgstr ""
"Системный спейс ``_bucket`` в каждом наборе реплик хранит идентификаторы "
"сегментов данного набора реплик. Спейс содержит следующие поля:"

msgid "``bucket`` – bucket id"
msgstr "``bucket`` -- идентификатор сегмента"

msgid "``status`` – state of the bucket"
msgstr "``status`` -- статус сегмента"

msgid "``destination`` – UUID of the destination replica set"
msgstr "``destination`` -- UUID целевого набора реплик"

msgid "An example of ``_bucket.select{}``:"
msgstr "Пример ``_bucket.select{}``:"

msgid ""
"---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."
msgstr ""
"---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."

msgid ""
"Once the bucket is migrated, the destination replica set identified by UUID "
"is filled in the table. While the bucket is still located on the source "
"replica set, the value of the destination replica set UUID is equal to "
"``NULL``."
msgstr ""
"После миграции сегмента UUID целевого набора реплик вносится в таблицу. Пока"
" сегмент еще находится в исходном наборе реплик, значение UUID целевого "
"набора реплик равно ``NULL``."

msgid "The routing table"
msgstr "Таблица маршрутизации"

msgid ""
"А routing table on the ``router`` stores the map of all bucket ids to "
"replica sets. It ensures the consistency of sharding in case of failover."
msgstr ""
"Таблица маршрутизации роутера отображает все идентификаторы сегментов с "
"соответствующими наборами реплик. Она обеспечивает консистентность шардинга "
"в случае отказа."

msgid ""
"The ``router`` keeps a persistent pool of connections to all the storages "
"that are created at startup. This helps prevent configuration errors. Once "
"the connection pool is created, the ``router`` caches the current state of "
"the routing table in order to speed up routing. If a bucket migrated to "
"another ``storage`` after rebalancing, or a failover occurred and caused one"
" of the shards switching to another replica, the ``discovery fiber`` on the "
"``router`` updates the routing table automatically."
msgstr ""
"Роутер поддерживает постоянный пул соединений со всеми хранилищами, "
"созданными при запуске, что помогает избежать ошибки конфигурации. После "
"создания пула соединений роутер кэширует текущее состояние таблицы "
"маршрутизации, чтобы ускорить ее. Если произошла миграция сегмента в другое "
"хранилище после балансировки или же отказ, который вызвал переключение шарда"
" на другую реплику, файбер обнаружения (``discovery fiber``) в роутере "
"обновит таблицу маршрутизации автоматически."

msgid ""
"As the bucket id is explicitly indicated both in the data and in the mapping"
" table on the ``router``, the data is consistent regardless of the "
"application logic. It also makes rebalancing transparent for the "
"application."
msgstr ""
"Поскольку идентификатор сегмента явно указан как в данных, так и в таблице "
"отображения на роутере, данные сохраняются независимо от логики приложения. "
"Это также обеспечивает прозрачность балансировки для приложения."

msgid "Processing requests"
msgstr "Обработка запросов"

msgid ""
"Requests to the database can be performed by the application or using stored"
" procedures. Either way, the bucket id should be explicitly specified in the"
" request."
msgstr ""
"Запросы в базу данных можно производить из приложения или с помощью хранимых"
" процедур. В любом случае идентификатор сегмента следует явным образом "
"указать в запросе."

msgid ""
"All requests are forwarded to the ``router`` first. The only operation "
"supported by the ``router`` is ``call``. The operation is performed via the "
"``vshard.router.call()`` function:"
msgstr ""
"Сначала все запросы направляются в роутер. Роутер поддерживает только "
"операцию вызова, которая выполняется с помощью функции "
"``vshard.router.call()``:"

msgid ""
"result = vshard.router.call(<bucket_id>, <mode>, <function_name>, "
"{<argument_list>}, {<opts>})"
msgstr ""
"result = vshard.router.call(<идентификатор_сегмента>, <режим>, "
"<имя_функции>, {<список_аргументов>}, {<опции>})"

msgid "Requests are processed as follows:"
msgstr "Запросы обрабатываются следующим образом:"

msgid ""
"The ``router`` uses the bucket id to search for a replica set with the "
"corresponding bucket in the routing table."
msgstr ""
"Роутер использует идентификатор сегмента для поиска набора реплик с "
"соответствующим сегментом в таблице маршрутизации."

msgid ""
"If the map of the bucket id to the replica set is not known to the "
"``router`` (the discovery fiber hasn’t filled the table yet), the ``router``"
" makes requests to all ``storages`` to find out where the bucket is located."
msgstr ""
"Если роутер не содержит информацию о соответствии идентификатора сегмента "
"набору реплик (файбер обнаружения еще не заполнил таблицу), роутер выполняет"
" запросы ко всем хранилищам, чтобы обнаружить местонахождение сегмента."

msgid "Once the bucket is located, the shard checks:"
msgstr "После обнаружения сегмента шард проверяет:"

msgid ""
"whether the bucket is stored in the ``_bucket`` system space of the replica "
"set;"
msgstr "хранится ли сегмент в системном спейсе ``_bucket`` набора реплик;"

msgid ""
"whether the bucket is ACTIVE or PINNED (for a read request, it can also be "
"SENDING)."
msgstr ""
"находится ли сегмент в статусе ACTIVE (активный) или PINNED (закрепленный) "
"(если выполняется запрос на чтение, то сегмент может находиться в состоянии "
"отправки SENDING)."

msgid ""
"If all the checks succeed, the request is executed. Otherwise, it is "
"terminated with the error: ``“wrong bucket”``."
msgstr ""
"Если проверка пройдена, запрос выполняется. В противном случае, выполнение "
"запроса прекращается с ошибкой: ``“wrong bucket”`` (несоответствующий "
"сегмент)."

msgid "Glossary"
msgstr "Глоссарий"

msgid "**Vertical scaling**"
msgstr "**Вертикальное масштабирование**"

msgid ""
"Adding more power to a single server: using a more powerful CPU, adding more"
" capacity to RAM, adding more storage space, etc."
msgstr ""
"Добавление мощности в отдельный сервер: использование более мощного "
"процессора, добавление оперативной памяти, добавление хранилищ и т.д. "

msgid "**Horizontal scaling**"
msgstr "**Горизонтальное масштабирование**"

msgid ""
"Adding more servers to the pool of resources, then partitioning and "
"distributing a dataset across the servers."
msgstr ""
"Добавление дополнительных серверов в пул ресурсов, последующее "
"секционирование и распределение набора данных по серверам."

msgid "**Sharding**"
msgstr "**Шардинг**"

msgid ""
"A database architecture that allows partitioning a dataset using a sharding "
"key and distributing a dataset across multiple servers. Sharding is a "
"special case of horizontal scaling."
msgstr ""
"Архитектура базы данных, которая допускает секционирование набора данных по "
"сегментному ключу и распределение набора данных по нескольким серверам. "
"Шардинг представляет собой частный случай горизонтального масштабирования."

msgid "**Node**"
msgstr "**Узел**"

msgid "A virtual or physical server instance."
msgstr "Виртуальный или физический экземпляр сервера."

msgid "**Cluster**"
msgstr "**Кластер**"

msgid "A set of nodes that make up a single group."
msgstr "Набор узлов, которые составляют отдельную группу."

msgid "**Storage**"
msgstr "**Хранилище**"

msgid "A node storing a subset of a dataset."
msgstr "Узел, который хранит подмножество данных из набора."

msgid "**Replica set**"
msgstr "**Набор реплик**"

msgid ""
"A set of storage nodes storing copies of a dataset. Each storage in a "
"replica set has a role, master or replica."
msgstr ""
"Ряд узлов, на которых хранятся копии набора данных. У каждого хранилища в "
"наборе реплик есть роль: мастер или реплика."

msgid "**Master**"
msgstr "**Мастер**"

msgid "A storage in a replica set processing read and write requests."
msgstr ""
"Хранилище в наборе реплик, которое обрабатывает запросы на чтение и запись."

msgid "**Replica**"
msgstr "**Реплика**"

msgid "A storage in a replica set processing only read requests."
msgstr ""
"Хранилище в наборе реплик, которое обрабатывает только запросы на чтение."

msgid "**Read requests**"
msgstr "**Запросы на чтение**"

msgid "Read-only requests, that is, select requests."
msgstr "Запросы только на чтение, то есть выборка."

msgid "**Write requests**"
msgstr "**Запросы на запись**"

msgid "Data-change operations, that is create, read, update, delete requests."
msgstr ""
"Операции по изменению данных, то есть запросы на создание, чтение, изменение"
" и удаление данных."

msgid "**Buckets (virtual buckets)**"
msgstr "**Сегменты (виртуальные сегменты)**"

msgid ""
"The abstract virtual nodes into which the dataset is partitioned by the "
"sharding key (bucket id)."
msgstr ""
"Абстрактные виртуальные узлы, на которые производится секционирование набора"
" данных по сегментному ключу (идентификатору сегмента)."

msgid "**Bucket id**"
msgstr "**Идентификатор сегмента**"

msgid ""
"A sharding key defining which bucket belongs to which replica set. A bucket "
"id may be calculated from a :ref:`hash key <router_api-bucket_id_strcrc32>`."
msgstr ""
"Сегментный ключ, который определяет принадлежность сегмента к определенному "
"набору реплик. Идентификатор сегмента можно вычислить по :ref:`хеш-ключу "
"<router_api-bucket_id_strcrc32>`."

msgid "**Router**"
msgstr "**Роутер**"

msgid ""
"A proxy server responsible for routing requests from an application to nodes"
" in a cluster."
msgstr ""
"Прокси-сервер, который отвечает за запросы маршрутизации от приложения к "
"узлам в кластере."
