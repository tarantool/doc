# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-06 07:42+0000\n"
"PO-Revision-Date: 2019-12-06 16:16+0300\n"
"Last-Translator: \n"
"Language: ru\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

msgid "Architecture"
msgstr "Архитектура"

msgid "Overview"
msgstr "Общие сведения"

msgid ""
"Consider a distributed Tarantool cluster that consists of subclusters "
"called **shards**, each storing some part of data. Each shard, in its "
"turn, constitutes a **replica set** consisting of several **replicas**, "
"one of which serves as a master node that processes all read and write "
"requests."
msgstr ""

msgid ""
"The whole dataset is logically partitioned into a predefined number of "
":ref:`virtual buckets <vshard-vbuckets>` (further just **buckets**), each"
" assigned a unique number ranging from 1 to N, where N is the total "
"number of buckets. The number of buckets is specifically chosen to be "
"several orders of magnitude larger than the potential number of cluster "
"nodes, even given future cluster scaling. For example, with M projected "
"nodes the dataset may be split into 100 * M or even 1,000 * M buckets. "
"Care should be taken when picking the number of buckets: if too large, it"
" may require extra memory for storing the routing information; if too "
"small, it may decrease the granularity of rebalancing."
msgstr ""

msgid ""
"Each shard stores a unique subset of buckets, which means that a bucket "
"cannot belong to several shards at once, as illustrated below:"
msgstr ""
"Каждый шард хранит уникальное подмножество сегментов. Один сегмент не "
"может относиться к нескольким шардам одновременно, как показано на схеме "
"ниже:"

msgid ""
"This shard-to-bucket mapping is stored in a table in one of Tarantool’s "
"system spaces, with each shard holding only a specific part of the "
"mapping that covers those buckets that were assigned to this shard."
msgstr ""

msgid ""
"Apart from the mapping table, the **bucket id** is also stored in a "
"special field of every tuple of every table participating in sharding."
msgstr ""

msgid ""
"Once a shard receives any request (except for SELECT) from an "
"application, this shard checks the bucket id specified in the request "
"against the table of bucket ids that belong to a given node. If the "
"specified bucket id is invalid, the request gets terminated with the "
"following error: “wrong bucket”. Otherwise the request is executed, and "
"all the data created in the process is assigned the bucket id specified "
"in the request. Note that the request should only modify the data that "
"has the same bucket id as the request itself."
msgstr ""

msgid ""
"Storing bucket ids both in the data itself and the mapping table ensures "
"data consistency regardless of the application logic and makes "
"rebalancing transparent for the application. Storing the mapping table in"
" a system space ensures sharding is performed consistently in case of a "
"failover, as all the replicas in a shard share a common table state."
msgstr ""

msgid "Virtual buckets"
msgstr "Виртуальные сегменты"

#, fuzzy
msgid ""
"The sharded dataset is partitioned into a large number of abstract nodes "
"called **virtual buckets** (further just **buckets**)."
msgstr ""
"Набор данных при шардинге распределяется на большое количество "
"абстрактных узлов, которые называются **виртуальные сегменты** (далее по "
"тексту **сегменты**)."

msgid ""
"The dataset is partitioned using the sharding key (or **bucket id**, in "
"Tarantool terminology). Bucket id is a number from 1 to N, where N is the"
" total number of buckets."
msgstr ""
"Секционирование набора данных происходит с помощью сегментного ключа (или"
" **идентификатора сегмента** (bucket id) в терминах Tarantool'а). "
"Идентификатор сегмента -- это число от 1 до N, где N -- это общее "
"количество сегментов."

msgid ""
"Each replica set stores a unique subset of buckets. One bucket cannot "
"belong to multiple replica sets at a time."
msgstr ""
"В каждом наборе реплик есть уникальное подмножество сегментов. Одна "
"сегмент не может относиться к нескольким наборам реплик одновременно."

msgid ""
"The total number of buckets is determined by the administrator who sets "
"up the initial cluster configuration."
msgstr ""
"Общее количество сегментов определяет администратор, который настраивает "
"первоначальную конфигурацию кластера."

msgid ""
"Every space you plan to shard must have a numeric field containing bucket"
" id-s. This field must comply with the following requirements:"
msgstr ""

msgid "The field's data type can be: unsigned, number or integer."
msgstr ""

msgid "The field must be not nullable."
msgstr ""

msgid ""
"The field must be indexed by the :ref:`shard_index <cfg_basic-"
"shard_index>`. The default name for this index is ``bucket_id``."
msgstr ""

#, fuzzy
msgid "See the :ref:`configuration example <vshard-define-spaces>`."
msgstr "См. :ref:`пример <tap-example>`."

msgid "Structure"
msgstr "Структура"

#, fuzzy
msgid "A sharded cluster in Tarantool consists of:"
msgstr "Минимальный рабочий сегментированный кластер должен состоять из:"

msgid "storages,"
msgstr "хранилище,"

msgid "routers,"
msgstr "роутеры,"

msgid "and a rebalancer."
msgstr "и ребалансировщик."

msgid "Storage"
msgstr "Хранилище"

#, fuzzy
msgid ""
"**Storage** is a node storing a subset of the dataset. Multiple "
"replicated (for redundancy) storages comprise a **replica set** (also "
"called **shard**)."
msgstr ""
"**Хранилище** (storage) -- это узел, который хранит подмножество набора "
"данных. Развертывание нескольких реплицируемых хранилищ осуществляется в "
"виде наборов реплик, чтобы обеспечить резерв (набор реплик также можно "
"называть шардом или сегментом)."

#, fuzzy
msgid ""
"Each storage in a replica set has a role, **master** or **replica**. A "
"master processes read and write requests. A replica processes read "
"requests but cannot process write requests."
msgstr ""
"**Хранилище** (storage) -- это узел, который хранит подмножество набора "
"данных. Несколько реплицируемых хранилищ составляют набор реплик. У "
"каждого хранилища в наборе реплик есть роль: **мастер** или **реплика**. "
"Мастер обрабатывает запросы на чтение и запись. Реплика обрабатывает "
"запросы на чтение, но не может обрабатывать запросы на запись."

msgid "Router"
msgstr "Роутер"

#, fuzzy
msgid ""
"**Router** is a standalone software component that routes read and write "
"requests from the client application to shards."
msgstr ""
"**Роутер** (router) -- это автономный компонент ПО, который обеспечивает "
"маршрутизацию запросов чтения и записи от клиентского приложения к "
"шардам."

msgid ""
"All requests from the application come to the sharded cluster through a "
"``router``. The ``router`` keeps the topology of a sharded cluster "
"transparent for the application, thus keeping the application unaware of:"
msgstr ""
"Все запросы из приложения приходят в сегментированный кластер через "
"роутер (``router``). Роутер сохраняет топологию сегментированного "
"кластера прозрачной для приложения, не сообщая приложению:"

msgid "the number and location of shards,"
msgstr "номер и местоположение шардов,"

msgid "data rebalancing process,"
msgstr "процесс балансировки данных,"

msgid ""
"the fact and the process of a failover that occurred after a replica's "
"failure."
msgstr "наличие отказа и восстановление после отказа реплики."

msgid ""
"A router can also calculate a bucket id on its own provided that the "
"application clearly defines rules for calculating a bucket id based on "
"the request data. To do it, a router needs to be aware of the data "
"schema."
msgstr ""

msgid ""
"The ``router`` does not have a persistent state, nor does it store the "
"cluster topology or balance the data. The ``router`` is a standalone "
"software component that can run in the storage layer or application layer"
" depending on the application features."
msgstr ""
"У роутера нет постоянного статуса, он не хранит топологию кластера и не "
"выполняет балансировку данных. Роутер -- это автономный компонент ПО, "
"который может работать на уровне хранилища или на уровне приложения в "
"зависимости от функций приложения."

msgid ""
"A router maintains a constant pool of connections to all the storages "
"that is created at startup. Creating it this way helps avoid "
"configuration errors. Once a pool is created, a router caches the current"
" state of the ``_vbucket`` table to speed up the routing. In case a "
"bucket id is moved to another storage as a result of data rebalancing, or"
" one of the shards fails over to a replica, a router updates the routing "
"table in a way that's transparent for the application."
msgstr ""

msgid ""
"Sharding is not integrated into any centralized configuration storage "
"system. It is assumed that the application itself handles all the "
"interactions with such systems and passes sharding parameters. That said,"
" the configuration can be changed dynamically - for example, when adding "
"or deleting one or several shards:"
msgstr ""

msgid ""
"To add a new shard to the cluster, a system administrator first changes "
"the configuration of all the routers and then the configuration of all "
"the storages."
msgstr ""

#, fuzzy
msgid "The new shard becomes available to the storage layer for rebalancing."
msgstr "Новый шард становится доступен для балансирования на уровне хранилища."

#, fuzzy
msgid "As a result of rebalancing, one of the vbuckets is moved to the new shard."
msgstr "В результате балансировки происходит миграция сегментов на новый шард."

msgid ""
"When trying to access the vbucket, a router receives a special error code"
" that specifies the new vbucket location."
msgstr ""

msgid "CRUD (create, replace, update, delete) operations"
msgstr ""

msgid "CRUD operations can be:"
msgstr ""

msgid "executed in a stored procedure inside a storage, or"
msgstr ""

msgid "initialized by the application."
msgstr ""

msgid ""
"In any case, the application must include the operation bucket id in a "
"request. When executing an INSERT request, the operation bucket id is "
"stored in a newly created tuple. In other cases, it is checked if the "
"specified operation bucket id matches the bucket id of a tuple being "
"modified."
msgstr ""

msgid "SELECT requests"
msgstr "SELECT-запросы"

msgid ""
"Since a storage is not aware of the mapping between a bucket id and a "
"primary key, all the SELECT requests executed in stored procedures inside"
" a storage are only executed locally. Those SELECT requests that were "
"initialized by the application are forwarded to a router. Then, if the "
"application has passed a bucket id, a router uses it for shard "
"calculation."
msgstr ""

#, fuzzy
msgid "Calling stored procedures"
msgstr "Вызов хранимой процедуры"

msgid ""
"There are several ways of calling stored procedures in cluster replica "
"sets. Stored procedures can be called:"
msgstr ""

msgid ""
"on a specific vbucket located in a replica set (in this case, it is "
"necessary to differentiate between read and write procedures, as write "
"procedures are not applicable to vbuckets that are being migrated), or"
msgstr ""

msgid "without specifying any particular vbucket."
msgstr ""

msgid ""
"All the routing validity checks performed for sharded DML operations hold"
" true for vbucket-bound stored procedures as well."
msgstr ""

msgid "Rebalancer"
msgstr ""

#, fuzzy
msgid ""
"**Rebalancer** is a background rebalancing process that ensures an even "
"distribution of buckets across the shards. During rebalancing, buckets "
"are being migrated among replica sets."
msgstr ""
"**Балансировщик** представляет собой фоновый процесс балансировки, "
"который обеспечивает равномерное распределение сегментов по шардам. Во "
"время балансировки происходит миграция сегментов по наборам реплик."

#, fuzzy
msgid ""
"The rebalancer \"wakes up\" periodically and redistributes data from the "
"most loaded nodes to less loaded nodes. Rebalancing starts if the "
"**disbalance threshold** of a replica set exceeds a disbalance threshold "
"specified in the configuration."
msgstr ""
"``Балансировщик`` периодически просыпается и перераспределяет данные из "
"наиболее загруженных узлов в менее загруженные узлы. Балансировка "
"начинается, когда предел дисбаланса в наборе реплик превышает предел "
"дисбаланса, указанный в конфигурации."

msgid "The disbalance threshold is calculated as follows:"
msgstr "Предел дисбаланса рассчитывается следующим образом:"

msgid "|etalon_bucket_number - real_bucket_number| / etalon_bucket_number * 100"
msgstr ""
"|эталонное_число_сегментов - текущее_число_сегментов| / "
"эталонное_число_сегментов * 100"

msgid "Migration of buckets"
msgstr "Миграция сегментов"

msgid ""
"A replica set from which the bucket is being migrated is called a "
"**source** ; a target replica set to which the bucket is being migrated "
"is called a **destination**."
msgstr ""
"Набор реплик, из которого переносится сегмент, называется **исходный** "
"(source); а набор реплик, куда переносится сегмент, называется "
"**целевой** (destination)."

msgid ""
"A **replica set lock** makes a replica set invisible to the rebalancer. A"
" locked replica set can neither receive new buckets nor migrate its own "
"buckets."
msgstr ""
"**Блокировка набора реплик** позволяет набору реплик оставаться невидимым"
" для балансировщика. Набор реплик с блокировкой не может ни принимать "
"новые сегменты, ни мигрировать свои собственные."

msgid "While a bucket is being migrated, it can have different states:"
msgstr "Во время миграции у сегмента могут быть разные статусы:"

msgid "ACTIVE – the bucket is available for read and write requests."
msgstr "ACTIVE (активный) -- сегмент доступен для запросов чтения и записи."

msgid ""
"PINNED – the bucket is locked for migrating to another replica set. "
"Otherwise pinned buckets are similar to buckets in the ACTIVE state."
msgstr ""
"PINNED (закрепленный) -- сегмент заблокирован для миграции в другой набор"
" реплик. Во всем остальном закрепленные сегменты аналогичны активным "
"сегментам."

msgid ""
"SENDING – the bucket is currently being copied to the destination replica"
" set; read requests to the source replica set are still processed."
msgstr ""
"SENDING (отправляемый) -- в настоящий момент сегмент копируется в целевой"
" набор реплик; запросы на чтение в исходный набор реплик обрабатываются."

msgid ""
"RECEIVING – the bucket is currently being filled; all requests to it are "
"rejected."
msgstr ""
"RECEIVING (принимающий) -- происходит наполнение сегмента; все запросы "
"отклоняются."

msgid ""
"SENT – the bucket was migrated to the destination replica set. The "
"`router` uses the SENT state to calculate the new location of the bucket."
" A bucket in the SENT state goes to the GARBAGE state automatically after"
" BUCKET_SENT_GARBAGE_DELAY seconds, which by default is :ref:`0.5 seconds"
" <cfg_basic-collect_bucket_garbage_interval>`."
msgstr ""
"SENT (отправленный) -- сегмент был перенесен в целевой набор реплик. "
"Роутер использует статус SENT, чтобы определить новое местонахождение "
"сегмента. Сегмент в статусе SENT переходит в статус мусора GARBAGE "
"автоматически через количество секунд, указанное в "
"BUCKET_SENT_GARBAGE_DELAY, по умолчанию равное :ref:`0,5 секунды "
"<cfg_basic-collect_bucket_garbage_interval>`."

msgid ""
"GARBAGE – the bucket was already migrated to the destination replica set "
"during rebalancing; or the bucket was initially in the RECEIVING state, "
"but some error occurred during the migration."
msgstr ""
"GARBAGE (мусор) -- произошла миграция сегмента в целевой набор реплик во "
"время балансировки; или же принимающий сегмент был в статусе RECEIVING, "
"но произошла ошибка во время миграции."

msgid "Buckets in the GARBAGE state are deleted by the garbage collector."
msgstr "Сегменты в статусе мусора GARBAGE удаляются сборщиком мусора."

msgid "Migration is performed as follows:"
msgstr "Миграция происходит следующим образом:"

msgid ""
"At the destination replica set, a new bucket is created and assigned the "
"RECEIVING state, the data copying starts, and the bucket rejects all "
"requests."
msgstr ""
"В целевом наборе реплик создается новый сегмент, который получает статус "
"RECEIVING (принимающий), начинается копирование данных, и сегмент "
"отклоняет все запросы."

msgid ""
"The source bucket in the source replica set is assigned the SENDING "
"state, and the bucket continues to process read requests."
msgstr ""
"Отправляемый сегмент в исходном наборе реплик получает статус SENDING и "
"продолжает обрабатывать запросы на чтение."

msgid ""
"Once the data is copied, the bucket on the source replica set is assigned"
" the SENT and it starts rejecting all requests."
msgstr ""
"После копирования данных сегмент в исходном наборе реплик получает статус"
" отправленного (SENT) и перестает принимать запросы."

msgid ""
"The bucket on the destination replica set is assigned the ACTIVE state "
"and starts accepting all requests."
msgstr ""
"Сегмент в целевом наборе реплик переходит в активный статус (ACTIVE) и "
"начинает принимать все запросы."

msgid ""
"There is a specific error ``vshard.error.code.TRANSFER_IS_IN_PROGRESS`` "
"that returns in case a request tries to perform an action not applicable "
"to a bucket which is being relocated. You need to retry the request in "
"this case."
msgstr ""

msgid "The `_bucket` system space"
msgstr "Системный спейс `_bucket`"

msgid ""
"The ``_bucket`` system space of each replica set stores the ids of "
"buckets present in the replica set. The space contains the following "
"fields:"
msgstr ""
"Системный спейс ``_bucket`` в каждом наборе реплик хранит идентификаторы "
"сегментов данного набора реплик. Спейс содержит следующие поля:"

msgid "``bucket`` – bucket id"
msgstr "``bucket`` -- идентификатор сегмента"

msgid "``status`` – state of the bucket"
msgstr "``status`` -- статус сегмента"

msgid "``destination`` – UUID of the destination replica set"
msgstr "``destination`` -- UUID целевого набора реплик"

msgid "An example of ``_bucket.select{}``:"
msgstr "Пример ``_bucket.select{}``:"

msgid ""
"---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."
msgstr ""
"---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."

msgid ""
"Once the bucket is migrated, the destination replica set identified by "
"UUID is filled in the table. While the bucket is still located on the "
"source replica set, the value of the destination replica set UUID is "
"equal to ``NULL``."
msgstr ""
"После миграции сегмента UUID целевого набора реплик вносится в таблицу. "
"Пока сегмент еще находится в исходном наборе реплик, значение UUID "
"целевого набора реплик равно ``NULL``."

msgid "The routing table"
msgstr "Таблица маршрутизации"

msgid ""
"А routing table on the ``router`` stores the map of all bucket ids to "
"replica sets. It ensures the consistency of sharding in case of failover."
msgstr ""
"Таблица маршрутизации роутера отображает все идентификаторы сегментов с "
"соответствующими наборами реплик. Она обеспечивает консистентность "
"шардинга в случае отказа."

msgid ""
"The ``router`` keeps a persistent pool of connections to all the storages"
" that are created at startup. This helps prevent configuration errors. "
"Once the connection pool is created, the ``router`` caches the current "
"state of the routing table in order to speed up routing. If a bucket "
"migrated to another ``storage`` after rebalancing, or a failover occurred"
" and caused one of the shards switching to another replica, the "
"``discovery fiber`` on the ``router`` updates the routing table "
"automatically."
msgstr ""
"Роутер поддерживает постоянный пул соединений со всеми хранилищами, "
"созданными при запуске, что помогает избежать ошибки конфигурации. После "
"создания пула соединений роутер кэширует текущее состояние таблицы "
"маршрутизации, чтобы ускорить ее. Если произошла миграция сегмента в "
"другое хранилище после балансировки или же отказ, который вызвал "
"переключение шарда на другую реплику, файбер обнаружения (``discovery "
"fiber``) в роутере обновит таблицу маршрутизации автоматически."

msgid ""
"As the bucket id is explicitly indicated both in the data and in the "
"mapping table on the ``router``, the data is consistent regardless of the"
" application logic. It also makes rebalancing transparent for the "
"application."
msgstr ""
"Поскольку идентификатор сегмента явно указан как в данных, так и в "
"таблице отображения на роутере, данные сохраняются независимо от логики "
"приложения. Это также обеспечивает прозрачность балансировки для "
"приложения."

msgid "Processing requests"
msgstr "Обработка запросов"

msgid ""
"Requests to the database can be performed by the application or using "
"stored procedures. Either way, the bucket id should be explicitly "
"specified in the request."
msgstr ""
"Запросы в базу данных можно производить из приложения или с помощью "
"хранимых процедур. В любом случае идентификатор сегмента следует явным "
"образом указать в запросе."

msgid ""
"All requests are forwarded to the ``router`` first. The only operation "
"supported by the ``router`` is ``call``. The operation is performed via "
"the ``vshard.router.call()`` function:"
msgstr ""
"Сначала все запросы направляются в роутер. Роутер поддерживает только "
"операцию вызова, которая выполняется с помощью функции "
"``vshard.router.call()``:"

msgid ""
"result = vshard.router.call(<bucket_id>, <mode>, <function_name>, "
"{<argument_list>}, {<opts>})"
msgstr ""
"result = vshard.router.call(<идентификатор_сегмента>, <режим>, "
"<имя_функции>, {<список_аргументов>}, {<опции>})"

msgid "Requests are processed as follows:"
msgstr "Запросы обрабатываются следующим образом:"

msgid ""
"The ``router`` uses the bucket id to search for a replica set with the "
"corresponding bucket in the routing table."
msgstr ""
"Роутер использует идентификатор сегмента для поиска набора реплик с "
"соответствующим сегментом в таблице маршрутизации."

msgid ""
"If the map of the bucket id to the replica set is not known to the "
"``router`` (the discovery fiber hasn’t filled the table yet), the "
"``router`` makes requests to all ``storages`` to find out where the "
"bucket is located."
msgstr ""
"Если роутер не содержит информацию о соответствии идентификатора сегмента"
" набору реплик (файбер обнаружения еще не заполнил таблицу), роутер "
"выполняет запросы ко всем хранилищам, чтобы обнаружить местонахождение "
"сегмента."

msgid "Once the bucket is located, the shard checks:"
msgstr "После обнаружения сегмента шард проверяет:"

msgid ""
"whether the bucket is stored in the ``_bucket`` system space of the "
"replica set;"
msgstr "хранится ли сегмент в системном спейсе ``_bucket`` набора реплик;"

msgid ""
"whether the bucket is ACTIVE or PINNED (for a read request, it can also "
"be SENDING)."
msgstr ""
"находится ли сегмент в статусе ACTIVE (активный) или PINNED "
"(закрепленный) (если выполняется запрос на чтение, то сегмент может "
"находиться в состоянии отправки SENDING)."

msgid ""
"If all the checks succeed, the request is executed. Otherwise, it is "
"terminated with the error: ``“wrong bucket”``."
msgstr ""
"Если проверка пройдена, запрос выполняется. В противном случае, "
"выполнение запроса прекращается с ошибкой: ``“wrong bucket”`` "
"(несоответствующий сегмент)."

msgid "Glossary"
msgstr "Глоссарий"

msgid "**Vertical scaling**"
msgstr "**Вертикальное масштабирование**"

msgid ""
"Adding more power to a single server: using a more powerful CPU, adding "
"more capacity to RAM, adding more storage space, etc."
msgstr ""
"Добавление мощности в отдельный сервер: использование более мощного "
"процессора, добавление оперативной памяти, добавление хранилищ и т.д. "

msgid "**Horizontal scaling**"
msgstr "**Горизонтальное масштабирование**"

msgid ""
"Adding more servers to the pool of resources, then partitioning and "
"distributing a dataset across the servers."
msgstr ""
"Добавление дополнительных серверов в пул ресурсов, последующее "
"секционирование и распределение набора данных по серверам."

msgid "**Sharding**"
msgstr "**Шардинг**"

msgid ""
"A database architecture that allows partitioning a dataset using a "
"sharding key and distributing a dataset across multiple servers. Sharding"
" is a special case of horizontal scaling."
msgstr ""
"Архитектура базы данных, которая допускает секционирование набора данных "
"по сегментному ключу и распределение набора данных по нескольким "
"серверам. Шардинг представляет собой частный случай горизонтального "
"масштабирования."

msgid "**Node**"
msgstr "**Узел**"

msgid "A virtual or physical server instance."
msgstr "Виртуальный или физический экземпляр сервера."

msgid "**Cluster**"
msgstr "**Кластер**"

msgid "A set of nodes that make up a single group."
msgstr "Набор узлов, которые составляют отдельную группу."

msgid "**Storage**"
msgstr "**Хранилище**"

msgid "A node storing a subset of a dataset."
msgstr "Узел, который хранит подмножество данных из набора."

msgid "**Replica set**"
msgstr "**Набор реплик**"

msgid ""
"A set of storage nodes storing copies of a dataset. Each storage in a "
"replica set has a role, master or replica."
msgstr ""
"Ряд узлов, на которых хранятся копии набора данных. У каждого хранилища в"
" наборе реплик есть роль: мастер или реплика."

msgid "**Master**"
msgstr "**Мастер**"

msgid "A storage in a replica set processing read and write requests."
msgstr ""
"Хранилище в наборе реплик, которое обрабатывает запросы на чтение и "
"запись."

msgid "**Replica**"
msgstr "**Реплика**"

msgid "A storage in a replica set processing only read requests."
msgstr "Хранилище в наборе реплик, которое обрабатывает только запросы на чтение."

msgid "**Read requests**"
msgstr "**Запросы на чтение**"

msgid "Read-only requests, that is, select requests."
msgstr "Запросы только на чтение, то есть выборка."

msgid "**Write requests**"
msgstr "**Запросы на запись**"

msgid "Data-change operations, that is create, replace, update, delete requests."
msgstr ""
"Операции по изменению данных, то есть запросы на создание, замену, "
"обновление и удаление данных."

msgid "**Buckets (virtual buckets)**"
msgstr "**Сегменты (виртуальные сегменты)**"

msgid ""
"The abstract virtual nodes into which the dataset is partitioned by the "
"sharding key (bucket id)."
msgstr ""
"Абстрактные виртуальные узлы, на которые производится секционирование "
"набора данных по сегментному ключу (идентификатору сегмента)."

msgid "**Bucket id**"
msgstr "**Идентификатор сегмента**"

#, fuzzy
msgid ""
"A sharding key defining which bucket belongs to which replica set. A "
"bucket id may be calculated from a :ref:`hash key <router_api-"
"bucket_id_strcrc32>`."
msgstr ""
"Сегментный ключ, который определяет принадлежность сегмента к "
"определенному набору реплик. Идентификатор сегмента можно вычислить из "
":ref:`хеш-ключа <router_api-bucket_id>`."

msgid "**Router**"
msgstr "**Роутер**"

msgid ""
"A proxy server responsible for routing requests from an application to "
"nodes in a cluster."
msgstr ""
"Прокси-сервер, который отвечает за запросы маршрутизации от приложения к "
"узлам в кластере."
