# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-06 07:42+0000\n"
"PO-Revision-Date: 2019-12-06 16:16+0300\n"
"Last-Translator: \n"
"Language: ru\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

msgid "Configuration reference"
msgstr "Справочник по настройке"

msgid "Basic parameters"
msgstr "Базовые параметры"

msgid ":ref:`sharding <cfg_basic-sharding>`"
msgstr ":ref:`sharding <cfg_basic-sharding>`"

msgid ":ref:`weights <cfg_basic-weights>`"
msgstr ":ref:`weights <cfg_basic-weights>`"

msgid ":ref:`shard_index <cfg_basic-shard_index>`"
msgstr ":ref:`shard_index <cfg_basic-shard_index>`"

msgid ":ref:`bucket_count <cfg_basic-bucket_count>`"
msgstr ":ref:`bucket_count <cfg_basic-bucket_count>`"

msgid ""
":ref:`collect_bucket_garbage_interval <cfg_basic-"
"collect_bucket_garbage_interval>`"
msgstr ""
":ref:`collect_bucket_garbage_interval <cfg_basic-"
"collect_bucket_garbage_interval>`"

msgid ":ref:`collect_lua_garbage <cfg_basic-collect_lua_garbage>`"
msgstr ":ref:`collect_lua_garbage <cfg_basic-collect_lua_garbage>`"

msgid ":ref:`sync_timeout <cfg_basic-sync_timeout>`"
msgstr ":ref:`sync_timeout <cfg_basic-sync_timeout>`"

msgid ""
":ref:`rebalancer_disbalance_threshold <cfg_basic-"
"rebalancer_disbalance_threshold>`"
msgstr ""
":ref:`rebalancer_disbalance_threshold <cfg_basic-"
"rebalancer_disbalance_threshold>`"

msgid ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"
msgstr ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"

#, fuzzy
msgid ":ref:`rebalancer_max_sending <cfg_basic-rebalancer_max_sending>`"
msgstr ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"

msgid "A field defining the logical topology of the sharded Tarantool cluster."
msgstr ""
"Поле, которое определяет логическую топологию сегментированного кластера "
"Tarantool'а."

msgid "Type: table"
msgstr "Тип: таблица"

msgid "Default: false"
msgstr "По умолчанию: false (ложь)"

msgid "Dynamic: yes"
msgstr "Динамический: да"

msgid ""
"A field defining the configuration of relative weights for each zone pair"
" in a replica set. See the :ref:`Replica weights <vshard-replica-"
"weights>` section."
msgstr ""
"Поле, которое определяет конфигурацию относительного веса для каждой пары"
" зон в наборе реплик. См. раздел :ref:`Вес реплики <vshard-replica-"
"weights>`."

msgid ""
"Name of a TREE index over the :ref:`bucket id <vshard-vbuckets>`. Spaces "
"without this index do not participate in a sharded Tarantool cluster and "
"can be used as regular spaces if needed."
msgstr ""

msgid "Type: non-empty string or non-negative integer"
msgstr "Тип: непустая строка или неотрицательное целое число"

#, fuzzy
msgid "Default: \"bucket_id\""
msgstr "По умолчанию: \".\""

msgid "Dynamic: no"
msgstr "Динамический: нет"

msgid "The total number of buckets in a cluster."
msgstr "Общее число сегментов в кластере."

msgid ""
"This number should be several orders of magnitude larger than the "
"potential number of cluster nodes, considering potential scaling out in "
"the foreseeable future."
msgstr ""
"Это число должно быть на несколько порядков больше, чем потенциальное "
"число узлов кластера, учитывая потенциальное масштабирование в обозримом "
"будущем."

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"If the estimated number of nodes is M, then the data set should be "
"divided into 100M or even 1000M buckets, depending on the planned scaling"
" out. This number is certainly greater than the potential number of "
"cluster nodes in the system being designed."
msgstr ""
"Если предполагаемое количество узлов равно M, тогда набор данных должен "
"быть разделен на 100M или даже 1000M сегментов, в зависимости от "
"запланированного масштабирования. Это число, безусловно, больше "
"потенциального числа узлов кластера в проектируемой системе."

msgid ""
"Keep in mind that too many buckets can cause a need to allocate more "
"memory to store routing information. On the other hand, an insufficient "
"number of buckets can lead to decreased granularity when rebalancing."
msgstr ""
"Следует помнить, что слишком большое число сегментов может привести к "
"необходимости выделять больше памяти для хранения информации о "
"маршрутизации. С другой стороны, недостаточное число сегментов может "
"привести к снижению степени детализации при балансировке."

msgid "Type: number"
msgstr "Тип: число"

msgid "Default: 3000"
msgstr "По умолчанию: 3000"

msgid "The interval between garbage collector actions, in seconds."
msgstr "Интервал между действиями сборщика мусора в секундах."

msgid "Default: 0.5"
msgstr "По умолчанию: 0.5"

#, fuzzy
msgid ""
"If set to true, the Lua ``collectgarbage()`` function is called "
"periodically."
msgstr ""
"Если задано значение true (правда), периодически вызывается Lua-функция "
"collectgarbage()."

msgid "Type: boolean"
msgstr "Тип: логический"

msgid "Default: no"
msgstr "По умолчанию: нет"

msgid ""
"Timeout to wait for synchronization of the old master with replicas "
"before demotion. Used when switching a master or when manually calling "
"the ``sync()`` function."
msgstr ""
"Время ожидания синхронизации старого мастера с репликами перед сменой "
"мастера. Используется при переключении мастера или при вызове функции "
"``sync()`` вручную."

msgid "Default: 1"
msgstr "По умолчанию: 1"

msgid ""
"A maximum bucket disbalance threshold, in percent. The threshold is "
"calculated for each replica set using the following formula:"
msgstr ""
"Максимальный предел дисбаланса сегментов в процентах. Предел вычисляется "
"для каждого набора реплик по следующей формуле:"

msgid "|etalon_bucket_count - real_bucket_count| / etalon_bucket_count * 100"
msgstr ""
"|эталонное_число_сегментов - фактическое_число_сегментов| / "
"эталонное_число_сегментов * 100"

#, fuzzy
msgid ""
"The maximum number of buckets that can be received in parallel by a "
"single replica set. This number must be limited, because when a new "
"replica set is added to a cluster, the rebalancer sends a very large "
"amount of buckets from the existing replica sets to the new replica set. "
"This produces a heavy load on the new replica set."
msgstr ""
"Максимальное количество сегментов, которые может получить параллельно "
"один набор реплик. Это число должно быть ограничено, так как при "
"добавлении нового набора реплик в кластер балансировщик отправляет очень "
"большое количество сегментов из существующих наборов реплик в новый набор"
" реплик. Это создает большую нагрузку на новый набор реплик."

msgid ""
"Suppose ``rebalancer_max_receiving`` is equal to 100, ``bucket_count`` is"
" equal to 1000. There are 3 replica sets with 333, 333 and 334 buckets on"
" each respectively. When a new replica set is added, each replica set’s "
"``etalon_bucket_count`` becomes equal to 250. Rather than receiving all "
"250 buckets at once, the new replica set receives 100, 100 and 50 buckets"
" sequentially."
msgstr ""
"Предположим, ``rebalancer_max_receiving`` = 100, число сегментов в "
"``bucket_count`` = 1000. Есть 3 набора реплик с 333, 333 и 334 сегментами"
" соответственно. При добавлении нового набора реплик "
"``эталонное_число_сегментов`` становится равным 250. Вместо того, чтобы "
"сразу получить все 250 сегментов, новый набор реплик получит "
"последовательно 100, 100 и 50 сегментов."

msgid "Default: 100"
msgstr "По умолчанию: 100"

msgid ""
"The degree of parallelism for :ref:`parallel rebalancing <vshard-"
"parallel-rebalancing>`."
msgstr ""

msgid "Works for storages only, ignored for routers."
msgstr ""

msgid "The maximum value is ``15``."
msgstr ""

msgid "Replica set functions"
msgstr "Функции набора реплик"

msgid ":ref:`uuid <cfg_replica_set-uuid>`"
msgstr ":ref:`uuid <cfg_replica_set-uuid>`"

msgid ":ref:`weight <cfg_replica_set-weight>`"
msgstr ":ref:`weight <cfg_replica_set-weight>`"

msgid "A unique identifier of a replica set."
msgstr "Уникальный идентификатор набора реплик."

msgid "Type:"
msgstr "Тип:"

msgid "Default:"
msgstr "По умолчанию:"

msgid "Dynamic:"
msgstr "Динамическое:"

msgid ""
"A weight of a replica set. See the :ref:`Replica set weights <vshard-"
"replica-set-weights>` section for details."
msgstr ""
"Вес набора реплик. Для получения подробной информации см. раздел "
":ref:`Вес набора реплик <vshard-replica-set-weights>`."

msgid "API reference"
msgstr "Справочник по API"

msgid "Router public API"
msgstr "Общедоступные API роутера"

msgid ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"
msgstr ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"

msgid ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"
msgstr ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"

msgid ":ref:`vshard.router.new(name, cfg) <router_api-new>`"
msgstr ":ref:`vshard.router.new(name, cfg) <router_api-new>`"

msgid ""
":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list},"
" {options}) <router_api-call>`"
msgstr ""
":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list},"
" {options}) <router_api-call>`"

msgid ""
":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callro>`"
msgstr ""
":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callro>`"

msgid ""
":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callrw>`"
msgstr ""
":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callrw>`"

msgid ""
":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callre>`"
msgstr ""
":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callre>`"

msgid ""
":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbro>`"
msgstr ""
":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbro>`"

msgid ""
":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbre>`"
msgstr ""
":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbre>`"

msgid ":ref:`vshard.router.route(bucket_id) <router_api-route>`"
msgstr ":ref:`vshard.router.route(bucket_id) <router_api-route>`"

msgid ":ref:`vshard.router.routeall() <router_api-routeall>`"
msgstr ":ref:`vshard.router.routeall() <router_api-routeall>`"

#, fuzzy
msgid ""
":ref:`vshard.router.bucket_id_strcrc32(key) <router_api-"
"bucket_id_strcrc32>`"
msgstr ":ref:`vshard.router.bucket_id(key) <router_api-bucket_id>`"

#, fuzzy
msgid ":ref:`vshard.router.bucket_id_mpcrc32(key) <router_api-bucket_id_mpcrc32>`"
msgstr ":ref:`vshard.router.bucket_id(key) <router_api-bucket_id>`"

msgid ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"
msgstr ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"

msgid ":ref:`vshard.router.sync(timeout) <router_api-sync>`"
msgstr ":ref:`vshard.router.sync(timeout) <router_api-sync>`"

msgid ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"
msgstr ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"

msgid ":ref:`vshard.router.info() <router_api-info>`"
msgstr ":ref:`vshard.router.info() <router_api-info>`"

msgid ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"
msgstr ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"

msgid ":ref:`replicaset.call() <router_api-replicaset_call>`"
msgstr ":ref:`replicaset.call() <router_api-replicaset_call>`"

msgid ":ref:`replicaset.callro() <router_api-replicaset_callro>`"
msgstr ":ref:`replicaset.callro() <router_api-replicaset_callro>`"

msgid ":ref:`replicaset.callrw() <router_api-replicaset_callrw>`"
msgstr ":ref:`replicaset.callrw() <router_api-replicaset_callrw>`"

msgid ":ref:`replicaset.callre() <router_api-replicaset_callre>`"
msgstr ":ref:`replicaset.callre() <router_api-replicaset_callre>`"

msgid ""
"Perform the initial cluster bootstrap and distribute all buckets across "
"the replica sets."
msgstr ""
"Выполнение первоначальной настройки кластера и распределение всех "
"сегментов по наборам реплик."

msgid "Parameters"
msgstr "Параметры"

msgid ""
"a number of seconds before ending a bootstrap attempt as unsuccessful. "
"Recreate the cluster in case of bootstrap timeout."
msgstr ""

msgid ""
"by default is set to ``false`` that means raise an error, when the "
"cluster is already bootstrapped. ``True`` means consider an already "
"bootstrapped cluster a success."
msgstr ""

#, fuzzy
msgid "vshard.router.bootstrap({timeout = 4, if_not_bootstrapped = true})"
msgstr ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"

msgid ""
"To detect whether a cluster is bootstrapped, ``vshard`` looks for at "
"least one bucket in the whole cluster. If the cluster was bootstrapped "
"only partially (for example, due to an error during the first bootstrap),"
" then it will be considered a bootstrapped cluster on a next bootstrap "
"call with ``if_not_bootstrapped``. So this is still a bad practice. Avoid"
" calling ``bootstrap()`` multiple times."
msgstr ""

msgid ""
"Configure the database and start sharding for the specified ``router`` "
"instance. See the :ref:`sample configuration <vshard-config-cluster-"
"example>` above."
msgstr ""
"Настройка базы данных и начало шардинга указанного ``роутера``. См. "
":ref:`образец конфигурации<vshard-config-cluster-example>` выше."

msgid "a configuration table"
msgstr "конфигурационная таблица"

msgid ""
"Create a new router instance. ``vshard`` supports multiple routers in a "
"single Tarantool instance. Each router can be connected to any ``vshard``"
" cluster, and multiple routers can be connected to the same cluster."
msgstr ""
"Создание нового экземпляра роутера. ``vshard`` поддерживает работу "
"нескольких роутеров в отдельном экземпляре Tarantool'а. Каждый роутер "
"может подключаться к любом кластеру ``vshard``, несколько роутеров могут "
"подключаться к одному кластеру."

msgid ""
"A router created via ``vshard.router.new()`` works in the same way as a "
"static router, but the method name is preceded by a colon "
"(``vshard.router:method_name(...)``), while for a static router the "
"method name is preceded by a period (``vshard.router.method_name(...)``)."
msgstr ""
"Роутер, созданный с помощью ``vshard.router.new()``, работает так же, как"
" и статичный роутер, но перед его методами указывается двоеточие "
"(``vshard.router:имя_метода(...)``), а перед методами статичного роутера "
"-- точка (``vshard.router.имя_метода(...)``)."

msgid ""
"A static router can be obtained via the ``vshard.router.static()`` method"
" and then used like a router created via the ``vshard.router.new()`` "
"method."
msgstr ""
"Статичный роутер можно получить при помощи метода "
"``vshard.router.static()``, а затем использовать его как роутер, "
"созданный с помощью метода ``vshard.router.new()``."

msgid "``box.cfg`` is shared among all the routers of a single instance."
msgstr "``box.cfg`` используется всеми роутерами одного экземпляра."

msgid ""
"a router instance name. This name is used as a prefix in logs of the "
"router and must be unique within the instance"
msgstr ""
"имя экземпляра роутера, которое используется в качестве префикса в "
"журналах роутера и должно быть уникальным в пределах экземпляра"

msgid ""
"a configuration table. The :ref:`sample configuration <vshard-config-"
"cluster-example>` is described above."
msgstr ""
"конфигурационная таблица. :ref:`Образец конфигурации <vshard-config-"
"cluster-example>` описан выше."

msgid "Return"
msgstr "Возвращается"

msgid ""
"a router instance, if created successfully; otherwise, nil and an error "
"object"
msgstr "экземпляр роутера, если он создан; в противном случае, nil и ошибка"

msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id. See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id). Для получения подробной "
"информации о работе функции см. раздел :ref:`Обработка запросов <vshard-"
"process-requests>`."

msgid "a bucket identifier"
msgstr "идентификатор сегмента"

msgid ""
"either a string = 'read'|'write', or a map with mode='read'|'write' "
"and/or prefer_replica=true|false and/or balance=true|false."
msgstr ""
"либо строка = 'read'|'write' (чтение|запись), либо ассоциативный массив с"
" параметром mode ='read'|'write' (чтение|запись) и/или "
"prefer_replica=true|false (правда|ложь), и/или balance=true|false "
"(правда|ложь)."

msgid "a function to execute"
msgstr "выполняемая функция"

msgid "an array of the function's arguments"
msgstr "массив аргументов функции"

#, fuzzy
msgid ""
"* ``timeout`` – a request timeout, in seconds. If the router cannot "
"identify a   shard with the specified ``bucket_id``, the operation will "
"be repeated until the   timeout is reached."
msgstr ""
"* ``timeout`` -- время ожидания запроса в секундах. Если роутер не может "
"определить шард с указанным идентификатором сегмента, операция "
"повторяется до истечения времени ожидания."

#, fuzzy
msgid ""
"``timeout`` – a request timeout, in seconds. If the router cannot "
"identify a shard with the specified ``bucket_id``, the operation will be "
"repeated until the timeout is reached."
msgstr ""
"``timeout`` -- время ожидания запроса в секундах. Если роутер не может "
"определить шард с указанным идентификатором сегмента, операция "
"повторяется до истечения времени ожидания."

msgid ""
"The mode parameter has two possible forms: a string or a map. Examples of"
" the string form are: ``'read'``, ``'write'``. Examples of the map form "
"are: ``{mode='read'}``, ``{mode='write'}``, ``{mode='read', "
"prefer_replica=true}``, ``{mode='read', balance=true}``, ``{mode='read', "
"prefer_replica=true, balance=true}``."
msgstr ""

msgid "If ``'write'`` is specified then the target is the master."
msgstr ""

msgid ""
"If ``prefer_replica=true`` is specified then the preferred target is one "
"of the replicas, but the target is the master if there is no conveniently"
" available replica."
msgstr ""

msgid ""
"It may be good to specify prefer_replica=true for functions which are "
"expensive in terms of resource use, to avoid slowing down the master."
msgstr ""

msgid ""
"If ``balance=true`` then there is load balancing -- reads are distributed"
" over all the nodes in the replica set in round-robin fashion, with a "
"preference for replicas if prefer_replica=true is also set."
msgstr ""

msgid ""
"The original return value of the executed function, or ``nil`` and error "
"object. The error object has a type attribute equal to ``ShardingError`` "
"or one of the regular Tarantool errors (``ClientError``, ``OutOfMemory``,"
" ``SocketError``, etc.)."
msgstr ""
"Исходное возвращаемое значение выполняемой функции или ``nil`` и ошибка. "
"Объект ошибки содержит атрибут типа, который равен ``ShardingError`` или "
"одной из стандартных ошибок Tarantool'а(``ClientError``, ``OutOfMemory``,"
" ``SocketError`` и т.д.)."

msgid ""
"``ShardingError`` is returned on errors specific for sharding: the master"
" is missing, wrong bucket id, etc. It has an attribute code containing "
"one of the values from the ``vshard.error.code.*`` LUA table, an optional"
" attribute containing a message with the human-readable error "
"description, and other attributes specific for the error code."
msgstr ""

msgid "**Examples:**"
msgstr "**Примеры:**"

msgid "To call ``customer_add`` function from ``vshard/example``, say:"
msgstr ""
"Для вызова функции ``customer_add`` из ``vshard/example`` выполните "
"команду:"

msgid ""
"vshard.router.call(100, 'write', 'customer_add', {{customer_id = 2, "
"bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})\n"
"-- or, the same thing but with a map for the second argument\n"
"vshard.router.call(100, {mode='write'}, 'customer_add', {{customer_id = "
"2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})"
msgstr ""
"vshard.router.call(100, 'write', 'customer_add', {{customer_id = 2, "
"bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})\n"
"-- или то же самое, но с ассоциативным массивом в качестве второго "
"аргумента\n"
"vshard.router.call(100, {mode='write'}, 'customer_add', {{customer_id = "
"2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})"

msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-only mode (similar to calling "
"vshard.router.call with mode='read'). See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id) в режиме только для "
"чтения (аналогично вызову vshard.router.call в режиме mode='read'). Для "
"получения подробной информации о работе функции см. раздел "
":ref:`Обработка запросов <vshard-process-requests>`."

msgid ""
"* ``timeout`` – a request timeout, in seconds. In case the ``router`` "
"cannot identify a   shard with the bucket id, the operation will be "
"repeated until the   timeout is reached."
msgstr ""
"* ``timeout`` -- время ожидания запроса в секундах. Если ``роутер`` не "
"может определить шард с идентификатором сегмента, операция повторяется до"
" истечения времени ожидания."

msgid ""
"``timeout`` – a request timeout, in seconds. In case the ``router`` "
"cannot identify a shard with the bucket id, the operation will be "
"repeated until the timeout is reached."
msgstr ""
"``timeout`` -- время ожидания запроса в секундах. Если ``роутер`` не "
"может определить шард с идентификатором сегмента, операция повторяется до"
" истечения времени ожидания."

msgid ""
"``ShardingError`` is returned on errors specific for sharding: the "
"replica set is not available, the master is missing, wrong bucket id, "
"etc. It has an attribute code containing one of the values from the "
"``vshard.error.code.*`` LUA table, an optional attribute containing a "
"message with the human-readable error description, and other attributes "
"specific for this error code."
msgstr ""
"``ShardingError`` возвращается в случае ошибок шардинга: набор реплик "
"недоступен, отсутствует мастер, неверный идентификатор сегмента и т.д. "
"Такая ошибка сб.одержит код с одним из значений из Lua-таблицы "
"``vshard.error.code.*``, необязательный атрибут сообщения с удобным для "
"восприятия описанием ошибки и другие атрибуты, специфичные для данного "
"кода ошибки."

msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-write mode (similar to calling "
"vshard.router.call with mode='write'). See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id) в режиме чтения и записи "
"(аналогично вызову vshard.router.call в режиме mode='write'). Для "
"получения подробной информации о работе функции см. раздел "
":ref:`Обработка запросов <vshard-process-requests>`."

#, fuzzy
msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-only mode (similar to calling "
"``vshard.router.call`` with ``mode='read'``), with preference for a "
"replica rather than a master (similar to calling ``vshard.router.call`` "
"with ``prefer_replica = true``). See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id) в режиме только для "
"чтения (аналогично вызову vshard.router.call в режиме mode='read'), когда"
" предпочтение отдается реплике, а не мастеру (аналогично вызову "
"vshard.router.call с параметром  prefer_replica = true). Для получения "
"подробной информации о работе функции см. раздел :ref:`Обработка запросов"
" <vshard-process-requests>`."

msgid ""
"This has the same effect as :ref:`vshard.router.call() <router_api-call>`"
" with mode parameter = {mode='read', balance=true}."
msgstr ""
"Эквивалент :ref:`vshard.router.call() <router_api-call>` с параметром "
"mode = {mode='read', balance=true}."

#, fuzzy
msgid ""
"This has the same effect as :ref:`vshard.router.call() <router_api-call>`"
" with mode ``parameter = {mode='read', balance=true, "
"prefer_replica=true}``."
msgstr ""
"Эквивалент :ref:`vshard.router.call() <router_api-call>` с параметром "
"mode = {mode='read', balance=true, prefer_replica=true}."

msgid ""
"Return the replica set object for the bucket with the specified bucket id"
" value."
msgstr ""
"Возврат объекта набора реплик для сегмента с указанным значением "
"идентификатора сегмента (bucket id)."

msgid "a replica set object"
msgstr "объект набора реплик"

msgid "replicaset = vshard.router.route(123)"
msgstr "replicaset = vshard.router.route(123)"

msgid "Return all available replica set objects."
msgstr "Возврат всех доступных объектов наборов реплик."

msgid "a map of the following type: ``{UUID = replicaset}``"
msgstr "ассоциативный массив следующего вида: ``{UUID = replicaset}``"

msgid "Rtype"
msgstr "Тип возвращаемого значения"

msgid "replicaset = vshard.router.routeall()"
msgstr "replicaset = vshard.router.routeall()"

msgid ""
"**Deprecated**. Logs a warning when used because it is not consistent for"
" cdata numbers."
msgstr ""

msgid ""
"In particular, it returns 3 different values for normal Lua numbers like "
"123, for unsigned long long cdata (like ``123ULL``, or "
"``ffi.cast('unsigned long long',123)``), and for signed long long cdata "
"(like ``123LL``, or ``ffi.cast('long long', 123)``). And it is important."
msgstr ""

msgid ""
"vshard.router.bucket_id(123)\n"
"vshard.router.bucket_id(123LL)\n"
"vshard.router.bucket_id(123ULL)"
msgstr ""

msgid ""
"For float and double cdata (``ffi.cast('float', number)``, "
"``ffi.cast('double', number)``) these functions return different values "
"even for the same numbers of the same floating point type. This is "
"because ``tostring()`` on a floating point cdata number returns not the "
"number, but a pointer at it. Different on each call."
msgstr ""

msgid ""
"``vshard.router.bucket_id_strcrc32()`` behaves exactly the same, but does"
" not log a warning. In case you need that behavior."
msgstr ""

msgid "Calculate the bucket id using a simple built-in hash function."
msgstr ""
"Вычисление идентификатора сегмента с помощью простой встроенной "
"хеш-функции."

msgid "a hash key. This can be any Lua object (number, table, string)."
msgstr "хеш-ключ. Это может быть любой Lua-объект (число, таблица, строка)."

msgid "number"
msgstr "число"

#, fuzzy
msgid "bucket_id = vshard.router.bucket_id_strcrc32(18374927634039)"
msgstr "bucket_id = vshard.router.bucket_id(18374927634039)"

msgid ""
"Remember that it is not safe. See details in :ref:`bucket_id() "
"<router_api-bucket_id>`"
msgstr ""

msgid ""
"This function is safer than ``bucket_id_strcrc32``. It takes a CRC32 from"
" a MessagePack encoded value. That is, bucket id of integers does not "
"depend on their Lua type. In case of a string key, it does not encode it "
"into MessagePack, but takes a hash right from the string."
msgstr ""

msgid ""
"However it still may return different values for not equal floating point"
" types. That is, ``ffi.cast('float', number)`` may be reflected into a "
"bucket id not equal to ``ffi.cast('double', number)``. This can't be "
"fixed, because a float value, even being casted to double, may have a "
"garbage tail in its fraction."
msgstr ""

msgid "Floating point keys should not be used to calculate a bucket id, usually."
msgstr ""

msgid ""
"Be very careful in case you store floating point types in a space. When "
"data is returned from a space, it is cast to Lua number. And if that "
"value had an empty fraction part, it will be treated as an integer by "
"``bucket_id_mpcrc32()``. So you need to do explicit casts in such cases. "
"Here is an example of the problem:"
msgstr ""

msgid ""
"tarantool> s = box.schema.create_space('test', {format = {{'id', "
"'double'}}}); _ = s:create_index('pk')\n"
"---\n"
"...\n"
"\n"
"tarantool> inserted = ffi.cast('double', 1)\n"
"---\n"
"...\n"
"\n"
"-- Value is stored as double\n"
"tarantool> s:replace({inserted})\n"
"---\n"
"- [1]\n"
"...\n"
"\n"
"-- But when returned to Lua, stored as Lua number, not cdata.\n"
"tarantool> returned = s:get({inserted}).id\n"
"---\n"
"...\n"
"\n"
"tarantool> type(returned), returned\n"
"---\n"
"- number\n"
"- 1\n"
"...\n"
"\n"
"tarantool> vshard.router.bucket_id_mpcrc32(inserted)\n"
"---\n"
"- 1411\n"
"...\n"
"tarantool> vshard.router.bucket_id_mpcrc32(returned)\n"
"---\n"
"- 1614\n"
"..."
msgstr ""

msgid "Return the total number of buckets specified in ``vshard.router.cfg()``."
msgstr "Возврат общего количества сегментов, указанных в `vshard.router.cfg()``."

msgid "the total number of buckets"
msgstr "общее количество сегментов"

msgid "Wait until the dataset is synchronized on replicas."
msgstr "Ожидание синхронизации набора данных на репликах."

msgid "a timeout, in seconds"
msgstr "время ожидания в секундах"

msgid "return"
msgstr "возвращает"

msgid ""
"``true`` if the dataset was synchronized successfully; or ``nil`` and "
"``err`` explaining why the dataset cannot be synchronized."
msgstr ""
"``true`` (правда), если выполнена синхронизация набора данных; или же "
"``nil`` и ошибка ``err`` с объяснением причины невозможности "
"синхронизации набора данных."

msgid "Force wakeup of the bucket discovery fiber."
msgstr "Принудительный запуск файбера обнаружения сегментов."

msgid "Return information about each instance."
msgstr "Возврат информации по каждому экземпляру."

msgid "Replica set parameters:"
msgstr "Параметры набора реплик:"

msgid "replica set uuid"
msgstr "UUID набора реплик"

msgid "master instance parameters"
msgstr "параметры мастер-экземпляра"

msgid "replica instance parameters"
msgstr "параметры реплики"

msgid "Instance parameters:"
msgstr "Параметры экземпляра:"

msgid "``uri`` — URI of the instance"
msgstr "``uri`` -- URI экземпляра"

msgid "``uuid`` — UUID of the instance"
msgstr "``uuid`` -- UUID экземпляра"

msgid ""
"``status`` – status of the instance (``available``, ``unreachable``, "
"``missing``)"
msgstr ""
"``status`` -- статус экземпляра: ``available`` (доступный), "
"``unreachable`` (недоступный), ``missing`` (отсутствующий)"

msgid ""
"``network_timeout`` – a timeout for the request. The value is updated "
"automatically on each 10th successful request and each 2nd failed "
"request."
msgstr ""
"``network_timeout`` -- время ожидания запроса. Данное значение "
"обновляется автоматически на каждом 10 выполненном запросе и на каждом 2 "
"невыполненном запросе."

msgid "Bucket parameters:"
msgstr "Параметры сегмента:"

msgid ""
"``available_ro`` – the number of buckets known to the ``router`` and "
"available for read requests"
msgstr ""
"``available_ro`` -- количество сегментов, известных роутеру и доступных "
"для запросов чтения"

msgid ""
"``available_rw`` – the number of buckets known to the router and "
"available for read and write requests"
msgstr ""
"``available_rw`` -- количество сегментов, известных роутеру и доступных "
"для запросов чтения и записи"

msgid ""
"``unavailable`` – the number of buckets known to the ``router`` but "
"unavailable for any requests"
msgstr ""
"``unavailable`` -- количество сегментов, известных роутеру, но "
"недоступных для любых запросов"

msgid ""
"``unreachable`` – the number of buckets whose replica sets are not known "
"to the ``router``"
msgstr ""
"``unreachable``-- количество сегментов, для которых роутер не знает "
"соответствующие наборы реплик"

msgid ""
"tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""
"tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."

msgid ""
"Return information about each bucket. Since a bucket map can be huge, "
"only the required range of buckets can be specified."
msgstr ""
"Возврат информации по каждому сегменту. Поскольку массив сегментов может "
"быть огромен, можно указать только необходимый ряд сегментов."

msgid "the offset in a bucket map of the first bucket to show"
msgstr "начальное значение выборки сегментов"

msgid "the maximum number of buckets to show"
msgstr "максимальное количество показываемых сегментов"

msgid "a map of the following type: ``{bucket_id = 'unknown'/replicaset_uuid}``"
msgstr ""
"ассоциативный массив следующего вида: ``{bucket_id = "
"'unknown'/replicaset_uuid}``"

msgid ""
"Call a function on a nearest available master (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with specified "
"arguments."
msgstr ""
"Вызов функции с указанными аргументами на ближайшем доступном мастере "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``)."

msgid "The ``replicaset.call`` method is similar to ``replicaset.callrw``."
msgstr "Метод ``replicaset.call`` аналогичен ``replicaset.callrw``."

msgid "UUID of a replica set"
msgstr "UUID набора реплик"

msgid "function to execute"
msgstr "выполняемая функция"

msgid "array of the function's arguments"
msgstr "массив аргументов функции"

msgid ""
"Call a function on a nearest available master (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with a specified "
"arguments."
msgstr ""
"Вызов функции с указанными аргументами на ближайшем доступном мастере "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``)."

msgid "The ``replicaset.callrw`` method is similar to ``replicaset.call``."
msgstr "Метод ``replicaset.callrw`` аналогичен ``replicaset.call``."

msgid ""
"Call a function on the nearest available replica (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with specified "
"arguments. It is recommended to call only read-only functions using "
"``replicaset.callro()``, as the function can be executed not only on a "
"master, but also on replicas."
msgstr ""
"Вызов функции с указанными аргументами на ближайшей доступной реплике "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``). С помощью ``replicaset.callro()`` рекомендуется "
"вызывать исключительно функции, доступные только для чтения. поскольку "
"такие функции можно выполнять не только на мастере, но и на репликах."

msgid ""
"Call a function on the nearest available replica (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with specified "
"arguments, with preference for a replica rather than a master (similar to"
" calling vshard.router.call with prefer_replica = true). It is "
"recommended to call only read-only functions using "
"``replicaset.callre()``, as the function can be executed not only on a "
"master, but also on replicas."
msgstr ""
"Вызов функции с указанными аргументами на ближайшей доступной реплике "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``), предпочтение отдается реплике, а не мастеру (аналогично"
" вызову vshard.router.call с параметром prefer_replica = true). С помощью"
" ``replicaset.callre()`` рекомендуется вызывать исключительно функции, "
"доступные только для чтения. поскольку такие функции можно выполнять не "
"только на мастере, но и на репликах."

msgid "Router internal API"
msgstr "Внутренние API роутера"

msgid ""
":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-"
"bucket_discovery>`"
msgstr ""
":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-"
"bucket_discovery>`"

msgid ""
"Search for the bucket in the whole cluster. If the bucket is not found, "
"it is likely that it does not exist. The bucket might also be moved "
"during rebalancing and currently is in the RECEIVING state."
msgstr ""
"Поиск сегмента по всему кластеру. Если сегмент не обнаружен, скорее "
"всего, он не существует. Также сегмент также может быть перемещен во "
"время балансировки и в данный момент находится в статусе получения "
"RECEIVING."

msgid "Storage public API"
msgstr "Общедоступные API хранилища"

msgid ":ref:`vshard.storage.cfg(cfg, name) <storage_api-cfg>`"
msgstr ":ref:`vshard.storage.cfg(cfg, name) <storage_api-cfg>`"

msgid ":ref:`vshard.storage.info() <storage_api-info>`"
msgstr ":ref:`vshard.storage.info() <storage_api-info>`"

msgid ""
":ref:`vshard.storage.call(bucket_id, mode, function_name, "
"{argument_list}) <storage_api-call>`"
msgstr ""
":ref:`vshard.storage.call(bucket_id, mode, function_name, "
"{argument_list}) <storage_api-call>`"

msgid ":ref:`vshard.storage.sync(timeout) <storage_api-sync>`"
msgstr ":ref:`vshard.storage.sync(timeout) <storage_api-sync>`"

msgid ":ref:`vshard.storage.bucket_pin(bucket_id) <storage_api-bucket_pin>`"
msgstr ":ref:`vshard.storage.bucket_pin(bucket_id) <storage_api-bucket_pin>`"

msgid ":ref:`vshard.storage.bucket_unpin(bucket_id) <storage_api-bucket_unpin>`"
msgstr ":ref:`vshard.storage.bucket_unpin(bucket_id) <storage_api-bucket_unpin>`"

msgid ":ref:`vshard.storage.bucket_ref(bucket_id, mode) <storage_api-bucket_ref>`"
msgstr ":ref:`vshard.storage.bucket_ref(bucket_id, mode) <storage_api-bucket_ref>`"

msgid ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"
msgstr ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"

msgid ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"
msgstr ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"

msgid ""
":ref:`vshard.storage.bucket_unref(bucket_id, mode) <storage_api-"
"bucket_unref>`"
msgstr ""
":ref:`vshard.storage.bucket_unref(bucket_id, mode) <storage_api-"
"bucket_unref>`"

msgid ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"
msgstr ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"

msgid ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"
msgstr ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"

msgid ""
":ref:`vshard.storage.find_garbage_bucket(bucket_index, control) "
"<storage_api-find_garbage_bucket>`"
msgstr ""
":ref:`vshard.storage.find_garbage_bucket(bucket_index, control) "
"<storage_api-find_garbage_bucket>`"

msgid ""
":ref:`vshard.storage.rebalancer_disable() <storage_api-"
"rebalancer_disable>`"
msgstr ""
":ref:`vshard.storage.rebalancer_disable() <storage_api-"
"rebalancer_disable>`"

msgid ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"
msgstr ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"

msgid ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"
msgstr ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"

msgid ""
":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-"
"rebalancing_is_in_progress>`"
msgstr ""
":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-"
"rebalancing_is_in_progress>`"

msgid ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"
msgstr ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"

msgid ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"
msgstr ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"

msgid ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"
msgstr ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"

msgid ""
"Configure the database and start sharding for the specified ``storage`` "
"instance."
msgstr ""
"Конфигурация базы данных и начало шардинга на указанном экземпляре "
"хранилища."

msgid "a ``storage`` configuration"
msgstr "конфигурация хранилища"

msgid "UUID of the instance"
msgstr "UUID экземпляра"

msgid "Return information about the storage instance in the following format:"
msgstr "Возврат информации по экземпляру хранилища в следующем формате:"

msgid ""
"tarantool> vshard.storage.info()\n"
"---\n"
"- buckets:\n"
"    2995:\n"
"      status: active\n"
"      id: 2995\n"
"    2997:\n"
"      status: active\n"
"      id: 2997\n"
"    2999:\n"
"      status: active\n"
"      id: 2999\n"
"  replicasets:\n"
"    2dd0a343-624e-4d3a-861d-f45efc571cd3:\n"
"      uuid: 2dd0a343-624e-4d3a-861d-f45efc571cd3\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"        uuid: 2ec29309-17b6-43df-ab07-b528e1243a79\n"
"    c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1:\n"
"      uuid: c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"        uuid: 810d85ef-4ce4-4066-9896-3c352fec9e64\n"
"..."
msgstr ""
"tarantool> vshard.storage.info()\n"
"---\n"
"- buckets:\n"
"    2995:\n"
"      status: active\n"
"      id: 2995\n"
"    2997:\n"
"      status: active\n"
"      id: 2997\n"
"    2999:\n"
"      status: active\n"
"      id: 2999\n"
"  replicasets:\n"
"    2dd0a343-624e-4d3a-861d-f45efc571cd3:\n"
"      uuid: 2dd0a343-624e-4d3a-861d-f45efc571cd3\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"        uuid: 2ec29309-17b6-43df-ab07-b528e1243a79\n"
"    c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1:\n"
"      uuid: c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"        uuid: 810d85ef-4ce4-4066-9896-3c352fec9e64\n"
"..."

msgid "Call the specified function on the current ``storage`` instance."
msgstr "Вызов указанной функции на текущем экземпляре хранилища."

msgid "a type of the function: 'read' or 'write'"
msgstr "тип функции: 'read' или 'write' (чтение или запись)"

msgid ""
"The original return value of the executed function, or ``nil`` and error "
"object."
msgstr "Исходное возвращаемое значение выполняемой функции или ``nil`` и ошибка."

msgid ""
"Pin a bucket to a replica set. A pinned bucket cannot be moved even if it"
" breaks the cluster balance."
msgstr ""
"Закрепление сегмента в наборе реплик. Закрепленный сегмент нельзя "
"перемещать, даже если это нарушает баланс в кластере."

msgid ""
"``true`` if the bucket is pinned successfully; or ``nil`` and ``err`` "
"explaining why the bucket cannot be pinned"
msgstr ""
"``true`` (правда), если выполнено закрепление сегмента; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности закрепления сегмента"

msgid "Return a pinned bucket back into the active state."
msgstr "Возврат закрепленного сегмента в активное состояние."

msgid ""
"``true`` if the bucket is unpinned successfully; or ``nil`` and ``err`` "
"explaining why the bucket cannot be unpinned"
msgstr ""
"``true`` (правда), если выполнено открепление сегмента; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности открепления сегмента"

msgid "Create an RO or RW :ref:`ref <vshard-ref>`."
msgstr "Создание :ref:`ссылки <vshard-ref>` типа RO или RW."

msgid "'read' or 'write'"
msgstr "'read' или 'write' (чтение или запись)"

msgid ""
"``true`` if the bucket ref is created successfully; or ``nil`` and "
"``err`` explaining why the ref cannot be created"
msgstr ""
"``true`` (правда), если выполнено создание ссылки; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности создания ссылки"

msgid ""
"An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in"
" the RO mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` в"
" режиме только чтения."

msgid ""
"An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in"
" the RW mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` в"
" режиме чтения и записи."

msgid "Remove a RO/RW :ref:`ref <vshard-ref>`."
msgstr "Удаление :ref:`ссылки <vshard-ref>` RO/RW."

msgid ""
"``true`` if the bucket ref is removed successfully; or ``nil`` and "
"``err`` explaining why the ref cannot be removed"
msgstr ""
"``true`` (правда), если выполнено удаление ссылки; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности удаления ссылки"

msgid ""
"An alias for :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` in the RO mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` в режиме только чтения."

msgid ""
"An alias for :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` in the RW mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` в режиме чтения и записи."

msgid ""
"Find a bucket which has data in a space but is not stored in a "
"``_bucket`` space; or is in a GARBAGE state."
msgstr ""
"Поиск сегмента, который хранит данные в спейсе, но не указан в спейсе "
"``_bucket``, или находится в статусе мусора (GARBAGE)."

msgid "index of a space with the part of a bucket id"
msgstr "индекс спейса с частью идентификатора спейса"

msgid ""
"a garbage collector controller. If there is an increased buckets "
"generation, then the search should be interrupted."
msgstr ""
"контроллер сборщика мусора. Если увеличивается масштаб создания "
"сегментов, поиск следует прервать."

msgid "an identifier of the bucket in the garbage state, if found; otherwise, nil"
msgstr ""
"идентификатор сегмента в статусе мусора, если таковой обнаружен; в "
"противном случае, nil"

msgid "Return information about each bucket located in storage. For example:"
msgstr ""
"Возврат информации по каждому сегменту, расположенному в хранилище. "
"Например:"

msgid ""
"vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"
msgstr ""
"vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"

msgid "Return the number of buckets located in storage."
msgstr "Возврат количества сегментов, расположенных в хранилище."

msgid "Immediately wake up a recovery fiber, if it exists."
msgstr "Немедленный запуск файбера восстановления, если такой есть."

msgid ""
"Return a flag indicating whether rebalancing is in progress. The result "
"is true if the node is currently applying routes received from a "
"rebalancer node in the special fiber."
msgstr ""
"Возврат флага, указывающего на ход процесса балансировки. Результатом "
"будет true (правда), если в данный момент узел применяет маршруты, "
"полученные от узла балансировки в специальном файбере."

msgid "Return a flag indicating whether storage is invisible to the rebalancer."
msgstr "Возврат флага, указывающего на недоступность хранилища для балансировщика."

msgid ""
"Disable rebalancing. A disabled rebalancer sleeps until it is enabled "
"again with vshard.storage.rebalancer_enable()."
msgstr ""
"Отключение балансировки. Отключенный балансировщик находится в режиме "
"ожидания до повторного запуска с помощью "
"vshard.storage.rebalancer_enable()."

msgid "Enable rebalancing."
msgstr "Запуск балансировки."

msgid ""
"Show the spaces that are visible to rebalancer and garbage collector "
"fibers."
msgstr ""
"Отображение спейсов, которые доступны балансировщику и файберам сборщика "
"мусора."

msgid "Storage internal API"
msgstr "Внутренние API хранилища"

msgid ":ref:`vshard.storage.bucket_stat(bucket_id) <storage_api-bucket_stat>`"
msgstr ":ref:`vshard.storage.bucket_stat(bucket_id) <storage_api-bucket_stat>`"

msgid ""
":ref:`vshard.storage.bucket_recv(bucket_id, from, data) <storage_api-"
"bucket_recv>`"
msgstr ""
":ref:`vshard.storage.bucket_recv(bucket_id, from, data) <storage_api-"
"bucket_recv>`"

msgid ""
":ref:`vshard.storage.bucket_delete_garbage(bucket_id) <storage_api-"
"bucket_delete_garbage>`"
msgstr ""
":ref:`vshard.storage.bucket_delete_garbage(bucket_id) <storage_api-"
"bucket_delete_garbage>`"

msgid ""
":ref:`vshard.storage.bucket_collect(bucket_id) <storage_api-"
"bucket_collect>`"
msgstr ""
":ref:`vshard.storage.bucket_collect(bucket_id) <storage_api-"
"bucket_collect>`"

msgid ""
":ref:`vshard.storage.bucket_force_create(first_bucket_id, count) "
"<storage_api-bucket_force_create>`"
msgstr ""
":ref:`vshard.storage.bucket_force_create(first_bucket_id, count) "
"<storage_api-bucket_force_create>`"

msgid ""
":ref:`vshard.storage.bucket_force_drop(bucket_id, to) <storage_api-"
"bucket_force_drop>`"
msgstr ""
":ref:`vshard.storage.bucket_force_drop(bucket_id, to) <storage_api-"
"bucket_force_drop>`"

msgid ":ref:`vshard.storage.bucket_send(bucket_id, to) <storage_api-bucket_send>`"
msgstr ":ref:`vshard.storage.bucket_send(bucket_id, to) <storage_api-bucket_send>`"

msgid ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"
msgstr ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"

msgid ""
":ref:`vshard.storage.rebalancer_request_state() <storage_api-"
"rebalancer_request_state>`"
msgstr ""
":ref:`vshard.storage.rebalancer_request_state() <storage_api-"
"rebalancer_request_state>`"

msgid "Receive a bucket identified by bucket id from a remote replica set."
msgstr ""
"Получение сегмента по идентификатору сегмента (bucket id) из удаленного "
"набора реплик."

msgid "UUID of source replica set"
msgstr "UUID исходного набора реплик"

msgid ""
"data logically stored in a bucket identified by bucket_id, in the same "
"format as the return value from ``bucket_collect() <storage_api-"
"bucket_collect>``"
msgstr ""
"данные, которые хранятся логически в сегменте, определенном по "
"идентификатору сегмента (bucket_id), в том же формате, что и возвращаемое"
" значение метода ``bucket_collect() <storage_api-bucket_collect>``"

msgid "Return information about the bucket id:"
msgstr "Возврат информации об идентификаторе сегмента (bucket id):"

msgid ""
"tarantool> vshard.storage.bucket_stat(1)\n"
"---\n"
"- 0\n"
"- status: active\n"
"  id: 1\n"
"..."
msgstr ""
"tarantool> vshard.storage.bucket_stat(1)\n"
"---\n"
"- 0\n"
"- status: active\n"
"  id: 1\n"
"..."

msgid ""
"Force garbage collection for the bucket identified by bucket_id in case "
"the bucket was transferred to a different replica set."
msgstr ""
"Принудительная сборка мусора для сегмента, найденного по идентификатору "
"(bucket_id), если сегмент был перемещен в другой набор реплик."

msgid ""
"Collect all the data that is logically stored in the bucket identified by"
" bucket_id:"
msgstr ""
"Сбор всех данных, которые хранятся логически в сегменте, найденном по "
"идентификатору (bucket_id):"

msgid ""
"tarantool> vshard.storage.bucket_collect(1)\n"
"---\n"
"- 0\n"
"- - - 514\n"
"    - - [10, 1, 1, 100, 'Account 10']\n"
"      - [11, 1, 1, 100, 'Account 11']\n"
"      - [12, 1, 1, 100, 'Account 12']\n"
"      - [50, 5, 1, 100, 'Account 50']\n"
"      - [51, 5, 1, 100, 'Account 51']\n"
"      - [52, 5, 1, 100, 'Account 52']\n"
"  - - 513\n"
"    - - [1, 1, 'Customer 1']\n"
"      - [5, 1, 'Customer 5']\n"
"..."
msgstr ""
"tarantool> vshard.storage.bucket_collect(1)\n"
"---\n"
"- 0\n"
"- - - 514\n"
"    - - [10, 1, 1, 100, 'Account 10']\n"
"      - [11, 1, 1, 100, 'Account 11']\n"
"      - [12, 1, 1, 100, 'Account 12']\n"
"      - [50, 5, 1, 100, 'Account 50']\n"
"      - [51, 5, 1, 100, 'Account 51']\n"
"      - [52, 5, 1, 100, 'Account 52']\n"
"  - - 513\n"
"    - - [1, 1, 'Customer 1']\n"
"      - [5, 1, 'Customer 5']\n"
"..."

msgid ""
"Force creation of the buckets (single or multiple) on the current replica"
" set. Use only for manual emergency recovery or for initial bootstrap."
msgstr ""
"Принудительное создание сегментов (одного или нескольких) в текущем "
"наборе реплик. Используется только для ручного аварийного восстановления "
"или для начальной настройки."

msgid "an identifier of the first bucket in a range"
msgstr "идентификатор первого сегмента в диапазоне"

msgid "the number of buckets to insert (default = 1)"
msgstr "количество вставляемых сегментов (по умолчанию, 1)"

msgid "Drop a bucket manually for tests or emergency cases."
msgstr "Удаление сегмента вручную для тестирования или в аварийной ситуации."

msgid ""
"Send a specified bucket from the current replica set to a remote replica "
"set."
msgstr ""
"Отправка указанного сегмента из текущего набора реплик в удаленный набор "
"реплик."

msgid "bucket identifier"
msgstr "идентификатор сегмента"

msgid "UUID of a remote replica set"
msgstr "UUID удаленного набора реплик"

msgid ""
"Check all buckets of the host storage that have the SENT or ACTIVE state,"
" return the number of active buckets."
msgstr ""
"Проверка всех сегментов хост-хранилища в статусе отправки SENT или "
"активном статусе ACTIVE, возврат количества активных сегментов."

msgid "the number of buckets in the active state, if found; otherwise, nil"
msgstr ""
"количество сегментов в активном статусе, если таковые обнаружены; в "
"противном случае, nil"

msgid "Collect an array of active bucket identifiers for discovery."
msgstr "Сбор массива идентификаторов активных сегментов для обнаружения."
