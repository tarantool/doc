
msgid "Router API"
msgstr ""

msgid "Subsection"
msgstr ""

msgid "Methods"
msgstr ""

msgid ":ref:`Router public API <vshard_api_reference-router_public_api>`"
msgstr ""

msgid ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"
msgstr ""

msgid ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"
msgstr ""

msgid ":ref:`vshard.router.new(name, cfg) <router_api-new>`"
msgstr ""

msgid ""
":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list}, "
"{options}) <router_api-call>`"
msgstr ""

msgid ""
":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callro>`"
msgstr ""

msgid ""
":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callrw>`"
msgstr ""

msgid ""
":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callre>`"
msgstr ""

msgid ""
":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbro>`"
msgstr ""

msgid ""
":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbre>`"
msgstr ""

msgid ""
":ref:`vshard.router.map_callrw(function_name, {argument_list}, {options}) "
"<router_api-map_callrw>`"
msgstr ""

msgid ":ref:`vshard.router.route(bucket_id) <router_api-route>`"
msgstr ""

msgid ":ref:`vshard.router.routeall() <router_api-routeall>`"
msgstr ""

msgid ""
":ref:`vshard.router.bucket_id_strcrc32(key) <router_api-bucket_id_strcrc32>`"
msgstr ""

msgid ""
":ref:`vshard.router.bucket_id_mpcrc32(key) <router_api-bucket_id_mpcrc32>`"
msgstr ""

msgid ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"
msgstr ""

msgid ":ref:`vshard.router.sync(timeout) <router_api-sync>`"
msgstr ""

msgid ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"
msgstr ""

msgid ":ref:`vshard.router.discovery_set() <router_api-discovery_set>`"
msgstr ""

msgid ":ref:`vshard.router.info({options}) <router_api-info>`"
msgstr ""

msgid ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"
msgstr ""

msgid ":ref:`vshard.router.enable() <router_api-enable>`"
msgstr ""

msgid ":ref:`vshard.router.disable() <router_api-disable>`"
msgstr ""

msgid ":ref:`replicaset_object:call() <router_api-replicaset_call>`"
msgstr ""

msgid ":ref:`replicaset_object:callro() <router_api-replicaset_callro>`"
msgstr ""

msgid ":ref:`replicaset_object:callrw() <router_api-replicaset_callrw>`"
msgstr ""

msgid ":ref:`replicaset_object:callre() <router_api-replicaset_callre>`"
msgstr ""

msgid ":ref:`Router internal API <vshard_api_reference-router_internal_api>`"
msgstr ""

msgid ""
":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-"
"bucket_discovery>`"
msgstr ""

msgid "Router public API"
msgstr ""

msgid ""
"Perform the initial cluster bootstrap and distribute all buckets across the "
"replica sets."
msgstr ""

msgid "Parameters"
msgstr ""

msgid ""
"a number of seconds before ending a bootstrap attempt as unsuccessful. "
"Recreate the cluster in case of bootstrap timeout."
msgstr ""

msgid ""
"by default is set to ``false`` that means raise an error, when the cluster "
"is already bootstrapped. ``True`` means consider an already bootstrapped "
"cluster a success."
msgstr ""

msgid "**Example:**"
msgstr ""

msgid "vshard.router.bootstrap({timeout = 4, if_not_bootstrapped = true})"
msgstr ""

msgid ""
"To detect whether a cluster is bootstrapped, ``vshard`` looks for at least "
"one bucket in the whole cluster. If the cluster was bootstrapped only "
"partially (for example, due to an error during the first bootstrap), then it"
" will be considered a bootstrapped cluster on a next bootstrap call with "
"``if_not_bootstrapped``. So this is still a bad practice. Avoid calling "
"``bootstrap()`` multiple times."
msgstr ""

msgid ""
"Configure the database and start sharding for the specified ``router`` "
"instance. See the :ref:`sample configuration <vshard-config-cluster-"
"example>`."
msgstr ""

msgid "a configuration table"
msgstr ""

msgid ""
"Create a new router instance. ``vshard`` supports multiple routers in a "
"single Tarantool instance. Each router can be connected to any ``vshard`` "
"cluster, and multiple routers can be connected to the same cluster."
msgstr ""

msgid ""
"A router created via ``vshard.router.new()`` works in the same way as a "
"static router, but the method name is preceded by a colon "
"(``vshard.router:method_name(...)``), while for a static router the method "
"name is preceded by a period (``vshard.router.method_name(...)``)."
msgstr ""

msgid ""
"A static router can be obtained via the ``vshard.router.static()`` method "
"and then used like a router created via the ``vshard.router.new()`` method."
msgstr ""

msgid "``box.cfg`` is shared among all the routers of a single instance."
msgstr ""

msgid ""
"a router instance name. This name is used as a prefix in logs of the router "
"and must be unique within the instance"
msgstr ""

msgid ""
"a configuration table. See the :ref:`sample configuration <vshard-config-"
"cluster-example>`."
msgstr ""

msgid "Return"
msgstr ""

msgid ""
"a router instance, if created successfully; otherwise, nil and an error "
"object"
msgstr ""

msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id. See the :ref:`Processing requests <vshard-"
"process-requests>` section for details on function operation."
msgstr ""

msgid "a bucket identifier"
msgstr ""

msgid ""
"either a string = 'read'|'write', or a map with mode='read'|'write' and/or "
"prefer_replica=true|false and/or balance=true|false."
msgstr ""

msgid "a function to execute"
msgstr ""

msgid "an array of the function's arguments"
msgstr ""

msgid ""
"* ``timeout`` — a request timeout, in seconds. If the ``router`` cannot "
"identify a   shard with the specified ``bucket_id``, it will retry until the"
" timeout is reached.  * other :ref:`net.box options <net_box-options>`, such"
" as ``is_async``,   ``buffer``, ``on_push`` are also supported."
msgstr ""

msgid ""
"``timeout`` — a request timeout, in seconds. If the ``router`` cannot "
"identify a shard with the specified ``bucket_id``, it will retry until the "
"timeout is reached."
msgstr ""

msgid ""
"other :ref:`net.box options <net_box-options>`, such as ``is_async``, "
"``buffer``, ``on_push`` are also supported."
msgstr ""

msgid ""
"The mode parameter has two possible forms: a string or a map. Examples of "
"the string form are: ``'read'``, ``'write'``. Examples of the map form are: "
"``{mode='read'}``, ``{mode='write'}``, ``{mode='read', "
"prefer_replica=true}``, ``{mode='read', balance=true}``, ``{mode='read', "
"prefer_replica=true, balance=true}``."
msgstr ""

msgid "If ``'write'`` is specified then the target is the master."
msgstr ""

msgid ""
"If ``prefer_replica=true`` is specified then the preferred target is one of "
"the replicas, but the target is the master if there is no conveniently "
"available replica."
msgstr ""

msgid ""
"It may be good to specify prefer_replica=true for functions which are "
"expensive in terms of resource use, to avoid slowing down the master."
msgstr ""

msgid ""
"If ``balance=true`` then there is load balancing—reads are distributed over "
"all the nodes in the replica set in round-robin fashion, with a preference "
"for replicas if prefer_replica=true is also set."
msgstr ""

msgid ""
"The original return value of the executed function, or ``nil`` and error "
"object. The error object has a type attribute equal to ``ShardingError`` or "
"one of the regular Tarantool errors (``ClientError``, ``OutOfMemory``, "
"``SocketError``, etc.)."
msgstr ""

msgid ""
"``ShardingError`` is returned on errors specific for sharding: the master is"
" missing, wrong bucket id, etc. It has an attribute code containing one of "
"the values from the ``vshard.error.code.*`` LUA table, an optional attribute"
" containing a message with the human-readable error description, and other "
"attributes specific for the error code."
msgstr ""

msgid "**Examples:**"
msgstr ""

msgid "To call ``customer_add`` function from ``vshard/example``, say:"
msgstr ""

msgid ""
"vshard.router.call(100,\n"
"                   'write',\n"
"                   'customer_add',\n"
"                   {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}},\n"
"                   {timeout = 5})\n"
"-- or, the same thing but with a map for the second argument\n"
"vshard.router.call(100,\n"
"                   {mode='write'},\n"
"                   'customer_add',\n"
"                   {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}},\n"
"                   {timeout = 5})"
msgstr ""

msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-only mode (similar to calling "
"vshard.router.call with mode='read'). See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""

msgid ""
"* ``timeout`` — a request timeout, in seconds.If the ``router`` cannot "
"identify a   shard with the specified ``bucket_id``, it will retry until the"
" timeout is reached.  * other :ref:`net.box options <net_box-options>`, such"
" as ``is_async``,   ``buffer``, ``on_push`` are also supported."
msgstr ""

msgid ""
"``timeout`` — a request timeout, in seconds.If the ``router`` cannot "
"identify a shard with the specified ``bucket_id``, it will retry until the "
"timeout is reached."
msgstr ""

msgid ""
"``ShardingError`` is returned on errors specific for sharding: the replica "
"set is not available, the master is missing, wrong bucket id, etc. It has an"
" attribute code containing one of the values from the "
"``vshard.error.code.*`` LUA table, an optional attribute containing a "
"message with the human-readable error description, and other attributes "
"specific for this error code."
msgstr ""

msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-write mode (similar to calling "
"vshard.router.call with mode='write'). See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""

msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-only mode (similar to calling "
"``vshard.router.call`` with ``mode='read'``), with preference for a replica "
"rather than a master (similar to calling ``vshard.router.call`` with "
"``prefer_replica = true``). See the :ref:`Processing requests <vshard-"
"process-requests>` section for details on function operation."
msgstr ""

msgid ""
"This has the same effect as :ref:`vshard.router.call() <router_api-call>` "
"with mode parameter = ``{mode='read', balance=true}``."
msgstr ""

msgid ""
"This has the same effect as :ref:`vshard.router.call() <router_api-call>` "
"with mode parameter = ``{mode='read', balance=true, prefer_replica=true}``."
msgstr ""

msgid ""
"The function implements consistent map-reduce over the entire cluster. "
"Consistency means:"
msgstr ""

msgid "All the data was accessible."
msgstr ""

msgid ""
"The data was not migrated between physical storages during the map requests "
"execution."
msgstr ""

msgid "The function can be helpful if you need to access:"
msgstr ""

msgid "all the data in the cluster"
msgstr ""

msgid ""
"a vast number of buckets scattered over the instances in case their "
"individual :ref:`vshard.router.call() <router_api-call>` takes up too much "
"time."
msgstr ""

msgid ""
"The function is called on the master node of each replica set with the given"
" arguments."
msgstr ""

msgid "a function to call on the storages (masters of all replica sets)"
msgstr ""

msgid ""
"*   ``timeout`` -- a request timeout, in seconds. The timeout is for the "
"entire ``map_callrw()``, including all its stages.  *   ``return_raw`` -- "
"the :ref:`net.box option <net_box-options>` implemented in Tarantool since "
"version 2.10.0.     If set to ``true``, ``net.box`` returns the response "
"data wrapped in a :ref:`MessagePack object <msgpack-object-info>` instead of"
" decoding it to Lua.     For more details, see the **Return** section below."
msgstr ""

msgid ""
"``timeout`` -- a request timeout, in seconds. The timeout is for the entire "
"``map_callrw()``, including all its stages."
msgstr ""

msgid ""
"``return_raw`` -- the :ref:`net.box option <net_box-options>` implemented in"
" Tarantool since version 2.10.0. If set to ``true``, ``net.box`` returns the"
" response data wrapped in a :ref:`MessagePack object <msgpack-object-info>` "
"instead of decoding it to Lua. For more details, see the **Return** section "
"below."
msgstr ""

msgid ""
"Do not use a big timeout (longer than 1 minute, for instance). The router "
"tries to block the bucket moves to another storage for the given timeout on "
"all storages. On failure, the block remains for the entire timeout."
msgstr ""

msgid ""
"On success: a map with replica set UUIDs (keys) and results of the "
"``function_name`` (values)."
msgstr ""

msgid "{uuid1 = {res1}, uuid2 = {res2}, ...}"
msgstr ""

msgid ""
"If the function returns ``nil`` or ``box.NULL`` from one of the storages, it"
" will not be present in the resulting map."
msgstr ""

msgid ""
"If the ``return_raw`` option is used, the result is a map of the following "
"format: ``{[replicaset_uuid] = msgpack.object}`` where ``msgpack.object`` is"
" an object that stores a MessagePack array with the results returned from "
"the storage map function."
msgstr ""

msgid ""
"The option use case is the same as in using ``net.box``: to avoid decoding "
"of the call results into Lua. The option can be helpful if a router is used "
"as a proxy and results received from a storage are big."
msgstr ""

msgid "Example:"
msgstr ""

#, python-format
msgid ""
"local res = vshard.router.map_callrw('my_func', args, {..., return_raw = true})\n"
"\n"
"for replicaset_uuid, msgpack_value in pairs(res) do\n"
"    log.info('Replicaset %s returned %s', replicaset_uuid,\n"
"             msgpack_value:decode())\n"
"end"
msgstr ""

msgid ""
"This is an illustration of the option usage. Normally, you don't need to use"
" ``return_raw`` if you call the :ref:`decode() <msgpack-decode_string>` "
"function."
msgstr ""

msgid ""
"On failure: ``nil``, error object, and optional replica set UUID where the "
"error occurred. UUID will not be returned if the error is not related to a "
"particular replica set. For instance, the method fails if not all buckets "
"were found, even if all replica sets were scanned successfully. Handling the"
" result looks like this:"
msgstr ""

msgid ""
"res, err, uuid = vshard.router.map_callrw(...)\n"
"if not res then\n"
"    -- Error.\n"
"    -- 'err' - error object. 'uuid' - optional UUID of replica set\n"
"    -- where the error happened.\n"
"    ...\n"
"else\n"
"    -- Success.\n"
"    for uuid, value in pairs(res) do\n"
"        ...\n"
"    end\n"
"end"
msgstr ""

msgid ""
"If the ``return_raw`` option is used, the result on failure is the same as "
"described above."
msgstr ""

msgid ""
"Map-Reduce in vshard can be divided into three stages: Ref, Map, and Reduce."
msgstr ""

msgid ""
"**Ref and Map**. ``map_callrw()`` combines both the Ref and the Map stages. "
"The Ref stage ensures data consistency while executing the user's function "
"(``function_name``) on all nodes. Keep in mind that consistency is "
"incompatible with rebalancing (it breaks data consistency). Map-reduce and "
"rebalancing are mutually exclusive, they compete for the cluster time. Any "
"bucket move makes the sender and receiver nodes inconsistent, so it is "
"impossible to call a function on them to access all the data without "
":ref:`vshard.storage.bucket_ref() <storage_api-bucket_ref>`. It makes the "
"Ref stage intricate, as it should work together with the rebalancer to "
"ensure they do not block each other."
msgstr ""

msgid ""
"For this, the storage has a special scheduler for bucket moves and storage "
"refs. Storage ref is a volatile counter defined on each instance. It is "
"incremented when a map-reduce request comes and decremented when it ends. "
"Storage ref pins the entire instance with all its buckets, not just a single"
" bucket (like bucket ref)."
msgstr ""

msgid ""
"The scheduler shares storage time between bucket moves and storage refs "
"fairly. The distribution depends on how long and frequent the moves and refs"
" are. It can be configured using the storage options ``sched_move_quota`` "
"and ``sched_ref_quota``. Keep in mind that the scheduler configuration may "
"affect map-reduce requests if used during rebalancing."
msgstr ""

msgid ""
"During the Map stage, ``map_callrw()`` sends map requests one by one to many"
" servers. On success, the function returns a map. The map is a set of "
"\"key—value\" pairs. The keys are replica set UUIDs, and the values are the "
"results of the user's function—``function_name``."
msgstr ""

msgid ""
"**Reduce**. The Reduce stage is not performed by vshard. It is what the "
"user's code does with the results of ``map_callrw()``."
msgstr ""

msgid ""
"``map_callrw()`` works only on masters. Therefore, you can't use it if at "
"least one replica set has its master node down."
msgstr ""

msgid ""
"Return the replica set object for the bucket with the specified bucket id "
"value."
msgstr ""

msgid "a replica set object"
msgstr ""

msgid "replicaset = vshard.router.route(123)"
msgstr ""

msgid "Return all available replica set objects."
msgstr ""

msgid "a map of the following type: ``{UUID = replicaset}``"
msgstr ""

msgid "Rtype"
msgstr ""

msgid "a map of replica set objects"
msgstr ""

msgid ""
"function selectall()\n"
"    local resultset = {}\n"
"    shards, err = vshard.router.routeall()\n"
"    if err ~= nil then\n"
"        error(err)\n"
"    end\n"
"    for uid, replica in pairs(shards) do\n"
"        local set = replica:callro('box.space.*space-name*:select', {{}, {limit=10}}, {timeout=5})\n"
"        for _, item in ipairs(set) do\n"
"            table.insert(resultset, item)\n"
"        end\n"
"    end\n"
"    table.sort(resultset, function(a, b) return a[1] < b[1] end)\n"
"    return resultset\n"
"end"
msgstr ""

msgid ""
"**Deprecated**. Logs a warning when used because it is not consistent for "
"cdata numbers."
msgstr ""

msgid ""
"In particular, it returns 3 different values for normal Lua numbers like "
"123, for unsigned long long cdata (like ``123ULL``, or ``ffi.cast('unsigned "
"long long',123)``), and for signed long long cdata (like ``123LL``, or "
"``ffi.cast('long long', 123)``). And it is important."
msgstr ""

msgid ""
"vshard.router.bucket_id(123)\n"
"vshard.router.bucket_id(123LL)\n"
"vshard.router.bucket_id(123ULL)"
msgstr ""

msgid ""
"For float and double cdata (``ffi.cast('float', number)``, "
"``ffi.cast('double', number)``) these functions return different values even"
" for the same numbers of the same floating point type. This is because "
"``tostring()`` on a floating point cdata number returns not the number, but "
"a pointer at it. Different on each call."
msgstr ""

msgid ""
"``vshard.router.bucket_id_strcrc32()`` behaves exactly the same, but does "
"not log a warning. In case you need that behavior."
msgstr ""

msgid "Calculate the bucket id using a simple built-in hash function."
msgstr ""

msgid "a hash key. This can be any Lua object (number, table, string)."
msgstr ""

msgid "number"
msgstr ""

msgid ""
"tarantool> vshard.router.bucket_count()\n"
"---\n"
"- 3000\n"
"...\n"
"\n"
"tarantool> vshard.router.bucket_id_strcrc32(\"18374927634039\")\n"
"---\n"
"- 2032\n"
"...\n"
"\n"
"tarantool> vshard.router.bucket_id_strcrc32(18374927634039)\n"
"---\n"
"- 2032\n"
"...\n"
"\n"
"tarantool> vshard.router.bucket_id_strcrc32(\"test\")\n"
"---\n"
"- 1216\n"
"...\n"
"\n"
"tarantool> vshard.router.bucket_id_strcrc32(\"other\")\n"
"---\n"
"- 2284\n"
"..."
msgstr ""

msgid ""
"Remember that it is not safe. See details in :ref:`bucket_id() <router_api-"
"bucket_id>`"
msgstr ""

msgid ""
"This function is safer than ``bucket_id_strcrc32``. It takes a CRC32 from a "
"MessagePack encoded value. That is, bucket id of integers does not depend on"
" their Lua type. In case of a string key, it does not encode it into "
"MessagePack, but takes a hash right from the string."
msgstr ""

msgid ""
"However it still may return different values for not equal floating point "
"types. That is, ``ffi.cast('float', number)`` may be reflected into a bucket"
" id not equal to ``ffi.cast('double', number)``. This can't be fixed, "
"because a float value, even being casted to double, may have a garbage tail "
"in its fraction."
msgstr ""

msgid ""
"Floating point keys should not be used to calculate a bucket id, usually."
msgstr ""

msgid ""
"Be very careful in case you store floating point types in a space. When data"
" is returned from a space, it is cast to Lua number. And if that value had "
"an empty fraction part, it will be treated as an integer by "
"``bucket_id_mpcrc32()``. So you need to do explicit casts in such cases. "
"Here is an example of the problem:"
msgstr ""

msgid ""
"tarantool> s = box.schema.create_space('test', {format = {{'id', 'double'}}}); _ = s:create_index('pk')\n"
"---\n"
"...\n"
"\n"
"tarantool> inserted = ffi.cast('double', 1)\n"
"---\n"
"...\n"
"\n"
"-- Value is stored as double\n"
"tarantool> s:replace({inserted})\n"
"---\n"
"- [1]\n"
"...\n"
"\n"
"-- But when returned to Lua, stored as Lua number, not cdata.\n"
"tarantool> returned = s:get({inserted}).id\n"
"---\n"
"...\n"
"\n"
"tarantool> type(returned), returned\n"
"---\n"
"- number\n"
"- 1\n"
"...\n"
"\n"
"tarantool> vshard.router.bucket_id_mpcrc32(inserted)\n"
"---\n"
"- 1411\n"
"...\n"
"tarantool> vshard.router.bucket_id_mpcrc32(returned)\n"
"---\n"
"- 1614\n"
"..."
msgstr ""

msgid ""
"Return the total number of buckets specified in ``vshard.router.cfg()``."
msgstr ""

msgid "the total number of buckets"
msgstr ""

msgid ""
"tarantool> vshard.router.bucket_count()\n"
"---\n"
"- 10000\n"
"..."
msgstr ""

msgid "Wait until the dataset is synchronized on replicas."
msgstr ""

msgid "a timeout, in seconds"
msgstr ""

msgid "return"
msgstr ""

msgid ""
"``true`` if the dataset was synchronized successfully; or ``nil`` and "
"``err`` explaining why the dataset cannot be synchronized."
msgstr ""

msgid "Force wakeup of the bucket discovery fiber."
msgstr ""

msgid ""
"Turn on/off the background discovery fiber used by the router to find "
"buckets."
msgstr ""

msgid ""
"working mode of a discovery fiber. There are three modes: ``on``, ``off`` "
"and ``once``"
msgstr ""

msgid ""
"When the mode is ``on`` (default), the discovery fiber works during all the "
"lifetime of the router. Even after all buckets are discovered, it will still"
" come to storages and download their buckets with some big period "
"(`DISCOVERY_IDLE_INTERVAL "
"<https://github.com/tarantool/vshard/blob/master/vshard/consts.lua>`_). This"
" is useful if the bucket topology changes often and the number of buckets is"
" not big. The router will keep its route table up to date even when no "
"requests are processed."
msgstr ""

msgid "When the mode is ``off``, discovery is disabled completely."
msgstr ""

msgid ""
"When the mode is ``once``, discovery starts and finds the locations of all "
"buckets, and then the discovery fiber is terminated. This is good for a "
"large bucket count and for clusters, where rebalancing is rare."
msgstr ""

msgid ""
"The method is good to enable/disable discovery after the router is already "
"started, but discovery is enabled by default. You may want to never enable "
"it even for a short time—then specify the ``discovery_mode`` option in the "
":ref:`configuration <cfg_basic-discovery_mode>`. It takes the same values as"
" :samp:`vshard.router.discovery_set({mode})`."
msgstr ""

#, python-format
msgid ""
"You may decide to turn off discovery or make it ``once`` if you have many "
"routers, or tons of buckets (hundreds of thousands and more), and you see "
"that the discovery process consumes notable CPU % on routers and storages. "
"In that case it may be wise to turn off the discovery when there is no "
"rebalancing in the cluster. And turn it on for new routers, as well as for "
"all routers when rebalancing is started."
msgstr ""

msgid ""
"Return information about each instance. Since vshard v.0.1.22, the function "
"also accepts options, which can be used to get additional information."
msgstr ""

msgid ""
"*    ``with_services`` — a bool value. If set to ``true``, the      function"
" returns information about the background services      (such as discovery, "
"master search, or failover) that are      working on the current instance."
msgstr ""

msgid ""
"``with_services`` — a bool value. If set to ``true``, the function returns "
"information about the background services (such as discovery, master search,"
" or failover) that are working on the current instance."
msgstr ""

msgid "Replica set parameters:"
msgstr ""

msgid "replica set uuid"
msgstr ""

msgid "master instance parameters"
msgstr ""

msgid "replica instance parameters"
msgstr ""

msgid "Instance parameters:"
msgstr ""

msgid "``uri``—URI of the instance"
msgstr ""

msgid "``uuid``—UUID of the instance"
msgstr ""

msgid ""
"``status``—status of the instance (``available``, ``unreachable``, "
"``missing``)"
msgstr ""

msgid ""
"``network_timeout``—a timeout for the request. The value is updated "
"automatically on each 10th successful request and each 2nd failed request."
msgstr ""

msgid "Bucket parameters:"
msgstr ""

msgid ""
"``available_ro`` -- the number of buckets known to the ``router`` and "
"available for read requests"
msgstr ""

msgid ""
"``available_rw`` -- the number of buckets known to the ``router`` and "
"available for read and write requests"
msgstr ""

msgid ""
"``unreachable`` -- the number of buckets known to the ``router`` but "
"unavailable for any requests"
msgstr ""

msgid ""
"``unknown`` -- the number of buckets whose replica sets are not known to the"
" ``router``"
msgstr ""

msgid "Service parameters:"
msgstr ""

msgid ""
"``name`` -- service name. Possible values: ``discovery``, ``failover``, "
"``master_search``."
msgstr ""

msgid "``status`` -- service status. Possible values: ``ok``, ``error``."
msgstr ""

msgid "``error`` -- error message that appears on the ``error`` status."
msgstr ""

msgid ""
"``activity`` -- service state. It shows what the service is currently doing "
"(for example, ``updating replicas``)."
msgstr ""

msgid ""
"``status_idx`` -- incrementing counter of the status changes. The ``ok`` "
"status is updated on every successful iteration of the service. The "
"``error`` status is updated only when it is fixed."
msgstr ""

msgid ""
"tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"...\n"
"\n"
"tarantool> vshard.router.info({with_services = true})\n"
"---\n"
"<all info from vshard.router.info()>\n"
"  services:\n"
"    failover:\n"
"      status_idx: 2\n"
"      error:\n"
"      activity: idling\n"
"      name: failover\n"
"      status: ok\n"
"    discovery:\n"
"      status_idx: 2\n"
"      error: Error during discovery: TimedOut\n"
"      activity: idling\n"
"      name: discovery\n"
"      status: error\n"
"..."
msgstr ""

msgid ""
"Return information about each bucket. Since a bucket map can be huge, only "
"the required range of buckets can be specified."
msgstr ""

msgid "the offset in a bucket map of the first bucket to show"
msgstr ""

msgid "the maximum number of buckets to show"
msgstr ""

msgid ""
"a map of the following type: ``{bucket_id = 'unknown'/replicaset_uuid}``"
msgstr ""

msgid ""
"tarantool> vshard.router.buckets_info()\n"
"---\n"
"- - uuid: aaaaaaaa-0000-4000-a000-000000000000\n"
"    status: available_rw\n"
"  - uuid: aaaaaaaa-0000-4000-a000-000000000000\n"
"    status: available_rw\n"
"  - uuid: aaaaaaaa-0000-4000-a000-000000000000\n"
"    status: available_rw\n"
"  - uuid: bbbbbbbb-0000-4000-a000-000000000000\n"
"    status: available_rw\n"
"  - uuid: bbbbbbbb-0000-4000-a000-000000000000\n"
"    status: available_rw\n"
"  - uuid: bbbbbbbb-0000-4000-a000-000000000000\n"
"    status: available_rw\n"
"  - uuid: bbbbbbbb-0000-4000-a000-000000000000\n"
"    status: available_rw\n"
"..."
msgstr ""

msgid ""
"Since vshard v.0.1.21. Manually allow access to the router API, revert "
":ref:`vshard.router.disable() <router_api-disable>`."
msgstr ""

msgid ""
"``vshard.router.enable()`` cannot be used for enabling a router API that was"
" automatically disabled due to a running configuration process."
msgstr ""

msgid ""
"Since vshard v.0.1.21. Manually restrict access to the router API. When the "
"API is disabled, all its methods throw a Lua error, except "
":ref:`vshard.router.cfg() <router_api-cfg>`, :ref:`vshard.router.new() "
"<router_api-new>`, :ref:`vshard.router.enable() <router_api-enable>` and "
":ref:`vshard.router.disable() <router_api-disable>`. The error object's name"
" attribute is ``ROUTER_IS_DISABLED``."
msgstr ""

msgid ""
"The router is enabled by default. However, it is automatically and "
"forcefully disabled until the configuration is finished, as accessing the "
"router's methods at that time is not safe."
msgstr ""

msgid ""
"Manual disabling can be used, for example, if some preparatory work needs to"
" be done after calling :ref:`vshard.router.cfg() <router_api-cfg>` but "
"before the router's methods are available. It will look like this:"
msgstr ""

msgid ""
"vshard.router.disable()\n"
"vshard.router.cfg(...)\n"
"-- Some preparatory work here ...\n"
"vshard.router.enable()\n"
"-- vshard.router's methods are available now"
msgstr ""

msgid ""
"Call a function on a nearest available master (distances are defined using "
"``replica.zone`` and ``cfg.weights`` matrix) with specified arguments."
msgstr ""

msgid ""
"The ``replicaset_object:call`` method is similar to "
"``replicaset_object:callrw``."
msgstr ""

msgid "function to execute"
msgstr ""

msgid "array of the function's arguments"
msgstr ""

msgid "result of ``function_name`` on success"
msgstr ""

msgid "nil, err otherwise"
msgstr ""

msgid ""
"Call a function on a nearest available master (distances are defined using "
"``replica.zone`` and ``cfg.weights`` matrix) with a specified arguments."
msgstr ""

msgid ""
"The ``replicaset_object:callrw`` method is similar to "
"``replicaset_object:call``."
msgstr ""

msgid ""
"tarantool> local bucket = 1; return vshard.router.callrw(\n"
"         >     bucket,\n"
"         >     'box.space.actors:insert',\n"
"         >     {{\n"
"         >         1, bucket, 'Renata Litvinova',\n"
"         >         {theatre=\"Moscow Art Theatre\"}\n"
"         >     }},\n"
"         >     {timeout=5}\n"
"         > )"
msgstr ""

msgid ""
"Call a function on the nearest available replica (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments."
" It is recommended to use ``replicaset_object:callro()`` for calling only "
"read-only functions, as the called functions can be executed not only on a "
"master, but also on replicas."
msgstr ""

msgid ""
"Call a function on the nearest available replica (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments,"
" with preference for a replica rather than a master (similar to calling "
"``vshard.router.call`` with ``prefer_replica = true``). It is recommended to"
" use ``replicaset_object:callre()`` for calling only read-only functions, as"
" the called function can be executed not only on a master, but also on "
"replicas."
msgstr ""

msgid ""
":ref:`Automated master discovery <cfg_replica_set-master>` works in its own "
"fiber on a router, which is activated only if at least one replica set is "
"configured to look for the master (the ``master`` parameter is set to "
"``auto``). The fiber wakes up within a certain period. But it is possible to"
" wake it up on demand by using this function."
msgstr ""

msgid ""
"Manual fiber wakeup can help speed up tests for master change. Another use "
"case is performing some actions with a router in the router console."
msgstr ""

msgid ""
"The function does nothing if master search is not :ref:`configured "
"<cfg_replica_set-master>` for any replica set."
msgstr ""

msgid "none"
msgstr ""

msgid "Router internal API"
msgstr ""

msgid ""
"Search for the bucket in the whole cluster. If the bucket is not found, it "
"is likely that it does not exist. The bucket might also be moved during "
"rebalancing and currently is in the RECEIVING state."
msgstr ""
