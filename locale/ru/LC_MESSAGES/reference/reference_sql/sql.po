
msgid "What Tarantool's SQL product delivers"
msgstr ""

msgid ""
"Tarantool's SQL is a major new feature that was first introduced with "
"Tarantool version 2.1. |br| The primary advantages are: |br| - a high "
"level of SQL compatibility |br| - an easy way to switch from NoSQL to SQL"
" and back |br| - the Tarantool brand."
msgstr ""

msgid ""
"The \"high level of SQL compatibility\" includes support for joins, "
"subqueries, triggers, indexes, groupings, transactions in a multi-user "
"environment, and conformance with the majority of the mandatory "
"requirements of the SQL:2016 standard."
msgstr ""

msgid ""
"The \"easy way to switch\" consists of the fact that the same tables can "
"be operated on with SQL and with the  long-established Tarantool-NoSQL "
"product, meaning that when you want standard Relational-DBMS jobs you can"
" do them, and when you want NoSQL capability you can have it (Tarantool-"
"NoSQL outperforms other NoSQL products in public benchmarks)."
msgstr ""

msgid ""
"The \"Tarantool brand\" comes from the support of a multi-billion-dollar "
"internet / mail / social-network provider, a dozens-of-professionals "
"staff of programmers and support people, a community who believes in "
"open-source BSD licensing, and hundreds of corporations / government "
"bodies using Tarantool products in production already."
msgstr ""

msgid ""
"The status of Tarantool's SQL feature is \"release\". So, it is working "
"now and you can verify that by downloading it and trying all the "
"features, which we will explain in the rest of this document. There is "
"also a :ref:`tutorial <sql_tutorial>`."
msgstr ""

msgid "Differences from other products"
msgstr ""

msgid ""
"Differences from other SQL products: We believe that Tarantool's SQL "
"conforms to the majority of the listed mandatory requirements of the core"
" SQL:2016 standard, and we enumerate the specific conformance statements "
"in the feature list in a section about :ref:`\"compliance with the "
"official SQL standard\" <sql>`. We believe that the deviations which most"
" people will find notable are: type checking is less strict, and some "
"data definition options must be done with NoSQL syntax."
msgstr ""

msgid ""
"Differences from other NoSQL products: We have examined attempts by "
"others to paste relatively smaller subsets of SQL onto NoSQL products, "
"and concluded that Tarantool's SQL has demonstrably more features and "
"capabilities. The reason is that we started with a complete code base of "
"a working SQL DBMS and made it work with Tarantool-NoSQL underneath, "
"rather than starting with a NoSQL DBMS and adding syntax to it."
msgstr ""

msgid "What Tarantool's SQL manual delivers"
msgstr ""

msgid ""
"The following five parts of this document are: |br| The :ref:`SQL "
"Beginners' Guide <sql_beginners_guide>` explains the basics of relational"
" database management and SQL in particular. |br| The :ref:`SQL User Guide"
" <sql_user_guide>` explains \"How to get Started\" and explains the terms"
" and the syntax elements that apply for all SQL statements. |br| The "
":ref:`SQL Statements and Clauses <sql_statements_and_clauses>` guide "
"explains, for each SQL statement, the format and the rules and the "
"exceptions and the examples and the limitations. |br| The :ref:`SQL Plus "
"Lua <sql_plus_lua>` guide has the details about calling Lua from SQL, "
"calling SQL from Lua, and using the same database objects in both SQL and"
" Lua. |br| The :ref:`SQL Features <sql>` list shows how the product "
"conforms with the mandatory features of the SQL standard."
msgstr ""

msgid ""
"Users are expected to know what databases are, and experience with other "
"SQL DBMSs would be an advantage."
msgstr ""

#~ msgid ""
#~ "(3) There are some options that "
#~ "are implemented in NoSQL that are "
#~ "not (yet) implemented in SQL. For "
#~ "example you can use NoSQL to "
#~ "change an index type to 'hash', "
#~ "and to deny access to users named"
#~ " 'guest'."
#~ msgstr ""

#~ msgid ""
#~ "Fields in NoSQL spaces can be "
#~ "accessed with SQL if and only if"
#~ " they are scalar and are defined "
#~ "in format clauses. Indexes of NoSQL "
#~ "spaces will be used with SQL if"
#~ " and only if they are TREE or"
#~ " HASH indexes."
#~ msgstr ""

#~ msgid ""
#~ "|nbsp| :ref:`ALTER TABLE table-name "
#~ "[RENAME or ADD CONSTRAINT clauses]; "
#~ "<sql_alter_table>` |br| |nbsp| ANALYZE "
#~ "[table-name]; -- temporarily disabled in"
#~ " current version |br| |nbsp| :ref:`COMMIT;"
#~ " <sql_commit>` |br| |nbsp| :ref:`CREATE "
#~ "[UNIQUE] INDEX [IF NOT EXISTS] index-"
#~ "name <sql_create_index>` |br| |nbsp| |nbsp|"
#~ " |nbsp| |nbsp| :ref:`ON table-name "
#~ "(column-name [, column-name ...]); "
#~ "<sql_create_index>` |br| |nbsp| :ref:`CREATE "
#~ "TABLE [IF NOT EXISTS] table-name "
#~ "<sql_create_table>` |br| |nbsp| |nbsp| |nbsp|"
#~ " |nbsp| :ref:`(column-or-constraint-"
#~ "definition <sql_create_table>` |br| |nbsp| "
#~ "|nbsp| |nbsp| |nbsp| :ref:`[, column-"
#~ "or-constraint-definition ...]) "
#~ "<sql_create_table>` |br| |nbsp| |nbsp| |nbsp|"
#~ " |nbsp| :ref:`[WITH ENGINE = engine-"
#~ "name]; <sql_create_table>` |br| |nbsp| "
#~ ":ref:`CREATE TRIGGER [IF NOT EXISTS] "
#~ "trigger-name <sql_create_trigger>` |br| |nbsp|"
#~ " |nbsp| |nbsp| |nbsp| :ref:`BEFORE|AFTER "
#~ "INSERT|UPDATE|DELETE ON table-name "
#~ "<sql_create_trigger>` |br| |nbsp| |nbsp| "
#~ "|nbsp| |nbsp| :ref:`FOR EACH ROW "
#~ "<sql_create_trigger>` |br| |nbsp| |nbsp| "
#~ "|nbsp| |nbsp| :ref:`BEGIN dml-statement "
#~ "[, dml-statement ...] END; "
#~ "<sql_create_trigger>` |br| |nbsp| :ref:`CREATE "
#~ "VIEW [IF NOT EXISTS] view-name "
#~ "<sql_create_view>`  |br| |nbsp| |nbsp| |nbsp|"
#~ " |nbsp| :ref:`[(column-name [, column-"
#~ "name ...])] <sql_create_view>`  |br| |nbsp|"
#~ " |nbsp| |nbsp| |nbsp| :ref:`AS select-"
#~ "statement | values-statement; "
#~ "<sql_create_view>`  |br| |nbsp| :ref:`DROP "
#~ "INDEX [IF EXISTS] index-name ON "
#~ "table-name; <sql_drop_index>`  |br| |nbsp| "
#~ ":ref:`DROP TABLE [IF EXISTS] table-name;"
#~ " <sql_drop_table>`  |br| |nbsp| :ref:`DROP "
#~ "TRIGGER [IF EXISTS] trigger-name; "
#~ "<sql_drop_trigger>` |br| |nbsp| :ref:`DROP "
#~ "VIEW [IF EXISTS] view-name; "
#~ "<sql_drop_view>` |br| |nbsp| :ref:`EXPLAIN "
#~ "explainable-statement; <sql_explain>` |br| |nbsp|"
#~ " :ref:`INSERT INTO table-name <sql_insert>`"
#~ " |br| |nbsp| |nbsp| |nbsp| |nbsp| "
#~ ":ref:`[(column-name [, column-name "
#~ "...])] <sql_insert>` |br| |nbsp| |nbsp| "
#~ "|nbsp| |nbsp| :ref:`values-statement | "
#~ "select-statement; <sql_insert>` |br| |nbsp| "
#~ ":ref:`PRAGMA pragma-name[(value)]; <sql_pragma>` "
#~ "|br| |nbsp| :ref:`RELEASE SAVEPOINT "
#~ "savepoint-name; <sql_release_savepoint>` |br| "
#~ "|nbsp| :ref:`REPLACE INTO table-name "
#~ "VALUES (expression [, expression ...]); "
#~ "<sql_replace>` |br| |nbsp| :ref:`ROLLBACK [TO"
#~ " [SAVEPOINT] savepoint-name]; <sql_rollback>` "
#~ "|br| |nbsp| :ref:`SAVEPOINT savepoint-name;"
#~ " <sql_savepoint>` |br| |nbsp| :ref:`SELECT "
#~ "[DISTINCT|ALL] expression [, expression ...]"
#~ " <sql_select>` |br| |nbsp| |nbsp| |nbsp|"
#~ " |nbsp| :ref:`FROM table-name | "
#~ "joined-table-names [AS alias]  "
#~ "<sql_select>` |br| |nbsp| |nbsp| |nbsp| "
#~ "|nbsp| :ref:`[WHERE expression] <sql_select>` "
#~ "|br| |nbsp| |nbsp| |nbsp| |nbsp| "
#~ ":ref:`[GROUP BY expression [, expression "
#~ "...]] <sql_group_by>` |br| |nbsp| |nbsp| "
#~ "|nbsp| |nbsp| :ref:`[HAVING expression] "
#~ "<sql_having>` |br| |nbsp| |nbsp| |nbsp| "
#~ "|nbsp| :ref:`[ORDER BY expression] "
#~ "<sql_order_by>` |br| |nbsp| |nbsp| |nbsp| "
#~ "|nbsp| :ref:`LIMIT expression [OFFSET "
#~ "expression]]; <sql_limit>` |br| |nbsp| "
#~ ":ref:`START TRANSACTION; <sql_start_transaction>` "
#~ "|br| |nbsp| :ref:`TRUNCATE TABLE table-"
#~ "name; <sql_truncate>` |br| |nbsp| :ref:`UPDATE"
#~ " table-name <sql_update>` |br| |nbsp| "
#~ "|nbsp| |nbsp| |nbsp| :ref:`SET column-"
#~ "name=expression [,column-name=expression...] "
#~ "<sql_update>` |br| |nbsp| |nbsp| |nbsp| "
#~ "|nbsp| :ref:`[WHERE expression]; <sql_update>` "
#~ "|br| |nbsp| :ref:`VALUES (expression [, "
#~ "expression ...]; <sql_values>` |br| |nbsp| "
#~ ":ref:`WITH [RECURSIVE] common-table-"
#~ "expression; <sql_with>`"
#~ msgstr ""

#~ msgid ""
#~ "NUMBER values have the same range "
#~ "as DOUBLE values. But NUMBER values "
#~ "may also also be integers, and, if"
#~ " so, arithmetic operation results will "
#~ "be exact rather than approximate. There"
#~ " is no literal format for NUMBER "
#~ "(literals like ``1.5`` or ``1E555`` are"
#~ " considered to be DOUBLEs), so use"
#~ " :ref:`CAST <sql_function_cast>` to insist "
#~ "that a number has data type "
#~ "NUMBER, but that is rarely necessary."
#~ " See the description of NoSQL type"
#~ " :ref:`'number' <index-box_number>`."
#~ msgstr ""

#~ msgid ""
#~ "``/`` division (arithmetic) Divide second "
#~ "number into first number according to"
#~ " standard arithmetic rules. Division by "
#~ "zero is not legal. Division of "
#~ "integers always results in rounding "
#~ "down, use :ref:`CAST <sql_function_cast>` to"
#~ " NUMBER to get non-integer results."
#~ " Example: ``5 / 2``, result = "
#~ "2."
#~ msgstr ""

#~ msgid ""
#~ "``!=`` not equal (comparison) This is"
#~ " a non-standard equivalent of "
#~ ":ref:`\"<> not equal (comparison)\" "
#~ "<sql_not_equal>`."
#~ msgstr ""

#~ msgid "... for setting a series of conditions"
#~ msgstr ""

#~ msgid ""
#~ "~                To BOOLEAN | To INTEGER"
#~ " | To DOUBLE | To STRING | "
#~ "To VARBINARY\n"
#~ "---------------  ----------   ----------   ---------"
#~ "   ---------   ------------\n"
#~ "From BOOLEAN   | AAA        | A--"
#~ "        | ---       | A--       | ---"
#~ "\n"
#~ "From INTEGER   | A--        | AAA"
#~ "        | AAA       | AAA       | ---"
#~ "\n"
#~ "From DOUBLE    | A--        | SSA"
#~ "        | AAA       | AAA       | ---"
#~ "\n"
#~ "From STRING    | S--        | SSS"
#~ "        | SSS       | AAA       | A--"
#~ "\n"
#~ "From VARBINARY | ---        | ---        | ---       | A--       | AAA"
#~ msgstr ""

#~ msgid ""
#~ "The S \"Sometimes allowed\" character "
#~ "applies for these special situations: "
#~ "|br| From STRING To BOOLEAN is "
#~ "allowed if UPPER(string-value) = "
#~ "``'TRUE'`` or ``'FALSE'``. |br| From "
#~ "DOUBLE to INTEGER is allowed for "
#~ "cast and assignment only if the "
#~ "result is not out of range. |br|"
#~ " From STRING to INTEGER or DOUBLE "
#~ "is allowed only if the string has"
#~ " a representation of a number."
#~ msgstr ""

#~ msgid ""
#~ "``CAST(TRUE AS INTEGER)`` is legal "
#~ "because the intersection of the  \"From"
#~ " BOOLEAN\" row with the \"To "
#~ "INTEGER\" column is ``A--`` and the "
#~ "first letter of ``A--`` is for "
#~ "explicit cast and A means Always "
#~ "Allowed. The result is 1."
#~ msgstr ""

#~ msgid ""
#~ "``1.7E-1 > 0`` is legal because "
#~ "the intersection of the \"From DOUBLE\""
#~ " row with the \"To INTEGER\" column"
#~ " is AAA, and the third letter "
#~ "of AAA is for implicit cast "
#~ "(comparison) and A means Always Allowed."
#~ " The result is TRUE."
#~ msgstr ""

#~ msgid ""
#~ "``11 > '2'`` is legal because the"
#~ " intersection of the \"From INTEGER\" "
#~ "row with the \"To STRING\" column "
#~ "is AAA and the third letter of "
#~ "AAA is for implicit cast (comparison)"
#~ " and A means Always Allowed. The "
#~ "result is TRUE.  For detailed "
#~ "explanation see the following section."
#~ msgstr ""

#~ msgid ""
#~ "Special considerations may apply for "
#~ "casting STRINGs to/from INTEGERs/DOUBLEs "
#~ "(numbers) for comparison or assignment."
#~ msgstr ""

#~ msgid ""
#~ "Implicit cast does NOT happen if "
#~ "numbers are used in concatenation, or"
#~ " in LIKE. |br| Therefore ``5 || "
#~ "5`` is illegal."
#~ msgstr ""

#~ msgid ""
#~ "In the following examples, implicit cast"
#~ " does not happen for SCALAR column"
#~ " values: |br| ``DROP TABLE scalars;`` "
#~ "|br| ``CREATE TABLE scalars (scalar_column "
#~ "SCALAR PRIMARY KEY);`` |br| ``INSERT "
#~ "INTO scalars VALUES (11), ('2');`` |br|"
#~ " ``SELECT * FROM scalars WHERE "
#~ "scalar_column > 11;   /* 0 rows. "
#~ "So 11 > '2'. */`` |br| ``SELECT"
#~ " * FROM scalars WHERE scalar_column <"
#~ " '2';  /* 1 row. So 11 < "
#~ "'2'. */`` |br| ``SELECT max(scalar_column) "
#~ "FROM scalars; /* 1 row: '2'. So"
#~ " 11 < '2'. */`` |br| ``SELECT "
#~ "sum(scalar_column) FROM scalars; /* 1 "
#~ "row: 13. So cast happened. */`` "
#~ "|br| These results are not affected "
#~ "by indexing, or by reversing the "
#~ "operands."
#~ msgstr ""

#~ msgid ""
#~ "-- adding a primary-key constraint definition:\n"
#~ "-- This is unusual because primary keys are created automatically\n"
#~ "-- and it is illegal to have two primary keys for the same table.\n"
#~ "-- However, it is possible to drop a primary-key index, and this\n"
#~ "-- is a way to restore the primary key if that happens.\n"
#~ "ALTER TABLE t1 ADD CONSTRAINT pk_s1_t1_1 PRIMARY KEY (s1);\n"
#~ "\n"
#~ "-- adding a unique-constraint definition:\n"
#~ "-- Alternatively, you can say CREATE "
#~ "UNIQUE INDEX unique_key ON t1 (s1);\n"
#~ ""
#~ "ALTER TABLE t1 ADD CONSTRAINT uk_s1_t1_1 UNIQUE (s1);\n"
#~ "\n"
#~ "-- Adding a check-constraint definition:\n"
#~ "ALTER TABLE t1 ADD CONSTRAINT ck_s1_t1_1 CHECK (s1 > 0);"
#~ msgstr ""

#~ msgid ""
#~ "For ``ALTER ... DROP CONSTRAINT``, it"
#~ " is only legal to drop a named"
#~ " constraint, and Tarantool only looks "
#~ "for names of foreign-key constraints."
#~ " (Tarantool generates the constraint names"
#~ " automatically if the user does not"
#~ " provide them.)"
#~ msgstr ""

#~ msgid ""
#~ "-- dropping a constraint:\n"
#~ "ALTER TABLE t1 DROP CONSTRAINT ck_s1_t1_1;"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`CREATE TABLE [IF NOT EXISTS] "
#~ "{table-name} ((column-definition or "
#~ "table-constraint list)` :samp:`[WITH ENGINE "
#~ "= {string}];`"
#~ msgstr ""

#~ msgid ""
#~ "The *column-definition* or *table-"
#~ "constraint* list is a comma-separated"
#~ " list of :ref:`column definitions "
#~ "<sql_column_def>` or table constraints."
#~ msgstr ""

#~ msgid ""
#~ "A *table-element-list* must be a"
#~ " comma-separated list of table "
#~ "elements; each table element may be "
#~ "either a column definition or a "
#~ ":ref:`table constraint definition "
#~ "<sql_table_constraint_def>`."
#~ msgstr ""

#~ msgid ""
#~ "When :samp:`WITH ENGINE = {string}` is"
#~ " specified, where :samp:`string}` must be"
#~ " either 'memtx' or 'vinyl', the table"
#~ " is created with that :ref:`storage "
#~ "engine <engines-chapter>`. When this "
#~ "clause is not specified, the table "
#~ "is created with the default engine, "
#~ "which is ordinarily 'memtx' but may "
#~ "be changed by updating a table "
#~ "that has a list of session "
#~ "settings."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool evaluates each column definition "
#~ "and *table-constraint*, and returns an"
#~ " error if any of the rules is"
#~ " violated."
#~ msgstr ""

#~ msgid "Tarantool effectively executes a :ref:`COMMIT <sql_commit>` statement."
#~ msgstr ""

#~ msgid ""
#~ "-- the simplest form, with one column and one constraint:\n"
#~ "CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
#~ "\n"
#~ "-- you can see the effect of the statement by querying\n"
#~ "-- Tarantool system spaces:\n"
#~ "SELECT * FROM \"_space\" WHERE \"name\" = 'T1';\n"
#~ "SELECT * FROM \"_index\" JOIN \"_space\""
#~ " ON \"_index\".\"id\" = \"_space\".\"id\"\n"
#~ "         WHERE \"_space\".\"name\" = 'T1';\n"
#~ "\n"
#~ "-- variation of the simplest form, with delimited identifiers\n"
#~ "-- and an inline comment:\n"
#~ "CREATE TABLE \"T1\" (\"S1\" INT /* "
#~ "synonym of INTEGER */, PRIMARY KEY "
#~ "(\"S1\"));\n"
#~ "\n"
#~ "-- two columns, one named constraint\n"
#~ "CREATE TABLE t1 (s1 INTEGER, s2 "
#~ "STRING, CONSTRAINT pk_s1s2_t1_1 PRIMARY KEY"
#~ " (s1, s2));"
#~ msgstr ""

#~ msgid ""
#~ "Every column has a data type: "
#~ "BOOLEAN or INTEGER or UNSIGNED or "
#~ "DOUBLE or NUMBER or STRING or "
#~ "VARBINARY or SCALAR. The detailed "
#~ "description of data types is in "
#~ "the section :ref:`Operands <sql_operands>`."
#~ msgstr ""

#~ msgid ""
#~ "The comparison is valid, because "
#~ "Tarantool knows the ordering of X'41'"
#~ " and 'a' in Tarantool/NoSQL 'scalar'. "
#~ "This would be true even if ``s1``"
#~ " was not defined as SCALAR."
#~ msgstr ""

#~ msgid ""
#~ "That is only possible with "
#~ "Tarantool/NoSQL scalar rules, but ``SELECT "
#~ "SUM(s2)`` would not be legal because "
#~ "addition would in this case require "
#~ "implicit casting from VARBINARY to "
#~ "integer, which is not sensible."
#~ msgstr ""

#~ msgid ""
#~ "The result data type of a "
#~ "primitive combination is never SCALAR "
#~ "because we in effect use TYPEOF(item)"
#~ " not the defined data type. (Here "
#~ "we use the word \"combination\" in "
#~ "the way that the standard document "
#~ "uses it for section \"Result of "
#~ "data type combinations\".) Therefore for "
#~ "``max(1E308, 'a', 0, X'00')`` the result"
#~ " is X'00'."
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t (\"smallint\" INTEGER "
#~ "PRIMARY KEY, CHECK (\"smallint\" <= "
#~ "32767 AND \"smallint\" >= -32768));\n"
#~ "CREATE TABLE t (\"shorttext\" STRING "
#~ "PRIMARY KEY, CHECK (length(\"shorttext\") <="
#~ " 10));"
#~ msgstr ""

#~ msgid ""
#~ "-- the simple form with column-name and data-type\n"
#~ "CREATE TABLE t (column1 INTEGER ...);\n"
#~ "-- with column-name and data-type and column-constraint\n"
#~ "CREATE TABLE t (column1 STRING PRIMARY KEY ...);\n"
#~ "-- with column-name and data-type"
#~ " and collate-clause and two "
#~ "column-constraints\n"
#~ "CREATE TABLE t (column1 SCALAR COLLATE \"unicode\" ...);"
#~ msgstr ""

#~ msgid ""
#~ "-- with all possible column constraints and a default clause\n"
#~ "CREATE TABLE t\n"
#~ "(column1 INTEGER PRIMARY KEY,\n"
#~ " column2 INTEGER UNIQUE,\n"
#~ " column3 INTEGER CHECK (column3 > column2),\n"
#~ " column4 INTEGER REFERENCES t,\n"
#~ " column6 INTEGER DEFAULT NULL);"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`CONSTRAINT {constraint-name}] primary-"
#~ "key-constraint | unique-constraint | "
#~ "check-constraint | foreign-key-constraint`"
#~ msgstr ""

#~ msgid ""
#~ "The optional update-or-delete rules "
#~ "look like this: |br| ``ON "
#~ "{UPDATE|DELETE} { CASCADE | SET DEFAULT"
#~ " | SET NULL | RESTRICT | NO "
#~ "ACTION}`` |br| and the idea is: if"
#~ " something changes the referenced key, "
#~ "then one of three possible \"referential"
#~ " actions\" takes place: |br| ``CASCADE``:"
#~ " the change that is applied for "
#~ "the referenced key is applied for "
#~ "the referencing key. |br| ``SET "
#~ "DEFAULT``: the referencing key is set"
#~ " to its default value. |br| ``SET "
#~ "NULL``: the referencing key is set "
#~ "to NULL. |br| ``RESTRICT``: the UPDATE"
#~ " or DELETE fails if a referencing "
#~ "key exists; checked immediately. |br| "
#~ "``NO ACTION``: the UPDATE or DELETE "
#~ "fails if a referencing key exists; "
#~ "checked at statement end. |br| The "
#~ "default is ``NO ACTION``."
#~ msgstr ""

#~ msgid "Tarantool returns an error if the table does not exist."
#~ msgstr ""

#~ msgid ""
#~ "If *column-list* is specified, the "
#~ "number of columns in *column-list* "
#~ "must be the same as the number "
#~ "of columns in the *select-list* of"
#~ " the subquery."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool will create a new persistent"
#~ " object with *column-names* equal to"
#~ " the names in the *column-list* "
#~ "or the names in the subquery's "
#~ "*select-list*."
#~ msgstr ""

#~ msgid "Tarantool returns an error if the view does not exist."
#~ msgstr ""

#~ msgid "Tarantool inserts values into the table."
#~ msgstr ""

#~ msgid "Tarantool deletes the set of matching rows from the table."
#~ msgstr ""

#~ msgid ""
#~ ":samp:`CREATE TRIGGER [IF NOT EXISTS] "
#~ "{trigger-name}` |br| :samp:`BEFORE|AFTER|INSTEAD "
#~ "OF` |br| :samp:`INSERT|UPDATE|DELETE ON "
#~ "{table-name}` |br| :samp:`FOR EACH ROW` "
#~ "|br| :samp:`[WHEN (search-condition)]` |br|"
#~ " :samp:`BEGIN` |br| :samp:`update-statement "
#~ "| insert-statement | delete-statement"
#~ " | select-statement;` |br| :samp"
#~ ":`[update-statement | insert-statement |"
#~ " delete-statement | select-statement; "
#~ "...]` |br| :samp:`END;`"
#~ msgstr ""

#~ msgid ""
#~ "It is legal for the trigger action"
#~ " to include a :ref:`SELECT statement "
#~ "<sql_select>` or a :ref:`REPLACE statement "
#~ "<sql_replace>`, but not recommended."
#~ msgstr ""

#~ msgid "\"triggered statement\" = BEGIN ... INSERT|DELETE|UPDATE ... END"
#~ msgstr ""

#~ msgid "\"triggered when clause\" = WHEN (search condition)"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TRIGGER t1_before_delete BEFORE DELETE"
#~ " ON t1 BEGIN DELETE FROM t2; "
#~ "END;\n"
#~ "CREATE TRIGGER t2_before_delete BEFORE DELETE"
#~ " ON t2 BEGIN DELETE FROM t3; "
#~ "END;"
#~ msgstr ""

#~ msgid ""
#~ "If an UPDATE trigger event does "
#~ "not make a change, the trigger is"
#~ " activated anyway. For example, if "
#~ "row 1 ``column1`` contains 'a', and "
#~ "the trigger event is ``UPDATE ... "
#~ "SET column1 = 'a';``, the trigger "
#~ "is activated."
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE base_table (primary_key_column "
#~ "INTEGER PRIMARY KEY, value_column INTEGER);"
#~ "\n"
#~ "CREATE VIEW viewed_table AS SELECT "
#~ "primary_key_column, value_column FROM base_table;"
#~ "\n"
#~ "CREATE TRIGGER viewed_table_instead_of_insert "
#~ "INSTEAD OF INSERT ON viewed_table FOR"
#~ " EACH ROW\n"
#~ "  BEGIN\n"
#~ "    INSERT INTO base_table VALUES "
#~ "(new.primary_key_column, new.value_column);\n"
#~ "  END;\n"
#~ "CREATE TRIGGER viewed_table_instead_of_update "
#~ "INSTEAD OF UPDATE ON viewed_table FOR"
#~ " EACH ROW\n"
#~ "  BEGIN\n"
#~ "    UPDATE base_table\n"
#~ "    SET primary_key_column = "
#~ "new.primary_key_column, value_column = "
#~ "new.value_column\n"
#~ "    WHERE primary_key_column = old.primary_key_column;\n"
#~ "  END;\n"
#~ "CREATE TRIGGER viewed_table_instead_of_delete "
#~ "INSTEAD OF DELETE ON viewed_table FOR"
#~ " EACH ROW\n"
#~ "  BEGIN\n"
#~ "    DELETE FROM base_table WHERE "
#~ "primary_key_column = old.primary_key_column;\n"
#~ "  END;"
#~ msgstr ""

#~ msgid ""
#~ "For each row\n"
#~ "  Perform constraint checks\n"
#~ "  For each BEFORE trigger that refers to table X\n"
#~ "    Check that the trigger's WHEN condition is true.\n"
#~ "    Execute what is in the trigger's BEGIN|END block.\n"
#~ "  Insert or update or delete the row in table X.\n"
#~ "  Perform more constraint checks\n"
#~ "  For each AFTER trigger that refers to table X\n"
#~ "    Check that the trigger's WHEN condition is true.\n"
#~ "    Execute what is in the trigger's BEGIN|END block."
#~ msgstr ""

#~ msgid "Tarantool returns an error if the trigger does not exist."
#~ msgstr ""

#~ msgid ""
#~ "If the table has an autoincrement "
#~ "primary key, its :ref:`sequence "
#~ "<box_schema-sequence_create_index>` is reset to"
#~ " zero."
#~ msgstr ""

#~ msgid ""
#~ ":samp:`SELECT [ALL|DISTINCT] select-list [from"
#~ " clause] [where clause] [group-by "
#~ "clause] [having clause] [order-by "
#~ "clause];`"
#~ msgstr ""

#~ msgid "Select-list"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`select-list-column [, select-"
#~ "list-column ...] select-list-column:`"
#~ msgstr ""

#~ msgid ""
#~ "The *select-list* is a comma-"
#~ "delimited list of expressions, or ``*``"
#~ " (asterisk). An expression can have "
#~ "an alias provided with an ``[AS "
#~ "[column-name]]`` clause."
#~ msgstr ""

#~ msgid ""
#~ "The ``[AS [column-name]]`` clause "
#~ "determines the column name. The column"
#~ " name is useful for two reasons:"
#~ msgstr ""

#~ msgid ""
#~ "if the results of the SELECT are"
#~ " used in ``CREATE TABLE new-table-"
#~ "name ... AS SELECT select-list "
#~ "...``, then the column names in "
#~ "the new table will be the column"
#~ " names in the *select-list*."
#~ msgstr ""

#~ msgid ""
#~ "If ``[AS [column-name]]`` is missing,"
#~ " Tarantool makes a name equal to "
#~ "the expression, for example ``SELECT 5"
#~ " * 88`` will cause the column "
#~ "name to be ``5 * 88``, but "
#~ "such names may be ambiguous or "
#~ "illegal in other contexts, so it "
#~ "is better to say, for example, "
#~ "``SELECT 5 * 88 AS column1``."
#~ msgstr ""

#~ msgid ""
#~ "a    b      c    COUNT(a) SUM(a) MIN(c)\n"
#~ "-    -      -    -------- ------ ------\n"
#~ "1    'a'  'b'         2      2    'b'\n"
#~ "1    'b'  'b'         1      1    'b'\n"
#~ "2    'a'  'b'         1      2    'b'\n"
#~ "     'a'  'b'         1      3    'b'"
#~ msgstr ""

#~ msgid ""
#~ "Aggregate functions are only legal in"
#~ " certain clauses of a :ref:`SELECT "
#~ "statement <sql_select>` for grouped tables."
#~ " (A table is a grouped table if"
#~ " a GROUP BY clause is present.) "
#~ "Also, if an aggregate function is "
#~ "used in a select-list and the "
#~ "GROUP BY clause is omitted, then "
#~ "Tarantool assumes ``SELECT ... GROUP BY"
#~ " [all columns];``."
#~ msgstr ""

#~ msgid "``GROUP_CONCAT(expression-1 [, expression-2])``"
#~ msgstr ""

#~ msgid "Example: :samp:`GROUP_CONCAT{column1})`"
#~ msgstr ""

#~ msgid ""
#~ "Expression is a positive integer, "
#~ "representing the ordinal position of the"
#~ " column in the select list. For "
#~ "example, in the statement |br| ``SELECT"
#~ " x, y, z FROM t ORDER BY "
#~ "2;`` |br| ``ORDER BY 2`` means "
#~ "\"order by the second column in "
#~ "the select list\", which is ``y``."
#~ msgstr ""

#~ msgid ""
#~ "NULLs come first, then BOOLEANs, then"
#~ " numbers (INTEGER or DOUBLE), then "
#~ "STRINGs, then VARBINARYs."
#~ msgstr ""

#~ msgid ""
#~ "-- with a single column:\n"
#~ "SELECT 1 FROM t ORDER BY column1;\n"
#~ "-- with two columns:\n"
#~ "SELECT 1 FROM t ORDER BY column1, column2;\n"
#~ "-- with a variety of data:\n"
#~ "CREATE TABLE h (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
#~ "INSERT INTO h VALUES (7, 'A'), (4,"
#~ " 'A '), (-4, 'AZ'), (17, 17), "
#~ "(23, NULL);\n"
#~ "INSERT INTO h VALUES (17.5, 'Д'), (1e+300, 'a'), (0, ''), (-1, '');\n"
#~ "SELECT * FROM h ORDER BY s2, s1;\n"
#~ "-- The result of the above SELECT will be:\n"
#~ "- - [23, null]\n"
#~ "  - [17, 17]\n"
#~ "  - [-1, '']\n"
#~ "  - [0, '']\n"
#~ "  - [7, 'A']\n"
#~ "  - [4, 'A ']\n"
#~ "  - [-4, 'AZ']\n"
#~ "  - [1e+300, 'a']\n"
#~ "  - [17.5, 'Д']\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
#~ "CREATE INDEX idx_column2_t_1 ON t (column2);\n"
#~ "INSERT INTO t VALUES (1, 2), (2, 1);\n"
#~ "SELECT * FROM t INDEXED BY \"pk_unnamed_T_1\";\n"
#~ "SELECT * FROM t INDEXED BY i;\n"
#~ "-- Result for the first select: (1, 2), (2, 1)\n"
#~ "-- Result for the second select: (2, 1), (1, 2)."
#~ msgstr ""

#~ msgid ""
#~ "Return a result set with one row"
#~ " for each foreign key of \"table-"
#~ "name\". Each row contains: |br| "
#~ "(INTEGER) id -- identification number "
#~ "|br| (INTEGER) seq -- sequential number"
#~ " |br| (STRING) table -- name of "
#~ "table |br| (STRING) from  -- referencing"
#~ " key |br| (STRING) to -- referenced"
#~ " key |br| (STRING) on_update -- ON"
#~ " UPDATE clause |br| (STRING) on_delete "
#~ "-- ON DELETE clause |br| (STRING) "
#~ "match -- MATCH clause |br| The "
#~ "system table is ``\"_fk_constraint\"``."
#~ msgstr ""

#~ msgid "Example: (not showing metadata)"
#~ msgstr ""

#~ msgid ""
#~ "Return the value of the first "
#~ "non-NULL expression, or, if both "
#~ "expression values are NULL, return NULL."
#~ " Thus ``IFNULL(expression, expression)`` is "
#~ "the same as ``COALESCE(expression, "
#~ "expression)``."
#~ msgstr ""

#~ msgid ""
#~ "Return the least value of the "
#~ "supplied expressions, or, if any "
#~ "expression is NULL, return . The "
#~ "reverse of ``LEAST`` is :ref:`GREATEST "
#~ "<sql_function_greatest>`."
#~ msgstr ""

#~ msgid ":samp:`REPLACE({expression-1}, {xpression-2}, {expression-3})`"
#~ msgstr ""

#~ msgid ""
#~ "Examples: ``TRIM('a' FROM 'abaaaaa')`` is "
#~ "'b' -- all repetitions of 'a' are"
#~ " removed on both sides; ``TRIM(TRAILING "
#~ "'ב' FROM 'אב')`` is 'א' -- if "
#~ "all characters are Hebrew, TRAILING "
#~ "means \"left\"; ``TRIM(X'004400')`` is X'44'"
#~ " -- the default byte sequence to "
#~ "trim is X'00' when data type is"
#~ " VARBINARY' ``TRIM(LEADING 'abc' FROM "
#~ "'abcd')`` is 'd' -- expression-1 can "
#~ "have more than 1 character"
#~ msgstr ""

#~ msgid ""
#~ "Example: for a December 2019 build "
#~ "VERSION() is ``2.3.0-258-g960e9c0c7``."
#~ msgstr ""

#~ msgid ""
#~ "To create a HASH index on things"
#~ " (remark), say: |br| "
#~ "``box.space.THINGS:create_index('hash', {type='hash', "
#~ "parts={2, 'scalar'}})``"
#~ msgstr ""

#~ msgid ""
#~ "For example, the :ref:`_space <box_space-"
#~ "space>` system table has these fields"
#~ " which are seen in SQL as "
#~ "columns: |br| |nbsp|  id = numeric "
#~ "identifier |br| |nbsp|  owner = for "
#~ "example, 1 if the object was made"
#~ " by the ``'admin'`` user |br| |nbsp|"
#~ "  name = the name that was used"
#~ " with CREATE TABLE |br| |nbsp|  "
#~ "engine = usually ``'memtx'`` (the "
#~ "``'vinyl'`` engine can be used but "
#~ "is not default) |br| |nbsp|  field_count"
#~ " = sometimes 0, but usually a "
#~ "count of the table's columns |br| "
#~ "|nbsp|  flags = usually empty |br| "
#~ "|nbsp|  format = what a Lua "
#~ "format() function or an SQL CREATE "
#~ "statement produced |br| Example selection: "
#~ "|br| |nbsp|  ``SELECT \"id\", \"name\" "
#~ "FROM \"_space\";``"
#~ msgstr ""

#~ msgid ""
#~ "Functions can be invoked anywhere that"
#~ " the SQL syntax allows a literal "
#~ "or a column name for reading. "
#~ "Function parameters can include any "
#~ "number of SQL values. If a SELECT"
#~ " statement's result list has a "
#~ "million rows, and the select list "
#~ "invokes a non-deterministic function, "
#~ "then the function is called a "
#~ "million times."
#~ msgstr ""

#~ msgid ""
#~ "For example this will show the "
#~ "number of seconds since the epoch: "
#~ "|br| ``box.execute([[SELECT lua('return "
#~ "os.time()');]])`` |br| For example this "
#~ "will show a database configuration "
#~ "member: |br| ``box.execute([[SELECT lua('return "
#~ "box.cfg.memtx_memory');]])`` For example this "
#~ "will return FALSE because Lua nil "
#~ "and box.NULL are the same as SQL"
#~ " NULL: |br| ``box.execute([[SELECT lua('return"
#~ " box.NULL') IS NOT NULL;]])``"
#~ msgstr ""

#~ msgid ""
#~ "So the session looks like this: "
#~ "|br| ``box.cfg{}`` |br| ``box.execute([[CREATE "
#~ "TABLE t1 (c1 INTEGER PRIMARY KEY, "
#~ "c2 STRING);]])`` |br| ``box.execute([[CREATE "
#~ "TABLE t2 (c1 INTEGER PRIMARY KEY, "
#~ "x2 STRING);]])`` |br| ``box.execute([[INSERT "
#~ "INTO t1 VALUES (1, 'A'), (2, 'B'),"
#~ " (3, 'C');]])`` |br| ``box.execute([[INSERT "
#~ "INTO t1 VALUES (4, 'D'), (5, 'E'),"
#~ " (6, 'F');]])`` |br| ``box.execute([[INSERT "
#~ "INTO t2 VALUES (1, 'C'), (4, 'A'),"
#~ " (6, NULL);]])`` |br| ``box.execute([[CREATE "
#~ "VIEW v AS SELECT * FROM t1 "
#~ "NATURAL JOIN t2;]])`` |br| "
#~ "``box.execute([[SELECT * FROM v WHERE c2"
#~ " IS NOT NULL ORDER BY c1;)]])``"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.func.drop('_COLUMNS_FORMATS', {if_exists = true})\n"
#~ "box.schema.func.create('_COLUMNS_FORMATS',\n"
#~ "    {language = 'LUA',\n"
#~ "     returns = 'string',\n"
#~ "     body = [[\n"
#~ "     function (row_number_, ordinal_position)\n"
#~ "         if row_number_ == 0 then\n"
#~ "             _G.box.FORMATS = {}\n"
#~ "             local vspace = box.space._vspace:select()\n"
#~ "             for i = 1, #vspace do\n"
#~ "                 local format = vspace[i][\"format\"]\n"
#~ "                 for j = 1, #format do\n"
#~ "                     local is_nullable = 'YES'\n"
#~ "                     if format[j].is_nullable == false then\n"
#~ "                         is_nullable = 'NO'\n"
#~ "                     end\n"
#~ "                     table.insert(_G.box.FORMATS,\n"
#~ "                                  {vspace[i].name, format[j].name, j,\n"
#~ "                                   is_nullable, "
#~ "format[j].type, vspace[i].id})\n"
#~ "                 end\n"
#~ "             end\n"
#~ "             return ''\n"
#~ "         end\n"
#~ "         if row_number_ > #_G.box.FORMATS then\n"
#~ "             _G.box.FORMATS = {}\n"
#~ "             return ''\n"
#~ "         end\n"
#~ "         return _G.box.FORMATS[row_number_][ordinal_position]\n"
#~ "     end\n"
#~ "     ]],\n"
#~ "    param_list = {'integer', 'integer'},\n"
#~ "    exports = {'LUA', 'SQL'},\n"
#~ "    is_sandboxed = false,\n"
#~ "    setuid = false,\n"
#~ "    is_deterministic = false})\n"
#~ "box.schema.role.grant('public', 'execute', 'function', "
#~ "'_COLUMNS_FORMATS')\n"
#~ "\n"
#~ "pcall(function ()\n"
#~ "    box.schema.role.revoke('public', 'read', "
#~ "'space', '_COLUMNS', {if_exists = true})\n"
#~ ""
#~ "    end)\n"
#~ "box.execute([[DROP VIEW IF EXISTS _columns;]])\n"
#~ "box.execute([[\n"
#~ "CREATE VIEW _columns AS\n"
#~ "WITH RECURSIVE r_columns AS\n"
#~ "(\n"
#~ "SELECT 0 AS row_number_,\n"
#~ "      '' AS table_name,\n"
#~ "      '' AS column_name,\n"
#~ "      0 AS ordinal_position,\n"
#~ "      '' AS is_nullable,\n"
#~ "      '' AS data_type,\n"
#~ "      0 AS id\n"
#~ "UNION ALL\n"
#~ "SELECT row_number_ + 1 AS row_number_,\n"
#~ "       _columns_formats(row_number_, 1) AS table_name,\n"
#~ "       _columns_formats(row_number_, 2) AS column_name,\n"
#~ "       _columns_formats(row_number_, 3) AS ordinal_position,\n"
#~ "       _columns_formats(row_number_, 4) AS is_nullable,\n"
#~ "       _columns_formats(row_number_, 5) AS data_type,\n"
#~ "       _columns_formats(row_number_, 6) AS id\n"
#~ "    FROM r_columns\n"
#~ "    WHERE row_number_ == 0 OR "
#~ "row_number_ <= lua('return #_G.box.FORMATS +"
#~ " 1')\n"
#~ ")\n"
#~ "SELECT CAST(NULL AS STRING) AS catalog_name,\n"
#~ "       CAST(NULL AS STRING) AS schema_name,\n"
#~ "       table_name,\n"
#~ "       column_name,\n"
#~ "       ordinal_position,\n"
#~ "       is_nullable,\n"
#~ "       data_type,\n"
#~ "       id\n"
#~ "    FROM r_columns\n"
#~ "    WHERE data_type <> '';\n"
#~ "]])\n"
#~ "box.schema.role.grant('public', 'read', 'space', '_COLUMNS')"
#~ msgstr ""

#~ msgid ""
#~ "The S \"Sometimes allowed\" character "
#~ "applies for these special situations: "
#~ "|br| From STRING To BOOLEAN is "
#~ "allowed if UPPER(string-value) = "
#~ "``'TRUE'`` or ``'FALSE'``. |br| From "
#~ "number to INTEGER or UNSIGNED is "
#~ "allowed for cast and assignment only "
#~ "if the result is not out of "
#~ "range. |br| From STRING to number "
#~ "is allowed only if the string has"
#~ " a representation of a number. |br|"
#~ " From BOOLEAN to number is allowed"
#~ " only if the number is not "
#~ "DOUBLE."
#~ msgstr ""

#~ msgid ""
#~ "The chart does not show To|From "
#~ "SCALAR because the conversions depend on"
#~ " the type of the value, not the"
#~ " type of the column definition. "
#~ "Explicit cast to SCALAR is allowed "
#~ "but has no effect, the result data"
#~ " type is always the same as the"
#~ " original data type. But comparisons "
#~ "of values of different types are "
#~ "allowed if the definition is SCALAR."
#~ msgstr ""

#~ msgid ""
#~ "For assignments, the cast is always "
#~ "from source to target. Therefore "
#~ "``INSERT INTO t (integer_column) VALUES "
#~ "('5');`` inserts 5. |br| |br| If "
#~ "the cast fails, then the result is"
#~ " an error."
#~ msgstr ""

#~ msgid "SQL beginners' guide"
#~ msgstr ""

#~ msgid "**What Tarantool's SQL product delivers**"
#~ msgstr ""

#~ msgid ""
#~ "This document has four parts. The "
#~ "SQL BEGINNERS' GUIDE explains the basics"
#~ " of relational database management and "
#~ "SQL in particular. The USER GUIDE "
#~ "explains \"How to get Started\" and "
#~ "explains the terms and the syntax "
#~ "elements that apply for all SQL "
#~ "statements. The SQL STATEMENTS AND "
#~ "CLAUSES guide explains, for each SQL "
#~ "statement, the format and the rules "
#~ "and the exceptions and the examples "
#~ "and the limitations. The SQL PLUS "
#~ "LUA guide has the details about "
#~ "calling Lua from SQL, calling SQL "
#~ "from Lua, and using the same "
#~ "database objects in both SQL and "
#~ "Lua."
#~ msgstr ""

#~ msgid "**SQL beginners' guide begins**"
#~ msgstr ""

#~ msgid ""
#~ "The Beginners' Guide describes how users"
#~ " can start up with SQL with "
#~ "Tarantool, and necessary concepts."
#~ msgstr ""

#~ msgid ""
#~ "The SQL Beginners' Guide is about "
#~ "databases in general, and about the "
#~ "relationship between Tarantool's NoSQL and "
#~ "SQL products. Most of the matters "
#~ "in the Beginners' Guide will already "
#~ "be familiar to people who have "
#~ "used relational databases before."
#~ msgstr ""

#~ msgid "**Sample Simple Table**"
#~ msgstr ""

#~ msgid ""
#~ "In football training camp it is "
#~ "traditional for the trainer to begin "
#~ "by showing a football and saying "
#~ "\"this is a football\". In that "
#~ "spirit, this is a table:"
#~ msgstr ""

#~ msgid ""
#~ "TABLE\n"
#~ "          [1]              [2]              [3]\n"
#~ "       +-----------------+----------------+----------------+\n"
#~ " Row#1 | Row#1,Column#1  | Row#1,Column#2 | Row#1,Column#3 |\n"
#~ "       +-----------------+----------------+----------------+\n"
#~ " Row#2 | Row#2,Column#1  | Row#2,Column#2 | Row#2,Column#3 |\n"
#~ "       +-----------------+----------------+----------------+\n"
#~ " Row#3 | Row#3,Column#1  | Row#3,Column#2 | Row#3,Column#3 |\n"
#~ "       +-----------------+----------------+----------------+"
#~ msgstr ""

#~ msgid ""
#~ "but the labels are misleading -- "
#~ "we usually don't identify rows and "
#~ "columns by their ordinal positions, we"
#~ " prefer to pick out specific items"
#~ " by their contents. In that spirit,"
#~ " this is a table:"
#~ msgstr ""

#~ msgid ""
#~ "modules\n"
#~ "\n"
#~ "+-----------------+------+---------------------+\n"
#~ "| name            | size | purpose             |\n"
#~ "+-----------------|------|---------------------|\n"
#~ "| box             | 1432 | Database Management |\n"
#~ "| clock           |  188 | Seconds             |\n"
#~ "| crypto          |    4 | Cryptography        |\n"
#~ "+-----------------+------+---------------------+"
#~ msgstr ""

#~ msgid ""
#~ "so we do not use longitude/latitude "
#~ "navigation by talking about \"Row#2 "
#~ "Column #2\", we use the contents "
#~ "of the Name column and the name"
#~ " of the Size column by talking "
#~ "about \"the size, where the name "
#~ "is 'clock'\". To be more exact, "
#~ "this is what we say:"
#~ msgstr ""

#~ msgid "``SELECT size FROM modules WHERE name = 'clock';``"
#~ msgstr ""

#~ msgid ""
#~ "If you're familiar with Tarantool's "
#~ "architecture -- and we hope that "
#~ "you read about that before coming "
#~ "to this chapter -- then you know"
#~ " that there is a NoSQL way to"
#~ " get the same thing:"
#~ msgstr ""

#~ msgid "``box.space.MODULES:select()[2][2]``"
#~ msgstr ""

#~ msgid ""
#~ "Well, you can do that. One of "
#~ "the advantages of Tarantool is that "
#~ "if you can get data via an "
#~ "SQL statement, then you can get "
#~ "the same data via a NoSQL request."
#~ " But the reverse is not true, "
#~ "because not all NoSQL tuple sets "
#~ "are definable as SQL tables. These "
#~ "restrictions apply for SQL that do "
#~ "not apply for NoSQL: |br| 1. Every"
#~ " column must have a name. |br| "
#~ "2. Every column must have a scalar"
#~ " type (Tarantool is relaxed about "
#~ "which particular scalar type you can "
#~ "have, but there is no way to "
#~ "index and search arrays, tables within"
#~ " tables, or what MessagePack calls "
#~ "\"maps\".)"
#~ msgstr ""

#~ msgid "Tarantool/NoSQL's \"format\" clause causes the same restrictions."
#~ msgstr ""

#~ msgid ""
#~ "So an SQL \"table\" is a NoSQL "
#~ "\"tuple set with format restrictions\", "
#~ "an SQL \"row\" is a NoSQL "
#~ "\"tuple\", an SQL \"column\" is a "
#~ "NoSQL \"list of fields within a "
#~ "tuple set\"."
#~ msgstr ""

#~ msgid "**Creating a table**"
#~ msgstr ""

#~ msgid "This is how to create the modules table:"
#~ msgstr ""

#~ msgid ""
#~ "``CREATE TABLE modules (name STRING, "
#~ "size INTEGER, purpose STRING, PRIMARY "
#~ "KEY (name));``"
#~ msgstr ""

#~ msgid ""
#~ "The words that are IN CAPITAL "
#~ "LETTERS are \"keywords\" (although it is"
#~ " only a convention in this manual "
#~ "that keywords are in capital letters,"
#~ " in practice many programmers prefer "
#~ "to avoid shouting). A keyword has "
#~ "meaning for the SQL parser so many"
#~ " keywords are reserved, they cannot "
#~ "be used as names unless they are"
#~ " enclosed inside quotation marks."
#~ msgstr ""

#~ msgid ""
#~ "The word \"modules\" is a \"table "
#~ "name\", and the words \"name\" and "
#~ "\"size\" and \"purpose\" are \"column "
#~ "names\". All tables and all columns "
#~ "must have names."
#~ msgstr ""

#~ msgid ""
#~ "The words \"STRING\" and \"INTEGER\" are"
#~ " \"data types\". STRING means \"the "
#~ "contents should be characters, the "
#~ "length is indefinite, the equivalent "
#~ "NoSQL type is 'string''\". INTEGER means"
#~ " \"the contents should be numbers "
#~ "without decimal points, the equivalent "
#~ "NoSQL type is 'integer'\". Tarantool "
#~ "supports other data types but our "
#~ "example table has data types from "
#~ "the two main groups, namely, data "
#~ "types for numbers and data types "
#~ "for strings."
#~ msgstr ""

#~ msgid ""
#~ "The final clause, PRIMARY KEY (name),"
#~ " means that the name column is "
#~ "the main column used to identify "
#~ "the row."
#~ msgstr ""

#~ msgid "**Nulls**"
#~ msgstr ""

#~ msgid ""
#~ "Frequently it is necessary, at least "
#~ "temporarily, that a column value should"
#~ " be NULL. Typical situations are: the"
#~ " value is unknown, or the value "
#~ "is not applicable. For example, you "
#~ "might make a module as a "
#~ "placeholder but you don't want to "
#~ "say its size or purpose. If such"
#~ " things are possible, the column is"
#~ " \"nullable\". Our name column cannot "
#~ "contain nulls, and it could be "
#~ "defined explicitly as \"name STRING NOT"
#~ " NULL\", but in this case that's "
#~ "unnecessary -- a column defined as "
#~ "PRIMARY KEY is automatically NOT NULL."
#~ msgstr ""

#~ msgid ""
#~ "Is a NULL in SQL the same "
#~ "thing as a nil in Lua? No, "
#~ "but it is close enough that there"
#~ " will be confusion. When nil means"
#~ " \"unknown\" or \"inapplicable\", yes. But"
#~ " when nil means \"nonexistent\" or "
#~ "\"type is nil\", no. NULL is a "
#~ "value, it has a data type because"
#~ " it is inside a column which is"
#~ " defined with that data type."
#~ msgstr ""

#~ msgid "**Creating an index**"
#~ msgstr "Создание экземпляра iconv"

#~ msgid "This is how to create indexes for the modules table:"
#~ msgstr ""

#~ msgid ""
#~ "``CREATE INDEX size ON modules (size);``"
#~ " |br| ``CREATE UNIQUE INDEX purpose "
#~ "ON modules (purpose);``"
#~ msgstr ""

#~ msgid ""
#~ "There is no need to create an "
#~ "index on the name column, because "
#~ "Tarantool creates an index automatically "
#~ "when it sees a PRIMARY KEY clause"
#~ " in the CREATE TABLE statement. In"
#~ " fact there is no need to "
#~ "create indexes on the size or "
#~ "purpose columns either -- if indexes "
#~ "don't exist, then it is still "
#~ "possible to use the columns for "
#~ "searches. Typically people create non-"
#~ "primary indexes, also called secondary "
#~ "indexes, when it becomes clear that "
#~ "the table will grow large and "
#~ "searches will be frequent, because "
#~ "searching with an index is generally "
#~ "much faster than searching without an"
#~ " index."
#~ msgstr ""

#~ msgid ""
#~ "Another use for indexes is to "
#~ "enforce uniqueness. When an index is "
#~ "created with CREATE UNIQUE INDEX for "
#~ "the purpose column, it is not "
#~ "possible to have duplicate values in "
#~ "that column."
#~ msgstr ""

#~ msgid "**Data change**"
#~ msgstr ""

#~ msgid ""
#~ "Putting data into a table is "
#~ "called \"inserting\". Changing data is "
#~ "called \"updating\". Removing data is "
#~ "called \"deleting\". Together, the three "
#~ "SQL statements INSERT plus UPDATE plus"
#~ " DELETE are the three main \"data-"
#~ "change\" statements."
#~ msgstr ""

#~ msgid "This is how to insert, update, and delete a row in the modules table:"
#~ msgstr ""

#~ msgid ""
#~ "``INSERT INTO modules VALUES ('json', "
#~ "14, 'format functions for JSON');`` |br|"
#~ " ``UPDATE modules SET size = 15 "
#~ "WHERE name = 'json';`` |br| ``DELETE "
#~ "FROM modules WHERE name = 'json';``"
#~ msgstr ""

#~ msgid "The corresponding non-SQL Tarantool requests would be:"
#~ msgstr ""

#~ msgid ""
#~ "``box.space.MODULES:insert{'json', 14, 'format "
#~ "functions for JSON'}`` |br| "
#~ "``box.space.MODULES:update('json', {{'=', 2, 15}})``"
#~ " |br| ``box.space.MODULES:delete{'json'}`` |br|"
#~ msgstr ""

#~ msgid ""
#~ "This is how we would populate the"
#~ " table with the values that we "
#~ "showed earlier:"
#~ msgstr ""

#~ msgid ""
#~ "``INSERT INTO modules VALUES ('box', "
#~ "1432, 'Database Management');`` |br| ``INSERT"
#~ " INTO modules VALUES ('clock', 188, "
#~ "'Seconds');`` |br| ``INSERT INTO modules "
#~ "VALUES ('crypto', 4, 'Cryptography');`` |br|"
#~ msgstr ""

#~ msgid "**Constraints**"
#~ msgstr "**Консистентное хеширование**"

#~ msgid ""
#~ "Some data-change statements are illegal"
#~ " due to something in the table's "
#~ "definition. This is called \"constraining "
#~ "what can be done\". We have "
#~ "already seen some types of constraints"
#~ " ..."
#~ msgstr ""

#~ msgid ""
#~ "NOT NULL -- if a column is "
#~ "defined with a NOT NULL clause, it"
#~ " is illegal to put NULL into "
#~ "it. A primary-key column is "
#~ "automatically NOT NULL."
#~ msgstr ""

#~ msgid ""
#~ "UNIQUE -- if a column has a "
#~ "UNIQUE index, it is illegal to put"
#~ " a duplicate into it. A primary-"
#~ "key column automatically has a UNIQUE"
#~ " index."
#~ msgstr ""

#~ msgid ""
#~ "data domain -- if a column is "
#~ "defined as having data type INTEGER, "
#~ "it is illegal to put a non-"
#~ "number into it. More generally, if "
#~ "a value doesn't correspond to the "
#~ "data type of the definition, it is"
#~ " illegal. However, some database management"
#~ " systems (DBMSs) are very forgiving "
#~ "and will try to make allowances "
#~ "for bad values rather than reject "
#~ "them; Tarantool is one of those "
#~ "DBMSs."
#~ msgstr ""

#~ msgid "Now, here are other types of constraints ..."
#~ msgstr ""

#~ msgid ""
#~ "CHECK -- a table description can "
#~ "have a clause \"CHECK (conditional "
#~ "expression)\". For example, if the "
#~ "CREATE TABLE modules statement looked "
#~ "like this:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE modules (name STRING,\n"
#~ "                      size INTEGER,\n"
#~ "                      purpose STRING,\n"
#~ "                      PRIMARY KEY (name),\n"
#~ "                      CHECK (size > 0));"
#~ msgstr ""

#~ msgid ""
#~ "then this INSERT statement would be "
#~ "illegal: |br| ``INSERT INTO modules "
#~ "VALUES ('box', 0, 'The Database "
#~ "Kernel');`` |br| because there is a "
#~ "CHECK constraint saying that the second"
#~ " column, the size column, cannot "
#~ "contain a value which is less than"
#~ " or equal to zero. Try this "
#~ "instead: |br| ``INSERT INTO modules "
#~ "VALUES ('box', 1, 'The Database "
#~ "Kernel');``"
#~ msgstr ""

#~ msgid ""
#~ "FOREIGN KEY -- a table description "
#~ "can have a clause \"FOREIGN KEY "
#~ "(column-list) REFERENCES table (column-"
#~ "list)\". For example, if there is "
#~ "a new table \"submodules\" which in "
#~ "a way depends on the modules "
#~ "table, it can be defined like "
#~ "this:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE submodules (name STRING,\n"
#~ "                         module_name STRING,\n"
#~ "                         size INTEGER,\n"
#~ "                         purpose STRING,\n"
#~ "                         PRIMARY KEY (name),\n"
#~ "                         FOREIGN KEY (module_name) REFERENCES\n"
#~ "                         modules (name));"
#~ msgstr ""

#~ msgid "Now try to insert a new row into this submodules table:"
#~ msgstr ""

#~ msgid ""
#~ "``INSERT INTO submodules VALUES`` |br| "
#~ "|nbsp| |nbsp| ``('space', 'Box', 10000, "
#~ "'insert etc.');``"
#~ msgstr ""

#~ msgid ""
#~ "The insert will fail because the "
#~ "second column (module_name) refers to "
#~ "the name column in the modules "
#~ "table, and the name column in the"
#~ " modules table does not contain "
#~ "'Box'. However, it does contain 'box'."
#~ " By default searches in Tarantool's "
#~ "SQL use a binary collation. This "
#~ "will work:"
#~ msgstr ""

#~ msgid ""
#~ "``INSERT INTO submodules`` |br| |nbsp| "
#~ "|nbsp| ``VALUES ('space', 'box', 10000, "
#~ "'insert etc.');``"
#~ msgstr ""

#~ msgid "Now try to delete the new row from the modules table:"
#~ msgstr ""

#~ msgid "``DELETE FROM modules WHERE name = 'box';``"
#~ msgstr ""

#~ msgid ""
#~ "The delete will fail because the "
#~ "second column (module_name) in the "
#~ "submodules table refers to the name "
#~ "column in the modules table, and "
#~ "the name column in the modules "
#~ "table would not contain 'box' if "
#~ "the delete succeeded. So the FOREIGN "
#~ "KEY constraint affects both the table"
#~ " which contains the FOREIGN KEY "
#~ "clause and the table that the "
#~ "FOREIGN KEY clause refers to."
#~ msgstr ""

#~ msgid ""
#~ "The constraints in a table's definition"
#~ " -- NOT NULL, UNIQUE, data domain,"
#~ " CHECK, and FOREIGN KEY -- are "
#~ "guarantors of the database's integrity. "
#~ "It is important that they are "
#~ "fixed and well-defined parts of "
#~ "the definition, and hard to bypass "
#~ "with SQL. This is often seen as"
#~ " a difference between SQL and NoSQL"
#~ " -- SQL emphasizes law and order, "
#~ "NoSQL emphasizes freedom and making your"
#~ " own rules."
#~ msgstr ""

#~ msgid "**Table Relationships**"
#~ msgstr ""

#~ msgid "Think about the two tables that we have discussed so far:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE modules (name STRING,\n"
#~ "                      size INTEGER,\n"
#~ "                       purpose STRING,\n"
#~ "                       PRIMARY KEY (name),\n"
#~ "                       CHECK (size > 0));\n"
#~ "\n"
#~ "CREATE TABLE submodules (name STRING,\n"
#~ "                         module_name STRING,\n"
#~ "                         size INTEGER,\n"
#~ "                         purpose STRING,\n"
#~ "                         PRIMARY KEY (name),\n"
#~ "                         FOREIGN KEY (module_name) REFERENCES\n"
#~ "                         modules (name));"
#~ msgstr ""

#~ msgid ""
#~ "Because of the FOREIGN KEYS clause "
#~ "in the submodules table, there is "
#~ "clearly a many-to-one relationship: "
#~ "|br| submodules -->> modules |br| that"
#~ " is, every submodules row must refer"
#~ " to one (and only one) modules "
#~ "row, while every modules row can "
#~ "be referred to in zero or more "
#~ "submodules rows."
#~ msgstr ""

#~ msgid ""
#~ "Table relationships are important, but "
#~ "beware: do not trust anyone who "
#~ "tells you that databases made with "
#~ "SQL are relational \"because there are"
#~ " relationships between tables\". That is"
#~ " wrong. We will see why when we"
#~ " talk about what makes a database "
#~ "relational, later."
#~ msgstr ""

#~ msgid "**Selecting with WHERE**"
#~ msgstr ""

#~ msgid "We gave a simple example of a SELECT statement earlier:"
#~ msgstr ""

#~ msgid ""
#~ "The clause \"WHERE name = 'clock'\" "
#~ "is legal in other statements -- we"
#~ " have seen it in UPDATE and "
#~ "DELETE -- but here we will only"
#~ " give examples with SELECT."
#~ msgstr ""

#~ msgid ""
#~ "The first variation is that the "
#~ "WHERE clause does not have to be"
#~ " specified at all, it is optional."
#~ " So this statement would return all"
#~ " rows:"
#~ msgstr ""

#~ msgid "``SELECT size FROM modules;``"
#~ msgstr ""

#~ msgid ""
#~ "The second variation is that the "
#~ "comparison operator does not have to "
#~ "be '=', it can be anything that"
#~ " makes sense: '>' or '>=' or "
#~ "'<' or '<=', or 'LIKE' which is"
#~ " an operator that works with strings"
#~ " that may contain wildcard characters "
#~ "'_' meaning 'match any one character'"
#~ " or '%' meaning 'match any zero "
#~ "or one or many characters'. These "
#~ "are legal statements which return all"
#~ " rows:"
#~ msgstr ""

#~ msgid ""
#~ "``SELECT size FROM modules WHERE name"
#~ " >= '';`` |br| ``SELECT size FROM "
#~ "modules WHERE name LIKE '%';``"
#~ msgstr ""

#~ msgid ""
#~ "The third variation is that IS "
#~ "[NOT] NULL is a special condition. "
#~ "Remembering that the NULL value can "
#~ "mean \"it is unknown what the "
#~ "value should be\", and supposing that"
#~ " in some row the size is NULL,"
#~ " then the condition \"size > 10\" "
#~ "is not certainly true and it is"
#~ " not certainly false, so it is "
#~ "evaluated as \"unknown\". Ordinarily the "
#~ "application of a WHERE clause filters"
#~ " out both false and unknown results."
#~ " So when searching for NULL, say "
#~ "IS NULL; when searching anything that"
#~ " is not NULL, say IS NOT NULL."
#~ " This statement will return all rows"
#~ " because (due to the definition) "
#~ "there are no NULLs in the name "
#~ "column:"
#~ msgstr ""

#~ msgid "``SELECT size FROM modules WHERE name IS NOT NULL;``"
#~ msgstr ""

#~ msgid ""
#~ "The fourth variation is that conditions"
#~ " can be combined with AND / OR,"
#~ " and negated with NOT."
#~ msgstr ""

#~ msgid ""
#~ "So this statement would return all "
#~ "rows (the first condition is false "
#~ "but the second condition is true, "
#~ "and OR means \"return true if "
#~ "either condition is true\"):"
#~ msgstr ""

#~ msgid ""
#~ "SELECT size\n"
#~ "FROM modules\n"
#~ "WHERE name = 'wombat' OR size IS NOT NULL;"
#~ msgstr ""

#~ msgid "**Selecting with a select list**"
#~ msgstr ""

#~ msgid "Yet again, here is a simple example of a SELECT statement:"
#~ msgstr ""

#~ msgid ""
#~ "The words between SELECT and FROM "
#~ "are the select list. In this case,"
#~ " the select list is just one "
#~ "word: size. Formally it means that "
#~ "the desire is to return the size"
#~ " values, and technically the name for"
#~ " picking a particular column is "
#~ "called \"projection\"."
#~ msgstr ""

#~ msgid "The first variation is that one can specify any column in any order:"
#~ msgstr ""

#~ msgid "``SELECT name, purpose, size FROM modules;``"
#~ msgstr ""

#~ msgid ""
#~ "The second variation is that one "
#~ "can specify an expression, it does "
#~ "not have to be a column name, "
#~ "it does not even have to include"
#~ " a column name. The common expression"
#~ " operators for numbers are the "
#~ "arithmetic operators ``+ - / *``; "
#~ "the common expression operator for "
#~ "strings is the concatenation operator "
#~ "||. For example this statement will "
#~ "return 8, 'XY':"
#~ msgstr ""

#~ msgid "``SELECT size * 2, 'X' || 'Y' FROM modules WHERE size = 4;``"
#~ msgstr ""

#~ msgid ""
#~ "The third variation is that one "
#~ "can add a clause [AS name] after"
#~ " every expression, so that in the "
#~ "return the column titles will make "
#~ "sense. This is especially important when"
#~ " a title might otherwise be ambiguous"
#~ " or meaningless. For example this "
#~ "statement will return 8, 'XY' as "
#~ "before"
#~ msgstr ""

#~ msgid ""
#~ "``SELECT size * 2 AS double_size, "
#~ "'X' || 'Y' AS concatenated_literals  "
#~ "FROM modules`` |br| |nbsp| |nbsp| "
#~ "``WHERE size = 4;``"
#~ msgstr ""

#~ msgid "but displayed as a table the result will look like"
#~ msgstr "Первые строки результата будут выглядеть следующим образом:"

#~ msgid ""
#~ "+----------------+------------------------+\n"
#~ "| double_size    | concatenated_literals  |\n"
#~ "+----------------+------------------------+\n"
#~ "|               8| XY                     |\n"
#~ "+----------------+------------------------+"
#~ msgstr ""

#~ msgid "**Selecting with a select list with asterisk**"
#~ msgstr ""

#~ msgid ""
#~ "Instead of listing columns in a "
#~ "select list, one can just say "
#~ "``'*'``. For example"
#~ msgstr ""

#~ msgid "``SELECT * FROM modules;``"
#~ msgstr ""

#~ msgid "This is the same thing as"
#~ msgstr ""

#~ msgid "``SELECT name, size, purpose FROM modules;``"
#~ msgstr ""

#~ msgid ""
#~ "Selecting with ``\"*\"``  saves time for"
#~ " the writer, but it is unclear "
#~ "to a reader who has not memorized"
#~ " what the column names are. Also "
#~ "it is unstable, because there is a"
#~ " way to change a table's definition"
#~ " (the ALTER statement, which is an"
#~ " advanced topic). Nevertheless, although it"
#~ " might be bad to use it for "
#~ "production, it is handy to use it"
#~ " for introduction, so we will use "
#~ "``\"*\"`` in several examples."
#~ msgstr ""

#~ msgid "**Select with subqueries**"
#~ msgstr ""

#~ msgid ""
#~ "Remember that we have a modules "
#~ "table and we have a submodules "
#~ "table. Suppose that we want to "
#~ "list the submodules that refer to "
#~ "modules for which the purpose is "
#~ "X. That is, this involves a search"
#~ " of one table using a value in"
#~ " another table. This can be done "
#~ "by enclosing \"(SELECT ...)\" within the"
#~ " WHERE clause. For example:"
#~ msgstr ""

#~ msgid ""
#~ "SELECT name FROM submodules\n"
#~ "WHERE module_name =\n"
#~ "    (SELECT name FROM modules WHERE purpose LIKE '%Database%');"
#~ msgstr ""

#~ msgid ""
#~ "Subqueries are also useful in the "
#~ "select list, when one wishes to "
#~ "combine information from more than one"
#~ " table. For example this statement "
#~ "will display submodules rows but will"
#~ " include values that come from the"
#~ " modules table:"
#~ msgstr ""

#~ msgid ""
#~ "SELECT name AS submodules_name,\n"
#~ "    (SELECT purpose FROM modules\n"
#~ "     WHERE modules.name = submodules.module_name)\n"
#~ "     AS modules_purpose,\n"
#~ "    purpose AS submodules_purpose\n"
#~ "FROM submodules;"
#~ msgstr ""

#~ msgid ""
#~ "Whoa. What are \"modules.name\" and "
#~ "\"submodules.name\"? Whenever you see \"x "
#~ ". y\" you are looking at a "
#~ "\"qualified column name\", and the first"
#~ " part is a table identifier, the "
#~ "second part is a column identifier. "
#~ "It is always legal to use "
#~ "qualified column names, but until now"
#~ " it has not been necessary. Now "
#~ "it is necessary, or at least it"
#~ " is a good idea, because both "
#~ "tables have a column named \"name\"."
#~ msgstr ""

#~ msgid "The result will look like this:"
#~ msgstr "Теперь вывод на экране выглядит следующим образом:"

#~ msgid ""
#~ "+-------------------+------------------------+--------------------+\n"
#~ "| submodules_name   | modules_purpose        | submodules_purpose |\n"
#~ "+-------------------+------------------------+--------------------+\n"
#~ "| space             | Database Management    | insert etc.        |\n"
#~ "+-------------------+------------------------+--------------------+"
#~ msgstr ""

#~ msgid ""
#~ "Perhaps you have read somewhere that "
#~ "SQL stands for \"Structured Query "
#~ "Language\". That is not true any "
#~ "more. But it is true that the "
#~ "query syntax allows for a structural "
#~ "component, namely the subquery, and that"
#~ " was the original idea. However, "
#~ "there is a different way to "
#~ "combine tables -- with joins instead "
#~ "of subqueries."
#~ msgstr ""

#~ msgid "**Select with Cartesian join**"
#~ msgstr ""

#~ msgid ""
#~ "Until now we have only used \"FROM"
#~ " modules\" or \"FROM submodules\" in "
#~ "our SELECT statements. What if we "
#~ "used more than one table in the"
#~ " FROM clause? For example"
#~ msgstr ""

#~ msgid ""
#~ "``SELECT * FROM modules, submodules;`` "
#~ "|br| or ``SELECT * FROM modules "
#~ "JOIN submodules;``"
#~ msgstr ""

#~ msgid ""
#~ "That is legal. Usually it is not"
#~ " what you want, but it is a "
#~ "learning aid. The result will be:"
#~ msgstr ""

#~ msgid ""
#~ "{ columns from modules table }"
#~ "         { columns from submodules table"
#~ " }\n"
#~ "+--------+------+---------------------+-------+-------------+-------+-------------+"
#~ "\n"
#~ "| name   | size | purpose"
#~ "             | name  | module_name | "
#~ "size  | purpose     |\n"
#~ "+--------+------+---------------------+-------+-------------+-------+-------------+"
#~ "\n"
#~ "| box    | 1432 | Database "
#~ "Management | space | box         | "
#~ "10000 | insert etc. |\n"
#~ "| clock  | 188  | Seconds"
#~ "             | space | box         | "
#~ "10000 | insert etc. |\n"
#~ "| crypto |   4  | Cryptography"
#~ "        | space | box         | 10000"
#~ " | insert etc. |\n"
#~ "+--------+------+---------------------+-------+-------------+-------+-------------+"
#~ msgstr ""

#~ msgid ""
#~ "It is not an error. The meaning"
#~ " of this type of join is "
#~ "\"combine every row in table-1 with "
#~ "every row in table-2\". It did not"
#~ " specify what the relationship should "
#~ "be, so the result has everything, "
#~ "even when the submodule has nothing "
#~ "to do with the module."
#~ msgstr ""

#~ msgid ""
#~ "It is handy to look at the "
#~ "above result, called a \"Cartesian "
#~ "join\" result, to see what we "
#~ "really want. Probably for this case "
#~ "the row that actually makes sense "
#~ "is the one where the modules.name "
#~ "= submodules.module_name, and we should "
#~ "make that clear in both the select"
#~ " list and the WHERE clause, thus:"
#~ msgstr ""

#~ msgid ""
#~ "SELECT modules.name AS modules_name,\n"
#~ "       modules.size AS modules_size,\n"
#~ "       modules.purpose AS modules_purpose,\n"
#~ "       submodules.name,\n"
#~ "       module_name,\n"
#~ "       submodules.size,\n"
#~ "       submodules.purpose\n"
#~ "FROM modules, submodules\n"
#~ "WHERE modules.name = submodules.module_name;"
#~ msgstr ""

#~ msgid "The result will be:"
#~ msgstr ""

#~ msgid ""
#~ "+----------+-----------+------------+--------+---------+-------+-------------+"
#~ "\n"
#~ "| modules_ |  modules_ | modules_   "
#~ "| name   | module_ | size  | "
#~ "purpose     |\n"
#~ "| name     |  size     | purpose    "
#~ "|        | name    |       |             "
#~ "|\n"
#~ "+----------+-----------+--------- "
#~ "--+--------+---------+-------+-------------|\n"
#~ "| box      | 1432      | Database   "
#~ "| space  | box     | 10000 | "
#~ "insert etc. |\n"
#~ "|          |           | Management |"
#~ "        |         |       |             |\n"
#~ "+----------+-----------+------------+--------+---------+-------+-------------|"
#~ msgstr ""

#~ msgid ""
#~ "In other words, you can specify a"
#~ " Cartesian join in the FROM clause,"
#~ " then you can filter out the "
#~ "irrelevant rows in the WHERE clause, "
#~ "and then you can rename columns in"
#~ " the select list. This is fine, "
#~ "and every SQL DBMS supports this. "
#~ "But it is worrisome that the "
#~ "number of rows in a Cartesian join"
#~ " is always (number of rows in "
#~ "first table multiplied by number of "
#~ "rows in second table), which means "
#~ "that conceptually you are often "
#~ "filtering in a large set of rows."
#~ msgstr ""

#~ msgid ""
#~ "It is good to start by looking "
#~ "at Cartesian joins because they show "
#~ "the concept. Many people, though, prefer"
#~ " to use different syntaxes for joins"
#~ " because they look better or clearer."
#~ " We will look at those alternatives"
#~ " now."
#~ msgstr ""

#~ msgid "**Select with join with ON clause**"
#~ msgstr ""

#~ msgid ""
#~ "The ON clause would have the same"
#~ " comparisons as the WHERE clause that"
#~ " we illustrated for the previous "
#~ "section, but by using different syntax"
#~ " we would be making it clear "
#~ "\"this is for the sake of the "
#~ "join\". Readers can see at a "
#~ "glance that it is, in concept at"
#~ " least, an initial step before the"
#~ " result rows are filtered. For "
#~ "example this"
#~ msgstr ""

#~ msgid ""
#~ "``SELECT * FROM modules JOIN "
#~ "submodules`` |br| |nbsp| |nbsp| ``ON "
#~ "(modules.name = submodules.module_name);``"
#~ msgstr ""

#~ msgid "is the same as"
#~ msgstr ""

#~ msgid ""
#~ "``SELECT * FROM modules, submodules`` "
#~ "|br| |nbsp| |nbsp| ``WHERE modules.name "
#~ "= submodules.module_name;``"
#~ msgstr ""

#~ msgid "**Select with join with USING clause**"
#~ msgstr ""

#~ msgid ""
#~ "The USING clause would take advantage"
#~ " of names that are held in "
#~ "common between the two tables, with "
#~ "the assumption that the intent is "
#~ "to match those columns with '=' "
#~ "comparisons. For example,"
#~ msgstr ""

#~ msgid "``SELECT * FROM modules JOIN submodules USING (name);``"
#~ msgstr ""

#~ msgid "has the same effect as"
#~ msgstr ""

#~ msgid ""
#~ "``SELECT * FROM modules JOIN submodules"
#~ " WHERE modules.name = submodules.name;``"
#~ msgstr ""

#~ msgid ""
#~ "If we had created our table with"
#~ " a plan in advance to use USING"
#~ " clauses, that would save time. But"
#~ " we did not. So, although the "
#~ "above example \"works\", the results "
#~ "will not be sensible."
#~ msgstr ""

#~ msgid "**Select with natural join**"
#~ msgstr ""

#~ msgid ""
#~ "A natural join would take advantage "
#~ "of names that are held in common"
#~ " between the two tables, and would"
#~ " do the filtering automatically based "
#~ "on that knowledge, and throw away "
#~ "duplicate columns."
#~ msgstr ""

#~ msgid ""
#~ "If we had created our table with"
#~ " a plan in advance to use "
#~ "natural joins, that would be very "
#~ "handy. But we did not. So, "
#~ "although the following example \"works\", "
#~ "the results won't be sensible."
#~ msgstr ""

#~ msgid "``SELECT * FROM modules NATURAL JOIN submodules;``"
#~ msgstr ""

#~ msgid ""
#~ "Result: nothing, because modules.name does "
#~ "not match submodules.name, and so on "
#~ "And even if there had been a "
#~ "result, it would only have included "
#~ "four columns: name, module_name, size, "
#~ "purpose."
#~ msgstr ""

#~ msgid "**Select with left join**"
#~ msgstr ""

#~ msgid ""
#~ "Now what if we want to join "
#~ "modules to submodules, but we want "
#~ "to be sure that we get all "
#~ "the modules? In other words, we "
#~ "want to get modules even if the"
#~ " condition submodules.module_name = modules.name"
#~ " is not true, because the module "
#~ "has no submodules."
#~ msgstr ""

#~ msgid ""
#~ "When that is what we want, the "
#~ "type of join is an \"outer join\""
#~ " (as opposed to the type we "
#~ "have used so far which is an "
#~ "\"inner join\"). Specifically we will "
#~ "use LEFT [OUTER] JOIN because our "
#~ "main table, modules, is on the "
#~ "left. For example:"
#~ msgstr ""

#~ msgid ""
#~ "SELECT *\n"
#~ "FROM modules LEFT JOIN submodules\n"
#~ "ON modules.name = submodules.module_name;"
#~ msgstr ""

#~ msgid "which returns:"
#~ msgstr ""

#~ msgid ""
#~ "{ columns from modules table }"
#~ "         { columns from submodules table"
#~ " }\n"
#~ "+--------+------+---------------------+-------+-------------+-------+-------------+"
#~ "\n"
#~ "| name   | size | purpose"
#~ "             | name  | module_name | "
#~ "size  | purpose     |\n"
#~ "+--------+------+---------------------+-------+-------------+-------+-------------+"
#~ "\n"
#~ "| box    | 1432 | Database "
#~ "Management | space | box         | "
#~ "10000 | insert etc. |\n"
#~ "| clock  | 188  | Seconds"
#~ "             | NULL  | NULL        | "
#~ "NULL  | NULL        |\n"
#~ "| crypto |   4  | Cryptography"
#~ "        | NULL  | NULL        | NULL"
#~ "  | NULL        |\n"
#~ "+--------+------+---------------------+-------+-------------+-------+-------------+"
#~ msgstr ""

#~ msgid ""
#~ "Thus, for the submodules of the "
#~ "clock module and the submodules of "
#~ "the crypto module -- which do not"
#~ " exist -- there are NULLs in "
#~ "every column."
#~ msgstr ""

#~ msgid "**Select with functions**"
#~ msgstr ""

#~ msgid ""
#~ "A function can take any expression, "
#~ "including an expression that contains "
#~ "another function, and return a scalar"
#~ " value. There are many such "
#~ "functions. We will just describe one,"
#~ " SUBSTR, which returns a substring of"
#~ " a string."
#~ msgstr ""

#~ msgid "Format: :samp:`SUBSTR({input-string}, {start-with} [, {length}])`"
#~ msgstr ""

#~ msgid ""
#~ "Description: SUBSTR takes input-string, "
#~ "eliminates any characters before start-"
#~ "with, eliminates any characters after "
#~ "(start-with plus length), and returns "
#~ "the result."
#~ msgstr ""

#~ msgid "Example: ``SUBSTR('abcdef', 2, 3)`` returns 'bcd'."
#~ msgstr ""

#~ msgid "Select with aggregation, GROUP BY, and HAVING"
#~ msgstr ""

#~ msgid "Remember that our modules table looks like this:"
#~ msgstr "Результат последнего запроса выглядит следующим образом:"

#~ msgid ""
#~ "Suppose that we do not want to "
#~ "know all the individual size values, "
#~ "we just want to know about their"
#~ " aggregation, that is, take the "
#~ "attributes of the collection. SQL allows"
#~ " five aggregation functions: AVG (average),"
#~ " SUM, MIN (minimum), MAX (maximum), "
#~ "and COUNT. For example"
#~ msgstr ""

#~ msgid ""
#~ "``SELECT AVG(size), SUM(size), MIN(size), "
#~ "MAX(size), COUNT(size) FROM modules;``"
#~ msgstr ""

#~ msgid ""
#~ "+--------------+-----------+-----------+-----------+-------------+\n"
#~ "| AVG(size)    | SUM(size) | MIN(size) | MAX(size) | COUNT(size) |\n"
#~ "+--------------+-----------+-----------+-----------+-------------|\n"
#~ "| 5.413333E+02 | 1624      |         4 |      1432 |           3 |\n"
#~ "+--------------+-----------+-----------+-----------+-------------+"
#~ msgstr ""

#~ msgid ""
#~ "Suppose that we want aggregations, but"
#~ " aggregations of rows that have some"
#~ " common characteristic. Supposing further, "
#~ "we want to divide the rows into"
#~ " two groups, the ones whose names "
#~ "begin with 'b' and the ones whose"
#~ " names begin with 'c'. This can "
#~ "be done by adding a clause [GROUP"
#~ " BY expression]. For example,"
#~ msgstr ""

#~ msgid ""
#~ "SELECT SUBSTR(name, 1, 1), AVG(size), "
#~ "SUM(size), MIN(size), MAX(size), COUNT(size)\n"
#~ "FROM modules\n"
#~ "GROUP BY SUBSTR(name, 1, 1);"
#~ msgstr ""

#~ msgid ""
#~ "+--------------------+--------------+-----------+-----------+-----------+-------------+"
#~ "\n"
#~ "| SUBSTR(name, 1, 1) | AVG(size)    "
#~ "| SUM(size) | MIN(size) | MAX(size) "
#~ "| CoUNT(size) |\n"
#~ "+--------------------+--------------+-----------+-----------+-----------|-------------|"
#~ "\n"
#~ "| b                  |         1432 |      "
#~ "1432 |      1432 |      1432 |"
#~ "           1 |\n"
#~ "| c                  |           96 |"
#~ "       192 |         4 |       188 |"
#~ "           2 |\n"
#~ "+--------------------+--------------+-----------+-----------+-----------|-------------+"
#~ msgstr ""

#~ msgid "**Select with common table expression**"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to define a "
#~ "temporary (viewed) table within a "
#~ "statement, usually within a SELECT "
#~ "statement, using a WITH clause. For "
#~ "example:"
#~ msgstr ""

#~ msgid "``WITH tmp_table AS (SELECT x1 FROM t1) SELECT * FROM tmp_table;``"
#~ msgstr ""

#~ msgid "**Select with order, limit, and offset clauses**"
#~ msgstr ""

#~ msgid ""
#~ "Every time we have searched in the"
#~ " modules table, the rows have come"
#~ " out in alphabetical order by name:"
#~ " 'box', then 'clock', then 'crypto'. "
#~ "However, if we want to be sure "
#~ "about the order, or if we want "
#~ "a different order, we will have to"
#~ " be explicit and add a clause: "
#~ "``ORDER BY column-name [ASC|DESC]``. "
#~ "(ASC stands for ASCending, DESC stands"
#~ " for DESCending.) For example:"
#~ msgstr ""

#~ msgid "``SELECT * FROM modules ORDER BY name DESC;``"
#~ msgstr ""

#~ msgid ""
#~ "The result will be the usual rows,"
#~ " in descending alphabetical order: 'crypto'"
#~ " then 'clock' then 'box'."
#~ msgstr ""

#~ msgid ""
#~ "After the ORDER BY clause we can"
#~ " add a clause LIMIT n, where n"
#~ " is the maximum number of rows "
#~ "that we want. For example:"
#~ msgstr ""

#~ msgid "``SELECT * FROM modules ORDER BY name DESC LIMIT 2;``"
#~ msgstr ""

#~ msgid "The result will be the first two rows, 'crypto' and 'clock'."
#~ msgstr ""

#~ msgid ""
#~ "After the ORDER BY clause and the"
#~ " LIMIT clause we can add a "
#~ "clause OFFSET n, where n is the"
#~ " row to start with. The first "
#~ "offset is 0. For example:"
#~ msgstr ""

#~ msgid "``SELECT * FROM modules ORDER BY name DESC LIMIT 2 OFFSET 2;``"
#~ msgstr ""

#~ msgid "The result will be the third row, 'box'."
#~ msgstr ""

#~ msgid "**Views**"
#~ msgstr ""

#~ msgid ""
#~ "A view is a canned SELECT. If "
#~ "you have a complex SELECT that you"
#~ " want to run frequently, create a "
#~ "view and then do a simple SELECT"
#~ " on the view. For example:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE VIEW v AS SELECT size, (size *5) AS size_times_5\n"
#~ "FROM modules\n"
#~ "GROUP BY size, name\n"
#~ "ORDER BY size_times_5;\n"
#~ "SELECT * FROM v;"
#~ msgstr ""

#~ msgid "**Transactions**"
#~ msgstr "функция"

#~ msgid ""
#~ "Tarantool has a \"Write Ahead Log\" "
#~ "(WAL). Effects of data-change statements"
#~ " are logged before they are "
#~ "permanently stored on disk. This is "
#~ "a reason that, although entire databases"
#~ " can be stored in temporary memory,"
#~ " they are not vulnerable in case "
#~ "of power failure."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool supports commits and rollbacks. "
#~ "In effect, asking for a commit "
#~ "means asking for all the recent "
#~ "data-change statements, since a transaction"
#~ " began, to become permanent. In "
#~ "effect, asking for a rollback means "
#~ "asking for all the recent data-"
#~ "change statements, since a transaction "
#~ "began, to be cancelled."
#~ msgstr ""

#~ msgid "For example, consider these statements:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE things (remark STRING, PRIMARY KEY (remark));\n"
#~ "START TRANSACTION;\n"
#~ "INSERT INTO things VALUES ('A');\n"
#~ "COMMIT;\n"
#~ "START TRANSACTION;\n"
#~ "INSERT INTO things VALUES ('B');\n"
#~ "ROLLBACK;\n"
#~ "SELECT * FROM things;"
#~ msgstr ""

#~ msgid ""
#~ "The result will be: one row, "
#~ "containing 'A'. The ROLLBACK cancelled "
#~ "the second INSERT statement, but did "
#~ "not cancel the first one, because "
#~ "it had already been committed."
#~ msgstr ""

#~ msgid "Ordinarily every statement is automatically committed."
#~ msgstr ""

#~ msgid ""
#~ "After START TRANSACTION, statements are "
#~ "not automatically committed -- Tarantool "
#~ "considers that a transaction is now "
#~ "\"active\", until the transaction ends "
#~ "with a COMMIT statement or a "
#~ "ROLLBACK statement. While a transaction "
#~ "is active, all statements are legal "
#~ "except another START TRANSACTION."
#~ msgstr ""

#~ msgid "**Implementing Tarantool's SQL On Top of NoSQL**"
#~ msgstr ""

#~ msgid ""
#~ "Tarantool's SQL data is the same "
#~ "as Tarantool's NoSQL data. When you "
#~ "create a table or an index with"
#~ " SQL, you are creating a space "
#~ "or an index in NoSQL. For example:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE things (remark STRING, PRIMARY KEY (remark));\n"
#~ "INSERT INTO things VALUES ('X');"
#~ msgstr ""

#~ msgid "is somewhat similar to"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.space.create('THINGS',\n"
#~ "{\n"
#~ "    format = {\n"
#~ "              [1] = {[\"name\"] = "
#~ "\"REMARK\", [\"type\"] = \"string\"}\n"
#~ "              }\n"
#~ "})\n"
#~ "box.space.THINGS:create_index('pk_unnamed_THINGS_1',{unique=true,parts={1,'string'}})"
#~ "\n"
#~ "box.space.THINGS:insert{'X'}"
#~ msgstr ""

#~ msgid ""
#~ "Therefore you can take advantage of "
#~ "Tarantool's NoSQL features even though "
#~ "your primary language is SQL. Here "
#~ "are some possibilities."
#~ msgstr ""

#~ msgid ""
#~ "(1) NoSQL applications written in one"
#~ " of the connector languages may be"
#~ " slightly faster than SQL applications "
#~ "because SQL statements may require more"
#~ " parsing and may be translated to "
#~ "NoSQL requests."
#~ msgstr ""

#~ msgid ""
#~ "(2) You can write stored procedures "
#~ "in Lua, combining Lua loop-control "
#~ "and Lua library-access statements with"
#~ " SQL statements. These routines are "
#~ "executed on the server, which is "
#~ "the principal advantage of pure-SQL "
#~ "stored procedures."
#~ msgstr ""

#~ msgid ""
#~ "(3) There are some options that "
#~ "are implemented in NoSQL that are "
#~ "not (yet) implemented in SQL. For "
#~ "example you can use NoSQL to "
#~ "change an index option, and to "
#~ "deny access to users named 'guest'."
#~ msgstr ""

#~ msgid ""
#~ "(4) System spaces such as _space "
#~ "and _index can be accessed with "
#~ "SQL SELECT statements. This is not "
#~ "quite the same as an information_schema,"
#~ " but it does mean that you can"
#~ " use SQL to access the database's "
#~ "metadata catalog."
#~ msgstr ""

#~ msgid ""
#~ "Fields in NoSQL spaces can be "
#~ "accessed with SQL if and only if"
#~ " they are scalar and are defined "
#~ "in format clauses. Indexes of NoSQL "
#~ "spaces will be used with SQL if"
#~ " and only if they are TREE "
#~ "indexes."
#~ msgstr ""

#~ msgid "**Relational Databases**"
#~ msgstr ""

#~ msgid ""
#~ "Edgar F. Codd, the person most "
#~ "responsible for researching and explaining "
#~ "relational database concepts, listed the "
#~ "main criteria as (`Codd's 12 rules "
#~ "<https://en.wikipedia.org/wiki/Codd's_12_rules>`_)."
#~ msgstr ""

#~ msgid ""
#~ "Although we do not advertise Tarantool"
#~ " as \"relational\", we claim that "
#~ "Tarantool complies with these rules, "
#~ "with the following caveats and "
#~ "exceptions ..."
#~ msgstr ""

#~ msgid ""
#~ "The rules state that all data must"
#~ " be viewable as relations. A "
#~ "Tarantool SQL table is a relation. "
#~ "However, it is possible to have "
#~ "duplicate values in SQL tables and "
#~ "it is possible to have an implicit"
#~ " ordering. Those characteristics are not"
#~ " allowed for true relations."
#~ msgstr ""

#~ msgid ""
#~ "The rules state that there must be"
#~ " a dynamic online catalog. Tarantool "
#~ "has one but some metadata is "
#~ "missing from it."
#~ msgstr ""

#~ msgid ""
#~ "The rules state that the data "
#~ "language must support authorization. "
#~ "Tarantool's SQL does not. Authorization "
#~ "occurs via NoSQL requests."
#~ msgstr ""

#~ msgid ""
#~ "The rules require that data must "
#~ "be physically independent (from underlying "
#~ "storage changes) and logically independent "
#~ "(from application program changes). So "
#~ "far we do not have enough "
#~ "experience to make this guarantee."
#~ msgstr ""

#~ msgid ""
#~ "The rules require certain types of "
#~ "updatable views. Tarantool's views are "
#~ "not updatable."
#~ msgstr ""

#~ msgid ""
#~ "The rules state that it should be"
#~ " impossible to use a low-level "
#~ "language to bypass integrity as defined"
#~ " in the relational-level language. In"
#~ " our case, this is not true, "
#~ "for example one can execute a "
#~ "request with Tarantool's NoSQL to "
#~ "violate a foreign-key constraint that"
#~ " was defined with Tarantool's SQL."
#~ msgstr ""

#~ msgid "SQL user guide"
#~ msgstr "новый UID пользователя."

#~ msgid ""
#~ "The User Guide describes how users "
#~ "can start up with SQL with "
#~ "Tarantool, and necessary concepts."
#~ msgstr ""

#~ msgid "Getting Started"
#~ msgstr ""

#~ msgid ""
#~ "The explanations for installing and "
#~ "starting the Tarantool server are in "
#~ "earlier chapters of the Tarantool "
#~ "manual.."
#~ msgstr ""

#~ msgid ""
#~ "To get started specifically with the "
#~ "SQL features, using Tarantool as a "
#~ "client, execute these requests:"
#~ msgstr ""

#~ msgid ""
#~ "box.cfg{}\n"
#~ "box.execute([[VALUES ('hello');]])"
#~ msgstr ""

#~ msgid "The bottom of the screen should now look like this:"
#~ msgstr "Теперь вывод на экране выглядит следующим образом:"

#~ msgid ""
#~ "tarantool> box.execute([[VALUES ('hello');]])\n"
#~ "---\n"
#~ "- metadata:\n"
#~ "  - name: column1\n"
#~ "    type: string\n"
#~ "  rows:\n"
#~ "  - ['hello']\n"
#~ "..."
#~ msgstr ""

#~ msgid "That's an SQL statement done with Tarantool."
#~ msgstr ""

#~ msgid ""
#~ "Now you are ready to execute any"
#~ " SQL statements via the connection. "
#~ "For example"
#~ msgstr ""

#~ msgid ""
#~ "box.execute([[CREATE TABLE things (id INTEGER PRIMARY key,\n"
#~ "                                   remark STRING);]])\n"
#~ "box.execute([[INSERT INTO things VALUES (55, 'Hello SQL world!');]])\n"
#~ "box.execute([[SELECT * FROM things WHERE id > 0;]])"
#~ msgstr ""

#~ msgid "And you will see the results of the SQL query."
#~ msgstr ""

#~ msgid ""
#~ "For the rest of this chapter, the"
#~ " :ref:`box.execute([[...]]) <box-sql>` enclosure"
#~ " will not be shown. Examples will "
#~ "simply say what a piece of syntax"
#~ " looks like, such as ``SELECT "
#~ "'hello';`` |br| and users should know"
#~ " that must be entered as |br| "
#~ "``box.execute([[SELECT 'hello';]])`` |br| It "
#~ "is also legal to enclose SQL "
#~ "statements inside single or double quote"
#~ " marks instead of [[ ... ]]."
#~ msgstr ""

#~ msgid "Supported syntax"
#~ msgstr "Поддерживаемые опции:"

#~ msgid ""
#~ "Keywords, for example CREATE or INSERT"
#~ " or VALUES, may be entered in "
#~ "either upper case or lower case."
#~ msgstr ""

#~ msgid ""
#~ "Literal values, for example ``55`` or"
#~ " ``'Hello SQL world!'``, should be "
#~ "entered without single quote marks if"
#~ " they are numeric, and should be "
#~ "entered with single quote marks if "
#~ "they are strings."
#~ msgstr ""

#~ msgid ""
#~ "Object names, for example table1 or "
#~ "column1, should usually be entered "
#~ "without double quote marks and are "
#~ "subject to some restrictions. They may"
#~ " be enclosed in double quote marks"
#~ " and in that case they are "
#~ "subject to fewer restrictions."
#~ msgstr ""

#~ msgid ""
#~ "Almost all keywords are :ref:`reserved "
#~ "<sql_reserved_words>`, which means that they"
#~ " cannot be used as object names "
#~ "unless they are enclosed in double "
#~ "quote marks."
#~ msgstr ""

#~ msgid ""
#~ "Comments may be between ``/*`` and "
#~ "``*/`` (bracketed) or between ``--`` and"
#~ " the end of a line (simple)."
#~ msgstr ""

#~ msgid ""
#~ "INSERT /* This is a bracketed comment */ INTO t VALUES (5);\n"
#~ "INSERT INTO t VALUES (5); -- this is a simple comment"
#~ msgstr ""

#~ msgid ""
#~ "Expressions, for example ``a + b`` "
#~ "OR ``a > b AND NOT a <= "
#~ "b``, may have arithmetic operators ``+"
#~ " - / *``, may have comparison "
#~ "operators ``= > < <= >= LIKE``,"
#~ " and may be combined with ``AND "
#~ "OR NOT``, with optional parentheses."
#~ msgstr ""

#~ msgid ""
#~ "SQL statements should end with ; "
#~ "(semicolon); this is not mandatory but"
#~ " it is recommended."
#~ msgstr ""

#~ msgid "In alphabetical order, the following statements are legal."
#~ msgstr ""

#~ msgid ""
#~ "|nbsp| :ref:`ALTER TABLE table-name "
#~ "[RENAME or ADD CONSTRAINT or DROP "
#~ "CONSTRAINT clauses]; <sql_alter_table>` |br| "
#~ "|nbsp| ANALYZE [table-name]; -- "
#~ "temporarily disabled in current version "
#~ "|br| |nbsp| :ref:`COMMIT; <sql_commit>` |br|"
#~ " |nbsp| :ref:`CREATE [UNIQUE] INDEX [IF "
#~ "NOT EXISTS] index-name <sql_create_index>` "
#~ "|br| |nbsp| |nbsp| |nbsp| |nbsp| "
#~ ":ref:`ON table-name (column-name [, "
#~ "column-name ...]); <sql_create_index>` |br|"
#~ " |nbsp| :ref:`CREATE TABLE [IF NOT "
#~ "EXISTS] table-name <sql_create_table>` |br|"
#~ " |nbsp| |nbsp| |nbsp| |nbsp| :ref"
#~ ":`(column-or-constraint-definition "
#~ "<sql_create_table>` |br| |nbsp| |nbsp| |nbsp|"
#~ " |nbsp| :ref:`[, column-or-constraint-"
#~ "definition ...]) <sql_create_table>` |br| "
#~ "|nbsp| |nbsp| |nbsp| |nbsp| :ref:`[WITH "
#~ "ENGINE = engine-name]; <sql_create_table>` "
#~ "|br| |nbsp| :ref:`CREATE TRIGGER [IF NOT"
#~ " EXISTS] trigger-name <sql_create_trigger>` "
#~ "|br| |nbsp| |nbsp| |nbsp| |nbsp| "
#~ ":ref:`BEFORE|AFTER INSERT|UPDATE|DELETE ON table-"
#~ "name <sql_create_trigger>` |br| |nbsp| |nbsp|"
#~ " |nbsp| |nbsp| :ref:`FOR EACH ROW "
#~ "<sql_create_trigger>` |br| |nbsp| |nbsp| "
#~ "|nbsp| |nbsp| :ref:`BEGIN dml-statement "
#~ "[, dml-statement ...] END; "
#~ "<sql_create_trigger>` |br| |nbsp| :ref:`CREATE "
#~ "VIEW [IF NOT EXISTS] view-name "
#~ "<sql_create_view>`  |br| |nbsp| |nbsp| |nbsp|"
#~ " |nbsp| :ref:`[(column-name [, column-"
#~ "name ...])] <sql_create_view>`  |br| |nbsp|"
#~ " |nbsp| |nbsp| |nbsp| :ref:`AS select-"
#~ "statement | values-statement; "
#~ "<sql_create_view>`  |br| |nbsp| :ref:`DROP "
#~ "INDEX [IF EXISTS] index-name ON "
#~ "table-name; <sql_drop_index>`  |br| |nbsp| "
#~ ":ref:`DROP TABLE [IF EXISTS] table-name;"
#~ " <sql_drop_table>`  |br| |nbsp| :ref:`DROP "
#~ "TRIGGER [IF EXISTS] trigger-name; "
#~ "<sql_drop_trigger>` |br| |nbsp| :ref:`DROP "
#~ "VIEW [IF EXISTS] view-name; "
#~ "<sql_drop_view>` |br| |nbsp| :ref:`EXPLAIN "
#~ "explainable-statement; <sql_explain>` |br| |nbsp|"
#~ " :ref:`INSERT INTO table-name <sql_insert>`"
#~ " |br| |nbsp| |nbsp| |nbsp| |nbsp| "
#~ ":ref:`[(column-name [, column-name "
#~ "...])] <sql_insert>` |br| |nbsp| |nbsp| "
#~ "|nbsp| |nbsp| :ref:`values-statement | "
#~ "select-statement; <sql_insert>` |br| |nbsp| "
#~ ":ref:`PRAGMA pragma-name[(value)]; <sql_pragma>` "
#~ "|br| |nbsp| :ref:`RELEASE SAVEPOINT "
#~ "savepoint-name; <sql_release_savepoint>` |br| "
#~ "|nbsp| :ref:`REPLACE INTO table-name "
#~ "VALUES (expression [, expression ...]); "
#~ "<sql_replace>` |br| |nbsp| :ref:`ROLLBACK [TO"
#~ " [SAVEPOINT] savepoint-name]; <sql_rollback>` "
#~ "|br| |nbsp| :ref:`SAVEPOINT savepoint-name;"
#~ " <sql_savepoint>` |br| |nbsp| :ref:`SELECT "
#~ "[DISTINCT|ALL] expression [, expression ...]"
#~ " <sql_select>` |br| |nbsp| |nbsp| |nbsp|"
#~ " |nbsp| :ref:`FROM table-name | "
#~ "joined-table-names [AS alias]  "
#~ "<sql_select>` |br| |nbsp| |nbsp| |nbsp| "
#~ "|nbsp| :ref:`[WHERE expression] <sql_select>` "
#~ "|br| |nbsp| |nbsp| |nbsp| |nbsp| "
#~ ":ref:`[GROUP BY expression [, expression "
#~ "...]] <sql_group_by>` |br| |nbsp| |nbsp| "
#~ "|nbsp| |nbsp| :ref:`[HAVING expression] "
#~ "<sql_having>` |br| |nbsp| |nbsp| |nbsp| "
#~ "|nbsp| :ref:`[ORDER BY expression] "
#~ "<sql_order_by>` |br| |nbsp| |nbsp| |nbsp| "
#~ "|nbsp| :ref:`LIMIT expression [OFFSET "
#~ "expression]]; <sql_limit>` |br| |nbsp| "
#~ ":ref:`START TRANSACTION; <sql_start_transaction>` "
#~ "|br| |nbsp| :ref:`TRUNCATE TABLE table-"
#~ "name; <sql_truncate>` |br| |nbsp| :ref:`UPDATE"
#~ " table-name <sql_update>` |br| |nbsp| "
#~ "|nbsp| |nbsp| |nbsp| :ref:`SET column-"
#~ "name=expression [,column-name=expression...] "
#~ "<sql_update>` |br| |nbsp| |nbsp| |nbsp| "
#~ "|nbsp| :ref:`[WHERE expression]; <sql_update>` "
#~ "|br| |nbsp| :ref:`VALUES (expression [, "
#~ "expression ...]; <sql_values>` |br| |nbsp| "
#~ ":ref:`WITH [RECURSIVE] common-table-"
#~ "expression; <sql_with>`"
#~ msgstr ""

#~ msgid "Concepts"
#~ msgstr ""

#~ msgid ""
#~ "In an earlier section of this "
#~ "documentation, we discussed: |br| What "
#~ "are: relational databases, tables, views, "
#~ "rows, and columns? |br| What are: "
#~ "transactions, write-ahead logs, commits "
#~ "and rollbacks? |br| What are: security"
#~ " considerations? |br| How do we: add,"
#~ " delete, or update rows in tables?"
#~ " |br| How do we: work inside "
#~ "transactions with commits and/or rollbacks?"
#~ " |br| How do we: select, join, "
#~ "filter, group, and sort rows?"
#~ msgstr ""

#~ msgid ""
#~ "Tarantool has a \"schema\". A schema "
#~ "is a container for all database "
#~ "objects. A schema may be called a"
#~ " \"database\" in other DBMS implementations"
#~ msgstr ""

#~ msgid ""
#~ "Tarantool allows four types of "
#~ "\"database objects\" to be created "
#~ "within the schema: tables, triggers, "
#~ "indexes, and constraints. Within tables, "
#~ "there are \"columns\"."
#~ msgstr ""

#~ msgid ""
#~ "Almost all Tarantool SQL statements "
#~ "begin with a reserved-word \"verb\" "
#~ "such as INSERT, and end optionally "
#~ "with a semicolon. For example: ``INSERT"
#~ " INTO t VALUES (1);``"
#~ msgstr ""

#~ msgid ""
#~ "A Tarantool SQL database and a "
#~ "Tarantool NoSQL database are the same"
#~ " thing. However, some operations are "
#~ "only possible with SQL, and others "
#~ "are only possible with NoSQL. Mixing "
#~ "SQL statements with NoSQL requests is"
#~ " allowed."
#~ msgstr ""

#~ msgid "Tokens"
#~ msgstr ""

#~ msgid ""
#~ "The token is the minimum SQL-"
#~ "syntax unit that Tarantool understands. "
#~ "These are the types of tokens:"
#~ msgstr ""

#~ msgid ""
#~ "Keywords -- official words in the "
#~ "language, for example ``SELECT`` |br| "
#~ "Literals -- constants for numbers or "
#~ "strings, for example ``15.7`` or "
#~ "``'Taranto'`` |br| Identifiers -- for "
#~ "example column55 or table_of_accounts |br| "
#~ "Operators (strictly speaking \"non-alphabetic"
#~ " operators\") -- for example ``* /"
#~ " + - ( ) , ; < = "
#~ ">=``"
#~ msgstr ""

#~ msgid ""
#~ "Tokens can be separated from each "
#~ "other by one or more separators: "
#~ "|br| * White space characters: tab "
#~ "(U+0009), line feed (U+000A), vertical "
#~ "tab (U+000B), form feed (U+000C), "
#~ "carriage return (U+000D), space (U+0020), "
#~ "next line (U+0085), and all the "
#~ "rare characters in Unicode classes Zl"
#~ " and Zp and Zs. For a full "
#~ "list see "
#~ "https://github.com/tarantool/tarantool/issues/2371. |br| *"
#~ " Bracketed comments (beginning with ``/*``"
#~ " and ending with ``*/``) |br| * "
#~ "Simple comments (beginning with ``--`` "
#~ "and ending with line feed) |br| "
#~ "Separators are not necessary before or"
#~ " after operators. |br| Separators are "
#~ "necessary after keywords or numbers or"
#~ " ordinary identifiers, unless the following"
#~ " token is an operator. |br| Thus "
#~ "Tarantool can understand this series of"
#~ " six tokens: |br| ``SELECT'a'FROM/**/t;`` "
#~ "|br| but for readability one would "
#~ "usually use spaces to separate tokens:"
#~ " |br| ``SELECT 'a' FROM /**/ t;``"
#~ msgstr ""

#~ msgid "Literals"
#~ msgstr "Lua-итератор"

#~ msgid ""
#~ "There are five kinds of literals: "
#~ "BOOLEAN INTEGER DOUBLE STRING VARBINARY."
#~ msgstr ""

#~ msgid ""
#~ "BOOLEAN literals:  |br| TRUE | FALSE "
#~ "| UNKNOWN |br| A literal has "
#~ ":ref:`data type = BOOLEAN "
#~ "<sql_data_type_boolean>` if it is the "
#~ "keyword TRUE or FALSE. UNKNOWN is "
#~ "a synonym for NULL. A literal may"
#~ " have type = BOOLEAN if it is"
#~ " the keyword NULL and there is "
#~ "no context to indicate a different "
#~ "data type."
#~ msgstr ""

#~ msgid ""
#~ "INTEGER literals: |br| [plus-sign | "
#~ "minus-sign] digit [digit ...] |br| "
#~ "or, for a hexadecimal integer literal,"
#~ " |br| [plus-sign | minus-sign] "
#~ "0X | 0x hexadecimal-digit "
#~ "[hexadecimal-digit ...] |br| Examples: 5,"
#~ " -5, +5, 55555, 0X55, 0x55 |br| "
#~ "Hexadecimal 0X55 is equal to decimal "
#~ "85. A literal has :ref:`data type "
#~ "= INTEGER <sql_data_type_integer>` if it "
#~ "contains only digits and is in the"
#~ " range  -9223372036854775808 to "
#~ "+18446744073709551615, integers outside that "
#~ "range are illegal."
#~ msgstr ""

#~ msgid ""
#~ "DOUBLE literals: |br| [plus-sign | "
#~ "minus-sign] [digit [digit ...]] period"
#~ " [digit [digit ...]] |br| [E|e "
#~ "[plus-sign | minus-sign] digit ...]"
#~ " |br| Examples: .0, 1.0, 1E5, 1.1E5."
#~ " |br| A literal has :ref:`data type"
#~ " = DOUBLE <sql_data_type_double>` if it "
#~ "contains a period, or contains \"E\"."
#~ " DOUBLE literals are also known as"
#~ " floating-point literals or approximate-"
#~ "numeric literals. To represent \"Inf\" "
#~ "(infinity), write a real number outside"
#~ " the double-precision number range, "
#~ "for example 1E309. To represent \"nan\""
#~ " (not a number), write an expression"
#~ " that does not result in a real"
#~ " number, for example 0/0, using "
#~ "Tarantool/NoSQL. This will appear as "
#~ "NULL in Tarantool/SQL. In an earlier "
#~ "version literals containing periods were "
#~ "considered to be :ref:`NUMBER "
#~ "<sql_data_type_number>` literals. In a future"
#~ " version \"nan\" may not appear as"
#~ " NULL."
#~ msgstr ""

#~ msgid ""
#~ "STRING literals: |br| [quote] [character "
#~ "...] [quote] |br| Examples: ``'ABC'``, "
#~ "``'AB''C'`` |br| A literal has "
#~ ":ref:`data type type = STRING "
#~ "<sql_data_type_string>` if it is a "
#~ "sequence of zero or more characters "
#~ "enclosed in single quotes. The sequence"
#~ " ``''``  (two single quotes in a "
#~ "row) is treated as ``'`` (a single"
#~ " quote) when enclosed in quotes, that"
#~ " is, ``'A''B'`` is interpreted as "
#~ "``A'B``."
#~ msgstr ""

#~ msgid ""
#~ "VARBINARY literals: |br| X|x [quote] "
#~ "[hexadecimal-digit-pair ...] [quote] |br|"
#~ " Example: ``X'414243'``, which will be "
#~ "displayed as ``'ABC'``. |br| A literal"
#~ " has :ref:`data type = VARBINARY "
#~ "<sql_data_type_varbinary>` (\"variable-length "
#~ "binary\") if it is the letter X"
#~ " followed by quotes containing pairs "
#~ "of hexadecimal digits, representing byte "
#~ "values."
#~ msgstr ""

#~ msgid ""
#~ "Here are four ways to put non-"
#~ "ASCII characters,such as the Greek "
#~ "letter α alpha,  in string literals: "
#~ "|br| First make sure that your "
#~ "shell program is set to accept "
#~ "characters as UTF-8. A simple way "
#~ "to check is |br| ``SELECT hex('α');``"
#~ " If the result is CEB1 -- which"
#~ " is the hexadecimal value for the "
#~ "UTF-8 representation of α -- it is"
#~ " good. |br| (1) Simply enclose the"
#~ " character inside ``'...'``, |br| ``'α'``"
#~ " |br| or |br| (2) Find out what"
#~ " is the hexadecimal code for the "
#~ "UTF-8 representation of α, and enclose"
#~ " that inside ``X'...'``, then cast to"
#~ " STRING because ``X'...'`` literals are "
#~ "data type VARBINARY not STRING, |br| "
#~ "``CAST(X'CEB1' AS STRING)`` |br| or |br|"
#~ " (3) Find out what is the "
#~ "Unicode code point for α, and pass"
#~ " that to the :ref:`CHAR function "
#~ "<sql_function_char>`. |br| ``CHAR(945)  /* "
#~ "remember that this is α as data"
#~ " type STRING not VARBINARY */`` |br|"
#~ " (4) Enclose statements inside double "
#~ "quotes and include Lua escapes, for "
#~ "example ``box.execute(\"SELECT '\\206\\177';\")`` "
#~ "|br| One can use the concatenation "
#~ "operator ``||`` to combine characters "
#~ "made with any of these methods."
#~ msgstr ""

#~ msgid ""
#~ "Limitations: (`Issue#2344 "
#~ "<https://github.com/tarantool/tarantool/issues/2344>`_) |br| "
#~ "* Numeric literals may be quoted, "
#~ "one cannot depend on the presence "
#~ "or absence of quote marks to "
#~ "determine whether a literal is numeric."
#~ " |br| * ``LENGTH('A''B') = 3`` which"
#~ " is correct, but the display from "
#~ "``SELECT A''B;`` is ``A''B``, which is"
#~ " misleading. |br| * It is unfortunate"
#~ " that ``X'41'`` is a byte sequence"
#~ " which looks the same as ``'A'``, "
#~ "but it is not the same. "
#~ "``box.execute(\"select 'A' < X'41';\")`` is"
#~ " not legal at the moment. This "
#~ "happens because ``TYPEOF(X'41')`` yields "
#~ "``'varbinary'``. Also it is illegal to"
#~ " say ``UPDATE ... SET string_column ="
#~ " X'41'``, one must say ``UPDATE ..."
#~ " SET string_column = CAST(X'41' AS "
#~ "STRING);``. |br| * It is non-"
#~ "standard to say that any number "
#~ "which contains a period has data "
#~ "type = DOUBLE."
#~ msgstr ""

#~ msgid "Identifiers"
#~ msgstr "идентификатор сегмента"

#~ msgid ""
#~ "All database objects -- tables, "
#~ "triggers, indexes, columns, constraints, "
#~ "functions, collations -- have identifiers. "
#~ "An identifier should begin with a "
#~ "letter or underscore (``'_'``) and "
#~ "should contain only letters, digits, "
#~ "dollar signs (``'$'``), or underscores. "
#~ "The maximum number of bytes in an"
#~ " identifier is between 64982 and "
#~ "65000. For compatibility reasons, Tarantool"
#~ " recommends that an identifier should "
#~ "not have more than 30 characters."
#~ msgstr ""

#~ msgid ""
#~ "Letters in identifiers do not have "
#~ "to come from the Latin alphabet, "
#~ "for example the Japanese syllabic ひ "
#~ "and the Cyrillic letter д are "
#~ "legal. But be aware that a Latin"
#~ " letter needs only one byte but "
#~ "a Cyrillic letter needs two bytes, "
#~ "so Cyrillic identifiers consume a tiny"
#~ " amount more space."
#~ msgstr ""

#~ msgid ""
#~ "Certain words are reserved and should"
#~ " not be used for identifiers. The "
#~ "simple rule is: if a word means"
#~ " something in Tarantool SQL syntax, "
#~ "do not try to use it for an"
#~ " identifier. The current list of "
#~ "reserved words is:"
#~ msgstr ""

#~ msgid ""
#~ "ALL ALTER ANALYZE AND ANY AS ASC"
#~ " ASENSITIVE AUTOINCREMENT BEGIN BETWEEN "
#~ "BINARY BLOB BOOL BOOLEAN BOTH BY "
#~ "CALL CASE CAST CHAR CHARACTER CHECK "
#~ "COLLATE COLUMN COMMIT CONDITION CONNECT "
#~ "CONSTRAINT CREATE CROSS CURRENT CURRENT_DATE"
#~ " CURRENT_TIME CURRENT_TIMESTAMP CURRENT_USER "
#~ "CURSOR DATE DATETIME dec DECIMAL DECLARE"
#~ " DEFAULT DEFERRABLE DELETE DENSE_RANK DESC"
#~ " DESCRIBE DETERMINISTIC DISTINCT DOUBLE "
#~ "DROP EACH ELSE ELSEIF END ESCAPE "
#~ "EXCEPT EXISTS EXPLAIN FALSE FETCH FLOAT"
#~ " FOR FOREIGN FROM FULL FUNCTION GET"
#~ " GRANT GROUP HAVING IF IMMEDIATE IN"
#~ " INDEX INNER INOUT INSENSITIVE INSERT "
#~ "INT INTEGER INTERSECT INTO IS ITERATE"
#~ " JOIN LEADING LEAVE LEFT LIKE LIMIT"
#~ " LOCALTIME LOCALTIMESTAMP LOOP MATCH "
#~ "NATURAL NOT NULL NUM NUMBER NUMERIC "
#~ "OF ON OR ORDER OUT OUTER OVER "
#~ "PARTIAL PARTITION PRAGMA PRECISION PRIMARY "
#~ "PROCEDURE RANGE RANK READS REAL "
#~ "RECURSIVE REFERENCES REGEXP RELEASE RENAME "
#~ "REPEAT REPLACE RESIGNAL RETURN REVOKE "
#~ "RIGHT ROLLBACK ROW ROWS ROW_NUMBER "
#~ "SAVEPOINT SCALAR SELECT SENSITIVE SET "
#~ "SIGNAL SIMPLE SMALLINT SPECIFIC SQL "
#~ "START STRING SYSTEM TABLE TEXT THEN "
#~ "TO TRAILING TRANSACTION TRIGGER TRIM "
#~ "TRUE TRUNCATE UNION UNIQUE UNKNOWN "
#~ "UNSIGNED UPDATE USER USING VALUES "
#~ "VARBINARY VARCHAR VIEW WHEN WHENEVER "
#~ "WHERE WHILE WITH"
#~ msgstr ""

#~ msgid ""
#~ "Identifiers may be enclosed in double"
#~ " quotes. These are called quoted "
#~ "identifiers or \"delimited identifiers\" "
#~ "(unquoted identifiers may be called "
#~ "\"regular identifiers\"). The double quotes"
#~ " are not part of the identifier. "
#~ "A delimited identifier may be a "
#~ "reserved word and may contain any "
#~ "printable character. Tarantool converts "
#~ "letters in regular identifiers to upper"
#~ " case before it accesses the "
#~ "database, so for statements like "
#~ "``CREATE TABLE a (a INTEGER PRIMARY "
#~ "KEY);`` or ``SELECT a FROM a;`` "
#~ "the table name is A and the "
#~ "column name is A. However, Tarantool "
#~ "does not convert delimited identifiers "
#~ "to upper case, so for statements "
#~ "like ``CREATE TABLE \"a\" (\"a\" INTEGER"
#~ " PRIMARY KEY);`` or ``SELECT \"a\" "
#~ "FROM \"a\";`` the table name is a"
#~ " and the column name is a. The"
#~ " sequence ``\"\"`` is treated as "
#~ "``\"`` when enclosed in double quotes,"
#~ " that is, ``\"A\"\"B\"`` is interpreted "
#~ "as ``\"A\"B\"``."
#~ msgstr ""

#~ msgid "Examples: things, t45, journal_entries_for_2017, ддд, ``\"into\"``"
#~ msgstr ""

#~ msgid ""
#~ "Inside certain statements, identifiers may "
#~ "have \"qualifiers\" to prevent ambiguity. "
#~ "A qualifier is an identifier of a"
#~ " higher-level object, followed by a"
#~ " period. For example column1 within "
#~ "table1 may be referred to as "
#~ "table1.column1. The \"name\" of an "
#~ "object is the same as its "
#~ "identifier, or its qualified identifier. "
#~ "For example, inside ``SELECT t1.column1, "
#~ "t2.column1 FROM t1, t2;`` the qualifiers"
#~ " make it clear that the first "
#~ "column is column1 from table1 and "
#~ "the second column is column2 from "
#~ "table2."
#~ msgstr ""

#~ msgid ""
#~ "The rules are sometimes relaxed for "
#~ "compatibility reasons, for example some "
#~ "non-letter characters such as $ and"
#~ " « are legal in regular identifiers."
#~ " However, it is better to assume "
#~ "that rules are never relaxed."
#~ msgstr ""

#~ msgid "The following are examples of legal and illegal identifiers."
#~ msgstr ""

#~ msgid ""
#~ "_A1   -- legal, begins with underscore"
#~ " and contains underscore | letter |"
#~ " digit\n"
#~ "1_A   -- illegal, begins with digit\n"
#~ "A$« -- legal, but not recommended, "
#~ "try to stick with digits and "
#~ "letters and underscores\n"
#~ "+ -- illegal, operator token\n"
#~ "grant -- illegal, GRANT is a reserved word\n"
#~ "\"grant\" -- legal, delimited identifiers may be reserved words\n"
#~ "\"_space\" -- legal, but Tarantool "
#~ "already uses this name for a "
#~ "system space\n"
#~ "\"A\".\"X\" -- legal, for columns only,"
#~ " inside statements where qualifiers may "
#~ "be necessary\n"
#~ "'a' -- illegal, single quotes are for literals not identifiers\n"
#~ "A123456789012345678901234567890 -- legal, identifiers can be long\n"
#~ "ддд -- legal, and will be converted to upper case in identifiers"
#~ msgstr ""

#~ msgid ""
#~ "The following example shows that "
#~ "conversion to upper case affects regular"
#~ " identifiers but not delimited identifiers."
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE \"q\" (\"q\" INTEGER PRIMARY KEY);\n"
#~ "SELECT * FROM q;\n"
#~ "-- Result = \"error: 'no such table: Q'."
#~ msgstr ""

#~ msgid "Operands"
#~ msgstr ""

#~ msgid ""
#~ "An operand is something that can "
#~ "be operated on. Literals and column "
#~ "identifiers are operands. So are NULL"
#~ " and DEFAULT."
#~ msgstr ""

#~ msgid ""
#~ "NULL and DEFAULT are keywords which "
#~ "represent values whose data types are"
#~ " not known until they are assigned"
#~ " or compared, so they are known "
#~ "by the technical term \"contextually "
#~ "typed value specifications\". (Exception: for"
#~ " the non-standard statement \"SELECT "
#~ "NULL FROM table-name;\"  NULL has "
#~ "data type BOOLEAN.)"
#~ msgstr ""

#~ msgid "Every operand has a data type."
#~ msgstr ""

#~ msgid ""
#~ "For literals, :ref:`as we saw earlier"
#~ " <sql_literals>`, the data type is "
#~ "usually determined by the format."
#~ msgstr ""

#~ msgid "For identifiers, the data type is usually determined by the definition."
#~ msgstr ""

#~ msgid ""
#~ "The usual determination may change "
#~ "because of context or because of "
#~ ":ref:`explicit casting <sql_function_cast>`."
#~ msgstr ""

#~ msgid ""
#~ "For some SQL data type names there"
#~ " are *aliases*. An alias may be "
#~ "used for data definition. For example"
#~ " VARCHAR(5) and TEXT are aliases of"
#~ " STRING and may appear in "
#~ ":samp:`CREATE TABLE {table_name} ({column_name} "
#~ "VARCHAR(5) PRIMARY KEY);` but Tarantool, "
#~ "if asked, will report that the "
#~ "data type of :samp:`{column_name}` is "
#~ "STRING."
#~ msgstr ""

#~ msgid ""
#~ "For every SQL data type there is"
#~ " a corresponding NoSQL type, for "
#~ "example an SQL STRING is stored in"
#~ " a NoSQL space as :ref:`type = "
#~ "'string' <index-box_string>`."
#~ msgstr ""

#~ msgid ""
#~ "To avoid confusion in this manual, "
#~ "all references to SQL data type "
#~ "names are in upper case and all"
#~ " similar words which refer to NoSQL"
#~ " types or to other kinds of "
#~ "object are in lower case, for "
#~ "example:"
#~ msgstr ""

#~ msgid "STRING is a data type name, but string is a general term;"
#~ msgstr ""

#~ msgid "NUMBER is a data type name, but number is a general term."
#~ msgstr ""

#~ msgid ""
#~ "Although it is common to say that"
#~ " a VARBINARY value is a \"binary "
#~ "string\", this manual will not use "
#~ "that term and will instead say "
#~ "\"byte sequence\"."
#~ msgstr ""

#~ msgid ""
#~ "Here are all the SQL data types,"
#~ " their corresponding NoSQL types, their "
#~ "aliases, and minimum / maximum literal"
#~ " examples."
#~ msgstr ""

#~ msgid "**Data types**"
#~ msgstr ""

#~ msgid "SQL type"
#~ msgstr "тип возвращаемого значения"

#~ msgid "NoSQL type"
#~ msgstr ""

#~ msgid "Aliases"
#~ msgstr "вызывает"

#~ msgid "Minimum"
#~ msgstr "num"

#~ msgid "Maximum"
#~ msgstr ""

#~ msgid "BOOLEAN"
#~ msgstr "boolean (логический)"

#~ msgid "boolean"
#~ msgstr "boolean (логический)"

#~ msgid "BOOL"
#~ msgstr "bool (логический)"

#~ msgid "FALSE"
#~ msgstr "false"

#~ msgid "TRUE"
#~ msgstr "true"

#~ msgid "INTEGER"
#~ msgstr "целое число"

#~ msgid "integer"
#~ msgstr "целое число"

#~ msgid "INT"
#~ msgstr "целое число"

#~ msgid "-9223372036854775808"
#~ msgstr ""

#~ msgid "18446744073709551615"
#~ msgstr ""

#~ msgid "UNSIGNED"
#~ msgstr ""

#~ msgid "unsigned"
#~ msgstr ""

#~ msgid "(none)"
#~ msgstr ""

#~ msgid "0"
#~ msgstr ""

#~ msgid "DOUBLE"
#~ msgstr ""

#~ msgid "double"
#~ msgstr ""

#~ msgid "-1.79769e308"
#~ msgstr ""

#~ msgid "1.79769e308"
#~ msgstr ""

#~ msgid "NUMBER"
#~ msgstr "число"

#~ msgid "number"
#~ msgstr "число"

#~ msgid "STRING"
#~ msgstr "строка"

#~ msgid "string"
#~ msgstr "строка"

#~ msgid "TEXT, VARCHAR(n)"
#~ msgstr ""

#~ msgid "``''``"
#~ msgstr ""

#~ msgid "``'many-characters'``"
#~ msgstr "управляющие символы,"

#~ msgid "VARBINARY"
#~ msgstr ""

#~ msgid "varbinary"
#~ msgstr ""

#~ msgid "``X''``"
#~ msgstr ""

#~ msgid "``X'many-hex-digits'``"
#~ msgstr ""

#~ msgid "SCALAR"
#~ msgstr ""

#~ msgid "scalar"
#~ msgstr ""

#~ msgid ""
#~ "BOOLEAN values are FALSE, TRUE, and "
#~ "UNKNOWN (which is the same as "
#~ "NULL). FALSE is less than TRUE."
#~ msgstr ""

#~ msgid ""
#~ "INTEGER values are numbers that do "
#~ "not contain decimal points and are "
#~ "not expressed with exponential notation. "
#~ "The range of possible values is "
#~ "between -2^63 and +2^64, or NULL."
#~ msgstr ""

#~ msgid ""
#~ "UNSIGNED values are numbers that do "
#~ "not contain decimal points and are "
#~ "not expressed with exponential notation. "
#~ "The range of possible values is "
#~ "between 0 and +2^64, or NULL."
#~ msgstr ""

#~ msgid ""
#~ "DOUBLE values are numbers that do "
#~ "contain decimal points (for example 0.5)"
#~ " or are expressed with exponential "
#~ "notation (for example 5E-1). The range"
#~ " of possible values is the same "
#~ "as for the IEEE 754 floating-point"
#~ " standard, or NULL. Numbers outside "
#~ "the range of DOUBLE literals may "
#~ "be displayed as -inf or inf."
#~ msgstr ""

#~ msgid ""
#~ "NUMBER values have the same range "
#~ "as DOUBLE values. But NUMBER values "
#~ "may also also be integers, and, if"
#~ " so, arithmetic operation results will "
#~ "be exact rather than approximate. For"
#~ " example, if a NUMBER column ``X``"
#~ " contains 5, then ``X / 2`` is"
#~ " 2, an integer. There is no "
#~ "literal format for NUMBER (literals like"
#~ " ``1.5`` or ``1E555`` are considered "
#~ "to be DOUBLEs), so use :ref:`CAST "
#~ "<sql_function_cast>` to insist that a "
#~ "number has data type NUMBER, but "
#~ "that is rarely necessary. See the "
#~ "description of NoSQL type :ref:`'number' "
#~ "<index-box_number>`."
#~ msgstr ""

#~ msgid ""
#~ "STRING values are any sequence of "
#~ "zero or more characters encoded with "
#~ "UTF-8, or NULL. The possible character"
#~ " values are the same as for the"
#~ " Unicode standard. Byte sequences which "
#~ "are not valid UTF-8 characters are "
#~ "allowed but not recommended. STRING "
#~ "literal values are enclosed within "
#~ "single quotes, for example ``'literal'``. "
#~ "If the VARCHAR alias is used for"
#~ " column definition, it must include a"
#~ " maximum length, for example column_1 "
#~ "VARCHAR(40). However, the maximum length "
#~ "is ignored. The data-type may be"
#~ " followed by :ref:`[COLLATE collation-name]"
#~ " <sql_collate_clause>`."
#~ msgstr ""

#~ msgid ""
#~ "VARBINARY values are any sequence of "
#~ "zero or more octets (bytes), or "
#~ "NULL. VARBINARY literal values are "
#~ "expressed as X followed by pairs "
#~ "of hexadecimal digits enclosed within "
#~ "single quotes, for example ``X'0044'``. "
#~ "VARBINARY's NoSQL equivalent is "
#~ "``'varbinary'`` but not character string "
#~ "-- the MessagePack storage is MP_BIN "
#~ "(MsgPack binary)."
#~ msgstr ""

#~ msgid ""
#~ "SCALAR can be used for :ref:`column "
#~ "definitions <sql_column_def_data_type>` but the "
#~ "individual column values have one of "
#~ "the preceding types -- BOOLEAN, INTEGER,"
#~ " DOUBLE, STRING, or VARBINARY. See "
#~ "more about SCALAR in the section "
#~ ":ref:`Column definition -- the rules for"
#~ " the SCALAR data type "
#~ "<sql_column_def_scalar>`. The data-type may"
#~ " be followed by :ref:`[COLLATE "
#~ "collation-name] <sql_collate_clause>`."
#~ msgstr ""

#~ msgid ""
#~ "Any value of any data type may "
#~ "be NULL. Ordinarily NULL will be "
#~ "cast to the data type of any "
#~ "operand it is being compared to or"
#~ " to the data type of the column"
#~ " it is in. If the data type "
#~ "of NULL cannot be determined from "
#~ "context, it is BOOLEAN."
#~ msgstr ""

#~ msgid ""
#~ "All the SQL data types correspond "
#~ "to :ref:`Tarantool/NoSQL types "
#~ "<details_about_index_field_types>` with the same "
#~ "name. There are also some "
#~ "Tarantool/NoSQL data types which have no"
#~ " corresponding SQL data types. If "
#~ "Tarantool/SQL reads a Tarantool/NoSQL value"
#~ " which has a type which has no"
#~ " SQL equivalent, Tarantool/SQL may treat"
#~ " it as NULL or INTEGER or "
#~ "VARBINARY. For example, ``SELECT \"flags\" "
#~ "FROM \"_space\";`` will return a column"
#~ " whose data type is ``'map'``. Such"
#~ " columns can only be manipulated in"
#~ " SQL by :ref:`invoking Lua functions "
#~ "<sql_calling_lua>`."
#~ msgstr ""

#~ msgid "Operators"
#~ msgstr ""

#~ msgid "An operator signifies what operation can be performed on operands."
#~ msgstr ""

#~ msgid ""
#~ "Almost all operators are easy to "
#~ "recognize because they consist of "
#~ "one-character or two-character non-"
#~ "alphabetic tokens, except for six "
#~ "keyword operators (AND IN IS LIKE "
#~ "NOT OR)."
#~ msgstr ""

#~ msgid ""
#~ "Almost all operators are \"dyadic\", "
#~ "that is, they are performed on a"
#~ " pair of operands -- the only "
#~ "operators that are performed on a "
#~ "single operand are NOT and ~ and"
#~ " (sometimes) -."
#~ msgstr ""

#~ msgid ""
#~ "The result of an operation is a"
#~ " new operand. If the operator is "
#~ "a comparison operator then the result"
#~ " has data type BOOLEAN (TRUE or "
#~ "FALSE or UNKNOWN). Otherwise the result"
#~ " has the same data type as the"
#~ " original operands, except that: promotion"
#~ " to a broader type may occur to"
#~ " avoid overflow. Arithmetic with NULL "
#~ "operands will result in a NULL "
#~ "operand."
#~ msgstr ""

#~ msgid ""
#~ "In the following list of operators, "
#~ "the tag \"(arithmetic)\" indicates that "
#~ "all operands are expected to be "
#~ "numbers and should result in a "
#~ "number; the tag \"(comparison)\" indicates "
#~ "that operands are expected to have "
#~ "similar data types and should result "
#~ "in a BOOLEAN; the tag \"(logic)\" "
#~ "indicates that operands are expected to"
#~ " be BOOLEAN and should result in "
#~ "a BOOLEAN. Exceptions may occur where"
#~ " operations are not possible, but see"
#~ " the \"special situations\" which are "
#~ "described after this list. Although all"
#~ " examples show literals, they could "
#~ "just as easily show column identifiers."
#~ msgstr ""

#~ msgid ""
#~ "``+`` addition (arithmetic) Add two "
#~ "numbers according to standard arithmetic "
#~ "rules. Example: ``1 + 5``, result "
#~ "= 6."
#~ msgstr ""

#~ msgid ""
#~ "``-`` subtraction (arithmetic) Subtract second"
#~ " number from first number according "
#~ "to standard arithmetic rules. Example: "
#~ "``1 - 5``, result = -4."
#~ msgstr ""

#~ msgid ""
#~ "``*`` multiplication (arithmetic) Multiply two"
#~ " numbers according to standard arithmetic"
#~ " rules. Example: ``2 * 5``, result"
#~ " = 10."
#~ msgstr ""

#~ msgid ""
#~ "``/`` division (arithmetic) Divide second "
#~ "number into first number according to"
#~ " standard arithmetic rules. Division by "
#~ "zero is not legal. Division of "
#~ "integers always results in rounding "
#~ "down, use :ref:`CAST <sql_function_cast>` to"
#~ " DOUBLE to get non-integer results."
#~ " Example: ``5 / 2``, result = "
#~ "2."
#~ msgstr ""

#~ msgid ""
#~ "``%`` modulus (arithmetic) Divide second "
#~ "number into first number according to"
#~ " standard arithmetic rules. The result "
#~ "is the remainder. Example: ``17 % "
#~ "5``, result = 2."
#~ msgstr ""

#~ msgid ""
#~ "``<<`` shift left (arithmetic) Shift the"
#~ " first number to the left N "
#~ "times, where N = the second "
#~ "number. For positive numbers, each 1-bit"
#~ " shift to the left is equivalent "
#~ "to multiplying times 2. Example: ``5 "
#~ "<< 1``, result = 10."
#~ msgstr ""

#~ msgid ""
#~ "``>>`` shift right (arithmetic) Shift "
#~ "the first number to the right N"
#~ " times, where N = the second "
#~ "number. For positive numbers, each 1-bit"
#~ " shift to the right is equivalent "
#~ "to dividing by 2. Example: ``5 >>"
#~ " 1``, result = 2."
#~ msgstr ""

#~ msgid ""
#~ "``&`` and (arithmetic) Combine the two"
#~ " numbers, with 1 bits in the "
#~ "result if and only if both "
#~ "original numbers have 1 bits. Example:"
#~ " ``5 & 4``, result = 4."
#~ msgstr ""

#~ msgid ""
#~ "``|`` or (arithmetic) Combine the two"
#~ " numbers, with 1 bits in the "
#~ "result if either original number has "
#~ "a 1 bit. Example: ``5 | 2``, "
#~ "result = 7."
#~ msgstr ""

#~ msgid ""
#~ "``~`` negate (arithmetic), sometimes called"
#~ " bit inversion Change 0 bits to "
#~ "1 bits, change 1 bits to 0 "
#~ "bits. Example: ``~5``, result = -6."
#~ msgstr ""

#~ msgid ""
#~ "``<`` less than (comparison) Return TRUE"
#~ " if the first operand is less "
#~ "than the second by arithmetic or "
#~ "collation rules. Example for numbers: "
#~ "``5 < 2``, result = FALSE. Example"
#~ " for strings: ``'C' < ' '``, "
#~ "result = FALSE."
#~ msgstr ""

#~ msgid ""
#~ "``<=`` less than or equal (comparison)"
#~ " Return TRUE if the first operand "
#~ "is less than or equal to the "
#~ "second by arithmetic or collation rules."
#~ " Example for numbers: ``5 <= 5``, "
#~ "result = TRUE. Example for strings: "
#~ "``'C' <= 'B'``, result = FALSE."
#~ msgstr ""

#~ msgid ""
#~ "``>`` greater than (comparison) Return "
#~ "TRUE if the first operand is "
#~ "greater than the second by arithmetic"
#~ " or collation rules. Example for "
#~ "numbers: ``5 > -5``, result = "
#~ "TRUE. Example for strings: ``'C' > "
#~ "'!'``, result = TRUE."
#~ msgstr ""

#~ msgid ""
#~ "``>=`` greater than or equal "
#~ "(comparison) Return TRUE if the first"
#~ " operand is greater than or equal "
#~ "to the second by arithmetic or "
#~ "collation rules. Example for numbers: "
#~ "``0 >= 0``, result = TRUE. Example"
#~ " for strings: ``'Z' >= 'Γ'``, result"
#~ " = FALSE."
#~ msgstr ""

#~ msgid ""
#~ "``=`` equal (assignment or comparison) "
#~ "After the word SET, \"=\" means "
#~ "the first operand gets the value "
#~ "from the second operand. In other "
#~ "contexts, \"=\" returns TRUE if operands"
#~ " are equal. Example for assignment: "
#~ "``... SET column1 = 'a';`` Example "
#~ "for numbers: ``0 = 0``, result ="
#~ " TRUE. Example for strings:  ``'1' ="
#~ " '2 '``, result = FALSE."
#~ msgstr ""

#~ msgid ""
#~ "``==`` equal (assignment), or equal "
#~ "(comparison) This is a non-standard "
#~ "equivalent of :ref:`\"= equal (assignment "
#~ "or comparison)\" <sql_equal>`."
#~ msgstr ""

#~ msgid ""
#~ "``<>`` not equal (comparison) Return "
#~ "TRUE if the first operand is not"
#~ " equal to the second by arithmetic"
#~ " or collation rules. Example for "
#~ "strings: ``'A' <> 'A     '`` is "
#~ "TRUE."
#~ msgstr ""

#~ msgid ""
#~ "``!=`` not equal (comparison) This is"
#~ " a non-standard equivalent of "
#~ ":ref:`\"\\<\\> not equal (comparison)\" "
#~ "<sql_not_equal>`."
#~ msgstr ""

#~ msgid ""
#~ "``IS NULL`` and ``IS NOT NULL`` "
#~ "(comparison) For IS NULL: Return TRUE"
#~ " if the first operand is NULL, "
#~ "otherwise return FALSE. Example: column1 "
#~ "IS NULL, result = TRUE if column1"
#~ " contains NULL. For IS NOT NULL: "
#~ "Return FALSE if the first operand "
#~ "is NULL, otherwise return TRUE. Example:"
#~ " ``column1 IS NOT NULL``, result ="
#~ " FALSE if column1 contains NULL."
#~ msgstr ""

#~ msgid ""
#~ "``LIKE`` (comparison) Perform a comparison "
#~ "of two string operands. If the "
#~ "second operand contains ``'_'``, the "
#~ "``'_'`` matches any single character in"
#~ " the first operand. If the second "
#~ "operand contains ``'%'``, the ``'%'`` "
#~ "matches 0 or more characters in "
#~ "the first operand. If it is "
#~ "necessary to search for either ``'_'``"
#~ " or ``'%'`` within a string without"
#~ " treating it specially, an optional "
#~ "clause can be added, ESCAPE single-"
#~ "character-operand, for example ``'abc_' "
#~ "LIKE 'abcX_' ESCAPE 'X'`` is TRUE "
#~ "because ``X'`` means \"following character "
#~ "is not special\". Matching is also "
#~ "affected by the string's collation."
#~ msgstr ""

#~ msgid ""
#~ "``BETWEEN`` (comparison) :samp:`{x} BETWEEN "
#~ "{y} AND {z}` is shorthand for "
#~ ":samp:`{x} >= {y} AND {x} <= {z}`."
#~ msgstr ""

#~ msgid ""
#~ "``NOT`` negation (logic) Return TRUE if"
#~ " operand is FALSE return FALSE if "
#~ "operand is TRUE, else return UNKNOWN."
#~ " Example: ``NOT (1 > 1)``, result "
#~ "= TRUE."
#~ msgstr ""

#~ msgid ""
#~ "``IN`` is equal to one of a "
#~ "list of operands (comparison) Return "
#~ "TRUE if first operand equals any "
#~ "of the operands in a parenthesized "
#~ "list. Example: ``1 IN (2,3,4,1,7)``, "
#~ "result = TRUE."
#~ msgstr ""

#~ msgid ""
#~ "``AND`` and (logic) Return TRUE if "
#~ "both operands are TRUE. Return UNKNOWN"
#~ " if both operands are UNKNOWN. Return"
#~ " UNKNOWN if one operand is TRUE "
#~ "and the other operand is UNKNOWN. "
#~ "Return FALSE if one operand is "
#~ "FALSE and the other operand is "
#~ "(UNKNOWN or TRUE or FALSE)."
#~ msgstr ""

#~ msgid ""
#~ "``OR`` or (logic) Return TRUE if "
#~ "either operand is TRUE. Return FALSE "
#~ "if both operands are FALSE. Return "
#~ "UNKNOWN if one operand is UNKNOWN "
#~ "and the other operand is (UNKNOWN "
#~ "or FALSE)."
#~ msgstr ""

#~ msgid ""
#~ "``||`` concatenate (string manipulation) "
#~ "Return the value of the first "
#~ "operand concatenated with the value of"
#~ " the second operand. Example: ``'A' "
#~ "|| 'B'``, result = ``'AB'``."
#~ msgstr ""

#~ msgid "The precedence of dyadic operators is:"
#~ msgstr ""

#~ msgid ""
#~ "||\n"
#~ "* / %\n"
#~ "+ -\n"
#~ "<< >> & |\n"
#~ "<  <= > >=\n"
#~ "=  == != <> IS IS NOT IN LIKE\n"
#~ "AND\n"
#~ "OR"
#~ msgstr ""

#~ msgid "To ensure a desired precedence, use () parentheses."
#~ msgstr ""

#~ msgid "Special Situations"
#~ msgstr ""

#~ msgid ""
#~ "If one of the operands has data"
#~ " type DOUBLE, Tarantool uses floating-"
#~ "point arithmetic. This means that exact"
#~ " results are not guaranteed and "
#~ "rounding may occur without warning. For"
#~ " example, 4.7777777777777778 = 4.7777777777777777"
#~ " is TRUE."
#~ msgstr ""

#~ msgid ""
#~ "The floating-point values inf and "
#~ "-inf are possible. For example, ``SELECT"
#~ " 1e318, -1e318;`` will return \"inf, "
#~ "-inf\". Arithmetic on infinite values "
#~ "may cause NULL results, for example "
#~ "``SELECT 1e318 - 1e318;`` is NULL "
#~ "and ``SELECT 1e318 * 0;`` is NULL."
#~ msgstr ""

#~ msgid ""
#~ "SQL operations never return the "
#~ "floating-point value -nan, although it "
#~ "may exist in data created by "
#~ "Tarantool's NoSQL. In SQL, -nan is "
#~ "treated as NULL."
#~ msgstr ""

#~ msgid ""
#~ "A string will be converted to a"
#~ " number if it is used with an"
#~ " arithmetic operator and conversion is "
#~ "possible, for example ``'7' + '7'`` "
#~ "= 14. And for comparison or "
#~ "assignment, ``'7'`` = 7. This is "
#~ "called implicit casting. It is "
#~ "applicable for STRINGs and all numeric"
#~ " data types."
#~ msgstr ""

#~ msgid ""
#~ "Limitations: (`Issue#2346 "
#~ "<https://github.com/tarantool/tarantool/issues/2346>`_) |br| "
#~ "* Some words, for example MATCH "
#~ "and REGEXP, are reserved but are "
#~ "not necessary for current or planned "
#~ "Tarantool versions |br| * 999999999999999 "
#~ "<< 210 yields 0. (1 << 63) "
#~ ">> 63 yields -1."
#~ msgstr ""

#~ msgid "Expressions"
#~ msgstr "Пример сессии"

#~ msgid ""
#~ "An expression is a chunk of syntax"
#~ " that causes return of a value. "
#~ "Expressions may contain literals, column-"
#~ "names, operators, and parentheses."
#~ msgstr ""

#~ msgid ""
#~ "Therefore these are examples of "
#~ "expressions: ``1``, ``1 + 1 << "
#~ "1``, ``(1 = 2) OR 4 > 3``,"
#~ " ``'x' || 'y' || 'z'``."
#~ msgstr ""

#~ msgid "Also there are two expressions that involve keywords:"
#~ msgstr ""

#~ msgid "value IS [NOT] NULL |br|"
#~ msgstr ""

#~ msgid "... for determining whether value is (not) NULL"
#~ msgstr ""

#~ msgid "CASE ... WHEN ... THEN ... ELSE ... END |br|"
#~ msgstr ""

#~ msgid "... for setting a series of conditions."
#~ msgstr ""

#~ msgid "See also: :ref:`subquery <sql_subquery>`."
#~ msgstr ""

#~ msgid "Limitations: IS TRUE and IS FALSE return an error."
#~ msgstr ""

#~ msgid "Comparing and Ordering"
#~ msgstr ""

#~ msgid ""
#~ "There are rules for determining whether"
#~ " value-1 is \"less than\", \"equal "
#~ "to\", or \"greater than\" value-2. These"
#~ " rules are applied for searches, for"
#~ " sorting results in order by column"
#~ " values, and for determining whether "
#~ "a column is unique. The result of"
#~ " a comparison of two values can "
#~ "be TRUE, FALSE, or UNKNOWN (the "
#~ "three BOOLEAN values). Sometimes for "
#~ "retrieval TRUE is converted to 1, "
#~ "FALSE is converted to 0, UNKNOWN "
#~ "is converted to NULL. For any "
#~ "comparisons where neither operand is "
#~ "NULL, the operands are \"distinct\" if"
#~ " the comparison result is FALSE. For"
#~ " any set of operands where all "
#~ "operands are distinct from each other,"
#~ " the set is considered to be "
#~ "\"unique\"."
#~ msgstr ""

#~ msgid ""
#~ "When comparing a number to a "
#~ "number: |br| * infinity = infinity "
#~ "is true |br| * regular numbers are"
#~ " compared according to usual arithmetic "
#~ "rules"
#~ msgstr ""

#~ msgid ""
#~ "When comparing any value to NULL: "
#~ "|br| (for examples in this paragraph "
#~ "assume that column1 in table T "
#~ "contains {NULL, NULL, 1, 2}) |br| "
#~ "* value comparison-operator NULL is "
#~ "UNKNOWN (not TRUE and not FALSE), "
#~ "which affects \"WHERE condition\" because "
#~ "the condition must be TRUE, and "
#~ "does not affect  \"CHECK (condition)\" "
#~ "because the condition must be either "
#~ "TRUE or UNKNOWN. Therefore SELECT * "
#~ "FROM T WHERE column1 > 0 OR "
#~ "column1 < 0 OR column1 = 0; "
#~ "returns only  {1,2}, and the table "
#~ "can have been created with CREATE "
#~ "TABLE T (... column1 INTEGER, CHECK "
#~ "(column1 >= 0)); |br| * for any"
#~ " operations that contain the keyword "
#~ "DISTINCT, NULLs are not distinct. "
#~ "Therefore SELECT DISTINCT column1 FROM "
#~ "T; will return {NULL,1,2}. |br| * "
#~ "for grouping, NULL values sort together."
#~ " Therefore SELECT column1, COUNT(*) FROM"
#~ " T GROUP BY column1; will include "
#~ "a row {NULL, 2}. |br| * for "
#~ "ordering, NULL values sort together and"
#~ " are less than non-NULL values. "
#~ "Therefore SELECT column1 FROM T ORDER"
#~ " BY column1; returns {NULL, NULL, "
#~ "1,2}. |br| * for evaluating a "
#~ "UNIQUE constraint or UNIQUE index, any"
#~ " number of NULLs is okay. Therefore"
#~ " CREATE UNIQUE INDEX i ON T "
#~ "(column1); will succeed."
#~ msgstr ""

#~ msgid ""
#~ "When comparing a number to a "
#~ "STRING: |br| * If implicit casting "
#~ "is possible, the STRING operand is "
#~ "converted to a number before comparison."
#~ " If implicit casting is not possible,"
#~ " and one of the operands is the"
#~ " name of a column which was "
#~ "defined as SCALAR, and the column "
#~ "is being compared with a number, "
#~ "then number is less than STRING. "
#~ "Otherwise, the comparison is not legal."
#~ msgstr ""

#~ msgid "When comparing a BOOLEAN to a BOOLEAN: |br| TRUE is greater than FALSE."
#~ msgstr ""

#~ msgid ""
#~ "When comparing a VARBINARY to a "
#~ "VARBINARY: |br| * The numeric value "
#~ "of each pair of bytes is compared"
#~ " until the end of the byte "
#~ "sequences or until inequality. If two"
#~ " byte sequences are otherwise equal "
#~ "but one is longer, then the longer"
#~ " one is greater."
#~ msgstr ""

#~ msgid ""
#~ "When comparing for the sake of "
#~ "eliminating duplicates: |br| * This is"
#~ " usually signalled by the word "
#~ "DISTINCT, so it applies to SELECT "
#~ "DISTINCT, to set operators such as "
#~ "UNION (where DISTINCT is implied), and"
#~ " to aggregate functions such as  "
#~ "AVG(DISTINCT). |br| * Two operators are"
#~ " \"not distinct\" if they are equal"
#~ " to each other, or are both "
#~ "NULL |br| * If two values are "
#~ "equal but not identical, for example "
#~ "1.0 and 1.00, they are non-"
#~ "distinct and there is no way to"
#~ " specify which one will be eliminated"
#~ " |br| * Values in primary-key "
#~ "or unique columns are distinct due "
#~ "to definition."
#~ msgstr ""

#~ msgid ""
#~ "When comparing a STRING to a "
#~ "STRING: |br| * Ordinarily collation is"
#~ " \"binary\", that is, comparison is "
#~ "done according to the numeric values "
#~ "of the bytes. This can be "
#~ "cancelled by adding a :ref:`COLLATE "
#~ "clause <sql_collate_clause>` at the end "
#~ "of either expression. So ``'A' < "
#~ "'a'`` and ``'a' < 'Ä'``, but ``'A'"
#~ " COLLATE \"unicode_ci\" = 'a'`` and "
#~ "``'a' COLLATE \"unicode_ci\" = 'Ä'``. "
#~ "|br| * When comparing a column "
#~ "with a string literal, the column's "
#~ "defined collation is used. |br| * "
#~ "Ordinarily trailing spaces matter. So "
#~ "``'a' = 'a  '`` is not TRUE. "
#~ "This can be cancelled by using the"
#~ " :ref:`TRIM(TRAILING ...) <sql_function_trim>` "
#~ "function. |br|"
#~ msgstr ""

#~ msgid ""
#~ "Limitations: |br| * LIKE comparisons "
#~ "return integer results according to "
#~ "meta-information. |br| * LIKE is not"
#~ " expected to work with VARBINARY."
#~ msgstr ""

#~ msgid "Data Type Conversion"
#~ msgstr "Замена регистра"

#~ msgid ""
#~ "Data type conversion, also called "
#~ "casting, is necessary for any operation"
#~ " involving two operands X and Y, "
#~ "when X and Y have different data"
#~ " types. |br| Or, casting is necessary"
#~ " for assignment operations (when INSERT "
#~ "or UPDATE is putting a value of"
#~ " type X into a column defined "
#~ "as type Y). |br| Casting can be"
#~ " \"explicit\" when a user uses the"
#~ " :ref:`CAST <sql_function_cast>` function, or "
#~ "\"implicit\" when Tarantool does a "
#~ "conversion automatically."
#~ msgstr ""

#~ msgid ""
#~ "The general rules are fairly simple: "
#~ "|br| Assignments and operations involving "
#~ "NULL cause NULL or UNKNOWN results. "
#~ "|br| For arithmetic, convert to the "
#~ "data type which can contain both "
#~ "operands and the result. |br| For "
#~ "explicit casts, if a meaningful result"
#~ " is possible, the operation is "
#~ "allowed. |br| For implicit casts, if "
#~ "a meaningful result is possible and "
#~ "the data types on both sides are"
#~ " either STRINGs or numbers (that is,"
#~ " are STRING or INTEGER or UNSIGNED"
#~ " or DOUBLE or NUMBER), the operation"
#~ " is sometimes allowed."
#~ msgstr ""

#~ msgid "The specific situations in this chart follow the general rules:"
#~ msgstr ""

#~ msgid ""
#~ "~                To BOOLEAN | To number  | To STRING | To VARBINARY\n"
#~ "---------------  ----------   ----------   ---------   ------------\n"
#~ "From BOOLEAN   | AAA        | S--        | A--       | ---\n"
#~ "From number    | A--        | SSA        | AAA       | ---\n"
#~ "From STRING    | S--        | SSS        | AAA       | A--\n"
#~ "From VARBINARY | ---        | ---        | A--       | AAA"
#~ msgstr ""

#~ msgid ""
#~ "Where each entry in the chart has"
#~ " 3 characters: |br| Where A = "
#~ "Always allowed, S = Sometimes allowed,"
#~ " - = Never allowed. |br| The "
#~ "first character of an entry is for"
#~ " explicit casts, |br| the second "
#~ "character is for implicit casts for "
#~ "assignment, |br| the third character is"
#~ " for implicit cast for comparison. "
#~ "|br| So AAA = Always for explicit,"
#~ " Always for Implicit (assignment), Always"
#~ " for Implicit (comparison)."
#~ msgstr ""

#~ msgid ""
#~ "The S \"Sometimes allowed\" character "
#~ "applies for these special situations: "
#~ "|br| From STRING To BOOLEAN is "
#~ "allowed if UPPER(string-value) = "
#~ "``'TRUE'`` or ``'FALSE'``. |br| From "
#~ "number to INTEGER or UNSIGNED is "
#~ "allowed for cast and assignment only "
#~ "if the result is not out of "
#~ "range, and the number has no "
#~ "post-decimal digits. |br| From STRING "
#~ "to INTEGER or UNSIGNED is allowed "
#~ "only if the string has a "
#~ "representation of a number, and the "
#~ "result is not out of range, and"
#~ " the number has no post-decimal "
#~ "digits. |br| From STRING to DOUBLE "
#~ "or NUMBER is allowed only if the"
#~ " string has a representation of a "
#~ "number. |br| From BOOLEAN to number "
#~ "is allowed only if the number is"
#~ " not DOUBLE. The chart does not "
#~ "show To|From SCALAR because the "
#~ "conversions depend on the type of "
#~ "the value, not the type of the "
#~ "column definition. Explicit cast to "
#~ "SCALAR is allowed but has no "
#~ "effect, the result data type is "
#~ "always the same as the original "
#~ "data type. But comparisons of values "
#~ "of different types are allowed if "
#~ "the definition is SCALAR."
#~ msgstr ""

#~ msgid "Examples of casts, illustrating the situations in the chart:"
#~ msgstr ""

#~ msgid ""
#~ "``CAST(TRUE AS INTEGER)`` is legal "
#~ "because the intersection of the  \"From"
#~ " BOOLEAN\" row with the \"To number\""
#~ " column is ``A--`` and the first "
#~ "letter of ``A--`` is for explicit "
#~ "cast and A means Always Allowed. "
#~ "The result is 1."
#~ msgstr ""

#~ msgid ""
#~ "``UPDATE ... SET varbinary_column = "
#~ "'A'`` is illegal because the "
#~ "intersection of the \"From STRING\" row"
#~ " with the \"To VARBINARY\" column is"
#~ " ``A--`` and the second letter of "
#~ "``A--`` is for implicit cast "
#~ "(assignment) and - means not allowed."
#~ " The result is an error message."
#~ msgstr ""

#~ msgid ""
#~ "``1.7E-1 > 0`` is legal because "
#~ "the intersection of the \"From number\""
#~ " row with the \"To number\" column"
#~ " is SSA, and the third letter "
#~ "of SSA is for implicit cast "
#~ "(comparison) and A means Always Allowed."
#~ " The result is TRUE."
#~ msgstr ""

#~ msgid ""
#~ "``11 > '2'`` is legal because the"
#~ " intersection of the \"From number\" "
#~ "row with the \"To STRING\" column "
#~ "is AAA and the third letter of "
#~ "AAA is for implicit cast (comparison)"
#~ " and A means Always Allowed. The "
#~ "result is TRUE.  For detailed "
#~ "explanation see the following section."
#~ msgstr ""

#~ msgid "Implicit string/numeric cast"
#~ msgstr ""

#~ msgid ""
#~ "Special considerations may apply for "
#~ "casting STRINGs to/from "
#~ "INTEGERs/DOUBLEs/NUMBERs/UNSIGNEDs (numbers) for "
#~ "comparison or assignment."
#~ msgstr ""

#~ msgid ""
#~ "``1 = '1' /* compare a STRING "
#~ "with a number */`` |br| ``UPDATE "
#~ "... SET string_column = 1 /* "
#~ "assign a number to a STRING */``"
#~ msgstr ""

#~ msgid ""
#~ "For comparisons, the cast is always "
#~ "from STRING to number. |br| Therefore"
#~ " ``1e2 = '100'`` is TRUE, and "
#~ "``11 > '2'`` is TRUE. |br| If "
#~ "the cast fails, then the number is"
#~ " less than the STRING. |br| Therefore"
#~ " ``1e400 < ''`` is TRUE. |br| "
#~ "Exception: for BETWEEN the cast is "
#~ "to the data type of the first "
#~ "and last operands. |br| Therefore ``'66'"
#~ " BETWEEN 5 AND '7'`` is TRUE."
#~ msgstr ""

#~ msgid ""
#~ "For assignments, the cast is always "
#~ "from source to target. Therefore "
#~ "``INSERT INTO t (integer_column) VALUES "
#~ "('5');`` inserts 5. |br| If the "
#~ "cast fails, then the result is an"
#~ " error. Due to a change in "
#~ "behavior starting with Tarantool 2.4.1, "
#~ "if the string contains post-decimal "
#~ "digits and the target is INTEGER "
#~ "or UNSIGNED, the assignment will fail."
#~ " Therefore ``INSERT INTO t (integer_column)"
#~ " VALUES ('5.5');`` causes an error. "
#~ "|br|"
#~ msgstr ""

#~ msgid ""
#~ "Implicit cast also happens if STRINGS"
#~ " are used in arithmetic. |br| "
#~ "Therefore ``'5' / '5' = 1``. If"
#~ " the cast fails, then the result "
#~ "is an error. |br| Therefore ``'5' "
#~ "/ ''`` is an error."
#~ msgstr ""

#~ msgid ""
#~ "Implicit cast does NOT happen if "
#~ "numbers are used in concatenation, or"
#~ " in LIKE. |br| Therefore ``5 || "
#~ "'5'`` is illegal."
#~ msgstr ""

#~ msgid ""
#~ "In the following examples, implicit cast"
#~ " does not happen for values in "
#~ "SCALAR columns: |br| ``DROP TABLE "
#~ "scalars;`` |br| ``CREATE TABLE scalars "
#~ "(scalar_column SCALAR PRIMARY KEY);`` |br| "
#~ "``INSERT INTO scalars VALUES (11), "
#~ "('2');`` |br| ``SELECT * FROM scalars"
#~ " WHERE scalar_column > 11;   /* 0 "
#~ "rows. So 11 > '2'. */`` |br| "
#~ "``SELECT * FROM scalars WHERE "
#~ "scalar_column < '2';  /* 1 row. So"
#~ " 11 < '2'. */`` |br| ``SELECT "
#~ "max(scalar_column) FROM scalars; /* 1 "
#~ "row: '2'. So 11 < '2'. */`` "
#~ "|br| ``SELECT sum(scalar_column) FROM scalars;"
#~ " /* 1 row: 13. So cast "
#~ "happened. */`` |br| These results are"
#~ " not affected by indexing, or by "
#~ "reversing the operands."
#~ msgstr ""

#~ msgid ""
#~ "Implicit cast does NOT happen for "
#~ ":ref:`GREATEST() <sql_function_greatest>` or "
#~ ":ref:`LEAST() <sql_function_least>`. Therefore "
#~ "``LEAST('5',6)`` is 6."
#~ msgstr ""

#~ msgid ""
#~ "For function arguments: |br| If the "
#~ "function description says that a "
#~ "parameter has a specific data type, "
#~ "and implicit assignment casts are "
#~ "allowed, then arguments which are not"
#~ " passed with that data type will "
#~ "be converted before the function is "
#~ "applied. |br| For example, the "
#~ ":ref:`LENGTH() <sql_function_length>` function "
#~ "expects a STRING or VARBINARY, and "
#~ "INTEGER  can be converted to STRING, "
#~ "therefore LENGTH(15) will return the "
#~ "length of ``'15'``, that is, 2. "
#~ "|br| But implicit cast sometimes does"
#~ " NOT happen for parameters. Therefore "
#~ "``ABS('5')`` will cause an error message"
#~ " after `Issue#4159 "
#~ "<https://github.com/tarantool/tarantool/issues/4159>`_ is "
#~ "fixed. However, :ref:`TRIM(5) <sql_function_trim>`"
#~ " will still be legal."
#~ msgstr ""

#~ msgid ""
#~ "Although it is not a requirement "
#~ "of the SQL standard, implicit cast "
#~ "is supposed to help compatibility with"
#~ " other DBMSs. However, other DBMSs "
#~ "have different rules about what can "
#~ "be converted (for example they may "
#~ "allow assignment of ``'inf'`` but "
#~ "disallow comparison with ``'1e5'``). And, "
#~ "of course, it is not possible to"
#~ " be compatible with other DBMSs and"
#~ " at the same time support SCALAR, "
#~ "which other DBMSs do not have."
#~ msgstr ""

#~ msgid ""
#~ "Limitations (`Issue#3809 "
#~ "<https://github.com/tarantool/tarantool/issues/3809>`_): |br|"
#~ " Result of concatenation, or out-"
#~ "of-bound result, may have wrong type."
#~ " |br| Parameter conversion behavior will"
#~ " change (`Issue#4159 "
#~ "<https://github.com/tarantool/tarantool/issues/4159>`_). After"
#~ " issue#4159 is done, LENGTH(15) will "
#~ "be illegal."
#~ msgstr ""

#~ msgid "Statements"
#~ msgstr ""

#~ msgid ""
#~ "A statement consists of SQL-language "
#~ "keywords and expressions that direct "
#~ "Tarantool to do something with a "
#~ "database. Statements begin with one of"
#~ " the words ALTER ANALYZE COMMIT "
#~ "CREATE DELETE DROP EXPLAIN INSERT PRAGMA"
#~ " RELEASE REPLACE ROLLBACK SAVEPOINT SELECT"
#~ " START TRUNCATE UPDATE VALUES WITH. "
#~ "Statements should end with \";\" "
#~ "semicolon although this is not "
#~ "mandatory."
#~ msgstr ""

#~ msgid ""
#~ "A client sends a statement to the"
#~ " Tarantool server. The Tarantool server "
#~ "parses the statement and executes it."
#~ " If there is an error, Tarantool "
#~ "returns an error message."
#~ msgstr ""

#~ msgid "SQL statements and clauses"
#~ msgstr ""

#~ msgid "ALTER TABLE"
#~ msgstr "строка, таблица"

#~ msgid "Syntax:"
#~ msgstr ""

#~ msgid ":samp:`ALTER TABLE {table-name} RENAME TO {new-table-name};`"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`ALTER TABLE {table-name} ADD "
#~ "CONSTRAINT {constraint-name} {constraint-"
#~ "definition};`"
#~ msgstr ""

#~ msgid ":samp:`ALTER TABLE {table-name} DROP CONSTRAINT {constraint-name};`"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`ALTER TABLE {table-name} ENABLE|DISABLE"
#~ " CHECK CONSTRAINT {constraint-name};`"
#~ msgstr ""

#~ msgid "|br|"
#~ msgstr ""

#~ msgid "ALTER is used to change a table's name or a table's constraints."
#~ msgstr ""

#~ msgid "Examples:"
#~ msgstr "Примеры"

#~ msgid ""
#~ "For renaming a table with ``ALTER "
#~ "... RENAME``, the *old-table* must "
#~ "exist, the *new-table* must not "
#~ "exist. Example: |br| ``-- renaming a "
#~ "table:`` ``ALTER TABLE t1 RENAME TO "
#~ "t2;``"
#~ msgstr ""

#~ msgid ""
#~ "For adding a :ref:`table constraint "
#~ "<sql_table_constraint_def>` with ``ADD CONSTRAINT``,"
#~ " the table must exist, the table "
#~ "must be empty, the constraint name "
#~ "must be unique within the table. "
#~ "Example with a :ref:`foreign-key "
#~ "constraint definition <sql_foreign_key>`: |br| "
#~ "``ALTER TABLE t1 ADD CONSTRAINT "
#~ "fk_s1_t1_1 FOREIGN KEY (s1) REFERENCES "
#~ "t1;`` |br|"
#~ msgstr ""

#~ msgid ""
#~ "It is not possible to say ``CREATE"
#~ " TABLE table_a ... REFERENCES table_b "
#~ "...`` if table ``b`` does not "
#~ "exist yet. This is a situation "
#~ "where ``ALTER TABLE`` is handy -- "
#~ "users can ``CREATE TABLE table_a`` "
#~ "without the foreign key, then ``CREATE"
#~ " TABLE table_b``, then ``ALTER TABLE "
#~ "table_a ... REFERENCES table_b ...``."
#~ msgstr ""

#~ msgid ""
#~ "-- adding a primary-key constraint definition:\n"
#~ "-- This is unusual because primary keys are created automatically\n"
#~ "-- and it is illegal to have two primary keys for the same table.\n"
#~ "-- However, it is possible to drop a primary-key index, and this\n"
#~ "-- is a way to restore the primary key if that happens.\n"
#~ "ALTER TABLE t1 ADD CONSTRAINT \"pk_unnamed_T1_1\" PRIMARY KEY (s1);\n"
#~ "\n"
#~ "-- adding a unique-constraint definition:\n"
#~ "-- Alternatively, you can say CREATE "
#~ "UNIQUE INDEX unique_key ON t1 (s1);\n"
#~ ""
#~ "ALTER TABLE t1 ADD CONSTRAINT \"unique_unnamed_T1_2\" UNIQUE (s1);\n"
#~ "\n"
#~ "-- Adding a check-constraint definition:\n"
#~ "ALTER TABLE t1 ADD CONSTRAINT \"ck_unnamed_T1_1\" CHECK (s1 > 0);"
#~ msgstr ""

#~ msgid ""
#~ "For ``ALTER ... DROP CONSTRAINT``, it"
#~ " is only legal to drop a named"
#~ " constraint. (Tarantool generates the "
#~ "constraint names automatically if the "
#~ "user does not provide them.) To "
#~ "remove a unique constraint, use use "
#~ "either ``ALTER ... DROP CONSTRAINT`` or"
#~ " :ref:`DROP INDEX <sql_drop_index>`, which "
#~ "will drop the constraint as well."
#~ msgstr ""

#~ msgid ""
#~ "To remove a unique constraint, use "
#~ ":ref:`DROP INDEX <sql_drop_index>`, which will"
#~ " drop the constraint as well."
#~ msgstr ""

#~ msgid ""
#~ "-- dropping a constraint:\n"
#~ "ALTER TABLE t1 DROP CONSTRAINT \"fk_unnamed_JJ2_1\";"
#~ msgstr ""

#~ msgid ""
#~ "For ``ALTER ... ENABLE|DISABLE CHECK "
#~ "CONSTRAINT``, it is only legal to "
#~ "enable or disable a named constraint,"
#~ " and Tarantool only looks for names"
#~ " of check constraints. By default a"
#~ " constraint is enabled. If a "
#~ "constraint is disabled, then the check"
#~ " will not be performed."
#~ msgstr ""

#~ msgid ""
#~ "-- disabling and re-enabling a constraint:\n"
#~ "ALTER TABLE t1 DISABLE CHECK CONSTRAINT c;\n"
#~ "ALTER TABLE t1 ENABLE CHECK CONSTRAINT c;"
#~ msgstr ""

#~ msgid "Limitations:"
#~ msgstr "Администрирование"

#~ msgid "It is not possible to add or drop a column."
#~ msgstr ""

#~ msgid ""
#~ "It is not possible to modify NOT"
#~ " NULL constraints or column properties "
#~ "DEFAULT and :ref:`data type "
#~ "<sql_column_def_data_type>`. However, it is "
#~ "possible to modify them with "
#~ "Tarantool/NOSQL, for example by calling "
#~ ":ref:`space_object:format() <box_space-format>` with"
#~ " a different ``is_nullable`` value."
#~ msgstr ""

#~ msgid "CREATE TABLE"
#~ msgstr "Тип возвращаемого значения: таблица"

#~ msgid ""
#~ ":samp:`CREATE TABLE [IF NOT EXISTS] "
#~ "{table-name} (column-definition or "
#~ "table-constraint list)` :samp:`[WITH ENGINE "
#~ "= {string}];`"
#~ msgstr ""

#~ msgid "Create a new base table, usually called a \"table\"."
#~ msgstr ""

#~ msgid ""
#~ "A table is a *base table* if "
#~ "it is created with CREATE TABLE "
#~ "and contains data in persistent storage."
#~ msgstr ""

#~ msgid ""
#~ "A table is a *viewed table*, or"
#~ " just \"view\", if it is created "
#~ "with :ref:`CREATE VIEW <sql_create_view>` and"
#~ " gets its data from other views "
#~ "or from base tables."
#~ msgstr ""

#~ msgid ""
#~ "The *table-name* must be an "
#~ "identifier which is valid according to"
#~ " the rules for identifiers, and must"
#~ " not be the name of an already"
#~ " existing base table or view."
#~ msgstr ""

#~ msgid ""
#~ "The *column-definition* or *table-"
#~ "constraint* list is a comma-separated"
#~ " list of :ref:`column definitions "
#~ "<sql_column_def>` or :ref:`table constraint "
#~ "definitions <sql_table_constraint_def>`. Column "
#~ "definitions and table constraint definitions"
#~ " are sometimes called *table elements*."
#~ msgstr ""

#~ msgid "Rules:"
#~ msgstr "true"

#~ msgid ""
#~ "A primary key is necessary; it can"
#~ " be specified with a table constraint"
#~ " PRIMARY KEY."
#~ msgstr ""

#~ msgid "There must be at least one column."
#~ msgstr ""

#~ msgid ""
#~ "When IF NOT EXISTS is specified, "
#~ "and there is already a table with"
#~ " the same name, the statement is "
#~ "ignored."
#~ msgstr ""

#~ msgid ""
#~ "When :samp:`WITH ENGINE = {string}` is"
#~ " specified, where :samp:`{string}` must be"
#~ " either 'memtx' or 'vinyl', the table"
#~ " is created with that :ref:`storage "
#~ "engine <engines-chapter>`. When this "
#~ "clause is not specified, the table "
#~ "is created with the default engine, "
#~ "which is ordinarily 'memtx' but may "
#~ "be changed by updating the "
#~ ":ref:`box.space._session_settings <box_space-"
#~ "session_settings>` system table.."
#~ msgstr ""

#~ msgid "Actions:"
#~ msgstr "функция"

#~ msgid ""
#~ "Tarantool evaluates each column definition "
#~ "and table-constraint, and returns an "
#~ "error if any of the rules is "
#~ "violated."
#~ msgstr ""

#~ msgid "Tarantool makes a new definition in the schema."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool makes new indexes for PRIMARY"
#~ " KEY or UNIQUE constraints. A unique"
#~ " index name is created automatically."
#~ msgstr ""

#~ msgid ""
#~ "Usually Tarantool effectively executes a "
#~ ":ref:`COMMIT <sql_commit>` statement."
#~ msgstr ""

#~ msgid ""
#~ "-- the simplest form, with one column and one constraint:\n"
#~ "CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
#~ "\n"
#~ "-- you can see the effect of the statement by querying\n"
#~ "-- Tarantool system spaces:\n"
#~ "SELECT * FROM \"_space\" WHERE \"name\" = 'T1';\n"
#~ "SELECT * FROM \"_index\" JOIN \"_space\""
#~ " ON \"_index\".\"id\" = \"_space\".\"id\"\n"
#~ "         WHERE \"_space\".\"name\" = 'T1';\n"
#~ "\n"
#~ "-- variation of the simplest form, with delimited identifiers\n"
#~ "-- and a bracketed comment:\n"
#~ "CREATE TABLE \"T1\" (\"S1\" INT /* "
#~ "synonym of INTEGER */, PRIMARY KEY "
#~ "(\"S1\"));\n"
#~ "\n"
#~ "-- two columns, one named constraint\n"
#~ "CREATE TABLE t1 (s1 INTEGER, s2 "
#~ "STRING, CONSTRAINT pk_s1s2_t1_1 PRIMARY KEY"
#~ " (s1, s2));"
#~ msgstr ""

#~ msgid "The maximum number of columns is 2000."
#~ msgstr "максимальное количество показываемых сегментов"

#~ msgid ""
#~ "The maximum length of a row "
#~ "depends on the :ref:`memtx_max_tuple_size "
#~ "<cfg_storage-memtx_max_tuple_size>` or "
#~ ":ref:`vinyl_max_tuple_size  <cfg_storage-"
#~ "memtx_max_tuple_size>` configuration option."
#~ msgstr ""

#~ msgid "Column definition"
#~ msgstr "Простые функции"

#~ msgid ":samp:`column-name data-type [, column-constraint]`"
#~ msgstr ""

#~ msgid ""
#~ "Define a column, which is a "
#~ "table-element used in a :ref:`CREATE "
#~ "TABLE <sql_create_table>` statement."
#~ msgstr ""

#~ msgid ""
#~ "The ``column-name`` must be an "
#~ "identifier which is valid according to"
#~ " the rules for identifiers."
#~ msgstr ""

#~ msgid "Each ``column-name`` must be unique within a table."
#~ msgstr ""

#~ msgid "Column definition -- data type"
#~ msgstr ""

#~ msgid ""
#~ "Every column has a data type: "
#~ "BOOLEAN or DOUBLE or INTEGER or "
#~ "NUMBER or SCALAR or STRING or "
#~ "UNSIGNED or VARBINARY. The detailed "
#~ "description of data types is in "
#~ "the section :ref:`Operands <sql_operands>`."
#~ msgstr ""

#~ msgid "Column definition -- the rules for the SCALAR data type"
#~ msgstr ""

#~ msgid ""
#~ "SCALAR is a \"complex\" data type, "
#~ "unlike all the other data types "
#~ "which are \"primitive\". Two column "
#~ "values in a SCALAR column can have"
#~ " two different primitive data types."
#~ msgstr ""

#~ msgid ""
#~ "Any item defined as SCALAR has an"
#~ " underlying primitive type. For example,"
#~ " here:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
#~ "INSERT INTO t VALUES (55), ('41');"
#~ msgstr ""

#~ msgid ""
#~ "the underlying primitive type of the "
#~ "item in the first row is INTEGER"
#~ " because literal 55 has data type "
#~ "INTEGER, and the underlying primitive "
#~ "type in the second row is STRING"
#~ " (the data type of a literal is"
#~ " always clear from its format)."
#~ msgstr ""

#~ msgid ""
#~ "An item's primitive type is far "
#~ "more important than its defined type."
#~ " Incidentally Tarantool might find the "
#~ "primitive type by looking at the "
#~ "way MsgPack stores it, but that is"
#~ " an implementation detail."
#~ msgstr ""

#~ msgid ""
#~ "A SCALAR definition may not include "
#~ "a maximum length, as there is no"
#~ " suggested restriction."
#~ msgstr ""

#~ msgid ""
#~ "A SCALAR definition may include a "
#~ ":ref:`COLLATE clause <sql_collate_clause>`, which"
#~ " affects any items whose primitive "
#~ "data type is STRING. The default "
#~ "collation is \"binary\"."
#~ msgstr ""

#~ msgid ""
#~ "Some assignments are illegal when data"
#~ " types differ, but legal when the "
#~ "target is a SCALAR item. For "
#~ "example ``UPDATE ... SET column1 = "
#~ "'a'`` is illegal if ``column1`` is "
#~ "defined as INTEGER, but is legal "
#~ "if ``column1`` is defined as SCALAR "
#~ "-- values which happen to be "
#~ "INTEGER will be changed so their "
#~ "data type is STRING."
#~ msgstr ""

#~ msgid "There is no literal syntax which implies data type SCALAR."
#~ msgstr ""

#~ msgid ""
#~ "TYPEOF(x) is never SCALAR, it is "
#~ "always the underlying data type. This"
#~ " is true even if ``x`` is NULL"
#~ " (in that case the data type is"
#~ " BOOLEAN). In fact there is no "
#~ "function that is guaranteed to return"
#~ " the defined data type. For example,"
#~ " ``TYPEOF(CAST(1 AS SCALAR));`` returns "
#~ "INTEGER, not SCALAR."
#~ msgstr ""

#~ msgid ""
#~ "For any operation that requires implicit"
#~ " casting from an item defined as "
#~ "SCALAR, the syntax is legal but "
#~ "the operation may fail at runtime. "
#~ "At runtime, Tarantool detects the "
#~ "underlying primitive data type and "
#~ "applies the rules for that. For "
#~ "example, if a definition is:"
#~ msgstr ""

#~ msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY, s2 INTEGER);"
#~ msgstr ""

#~ msgid ""
#~ "and within any row ``s1 = 'a'``,"
#~ " that is, its underlying primitive "
#~ "type is STRING to indicate character "
#~ "strings, then ``UPDATE t SET s2 ="
#~ " s1;`` is illegal. Tarantool usually "
#~ "does not know that in advance."
#~ msgstr ""

#~ msgid ""
#~ "For any dyadic operation that requires"
#~ " implicit casting for comparison, the "
#~ "syntax is legal and the operation "
#~ "will not fail at runtime. Take "
#~ "this situation: comparison with a "
#~ "primitive type VARBINARY and a primitive"
#~ " type STRING."
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
#~ "INSERT INTO t VALUES (X'41');\n"
#~ "SELECT * FROM t WHERE s1 > 'a';"
#~ msgstr ""

#~ msgid ""
#~ "The comparison is valid, because "
#~ "Tarantool knows the ordering of X'41'"
#~ " and 'a' in Tarantool/NoSQL 'scalar'."
#~ msgstr ""

#~ msgid ""
#~ "The result data type of :ref:`min/max"
#~ " <sql_aggregate>` operation on a column "
#~ "defined as SCALAR is the data type"
#~ " of the minimum/maximum operand, unless "
#~ "the result value is NULL. For "
#~ "example:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t (s1 INTEGER, s2 SCALAR PRIMARY KEY);\n"
#~ "INSERT INTO t VALUES (1, X'44'), (2, 11), (3, 1E4), (4, 'a');\n"
#~ "SELECT min(s2), hex(max(s2)) FROM t;"
#~ msgstr ""

#~ msgid "The result is: ``- - [11, '44',]``"
#~ msgstr ""

#~ msgid ""
#~ "That is only possible with "
#~ "Tarantool/NoSQL scalar rules, but ``SELECT "
#~ "SUM(s2)`` would not be legal because "
#~ "addition would in this case require "
#~ "implicit casting from VARBINARY to a "
#~ "number, which is not sensible."
#~ msgstr ""

#~ msgid ""
#~ "The result data type of a "
#~ "primitive combination is never SCALAR "
#~ "because we in effect use TYPEOF(item)"
#~ " not the defined data type. (Here "
#~ "we use the word \"combination\" in "
#~ "the way that the standard document "
#~ "uses it for section \"Result of "
#~ "data type combinations\".) Therefore for "
#~ "``greatest(1E308, 'a', 0, X'00')`` the "
#~ "result is X'00'."
#~ msgstr ""

#~ msgid "Column definition -- relation to NoSQL"
#~ msgstr ""

#~ msgid ""
#~ "All the SQL data types correspond "
#~ "to :ref:`Tarantool/NoSQL types with the "
#~ "same name <box_space-index_field_types>`. For"
#~ " example an SQL STRING is stored "
#~ "in a NoSQL space as type = "
#~ "'string'."
#~ msgstr ""

#~ msgid ""
#~ "Therefore specifying an SQL data type"
#~ " X determines that the storage will"
#~ " be in a space with a format"
#~ " column saying that the NoSQL type"
#~ " is 'x'."
#~ msgstr ""

#~ msgid "The rules for that NoSQL type are applicable to the SQL data type."
#~ msgstr ""

#~ msgid ""
#~ "If two items have SQL data types"
#~ " that have the same underlying type,"
#~ " then they are compatible for all "
#~ "assignment or comparison purposes."
#~ msgstr ""

#~ msgid ""
#~ "If two items have SQL data types"
#~ " that have different underlying types, "
#~ "then the rules for explicit casts, "
#~ "or implicit (assignment) casts, or "
#~ "implicit (comparison) casts, apply."
#~ msgstr ""

#~ msgid ""
#~ "There is one floating-point value "
#~ "which is not handled by SQL: -nan"
#~ " is seen as NULL."
#~ msgstr ""

#~ msgid ""
#~ "There are also some Tarantool/NoSQL data"
#~ " types which have no corresponding "
#~ "SQL data types. For example, ``SELECT"
#~ " \"flags\" FROM \"_space\";`` will return"
#~ " a column whose data type is "
#~ "'map'. Such columns can only be "
#~ "manipulated in SQL by :ref:`invoking Lua"
#~ " functions <sql_calling_lua>`."
#~ msgstr ""

#~ msgid "Column definition -- column-constraint or default clause"
#~ msgstr ""

#~ msgid "The column-constraint or default clause may be as follows:"
#~ msgstr ""

#~ msgid "Type"
#~ msgstr "тип возвращаемого значения"

#~ msgid "Comment"
#~ msgstr ""

#~ msgid "NOT NULL"
#~ msgstr "null"

#~ msgid "means \"it is illegal to assign a NULL to this column\""
#~ msgstr ""

#~ msgid "PRIMARY KEY"
#~ msgstr ""

#~ msgid ""
#~ "explained in the later section "
#~ ":ref:`\"Table Constraint Definition\" "
#~ "<sql_table_constraint_def>`"
#~ msgstr ""

#~ msgid "UNIQUE"
#~ msgstr ""

#~ msgid "explained in the later section \"Table Constraint Definition\""
#~ msgstr ""

#~ msgid "CHECK (expression)"
#~ msgstr ""

#~ msgid "foreign-key-clause"
#~ msgstr ""

#~ msgid ""
#~ "explained in the later section "
#~ ":ref:`\"Table Constraint Definition for "
#~ "foreign keys\" <sql_foreign_key>`"
#~ msgstr ""

#~ msgid "DEFAULT expression"
#~ msgstr ""

#~ msgid ""
#~ "means \"if INSERT does not assign "
#~ "to this column then assign expression"
#~ " result to this column\" -- if "
#~ "there is no DEFAULT clause then "
#~ "DEFAULT NULL is assumed."
#~ msgstr ""

#~ msgid ""
#~ "If column-constraint is PRIMARY KEY, "
#~ "this is a shorthand for a separate"
#~ " :ref:`table-constraint definition "
#~ "<sql_table_constraint_def>`: \"PRIMARY KEY "
#~ "(column-name)\"."
#~ msgstr ""

#~ msgid ""
#~ "If column-constraint is UNIQUE, this "
#~ "is a shorthand for a separate :ref"
#~ ":`table-constraint definition "
#~ "<sql_table_constraint_def>`: \"UNIQUE (column-"
#~ "name)\"."
#~ msgstr ""

#~ msgid ""
#~ "If column-constraint is CHECK, this "
#~ "is a shorthand for a separate :ref"
#~ ":`table-constraint definition "
#~ "<sql_table_constraint_def>`: \"CHECK (expression)\"."
#~ msgstr ""

#~ msgid "Columns defined with PRIMARY KEY are automatically NOT NULL."
#~ msgstr ""

#~ msgid ""
#~ "To enforce some restrictions that "
#~ "Tarantool does not enforce automatically, "
#~ "add CHECK clauses, like these:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t (\"smallint\" INTEGER "
#~ "PRIMARY KEY CHECK (\"smallint\" <= 32767"
#~ " AND \"smallint\" >= -32768));\n"
#~ "CREATE TABLE t (\"shorttext\" STRING "
#~ "PRIMARY KEY CHECK (length(\"shorttext\") <="
#~ " 10));"
#~ msgstr ""

#~ msgid "but this may cause inserts or updates to be slow."
#~ msgstr ""

#~ msgid "Column definition -- examples"
#~ msgstr ""

#~ msgid ""
#~ "These are shown within :ref:`CREATE "
#~ "TABLE <sql_create_table>` statements. Data "
#~ "types may also appear in :ref:`CAST "
#~ "<sql_function_cast>` functions."
#~ msgstr ""

#~ msgid ""
#~ "-- the simple form with column-name and data-type\n"
#~ "CREATE TABLE t (column1 INTEGER ...);\n"
#~ "-- with column-name and data-type and column-constraint\n"
#~ "CREATE TABLE t (column1 STRING PRIMARY KEY ...);\n"
#~ "-- with column-name and data-type and collate-clause\n"
#~ "CREATE TABLE t (column1 SCALAR COLLATE \"unicode\" ...);"
#~ msgstr ""

#~ msgid ""
#~ "-- with all possible data types and aliases\n"
#~ "CREATE TABLE t\n"
#~ "(column1 BOOLEAN, column2 BOOL,\n"
#~ " column3 INT PRIMARY KEY, column4 INTEGER,\n"
#~ " column5 DOUBLE,\n"
#~ " column6 NUMBER,\n"
#~ " column7 STRING, column8 STRING COLLATE \"unicode\",\n"
#~ " column9 TEXT, columna TEXT COLLATE \"unicode_sv_s1\",\n"
#~ " columnb VARCHAR(0), columnc VARCHAR(100000) COLLATE \"binary\",\n"
#~ " columnd VARBINARY,\n"
#~ " columne SCALAR, columnf SCALAR COLLATE \"unicode_uk_s2\");"
#~ msgstr ""

#~ msgid ""
#~ "-- with all possible column constraints and a default clause\n"
#~ "CREATE TABLE t\n"
#~ "(column1 INTEGER NOT NULL,\n"
#~ " column2 INTEGER PRIMARY KEY,\n"
#~ " column3 INTEGER UNIQUE,\n"
#~ " column4 INTEGER CHECK (column3 > column2),\n"
#~ " column5 INTEGER REFERENCES t,\n"
#~ " column6 INTEGER DEFAULT NULL);"
#~ msgstr ""

#~ msgid "Table Constraint Definition"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`[CONSTRAINT {constraint-name}] primary-"
#~ "key-constraint | unique-constraint | "
#~ "check-constraint | foreign-key-constraint`"
#~ msgstr ""

#~ msgid ""
#~ "Define a constraint, which is a "
#~ "table-element used in a CREATE TABLE"
#~ " statement."
#~ msgstr ""

#~ msgid ""
#~ "The constraint-name must be an "
#~ "identifier which is valid according to"
#~ " the rules for identifiers. The "
#~ "constraint-name must be unique within "
#~ "the table."
#~ msgstr ""

#~ msgid ""
#~ "PRIMARY KEY constraints look like this:"
#~ " |br| :samp:`PRIMARY KEY ({column-name} "
#~ "[, {column-name}...])`"
#~ msgstr ""

#~ msgid ""
#~ "There is a shorthand: specifying PRIMARY"
#~ " KEY in a :ref:`column definition "
#~ "<sql_column_def_constraint>`."
#~ msgstr ""

#~ msgid ""
#~ "Every table must have one and only"
#~ " one primary key. |br| Primary-key"
#~ " columns are automatically NOT NULL. "
#~ "|br| Primary-key columns are "
#~ "automatically indexed. |br| Primary-key "
#~ "columns are unique, that is, it is"
#~ " illegal to have two rows which "
#~ "have the same values for the "
#~ "columns specified in the constraint."
#~ msgstr ""

#~ msgid ""
#~ "-- this is a table with a one-column primary-key constraint\n"
#~ "CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
#~ "-- this is the column-definition shorthand for the same thing:\n"
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY);\n"
#~ "-- this is a table with a two-column primary-key constraint\n"
#~ "CREATE TABLE t2 (s1 INTEGER, s2 INTEGER, PRIMARY KEY (s1, s2));\n"
#~ "-- this is an example of an attempted primary-key violation\n"
#~ "-- (the third INSERT will fail because 55, 'a' is a duplicate)\n"
#~ "CREATE TABLE t3 (s1 INTEGER, s2 STRING, PRIMARY KEY (s1, s2));\n"
#~ "INSERT INTO t3 VALUES (55, 'a');\n"
#~ "INSERT INTO t3 VALUES (55, 'b');\n"
#~ "INSERT INTO t3 VALUES (55, 'a');"
#~ msgstr ""

#~ msgid ""
#~ "PRIMARY KEY plus AUTOINCREMENT modifier "
#~ "may be specified in one of two "
#~ "ways: |br| - In a column "
#~ "definition after the words PRIMARY KEY,"
#~ " as in ``CREATE TABLE t (c "
#~ "INTEGER PRIMARY KEY AUTOINCREMENT);`` |br| "
#~ "- In a PRIMARY KEY (column-list)"
#~ " after a column name, as in "
#~ "``CREATE TABLE t (c INTEGER, PRIMARY "
#~ "KEY (c AUTOINCREMENT));`` |br| When "
#~ "AUTOINCREMENT is specified, the column "
#~ "must be a primary-key column and"
#~ " it must be INTEGER or UNSIGNED. "
#~ "|br| Only one column in the table"
#~ " may be autoincrement. However, it is"
#~ " legal to say ``PRIMARY KEY (a, "
#~ "b, c AUTOINCREMENT)`` -- in that "
#~ "case, there are three columns in "
#~ "the primary key but only the first"
#~ " column (``a``) is AUTOINCREMENT."
#~ msgstr ""

#~ msgid ""
#~ "As the name suggests, values in an"
#~ " autoincrement column are automatically "
#~ "incremented. That is: if a user "
#~ "inserts NULL in the column, then "
#~ "the stored value will be the "
#~ "smallest non-negative integer that has"
#~ " not already been used. This occurs"
#~ " because autoincrement columns are "
#~ "associated with :ref:`sequences <box_schema-"
#~ "sequence_create_index>`."
#~ msgstr ""

#~ msgid ""
#~ "UNIQUE constraints look like this: |br|"
#~ " :samp:`UNIQUE ({column-name} [, "
#~ "{column-name}...])`"
#~ msgstr ""

#~ msgid ""
#~ "There is a shorthand: specifying UNIQUE"
#~ " in a :ref:`column definition "
#~ "<sql_column_def_constraint>`."
#~ msgstr ""

#~ msgid ""
#~ "Unique constraints are similar to "
#~ "primary-key constraints, except that: a "
#~ "table may have any number of "
#~ "unique keys, and unique keys are "
#~ "not automatically NOT NULL. |br| Unique"
#~ " columns are automatically indexed. |br|"
#~ " Unique columns are unique, that is,"
#~ " it is illegal to have two rows"
#~ " with the same values in the "
#~ "unique-key columns."
#~ msgstr ""

#~ msgid ""
#~ "-- this is a table with a one-column primary-key constraint\n"
#~ "-- and a one-column unique constraint\n"
#~ "CREATE TABLE t1 (s1 INTEGER, s2 "
#~ "INTEGER, PRIMARY KEY (s1), UNIQUE (s2));"
#~ "\n"
#~ "-- this is the column-definition shorthand for the same thing:\n"
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER UNIQUE);\n"
#~ "-- this is a table with a two-column unique constraint\n"
#~ "CREATE TABLE t2 (s1 INTEGER PRIMARY "
#~ "KEY, s2 INTEGER, UNIQUE (s2, s1));\n"
#~ ""
#~ "-- this is an example of an attempted unique-key violation\n"
#~ "-- (the third INSERT will not fail because NULL is not a duplicate)\n"
#~ "-- (the fourth INSERT will fail because 'a' is a duplicate)\n"
#~ "CREATE TABLE t3 (s1 INTEGER PRIMARY KEY, s2 STRING, UNIQUE (s2));\n"
#~ "INSERT INTO t3 VALUES (1, 'a');\n"
#~ "INSERT INTO t3 VALUES (2, NULL);\n"
#~ "INSERT INTO t3 VALUES (3, NULL);\n"
#~ "INSERT INTO t3 VALUES (4, 'a');"
#~ msgstr ""

#~ msgid "CHECK constraints look like this: |br| :samp:`CHECK ({expression})`"
#~ msgstr ""

#~ msgid ""
#~ "There is a shorthand: specifying CHECK"
#~ " in a :ref:`column definition "
#~ "<sql_column_def_constraint>`."
#~ msgstr ""

#~ msgid ""
#~ "The expression may be anything that "
#~ "returns a BOOLEAN result = TRUE or"
#~ " FALSE or UNKNOWN. |br| The "
#~ "expression may not contain a "
#~ ":ref:`subquery <sql_subquery>`. |br| If the"
#~ " expression contains a column name, "
#~ "the column must exist in the "
#~ "table. |br| If a CHECK constraint "
#~ "is specified, the table must not "
#~ "contain rows where the expression is "
#~ "FALSE. (The table may contain rows "
#~ "where the expression is either TRUE "
#~ "or UNKNOWN.) |br| Constraint checking "
#~ "may be stopped with :ref:`ALTER TABLE"
#~ " ... DISABLE CHECK CONSTRAINT "
#~ "<sql_alter_table>` and restarted with ALTER"
#~ " TABLE ... ENABLE CHECK CONSTRAINT."
#~ msgstr ""

#~ msgid ""
#~ "-- this is a table with a one-column primary-key constraint\n"
#~ "-- and a check constraint\n"
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY "
#~ "KEY, s2 INTEGER, CHECK (s2 <> "
#~ "s1));\n"
#~ "-- this is an attempt to violate the constraint, it will fail\n"
#~ "INSERT INTO t1 VALUES (1, 1);\n"
#~ "-- this is okay because comparison with NULL will not return FALSE\n"
#~ "INSERT INTO t1 VALUES (1, NULL);\n"
#~ "-- a constraint that makes it difficult to insert lower case\n"
#~ "CHECK (s1 = UPPER(s1))"
#~ msgstr ""

#~ msgid ""
#~ "Limitations: (`Issue#3503 "
#~ "<https://github.com/tarantool/tarantool/issues/3503>`_): |br|"
#~ " * ``CREATE TABLE t99 (s1 INTEGER,"
#~ " UNIQUE(s1, s1),PRIMARY KEY(s1));`` causes "
#~ "no error message, although (s1, s1) "
#~ "is probably a user error."
#~ msgstr ""

#~ msgid "Table Constraint Definition for foreign keys"
#~ msgstr ""

#~ msgid ""
#~ "FOREIGN KEY constraints look like this:"
#~ " |br| :samp:`FOREIGN KEY ({referencing-"
#~ "column-name} [, {referencing-column-"
#~ "name}...]) REFERENCES {referenced-table-name}"
#~ " [({referenced-column-name} [, "
#~ "{referenced-column-name}...]]) [MATCH FULL] "
#~ "[update-or-delete-rules]`"
#~ msgstr ""

#~ msgid ""
#~ "There is a shorthand: specifying "
#~ "REFERENCES in a :ref:`column definition "
#~ "<sql_column_def_constraint>`."
#~ msgstr ""

#~ msgid ""
#~ "The referencing column names must be "
#~ "defined in the table that is being"
#~ " created. The referenced table name "
#~ "must refer to a table that already"
#~ " exists, or to the table that "
#~ "is being created. The referenced column"
#~ " names must be defined in the "
#~ "referenced table, and have similar data"
#~ " types. There must be a PRIMARY "
#~ "KEY or UNIQUE constraint or UNIQUE "
#~ "index on the referenced column names."
#~ msgstr ""

#~ msgid "The words MATCH FULL are optional and have no effect."
#~ msgstr ""

#~ msgid ""
#~ "If a foreign-key constraint exists, "
#~ "then the values in the referencing "
#~ "columns must equal values in the "
#~ "referenced columns of the referenced "
#~ "table, or at least one of the "
#~ "referencing columns must contain NULL."
#~ msgstr ""

#~ msgid ""
#~ "-- A foreign key referencing a primary key in the same table\n"
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY "
#~ "KEY, s2 INTEGER, FOREIGN KEY (s2) "
#~ "REFERENCES t1 (s1));\n"
#~ "-- The same thing with column shorthand\n"
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY "
#~ "KEY, s2 INTEGER REFERENCES t1(s1));\n"
#~ "-- An attempt to violate the constraint -- this will fail\n"
#~ "INSERT INTO t1 VALUES (1, 2);\n"
#~ "-- A NULL in the referencing column -- this will succeed\n"
#~ "INSERT INTO t1 VALUES (1, NULL);\n"
#~ "-- A reference to a primary key that now exists -- this will succeed\n"
#~ "INSERT INTO t1 VALUES (2, 1);"
#~ msgstr ""

#~ msgid ""
#~ "The optional update-or-delete rules "
#~ "look like this: |br| ``ON "
#~ "{UPDATE|DELETE} { CASCADE | SET DEFAULT"
#~ " | SET NULL | RESTRICT | NO "
#~ "ACTION}`` |br| and the idea is: if"
#~ " something changes the referenced key, "
#~ "then one of these possible \"referential"
#~ " actions\" takes place: |br| ``CASCADE``:"
#~ " the change that is applied for "
#~ "the referenced key is applied for "
#~ "the referencing key. |br| ``SET "
#~ "DEFAULT``: the referencing key is set"
#~ " to its default value. |br| ``SET "
#~ "NULL``: the referencing key is set "
#~ "to NULL. |br| ``RESTRICT``: the UPDATE"
#~ " or DELETE fails if a referencing "
#~ "key exists; checked immediately. |br| "
#~ "``NO ACTION``: the UPDATE or DELETE "
#~ "fails if a referencing key exists; "
#~ "checked at statement end. |br| The "
#~ "default is ``NO ACTION``."
#~ msgstr ""

#~ msgid "For example:"
#~ msgstr "Пример:"

#~ msgid ""
#~ "CREATE TABLE f1 (ordinal INTEGER PRIMARY KEY,\n"
#~ "             referenced_planet STRING UNIQUE NOT NULL);\n"
#~ "CREATE TABLE f2 (\n"
#~ "    ordinal INTEGER PRIMARY KEY,\n"
#~ "    referring_planet STRING DEFAULT 'Earth',\n"
#~ "    FOREIGN KEY (referring_planet) REFERENCES f1 (referenced_planet)\n"
#~ "        ON UPDATE SET DEFAULT\n"
#~ "        ON DELETE CASCADE);\n"
#~ "INSERT INTO f1 VALUES (1, 'Mercury'), (2,' Venus'), (3, 'Earth');\n"
#~ "INSERT INTO f2 VALUES (1, 'Mercury'), (2, 'Mercury');\n"
#~ "UPDATE f1 SET referenced_planet = 'Mars'\n"
#~ "    WHERE referenced_planet = 'Mercury';\n"
#~ "SELECT * FROM f2;\n"
#~ "DELETE FROM f1 WHERE referenced_planet = 'Earth';\n"
#~ "SELECT * FROM f2;\n"
#~ "... In this example, the UPDATE statement changes the referenced key,\n"
#~ "    and the clause is ON UPDATE SET DEFAULT, therefore both of the\n"
#~ "    rows in f2 have referring_planet set to their default value,\n"
#~ "    which is 'Earth'. The DELETE statement deletes the row that\n"
#~ "    has 'Earth', and the clause is ON DELETE CASCADE,\n"
#~ "    therefore both of the rows in f2 are deleted."
#~ msgstr ""

#~ msgid ""
#~ "Limitations: |br| * Foreign keys can "
#~ "have a MATCH clause (`Issue#3455 "
#~ "<https://github.com/tarantool/tarantool/issues/3455>`_)."
#~ msgstr ""

#~ msgid "DROP TABLE"
#~ msgstr "Тип возвращаемого значения: таблица"

#~ msgid ":samp:`DROP TABLE [IF EXISTS] {table-name};`"
#~ msgstr ""

#~ msgid "Drop a table."
#~ msgstr "Тип возвращаемого значения: таблица"

#~ msgid ""
#~ "The *table-name* must identify a "
#~ "table that was created earlier with "
#~ "the :ref:`CREATE TABLE statement "
#~ "<sql_create_table>`."
#~ msgstr ""

#~ msgid ""
#~ "If there is a view that references"
#~ " the table, the drop will fail. "
#~ "Please drop the referencing view with"
#~ " :ref:`DROP VIEW <sql_drop_view>` first."
#~ msgstr ""

#~ msgid ""
#~ "If there is a foreign key that "
#~ "references the table, the drop will "
#~ "fail. Please drop the referencing "
#~ "constraint with :ref:`ALTER TABLE ... "
#~ "DROP <sql_alter_table_drop_constraint>` first."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool returns an error if the "
#~ "table does not exist and there is"
#~ " no ``IF EXISTS`` clause."
#~ msgstr ""

#~ msgid "The table and all its data are dropped."
#~ msgstr ""

#~ msgid "All indexes for the table are dropped."
#~ msgstr ""

#~ msgid "All triggers for the table are dropped."
#~ msgstr ""

#~ msgid ""
#~ "-- the simple case:\n"
#~ "DROP TABLE t31;\n"
#~ "-- with an IF EXISTS clause:\n"
#~ "DROP TABLE IF EXISTS t31;"
#~ msgstr ""

#~ msgid "See also: :ref:`DROP VIEW <sql_drop_view>`."
#~ msgstr ""

#~ msgid "CREATE VIEW"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`CREATE VIEW [IF NOT EXISTS] "
#~ "{view-name} [(column-list)] AS subquery;`"
#~ msgstr ""

#~ msgid "Create a new viewed table, usually called a \"view\"."
#~ msgstr ""

#~ msgid "The *view-name* must be valid according to the rules for identifiers."
#~ msgstr ""

#~ msgid ""
#~ "The optional *column-list* must be "
#~ "a comma-separated list of names of"
#~ " columns in the view."
#~ msgstr ""

#~ msgid ""
#~ "The syntax of the subquery must be"
#~ " the same as the syntax of a"
#~ " :ref:`SELECT statement <sql_select>`, or "
#~ "of a VALUES clause."
#~ msgstr ""

#~ msgid ""
#~ "There must not already be a base"
#~ " table or view with the same "
#~ "name as *view-name*."
#~ msgstr ""

#~ msgid ""
#~ "If *column-list* is specified, the "
#~ "number of columns in *column-list* "
#~ "must be the same as the number "
#~ "of columns in the :ref:`select list "
#~ "<sql_select_list>` of the subquery."
#~ msgstr ""

#~ msgid "Tarantool will throw an error if a rule is violated."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool will create a new persistent"
#~ " object with *column-names* equal to"
#~ " the names in the *column-list* "
#~ "or the names in the subquery's "
#~ "*select list*."
#~ msgstr ""

#~ msgid ""
#~ "-- the simple case:\n"
#~ "CREATE VIEW v AS SELECT column1, column2 FROM t;\n"
#~ "-- with a column-list:\n"
#~ "CREATE VIEW v (a,b) AS SELECT column1, column2 FROM t;"
#~ msgstr ""

#~ msgid ""
#~ "It is not possible to insert or"
#~ " update or delete from a view, "
#~ "although sometimes a possible substitution "
#~ "is to :ref:`create an INSTEAD OF "
#~ "trigger <sql_create_trigger>`."
#~ msgstr ""

#~ msgid "DROP VIEW"
#~ msgstr ""

#~ msgid ":samp:`DROP VIEW [IF EXISTS] {view-name};`"
#~ msgstr ""

#~ msgid "Drop a view."
#~ msgstr "Копирование файла"

#~ msgid ""
#~ "The *view-name* must identify a "
#~ "view that was created earlier with "
#~ "the :ref:`CREATE VIEW statement "
#~ "<sql_create_view>`."
#~ msgstr ""

#~ msgid "Rules: none"
#~ msgstr ""

#~ msgid ""
#~ "Tarantool returns an error if the "
#~ "view does not exist and there is"
#~ " no ``IF EXISTS`` clause."
#~ msgstr ""

#~ msgid "The view is dropped."
#~ msgstr ""

#~ msgid "All triggers for the view are dropped."
#~ msgstr ""

#~ msgid ""
#~ "-- the simple case:\n"
#~ "DROP VIEW v31;\n"
#~ "-- with an IF EXISTS clause:\n"
#~ "DROP VIEW IF EXISTS v31;"
#~ msgstr ""

#~ msgid "See also: :ref:`DROP TABLE <sql_drop_table>`."
#~ msgstr ""

#~ msgid "CREATE INDEX"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`CREATE [UNIQUE] INDEX [IF NOT "
#~ "EXISTS] {index-name} ON {table-name} "
#~ "(column-list);`"
#~ msgstr ""

#~ msgid "Create an index."
#~ msgstr "Создание экземпляра iconv"

#~ msgid "The *index-name* must be valid according to the rules for identifiers."
#~ msgstr ""

#~ msgid "The *table-name* must refer to an existing table."
#~ msgstr ""

#~ msgid ""
#~ "The *column-list* must be a "
#~ "comma-separated list of names of "
#~ "columns in the table."
#~ msgstr ""

#~ msgid ""
#~ "There must not already be, for the"
#~ " same table, an index with the "
#~ "same name as *index-name*. But "
#~ "there may already be, for a "
#~ "different table, an index with the "
#~ "same name as *index-name*."
#~ msgstr ""

#~ msgid "The maximum number of indexes per table is 128."
#~ msgstr "максимальное количество показываемых сегментов"

#~ msgid ""
#~ "If the new index is UNIQUE, "
#~ "Tarantool will throw an error if "
#~ "any row exists with columns that "
#~ "have duplicate values."
#~ msgstr ""

#~ msgid "Tarantool will create a new index."
#~ msgstr ""

#~ msgid "Automatic indexes:"
#~ msgstr ""

#~ msgid ""
#~ "Indexes may be created automatically for"
#~ " columns mentioned in the PRIMARY KEY"
#~ " or UNIQUE clauses of a CREATE "
#~ "TABLE statement. If an index was "
#~ "created automatically, then the *index-"
#~ "name* has four parts:"
#~ msgstr ""

#~ msgid ""
#~ "``pk`` if this is for a PRIMARY"
#~ " KEY clause, ``unique`` if this is"
#~ " for a UNIQUE clause;"
#~ msgstr ""

#~ msgid "``_unnamed_``;"
#~ msgstr ""

#~ msgid "the name of the table;"
#~ msgstr "копия таблицы"

#~ msgid ""
#~ "``_`` and an ordinal number; the "
#~ "first index is 1, the second index"
#~ " is 2, and so on."
#~ msgstr ""

#~ msgid ""
#~ "For example, after ``CREATE TABLE t "
#~ "(s1 INTEGER PRIMARY KEY, s2 INTEGER, "
#~ "UNIQUE (s2));`` there are two indexes"
#~ " named ``pk_unnamed_T_1`` and "
#~ "``unique_unnamed_T_2``. You can confirm this"
#~ " by saying ``SELECT * FROM "
#~ "\"_index\";`` which will list all "
#~ "indexes on all tables. There is no"
#~ " need to say ``CREATE INDEX`` for "
#~ "columns that already have automatic "
#~ "indexes."
#~ msgstr ""

#~ msgid ""
#~ "-- the simple case\n"
#~ "CREATE INDEX idx_column1_t_1 ON t (column1);\n"
#~ "-- with IF NOT EXISTS clause\n"
#~ "CREATE INDEX IF NOT EXISTS idx_column1_t_1 ON t (column1);\n"
#~ "-- with UNIQUE specifier and more than one column\n"
#~ "CREATE UNIQUE INDEX idx_unnamed_t_1 ON t (column1, column2);"
#~ msgstr ""

#~ msgid ""
#~ "Dropping an automatic index created for"
#~ " a unique constraint will drop the"
#~ " unique constraint as well."
#~ msgstr ""

#~ msgid "DROP INDEX"
#~ msgstr ""

#~ msgid ":samp:`DROP INDEX [IF EXISTS] index-name ON {table-name};`"
#~ msgstr ""

#~ msgid ""
#~ "The *index-name* must be the name"
#~ " of an existing index, which was "
#~ "created with :ref:`CREATE INDEX "
#~ "<sql_create_index>`. Or, the *index-name* "
#~ "must be the name of an index "
#~ "that was created automatically due to"
#~ " a PRIMARY KEY or UNIQUE clause "
#~ "in the :ref:`CREATE TABLE <sql_create_table>`"
#~ " statement. To see what a table's "
#~ "indexes are, use :ref:`PRAGMA index_list"
#~ "(table-name); <sql_pragma>`."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool throws an error if the "
#~ "index does not exist, or is an "
#~ "automatically created index."
#~ msgstr ""

#~ msgid "Tarantool will drop the index."
#~ msgstr ""

#~ msgid "Example:"
#~ msgstr "Пример:"

#~ msgid ""
#~ "-- the simplest form:\n"
#~ "DROP INDEX idx_unnamed_t_1 ON t;"
#~ msgstr ""

#~ msgid "INSERT"
#~ msgstr "целое число"

#~ msgid ""
#~ ":samp:`INSERT INTO {table-name} [(column-"
#~ "list)] VALUES (expression-list) [, "
#~ "(expression-list)];`"
#~ msgstr ""

#~ msgid ":samp:`INSERT INTO {table-name} [(column-list)]  select-statement;`"
#~ msgstr ""

#~ msgid ":samp:`INSERT INTO {table-name} DEFAULT VALUES;`"
#~ msgstr ":samp:`db = {имя-базы-данных}` -- строка, по умолчанию пустая"

#~ msgid "Insert one or more new rows into a table."
#~ msgstr ""

#~ msgid ""
#~ "The *table-name* must be a name"
#~ " of a table defined earlier with "
#~ ":ref:`CREATE TABLE <sql_create_table>`."
#~ msgstr ""

#~ msgid ""
#~ "The optional *column-list* must be "
#~ "a comma-separated list of names of"
#~ " columns in the table."
#~ msgstr ""

#~ msgid ""
#~ "The *expression-list* must be a "
#~ "comma-separated list of expressions; each"
#~ " expression may contain literals and "
#~ "operators and subqueries and function "
#~ "invocations."
#~ msgstr ""

#~ msgid "The values in the *expression-list* are evaluated from left to right."
#~ msgstr ""

#~ msgid ""
#~ "The order of the values in the "
#~ "*expression-list* must correspond to the"
#~ " order of the columns in the "
#~ "table, or (if a *column-list* is"
#~ " specified) to the order of the "
#~ "columns in the *column-list*."
#~ msgstr ""

#~ msgid ""
#~ "The data type of the value should"
#~ " correspond to the :ref:`data type of"
#~ " the column <sql_column_def_data_type>`, that "
#~ "is, the data type that was "
#~ "specified with CREATE TABLE."
#~ msgstr ""

#~ msgid ""
#~ "If a *column-list* is not "
#~ "specified, then the number of "
#~ "expressions must be the same as "
#~ "the number of columns in the "
#~ "table."
#~ msgstr ""

#~ msgid ""
#~ "If a *column-list* is specified, "
#~ "then some columns may be omitted; "
#~ "omitted columns will get default values."
#~ msgstr ""

#~ msgid ""
#~ "The parenthesized *expression-list* may "
#~ "be repeated -- ``(expression-list"
#~ "),(expression-list),...`` -- for multiple "
#~ "rows."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool evaluates each expression in "
#~ "*expression-list*, and returns an error "
#~ "if any of the rules is violated."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool creates zero or more new "
#~ "rows containing values based on the "
#~ "values in the VALUES list or based"
#~ " on the results of the *select-"
#~ "expression* or based on the default "
#~ "values."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool executes constraint checks and "
#~ "trigger actions and the actual "
#~ "insertion."
#~ msgstr ""

#~ msgid ""
#~ "-- the simplest form:\n"
#~ "INSERT INTO table1 VALUES (1, 'A');\n"
#~ "-- with a column list:\n"
#~ "INSERT INTO table1 (column1, column2) VALUES (2, 'B');\n"
#~ "-- with an arithmetic operator in the first expression:\n"
#~ "INSERT INTO table1 VALUES (2 + 1, 'C');\n"
#~ "-- put two rows in the table:\n"
#~ "INSERT INTO table1 VALUES (4, 'D'), (5, 'E');"
#~ msgstr ""

#~ msgid "See also: :ref:`REPLACE statement <sql_replace>`."
#~ msgstr ""

#~ msgid "UPDATE"
#~ msgstr "шаблон"

#~ msgid ""
#~ ":samp:`UPDATE {table-name} SET column-"
#~ "name = expression [, column-name ="
#~ " expression ...] [WHERE search-condition];`"
#~ msgstr ""

#~ msgid "Update zero or more existing rows in a table."
#~ msgstr ""

#~ msgid ""
#~ "The *table-name* must be a name"
#~ " of a table defined earlier with "
#~ ":ref:`CREATE TABLE <sql_create_table>` or "
#~ ":ref:`CREATE VIEW <sql_create_view>`."
#~ msgstr ""

#~ msgid "The *column-name* must be an updatable column in the table."
#~ msgstr ""

#~ msgid ""
#~ "The *expression* may contain literals "
#~ "and operators and subqueries and "
#~ "function invocations and column names."
#~ msgstr ""

#~ msgid "The values in the SET clause are evaluated from left to right."
#~ msgstr ""

#~ msgid ""
#~ "If a *search-condition* is not "
#~ "specified, then all rows in the "
#~ "table will be updated; otherwise only"
#~ " those rows which match the "
#~ "*search-condition* will be updated."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool evaluates each expression in "
#~ "the SET clause, and returns an "
#~ "error if any of the rules is "
#~ "violated. For each row that is "
#~ "found by the WHERE clause, a "
#~ "temporary new row is formed based "
#~ "on the original contents and the "
#~ "modifications caused by the SET clause."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool executes constraint checks and "
#~ "trigger actions and the actual update."
#~ msgstr ""

#~ msgid ""
#~ "-- the simplest form:\n"
#~ "UPDATE t SET column1 = 1;\n"
#~ "-- with more than one assignment in the SET clause:\n"
#~ "UPDATE t SET column1 = 1, column2 = 2;\n"
#~ "-- with a WHERE clause:\n"
#~ "UPDATE t SET column1 = 5 WHERE column2 = 6;"
#~ msgstr ""

#~ msgid "Special cases:"
#~ msgstr ""

#~ msgid ""
#~ "It is legal to say SET (list "
#~ "of columns) = (list of values). "
#~ "For example:"
#~ msgstr ""

#~ msgid "UPDATE t SET (column1, column2, column3) = (1, 2, 3);"
#~ msgstr ""

#~ msgid "It is not legal to assign to a column more than once. For example:"
#~ msgstr ""

#~ msgid ""
#~ "INSERT INTO t (column1) VALUES (0);\n"
#~ "UPDATE t SET column1 = column1 + 1, column1 = column1 + 1;"
#~ msgstr ""

#~ msgid "The result is an error: \"duplicate column name\"."
#~ msgstr ""

#~ msgid "It is not legal to assign to a primary-key column."
#~ msgstr ""

#~ msgid "DELETE"
#~ msgstr ""

#~ msgid ":samp:`DELETE FROM {table-name} [WHERE search-condition];`"
#~ msgstr ""

#~ msgid "Delete zero or more existing rows in a table."
#~ msgstr ""

#~ msgid ""
#~ "The *search-condition* may contain "
#~ "literals and operators and subqueries "
#~ "and function invocations and column "
#~ "names."
#~ msgstr ""

#~ msgid ""
#~ "If a search-condition is not "
#~ "specified, then all rows in the "
#~ "table will be deleted; otherwise only"
#~ " those rows which match the "
#~ "*search-condition* will be deleted."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool evaluates each expression in "
#~ "the *search-condition*, and returns an"
#~ " error if any of the rules is"
#~ " violated."
#~ msgstr ""

#~ msgid "Tarantool finds the set of rows that are to be deleted."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool executes constraint checks and "
#~ "trigger actions and the actual deletion."
#~ msgstr ""

#~ msgid ""
#~ "-- the simplest form:\n"
#~ "DELETE FROM t;\n"
#~ "-- with a WHERE clause:\n"
#~ "DELETE FROM t WHERE column2 = 6;"
#~ msgstr ""

#~ msgid "REPLACE"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`REPLACE INTO {table-name} [(column-"
#~ "list)] VALUES (expression-list) [, "
#~ "(expression-list)];`"
#~ msgstr ""

#~ msgid ":samp:`REPLACE INTO {table-name} [(column-list)] select-statement;`"
#~ msgstr ""

#~ msgid ":samp:`REPLACE INTO {table-name} DEFAULT VALUES;`"
#~ msgstr ":samp:`db = {имя-базы-данных}` -- строка, по умолчанию пустая"

#~ msgid "Insert one or more new rows into a table, or update existing rows."
#~ msgstr ""

#~ msgid ""
#~ "If a row already exists (as "
#~ "determined by the primary key or "
#~ "any unique key), then the action "
#~ "is delete + insert, and the rules"
#~ " are the same as for a "
#~ ":ref:`DELETE statement <sql_delete>` followed "
#~ "by an :ref:`INSERT statement <sql_insert>`."
#~ " Otherwise the action is insert, and"
#~ " the rules are the same as for"
#~ " the INSERT statement."
#~ msgstr ""

#~ msgid ""
#~ "-- the simplest form:\n"
#~ "REPLACE INTO table1 VALUES (1, 'A');\n"
#~ "-- with a column list:\n"
#~ "REPLACE INTO table1 (column1, column2) VALUES (2, 'B');\n"
#~ "-- with an arithmetic operator in the first expression:\n"
#~ "REPLACE INTO table1 VALUES (2 + 1, 'C');\n"
#~ "-- put two rows in the table:\n"
#~ "REPLACE INTO table1 VALUES (4, 'D'), (5, 'E');"
#~ msgstr ""

#~ msgid ""
#~ "See also: :ref:`INSERT Statement "
#~ "<sql_insert>`, :ref:`UPDATE Statement <sql_update>`."
#~ msgstr ""

#~ msgid "CREATE TRIGGER"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`CREATE TRIGGER [IF NOT EXISTS] "
#~ "{trigger-name}` |br| :samp:`BEFORE|AFTER|INSTEAD "
#~ "OF` |br| :samp:`DELETE|INSERT|UPDATE ON "
#~ "{table-name}` |br| :samp:`FOR EACH ROW` "
#~ "|br| :samp:`[WHEN search-condition]` |br| "
#~ ":samp:`BEGIN` |br| :samp:`delete-statement |"
#~ " insert-statement | replace-statement "
#~ "| select-statement | update-statement;`"
#~ " |br| :samp:`[delete-statement | insert-"
#~ "statement | replace-statement | "
#~ "select-statement | update-statement; ...]`"
#~ " |br| :samp:`END;`"
#~ msgstr ""

#~ msgid ""
#~ "The *trigger-name* must be valid "
#~ "according to the rules for identifiers."
#~ msgstr ""

#~ msgid ""
#~ "If the trigger action time is "
#~ "BEFORE or AFTER, then the *table-"
#~ "name* must refer to an existing "
#~ "base table."
#~ msgstr ""

#~ msgid ""
#~ "If the trigger action time is "
#~ "INSTEAD OF, then the *table-name* "
#~ "must refer to an existing view."
#~ msgstr ""

#~ msgid ""
#~ "There must not already be a "
#~ "trigger with the same name as "
#~ "*trigger-name*."
#~ msgstr ""

#~ msgid "Triggers on different tables or views share the same namespace."
#~ msgstr ""

#~ msgid ""
#~ "The statements between BEGIN and END "
#~ "should not refer to the *table-"
#~ "name* mentioned in the ON clause."
#~ msgstr ""

#~ msgid ""
#~ "The statements between BEGIN and END "
#~ "should not contain an :ref:`INDEXED BY"
#~ " <sql_indexed_by>` clause."
#~ msgstr ""

#~ msgid ""
#~ "SQL triggers are not activated by "
#~ "Tarantool/NoSQL requests. This will change "
#~ "in a future version."
#~ msgstr ""

#~ msgid ""
#~ "On a :ref:`replica <Replication>`, effects "
#~ "of trigger execution are applied, and"
#~ " the SQL triggers themselves are not"
#~ " activated upon replication events."
#~ msgstr ""

#~ msgid ""
#~ "NoSQL triggers are activated both on "
#~ "replica and master, thus if you "
#~ "have a :ref:`NoSQL trigger <triggers>` "
#~ "on a replica, it is activated when"
#~ " applying effects of an SQL trigger."
#~ msgstr ""

#~ msgid "Tarantool will create a new trigger."
#~ msgstr ""

#~ msgid ""
#~ "-- the simple case:\n"
#~ "CREATE TRIGGER stores_before_insert BEFORE "
#~ "INSERT ON stores FOR EACH ROW\n"
#~ "  BEGIN DELETE FROM warehouses; END;\n"
#~ "-- with IF NOT EXISTS clause:\n"
#~ "CREATE TRIGGER IF NOT EXISTS "
#~ "stores_before_insert BEFORE INSERT ON stores"
#~ " FOR EACH ROW\n"
#~ "  BEGIN DELETE FROM warehouses; END;\n"
#~ "-- with FOR EACH ROW and WHEN clauses:\n"
#~ "CREATE TRIGGER stores_before_insert BEFORE "
#~ "INSERT ON stores FOR EACH ROW WHEN"
#~ " a=5\n"
#~ "  BEGIN DELETE FROM warehouses; END;\n"
#~ "-- with multiple statements between BEGIN and END:\n"
#~ "CREATE TRIGGER stores_before_insert BEFORE "
#~ "INSERT ON stores FOR EACH ROW\n"
#~ "  BEGIN DELETE FROM warehouses; INSERT"
#~ " INTO inventories VALUES (1); END;"
#~ msgstr ""

#~ msgid "Trigger extra clauses"
#~ msgstr ""

#~ msgid ":samp:`UPDATE OF column-list`"
#~ msgstr ""

#~ msgid ""
#~ "After BEFORE|AFTER UPDATE it is optional"
#~ " to add ``OF column-list``. If "
#~ "any of the columns in *column-"
#~ "list* is affected at the time the"
#~ " row is processed, then the trigger"
#~ " will be activated for that row. "
#~ "For example:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TRIGGER table1_before_update\n"
#~ " BEFORE UPDATE  OF column1, column2 ON table1\n"
#~ " FOR EACH ROW\n"
#~ " BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
#~ "UPDATE table1 SET column3 = column3 "
#~ "+ 1; -- Trigger will not be "
#~ "activated\n"
#~ "UPDATE table1 SET column2 = column2 + 0; -- Trigger will be activated"
#~ msgstr ""

#~ msgid ":samp:`WHEN`"
#~ msgstr ""

#~ msgid ""
#~ "After *table-name* FOR EACH ROW it"
#~ " is optional to add [``WHEN "
#~ "expression``]. If the expression is true"
#~ " at the time the row is "
#~ "processed, only then will the trigger"
#~ " will be activated for that row. "
#~ "For example:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TRIGGER table1_before_update BEFORE "
#~ "UPDATE ON table1 FOR EACH ROW\n"
#~ " WHEN (SELECT COUNT(*) FROM table1) > 1\n"
#~ " BEGIN UPDATE table2 SET column1 = column1 + 1; END;"
#~ msgstr ""

#~ msgid ""
#~ "This trigger will not be activated "
#~ "unless there is more than one row"
#~ " in ``table1``."
#~ msgstr ""

#~ msgid ":samp:`OLD and NEW`"
#~ msgstr ""

#~ msgid ""
#~ "The keywords OLD and NEW have "
#~ "special meaning in the context of "
#~ "trigger action:"
#~ msgstr ""

#~ msgid "OLD.column-name refers to the value of *column-name* before the change."
#~ msgstr ""

#~ msgid "NEW.column-name refers to the value of *column-name* after the change."
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE table1 (column1 STRING, column2 INTEGER PRIMARY KEY);\n"
#~ "CREATE TABLE table2 (column1 STRING, "
#~ "column2 STRING, column3 INTEGER PRIMARY "
#~ "KEY);\n"
#~ "INSERT INTO table1 VALUES ('old value', 1);\n"
#~ "INSERT INTO table2 VALUES ('', '', 1);\n"
#~ "CREATE TRIGGER table1_before_update BEFORE "
#~ "UPDATE ON table1 FOR EACH ROW\n"
#~ " BEGIN UPDATE table2 SET column1 ="
#~ " old.column1, column2 = new.column1; END;"
#~ "\n"
#~ "UPDATE table1 SET column1 = 'new value';\n"
#~ "SELECT * FROM table2;"
#~ msgstr ""

#~ msgid ""
#~ "At the beginning of the UPDATE for"
#~ " the single row of ``table1``, the"
#~ " value in ``column1`` is 'old value'"
#~ " -- so that is what is seen "
#~ "as ``old.column1``."
#~ msgstr ""

#~ msgid ""
#~ "At the end of the UPDATE for "
#~ "the single row of ``table1``, the "
#~ "value in ``column1`` is 'new value' "
#~ "-- so that is what is seen "
#~ "as ``new.column1``. (OLD and NEW are "
#~ "qualifiers for ``table1``, not ``table2.``)"
#~ msgstr ""

#~ msgid ""
#~ "Therefore, ``SELECT * FROM table2;`` "
#~ "returns ``['old value', 'new value']``."
#~ msgstr ""

#~ msgid "``OLD.column-name`` does not exist for an INSERT trigger."
#~ msgstr ""

#~ msgid "``NEW.column-name`` does not exist for a DELETE trigger."
#~ msgstr ""

#~ msgid "OLD and NEW are read-only; you cannot change their values."
#~ msgstr ""

#~ msgid "Deprecated or illegal statements:"
#~ msgstr ""

#~ msgid ""
#~ "It is illegal for the trigger "
#~ "action to include a qualified column "
#~ "reference other than ``OLD.column-name`` "
#~ "or ``NEW.column-name``. For example, "
#~ "``CREATE TRIGGER ... BEGIN UPDATE table1"
#~ " SET table1.column1 = 5; END;`` is"
#~ " illegal."
#~ msgstr ""

#~ msgid ""
#~ "It is illegal for the trigger "
#~ "action to include statements that "
#~ "include a :ref:`WITH clause <sql_with>`, "
#~ "a DEFAULT VALUES clause, or an "
#~ ":ref:`INDEXED BY <sql_indexed_by>` clause."
#~ msgstr ""

#~ msgid ""
#~ "It is usually not a good idea "
#~ "to have a trigger on ``table1`` "
#~ "which causes a change on ``table2``, "
#~ "and at the same time have a "
#~ "trigger on ``table2`` which causes a "
#~ "change on ``table1``. For example:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TRIGGER table1_before_update\n"
#~ " BEFORE UPDATE ON table1\n"
#~ " FOR EACH ROW\n"
#~ " BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
#~ "CREATE TRIGGER table2_before_update\n"
#~ " BEFORE UPDATE ON table2\n"
#~ " FOR EACH ROW\n"
#~ " BEGIN UPDATE table1 SET column1 = column1 + 1; END;"
#~ msgstr ""

#~ msgid ""
#~ "Luckily ``UPDATE table1 ...`` will not"
#~ " cause an infinite loop, because "
#~ "Tarantool recognizes when it has already"
#~ " updated so it will stop. However,"
#~ " not every DBMS acts this way."
#~ msgstr ""

#~ msgid "Trigger activation"
#~ msgstr ""

#~ msgid "These are remarks concerning trigger activation."
#~ msgstr ""

#~ msgid "Standard terminology:"
#~ msgstr "Для начала введем терминологию:"

#~ msgid "\"trigger action time\" = BEFORE or AFTER or INSTEAD OF"
#~ msgstr ""

#~ msgid "\"trigger event\" = INSERT or DELETE or UPDATE"
#~ msgstr ""

#~ msgid ""
#~ "\"triggered statement\" = BEGIN ... "
#~ "DELETE|INSERT|REPLACE|SELECT|UPDATE ... END"
#~ msgstr ""

#~ msgid "\"triggered when clause\" = WHEN search-condition"
#~ msgstr ""

#~ msgid "\"activate\" = execute a triggered statement"
#~ msgstr ""

#~ msgid "some vendors use the word \"fire\" instead of \"activate\""
#~ msgstr ""

#~ msgid ""
#~ "If there is more than one trigger"
#~ " for the same trigger event, "
#~ "Tarantool may execute the triggers in"
#~ " any order."
#~ msgstr ""

#~ msgid ""
#~ "It is possible for a triggered "
#~ "statement to cause activation of another"
#~ " triggered statement. For example, this "
#~ "is legal:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TRIGGER t1_before_delete BEFORE DELETE"
#~ " ON t1 FOR EACH ROW BEGIN "
#~ "DELETE FROM t2; END;\n"
#~ "CREATE TRIGGER t2_before_delete BEFORE DELETE"
#~ " ON t2 FOR EACH ROW BEGIN "
#~ "DELETE FROM t3; END;"
#~ msgstr ""

#~ msgid ""
#~ "Activation occurs FOR EACH ROW, not "
#~ "FOR EACH STATEMENT. Therefore, if no "
#~ "rows are candidates for insert or "
#~ "update or delete, then no triggers "
#~ "are activated."
#~ msgstr ""

#~ msgid "The BEFORE trigger is activated even if the trigger event fails."
#~ msgstr ""

#~ msgid ""
#~ "If an UPDATE trigger event does "
#~ "not make a change, the trigger is"
#~ " activated anyway. For example, if "
#~ "row 1 ``column1`` contains ``'a'``, and"
#~ " the trigger event is ``UPDATE ..."
#~ " SET column1 = 'a';``, the trigger"
#~ " is activated."
#~ msgstr ""

#~ msgid ""
#~ "The triggered statement may refer to "
#~ "a function: ``RAISE(FAIL, error-message)``."
#~ " If a triggered statement invokes a"
#~ " ``RAISE(FAIL, error-message)`` function, "
#~ "or if a triggered statement causes "
#~ "an error, then statement execution stops"
#~ " immediately."
#~ msgstr ""

#~ msgid ""
#~ "The triggered statement may refer to "
#~ "column values within the rows being "
#~ "changed. in this case:"
#~ msgstr ""

#~ msgid ""
#~ "The row \"as of before\" the "
#~ "change is called the \"old\" row "
#~ "(which makes sense only for UPDATE "
#~ "and DELETE statements)."
#~ msgstr ""

#~ msgid ""
#~ "The row \"as of after\" the change"
#~ " is called the \"new\" row (which "
#~ "makes sense only for UPDATE and "
#~ "INSERT statements)."
#~ msgstr ""

#~ msgid ""
#~ "This example shows how an INSERT "
#~ "can be done to a view by "
#~ "referring to the \"new\" row:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
#~ "CREATE VIEW v AS SELECT s1, s2 FROM t;\n"
#~ "CREATE TRIGGER v_instead_of INSTEAD OF INSERT ON v\n"
#~ "  FOR EACH ROW\n"
#~ "  BEGIN INSERT INTO t VALUES (new.s1, new.s2); END;\n"
#~ "INSERT INTO v VALUES (1, 2);"
#~ msgstr ""

#~ msgid ""
#~ "Ordinarily saying ``INSERT INTO view_name "
#~ "...`` is illegal in Tarantool, so "
#~ "this is a workaround."
#~ msgstr ""

#~ msgid ""
#~ "It is possible to generalize this "
#~ "so that all data-change statements "
#~ "on views will change the base "
#~ "tables, provided that the view contains"
#~ " all the columns of the base "
#~ "table, and provided that the triggers"
#~ " refer to those columns when "
#~ "necessary, as in this example:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE base_table (primary_key_column "
#~ "INTEGER PRIMARY KEY, value_column INTEGER);"
#~ "\n"
#~ "CREATE VIEW viewed_table AS SELECT "
#~ "primary_key_column, value_column FROM base_table;"
#~ "\n"
#~ "CREATE TRIGGER viewed_table_instead_of_insert "
#~ "INSTEAD OF INSERT ON viewed_table FOR"
#~ " EACH ROW\n"
#~ "  BEGIN\n"
#~ "    INSERT INTO base_table VALUES "
#~ "(new.primary_key_column, new.value_column); END;\n"
#~ "CREATE TRIGGER viewed_table_instead_of_update "
#~ "INSTEAD OF UPDATE ON viewed_table FOR"
#~ " EACH ROW\n"
#~ "  BEGIN\n"
#~ "    UPDATE base_table\n"
#~ "    SET primary_key_column = "
#~ "new.primary_key_column, value_column = "
#~ "new.value_column\n"
#~ "    WHERE primary_key_column = old.primary_key_column; END;\n"
#~ "CREATE TRIGGER viewed_table_instead_of_delete "
#~ "INSTEAD OF DELETE ON viewed_table FOR"
#~ " EACH ROW\n"
#~ "  BEGIN\n"
#~ "    DELETE FROM base_table WHERE "
#~ "primary_key_column = old.primary_key_column; END;"
#~ msgstr ""

#~ msgid ""
#~ "When INSERT or UPDATE or DELETE "
#~ "occurs for table ``X``, Tarantool "
#~ "usually operates in this order (a "
#~ "basic scheme):"
#~ msgstr ""

#~ msgid ""
#~ "For each row\n"
#~ "  Perform constraint checks\n"
#~ "  For each BEFORE trigger that refers to table X\n"
#~ "    Check that the trigger's WHEN condition is true.\n"
#~ "    Execute what is in the triggered statement.\n"
#~ "  Insert or update or delete the row in table X.\n"
#~ "  Perform more constraint checks\n"
#~ "  For each AFTER trigger that refers to table X\n"
#~ "    Check that the trigger's WHEN condition is true.\n"
#~ "    Execute what is in the triggered statement."
#~ msgstr ""

#~ msgid ""
#~ "However, Tarantool does not guarantee "
#~ "execution order when there are multiple"
#~ " constraints, or multiple triggers for "
#~ "the same event (including NoSQL "
#~ ":ref:`on_replace triggers <box_space-on_replace>`"
#~ " or SQL :ref:`INSTEAD OF triggers "
#~ "<sql_instead_of_triggers>` that affect a view"
#~ " of table ``X``)."
#~ msgstr ""

#~ msgid "The maximum number of trigger activations per statement is 32."
#~ msgstr ""

#~ msgid "INSTEAD OF triggers"
#~ msgstr "Создание подключения"

#~ msgid ""
#~ "A trigger which is created with "
#~ "the clause |br| :samp:`INSTEAD OF "
#~ "{INSERT|UPDATE|DELETE} ON {view-name}` |br|"
#~ " is an INSTEAD OF trigger. For "
#~ "each affected row, the trigger action"
#~ " is performed \"instead of\" the "
#~ "INSERT or UPDATE or DELETE statement "
#~ "that causes trigger activation."
#~ msgstr ""

#~ msgid ""
#~ "For example, ordinarily it is illegal"
#~ " to INSERT rows in a view, but"
#~ " it is legal to create a "
#~ "trigger which intercepts attempts to "
#~ "INSERT, and puts rows in the "
#~ "underlying base table:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t1 (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
#~ "CREATE VIEW v1 AS SELECT column1, column2 FROM t1;\n"
#~ "CREATE TRIGGER v1_instead_of INSTEAD OF "
#~ "INSERT ON v1 FOR EACH ROW BEGIN"
#~ "\n"
#~ " INSERT INTO t1 VALUES (NEW.column1, NEW.column2); END;\n"
#~ "INSERT INTO v1 VALUES (1, 1);\n"
#~ "-- ... The result will be: table t1 will contain a new row."
#~ msgstr ""

#~ msgid ""
#~ "INSTEAD OF triggers are only legal "
#~ "for views, while BEFORE or AFTER "
#~ "triggers are only legal for base "
#~ "tables."
#~ msgstr ""

#~ msgid "It is legal to create INSTEAD OF triggers with triggered WHEN clauses."
#~ msgstr ""

#~ msgid ""
#~ "It is legal to create INSTEAD OF"
#~ " triggers with UPDATE OF *column-"
#~ "list* clauses, but they are not "
#~ "standard SQL."
#~ msgstr ""

#~ msgid ""
#~ "CREATE TRIGGER ev1_instead_of_update\n"
#~ "  INSTEAD OF UPDATE OF column2,column1 ON ev1\n"
#~ "  FOR EACH ROW BEGIN\n"
#~ "  INSERT INTO et2 VALUES (NEW.column1, NEW.column2); END;"
#~ msgstr ""

#~ msgid "DROP TRIGGER"
#~ msgstr ""

#~ msgid ":samp:`DROP TRIGGER [IF EXISTS] {trigger-name};`"
#~ msgstr ""

#~ msgid "Drop a trigger."
#~ msgstr ""

#~ msgid ""
#~ "The *trigger-name* must identify a "
#~ "trigger that was created earlier with"
#~ " the :ref:`CREATE TRIGGER <sql_create_trigger>`"
#~ " statement."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool returns an error if the "
#~ "trigger does not exist and there "
#~ "is no ``IF EXISTS`` clause."
#~ msgstr ""

#~ msgid "The trigger is dropped."
#~ msgstr ""

#~ msgid ""
#~ "-- the simple case:\n"
#~ "DROP TRIGGER table1_before_insert;\n"
#~ "-- with an IF EXISTS clause:\n"
#~ "DROP TRIGGER IF EXISTS table1_before_insert;"
#~ msgstr ""

#~ msgid "TRUNCATE"
#~ msgstr "Структура"

#~ msgid ":samp:`TRUNCATE TABLE {table-name};`"
#~ msgstr ""

#~ msgid "Remove all rows in the table."
#~ msgstr ""

#~ msgid ""
#~ "TRUNCATE is considered to be a "
#~ "schema-change rather than a data-"
#~ "change statement, so it does not "
#~ "work within transactions (it cannot be"
#~ " :ref:`rolled back <sql_rollback>`)."
#~ msgstr ""

#~ msgid "It is illegal to truncate a table which is referenced by a foreign key."
#~ msgstr ""

#~ msgid ""
#~ "It is illegal to truncate a table"
#~ " which is also a system space, "
#~ "such as ``_space``."
#~ msgstr ""

#~ msgid "The table must be a base table rather than a view."
#~ msgstr ""

#~ msgid ""
#~ "All rows in the table are removed."
#~ " Usually this is faster than "
#~ ":samp:`DELETE FROM {table-name};`."
#~ msgstr ""

#~ msgid ""
#~ "If the table has an autoincrement "
#~ "primary key, its :ref:`sequence "
#~ "<box_schema-sequence_create_index>` is not reset"
#~ " to zero, but that may occur in"
#~ " a future Tarantool version."
#~ msgstr ""

#~ msgid "There is no effect for any triggers associated with the table."
#~ msgstr "функция, которая будет связана с файбером"

#~ msgid "There is no effect on the counts for the ``ROW_COUNT()`` function."
#~ msgstr ""

#~ msgid ""
#~ "Only one action is written to the"
#~ " :ref:`write-ahead log <internals-wal>` "
#~ "(with :samp:`DELETE FROM {table-name};` "
#~ "there would be one action for each"
#~ " deleted row)."
#~ msgstr ""

#~ msgid "TRUNCATE TABLE t;"
#~ msgstr "Тип возвращаемого значения: таблица"

#~ msgid "SELECT"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`SELECT [ALL|DISTINCT] select list [from"
#~ " clause] [where clause] [group-by "
#~ "clause] [having clause] [order-by "
#~ "clause];`"
#~ msgstr ""

#~ msgid "Select zero or more rows."
#~ msgstr "Выбор одного или нескольких кортежей"

#~ msgid ""
#~ "The clauses of the SELECT statement "
#~ "are discussed in the following five "
#~ "sections."
#~ msgstr ""

#~ msgid "Select list"
#~ msgstr ""

#~ msgid ":samp:`select-list-column [, select-list-column ...]`"
#~ msgstr ""

#~ msgid "select-list-column:"
#~ msgstr ""

#~ msgid ""
#~ "Define what will be in a result"
#~ " set; this is a clause in a "
#~ ":ref:`SELECT statement <sql_select>`."
#~ msgstr ""

#~ msgid ""
#~ "The *select list* is a comma-"
#~ "delimited list of expressions, or ``*``"
#~ " (asterisk). An expression can have "
#~ "an alias provided with an ``[[AS] "
#~ "column-name]`` clause."
#~ msgstr ""

#~ msgid ""
#~ "The ``*`` \"asterisk\" shorthand is "
#~ "valid if and only if the SELECT"
#~ " statement also contains a :ref:`FROM "
#~ "clause <sql_from>` which specifies the "
#~ "table or tables (details about the "
#~ "FROM clause are in the next "
#~ "section). The simple form is ``*`` "
#~ "which means \"all columns\" -- for "
#~ "example, if the select is done for"
#~ " a table which contains three columns"
#~ " ``s1`` ``s2`` ``s3``, then ``SELECT "
#~ "* ...`` is equivalent to ``SELECT "
#~ "s1, s2, s3 ...``. The qualified "
#~ "form is ``table-name.*`` which means "
#~ "\"all columns in the specified table\","
#~ " which again must be a result "
#~ "of the FROM clause -- for example,"
#~ " if the table is named ``table1``,"
#~ " then ``table1.*`` is equivalent to a"
#~ " list of the columns of ``table1``."
#~ msgstr ""

#~ msgid ""
#~ "The ``[[AS] column-name]`` clause "
#~ "determines the column name. The column"
#~ " name is useful for two reasons:"
#~ msgstr ""

#~ msgid "in a tabular display, the column names are the headings"
#~ msgstr ""

#~ msgid ""
#~ "if the results of the SELECT are"
#~ " used when creating a new table "
#~ "(such as a view), then the column"
#~ " names in the new table will be"
#~ " the column names in the *select "
#~ "list*."
#~ msgstr ""

#~ msgid ""
#~ "If ``[[AS] column-name]`` is missing,"
#~ " Tarantool makes a name equal to "
#~ "the expression, for example ``SELECT 5"
#~ " * 88`` will cause the column "
#~ "name to be ``5 * 88``, but "
#~ "such names may be ambiguous or "
#~ "illegal in other contexts, so it "
#~ "is better to say, for example, "
#~ "``SELECT 5 * 88 AS column1``."
#~ msgstr ""

#~ msgid ""
#~ "-- the simple form:\n"
#~ "SELECT 5;\n"
#~ "-- with multiple expressions including operators:\n"
#~ "SELECT 1, 2 * 2, 'Three' || 'Four';\n"
#~ "-- with [[AS] column-name] clause:\n"
#~ "SELECT 5 AS column1;\n"
#~ "-- * which must be eventually followed by a FROM clause:\n"
#~ "SELECT * FROM table1;\n"
#~ "-- as a list:\n"
#~ "SELECT 1 AS a, 2 AS b, table1.* FROM table1;"
#~ msgstr ""

#~ msgid ""
#~ "Limitations: (`Issue#3962 "
#~ "<https://github.com/tarantool/tarantool/issues/3962>`_) |br| "
#~ "* Names for expressions will change "
#~ "in a future version."
#~ msgstr ""

#~ msgid "FROM clause"
#~ msgstr ""

#~ msgid ":samp:`FROM table-reference [, table-reference ...]`"
#~ msgstr ""

#~ msgid ""
#~ "Specify the table or tables for "
#~ "the source of a :ref:`SELECT statement"
#~ " <sql_select>`."
#~ msgstr ""

#~ msgid ""
#~ "The *table-reference* must be a "
#~ "name of an existing table, or a"
#~ " subquery, or a joined table."
#~ msgstr ""

#~ msgid "A joined table looks like this:"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`table-reference-or-joined-table "
#~ "join-operator table-reference-or-joined-"
#~ "table [join-specification]`"
#~ msgstr ""

#~ msgid ""
#~ "A *join-operator* must be any of"
#~ " `the standard types "
#~ "<https://en.wikipedia.org/wiki/Join_(SQL)>`_:"
#~ msgstr ""

#~ msgid "[NATURAL] LEFT [OUTER] JOIN,"
#~ msgstr ""

#~ msgid "[NATURAL] INNER JOIN, or"
#~ msgstr ""

#~ msgid "CROSS JOIN"
#~ msgstr ""

#~ msgid "A *join-specification* must be any of:"
#~ msgstr ""

#~ msgid "ON expression, or"
#~ msgstr ""

#~ msgid "USING (column-name [, column-name ...])"
#~ msgstr ""

#~ msgid "Parentheses are allowed, and ``[[AS] correlation-name]`` is allowed."
#~ msgstr ""

#~ msgid "The maximum number of joins in a FROM clause is 64."
#~ msgstr ""
#~ "Максимальное количество байтов оперативной "
#~ "памяти, которые использует vinyl."

#~ msgid ""
#~ "-- the simplest form:\n"
#~ "SELECT * FROM t;\n"
#~ "-- with two tables, making a Cartesian join:\n"
#~ "SELECT * FROM t1, t2;\n"
#~ "-- with one table joined to itself, requiring correlation names:\n"
#~ "SELECT a.*, b.* FROM t1 AS a, t1 AS b;\n"
#~ "-- with a left outer join:\n"
#~ "SELECT * FROM t1 LEFT JOIN t2;"
#~ msgstr ""

#~ msgid "WHERE clause"
#~ msgstr ""

#~ msgid ":samp:`WHERE condition;`"
#~ msgstr ""

#~ msgid ""
#~ "Specify the condition for filtering rows"
#~ " from a table; this is a clause"
#~ " in a :ref:`SELECT <sql_select>` or "
#~ ":ref:`UPDATE <sql_update>` or :ref:`DELETE "
#~ "<sql_delete>` statement."
#~ msgstr ""

#~ msgid ""
#~ "The condition may contain any expression"
#~ " that returns a BOOLEAN (TRUE or "
#~ "FALSE or UNKNOWN) value."
#~ msgstr ""

#~ msgid "For each row in the table:"
#~ msgstr ""

#~ msgid "if the condition is true, then the row is kept;"
#~ msgstr ""

#~ msgid "if the condition is false or unknown, then the row is ignored."
#~ msgstr ""

#~ msgid ""
#~ "In effect, WHERE condition takes a "
#~ "table with n rows and returns a"
#~ " table with n or fewer rows."
#~ msgstr ""

#~ msgid ""
#~ "-- with a simple condition:\n"
#~ "SELECT 1 FROM t WHERE column1 = 5;\n"
#~ "-- with a condition that contains AND and OR and parentheses:\n"
#~ "SELECT 1 FROM t WHERE column1 = 5 AND (x > 1 OR y < 1);"
#~ msgstr ""

#~ msgid "GROUP BY clause"
#~ msgstr ""

#~ msgid ":samp:`GROUP BY expression [, expression ...]`"
#~ msgstr ""

#~ msgid ""
#~ "Make a grouped table; this is a"
#~ " clause in a :ref:`SELECT statement "
#~ "<sql_select>`."
#~ msgstr ""

#~ msgid ""
#~ "The expressions should be column names"
#~ " in the table, and each column "
#~ "should be specified only once."
#~ msgstr ""

#~ msgid ""
#~ "In effect, the GROUP BY clause "
#~ "takes a table with rows that may"
#~ " have matching values, combines rows "
#~ "that have matching values into single"
#~ " rows, and returns a table which, "
#~ "because it is the result of GROUP"
#~ " BY, is called a grouped table."
#~ msgstr ""

#~ msgid "Thus, if the input is a table:"
#~ msgstr ""

#~ msgid ""
#~ "a    b      c\n"
#~ "-    -      -\n"
#~ "1    'a'   'b\n"
#~ "1    'b'   'b'\n"
#~ "2    'a'   'b'\n"
#~ "3    'a'   'b'\n"
#~ "1    'b'   'b'"
#~ msgstr ""

#~ msgid "then ``GROUP BY a, b`` will produce a grouped table:"
#~ msgstr ""

#~ msgid ""
#~ "a    b      c\n"
#~ "-    -      -\n"
#~ "1    'a'   'b'\n"
#~ "1    'b'   'b'\n"
#~ "2    'a'   'b'\n"
#~ "3    'a'   'b'"
#~ msgstr ""

#~ msgid ""
#~ "The rows where column ``a`` and "
#~ "column ``b`` have the same value "
#~ "have been merged; column ``c`` has "
#~ "been preserved but its value should "
#~ "not be depended on -- if the "
#~ "rows were not all 'b', Tarantool "
#~ "could pick any value."
#~ msgstr ""

#~ msgid ""
#~ "It is useful to envisage a grouped"
#~ " table as having hidden extra columns"
#~ " for the aggregation of the values,"
#~ " for example:"
#~ msgstr ""

#~ msgid ""
#~ "a    b      c    COUNT(a) SUM(a) MIN(c)\n"
#~ "-    -      -    -------- ------ ------\n"
#~ "1    'a'    'b'         2      2    'b'\n"
#~ "1    'b'    'b'         1      1    'b'\n"
#~ "2    'a'    'b'         1      2    'b'\n"
#~ "     'a'    'b'         1      3    'b'"
#~ msgstr ""

#~ msgid ""
#~ "These extra columns are what "
#~ ":ref:`aggregate functions <sql_aggregate>` are "
#~ "for."
#~ msgstr ""

#~ msgid ""
#~ "-- with a single column:\n"
#~ "SELECT 1 FROM t GROUP BY column1;\n"
#~ "-- with two columns:\n"
#~ "SELECT 1 FROM t GROUP BY column1, column2;"
#~ msgstr ""

#~ msgid "``SELECT s1, s2 FROM t GROUP BY s1;`` is legal."
#~ msgstr ""

#~ msgid "``SELECT s1 AS q FROM t GROUP BY q;`` is legal."
#~ msgstr ""

#~ msgid "``SELECT s1 FROM t GROUP by 1;`` is legal."
#~ msgstr ""

#~ msgid "Aggregate functions"
#~ msgstr "функция"

#~ msgid ":samp:`function-name (one or more expressions)`"
#~ msgstr ""

#~ msgid ""
#~ "Apply a built-in aggregate function "
#~ "to one or more expressions and "
#~ "return a scalar value."
#~ msgstr ""

#~ msgid ""
#~ "Aggregate functions are only legal in"
#~ " certain clauses of a :ref:`SELECT "
#~ "statement <sql_select>` for grouped tables."
#~ " (A table is a grouped table if"
#~ " a GROUP BY clause is present.) "
#~ "Also, if an aggregate function is "
#~ "used in a :ref:`select list "
#~ "<sql_select_list>` and the GROUP BY "
#~ "clause is omitted, then Tarantool "
#~ "assumes ``SELECT ... GROUP BY [all "
#~ "columns];``."
#~ msgstr ""

#~ msgid "NULLs are ignored for all aggregate functions except COUNT(*)."
#~ msgstr ""

#~ msgid "``AVG([DISTINCT] expression)``"
#~ msgstr ""

#~ msgid "Return the average value of expression."
#~ msgstr "Возврат шестнадцатеричного значения введенной строки."

#~ msgid "Example: :samp:`AVG({column1})`"
#~ msgstr ""

#~ msgid "``COUNT([DISTINCT] expression)``"
#~ msgstr ""

#~ msgid "Return the number of occurrences of expression."
#~ msgstr "Возврат числа секунд с начала отсчета."

#~ msgid "Example: :samp:`COUNT({column1})`"
#~ msgstr ""

#~ msgid "``COUNT(*)``"
#~ msgstr "``y:unpack()``"

#~ msgid "Return the number of occurrences of a row."
#~ msgstr "Возврат количества сегментов, расположенных в хранилище."

#~ msgid "Example: :samp:`COUNT(*)`"
#~ msgstr ""

#~ msgid ""
#~ "``GROUP_CONCAT(expression-1 [, expression-2])`` or"
#~ " ``GROUP_CONCAT(DISTINCT expression-1)``"
#~ msgstr ""

#~ msgid ""
#~ "Return a list of *expression-1* values,"
#~ " separated by commas if *expression-2* "
#~ "is omitted, or separated by the "
#~ "*expression-2* value if *expression-2* is "
#~ "not omitted."
#~ msgstr ""

#~ msgid "Example: :samp:`GROUP_CONCAT({column1})`"
#~ msgstr ""

#~ msgid "``MAX([DISTINCT] expression)``"
#~ msgstr ""

#~ msgid "Return the maximum value of expression."
#~ msgstr "Возврат шестнадцатеричного значения введенной строки."

#~ msgid "Example: :samp:`MAX({column1})`"
#~ msgstr ""

#~ msgid "``MIN([DISTINCT] expression)``"
#~ msgstr ""

#~ msgid "Return the minimum value of expression."
#~ msgstr ""

#~ msgid "Example: :samp:`MIN({column1})`"
#~ msgstr ""

#~ msgid "``SUM([DISTINCT] expression)``"
#~ msgstr ""

#~ msgid "Return the sum of values of expression."
#~ msgstr ""

#~ msgid "Example: :samp:`SUM({column1})`"
#~ msgstr ""

#~ msgid "``TOTAL([DISTINCT] expression)``"
#~ msgstr ""

#~ msgid "Example: :samp:`TOTAL({column1})`"
#~ msgstr ""

#~ msgid "HAVING clause"
#~ msgstr ""

#~ msgid ":samp:`HAVING condition;`"
#~ msgstr ""

#~ msgid ""
#~ "Specify the condition for filtering rows"
#~ " from a grouped table; this is "
#~ "a clause in a :ref:`SELECT statement "
#~ "<sql_select>`."
#~ msgstr ""

#~ msgid ""
#~ "The clause preceding the HAVING clause"
#~ " may be a GROUP BY clause. "
#~ "HAVING operates on the table that "
#~ "the GROUP BY produces, which may "
#~ "contain grouped columns and aggregates."
#~ msgstr ""

#~ msgid ""
#~ "If the preceding clause is not a"
#~ " GROUP BY clause, then there is "
#~ "only one group and the HAVING "
#~ "clause may only contain aggregate "
#~ "functions or literals."
#~ msgstr ""

#~ msgid ""
#~ "In effect, HAVING condition takes a "
#~ "table with n rows and returns a"
#~ " table with n or fewer rows."
#~ msgstr ""

#~ msgid ""
#~ "-- with a simple condition:\n"
#~ "SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5;\n"
#~ "-- with a more complicated condition:\n"
#~ "SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5 OR column2 < 5;\n"
#~ "-- with an aggregate:\n"
#~ "SELECT x, SUM(y) FROM t GROUP BY x HAVING SUM(y) > 0;\n"
#~ "-- with no GROUP BY and an aggregate:\n"
#~ "SELECT SUM(y) FROM t GROUP BY x HAVING MIN(y) < MAX(y);"
#~ msgstr ""

#~ msgid "HAVING without GROUP BY is not supported for multiple tables."
#~ msgstr ""

#~ msgid "ORDER BY clause"
#~ msgstr ""

#~ msgid ":samp:`ORDER BY expression [ASC|DESC] [, expression [ASC|DESC] ...]`"
#~ msgstr ""

#~ msgid ""
#~ "Put rows in order; this is a "
#~ "clause in a :ref:`SELECT statement "
#~ "<sql_select>`."
#~ msgstr ""

#~ msgid ""
#~ "An ORDER BY expression has one of"
#~ " three types which are checked in "
#~ "order:"
#~ msgstr ""

#~ msgid ""
#~ "Expression is a positive integer, "
#~ "representing the ordinal position of the"
#~ " column in the :ref:`select list "
#~ "<sql_select_list>`. For example, in the "
#~ "statement |br| ``SELECT x, y, z "
#~ "FROM t ORDER BY 2;`` |br| ``ORDER"
#~ " BY 2`` means \"order by the "
#~ "second column in the select list\", "
#~ "which is ``y``."
#~ msgstr ""

#~ msgid ""
#~ "Expression is a name of a column"
#~ " in the select list, which is "
#~ "determined by an AS clause. For "
#~ "example, in the statement |br| ``SELECT"
#~ " x, y AS x, z FROM t "
#~ "ORDER BY x;`` |br| ``ORDER BY x``"
#~ " means \"order by the column "
#~ "explicitly named ``x`` in the select "
#~ "list\", which is the second column."
#~ msgstr ""

#~ msgid ""
#~ "Expression contains a name of a "
#~ "column in a table of the FROM "
#~ "clause. For example, in the statement"
#~ " |br| ``SELECT x, y FROM t1 "
#~ "JOIN t2 ORDER BY z;`` |br| ``ORDER"
#~ " BY z`` means \"order by a "
#~ "column named ``z`` which is expected "
#~ "to be in table ``t1`` or table "
#~ "``t2``\"."
#~ msgstr ""

#~ msgid ""
#~ "If both tables contain a column "
#~ "named ``z``, then Tarantool will choose"
#~ " the first column that it finds."
#~ msgstr ""

#~ msgid ""
#~ "The expression may also contain "
#~ "operators and function names and "
#~ "literals. For example, in the statement"
#~ " |br| ``SELECT x, y FROM t "
#~ "ORDER BY UPPER(z);`` |br| ``ORDER BY "
#~ "UPPER(z)`` means \"order by the "
#~ "uppercase form of column ``t.z``\", "
#~ "which may be similar to doing "
#~ "ordering in a case-insensitive manner."
#~ msgstr ""

#~ msgid ""
#~ "Type 3 is illegal if the SELECT"
#~ " statement contains :ref:`UNION or EXCEPT"
#~ " or INTERSECT <sql_union>`."
#~ msgstr ""

#~ msgid ""
#~ "If an ORDER BY clause contains "
#~ "multiple expressions, then expressions on "
#~ "the left are processed first and "
#~ "expressions on the right are processed"
#~ " only if necessary for tie-breaking."
#~ " For example, in the statement |br|"
#~ " ``SELECT x, y FROM t ORDER BY"
#~ " x, y;`` if there are two rows"
#~ " which both have the same values "
#~ "for column ``x``, then an additional "
#~ "check is made to see which row "
#~ "has a greater value for column "
#~ "``y``."
#~ msgstr ""

#~ msgid ""
#~ "In effect, ORDER BY clause takes a"
#~ " table with rows that may be "
#~ "out of order, and returns a table"
#~ " with rows in order."
#~ msgstr ""

#~ msgid "Sorting order:"
#~ msgstr ""

#~ msgid ""
#~ "The default order is ASC (ascending),"
#~ " the optional order is DESC "
#~ "(descending)."
#~ msgstr ""

#~ msgid ""
#~ "NULLs come first, then BOOLEANs, then"
#~ " numbers, then STRINGs, then VARBINARYs."
#~ msgstr ""

#~ msgid "Within STRINGs, ordering is according to collation."
#~ msgstr ""

#~ msgid ""
#~ "Collation may be specified with a "
#~ ":ref:`COLLATE clause <sql_collate_clause>` within"
#~ " the ORDER BY column-list, or "
#~ "may be default."
#~ msgstr ""

#~ msgid ""
#~ "-- with a single column:\n"
#~ "SELECT 1 FROM t ORDER BY column1;\n"
#~ "-- with two columns:\n"
#~ "SELECT 1 FROM t ORDER BY column1, column2;\n"
#~ "-- with a variety of data:\n"
#~ "CREATE TABLE h (s1 NUMBER PRIMARY KEY, s2 SCALAR);\n"
#~ "INSERT INTO h VALUES (7, 'A'), (4,"
#~ " 'a'), (-4, 'AZ'), (17, 17), (23, "
#~ "NULL);\n"
#~ "INSERT INTO h VALUES (17.5, 'Д'), (1e+300, 'A'), (0, ''), (-1, '');\n"
#~ "SELECT * FROM h ORDER BY s2 COLLATE \"unicode_ci\", s1;\n"
#~ "-- The result of the above SELECT will be:\n"
#~ "- - [23, null]\n"
#~ "  - [17, 17]\n"
#~ "  - [-1, '']\n"
#~ "  - [0, '']\n"
#~ "  - [4, 'a']\n"
#~ "  - [7, 'A']\n"
#~ "  - [1e+300, 'A']\n"
#~ "  - [-4, 'AZ']\n"
#~ "  - [17.5, 'Д']\n"
#~ "..."
#~ msgstr ""

#~ msgid "ORDER BY 1 is legal. This is common but is not standard SQL nowadays."
#~ msgstr ""

#~ msgid "LIMIT clause"
#~ msgstr ""

#~ msgid ":samp:`LIMIT limit-expression [OFFSET offset-expression]`"
#~ msgstr ""

#~ msgid ":samp:`LIMIT offset-expression, limit-expression`"
#~ msgstr ""

#~ msgid ""
#~ "The above is not a typo: "
#~ "*offset-expression* and *limit-expression* "
#~ "are in reverse order if a comma"
#~ " is used."
#~ msgstr ""

#~ msgid ""
#~ "Specify a maximum number of rows "
#~ "and a start row; this is a "
#~ "clause in a :ref:`SELECT statement "
#~ "<sql_select>`."
#~ msgstr ""

#~ msgid ""
#~ "Expressions may contain integers and "
#~ "arithmetic operators or functions, for "
#~ "example ``ABS(-3 / 1)``. However, the"
#~ " result must be an integer value "
#~ "greater than or equal to zero."
#~ msgstr ""

#~ msgid ""
#~ "Usually the LIMIT clause follows an "
#~ ":ref:`ORDER BY clause <sql_order_by>`, because"
#~ " otherwise Tarantool does not guarantee "
#~ "that rows are in order."
#~ msgstr ""

#~ msgid ""
#~ "-- simple case:\n"
#~ "SELECT * FROM t LIMIT 3;\n"
#~ "-- both limit and order:\n"
#~ "SELECT * FROM t LIMIT 3 OFFSET 1;\n"
#~ "-- applied to a UNIONed result "
#~ "(LIMIT clause must be the final "
#~ "clause):\n"
#~ "SELECT column1 FROM table1 UNION SELECT"
#~ " column1 FROM table2 ORDER BY 1 "
#~ "LIMIT 1;"
#~ msgstr ""

#~ msgid ""
#~ "If ORDER BY ... LIMIT is used, "
#~ "then all order-by columns must be"
#~ " ASC or all must be DESC."
#~ msgstr ""

#~ msgid "VALUES"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`VALUES (expression [, expression ...])"
#~ " [, (expression [, expression ...])`"
#~ msgstr ""

#~ msgid "Select one or more rows."
#~ msgstr "Выбор одного или нескольких кортежей"

#~ msgid ""
#~ "VALUES has the same effect as "
#~ ":ref:`SELECT <sql_select>`, that is, it "
#~ "returns a result set, but VALUES "
#~ "statements may not have FROM or "
#~ "GROUP or ORDER BY or LIMIT "
#~ "clauses."
#~ msgstr ""

#~ msgid ""
#~ "VALUES may be used wherever SELECT "
#~ "may be used, for example in "
#~ ":ref:`subqueries <sql_subquery>`."
#~ msgstr ""

#~ msgid ""
#~ "-- simple case:\n"
#~ "VALUES (1);\n"
#~ "-- equivalent to SELECT 1, 2, 3:\n"
#~ "VALUES (1, 2, 3);\n"
#~ "-- two rows:\n"
#~ "VALUES (1, 2, 3), (4, 5, 6);"
#~ msgstr ""

#~ msgid "Subquery"
#~ msgstr ""

#~ msgid ":ref:`SELECT-statement <sql_select>` syntax"
#~ msgstr ""

#~ msgid ":ref:`VALUES-statement <sql_values>` syntax"
#~ msgstr ""

#~ msgid ""
#~ "A subquery has the same syntax as"
#~ " a :ref:`SELECT statement <sql_select>` or"
#~ " :ref:`VALUES statement <sql_values>` embedded"
#~ " inside a main statement."
#~ msgstr ""

#~ msgid ""
#~ "The SELECT and VALUES statements are "
#~ "called \"queries\" because they return "
#~ "answers, in the form of result "
#~ "sets."
#~ msgstr ""

#~ msgid ""
#~ "Subqueries may be the second part "
#~ "of :ref:`INSERT statements <sql_insert>`. For"
#~ " example:"
#~ msgstr ""

#~ msgid "INSERT INTO t2 SELECT a, b, c FROM t1;"
#~ msgstr ""

#~ msgid ""
#~ "Subqueries may be in the :ref:`FROM "
#~ "clause <sql_from>` of SELECT statements."
#~ msgstr ""

#~ msgid ""
#~ "Subqueries may be expressions, or be "
#~ "inside expressions. In this case they"
#~ " must be parenthesized, and usually "
#~ "the number of rows must be 1. "
#~ "For example:"
#~ msgstr ""

#~ msgid ""
#~ "SELECT 1, (SELECT 5), 3 FROM t "
#~ "WHERE c1 * (SELECT COUNT(*) FROM "
#~ "t2) > 5;"
#~ msgstr ""

#~ msgid ""
#~ "Subqueries may be expressions on the "
#~ "right side of certain comparison "
#~ "operators, and in this unusual case "
#~ "the number of rows may be greater"
#~ " than 1. The comparison operators "
#~ "are: [NOT] EXISTS and [NOT] IN. "
#~ "For example:"
#~ msgstr ""

#~ msgid "DELETE FROM t WHERE s1 NOT IN (SELECT s2 FROM t);"
#~ msgstr ""

#~ msgid ""
#~ "Subqueries may refer to values in "
#~ "the outer query. In this case, the"
#~ " subquery is called a \"correlated "
#~ "subquery\"."
#~ msgstr ""

#~ msgid ""
#~ "Subqueries may refer to rows which "
#~ "are being updated or deleted by "
#~ "the main query. In that case, the"
#~ " subquery finds the matching rows "
#~ "first, before starting to update or "
#~ "delete. For example, after:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
#~ "INSERT INTO t VALUES (1, 3), (2, 1);\n"
#~ "DELETE FROM t WHERE s2 NOT IN (SELECT s1 FROM t);"
#~ msgstr ""

#~ msgid "only one of the rows is deleted, not both rows."
#~ msgstr ""

#~ msgid "WITH clause"
#~ msgstr ""

#~ msgid "**WITH clause (common table expression)**"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`WITH {temporary-table-name} AS "
#~ "(subquery)` |br| :samp:`[, {temporary-"
#~ "table-name} AS (subquery)]` |br| "
#~ ":samp:`SELECT statement | INSERT statement "
#~ "| DELETE statement | UPDATE statement"
#~ " | REPLACE statement;`"
#~ msgstr ""

#~ msgid "WITH v AS (SELECT * FROM t) SELECT * FROM v;"
#~ msgstr ""

#~ msgid ""
#~ "is equivalent to :ref:`creating a view"
#~ " <sql_create_view>` and selecting from it:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE VIEW v AS SELECT * FROM t;\n"
#~ "SELECT * FROM v;"
#~ msgstr ""

#~ msgid ""
#~ "The difference is that a WITH-"
#~ "clause \"view\" is temporary and only"
#~ " useful within the same statement. No"
#~ " CREATE privilege is required."
#~ msgstr ""

#~ msgid ""
#~ "The WITH-clause can also be "
#~ "thought of as a :ref:`subquery "
#~ "<sql_subquery>` that has a name. This"
#~ " is useful when the same subquery "
#~ "is being repeated. For example:"
#~ msgstr ""

#~ msgid ""
#~ "SELECT * FROM t WHERE a < "
#~ "(SELECT s1 FROM x) AND b < "
#~ "(SELECT s1 FROM x);"
#~ msgstr ""

#~ msgid "can be replaced with:"
#~ msgstr "Можно создать?"

#~ msgid ""
#~ "WITH s AS (SELECT s1 FROM x) "
#~ "SELECT * FROM t,s WHERE a < "
#~ "s.s1 AND b < s.s1;"
#~ msgstr ""

#~ msgid ""
#~ "This \"factoring out\" of a repeated "
#~ "expression is regarded as good practice."
#~ msgstr ""

#~ msgid ""
#~ "WITH cte AS (VALUES (7, '') INSERT INTO j SELECT * FROM cte;\n"
#~ "WITH cte AS (SELECT s1 AS x FROM k) SELECT * FROM cte;\n"
#~ "WITH cte AS (SELECT COUNT(*) FROM k WHERE s2 < 'x' GROUP BY s3)\n"
#~ "  UPDATE j SET s2 = 5\n"
#~ "  WHERE s1 = (SELECT s1 FROM cte) OR s3 = (SELECT s1 FROM cte);"
#~ msgstr ""

#~ msgid ""
#~ "WITH can only be used at the "
#~ "beginning of a statement, therefore it"
#~ " cannot be used at the beginning "
#~ "of a subquery or after a :ref:`set"
#~ " operator <sql_union>` or inside a "
#~ "CREATE statement."
#~ msgstr ""

#~ msgid ""
#~ "A WITH-clause \"view\" is read-"
#~ "only because Tarantool does not support"
#~ " updatable views."
#~ msgstr ""

#~ msgid "WITH RECURSIVE"
#~ msgstr ""

#~ msgid "**WITH RECURSIVE clause (iterative common table expression)**"
#~ msgstr ""

#~ msgid ""
#~ "The real power of WITH lies in "
#~ "the WITH RECURSIVE clause, which is "
#~ "useful when it is combined with "
#~ ":ref:`UNION or UNION ALL <sql_union>`:"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`WITH RECURSIVE recursive-table-name "
#~ "AS` |br| :samp:`(SELECT ... FROM non-"
#~ "recursive-table-name ...` |br| "
#~ ":samp:`UNION [ALL]` |br| :samp:`SELECT ... "
#~ "FROM recursive-table-name ...)` |br| "
#~ ":samp:`statement-that-uses-recursive-table-"
#~ "name;` |br|"
#~ msgstr ""

#~ msgid ""
#~ "In non-SQL this can be read "
#~ "as: starting with a seed value "
#~ "from a non-recursive table, produce "
#~ "a recursive viewed table, UNION that "
#~ "with itself, UNION that with itself, "
#~ "UNION that with itself ... forever, "
#~ "or until a condition in the WHERE"
#~ " clause says \"stop\"."
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE ts (s1 INTEGER PRIMARY KEY);\n"
#~ "INSERT INTO ts VALUES (1);\n"
#~ "WITH RECURSIVE w AS (\n"
#~ "  SELECT s1 FROM ts\n"
#~ "  UNION ALL\n"
#~ "  SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
#~ "SELECT * FROM w;"
#~ msgstr ""

#~ msgid "First, table ``w`` is seeded from ``t1``, so it has one row: [1]."
#~ msgstr ""

#~ msgid ""
#~ "Then, ``UNION ALL (SELECT s1 + 1"
#~ " FROM w)`` takes the row from "
#~ "``w`` -- which contains [1] -- "
#~ "adds 1 because the select list "
#~ "says \"s1+1\", and so it has one"
#~ " row: [2]."
#~ msgstr ""

#~ msgid ""
#~ "Then, ``UNION ALL (SELECT s1 + 1"
#~ " FROM w)`` takes the row from "
#~ "``w`` -- which contains [2] -- "
#~ "adds 1 because the select list "
#~ "says \"s1+1\", and so it has one"
#~ " row: [3]."
#~ msgstr ""

#~ msgid ""
#~ "Then, ``UNION ALL (SELECT s1 + 1"
#~ " FROM w)`` takes the row from "
#~ "``w`` -- which contains [3] -- "
#~ "adds 1 because the select list "
#~ "says \"s1+1\", and so it has one"
#~ " row: [4]."
#~ msgstr ""

#~ msgid ""
#~ "Then, ``UNION ALL (SELECT s1 + 1"
#~ " FROM w)`` takes the row from "
#~ "``w`` -- which contains [4] -- and"
#~ " now the importance of the WHERE "
#~ "clause becomes evident, because \"s1 <"
#~ " 4\" is false for this row, and"
#~ " therefore we have reached the "
#~ "\"stop\" condition."
#~ msgstr ""

#~ msgid ""
#~ "So, before the \"stop\", table ``w`` "
#~ "got 4 rows -- [1], [2], [3], "
#~ "[4] -- and the result of the "
#~ "statement looks like:"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> WITH RECURSIVE w AS (\n"
#~ "         >   SELECT s1 FROM ts\n"
#~ "         >   UNION ALL\n"
#~ "         >   SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
#~ "         > SELECT * FROM w;\n"
#~ "---\n"
#~ "- - [1]\n"
#~ "  - [2]\n"
#~ "  - [3]\n"
#~ "  - [4]\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "In other words, this ``WITH RECURSIVE"
#~ " ... SELECT`` produces a table of "
#~ "auto-incrementing values."
#~ msgstr ""

#~ msgid "UNION, EXCEPT, and INTERSECT clauses"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`select-statement UNION [ALL] select-"
#~ "statement [ORDER BY clause] [LIMIT "
#~ "clause];`"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`select-statement EXCEPT select-"
#~ "statement [ORDER BY clause] [LIMIT "
#~ "clause];`"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`select-statement INTERSECT select-"
#~ "statement [ORDER BY clause] [LIMIT "
#~ "clause];`"
#~ msgstr ""

#~ msgid ""
#~ "UNION, EXCEPT, and INTERSECT are "
#~ "collectively called \"set operators\" or "
#~ "\"table operators\". In particular:"
#~ msgstr ""

#~ msgid "``a UNION b`` means \"take rows which occur in a OR b\"."
#~ msgstr ""

#~ msgid "``a EXCEPT b`` means \"take rows which occur in a AND NOT b\"."
#~ msgstr ""

#~ msgid "``a INTERSECT b`` means \"take rows which occur in a AND b\"."
#~ msgstr ""

#~ msgid "Duplicate rows are eliminated unless ALL is specified."
#~ msgstr ""

#~ msgid ""
#~ "The *select-statements* may be chained:"
#~ " ``SELECT ... SELECT ... SELECT "
#~ "...;``"
#~ msgstr ""

#~ msgid "Each *select-statement* must result in the same number of columns."
#~ msgstr ""

#~ msgid ""
#~ "The *select-statements* may be replaced"
#~ " with :ref:`VALUES statements <sql_values>`."
#~ msgstr ""

#~ msgid "The maximum number of set operations is 50."
#~ msgstr "максимальное количество показываемых сегментов"

#~ msgid ""
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
#~ "CREATE TABLE t2 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
#~ "INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, NULL);\n"
#~ "INSERT INTO t2 VALUES (1, 'A'), (2, 'C'), (3,NULL);\n"
#~ "SELECT s2 FROM t1 UNION SELECT s2 FROM t2;\n"
#~ "SELECT s2 FROM t1 UNION ALL SELECT s2 FROM t2 ORDER BY s2;\n"
#~ "SELECT s2 FROM t1 EXCEPT SELECT s2 FROM t2;\n"
#~ "SELECT s2 FROM t1 INTERSECT SELECT s2 FROM t2;"
#~ msgstr ""

#~ msgid "In this example:"
#~ msgstr "В данном примере:"

#~ msgid "The UNION query returns 4 rows: NULL, 'A', 'B', 'C'."
#~ msgstr ""

#~ msgid "The UNION ALL query returns 6 rows: NULL, NULL, 'A', 'A', 'B', 'C'."
#~ msgstr ""

#~ msgid "The EXCEPT query returns 1 row: 'B'."
#~ msgstr ""

#~ msgid "The INTERSECT query returns 2 rows: NULL, 'A'."
#~ msgstr ""

#~ msgid "Parentheses are not allowed."
#~ msgstr ""

#~ msgid "Evaluation is left to right, INTERSECT does not have precedence."
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t01 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
#~ "CREATE TABLE t02 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
#~ "CREATE TABLE t03 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
#~ "INSERT INTO t01 VALUES (1, 'A');\n"
#~ "INSERT INTO t02 VALUES (1, 'B');\n"
#~ "INSERT INTO t03 VALUES (1, 'A');\n"
#~ "SELECT s2 FROM t01 INTERSECT SELECT "
#~ "s2 FROM t03 UNION SELECT s2 FROM"
#~ " t02;\n"
#~ "SELECT s2 FROM t03 UNION SELECT s2"
#~ " FROM t02 INTERSECT SELECT s2 FROM"
#~ " t03;\n"
#~ "-- ... results are different."
#~ msgstr ""

#~ msgid "INDEXED BY clause"
#~ msgstr ""

#~ msgid ":samp:`INDEXED BY {index-name}`"
#~ msgstr ""

#~ msgid ""
#~ "The INDEXED BY clause may be used"
#~ " in a :ref:`SELECT <sql_select>`, "
#~ ":ref:`DELETE <sql_delete>`, or :ref:`UPDATE "
#~ "<sql_update>` statement, immediately after the"
#~ " *table-name*. For example:"
#~ msgstr ""

#~ msgid "DELETE FROM table7 INDEXED BY index7 WHERE column1 = 'a';"
#~ msgstr ""

#~ msgid ""
#~ "In this case the search for 'a'"
#~ " will take place within ``index7``. "
#~ "For example:"
#~ msgstr ""

#~ msgid "SELECT * FROM table7 NOT INDEXED WHERE column1 = 'a';"
#~ msgstr ""

#~ msgid ""
#~ "In this case the search for 'a'"
#~ " will be done via a search of"
#~ " the whole table, what is sometimes"
#~ " called a \"full table scan\", even"
#~ " if there is an index for "
#~ "``column1``."
#~ msgstr ""

#~ msgid ""
#~ "Ordinarily Tarantool chooses the appropriate"
#~ " index or lookup method depending on"
#~ " a complex set of \"optimizer\" "
#~ "rules; the INDEXED BY clause overrides"
#~ " the optimizer choice."
#~ msgstr ""

#~ msgid "Suppose a table has two columns:"
#~ msgstr ""

#~ msgid ""
#~ "The first column is the primary "
#~ "key and therefore it has an "
#~ "automatic index named ``pk_unnamed_T_1``."
#~ msgstr ""

#~ msgid "The second column has an index created by the user."
#~ msgstr ""

#~ msgid ""
#~ "The user selects with ``INDEXED BY "
#~ "the-index-on-column1``, then selects "
#~ "with ``INDEXED BY the-index-on-"
#~ "column-2``."
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
#~ "CREATE INDEX idx_column2_t_1 ON t (column2);\n"
#~ "INSERT INTO t VALUES (1, 2), (2, 1);\n"
#~ "SELECT * FROM t INDEXED BY \"pk_unnamed_T_1\";\n"
#~ "SELECT * FROM t INDEXED BY idx_column2_t_1;\n"
#~ "-- Result for the first select: (1, 2), (2, 1)\n"
#~ "-- Result for the second select: (2, 1), (1, 2)."
#~ msgstr ""

#~ msgid ""
#~ "Limitations: |br| Often INDEXED BY has"
#~ " no effect. |br| Often INDEXED BY "
#~ "affects a choice of covering index, "
#~ "but not a WHERE clause."
#~ msgstr ""

#~ msgid "Transactions"
#~ msgstr "функция"

#~ msgid "START TRANSACTION"
#~ msgstr ""

#~ msgid ":samp:`START TRANSACTION;`"
#~ msgstr ""

#~ msgid ""
#~ "Start a transaction. After ``START "
#~ "TRANSACTION;``, a transaction is \"active\"."
#~ " If a transaction is already active,"
#~ " then ``START TRANSACTION;`` is illegal."
#~ msgstr ""

#~ msgid ""
#~ "Transactions should be active for fairly"
#~ " short periods of time, to avoid "
#~ "concurrency issues. To end a "
#~ "transaction, say :ref:`COMMIT; <sql_commit>` "
#~ "or :ref:`ROLLBACK; <sql_rollback>`."
#~ msgstr ""

#~ msgid ""
#~ "Just as in NoSQL, transaction control"
#~ " statements are subject to limitations "
#~ "set by the :ref:`storage engine "
#~ "<engines-chapter>` involved: |br| * For "
#~ "the memtx storage engine, if a "
#~ "yield happens within an active "
#~ "transaction, the transaction is rolled "
#~ "back. |br| * For the vinyl engine,"
#~ " yields are allowed. |br| Also, "
#~ "although CREATE AND DROP and ALTER "
#~ "statements are legal in transactions, "
#~ "there are a few exceptions. For "
#~ "example, :samp:`CREATE INDEX ON {table_name}"
#~ " ...` will fail within a multi-"
#~ "statement transaction if the table is"
#~ " not empty."
#~ msgstr ""

#~ msgid ""
#~ "However,transaction control statements still "
#~ "may not work as you expect when"
#~ " run over a network connection: a "
#~ "transaction is associated with a fiber,"
#~ " not a network connection, and "
#~ "different transaction control statements sent"
#~ " via the same network connection may"
#~ " be executed by different fibers from"
#~ " the fiber pool."
#~ msgstr ""

#~ msgid ""
#~ "In order to ensure that all "
#~ "statements are part of the intended "
#~ "transaction, put all of them between "
#~ "``START TRANSACTION;`` and ``COMMIT;`` or "
#~ "``ROLLBACK;`` then send as a single "
#~ "batch. For example:"
#~ msgstr ""

#~ msgid ""
#~ "Enclose each separate SQL statement in"
#~ " a :ref:`box.execute() <box-sql_box_execute>` "
#~ "function."
#~ msgstr ""

#~ msgid ""
#~ "Pass all the ``box.execute()`` functions "
#~ "to the server in a single message."
#~ msgstr ""

#~ msgid ""
#~ "If you are using a console, you"
#~ " can do this by writing everything"
#~ " on a single line."
#~ msgstr ""

#~ msgid ""
#~ "If you are using :ref:`net.box "
#~ "<net_box-module>`, you can do this by"
#~ " putting all the function calls in"
#~ " a single string and calling "
#~ ":ref:`eval(string) <net_box-eval>`."
#~ msgstr ""

#~ msgid "START TRANSACTION;"
#~ msgstr ""

#~ msgid ""
#~ "Example of a whole transaction sent "
#~ "to a server on ``localhost:3301`` with"
#~ " ``eval(string)``:"
#~ msgstr ""

#~ msgid ""
#~ "net_box = require('net.box')\n"
#~ "conn = net_box.new('localhost', 3301)\n"
#~ "s = 'box.execute([[START TRANSACTION;]]) '\n"
#~ "s = s .. 'box.execute([[INSERT INTO t VALUES (1);]]) '\n"
#~ "s = s .. 'box.execute([[ROLLBACK;]]) '\n"
#~ "conn:eval(s)"
#~ msgstr ""

#~ msgid "COMMIT"
#~ msgstr ""

#~ msgid ":samp:`COMMIT;`"
#~ msgstr ""

#~ msgid ""
#~ "Commit an active transaction, so all "
#~ "changes are made permanent and the "
#~ "transaction ends."
#~ msgstr ""

#~ msgid ""
#~ "COMMIT is illegal unless a transaction"
#~ " is active. If a transaction is "
#~ "not active then SQL statements are "
#~ "committed automatically."
#~ msgstr ""

#~ msgid "COMMIT;"
#~ msgstr ""

#~ msgid "SAVEPOINT"
#~ msgstr ""

#~ msgid ":samp:`SAVEPOINT {savepoint-name};`"
#~ msgstr ""

#~ msgid ""
#~ "Set a savepoint, so that :ref:`ROLLBACK"
#~ " TO savepoint-name <sql_rollback>` is "
#~ "possible."
#~ msgstr ""

#~ msgid "SAVEPOINT is illegal unless a transaction is active."
#~ msgstr ""

#~ msgid ""
#~ "If a savepoint with the same name"
#~ " already exists, it is released "
#~ "before the new savepoint is set."
#~ msgstr ""

#~ msgid "SAVEPOINT x;"
#~ msgstr ""

#~ msgid "RELEASE SAVEPOINT"
#~ msgstr ""

#~ msgid ":samp:`RELEASE SAVEPOINT {savepoint-name};`"
#~ msgstr ""

#~ msgid ""
#~ "Release (destroy) a savepoint created by"
#~ " a :ref:`SAVEPOINT statement <sql_savepoint>`."
#~ msgstr ""

#~ msgid "RELEASE is illegal unless a transaction is active."
#~ msgstr ""

#~ msgid "Savepoints are released automatically when a transaction ends."
#~ msgstr ""

#~ msgid "RELEASE SAVEPOINT x;"
#~ msgstr ""

#~ msgid "ROLLBACK"
#~ msgstr ""

#~ msgid ":samp:`ROLLBACK [TO [SAVEPOINT] {savepoint-name}];`"
#~ msgstr ""

#~ msgid ""
#~ "If ROLLBACK does not specify a "
#~ "*savepoint-name*, rollback an active "
#~ "transaction, so all changes since "
#~ ":ref:`START TRANSACTION <sql_start_transaction>` are"
#~ " cancelled, and the transaction ends."
#~ msgstr ""

#~ msgid ""
#~ "If ROLLBACK does specify a "
#~ "*savepoint-name*, rollback an active "
#~ "transaction, so all changes since "
#~ ":ref:`SAVEPOINT savepoint-name <sql_savepoint>` "
#~ "are cancelled, and the transaction does"
#~ " not end."
#~ msgstr ""

#~ msgid "ROLLBACK is illegal unless a transaction is active."
#~ msgstr ""

#~ msgid ""
#~ "-- the simple form:\n"
#~ "ROLLBACK;\n"
#~ "-- the form so changes before a savepoint are not cancelled:\n"
#~ "ROLLBACK TO SAVEPOINT x;"
#~ msgstr ""

#~ msgid ""
#~ "-- An example of a Lua function that will do a transaction\n"
#~ "-- containing savepoint and rollback to savepoint.\n"
#~ "function f()\n"
#~ "box.execute([[DROP TABLE IF EXISTS t;]]) -- commits automatically\n"
#~ "box.execute([[CREATE TABLE t (s1 STRING "
#~ "PRIMARY KEY);]]) -- commits automatically\n"
#~ ""
#~ "box.execute([[START TRANSACTION;]]) -- after "
#~ "this succeeds, a transaction is active"
#~ "\n"
#~ "box.execute([[INSERT INTO t VALUES ('Data change #1');]])\n"
#~ "box.execute([[SAVEPOINT \"1\";]])\n"
#~ "box.execute([[INSERT INTO t VALUES ('Data change #2');]])\n"
#~ "box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) "
#~ "-- rollback Data change #2\n"
#~ "box.execute([[ROLLBACK TO SAVEPOINt \"1\";]]) "
#~ "-- this is legal but does nothing"
#~ "\n"
#~ "box.execute([[COMMIT;]]) -- make Data change"
#~ " #1 permanent, end the transaction\n"
#~ "end"
#~ msgstr ""

#~ msgid "PRAGMA"
#~ msgstr ""

#~ msgid ":samp:`PRAGMA {pragma-name} (pragma-value);`"
#~ msgstr ""

#~ msgid "or :samp:`PRAGMA {pragma-name};`"
#~ msgstr ""

#~ msgid ""
#~ "PRAGMA statements will give rudimentary "
#~ "information about database 'metadata' or "
#~ "server performance, although it is "
#~ "better to get metadata via :ref:`system"
#~ " tables <sql_system_tables>`."
#~ msgstr ""

#~ msgid ""
#~ "For PRAGMA statements that include "
#~ "(``pragma-value``), pragma values are "
#~ "strings and can be specified inside "
#~ "``\"\"`` double quotes, or without "
#~ "quotes. When a string is used for"
#~ " searching, results must match according"
#~ " to a binary collation. If the "
#~ "object being searched has a lower-"
#~ "case name, use double quotes."
#~ msgstr ""

#~ msgid ""
#~ "In an earlier version, there were "
#~ "some PRAGMA statements that determined "
#~ "behavior. Now that does not happen. "
#~ "Behavior change is done by updating "
#~ "the :ref:`box.space._session_settings <box_space-"
#~ "session_settings>` system table."
#~ msgstr ""

#~ msgid "Pragma"
#~ msgstr ""

#~ msgid "Parameter"
#~ msgstr "Параметры"

#~ msgid "Effect"
#~ msgstr ""

#~ msgid "foreign_key_list"
#~ msgstr ""

#~ msgid "string |br| table-name"
#~ msgstr "строка, таблица"

#~ msgid ""
#~ "Return a :ref:`result set <box-"
#~ "sql_result_sets>` with one row for each"
#~ " foreign key of \"table-name\". Each"
#~ " row contains: |br| (INTEGER) id --"
#~ " identification number |br| (INTEGER) seq"
#~ " -- sequential number |br| (STRING) "
#~ "table -- name of table |br| "
#~ "(STRING) from  -- referencing key |br|"
#~ " (STRING) to -- referenced key |br|"
#~ " (STRING) on_update -- ON UPDATE "
#~ "clause |br| (STRING) on_delete -- ON "
#~ "DELETE clause |br| (STRING) match -- "
#~ "MATCH clause |br| The system table "
#~ "is ``\"_fk_constraint\"``."
#~ msgstr ""

#~ msgid "collation_list"
#~ msgstr ""

#~ msgid ""
#~ "Return a result set with one row"
#~ " for each supported collation. The "
#~ "first four collations are ``'none'`` and"
#~ " ``'unicode'`` and ``'unicode_ci'`` and "
#~ "``'binary'``, then come about 270 "
#~ "predefined collations, the exact count "
#~ "may vary because users can add "
#~ "their own collations. |br| The system"
#~ " table is ``\"_collation\"``."
#~ msgstr ""

#~ msgid "index_info"
#~ msgstr ""

#~ msgid "string |br| table-name . index-name"
#~ msgstr ""

#~ msgid ""
#~ "Return a result set with one row"
#~ " for each column in \"table-name"
#~ ".index-name\". Each row contains: |br| "
#~ "(INTEGER) seqno -- the column's ordinal"
#~ " position in the index (first column"
#~ " is 0) |br| (INTEGER) cid -- "
#~ "the column's ordinal position in the "
#~ "table (first column is 0) |br| "
#~ "(STRING) name -- name of the "
#~ "column |br| (INTEGER) desc -- 0 if"
#~ " ASC, 1 if DESC |br| (STRING) "
#~ "collation name |br| (STRING) type -- "
#~ "data type |br|"
#~ msgstr ""

#~ msgid "index_list"
#~ msgstr ""

#~ msgid ""
#~ "Return a result set with one row"
#~ " for each index of \"table-name\"."
#~ " Each row contains: |br| (INTEGER) "
#~ "seq -- sequential number |br| (STRING)"
#~ " name -- index name |br| (INTEGER)"
#~ " unique -- whether the index is "
#~ "unique, 0 = false, 1 = true "
#~ "|br| The system table is ``\"_index\"``."
#~ msgstr ""

#~ msgid "stats"
#~ msgstr ""

#~ msgid ""
#~ "Return a result set with one row"
#~ " for each index of each table. "
#~ "Each row contains: |br| (STRING) table"
#~ " -- name of the table |br| "
#~ "(STRING) index -- name of the "
#~ "index |br| (INTEGER) width -- arbitrary"
#~ " information |br| (INTEGER) height -- "
#~ "arbitrary information"
#~ msgstr ""

#~ msgid "table_info"
#~ msgstr "таблица"

#~ msgid ""
#~ "Return a result set with one row"
#~ " for each column in \"table-name\"."
#~ " Each row contains: |br| (INTEGER) "
#~ "cid -- ordinal position in the "
#~ "table |br| (first column number is "
#~ "0) |br| (STRING) name -- column "
#~ "name |br| (INTEGER) notnull -- whether"
#~ " the column is NOT NULL. 0 is"
#~ " false, 1 is true. |br| (STRING) "
#~ "dflt_value -- default value |br| "
#~ "(INTEGER) pk -- whether the column "
#~ "is a PRIMARY KEY column. 0 is "
#~ "false, 1 is true."
#~ msgstr ""

#~ msgid "Example: (not showing result set metadata)"
#~ msgstr ""

#~ msgid ""
#~ "PRAGMA table_info('T');\n"
#~ "---\n"
#~ "- - [0, 's1', 'integer', 1, null, 1]\n"
#~ "  - [1, 's2', 'integer', 0, null, 0]\n"
#~ "..."
#~ msgstr ""

#~ msgid "EXPLAIN"
#~ msgstr ""

#~ msgid ":samp:`EXPLAIN explainable-statement;`"
#~ msgstr ""

#~ msgid ""
#~ "EXPLAIN will show what steps Tarantool"
#~ " would take if it executed "
#~ "explainable-statement. This is primarily a"
#~ " debugging and optimization aid for "
#~ "the Tarantool team."
#~ msgstr ""

#~ msgid "Example: ``EXPLAIN DELETE FROM m;`` returns:"
#~ msgstr ""

#~ msgid ""
#~ "- - [0, 'Init', 0, 3, 0, '', '00', 'Start at 3']\n"
#~ "  - [1, 'Clear', 16416, 0, 0, '', '00', '']\n"
#~ "  - [2, 'Halt', 0, 0, 0, '', '00', '']\n"
#~ "  - [3, 'Transaction', 0, 1, 1, '0', '01', 'usesStmtJournal=0']\n"
#~ "  - [4, 'Goto', 0, 1, 0, '', '00', '']"
#~ msgstr ""

#~ msgid ""
#~ "Variation: ``EXPLAIN QUERY PLAN statement;``"
#~ " shows the steps of a search."
#~ msgstr ""

#~ msgid "Functions"
#~ msgstr "функция"

#~ msgid ""
#~ "Apply a built-in function to one"
#~ " or more expressions and return a "
#~ "scalar value."
#~ msgstr ""

#~ msgid "Tarantool supports 32 built-in functions."
#~ msgstr ""

#~ msgid "The maximum number of operands for any function is 127."
#~ msgstr "максимальное количество показываемых сегментов"

#~ msgid ""
#~ "The required privileges for built-in "
#~ "functions will likely change in a "
#~ "future version."
#~ msgstr ""

#~ msgid "ABS"
#~ msgstr ""

#~ msgid ":samp:`ABS({numeric-expression})`"
#~ msgstr ""

#~ msgid ""
#~ "Return the absolute value of numeric-"
#~ "expression, which can be any numeric "
#~ "type."
#~ msgstr ""

#~ msgid "Example: ``ABS(-1)`` is 1."
#~ msgstr ""

#~ msgid "CAST"
#~ msgstr ""

#~ msgid ":samp:`CAST({expression} AS {data-type})`"
#~ msgstr ""

#~ msgid ""
#~ "Return the expression value after "
#~ "casting to the specified :ref:`data type"
#~ " <sql_column_def_data_type>`."
#~ msgstr ""

#~ msgid "Examples: ``CAST('AB' AS VARBINARY)``, ``CAST(X'4142' AS STRING)``"
#~ msgstr ""

#~ msgid "CHAR"
#~ msgstr ""

#~ msgid ":samp:`CHAR([numeric-expression [,numeric-expression...])`"
#~ msgstr ""

#~ msgid ""
#~ "Return the characters whose Unicode code"
#~ " point values are equal to the "
#~ "numeric expressions."
#~ msgstr ""

#~ msgid "Short example:"
#~ msgstr "Пример:"

#~ msgid ""
#~ "The first 128 Unicode characters are "
#~ "the \"ASCII\" characters, so CHAR(65, "
#~ "66, 67) is 'ABC'."
#~ msgstr ""

#~ msgid "Long example:"
#~ msgstr "Пример:"

#~ msgid ""
#~ "For the current list of Unicode "
#~ "characters, in order by code point, "
#~ "see `www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt "
#~ "<http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt>`_. "
#~ "In that list, there is a line "
#~ "for a Linear B ideogram"
#~ msgstr ""

#~ msgid "``100CC;LINEAR B IDEOGRAM B240 WHEELED CHARIOT ...``"
#~ msgstr ""

#~ msgid ""
#~ "Therefore, for a string with a "
#~ "chariot in the middle, use the "
#~ "concatenation operator ``||`` and the "
#~ "CHAR function"
#~ msgstr ""

#~ msgid "``'start of string ' || CHAR(0X100CC) || ' end of string'``."
#~ msgstr ""

#~ msgid "COALESCE"
#~ msgstr "false"

#~ msgid ":samp:`COALESCE(expression, expression [, expression ...])`"
#~ msgstr ""

#~ msgid ""
#~ "Return the value of the first "
#~ "non-NULL expression, or, if all "
#~ "expression values are NULL, return NULL."
#~ msgstr ""

#~ msgid "``COALESCE(NULL, 17, 32)`` is 17."
#~ msgstr ""

#~ msgid "GREATEST"
#~ msgstr "Тип возвращаемого значения: таблица"

#~ msgid ":samp:`GREATEST({expression-1}, {expression-2}, [{expression-3} ...])`"
#~ msgstr ""

#~ msgid ""
#~ "Return the greatest value of the "
#~ "supplied expressions, or, if any "
#~ "expression is NULL, return NULL. The "
#~ "reverse of ``GREATEST`` is :ref:`LEAST "
#~ "<sql_function_least>`."
#~ msgstr ""

#~ msgid ""
#~ "Examples: ``GREATEST(7, 44, -1)`` is 44;"
#~ " ``GREATEST(1E308, 'a', 0, X'00')`` is "
#~ "'\\0' = the nul character; ``GREATEST(3,"
#~ " NULL, 2)`` is NULL"
#~ msgstr ""

#~ msgid "HEX"
#~ msgstr ""

#~ msgid ":samp:`HEX(expression)`"
#~ msgstr ""

#~ msgid ""
#~ "Return the hexadecimal code for each "
#~ "byte in **expression**, which may be "
#~ "either a string or a byte "
#~ "sequence. For ASCII characters, this is"
#~ " straightforward because the encoding is"
#~ " the same as the code point "
#~ "value. For non-ASCII characters, since"
#~ " character strings are usually encoded "
#~ "in UTF-8, each character will require"
#~ " two or more bytes."
#~ msgstr ""

#~ msgid "``HEX('A')`` will return ``41``."
#~ msgstr ""

#~ msgid "``HEX('Д')`` will return ``D094``."
#~ msgstr ""

#~ msgid "IFNULL"
#~ msgstr "null"

#~ msgid ":samp:`IFNULL(expression, expression)`"
#~ msgstr ""

#~ msgid ""
#~ "Return the value of the first "
#~ "non-NULL expression, or, if both "
#~ "expression values are NULL, return NULL."
#~ " Thus ``IFNULL(expression, expression)`` is "
#~ "the same as :ref:`COALESCE(expression, "
#~ "expression) <sql_function_coalesce>`."
#~ msgstr ""

#~ msgid "``IFNULL(NULL, 17)`` is 17"
#~ msgstr ""

#~ msgid "LEAST"
#~ msgstr ""

#~ msgid ":samp:`LEAST({expression-1}, {expression-2}, [{expression-3} ...])`"
#~ msgstr ""

#~ msgid ""
#~ "Return the least value of the "
#~ "supplied expressions, or, if any "
#~ "expression is NULL, return NULL. The "
#~ "reverse of ``LEAST`` is :ref:`GREATEST "
#~ "<sql_function_greatest>`."
#~ msgstr ""

#~ msgid ""
#~ "Examples: ``LEAST(7, 44, -1)`` is -1;"
#~ " ``LEAST(1E308, 'a', 0, X'00')`` is "
#~ "0; ``LEAST(3, NULL, 2)`` is NULL."
#~ msgstr ""

#~ msgid "LENGTH"
#~ msgstr ""

#~ msgid ":samp:`LENGTH(expression)`"
#~ msgstr ""

#~ msgid ""
#~ "Return the number of characters in "
#~ "the **expression**, or the number of "
#~ "bytes in the **expression**. It depends"
#~ " on the data type: strings with "
#~ "data type STRING are counted in "
#~ "characters, byte sequences with data "
#~ "type VARBINARY are counted in bytes "
#~ "and are not ended by the nul "
#~ "character. There are two aliases for "
#~ "``LENGTH(expression)`` -- ``CHAR_LENGTH(expression)`` "
#~ "and ``CHARACTER_LENGTH(expression)`` do the "
#~ "same thing."
#~ msgstr ""

#~ msgid "``LENGTH('ДД')`` is 2, the string has 2 characters."
#~ msgstr ""

#~ msgid "``LENGTH(CAST('ДД' AS VARBINARY))`` is 4, the string has 4 bytes."
#~ msgstr ""

#~ msgid "``LENGTH(CHAR(0, 65))`` is 2, '\\0' does not mean 'end of string'."
#~ msgstr ""

#~ msgid "``LENGTH(X'410041')`` is 3, X'...' byte sequences have type VARBINARY."
#~ msgstr ""

#~ msgid "LIKELIHOOD"
#~ msgstr ""

#~ msgid ":samp:`LIKELIHOOD({expression}, {number literal})`"
#~ msgstr ""

#~ msgid ""
#~ "Return the result of the expression, "
#~ "provided that the number literal is "
#~ "between 0.0 and 1.0."
#~ msgstr ""

#~ msgid "Example: ``LIKELIHOOD('a' = 'b', .0)`` is FALSE"
#~ msgstr ""

#~ msgid "LIKELY"
#~ msgstr ""

#~ msgid ":samp:`LIKELY({expression})`"
#~ msgstr ""

#~ msgid "Return TRUE if the expression is probably true."
#~ msgstr ""

#~ msgid "Example: ``LIKELY('a' <= 'b')`` is TRUE"
#~ msgstr ""

#~ msgid "LOWER"
#~ msgstr "Восстановление после отказа"

#~ msgid ":samp:`LOWER({string-expression})`"
#~ msgstr ""

#~ msgid ""
#~ "Return the expression, with upper-case"
#~ " characters converted to lower case. "
#~ "The reverse of ``LOWER`` is :ref:`UPPER"
#~ " <sql_function_upper>`."
#~ msgstr ""

#~ msgid "Example: ``LOWER('ДA')`` is 'дa'"
#~ msgstr ""

#~ msgid "NULLIF"
#~ msgstr "null"

#~ msgid ":samp:`NULLIF(expression-1, expression-2)`"
#~ msgstr ""

#~ msgid ""
#~ "Return *expression-1* if *expression-1* <> "
#~ "*expression-2*, otherwise return NULL."
#~ msgstr ""

#~ msgid "``NULLIF('a', 'A')`` is 'a'."
#~ msgstr ""

#~ msgid "``NULLIF(1.00, 1)`` is NULL."
#~ msgstr ""

#~ msgid "POSITION"
#~ msgstr ""

#~ msgid ":samp:`POSITION({expression-1}, {expression-2})`"
#~ msgstr ""

#~ msgid ""
#~ "Return the position of expression-1 "
#~ "within expression-2, or return 0 if "
#~ "expression-1 does not appear within "
#~ "expression-2. The data types of the "
#~ "expressions must be either STRING or "
#~ "VARBINARY. If the expressions have data"
#~ " type STRING, then the result is "
#~ "the character position. If the "
#~ "expressions have data type VARBINARY, "
#~ "then the result is the byte "
#~ "position."
#~ msgstr ""

#~ msgid "Short example: ``POSITION('C', 'ABC')`` is 3"
#~ msgstr ""

#~ msgid ""
#~ "Long example: The UTF-8 encoding for "
#~ "the Latin letter A is hexadecimal "
#~ "41; the UTF-8 encoding for the "
#~ "Cyrillic letter Д is hexadecimal D094"
#~ " -- you can confirm this by "
#~ "saying SELECT HEX('ДA'); and seeing that"
#~ " the result is 'D09441'. If you "
#~ "now execute ``SELECT POSITION('A', 'ДA');``"
#~ " the result will be 2, because "
#~ "'A' is the second character in the"
#~ " string. However, if you now execute"
#~ " ``SELECT POSITION(X'41', X'D09441');`` the "
#~ "result will be 3, because X'41' is"
#~ " the third byte in the byte "
#~ "sequence."
#~ msgstr ""

#~ msgid "PRINTF"
#~ msgstr "порт"

#~ msgid ":samp:`PRINTF(string-expression [, expression ...])`"
#~ msgstr ""

#~ msgid ""
#~ "Return a string formatted according to"
#~ " the rules of the C ``sprintf()`` "
#~ "function, where ``%d%s`` means the next"
#~ " two arguments are a number and "
#~ "a string, and so on."
#~ msgstr ""

#~ msgid "If an argument is missing or is NULL, it becomes:"
#~ msgstr ""

#~ msgid "'0' if the format requires an integer,"
#~ msgstr ""

#~ msgid "'0.0' if the format requires a number with a decimal point,"
#~ msgstr ""

#~ msgid "'' if the format requires a string."
#~ msgstr ""

#~ msgid "Example: ``PRINTF('%da', 5)`` is '5a'."
#~ msgstr ""

#~ msgid "QUOTE"
#~ msgstr ""

#~ msgid ":samp:`QUOTE(string-literal)`"
#~ msgstr ""

#~ msgid ""
#~ "Return a string with enclosing quotes"
#~ " if necessary, and with quotes inside"
#~ " the enclosing quotes if necessary. "
#~ "This function is useful for creating "
#~ "strings which are part of SQL "
#~ "statements, because of SQL's rules that"
#~ " string literals are enclosed by "
#~ "single quotes, and single quotes inside"
#~ " such strings are shown as two "
#~ "single quotes in a row."
#~ msgstr ""

#~ msgid "Example: ``QUOTE('a')`` is ``'a'``."
#~ msgstr ""

#~ msgid "RAISE"
#~ msgstr ""

#~ msgid ":samp:`RAISE(FAIL, {error-message})`"
#~ msgstr ""

#~ msgid ""
#~ "This may only be used within a "
#~ "triggered statement. See also :ref:`Trigger"
#~ " Activation <sql_trigger_activation>`."
#~ msgstr ""

#~ msgid "RANDOM"
#~ msgstr ""

#~ msgid "Syntax: :samp:`RANDOM()`"
#~ msgstr ""

#~ msgid ""
#~ "Return a 19-digit integer which is "
#~ "generated by a pseudo-random number "
#~ "generator,"
#~ msgstr ""

#~ msgid ""
#~ "Example: ``RANDOM()`` is 6832175749978026034, "
#~ "or it is any other integer"
#~ msgstr ""

#~ msgid "RANDOMBLOB"
#~ msgstr ""

#~ msgid ":samp:`RANDOMBLOB({n})`"
#~ msgstr ""

#~ msgid ""
#~ "Return a byte sequence, n bytes "
#~ "long, data type = VARBINARY, containing"
#~ " bytes generated by a pseudo-random"
#~ " byte generator. The result can be"
#~ " translated to hexadecimal. If n is"
#~ " less than 1 or is NULL or "
#~ "is infinity, then NULL is returned."
#~ msgstr ""

#~ msgid ""
#~ "Example: ``HEX(RANDOMBLOB(3))`` is '9EAAA8', "
#~ "or it is the hex value for "
#~ "any other three-byte string"
#~ msgstr ""

#~ msgid ":samp:`REPLACE({expression-1}, {expression-2}, {expression-3})`"
#~ msgstr ""

#~ msgid ""
#~ "Return expression-1, except that wherever "
#~ "expression-1 contains expression-2, replace "
#~ "expression-2 with expression-3. The "
#~ "expressions should all have data type"
#~ " STRING or VARBINARY."
#~ msgstr ""

#~ msgid "Example: ``REPLACE('AAABCCCBD', 'B', '!')`` is 'AAA!CCC!D'"
#~ msgstr ""

#~ msgid "ROUND"
#~ msgstr "Указатель"

#~ msgid ":samp:`ROUND({numeric-expression-1} [, {numeric-expression-2}])`"
#~ msgstr ""

#~ msgid ""
#~ "Return the rounded value of numeric-"
#~ "expression-1, always rounding .5 upward "
#~ "for floating-point positive numbers or"
#~ " downward for negative numbers. If "
#~ "numeric-expression-2 is supplied then "
#~ "rounding is to the nearest numeric-"
#~ "expression-2 digits after the decimal "
#~ "point; if numeric-expression-2 is not"
#~ " supplied then rounding is to the "
#~ "nearest integer."
#~ msgstr ""

#~ msgid "Example: ``ROUND(-1.5)`` is -2, ``ROUND(1.7766E1,2)`` is 17.77."
#~ msgstr ""

#~ msgid "ROW_COUNT"
#~ msgstr ""

#~ msgid ":samp:`ROW_COUNT()`"
#~ msgstr ""

#~ msgid ""
#~ "Return the number of rows that "
#~ "were inserted / updated / deleted "
#~ "by the last :ref:`INSERT <sql_insert>` "
#~ "or :ref:`UPDATE <sql_update>` or :ref:`DELETE"
#~ " <sql_delete>` or :ref:`REPLACE <sql_replace>`"
#~ " statement. Rows which were updated "
#~ "by an UPDATE statement are counted "
#~ "even if there was no change. Rows"
#~ " which were inserted / updated / "
#~ "deleted due to foreign-key action "
#~ "are not counted. Rows which were "
#~ "inserted / updated / deleted due "
#~ "to a view's :ref:`INSTEAD OF triggers"
#~ " <sql_instead_of_triggers>` are  not counted. "
#~ "After a CREATE or DROP statement, "
#~ "ROW_COUNT() is 1. After other "
#~ "statements,  ROW_COUNT() is 0."
#~ msgstr ""

#~ msgid ""
#~ "Example: ``ROW_COUNT()`` is 1 after a"
#~ " successful INSERT of a single row."
#~ msgstr ""

#~ msgid ""
#~ "Special rule if there are BEFORE "
#~ "or AFTER triggers: In effect the "
#~ "ROW_COUNT() counter is pushed at the "
#~ "beginning of a series of triggered "
#~ "statements, and popped at the end. "
#~ "Therefore, after the following statements:"
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY);\n"
#~ "CREATE TABLE t2 (s1 INTEGER, s2 "
#~ "STRING, s3 INTEGER, PRIMARY KEY (s1, "
#~ "s2, s3));\n"
#~ "CREATE TRIGGER tt1 BEFORE DELETE ON t1 FOR EACH ROW BEGIN\n"
#~ "  INSERT INTO t2 VALUES (old.s1, '#2 Triggered', ROW_COUNT());\n"
#~ "  INSERT INTO t2 VALUES (old.s1, '#3 Triggered', ROW_COUNT());\n"
#~ "  END;\n"
#~ "INSERT INTO t1 VALUES (1),(2),(3);\n"
#~ "DELETE FROM t1;\n"
#~ "INSERT INTO t2 VALUES (4, '#4 Untriggered', ROW_COUNT());\n"
#~ "SELECT * FROM t2;"
#~ msgstr ""

#~ msgid "The result is:"
#~ msgstr ""

#~ msgid ""
#~ "---\n"
#~ "- - [1, '#2 Triggered', 3]\n"
#~ "  - [1, '#3 Triggered', 1]\n"
#~ "  - [2, '#2 Triggered', 3]\n"
#~ "  - [2, '#3 Triggered', 1]\n"
#~ "  - [3, '#2 Triggered', 3]\n"
#~ "  - [3, '#3 Triggered', 1]\n"
#~ "  - [4, '#4 Untriggered', 3]\n"
#~ "..."
#~ msgstr ""

#~ msgid "SOUNDEX"
#~ msgstr "Указатель"

#~ msgid ":samp:`SOUNDEX(string-expression)`"
#~ msgstr ""

#~ msgid ""
#~ "Return a four-character string which "
#~ "represents the sound of ``string-"
#~ "expression``. Often words and names "
#~ "which have different spellings will have"
#~ " the same Soundex representation if "
#~ "they are pronounced similarly, so it "
#~ "is possible to search by what they"
#~ " sound like. The algorithm works with"
#~ " characters in the Latin alphabet and"
#~ " works best with English words."
#~ msgstr ""

#~ msgid ""
#~ "Example: ``SOUNDEX('Crater')`` and "
#~ "``SOUNDEX('Creature')`` both return ``C636``."
#~ msgstr ""

#~ msgid "SUBSTR"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`SUBSTR({expression-1}, {numeric-expression-1} "
#~ "[, {numeric-expression-2}])`"
#~ msgstr ""

#~ msgid ""
#~ "If expression-1 has data type STRING,"
#~ " then return the substring which "
#~ "begins at character position numeric-"
#~ "expression-1 and continues for numeric-"
#~ "expression-2 characters (if numeric-"
#~ "expression-2 is supplied), or continues "
#~ "till the end of string-expression-1 "
#~ "(if numeric-expression-2 is not "
#~ "supplied)."
#~ msgstr ""

#~ msgid ""
#~ "If expression-1 has data type VARBINARY"
#~ " rather than data type STRING, then"
#~ " positioning and counting is by bytes"
#~ " rather than by characters."
#~ msgstr ""

#~ msgid "Example: ``SUBSTR('ABCDEFG', 3, 2)`` is 'CD'"
#~ msgstr ""

#~ msgid "TRIM"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`TRIM([[LEADING|TRAILING|BOTH] [{expression-1}] "
#~ "FROM] {expression-2})`"
#~ msgstr ""

#~ msgid ""
#~ "Return expression-2 after removing all "
#~ "leading and/or trailing characters or "
#~ "bytes. The expressions should have data"
#~ " type STRING or VARBINARY. If "
#~ "LEADING|TRAILING|BOTH is omitted, the default"
#~ " is BOTH. If expression-1 is omitted,"
#~ " the default is ' ' (space) for"
#~ " data type STRING or X'00' (nul) "
#~ "for data type VARBINARY."
#~ msgstr ""

#~ msgid ""
#~ "Examples: ``TRIM('a' FROM 'abaaaaa')`` is "
#~ "'b' -- all repetitions of 'a' are"
#~ " removed on both sides; ``TRIM(TRAILING "
#~ "'ב' FROM 'אב')`` is 'א' -- if "
#~ "all characters are Hebrew, TRAILING "
#~ "means \"left\"; ``TRIM(X'004400')`` is X'44'"
#~ " -- the default byte sequence to "
#~ "trim is X'00' when data type is"
#~ " VARBINARY; ``TRIM(LEADING 'abc' FROM "
#~ "'abcd')`` is 'd' -- expression-1 can "
#~ "have more than 1 character."
#~ msgstr ""

#~ msgid "TYPEOF"
#~ msgstr "SO_TYPE"

#~ msgid ":samp:`TYPEOF({expression})`"
#~ msgstr ""

#~ msgid ""
#~ "Return the :ref:`data type "
#~ "<sql_column_def_data_type>` of the expression."
#~ msgstr ""

#~ msgid ""
#~ "Examples: ``TYPEOF('A')`` returns 'string'; "
#~ "``TYPEOF(RANDOMBLOB(1))`` returns 'varbinary'; "
#~ "``TYPEOF(1e44)`` returns 'double' or 'number';"
#~ " ``TYPEOF(-44)`` returns 'integer'; "
#~ "``TYPEOF(NULL)`` returns 'boolean'"
#~ msgstr ""

#~ msgid "UNICODE"
#~ msgstr "Lua-код"

#~ msgid ":samp:`UNICODE(string-expression)`"
#~ msgstr ""

#~ msgid ""
#~ "Return the Unicode code point value "
#~ "of the first character of **string-"
#~ "expression**. If *string-expression* is "
#~ "empty, the return is NULL. This is"
#~ " the reverse of :ref:`CHAR(integer) "
#~ "<sql_function_char>`."
#~ msgstr ""

#~ msgid "Example: ``UNICODE('Щ')`` is 1065 (hexadecimal 0429)."
#~ msgstr ""

#~ msgid "UNLIKELY"
#~ msgstr ""

#~ msgid ":samp:`UNLIKELY({expression})`"
#~ msgstr ""

#~ msgid ""
#~ "Return TRUE if the expression is "
#~ "probably false. Limitation: in fact "
#~ "``UNLIKELY`` may return the same thing"
#~ " as :ref:`LIKELY <sql_function_likely>`."
#~ msgstr ""

#~ msgid "Example: ``UNLIKELY('a' <= 'b')`` is TRUE."
#~ msgstr ""

#~ msgid "UPPER"
#~ msgstr ""

#~ msgid ":samp:`UPPER(string-expression)`"
#~ msgstr ""

#~ msgid ""
#~ "Return the expression, with lower-case"
#~ " characters converted to upper case. "
#~ "The reverse of ``UPPER`` is :ref:`LOWER"
#~ " <sql_function_lower>`."
#~ msgstr ""

#~ msgid "Example: ``UPPER('-4щl')`` is '-4ЩL'."
#~ msgstr ""

#~ msgid "VERSION"
#~ msgstr "Замена регистра"

#~ msgid ":samp:`VERSION()`"
#~ msgstr ""

#~ msgid "Return the Tarantool version."
#~ msgstr "Запустите Tarantool-сервер, как описано выше."

#~ msgid ""
#~ "Example: for a February 2020 build "
#~ "VERSION() is ``'2.4.0-35-g57f6fc932'``."
#~ msgstr ""

#~ msgid "ZEROBLOB"
#~ msgstr ""

#~ msgid ":samp:`ZEROBLOB({n})`"
#~ msgstr ""

#~ msgid "Return a byte sequence, data type = VARBINARY, n bytes long."
#~ msgstr ""

#~ msgid "COLLATE clause"
#~ msgstr ""

#~ msgid ":samp:`COLLATE collation-name`"
#~ msgstr ""

#~ msgid "The collation-name must identify an existing collation."
#~ msgstr ""

#~ msgid ""
#~ "The COLLATE clause is allowed for "
#~ "STRING or SCALAR items: |br| () in"
#~ " :ref:`CREATE INDEX <sql_create_index>` |br| "
#~ "() in :ref:`CREATE TABLE <sql_create_table>`"
#~ " as part of :ref:`column definition "
#~ "<sql_column_def>` |br| () in CREATE "
#~ "TABLE as part of :ref:`UNIQUE definition"
#~ " <sql_table_constraint_def>` |br| () in "
#~ "string expressions |br|"
#~ msgstr ""

#~ msgid ""
#~ "-- In CREATE INDEX\n"
#~ "CREATE INDEX idx_unicode_mb_1 ON mb (s1 COLLATE \"unicode\");\n"
#~ "-- In CREATE TABLE\n"
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY "
#~ "KEY, s2 STRING COLLATE \"unicode_ci\");\n"
#~ ""
#~ "-- In CREATE TABLE ... UNIQUE\n"
#~ "CREATE TABLE mb (a STRING, b "
#~ "STRING, PRIMARY KEY(a), UNIQUE(b COLLATE "
#~ "\"unicode_ci\" DESC));\n"
#~ "-- In string expressions\n"
#~ "SELECT 'a' = 'b' COLLATE \"unicode\"\n"
#~ "    FROM t\n"
#~ "    WHERE s1 = 'b' COLLATE \"unicode\"\n"
#~ "    ORDER BY s1 COLLATE \"unicode\";"
#~ msgstr ""

#~ msgid ""
#~ "The list of collations can be seen"
#~ " with: :ref:`PRAGMA collation_list; <sql_pragma>`"
#~ msgstr ""

#~ msgid ""
#~ "The collation rules comply completely "
#~ "with the Unicode Technical Standard #10"
#~ " (`\"Unicode Collation Algorithm\" "
#~ "<http://unicode.org/reports/tr10/>`_) and the "
#~ "default character order is as in "
#~ "the `Default Unicode Collation Element "
#~ "Table (DUCET) "
#~ "<https://www.unicode.org/Public/UCA/8.0.0/allkeys.txt>`_. There"
#~ " are many permanent collations; the "
#~ "commonly used ones include: |br| |nbsp|"
#~ " |nbsp| ``\"none\"`` (not applicable) |br|"
#~ " |nbsp| |nbsp| ``\"unicode\"`` (characters "
#~ "are in DUCET order with strength ="
#~ " 'tertiary') |br| |nbsp| |nbsp| "
#~ "``\"unicode_ci\"`` (characters are in DUCET"
#~ " order with strength = 'primary') "
#~ "|br| |nbsp| |nbsp| ``\"binary\"`` (characters"
#~ " are in code point order) |br| "
#~ "These identifiers must be quoted and "
#~ "in lower case because they are in"
#~ " lower case in :ref:`Tarantool/NoSQL "
#~ "collations <index-collation>`."
#~ msgstr ""

#~ msgid ""
#~ "If one says ``COLLATE \"binary\"``, this"
#~ " is equivalent to asking for what "
#~ "is sometimes called \"code point order\""
#~ " because, if the contents are in "
#~ "the UTF-8 character set, characters with"
#~ " larger code points will appear after"
#~ " characters with lower code points."
#~ msgstr ""

#~ msgid ""
#~ "In an expression, ``COLLATE`` is an "
#~ "operator with higher precedence than "
#~ "anything except ``~``. This is fine "
#~ "because there are no other useful "
#~ "operators except ``||`` and comparison. "
#~ "After ``||``, collation is preserved."
#~ msgstr ""

#~ msgid ""
#~ "In an expression with more than "
#~ "one ``COLLATE`` clause, if the collation"
#~ " names differ, there is an error: "
#~ "\"Illegal mix of collations\". In an "
#~ "expression with no ``COLLATE`` clauses, "
#~ "literals have collation ``\"binary\"``, "
#~ "columns have the collation specified by"
#~ " ``CREATE TABLE``."
#~ msgstr ""

#~ msgid ""
#~ "In other words, to pick a "
#~ "collation, we use: |br| the first "
#~ "``COLLATE`` clause in an expression if"
#~ " it was specified, |br| else the "
#~ "the column's ``COLLATE`` clause if it"
#~ " was specified, |br| else ``\"binary\"``."
#~ msgstr ""

#~ msgid ""
#~ "However, for searches and sometimes for"
#~ " sorting, the collation may be an "
#~ "index's collation, so all non-index "
#~ "``COLLATE`` clauses are ignored."
#~ msgstr ""

#~ msgid ""
#~ ":ref:`EXPLAIN <sql_explain>` will not show "
#~ "the name of what collation was "
#~ "used, but will show the collation's "
#~ "characteristics."
#~ msgstr ""

#~ msgid ""
#~ "Example with Swedish collation: |br| "
#~ "Knowing that \"sv\" is the two-"
#~ "letter code for Swedish, |br| and "
#~ "knowing that \"s1\" means strength = "
#~ "1, |br| and seeing with ``PRAGMA "
#~ "collation_list;`` that there is a "
#~ "collation named unicode_sv_s1, |br| check "
#~ "whether two strings are equal according"
#~ " to Swedish rules (yes they are): "
#~ "|br| ``SELECT 'ÄÄ' = 'ĘĘ' COLLATE "
#~ "\"unicode_sv_s1\";``"
#~ msgstr ""

#~ msgid ""
#~ "Example with Russian and Ukrainian and"
#~ " Kyrgyz collations: |br| Knowing that "
#~ "Russian collation is practically the "
#~ "same as Unicode default, |br| and "
#~ "knowing that the two-letter codes "
#~ "for Ukrainian and Kyrgyz are 'uk' "
#~ "and 'ky', |br| and knowing that in"
#~ " Russian (but not Ukrainian) 'Г' ="
#~ " 'Ґ' with strength=primary, |br| and "
#~ "knowing that in Russian (but not "
#~ "Kyrgyz) 'Е' = 'Ё' with strength=primary,"
#~ " |br| the three SELECT statements "
#~ "here will return results in three "
#~ "different orders: |br| ``CREATE TABLE "
#~ "things (remark STRING PRIMARY KEY);`` "
#~ "|br| ``INSERT INTO things VALUES ('Е2'),"
#~ " ('Ё1');`` |br| ``INSERT INTO things "
#~ "VALUES ('Г2'), ('Ґ1');`` |br| ``SELECT "
#~ "remark FROM things ORDER BY remark "
#~ "COLLATE \"unicode\";`` |br| ``SELECT remark"
#~ " FROM things ORDER BY remark COLLATE"
#~ " \"unicode_uk_s1\";`` |br| ``SELECT remark "
#~ "FROM things ORDER BY remark COLLATE "
#~ "\"unicode_ky_s1\";``"
#~ msgstr ""

#~ msgid "SQL PLUS LUA -- Adding Tarantool/NoSQL to Tarantool/SQL"
#~ msgstr ""

#~ msgid ""
#~ "The Adding Tarantool/NoSQL To Tarantool/SQL"
#~ " Guide contains descriptions of NoSQL "
#~ "database objects that can be accessed"
#~ " from SQL, of SQL database objects"
#~ " that can be accessed from NoSQL, "
#~ "of the way to call SQL from "
#~ "Lua, and of the way to call "
#~ "Lua from SQL."
#~ msgstr ""

#~ msgid "Lua Requests"
#~ msgstr "SELECT-запросы"

#~ msgid ""
#~ "A great deal of functionality is "
#~ "not specifically part of Tarantool's SQL"
#~ " feature, but is part of the "
#~ "Tarantool Lua application server and "
#~ "DBMS. Here we will give examples "
#~ "so it is clear where to look "
#~ "in other sections of the Tarantool "
#~ "manual."
#~ msgstr ""

#~ msgid ""
#~ "NoSQL :ref:`\"spaces\" <index-box_space>` can"
#~ " be accessed as SQL ``\"tables\"``, "
#~ "and vice versa. For example, suppose "
#~ "a table has been created with |br|"
#~ " ``CREATE TABLE things (id INTEGER "
#~ "PRIMARY KEY, remark SCALAR);``"
#~ msgstr ""

#~ msgid ""
#~ "This is viewable from Tarantool's NoSQL"
#~ " feature as a memtx space named "
#~ "THINGS with a primary-key :ref:`TREE "
#~ "index <index-box_index>` ..."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.space.THINGS\n"
#~ "---\n"
#~ "- engine: memtx\n"
#~ "  before_replace: 'function: 0x40bb4608'\n"
#~ "  on_replace: 'function: 0x40bb45e0'\n"
#~ "  ck_constraint: []\n"
#~ "  field_count: 2\n"
#~ "  temporary: false\n"
#~ "  index:\n"
#~ "    0: &0\n"
#~ "      unique: true\n"
#~ "      parts:\n"
#~ "     - type: integer\n"
#~ "        is_nullable: false\n"
#~ "        fieldno: 1\n"
#~ "      id: 0\n"
#~ "      space_id: 520\n"
#~ "      type: TREE\n"
#~ "      name: pk_unnamed_THINGS_1\n"
#~ "    pk_unnamed_THINGS_1: *0\n"
#~ "  is_local: false\n"
#~ "  enabled: true\n"
#~ "  name: THINGS\n"
#~ "  id: 520"
#~ msgstr ""

#~ msgid ""
#~ "The NoSQL :ref:`basic data operation "
#~ "requests <index-box_data-operations>` select,"
#~ " insert, replace, upsert, update, delete"
#~ " will all work. Particularly interesting"
#~ " are the requests that come only "
#~ "via NoSQL."
#~ msgstr ""

#~ msgid ""
#~ "To create an index on things "
#~ "(remark) with a non-default :ref:`option"
#~ " <box_space-create_index-options>` for "
#~ "example a special id, say: |br| "
#~ "``box.space.THINGS:create_index('idx_100_things_2', {id=100, "
#~ "parts={2, 'scalar'}})``"
#~ msgstr ""

#~ msgid ""
#~ "(If the SQL data type name is "
#~ "SCALAR, then the NoSQL type is "
#~ "'scalar', as described earlier. See the"
#~ " chart in section :ref:`Operands "
#~ "<sql_operands>`.)"
#~ msgstr ""

#~ msgid ""
#~ "To :ref:`grant <box_schema-user_grant>` "
#~ "database-access privileges to user 'guest',"
#~ " say |br| ``box.schema.user.grant('guest', "
#~ "'execute', 'universe')`` |br| To grant "
#~ "SELECT privileges on table things to "
#~ "user 'guest', say |br| "
#~ "``box.schema.user.grant('guest',  'read', 'space', "
#~ "'THINGS')`` |br| To grant UPDATE "
#~ "privileges on table things to user "
#~ "'guest', say: |br| ``box.schema.user.grant('guest',"
#~ " 'read,write', 'space', 'THINGS')`` |br| To"
#~ " grant DELETE or INSERT privileges on"
#~ " table things if no reading is "
#~ "involved, say: |br| ``box.schema.user.grant('guest',"
#~ " 'write', 'space', 'THINGS')`` |br| To "
#~ "grant DELETE or INSERT privileges on "
#~ "table things if reading is involved, "
#~ "say: |br| ``box.schema.user.grant('guest',  "
#~ "'read,write',  'space',  'THINGS')`` |br| To"
#~ " grant CREATE TABLE privilege to user"
#~ " 'guest', say |br| "
#~ "``box.schema.user.grant('guest', 'read,write', 'space',"
#~ " '_schema')`` |br| ``box.schema.user.grant('guest', "
#~ "'read,write', 'space', '_space')`` |br| "
#~ "``box.schema.user.grant('guest', 'read,write', 'space',"
#~ " '_index')`` |br| ``box.schema.user.grant('guest', "
#~ "'create', 'space')`` |br| To grant "
#~ "CREATE TRIGGER privilege to user "
#~ "'guest', say |br| ``box.schema.user.grant('guest',"
#~ " 'read', 'space', '_space')`` |br| "
#~ "``box.schema.user.grant('guest', 'read,write', 'space',"
#~ " '_trigger')`` |br| To grant CREATE "
#~ "INDEX privilege to user 'guest', say "
#~ "|br| ``box.schema.user.grant('guest', 'read,write', "
#~ "'space', '_index')`` |br| "
#~ "``box.schema.user.grant('guest', 'create', 'space')`` "
#~ "|br| To grant CREATE TABLE ... "
#~ "INTEGER PRIMARY KEY AUTOINCREMENT to "
#~ "user 'guest', say |br| "
#~ "``box.schema.user.grant('guest', 'read,write', 'space',"
#~ " '_schema')`` |br| ``box.schema.user.grant('guest', "
#~ "'read,write', 'space', '_space')`` |br| "
#~ "``box.schema.user.grant('guest', 'read,write', 'space',"
#~ " '_index')`` |br| ``box.schema.user.grant('guest', "
#~ "'create', 'space')`` |br| "
#~ "``box.schema.user.grant('guest', 'read,write', 'space',"
#~ " '_space_sequence')`` |br| "
#~ "``box.schema.user.grant('guest', 'read,write', 'space',"
#~ " '_sequence')`` |br| ``box.schema.user.grant('guest',"
#~ " 'create', 'sequence')`` |br|"
#~ msgstr ""

#~ msgid ""
#~ "To write a stored procedure that "
#~ "inserts 5 rows in things, say |br|"
#~ " ``function f() for i = 3, 7"
#~ " do box.space.THINGS:insert{i, i} end end``"
#~ " |br| For client-side API functions,"
#~ " see section :ref:`\"Connectors\" <index-"
#~ "box_connectors>`."
#~ msgstr ""

#~ msgid ""
#~ "To make spaces with field names "
#~ "that SQL can understand, use "
#~ ":ref:`space_object:format() <box_space-format>`. "
#~ "(Exception: in Tarantool/NoSQL it is "
#~ "legal for tuples to have more "
#~ "fields than are described by a "
#~ "format clause, but in Tarantool/SQL such"
#~ " fields will be ignored.)"
#~ msgstr ""

#~ msgid ""
#~ "To handle replication and sharding of"
#~ " SQL data, see section :ref:`Sharding "
#~ "<shard-module>`."
#~ msgstr ""

#~ msgid ""
#~ "To enhance performance of SQL statements"
#~ " by preparing them in advance, see"
#~ " section :ref:`box.prepare() <box-"
#~ "sql_box_prepare>`."
#~ msgstr ""

#~ msgid ""
#~ "To call SQL from Lua, see section"
#~ " :ref:`box.execute([[...]]) <box-sql>`."
#~ msgstr ""

#~ msgid ""
#~ "Limitations: (`Issue#2368 "
#~ "<https://github.com/tarantool/tarantool/issues/2368>`_) |br| "
#~ "* after "
#~ "``box.schema.user.grant('guest','read,write,execute','universe')``,"
#~ " user ``'guest'`` can create tables. "
#~ "But this is a powerful set of "
#~ "privileges."
#~ msgstr ""

#~ msgid ""
#~ "Limitations: (`Issue#4659 "
#~ "<https://github.com/tarantool/tarantool/issues/4659>`_, "
#~ "`Issue#4757 "
#~ "<https://github.com/tarantool/tarantool/issues/4757>`_, "
#~ "`Issue#4758 "
#~ "<https://github.com/tarantool/tarantool/issues/4758>`_) |br| "
#~ "SELECT with * or ORDER BY or "
#~ "GROUP BY from spaces that have map"
#~ " fields or array fields may cause "
#~ "errors. Any access to spaces that "
#~ "have hash indexes may cause severe "
#~ "errors."
#~ msgstr ""

#~ msgid "System Tables"
#~ msgstr ""

#~ msgid ""
#~ "There is a way to get some "
#~ "information about the database objects, "
#~ "for example the names of all the"
#~ " tables and their indexes, using "
#~ ":ref:`SELECT statements <sql_select>`. This is"
#~ " done by looking at special read-"
#~ "only tables which Tarantool updates "
#~ "automatically whenever objects are created "
#~ "or dropped. See the :ref:`submodule "
#~ "box.space <box_space>` overview section. Names"
#~ " of system tables are in lower "
#~ "case so always enclose them in "
#~ "``\"quotes\"``."
#~ msgstr ""

#~ msgid ""
#~ "For example, the :ref:`_space <box_space-"
#~ "space>` system table has these fields"
#~ " which are seen in SQL as "
#~ "columns: |br| |nbsp|  id = numeric "
#~ "identifier |br| |nbsp|  owner = for "
#~ "example, 1 if the object was made"
#~ " by the ``'admin'`` user |br| |nbsp|"
#~ "  name = the name that was used"
#~ " with :ref:`CREATE TABLE <sql_create_table>` "
#~ "|br| |nbsp|  engine = usually "
#~ "``'memtx'`` (the ``'vinyl'`` engine can "
#~ "be used but is not default) |br|"
#~ " |nbsp|  field_count = sometimes 0, "
#~ "but usually a count of the table's"
#~ " columns |br| |nbsp|  flags = usually"
#~ " empty |br| |nbsp|  format = what "
#~ "a Lua format() function or an SQL"
#~ " CREATE statement produced |br| Example "
#~ "selection: |br| |nbsp|  ``SELECT \"id\", "
#~ "\"name\" FROM \"_space\";``"
#~ msgstr ""

#~ msgid ""
#~ "See also: :ref:`Lua functions to make"
#~ " views of metadata <sql_lua_functions>`."
#~ msgstr ""

#~ msgid "Calling Lua routines from SQL"
#~ msgstr ""

#~ msgid ""
#~ "SQL statements can invoke functions that"
#~ " are written in Lua. This is "
#~ "Tarantool's equivalent for the \"stored "
#~ "procedure\" feature found in other SQL"
#~ " DBMSs. Tarantool server-side stored "
#~ "procedures are written in Lua rather "
#~ "than SQL/PSM dialect."
#~ msgstr ""

#~ msgid ""
#~ "Functions can be invoked anywhere that"
#~ " the SQL syntax allows a literal "
#~ "or a column name for reading. "
#~ "Function parameters can include any "
#~ "number of SQL values. If a SELECT"
#~ " statement's result set has a million"
#~ " rows, and the :ref:`select list "
#~ "<sql_select_list>` invokes a non-deterministic"
#~ " function, then the function is "
#~ "called a million times."
#~ msgstr ""

#~ msgid ""
#~ "To create a Lua function that you"
#~ " can call from SQL, use "
#~ ":ref:`box.schema.func.create(func-name, {options-"
#~ "with-body}) <box_schema-func_create_with-body>`"
#~ " with these additional options:"
#~ msgstr ""

#~ msgid ""
#~ "``exports = {'LUA', 'SQL'}`` -- This "
#~ "indicates what languages can call the"
#~ " function. The default is ``'LUA'``. "
#~ "Specify both: ``'LUA', 'SQL'``."
#~ msgstr ""

#~ msgid ""
#~ "``param_list = {list}`` -- This is "
#~ "the list of parameters. Specify the "
#~ "Lua type names for each parameter "
#~ "of the function. Remember that a "
#~ "Lua type name is :ref:`the same as"
#~ " <sql_operands>` an SQL data type "
#~ "name, in lower case. The Lua type"
#~ " should not be an array."
#~ msgstr ""

#~ msgid ""
#~ "Also it is good to specify "
#~ "``{deterministic = true}`` if possible, "
#~ "because that may allow Tarantool to "
#~ "generate more efficient SQL byte code."
#~ msgstr ""

#~ msgid ""
#~ "For a useful example, here is a"
#~ " general function for decoding a "
#~ "single Lua ``'map'`` field:"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.func.create('_DECODE',\n"
#~ "   {language = 'LUA',\n"
#~ "    returns = 'string',\n"
#~ "    body = [[function (field, part)\n"
#~ "             __GLOBAL= field\n"
#~ "             return dostring(\"return "
#~ "require('msgpack').decode(__GLOBAL,1).\" .. part)\n"
#~ "             end]],\n"
#~ "    is_sandboxed = false,\n"
#~ "    param_list = {'string', \"string\"},\n"
#~ "    exports = {'LUA', 'SQL'},\n"
#~ "    is_deterministic = true})"
#~ msgstr ""

#~ msgid ""
#~ "See it work with, say, the "
#~ "_trigger space. That space has a "
#~ "``'map'`` field named opts which has "
#~ "a part named sql. By selecting "
#~ "from the space and passing the "
#~ "field and the part name to "
#~ "_DECODE, you can get a list of "
#~ "all the trigger bodies."
#~ msgstr ""

#~ msgid ""
#~ "__GLOBAL = \"\"\n"
#~ "box.execute([[SELECT _decode(\"opts\", 'sql') FROM \"_trigger\";]])"
#~ msgstr ""

#~ msgid ""
#~ "Remember that SQL converts :ref:`regular "
#~ "identifiers <sql_identifiers>` to upper case,"
#~ " so this example works with a "
#~ "function named _DECODE. If the function"
#~ " had been named _decode, then the "
#~ "SELECT statement would have to be: "
#~ "|br| ``box.execute([[SELECT \"_decode\"(\"opts\", "
#~ "'sql') FROM \"_trigger\";]])``"
#~ msgstr ""

#~ msgid ""
#~ "Here is another example, which "
#~ "illustrates the way that Tarantool "
#~ "creates a view which includes the "
#~ "table_name and table_type columns in the"
#~ " same way that the standard-SQL "
#~ "information_schema.tables view contains them. "
#~ "The difficulty is that, in order "
#~ "to discover whether table_type should be"
#~ " ``'BASE TABLE'`` or should be "
#~ "``'VIEW'``, we need to know the "
#~ "value of the ``\"flags\"`` field in "
#~ "the Tarantool/NoSQL :ref:`\"_space\" <box_space-"
#~ "space>` or ``\"_vspace\"`` space. The "
#~ "``\"flags\"`` field type is ``\"map\"``, "
#~ "which SQL does not understand well. "
#~ "If there were no Lua functions, we"
#~ " would have to treat it as a"
#~ " VARBINARY and look for "
#~ "``POSITION(X'A476696577C3',\"flags\")  > 0`` (A4 "
#~ "is a MsgPack signal that a 4-byte"
#~ " string follows, 76696577 is UTF8 "
#~ "encoding for 'view', C3 is a "
#~ "MsgPack code meaning true). But we "
#~ "have a more sophisticated way, we "
#~ "can create a function that returns "
#~ "true if ``\"flags\".view`` is true. So"
#~ " our way of making the function "
#~ "looks like this:"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.func.create('TABLES_IS_VIEW',\n"
#~ "     {language = 'LUA',\n"
#~ "      returns = 'boolean',\n"
#~ "      body = [[function (flags)\n"
#~ "          local view\n"
#~ "          view = require('msgpack').decode(flags).view\n"
#~ "          if view == nil then return false end\n"
#~ "          return view\n"
#~ "          end]],\n"
#~ "     is_sandboxed = false,\n"
#~ "     param_list = {'string'},\n"
#~ "     exports = {'LUA', 'SQL'},\n"
#~ "     is_deterministic = true})"
#~ msgstr ""

#~ msgid "And this creates the view:"
#~ msgstr ""

#~ msgid ""
#~ "box.execute([[\n"
#~ "CREATE VIEW vtables AS SELECT\n"
#~ "\"name\" AS table_name,\n"
#~ "CASE WHEN tables_is_view(\"flags\") == TRUE THEN 'VIEW'\n"
#~ "     ELSE 'BASE TABLE' END AS table_type,\n"
#~ "\"id\" AS id,\n"
#~ "\"engine\" AS engine,\n"
#~ "(SELECT \"name\" FROM \"_vuser\" x\n"
#~ " WHERE x.\"id\" = y.\"owner\") AS owner,\n"
#~ "\"field_count\" AS field_count\n"
#~ "FROM \"_vspace\" y;\n"
#~ "]])"
#~ msgstr ""

#~ msgid ""
#~ "Remember that these Lua functions are"
#~ " persistent, so if the server has "
#~ "to be restarted then they do not"
#~ " have to be re-declared."
#~ msgstr ""

#~ msgid "Executing Lua chunks"
#~ msgstr "Исполнение оператора"

#~ msgid ""
#~ "To execute Lua code without creating "
#~ "a function, use: |br| :samp:`LUA({Lua-"
#~ "code-string})` |br| where Lua-code-"
#~ "string is any amount of Lua code."
#~ " The string should begin with "
#~ "``'return '``."
#~ msgstr ""

#~ msgid ""
#~ "For example this will show the "
#~ "number of seconds since the epoch: "
#~ "|br| ``box.execute([[SELECT lua('return "
#~ "os.time()');]])`` |br| For example this "
#~ "will show a database configuration "
#~ "member: |br| ``box.execute([[SELECT lua('return "
#~ "box.cfg.memtx_memory');]])`` |br| For example "
#~ "this will return FALSE because Lua "
#~ "nil and box.NULL are the same as"
#~ " SQL NULL: |br| ``box.execute([[SELECT "
#~ "lua('return box.NULL') IS NOT NULL;]])``"
#~ msgstr ""

#~ msgid ""
#~ "Warning: the SQL statement must not "
#~ "invoke a Lua function, or execute "
#~ "a Lua chunk, that accesses a space"
#~ " that underlies any SQL table that"
#~ " the SQL statement accesses. For "
#~ "example, if function ``f()`` contains a"
#~ " request ``\"box.space.TEST:insert{0}\"``, then "
#~ "the SQL statement ``\"SELECT f() FROM"
#~ " test;\"`` will try to access the "
#~ "same space in two ways. The "
#~ "results of such conflict may include "
#~ "a hang or an infinite loop."
#~ msgstr ""

#~ msgid "Example Session -- Create, Insert, Select"
#~ msgstr ""

#~ msgid ""
#~ "Assume that the task is to create"
#~ " two tables, put some rows in "
#~ "each table, create a :ref:`view "
#~ "<sql_create_view>` that is based on a"
#~ " join of the tables, then select "
#~ "from the view all rows where the"
#~ " second column values are not null,"
#~ " ordered by the first column."
#~ msgstr ""

#~ msgid ""
#~ "That is, what we want is |br| "
#~ "``CREATE TABLE t1 (c1 INTEGER PRIMARY"
#~ " KEY, c2 STRING);`` |br| ``CREATE "
#~ "TABLE t2 (c1 INTEGER PRIMARY KEY, "
#~ "x2 STRING);`` |br| ``INSERT INTO t1 "
#~ "VALUES (1, 'A'), (2, 'B'), (3, "
#~ "'C');`` |br| ``INSERT INTO t1 VALUES "
#~ "(4, 'D'), (5, 'E'), (6, 'F');`` "
#~ "|br| ``INSERT INTO t2 VALUES (1, "
#~ "'C'), (4, 'A'), (6, NULL);`` |br| "
#~ "``CREATE VIEW v AS SELECT * FROM"
#~ " t1 NATURAL JOIN t2;`` |br| ``SELECT"
#~ " * FROM v WHERE c2 IS NOT "
#~ "NULL ORDER BY c1;``"
#~ msgstr ""

#~ msgid ""
#~ "So the session looks like this: "
#~ "|br| ``box.cfg{}`` |br| ``box.execute([[CREATE "
#~ "TABLE t1 (c1 INTEGER PRIMARY KEY, "
#~ "c2 STRING);]])`` |br| ``box.execute([[CREATE "
#~ "TABLE t2 (c1 INTEGER PRIMARY KEY, "
#~ "x2 STRING);]])`` |br| ``box.execute([[INSERT "
#~ "INTO t1 VALUES (1, 'A'), (2, 'B'),"
#~ " (3, 'C');]])`` |br| ``box.execute([[INSERT "
#~ "INTO t1 VALUES (4, 'D'), (5, 'E'),"
#~ " (6, 'F');]])`` |br| ``box.execute([[INSERT "
#~ "INTO t2 VALUES (1, 'C'), (4, 'A'),"
#~ " (6, NULL);]])`` |br| ``box.execute([[CREATE "
#~ "VIEW v AS SELECT * FROM t1 "
#~ "NATURAL JOIN t2;]])`` |br| "
#~ "``box.execute([[SELECT * FROM v WHERE c2"
#~ " IS NOT NULL ORDER BY c1;]])``"
#~ msgstr ""

#~ msgid ""
#~ "If one executes the above requests "
#~ "with Tarantool as a client, provided "
#~ "the database objects do not already "
#~ "exist, the execution will be successful"
#~ " and the final display will be "
#~ "|br| tarantool> box.execute([[SELECT * FROM"
#~ " v WHERE c2 IS NOT NULL ORDER"
#~ " BY c1;]]) ``---`` |br| ``- - "
#~ "[1, 'A', 'C']`` |br| ``  - [4, "
#~ "'D', 'A']`` |br| ``  - [6, 'F',"
#~ " null]`` |br|"
#~ msgstr ""

#~ msgid "Example Session -- Get a List of Columns"
#~ msgstr ""

#~ msgid ""
#~ "Here  is a function which will "
#~ "create a table that contains a "
#~ "list of all the columns and their"
#~ " Lua types, for all tables. It "
#~ "is not a necessary function because "
#~ "one can create a :ref:`_COLUMNS view "
#~ "<sql__columns_view>` instead. It merely shows,"
#~ " with simpler Lua code, how to "
#~ "make a base table instead of a "
#~ "view."
#~ msgstr ""

#~ msgid ""
#~ "function create_information_schema_columns()\n"
#~ "  box.execute([[DROP TABLE IF EXISTS information_schema_columns;]])\n"
#~ "  box.execute([[CREATE TABLE information_schema_columns (\n"
#~ "                    table_name STRING,\n"
#~ "                    column_name STRING,\n"
#~ "                    ordinal_position INTEGER,\n"
#~ "                    data_type STRING,\n"
#~ "                    PRIMARY KEY (table_name, column_name));]]);\n"
#~ "  local space = box.space._vspace:select()\n"
#~ "  local sqlstring = ''\n"
#~ "  for i = 1, #space do\n"
#~ "      for j = 1, #space[i][7] do\n"
#~ "          sqlstring = \"INSERT INTO "
#~ "information_schema_columns VALUES (\"\n"
#~ "                  .. \"'\" .. space[i][3] .. \"'\"\n"
#~ "                  .. \",\"\n"
#~ "                  .. \"'\" .. space[i][7][j].name .. \"'\"\n"
#~ "                  .. \",\"\n"
#~ "                  .. j\n"
#~ "                  .. \",\"\n"
#~ "                  .. \"'\" .. space[i][7][j].type .. \"'\"\n"
#~ "                  .. \");\"\n"
#~ "          box.execute(sqlstring)\n"
#~ "      end\n"
#~ "  end\n"
#~ "  return\n"
#~ "end"
#~ msgstr ""

#~ msgid ""
#~ "If you now execute the function by"
#~ " saying |br| ``create_information_schema_columns()``"
#~ " |br| you will see that there "
#~ "is a table named information_schema_columns"
#~ " containing table_name and column_name and"
#~ " ordinal_position and data_type for "
#~ "everything that was accessible."
#~ msgstr ""

#~ msgid "Example Session -- Million-Row Insert"
#~ msgstr ""

#~ msgid ""
#~ "Here is a variation of the Lua "
#~ "tutorial :ref:`\"Insert one million tuples "
#~ "with a Lua stored procedure\" "
#~ "<c_lua_tutorial-insert_one_million_tuples>`. The "
#~ "differences are: the creation is done"
#~ " with an SQL :ref:`CREATE TABLE "
#~ "statement <sql_create_table>`, and the "
#~ "inserting is done with an SQL "
#~ ":ref:`INSERT statement <sql_insert>`. Otherwise, "
#~ "it is the same. It is the "
#~ "same because Lua and SQL are "
#~ "compatible, just as Lua and NoSQL "
#~ "are compatible."
#~ msgstr ""

#~ msgid ""
#~ "box.execute([[CREATE TABLE tester (s1 INTEGER"
#~ " PRIMARY KEY, s2 STRING);]])\n"
#~ "\n"
#~ "function string_function()\n"
#~ "  local random_number\n"
#~ "  local random_string\n"
#~ "  random_string = \"\"\n"
#~ "  for x = 1,10,1 do\n"
#~ "    random_number = math.random(65, 90)\n"
#~ "    random_string = random_string .. string.char(random_number)\n"
#~ "  end\n"
#~ "  return random_string\n"
#~ "end\n"
#~ "\n"
#~ "function main_function()\n"
#~ "    local string_value, t, sql_statement\n"
#~ "    for i = 1,1000000, 1 do\n"
#~ "    string_value = string_function()\n"
#~ "    sql_statement = \"INSERT INTO tester"
#~ " VALUES (\" .. i .. \",'\" .."
#~ " string_value .. \"')\"\n"
#~ "    box.execute(sql_statement)\n"
#~ "    end\n"
#~ "end\n"
#~ "start_time = os.clock()\n"
#~ "main_function()\n"
#~ "end_time = os.clock()\n"
#~ "'insert done in ' .. end_time - start_time .. ' seconds'"
#~ msgstr ""

#~ msgid ""
#~ "Limitations: The function takes more "
#~ "time than the original (Tarantool/NoSQL)."
#~ msgstr ""

#~ msgid "Lua functions to make views of metadata"
#~ msgstr ""

#~ msgid ""
#~ "Tarantool does not include all the "
#~ "standard-SQL `information_schema "
#~ "<https://en.wikipedia.org/wiki/information_schema>`_ views, "
#~ "which are for looking at metadata, "
#~ "that is, \"data about the data\". "
#~ "But here is the Lua code and "
#~ "SQL code for creating equivalents: |br|"
#~ " :ref:`_TABLES <sql__tables_view>` nearly "
#~ "equivalent to INFORMATION_SCHEMA.TABLES |br| "
#~ ":ref:`_COLUMNS <sql__columns_view>` nearly "
#~ "equivalent to INFORMATION_SCHEMA.COLUMNS |br| "
#~ ":ref:`_VIEWS <sql__views_view>` nearly equivalent"
#~ " to INFORMATION_SCHEMA.VIEWS |br| :ref:`_TRIGGERS"
#~ " <sql__triggers_view>` nearly equivalent to "
#~ "INFORMATION_SCHEMA.TRIGGERS |br| "
#~ ":ref:`_REFERENTIAL_CONSTRAINTS "
#~ "<sql__referential_constraints_view>` nearly equivalent "
#~ "to INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS |br| "
#~ ":ref:`_CHECK_CONSTRAINTS <sql__check_constraints_view>` "
#~ "nearly equivalent to "
#~ "INFORMATION_SCHEMA.CHECK_CONSTRAINTS |br| "
#~ ":ref:`_TABLE_CONSTRAINTS <sql__table_constraints_view>` "
#~ "nearly equivalent to "
#~ "INFORMATION_SCHEMA.TABLE_CONSTRAINTS. |br| For each"
#~ " view we show an example of a"
#~ " SELECT from the view, and the "
#~ "code. Users who want metadata can "
#~ "simply copy the code. Use this "
#~ "code only with Tarantool version 2.3.0"
#~ " or later. With an earlier Tarantool"
#~ " version, a :ref:`PRAGMA statement "
#~ "<sql_pragma>` may be useful."
#~ msgstr ""

#~ msgid "_TABLES view"
#~ msgstr ""

#~ msgid ""
#~ "tarantool>SELECT * FROM _tables WHERE id > 340 LIMIT 5;\n"
#~ "OK 5 rows selected (0.0 seconds)\n"
#~ "+---------------+--------------+----------------+------------+-----+--------+-------+-------------+"
#~ "\n"
#~ "| TABLE_CATALOG | TABLE_SCHEMA | "
#~ "TABLE_NAME     | TABLE_TYPE | ID  | "
#~ "ENGINE | OWNER | FIELD_COUNT |\n"
#~ "+---------------+--------------+----------------+------------+-----+--------+-------+-------------+"
#~ "\n"
#~ "| NULL          | NULL         | "
#~ "_fk_constraint | BASE TABLE | 356 "
#~ "| memtx  | admin |        0    |"
#~ "\n"
#~ "| NULL          | NULL         | "
#~ "_ck_constraint | BASE TABLE | 364 "
#~ "| memtx  | admin |        0    |"
#~ "\n"
#~ "| NULL          | NULL         | "
#~ "_func_index    | BASE TABLE | 372 "
#~ "| memtx  | admin |        0    |"
#~ "\n"
#~ "| NULL          | NULL         | "
#~ "_COLUMNS       | VIEW       | 513 | "
#~ "memtx  | admin |        8    |\n"
#~ "| NULL          | NULL         | _VIEWS"
#~ "         | VIEW       | 514 | memtx"
#~ "  | admin |        7    |\n"
#~ "+---------------+--------------+----------------+------------+-----+--------+-------+-------------+"
#~ msgstr ""

#~ msgid "Definition of the function and the CREATE VIEW statement:"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.func.drop('_TABLES_IS_VIEW',{if_exists = true})\n"
#~ "box.schema.func.create('_TABLES_IS_VIEW',\n"
#~ "     {language = 'LUA',\n"
#~ "      returns = 'boolean',\n"
#~ "      body = [[function (flags)\n"
#~ "          local view\n"
#~ "          view = require('msgpack').decode(flags).view\n"
#~ "          if view == nil then return false end\n"
#~ "          return view\n"
#~ "          end]],\n"
#~ "     is_sandboxed = false,\n"
#~ "     param_list = {'string'},\n"
#~ "     exports = {'LUA', 'SQL'},\n"
#~ "     setuid = false,\n"
#~ "     is_deterministic = true})\n"
#~ "box.schema.role.grant('public', 'execute', 'function', "
#~ "'_TABLES_IS_VIEW')\n"
#~ "pcall(function ()\n"
#~ "    box.schema.role.revoke('public', 'read', "
#~ "'space', '_TABLES', {if_exists = true})\n"
#~ ""
#~ "    end)\n"
#~ "box.execute([[DROP VIEW IF EXISTS _tables;]])\n"
#~ "box.execute([[\n"
#~ "CREATE VIEW _tables AS SELECT\n"
#~ "    CAST(NULL AS STRING) AS table_catalog,\n"
#~ "    CAST(NULL AS STRING) AS table_schema,\n"
#~ "    \"name\" AS table_name,\n"
#~ "    CASE\n"
#~ "        WHEN _tables_is_view(\"flags\") = TRUE THEN 'VIEW'\n"
#~ "        ELSE 'BASE TABLE' END\n"
#~ "        AS table_type,\n"
#~ "    \"id\" AS id,\n"
#~ "    \"engine\" AS engine,\n"
#~ "    (SELECT \"name\" FROM \"_vuser\" x"
#~ " WHERE x.\"id\" = y.\"owner\") AS "
#~ "owner,\n"
#~ "    \"field_count\" AS field_count\n"
#~ "FROM \"_vspace\" y;\n"
#~ "]])\n"
#~ "box.schema.role.grant('public', 'read', 'space', '_TABLES')"
#~ msgstr ""

#~ msgid "_COLUMNS view"
#~ msgstr ""

#~ msgid ""
#~ "This is also an example of how "
#~ "one can use :ref:`recursive views "
#~ "<sql_with>` to make temporary tables "
#~ "with multiple rows for each tuple "
#~ "in the original ``\"_vtable\"`` space. "
#~ "It requires a global variable, "
#~ "_G.box.FORMATS, as a temporary static "
#~ "variable."
#~ msgstr ""

#~ msgid ""
#~ "Warning: Use this code only with "
#~ "Tarantool version 2.3.2 or later. Use"
#~ " with earlier versions will cause an"
#~ " assertion. See `Issue#4504 "
#~ "<https://github.com/tarantool/tarantool/issues/4504>`_."
#~ msgstr ""

#~ msgid ""
#~ "tarantool>SELECT * FROM _columns WHERE ordinal_position = 9;\n"
#~ "OK 6 rows selected (0.0 seconds)\n"
#~ "+--------------+-------------+--------------------------+--------------+------------------+-------------+-----------+-----+"
#~ "\n"
#~ "| CATALOG_NAME | SCHEMA_NAME | "
#~ "TABLE_NAME               | COLUMN_NAME  | "
#~ "ORDINAL_POSITION | IS_NULLABLE | DATA_TYPE "
#~ "| ID  |\n"
#~ "+--------------+-------------+--------------------------+--------------+------------------+-------------+-----------+-----+"
#~ "\n"
#~ "| NULL         | NULL        | _sequence"
#~ "                | cycle        |                9"
#~ " | YES         | boolean   | 284 "
#~ "|\n"
#~ "| NULL         | NULL        | "
#~ "_vsequence               | cycle        |"
#~ "                9 | YES         | boolean"
#~ "   | 286 |\n"
#~ "| NULL         | NULL        | _func"
#~ "                    | returns      |                "
#~ "9   YES           string    | 296 |\n"
#~ ""
#~ "| NULL         | NULL        | "
#~ "_fk_constraint           | parent_cols  |"
#~ "                9 | YES         | array"
#~ "     | 356 |\n"
#~ "| NULL         | NULL        | "
#~ "_REFERENTIAL_CONSTRAINTS | MATCH_OPTION |"
#~ "                9 | YES         | string"
#~ "    | 518 |\n"
#~ "+--------------+-------------+--------------------------+--------------+------------------+-------------+-----------+-----+"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.func.drop('_COLUMNS_FORMATS', {if_exists = true})\n"
#~ "box.schema.func.create('_COLUMNS_FORMATS',\n"
#~ "    {language = 'LUA',\n"
#~ "     returns = 'scalar',\n"
#~ "     body = [[\n"
#~ "     function (row_number_, ordinal_position)\n"
#~ "         if row_number_ == 0 then\n"
#~ "             _G.box.FORMATS = {}\n"
#~ "             local vspace = box.space._vspace:select()\n"
#~ "             for i = 1, #vspace do\n"
#~ "                 local format = vspace[i][\"format\"]\n"
#~ "                 for j = 1, #format do\n"
#~ "                     local is_nullable = 'YES'\n"
#~ "                     if format[j].is_nullable == false then\n"
#~ "                         is_nullable = 'NO'\n"
#~ "                     end\n"
#~ "                     table.insert(_G.box.FORMATS,\n"
#~ "                                  {vspace[i].name, format[j].name, j,\n"
#~ "                                   is_nullable, "
#~ "format[j].type, vspace[i].id})\n"
#~ "                 end\n"
#~ "             end\n"
#~ "             return ''\n"
#~ "         end\n"
#~ "         if row_number_ > #_G.box.FORMATS then\n"
#~ "             _G.box.FORMATS = {}\n"
#~ "             return ''\n"
#~ "         end\n"
#~ "         return _G.box.FORMATS[row_number_][ordinal_position]\n"
#~ "     end\n"
#~ "     ]],\n"
#~ "    param_list = {'integer', 'integer'},\n"
#~ "    exports = {'LUA', 'SQL'},\n"
#~ "    is_sandboxed = false,\n"
#~ "    setuid = false,\n"
#~ "    is_deterministic = false})\n"
#~ "box.schema.role.grant('public', 'execute', 'function', "
#~ "'_COLUMNS_FORMATS')\n"
#~ "\n"
#~ "pcall(function ()\n"
#~ "    box.schema.role.revoke('public', 'read', "
#~ "'space', '_COLUMNS', {if_exists = true})\n"
#~ ""
#~ "    end)\n"
#~ "box.execute([[DROP VIEW IF EXISTS _columns;]])\n"
#~ "box.execute([[\n"
#~ "CREATE VIEW _columns AS\n"
#~ "WITH RECURSIVE r_columns AS\n"
#~ "(\n"
#~ "SELECT 0 AS row_number_,\n"
#~ "      '' AS table_name,\n"
#~ "      '' AS column_name,\n"
#~ "      0 AS ordinal_position,\n"
#~ "      '' AS is_nullable,\n"
#~ "      '' AS data_type,\n"
#~ "      0 AS id\n"
#~ "UNION ALL\n"
#~ "SELECT row_number_ + 1 AS row_number_,\n"
#~ "       _columns_formats(row_number_, 1) AS table_name,\n"
#~ "       _columns_formats(row_number_, 2) AS column_name,\n"
#~ "       _columns_formats(row_number_, 3) AS ordinal_position,\n"
#~ "       _columns_formats(row_number_, 4) AS is_nullable,\n"
#~ "       _columns_formats(row_number_, 5) AS data_type,\n"
#~ "       _columns_formats(row_number_, 6) AS id\n"
#~ "    FROM r_columns\n"
#~ "    WHERE row_number_ == 0 OR "
#~ "row_number_ <= lua('return #_G.box.FORMATS +"
#~ " 1')\n"
#~ ")\n"
#~ "SELECT CAST(NULL AS STRING) AS catalog_name,\n"
#~ "       CAST(NULL AS STRING) AS schema_name,\n"
#~ "       table_name,\n"
#~ "       column_name,\n"
#~ "       ordinal_position,\n"
#~ "       is_nullable,\n"
#~ "       data_type,\n"
#~ "       id\n"
#~ "    FROM r_columns\n"
#~ "    WHERE data_type <> '';\n"
#~ "]])\n"
#~ "box.schema.role.grant('public', 'read', 'space', '_COLUMNS')"
#~ msgstr ""

#~ msgid "_VIEWS view"
#~ msgstr ""

#~ msgid ""
#~ "tarantool>SELECT table_name, substr(view_definition,1,20),"
#~ " id, owner, field_count FROM _views "
#~ "LIMIT 5;\n"
#~ "OK 5 rows selected (0.0 seconds)\n"
#~ "+--------------------------+------------------------------+-----+-------+-------------+"
#~ "\n"
#~ "| TABLE_NAME               | "
#~ "SUBSTR(VIEW_DEFINITION,1,20) | ID  | OWNER "
#~ "| FIELD_COUNT |\n"
#~ "+--------------------------+------------------------------+-----+-------+-------------+"
#~ "\n"
#~ "| _COLUMNS                 | CREATE VIEW "
#~ "_columns         | 513 | admin |"
#~ "           8 |\n"
#~ "| _TRIGGERS                | CREATE VIEW "
#~ "_trigger         | 515 | admin |"
#~ "           4 |\n"
#~ "| _CHECK_CONSTRAINTS       | CREATE VIEW "
#~ "_check_c         | 517 | admin |"
#~ "           8 |\n"
#~ "| _REFERENTIAL_CONSTRAINTS | CREATE VIEW "
#~ "_referen         | 518 | admin |"
#~ "          12 |\n"
#~ "| _TABLE_CONSTRAINTS       | CREATE VIEW "
#~ "_table_c         | 519 | admin |"
#~ "          11 |\n"
#~ "+--------------------------+------------------------------+-----+-------+-------------+"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.func.drop('_VIEWS_DEFINITION',{if_exists = true})\n"
#~ "box.schema.func.create('_VIEWS_DEFINITION',\n"
#~ "    {language = 'LUA',\n"
#~ "     returns = 'string',\n"
#~ "     body = [[function (flags)\n"
#~ "                  return require('msgpack').decode(flags).sql end]],\n"
#~ "     param_list = {'string'},\n"
#~ "     exports = {'LUA', 'SQL'},\n"
#~ "     is_sandboxed = false,\n"
#~ "     setuid = false,\n"
#~ "     is_deterministic = false})\n"
#~ "box.schema.role.grant('public', 'execute', 'function', "
#~ "'_VIEWS_DEFINITION')\n"
#~ "pcall(function ()\n"
#~ "    box.schema.role.revoke('public', 'read', "
#~ "'space', '_VIEWS', {if_exists = true})\n"
#~ "    end)\n"
#~ "box.execute([[DROP VIEW IF EXISTS _views;]])\n"
#~ "box.execute([[\n"
#~ "CREATE VIEW _views AS SELECT\n"
#~ "    CAST(NULL AS STRING) AS table_catalog,\n"
#~ "    CAST(NULL AS STRING) AS table_schema,\n"
#~ "    \"name\" AS table_name,\n"
#~ "    CAST(_views_definition(\"flags\") AS STRING) AS VIEW_DEFINITION,\n"
#~ "    \"id\" AS id,\n"
#~ "    (SELECT \"name\" FROM \"_vuser\" x"
#~ " WHERE x.\"id\" = y.\"owner\") AS "
#~ "owner,\n"
#~ "    \"field_count\" AS field_count\n"
#~ "    FROM \"_vspace\" y\n"
#~ "    WHERE _tables_is_view(\"flags\") = TRUE;\n"
#~ "]])\n"
#~ "box.schema.role.grant('public', 'read', 'space', '_VIEWS')"
#~ msgstr ""

#~ msgid ""
#~ "_TABLES_IS_VIEW() was described earlier, see"
#~ " :ref:`_TABLES view <sql__tables_view>`."
#~ msgstr ""

#~ msgid "_TRIGGERS view"
#~ msgstr ""

#~ msgid ""
#~ "tarantool>SELECT trigger_name, opts_sql FROM _triggers;\n"
#~ "OK 2 rows selected (0.0 seconds)\n"
#~ "+--------------+-------------------------------------------------------------------------------------------------+"
#~ "\n"
#~ "| TRIGGER_NAME | OPTS_SQL"
#~ "                                                                                        "
#~ "|\n"
#~ "+--------------+-------------------------------------------------------------------------------------------------+"
#~ "\n"
#~ "| THINGS1_AD   | CREATE TRIGGER "
#~ "things1_ad AFTER DELETE ON things1 FOR"
#~ " EACH ROW BEGIN DELETE FROM things2;"
#~ " END;  |\n"
#~ "| THINGS1_BI   | CREATE TRIGGER "
#~ "things1_bi BEFORE INSERT ON things1 FOR"
#~ " EACH ROW BEGIN DELETE FROM things2;"
#~ " END; |\n"
#~ "+--------------+-------------------------------------------------------------------------------------------------+"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.func.drop('_TRIGGERS_OPTS_SQL',{if_exists = true})\n"
#~ "box.schema.func.create('_TRIGGERS_OPTS_SQL',\n"
#~ "    {language = 'LUA',\n"
#~ "     returns = 'string',\n"
#~ "     body = [[function (opts)\n"
#~ "                  return require('msgpack').decode(opts).sql end]],\n"
#~ "     param_list = {'string'},\n"
#~ "     exports = {'LUA', 'SQL'},\n"
#~ "     is_sandboxed = false,\n"
#~ "     setuid = false,\n"
#~ "     is_deterministic = false})\n"
#~ "box.schema.role.grant('public', 'execute', 'function', "
#~ "'_TRIGGERS_OPTS_SQL')\n"
#~ "pcall(function ()\n"
#~ "    box.schema.role.revoke('public', 'read', "
#~ "'space', '_TRIGGERS', {if_exists = true})\n"
#~ ""
#~ "    end)\n"
#~ "box.execute([[DROP VIEW IF EXISTS _triggers;]])\n"
#~ "box.execute([[\n"
#~ "CREATE VIEW _triggers AS SELECT\n"
#~ "    CAST(NULL AS STRING) AS trigger_catalog,\n"
#~ "    CAST(NULL AS STRING) AS trigger_schema,\n"
#~ "    \"name\" AS trigger_name,\n"
#~ "    CAST(_triggers_opts_sql(\"opts\") AS STRING) AS opts_sql,\n"
#~ "    \"space_id\" AS space_id\n"
#~ "    FROM \"_trigger\";\n"
#~ "]])\n"
#~ "box.schema.role.grant('public', 'read', 'space', '_TRIGGERS')"
#~ msgstr ""

#~ msgid ""
#~ "Users who select from this view "
#~ "will need 'read' privilege on the "
#~ "_trigger space."
#~ msgstr ""

#~ msgid "_REFERENTIAL_CONSTRAINTS view"
#~ msgstr ""

#~ msgid ""
#~ "tarantool>SELECT constraint_name, update_rule, "
#~ "delete_rule, match_option,\n"
#~ "> referencing, referenced\n"
#~ "> FROM _referential_constraints;\n"
#~ "OK 2 rows selected (0.0 seconds)\n"
#~ "+----------------------+-------------+-------------+--------------+-------------+------------+"
#~ "\n"
#~ "| CONSTRAINT_NAME      | UPDATE_RULE | "
#~ "DELETE_RULE | MATCH_OPTION | REFERENCING "
#~ "| REFERENCED |\n"
#~ "+----------------------+-------------+-------------+--------------+-------------+------------+"
#~ "\n"
#~ "| fk_unnamed_THINGS2_1 | no_action   | "
#~ "no_action   | simple       | THINGS2     "
#~ "| THINGS1    |\n"
#~ "| fk_unnamed_THINGS3_1 | no_action   | "
#~ "no_action   | simple       | THINGS3     "
#~ "| THINGS1    |\n"
#~ "+----------------------+-------------+-------------+--------------+-------------+------------+"
#~ msgstr ""

#~ msgid "Definition of the CREATE VIEW statement:"
#~ msgstr ""

#~ msgid ""
#~ "pcall(function ()\n"
#~ "    box.schema.role.revoke('public', 'read', "
#~ "'space', '_REFERENTIAL_CONSTRAINTS', {if_exists ="
#~ " true})\n"
#~ "    end)\n"
#~ "box.execute([[DROP VIEW IF EXISTS _referential_constraints;]])\n"
#~ "box.execute([[\n"
#~ "CREATE VIEW _referential_constraints AS SELECT\n"
#~ "    CAST(NULL AS STRING) AS constraint_catalog,\n"
#~ "    CAST(NULL AS STRING) AS constraint_schema,\n"
#~ "    \"name\" AS constraint_name,\n"
#~ "    CAST(NULL AS STRING) AS unique_constraint_catalog,\n"
#~ "    CAST(NULL AS STRING) AS unique_constraint_schema,\n"
#~ "    '' AS unique_constraint_name,\n"
#~ "    \"on_update\" AS update_rule,\n"
#~ "    \"on_delete\" AS delete_rule,\n"
#~ "    \"match\" AS match_option,\n"
#~ "    (SELECT \"name\" FROM \"_vspace\" x"
#~ " WHERE x.\"id\" = y.\"child_id\") AS "
#~ "referencing,\n"
#~ "    (SELECT \"name\" FROM \"_vspace\" x"
#~ " WHERE x.\"id\" = y.\"parent_id\") AS "
#~ "referenced,\n"
#~ "    \"is_deferred\" AS is_deferred,\n"
#~ "    \"child_id\" AS child_id,\n"
#~ "    \"parent_id\" AS parent_id\n"
#~ "    FROM \"_fk_constraint\" y;\n"
#~ "]])\n"
#~ "box.schema.role.grant('public', 'read', 'space', "
#~ "'_REFERENTIAL_CONSTRAINTS')"
#~ msgstr ""

#~ msgid ""
#~ "We are not taking child_cols or "
#~ "parent_cols from the _fk_constraint space "
#~ "because in standard SQL those are "
#~ "in a separate table."
#~ msgstr ""

#~ msgid ""
#~ "Users who select from this view "
#~ "will need 'read' privilege on the "
#~ "_fk_constraint space."
#~ msgstr ""

#~ msgid "_CHECK_CONSTRAINTS view"
#~ msgstr ""

#~ msgid ""
#~ "tarantool>SELECT constraint_name, check_clause, space_name, language\n"
#~ "> FROM _check_constraints;\n"
#~ "OK 3 rows selected (0.0 seconds)\n"
#~ "+------------------------+-------------------------+------------+----------+"
#~ "\n"
#~ "| CONSTRAINT_NAME        | CHECK_CLAUSE"
#~ "            | SPACE_NAME | LANGUAGE |\n"
#~ ""
#~ "+------------------------+-------------------------+------------+----------+"
#~ "\n"
#~ "| ck_unnamed_Employees_1 | first_name LIKE "
#~ "'Влад%' | Employees  | SQL      |\n"
#~ ""
#~ "| ck_unnamed_Critics_1   | first_name LIKE "
#~ "'Vlad%' | Critics    | SQL      |\n"
#~ ""
#~ "| ck_unnamed_ACTORS_1    | salary > 0"
#~ "              | ACTORS     | SQL      |"
#~ "\n"
#~ "+------------------------+-------------------------+------------+----------+"
#~ msgstr ""

#~ msgid ""
#~ "pcall(function ()\n"
#~ "    box.schema.role.revoke('public', 'read', "
#~ "'space', '_CHECK_CONSTRAINTS', {if_exists = "
#~ "true})\n"
#~ "    end)\n"
#~ "box.execute([[DROP VIEW IF EXISTS _check_constraints;]])\n"
#~ "box.execute([[\n"
#~ "CREATE VIEW _check_constraints AS SELECT\n"
#~ "    CAST(NULL AS STRING) AS constraint_catalog,\n"
#~ "    CAST(NULL AS STRING) AS constraint_schema,\n"
#~ "    \"name\" AS constraint_name,\n"
#~ "    \"code\" AS check_clause,\n"
#~ "    (SELECT \"name\" FROM \"_vspace\" x"
#~ " WHERE x.\"id\" = y.\"space_id\") AS "
#~ "space_name,\n"
#~ "    \"language\" AS language,\n"
#~ "    \"is_deferred\" AS is_deferred,\n"
#~ "    \"space_id\" AS space_id\n"
#~ "    FROM \"_ck_constraint\" y;\n"
#~ "]])\n"
#~ "box.schema.role.grant('public', 'read', 'space', '_CHECK_CONSTRAINTS')"
#~ msgstr ""

#~ msgid ""
#~ "Users who select from this view "
#~ "will need 'read' privilege on the "
#~ "_ck_constraint space."
#~ msgstr ""

#~ msgid "_TABLE_CONSTRAINTS view"
#~ msgstr ""

#~ msgid ""
#~ "This has only the constraints "
#~ "(primary-key and unique-key) that can"
#~ " be found by looking at the "
#~ ":ref:`_index <box_space-index>` space. It "
#~ "is not a list of indexes, that "
#~ "is, it is not equivalent to "
#~ "INFORMATION_SCHEMA.STATISTICS. We do not take"
#~ " the columns of the index because "
#~ "in standard SQL they would be in"
#~ " a different table."
#~ msgstr ""

#~ msgid ""
#~ "tarantool>SELECT constraint_name, constraint_type, "
#~ "table_name, id, iid, index_type\n"
#~ "> FROM _table_constraints\n"
#~ "> LIMIT 5;\n"
#~ "OK 5 rows selected (0.0 seconds)\n"
#~ "+-----------------+-----------------+-------------+-----+-----+------------+"
#~ "\n"
#~ "| CONSTRAINT_NAME | CONSTRAINT_TYPE | "
#~ "TABLE_NAME  | ID  | IID | "
#~ "INDEX_TYPE |\n"
#~ "+-----------------+-----------------+-------------+-----+-----+------------+"
#~ "\n"
#~ "| primary         | PRIMARY         | "
#~ "_schema     | 272 |   0 | tree"
#~ "       |\n"
#~ "| primary         | PRIMARY         | "
#~ "_collation  | 276 |   0 | tree"
#~ "       |\n"
#~ "| name            | UNIQUE          | "
#~ "_collation  | 276 |   1 | tree"
#~ "       |\n"
#~ "| primary         | PRIMARY         | "
#~ "_vcollation | 277 |   0 | tree"
#~ "       |\n"
#~ "| name            | UNIQUE          | "
#~ "_vcollation | 277 |   1 | tree"
#~ "       |\n"
#~ "+-----------------+-----------------+-------------+-----+-----+------------+"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.func.drop('_TABLE_CONSTRAINTS_OPTS_UNIQUE',{if_exists "
#~ "= true})\n"
#~ "function _TABLE_CONSTRAINTS_OPTS_UNIQUE (opts) "
#~ "return require('msgpack').decode(opts).unique end\n"
#~ "box.schema.func.create('_TABLE_CONSTRAINTS_OPTS_UNIQUE',\n"
#~ "    {language = 'LUA',\n"
#~ "     returns = 'boolean',\n"
#~ "     body = [[function (opts) return "
#~ "require('msgpack').decode(opts).unique end]],\n"
#~ "     param_list = {'string'},\n"
#~ "     exports = {'LUA', 'SQL'},\n"
#~ "     is_sandboxed = false,\n"
#~ "     setuid = false,\n"
#~ "     is_deterministic = false})\n"
#~ "box.schema.role.grant('public', 'execute', 'function', "
#~ "'_TABLE_CONSTRAINTS_OPTS_UNIQUE')\n"
#~ "pcall(function ()\n"
#~ "box.schema.role.revoke('public', 'read', 'space', "
#~ "'_TABLE_CONSTRAINTS', {if_exists = true})\n"
#~ "end)\n"
#~ "box.execute([[DROP VIEW IF EXISTS _table_constraints;]])\n"
#~ "box.execute([[\n"
#~ "CREATE VIEW _table_constraints AS SELECT\n"
#~ "CAST(NULL AS STRING) AS constraint_catalog,\n"
#~ "CAST(NULL AS STRING) AS constraint_schema,\n"
#~ "\"name\" AS constraint_name,\n"
#~ "(SELECT \"name\" FROM \"_vspace\" x "
#~ "WHERE x.\"id\" = y.\"id\") AS "
#~ "table_name,\n"
#~ "CASE WHEN \"iid\" = 0 THEN "
#~ "'PRIMARY' ELSE 'UNIQUE' END AS "
#~ "constraint_type,\n"
#~ "CAST(NULL AS STRING) AS initially_deferrable,\n"
#~ "CAST(NULL AS STRING) AS deferred,\n"
#~ "CAST(NULL AS STRING) AS enforced,\n"
#~ "\"id\" AS id,\n"
#~ "\"iid\" AS iid,\n"
#~ "\"type\" AS index_type\n"
#~ "FROM \"_vindex\" y\n"
#~ "WHERE _table_constraints_opts_unique(\"opts\") = TRUE;\n"
#~ "]])\n"
#~ "box.schema.role.grant('public', 'read', 'space', '_TABLE_CONSTRAINTS')"
#~ msgstr ""
