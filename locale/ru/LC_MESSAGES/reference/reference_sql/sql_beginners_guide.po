
msgid "SQL beginners' guide"
msgstr "Руководство для начинающих по SQL"

msgid ""
"The Beginners' Guide describes how users can start up with SQL with "
"Tarantool, and necessary concepts."
msgstr ""
"В этом руководстве описано, как пользователю начать работу с SQL в "
"Tarantool, а также объясняются все необходимые понятия."

msgid ""
"The SQL Beginners' Guide is about databases in general, and about the "
"relationship between Tarantool's NoSQL and SQL products. Most of the matters"
" in the Beginners' Guide will already be familiar to people who have used "
"relational databases before."
msgstr ""
"Ниже рассказывается о базах данных в целом и взаимосвязи между решениями "
"NoSQL и SQL в Tarantool. Большинство тем, изложенных в этом руководстве, "
"будут знакомы тем, кто уже использовал реляционные базы данных."

msgid "**Sample Simple Table**"
msgstr "**Пример простой таблицы**"

msgid ""
"In football training camp it is traditional for the trainer to begin by "
"showing a football and saying \"this is a football\". In that spirit, this "
"is a table:"
msgstr ""
"В футбольном тренировочном лагере тренер традиционно начинает с того, что "
"показывает игрокам футбольный мяч и говорит: \"Это --- футбольный мяч\". В "
"случае SQL подобный базовый объект --- это таблица:"

msgid ""
"TABLE\n"
"          [1]              [2]              [3]\n"
"       +-----------------+----------------+----------------+\n"
" Row#1 | Row#1,Column#1  | Row#1,Column#2 | Row#1,Column#3 |\n"
"       +-----------------+----------------+----------------+\n"
" Row#2 | Row#2,Column#1  | Row#2,Column#2 | Row#2,Column#3 |\n"
"       +-----------------+----------------+----------------+\n"
" Row#3 | Row#3,Column#1  | Row#3,Column#2 | Row#3,Column#3 |\n"
"       +-----------------+----------------+----------------+"
msgstr ""
"TABLE\n"
"          [1]              [2]              [3]\n"
"       +-----------------+----------------+----------------+\n"
" Стрк1 |  Стрк1, Стлб1   |  Стрк1, Стлб2  |  Стрк1, Стлб3  |\n"
"       +-----------------+----------------+----------------+\n"
" Стрк2 |  Стрк2, Стлб1   | Стрк2, Стлб2   |  Стрк2, Стлб3  |\n"
"       +-----------------+----------------+----------------+\n"
" Стрк3 |  Стрк3, Стлб1   |  Стрк3, Стлб2  |  Стрк3, Стлб3  |\n"
"       +-----------------+----------------+----------------+"

msgid ""
"but the labels are misleading -- we usually don't identify rows and columns "
"by their ordinal positions, we prefer to pick out specific items by their "
"contents. In that spirit, this is a table:"
msgstr ""
"Но эти обозначения вводят в заблуждение. Обычно мы не обозначаем строки и "
"столбцы порядковыми позициями, мы скорее будем искать элементы таблицы по их"
" содержимому:"

msgid ""
"MODULES\n"
"\n"
"+-----------------+------+---------------------+\n"
"| NAME            | SIZE | PURPOSE             |\n"
"+-----------------+------+---------------------+\n"
"| box             | 1432 | Database Management |\n"
"| clock           |  188 | Seconds             |\n"
"| crypto          |    4 | Cryptography        |\n"
"+-----------------+------+---------------------+"
msgstr ""
"MODULES\n"
"\n"
"+-----------------+------+---------------------+\n"
"| NAME            | SIZE | PURPOSE             |\n"
"+-----------------+------+---------------------+\n"
"| box             | 1432 | Управление БД       |\n"
"| clock           |  188 | Секунды             |\n"
"| crypto          |    4 | Криптография        |\n"
"+-----------------+------+---------------------+"

msgid ""
"so we do not use longitude/latitude navigation by talking about \"Row#2 "
"Column #2\", we use the contents of the Name column and the name of the Size"
" column by talking about \"the size, where the name is 'clock'\". To be more"
" exact, this is what we say:"
msgstr ""
"Так что мы не используем навигацию по позиции, обращаясь к элементу \"Строка"
" #2, столбец #2\"; мы используем содержимое колонок \"name\" (имя) и "
"\"size\" (размер), и ищем значение \"size\" для элемента, для которого "
"значение \"name\" совпадает с 'clock'. Если быть точнее, вот что мы говорим:"

msgid "``SELECT size FROM modules WHERE name = 'clock';``"
msgstr "``SELECT size FROM modules WHERE name = 'clock';``"

msgid ""
"If you're familiar with Tarantool's architecture -- and we hope that you "
"read about that before coming to this chapter -- then you know that there is"
" a NoSQL way to get the same thing:"
msgstr ""

msgid "``box.space.MODULES:select()[2][2]``"
msgstr ""

msgid ""
"Well, you can do that. One of the advantages of Tarantool is that if you can"
" get data via an SQL statement, then you can get the same data via a NoSQL "
"request. But the reverse is not true, because not all NoSQL tuple sets are "
"definable as SQL tables. These restrictions apply for SQL that do not apply "
"for NoSQL: |br| 1. Every column must have a name. |br| 2. Every column must "
"have a scalar type (Tarantool is relaxed about which particular scalar type "
"you can have, but there is no way to index and search arrays, tables within "
"tables, or what MessagePack calls \"maps\".)"
msgstr ""

msgid "Tarantool/NoSQL's \"format\" clause causes the same restrictions."
msgstr ""

msgid ""
"So an SQL \"table\" is a NoSQL \"tuple set with format restrictions\", an "
"SQL \"row\" is a NoSQL \"tuple\", an SQL \"column\" is a NoSQL \"list of "
"fields within a tuple set\"."
msgstr ""

msgid "**Creating a table**"
msgstr "**Создание таблицы**"

msgid "This is how to create the modules table:"
msgstr ""

msgid ""
"``CREATE TABLE modules (name STRING, size INTEGER, purpose STRING, PRIMARY "
"KEY (name));``"
msgstr ""

msgid ""
"The words that are IN CAPITAL LETTERS are \"keywords\" (although it is only "
"a convention in this manual that keywords are in capital letters, in "
"practice many programmers prefer to avoid shouting). A keyword has meaning "
"for the SQL parser so many keywords are reserved, they cannot be used as "
"names unless they are enclosed inside quotation marks."
msgstr ""

msgid ""
"The word \"modules\" is a \"table name\", and the words \"name\" and "
"\"size\" and \"purpose\" are \"column names\". All tables and all columns "
"must have names."
msgstr ""

msgid ""
"The words \"STRING\" and \"INTEGER\" are \"data types\". STRING means \"the "
"contents should be characters, the length is indefinite, the equivalent "
"NoSQL type is 'string''\". INTEGER means \"the contents should be numbers "
"without decimal points, the equivalent NoSQL type is 'integer'\". Tarantool "
"supports other data types but our example table has data types from the two "
"main groups, namely, data types for numbers and data types for strings."
msgstr ""

msgid ""
"The final clause, PRIMARY KEY (name), means that the name column is the main"
" column used to identify the row."
msgstr ""

msgid "**Nulls**"
msgstr ""

msgid ""
"Frequently it is necessary, at least temporarily, that a column value should"
" be NULL. Typical situations are: the value is unknown, or the value is not "
"applicable. For example, you might make a module as a placeholder but you "
"don't want to say its size or purpose. If such things are possible, the "
"column is \"nullable\". Our name column cannot contain nulls, and it could "
"be defined explicitly as \"name STRING NOT NULL\", but in this case that's "
"unnecessary -- a column defined as PRIMARY KEY is automatically NOT NULL."
msgstr ""

msgid ""
"Is a NULL in SQL the same thing as a nil in Lua? No, but it is close enough "
"that there will be confusion. When nil means \"unknown\" or "
"\"inapplicable\", yes. But when nil means \"nonexistent\" or \"type is "
"nil\", no. NULL is a value, it has a data type because it is inside a column"
" which is defined with that data type."
msgstr ""

msgid "**Creating an index**"
msgstr "**Создание индекса**"

msgid "This is how to create indexes for the modules table:"
msgstr ""

msgid ""
"``CREATE INDEX size ON modules (size);`` |br| ``CREATE UNIQUE INDEX purpose "
"ON modules (purpose);``"
msgstr ""

msgid ""
"There is no need to create an index on the name column, because Tarantool "
"creates an index automatically when it sees a PRIMARY KEY clause in the "
"CREATE TABLE statement. In fact there is no need to create indexes on the "
"size or purpose columns either -- if indexes don't exist, then it is still "
"possible to use the columns for searches. Typically people create non-"
"primary indexes, also called secondary indexes, when it becomes clear that "
"the table will grow large and searches will be frequent, because searching "
"with an index is generally much faster than searching without an index."
msgstr ""

msgid ""
"Another use for indexes is to enforce uniqueness. When an index is created "
"with CREATE UNIQUE INDEX for the purpose column, it is not possible to have "
"duplicate values in that column."
msgstr ""

msgid "**Data change**"
msgstr "**Изменение данных**"

msgid ""
"Putting data into a table is called \"inserting\". Changing data is called "
"\"updating\". Removing data is called \"deleting\". Together, the three SQL "
"statements INSERT plus UPDATE plus DELETE are the three main \"data-change\""
" statements."
msgstr ""

msgid "This is how to insert, update, and delete a row in the modules table:"
msgstr ""

msgid ""
"``INSERT INTO modules VALUES ('json', 14, 'format functions for JSON');`` "
"|br| ``UPDATE modules SET size = 15 WHERE name = 'json';`` |br| ``DELETE "
"FROM modules WHERE name = 'json';``"
msgstr ""

msgid "The corresponding non-SQL Tarantool requests would be:"
msgstr ""

msgid ""
"``box.space.MODULES:insert{'json', 14, 'format functions for JSON'}`` |br| "
"``box.space.MODULES:update('json', {{'=', 2, 15}})`` |br| "
"``box.space.MODULES:delete{'json'}`` |br|"
msgstr ""

msgid ""
"This is how we would populate the table with the values that we showed "
"earlier:"
msgstr ""

msgid ""
"``INSERT INTO modules VALUES ('box', 1432, 'Database Management');`` |br| "
"``INSERT INTO modules VALUES ('clock', 188, 'Seconds');`` |br| ``INSERT INTO"
" modules VALUES ('crypto', 4, 'Cryptography');`` |br|"
msgstr ""

msgid "**Constraints**"
msgstr ""

msgid ""
"Some data-change statements are illegal due to something in the table's "
"definition. This is called \"constraining what can be done\". We have "
"already seen some types of constraints ..."
msgstr ""

msgid ""
"NOT NULL -- if a column is defined with a NOT NULL clause, it is illegal to "
"put NULL into it. A primary-key column is automatically NOT NULL."
msgstr ""

msgid ""
"UNIQUE -- if a column has a UNIQUE index, it is illegal to put a duplicate "
"into it. A primary-key column automatically has a UNIQUE index."
msgstr ""

msgid ""
"data domain -- if a column is defined as having data type INTEGER, it is "
"illegal to put a non-number into it. More generally, if a value doesn't "
"correspond to the data type of the definition, it is illegal. Some database "
"management systems (DBMSs) are very forgiving and will try to make "
"allowances for bad values rather than reject them; Tarantool is a bit more "
"strict than those DBMSs."
msgstr ""
"Допустимые значения --- если столбец по определению содержит тип данных "
"INTEGER, в него запрещено помещать нечисловые значения. В целом, недопустимо"
" любое значение, которое не соответствует типу данных, указанному в "
"определении. Некоторые системы управления базами данных относительно гибки и"
" скорее примут некорректные значения, чем отклонят их. Tarantool в этом "
"плане более строгий."

msgid "Now, here are other types of constraints ..."
msgstr ""

msgid ""
"CHECK -- a table description can have a clause \"CHECK (conditional "
"expression)\". For example, if the CREATE TABLE modules statement looked "
"like this:"
msgstr ""

msgid ""
"CREATE TABLE modules (name STRING,\n"
"                      size INTEGER,\n"
"                      purpose STRING,\n"
"                      PRIMARY KEY (name),\n"
"                      CHECK (size > 0));"
msgstr ""

msgid ""
"then this INSERT statement would be illegal: |br| ``INSERT INTO modules "
"VALUES ('box', 0, 'The Database Kernel');`` |br| because there is a CHECK "
"constraint saying that the second column, the size column, cannot contain a "
"value which is less than or equal to zero. Try this instead: |br| ``INSERT "
"INTO modules VALUES ('box', 1, 'The Database Kernel');``"
msgstr ""

msgid ""
"FOREIGN KEY -- a table description can have a clause \"FOREIGN KEY (column-"
"list) REFERENCES table (column-list)\". For example, if there is a new table"
" \"submodules\" which in a way depends on the modules table, it can be "
"defined like this:"
msgstr ""

msgid ""
"CREATE TABLE submodules (name STRING,\n"
"                         module_name STRING,\n"
"                         size INTEGER,\n"
"                         purpose STRING,\n"
"                         PRIMARY KEY (name),\n"
"                         FOREIGN KEY (module_name) REFERENCES\n"
"                         modules (name));"
msgstr ""

msgid "Now try to insert a new row into this submodules table:"
msgstr ""

msgid ""
"``INSERT INTO submodules VALUES`` |br| |nbsp| |nbsp| ``('space', 'Box', "
"10000, 'insert etc.');``"
msgstr ""

msgid ""
"The insert will fail because the second column (module_name) refers to the "
"name column in the modules table, and the name column in the modules table "
"does not contain 'Box'. However, it does contain 'box'. By default searches "
"in Tarantool's SQL use a binary collation. This will work:"
msgstr ""

msgid ""
"``INSERT INTO submodules`` |br| |nbsp| |nbsp| ``VALUES ('space', 'box', "
"10000, 'insert etc.');``"
msgstr ""

msgid "Now try to delete the corresponding row from the modules table:"
msgstr "Теперь попробуем удалить соответствующую строку из таблицы modules:"

msgid "``DELETE FROM modules WHERE name = 'box';``"
msgstr ""

msgid ""
"The delete will fail because the second column (module_name) in the "
"submodules table refers to the name column in the modules table, and the "
"name column in the modules table would not contain 'box' if the delete "
"succeeded. So the FOREIGN KEY constraint affects both the table which "
"contains the FOREIGN KEY clause and the table that the FOREIGN KEY clause "
"refers to."
msgstr ""

msgid ""
"The constraints in a table's definition -- NOT NULL, UNIQUE, data domain, "
"CHECK, and FOREIGN KEY -- are guarantors of the database's integrity. It is "
"important that they are fixed and well-defined parts of the definition, and "
"hard to bypass with SQL. This is often seen as a difference between SQL and "
"NoSQL -- SQL emphasizes law and order, NoSQL emphasizes freedom and making "
"your own rules."
msgstr ""

msgid "**Table Relationships**"
msgstr ""

msgid "Think about the two tables that we have discussed so far:"
msgstr ""

msgid ""
"CREATE TABLE modules (name STRING,\n"
"                      size INTEGER,\n"
"                       purpose STRING,\n"
"                       PRIMARY KEY (name),\n"
"                       CHECK (size > 0));\n"
"\n"
"CREATE TABLE submodules (name STRING,\n"
"                         module_name STRING,\n"
"                         size INTEGER,\n"
"                         purpose STRING,\n"
"                         PRIMARY KEY (name),\n"
"                         FOREIGN KEY (module_name) REFERENCES\n"
"                         modules (name));"
msgstr ""

msgid ""
"Because of the FOREIGN KEYS clause in the submodules table, there is clearly"
" a many-to-one relationship: |br| submodules -->> modules |br| that is, "
"every submodules row must refer to one (and only one) modules row, while "
"every modules row can be referred to in zero or more submodules rows."
msgstr ""

msgid ""
"Table relationships are important, but beware: do not trust anyone who tells"
" you that databases made with SQL are relational \"because there are "
"relationships between tables\". That is wrong. We will see why when we talk "
"about what makes a database relational, later."
msgstr ""

msgid "**Selecting with WHERE**"
msgstr ""

msgid "We gave a simple example of a SELECT statement earlier:"
msgstr ""

msgid ""
"The clause \"WHERE name = 'clock'\" is legal in other statements -- we have "
"seen it in UPDATE and DELETE -- but here we will only give examples with "
"SELECT."
msgstr ""

msgid ""
"The first variation is that the WHERE clause does not have to be specified "
"at all, it is optional. So this statement would return all rows:"
msgstr ""

msgid "``SELECT size FROM modules;``"
msgstr ""

msgid ""
"The second variation is that the comparison operator does not have to be "
"'=', it can be anything that makes sense: '>' or '>=' or '<' or '<=', or "
"'LIKE' which is an operator that works with strings that may contain "
"wildcard characters '_' meaning 'match any one character' or '%' meaning "
"'match any zero or one or many characters'. These are legal statements which"
" return all rows:"
msgstr ""

msgid ""
"``SELECT size FROM modules WHERE name >= '';`` |br| ``SELECT size FROM "
"modules WHERE name LIKE '%';``"
msgstr ""

msgid ""
"The third variation is that IS [NOT] NULL is a special condition. "
"Remembering that the NULL value can mean \"it is unknown what the value "
"should be\", and supposing that in some row the size is NULL, then the "
"condition \"size > 10\" is not certainly true and it is not certainly false,"
" so it is evaluated as \"unknown\". Ordinarily the application of a WHERE "
"clause filters out both false and unknown results. So when searching for "
"NULL, say IS NULL; when searching anything that is not NULL, say IS NOT "
"NULL. This statement will return all rows because (due to the definition) "
"there are no NULLs in the name column:"
msgstr ""

msgid "``SELECT size FROM modules WHERE name IS NOT NULL;``"
msgstr ""

msgid ""
"The fourth variation is that conditions can be combined with AND / OR, and "
"negated with NOT."
msgstr ""

msgid ""
"So this statement would return all rows (the first condition is false but "
"the second condition is true, and OR means \"return true if either condition"
" is true\"):"
msgstr ""

msgid ""
"SELECT size\n"
"FROM modules\n"
"WHERE name = 'wombat' OR size IS NOT NULL;"
msgstr ""

msgid "**Selecting with a select list**"
msgstr ""

msgid "Yet again, here is a simple example of a SELECT statement:"
msgstr ""

msgid ""
"The words between SELECT and FROM are the select list. In this case, the "
"select list is just one word: size. Formally it means that the desire is to "
"return the size values, and technically the name for picking a particular "
"column is called \"projection\"."
msgstr ""

msgid "The first variation is that one can specify any column in any order:"
msgstr ""

msgid "``SELECT name, purpose, size FROM modules;``"
msgstr ""

msgid ""
"The second variation is that one can specify an expression, it does not have"
" to be a column name, it does not even have to include a column name. The "
"common expression operators for numbers are the arithmetic operators ``+ - /"
" *``; the common expression operator for strings is the concatenation "
"operator ||. For example this statement will return 8, 'XY':"
msgstr ""

msgid "``SELECT size * 2, 'X' || 'Y' FROM modules WHERE size = 4;``"
msgstr ""

msgid ""
"The third variation is that one can add a clause [AS name] after every "
"expression, so that in the return the column titles will make sense. This is"
" especially important when a title might otherwise be ambiguous or "
"meaningless. For example this statement will return 8, 'XY' as before"
msgstr ""

msgid ""
"``SELECT size * 2 AS double_size, 'X' || 'Y' AS concatenated_literals  FROM "
"modules`` |br| |nbsp| |nbsp| ``WHERE size = 4;``"
msgstr ""

msgid "but displayed as a table the result will look like"
msgstr ""

msgid ""
"+----------------+------------------------+\n"
"| DOUBLE_SIZE    | CONCATENATED_LITERALS  |\n"
"+----------------+------------------------+\n"
"|              8 | XY                     |\n"
"+----------------+------------------------+"
msgstr ""
"+----------------+------------------------+\n"
"| DOUBLE_SIZE    | CONCATENATED_LITERALS  |\n"
"+----------------+------------------------+\n"
"|              8 | XY                     |\n"
"+----------------+------------------------+"

msgid "**Selecting with a select list with asterisk**"
msgstr ""

msgid ""
"Instead of listing columns in a select list, one can just say ``'*'``. For "
"example"
msgstr ""

msgid "``SELECT * FROM modules;``"
msgstr ""

msgid "This is the same thing as"
msgstr ""

msgid "``SELECT name, size, purpose FROM modules;``"
msgstr ""

msgid ""
"Selecting with ``\"*\"``  saves time for the writer, but it is unclear to a "
"reader who has not memorized what the column names are. Also it is unstable,"
" because there is a way to change a table's definition (the ALTER statement,"
" which is an advanced topic). Nevertheless, although it might be bad to use "
"it for production, it is handy to use it for introduction, so we will use "
"``\"*\"`` in several examples."
msgstr ""

msgid "**Select with subqueries**"
msgstr ""

msgid ""
"Remember that we have a modules table and we have a submodules table. "
"Suppose that we want to list the submodules that refer to modules for which "
"the purpose is X. That is, this involves a search of one table using a value"
" in another table. This can be done by enclosing \"(SELECT ...)\" within the"
" WHERE clause. For example:"
msgstr ""

msgid ""
"SELECT name FROM submodules\n"
"WHERE module_name =\n"
"    (SELECT name FROM modules WHERE purpose LIKE '%Database%');"
msgstr ""

msgid ""
"Subqueries are also useful in the select list, when one wishes to combine "
"information from more than one table. For example this statement will "
"display submodules rows but will include values that come from the modules "
"table:"
msgstr ""

msgid ""
"SELECT name AS submodules_name,\n"
"    (SELECT purpose FROM modules\n"
"     WHERE modules.name = submodules.module_name)\n"
"     AS modules_purpose,\n"
"    purpose AS submodules_purpose\n"
"FROM submodules;"
msgstr ""

msgid ""
"Whoa. What are \"modules.name\" and \"submodules.name\"? Whenever you see "
"\"x . y\" you are looking at a \"qualified column name\", and the first part"
" is a table identifier, the second part is a column identifier. It is always"
" legal to use qualified column names, but until now it has not been "
"necessary. Now it is necessary, or at least it is a good idea, because both "
"tables have a column named \"name\"."
msgstr ""

msgid "The result will look like this:"
msgstr "Результат будет выглядеть следующим образом:"

msgid ""
"+-------------------+------------------------+--------------------+\n"
"| SUBMODULES_NAME   | MODULES_PURPOSE        | SUBMODULES_PURPOSE |\n"
"+-------------------+------------------------+--------------------+\n"
"| space             | Database Management    | insert etc.        |\n"
"+-------------------+------------------------+--------------------+"
msgstr ""
"+-------------------+------------------------+--------------------+\n"
"| SUBMODULES_NAME   | MODULES_PURPOSE        | SUBMODULES_PURPOSE |\n"
"+-------------------+------------------------+--------------------+\n"
"| space             | Управление БД          | Вставка ...        |\n"
"+-------------------+------------------------+--------------------+"

msgid ""
"Perhaps you have read somewhere that SQL stands for \"Structured Query "
"Language\". That is not true any more. But it is true that the query syntax "
"allows for a structural component, namely the subquery, and that was the "
"original idea. However, there is a different way to combine tables -- with "
"joins instead of subqueries."
msgstr ""

msgid "**Select with Cartesian join**"
msgstr ""

msgid ""
"Until now we have only used \"FROM modules\" or \"FROM submodules\" in our "
"SELECT statements. What if we used more than one table in the FROM clause? "
"For example"
msgstr ""

msgid ""
"``SELECT * FROM modules, submodules;`` |br| or ``SELECT * FROM modules JOIN "
"submodules;``"
msgstr ""

msgid ""
"That is legal. Usually it is not what you want, but it is a learning aid. "
"The result will be:"
msgstr ""

msgid ""
"{ columns from modules table }         { columns from submodules table }\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| NAME   | SIZE | PURPOSE             | NAME  | MODULE_NAME | SIZE  | PURPOSE     |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| box    | 1432 | Database Management | space | box         | 10000 | insert etc. |\n"
"| clock  |  188 | Seconds             | space | box         | 10000 | insert etc. |\n"
"| crypto |    4 | Cryptography        | space | box         | 10000 | insert etc. |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+"
msgstr ""
"{ столбцы таблицы modules }         { столбцы таблицы submodules }\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| NAME   | SIZE | PURPOSE             | NAME  | MODULE_NAME | SIZE  | PURPOSE     |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| box    | 1432 | Управление БД       | space | box         | 10000 | Вставка ... |\n"
"| clock  |  188 | Секунды             | space | box         | 10000 | Вставка ... |\n"
"| crypto |    4 | Криптография        | space | box         | 10000 | Вставка ... |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+"

msgid ""
"It is not an error. The meaning of this type of join is \"combine every row "
"in table-1 with every row in table-2\". It did not specify what the "
"relationship should be, so the result has everything, even when the "
"submodule has nothing to do with the module."
msgstr ""

msgid ""
"It is handy to look at the above result, called a \"Cartesian join\" result,"
" to see what we really want. Probably for this case the row that actually "
"makes sense is the one where the modules.name = submodules.module_name, and "
"we should make that clear in both the select list and the WHERE clause, "
"thus:"
msgstr ""

msgid ""
"SELECT modules.name AS modules_name,\n"
"       modules.size AS modules_size,\n"
"       modules.purpose AS modules_purpose,\n"
"       submodules.name,\n"
"       module_name,\n"
"       submodules.size,\n"
"       submodules.purpose\n"
"FROM modules, submodules\n"
"WHERE modules.name = submodules.module_name;"
msgstr ""

msgid "The result will be:"
msgstr "Мы получим следующий результат:"

msgid ""
"+----------+-----------+------------+--------+---------+-------+-------------+\n"
"| MODULES_ |  MODULES_ | MODULES_   | NAME   | MODULE_ | SIZE  | PURPOSE     |\n"
"| NAME     |  SIZE     | PURPOSE    |        | NAME    |       |             |\n"
"+----------+-----------+--------- --+--------+---------+-------+-------------+\n"
"| box      |      1432 | Database   | space  | box     | 10000 | insert etc. |\n"
"|          |           | Management |        |         |       |             |\n"
"+----------+-----------+------------+--------+---------+-------+-------------+"
msgstr ""
"+----------+-----------+------------+--------+---------+-------+-------------+\n"
"| MODULES_ |  MODULES_ | MODULES_   | NAME   | MODULE_ | SIZE  | PURPOSE     |\n"
"| NAME     |  SIZE     | PURPOSE    |        | NAME    |       |             |\n"
"+----------+-----------+--------- --+--------+---------+-------+-------------+\n"
"| box      |      1432 | Управление | space  | box     | 10000 | Вставка ... |\n"
"|          |           | БД         |        |         |       |             |\n"
"+----------+-----------+------------+--------+---------+-------+-------------+"

msgid ""
"In other words, you can specify a Cartesian join in the FROM clause, then "
"you can filter out the irrelevant rows in the WHERE clause, and then you can"
" rename columns in the select list. This is fine, and every SQL DBMS "
"supports this. But it is worrisome that the number of rows in a Cartesian "
"join is always (number of rows in first table multiplied by number of rows "
"in second table), which means that conceptually you are often filtering in a"
" large set of rows."
msgstr ""

msgid ""
"It is good to start by looking at Cartesian joins because they show the "
"concept. Many people, though, prefer to use different syntaxes for joins "
"because they look better or clearer. We will look at those alternatives now."
msgstr ""

msgid "**Select with join with ON clause**"
msgstr ""

msgid ""
"The ON clause would have the same comparisons as the WHERE clause that we "
"illustrated for the previous section, but by using different syntax we would"
" be making it clear \"this is for the sake of the join\". Readers can see at"
" a glance that it is, in concept at least, an initial step before the result"
" rows are filtered. For example this"
msgstr ""

msgid ""
"``SELECT * FROM modules JOIN submodules`` |br| |nbsp| |nbsp| ``ON "
"(modules.name = submodules.module_name);``"
msgstr ""

msgid "is the same as"
msgstr ""

msgid ""
"``SELECT * FROM modules, submodules`` |br| |nbsp| |nbsp| ``WHERE "
"modules.name = submodules.module_name;``"
msgstr ""

msgid "**Select with join with USING clause**"
msgstr ""

msgid ""
"The USING clause would take advantage of names that are held in common "
"between the two tables, with the assumption that the intent is to match "
"those columns with '=' comparisons. For example,"
msgstr ""

msgid "``SELECT * FROM modules JOIN submodules USING (name);``"
msgstr ""

msgid "has the same effect as"
msgstr ""

msgid ""
"``SELECT * FROM modules JOIN submodules WHERE modules.name = "
"submodules.name;``"
msgstr ""

msgid ""
"If we had created our table with a plan in advance to use USING clauses, "
"that would save time. But we did not. So, although the above example "
"\"works\", the results will not be sensible."
msgstr ""

msgid "**Select with natural join**"
msgstr ""

msgid ""
"A natural join would take advantage of names that are held in common between"
" the two tables, and would do the filtering automatically based on that "
"knowledge, and throw away duplicate columns."
msgstr ""

msgid ""
"If we had created our table with a plan in advance to use natural joins, "
"that would be very handy. But we did not. So, although the following example"
" \"works\", the results won't be sensible."
msgstr ""

msgid "``SELECT * FROM modules NATURAL JOIN submodules;``"
msgstr ""

msgid ""
"Result: nothing, because modules.name does not match submodules.name, and so"
" on And even if there had been a result, it would only have included four "
"columns: name, module_name, size, purpose."
msgstr ""

msgid "**Select with left join**"
msgstr ""

msgid ""
"Now what if we want to join modules to submodules, but we want to be sure "
"that we get all the modules? In other words, we want to get modules even if "
"the condition submodules.module_name = modules.name is not true, because the"
" module has no submodules."
msgstr ""

msgid ""
"When that is what we want, the type of join is an \"outer join\" (as opposed"
" to the type we have used so far which is an \"inner join\"). Specifically "
"we will use LEFT [OUTER] JOIN because our main table, modules, is on the "
"left. For example:"
msgstr ""

msgid ""
"SELECT *\n"
"FROM modules LEFT JOIN submodules\n"
"ON modules.name = submodules.module_name;"
msgstr ""

msgid "which returns:"
msgstr ""

msgid ""
"{ columns from modules table }         { columns from submodules table }\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| NAME   | SIZE | PURPOSE             | NAME  | MODULE_NAME | SIZE  | PURPOSE     |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| box    | 1432 | Database Management | space | box         | 10000 | insert etc. |\n"
"| clock  |  188 | Seconds             | NULL  | NULL        | NULL  | NULL        |\n"
"| crypto |    4 | Cryptography        | NULL  | NULL        | NULL  | NULL        |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+"
msgstr ""
"{ столбцы таблицы modules    }         { столбцы таблицы submodules    }\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| NAME   | SIZE | PURPOSE             | NAME  | MODULE_NAME | SIZE  | PURPOSE     |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| box    | 1432 | Управление БД       | space | box         | 10000 | Вставка ... |\n"
"| clock  |  188 | Секунды             | NULL  | NULL        | NULL  | NULL        |\n"
"| crypto |    4 | Криптография        | NULL  | NULL        | NULL  | NULL        |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+"

msgid ""
"Thus, for the submodules of the clock module and the submodules of the "
"crypto module -- which do not exist -- there are NULLs in every column."
msgstr ""

msgid "**Select with functions**"
msgstr ""

msgid ""
"A function can take any expression, including an expression that contains "
"another function, and return a scalar value. There are many such functions. "
"We will just describe one, SUBSTR, which returns a substring of a string."
msgstr ""

msgid "Format: :samp:`SUBSTR({input-string}, {start-with} [, {length}])`"
msgstr ""

msgid ""
"Description: SUBSTR takes input-string, eliminates any characters before "
"start-with, eliminates any characters after (start-with plus length), and "
"returns the result."
msgstr ""

msgid "Example: ``SUBSTR('abcdef', 2, 3)`` returns 'bcd'."
msgstr ""

msgid "Select with aggregation, GROUP BY, and HAVING"
msgstr ""

msgid "Remember that our modules table looks like this:"
msgstr ""

msgid ""
"Suppose that we do not want to know all the individual size values, we just "
"want to know about their aggregation, that is, take the attributes of the "
"collection. SQL allows aggregation functions including: AVG (average), SUM, "
"MIN (minimum), MAX (maximum), and COUNT. For example"
msgstr ""
"Предположим, что требуется не получить все отдельные значения из столбца "
"``size``, а узнать что-либо об их совокупности, то есть получить атрибуты "
"коллекции. SQL позволяет использовать агрегатные функции, в том числе: AVG "
"(среднее значение), SUM (сумма), MIN (минимум), MAX (максимум) и COUNT "
"(число элементов). Пример:"

msgid ""
"``SELECT AVG(size), SUM(size), MIN(size), MAX(size), COUNT(size) FROM "
"modules;``"
msgstr ""

msgid ""
"+-----------+-----------+-----------+-----------+-----------+\n"
"| COLUMN_1  | COLUMN_2  | COLUMN_3  | COLUMN_4  | COLUMN_5  |\n"
"+-----------+-----------+-----------+-----------+-----------|\n"
"|       541 |      1624 |         4 |      1432 |         3 |\n"
"+-----------+-----------+-----------+-----------+-----------+"
msgstr ""
"+-----------+-----------+-----------+-----------+-----------+\n"
"| СТОЛБЕЦ1  | СТОЛБЕЦ2  | СТОЛБЕЦ3  | СТОЛБЕЦ4  | СТОЛБЕЦ5  |\n"
"+-----------+-----------+-----------+-----------+-----------|\n"
"|       541 |      1624 |         4 |      1432 |         3 |\n"
"+-----------+-----------+-----------+-----------+-----------+"

msgid ""
"Suppose that we want aggregations, but aggregations of rows that have some "
"common characteristic. Supposing further, we want to divide the rows into "
"two groups, the ones whose names begin with 'b' and the ones whose names "
"begin with 'c'. This can be done by adding a clause [GROUP BY expression]. "
"For example,"
msgstr ""

msgid ""
"SELECT SUBSTR(name, 1, 1), AVG(size), SUM(size), MIN(size), MAX(size), COUNT(size)\n"
"FROM modules\n"
"GROUP BY SUBSTR(name, 1, 1);"
msgstr ""

msgid ""
"+------------+--------------+-----------+-----------+-----------+-------------+\n"
"| COLUMN_1   | COLUMN_2     | COLUMN_3  | COLUMN_4  | COLUMN_5  | COLUMN_6    |\n"
"+------------+--------------+-----------+-----------+-----------+-------------+\n"
"| b          |         1432 |      1432 |      1432 |      1432 |           1 |\n"
"| c          |           96 |       192 |         4 |       188 |           2 |\n"
"+------------+--------------+-----------+-----------+-----------+-------------+"
msgstr ""
"+------------+--------------+-----------+-----------+-----------+-------------+\n"
"| СТОЛБЕЦ1   | СТОЛБЕЦ2     | СТОЛБЕЦ3  | СТОЛБЕЦ4  | СТОЛБЕЦ5  | СТОЛБЕЦ6    |\n"
"+------------+--------------+-----------+-----------+-----------+-------------+\n"
"| b          |         1432 |      1432 |      1432 |      1432 |           1 |\n"
"| c          |           96 |       192 |         4 |       188 |           2 |\n"
"+------------+--------------+-----------+-----------+-----------+-------------+"

msgid "**Select with common table expression**"
msgstr ""

msgid ""
"It is possible to define a temporary (viewed) table within a statement, "
"usually within a SELECT statement, using a WITH clause. For example:"
msgstr ""

msgid "``WITH tmp_table AS (SELECT x1 FROM t1) SELECT * FROM tmp_table;``"
msgstr ""

msgid "**Select with order, limit, and offset clauses**"
msgstr ""

msgid ""
"Every time we have searched in the modules table, the rows have come out in "
"alphabetical order by name: 'box', then 'clock', then 'crypto'. However, if "
"we want to be sure about the order, or if we want a different order, we will"
" have to be explicit and add a clause: ``ORDER BY column-name [ASC|DESC]``. "
"(ASC stands for ASCending, DESC stands for DESCending.) For example:"
msgstr ""

msgid "``SELECT * FROM modules ORDER BY name DESC;``"
msgstr ""

msgid ""
"The result will be the usual rows, in descending alphabetical order: "
"'crypto' then 'clock' then 'box'."
msgstr ""

msgid ""
"After the ORDER BY clause we can add a clause LIMIT n, where n is the "
"maximum number of rows that we want. For example:"
msgstr ""

msgid "``SELECT * FROM modules ORDER BY name DESC LIMIT 2;``"
msgstr ""

msgid "The result will be the first two rows, 'crypto' and 'clock'."
msgstr ""

msgid ""
"After the ORDER BY clause and the LIMIT clause we can add a clause OFFSET n,"
" where n is the row to start with. The first offset is 0. For example:"
msgstr ""

msgid "``SELECT * FROM modules ORDER BY name DESC LIMIT 2 OFFSET 2;``"
msgstr ""

msgid "The result will be the third row, 'box'."
msgstr ""

msgid "**Views**"
msgstr ""

msgid ""
"A view is a canned SELECT. If you have a complex SELECT that you want to run"
" frequently, create a view and then do a simple SELECT on the view. For "
"example:"
msgstr ""

msgid ""
"CREATE VIEW v AS SELECT size, (size *5) AS size_times_5\n"
"FROM modules\n"
"GROUP BY size, name\n"
"ORDER BY size_times_5;\n"
"SELECT * FROM v;"
msgstr ""

msgid "**Transactions**"
msgstr "**Транзакции**"

msgid ""
"Tarantool has a \"Write Ahead Log\" (WAL). Effects of data-change statements"
" are logged before they are permanently stored on disk. This is a reason "
"that, although entire databases can be stored in temporary memory, they are "
"not vulnerable in case of power failure."
msgstr ""

msgid ""
"Tarantool supports commits and rollbacks. In effect, asking for a commit "
"means asking for all the recent data-change statements, since a transaction "
"began, to become permanent. In effect, asking for a rollback means asking "
"for all the recent data-change statements, since a transaction began, to be "
"cancelled."
msgstr ""

msgid "For example, consider these statements:"
msgstr ""

msgid ""
"CREATE TABLE things (remark STRING, PRIMARY KEY (remark));\n"
"START TRANSACTION;\n"
"INSERT INTO things VALUES ('A');\n"
"COMMIT;\n"
"START TRANSACTION;\n"
"INSERT INTO things VALUES ('B');\n"
"ROLLBACK;\n"
"SELECT * FROM things;"
msgstr ""

msgid ""
"The result will be: one row, containing 'A'. The ROLLBACK cancelled the "
"second INSERT statement, but did not cancel the first one, because it had "
"already been committed."
msgstr ""

msgid "Ordinarily every statement is automatically committed."
msgstr ""

msgid ""
"After START TRANSACTION, statements are not automatically committed -- "
"Tarantool considers that a transaction is now \"active\", until the "
"transaction ends with a COMMIT statement or a ROLLBACK statement. While a "
"transaction is active, all statements are legal except another START "
"TRANSACTION."
msgstr ""

msgid "**Implementing Tarantool's SQL On Top of NoSQL**"
msgstr ""

msgid ""
"Tarantool's SQL data is the same as Tarantool's NoSQL data. When you create "
"a table or an index with SQL, you are creating a space or an index in NoSQL."
" For example:"
msgstr ""

msgid ""
"CREATE TABLE things (remark STRING, PRIMARY KEY (remark));\n"
"INSERT INTO things VALUES ('X');"
msgstr ""

msgid "is somewhat similar to"
msgstr ""

msgid ""
"box.schema.space.create('THINGS',\n"
"{\n"
"    format = {\n"
"              [1] = {[\"name\"] = \"REMARK\", [\"type\"] = \"string\"}\n"
"              }\n"
"})\n"
"box.space.THINGS:create_index('pk_unnamed_THINGS_1',{unique=true,parts={1,'string'}})\n"
"box.space.THINGS:insert{'X'}"
msgstr ""

msgid ""
"Therefore you can take advantage of Tarantool's NoSQL features even though "
"your primary language is SQL. Here are some possibilities."
msgstr ""

msgid ""
"(1) NoSQL applications written in one of the connector languages may be "
"slightly faster than SQL applications because SQL statements may require "
"more parsing and may be translated to NoSQL requests."
msgstr ""

msgid ""
"(2) You can write stored procedures in Lua, combining Lua loop-control and "
"Lua library-access statements with SQL statements. These routines are "
"executed on the server, which is the principal advantage of pure-SQL stored "
"procedures."
msgstr ""

msgid ""
"(3) There are some options that are implemented in NoSQL that are not (yet) "
"implemented in SQL. For example you can use NoSQL to change an index option,"
" and to deny access to users named 'guest'."
msgstr ""

msgid ""
"(4) System spaces such as _space and _index can be accessed with SQL SELECT "
"statements. This is not quite the same as an information_schema, but it does"
" mean that you can use SQL to access the database's metadata catalog."
msgstr ""

msgid ""
"Fields in NoSQL spaces can be accessed with SQL if and only if they are "
"scalar and are defined in format clauses. Indexes of NoSQL spaces will be "
"used with SQL if and only if they are TREE indexes."
msgstr ""

msgid "**Relational Databases**"
msgstr "**Реляционные базы данных**"

msgid ""
"Edgar F. Codd, the person most responsible for researching and explaining "
"relational database concepts, listed the main criteria as (`Codd's 12 rules "
"<https://en.wikipedia.org/wiki/Codd's_12_rules>`_)."
msgstr ""

msgid ""
"Although we do not advertise Tarantool as \"relational\", we claim that "
"Tarantool complies with these rules, with the following caveats and "
"exceptions ..."
msgstr ""

msgid ""
"The rules state that all data must be viewable as relations. A Tarantool SQL"
" table is a relation. However, it is possible to have duplicate values in "
"SQL tables and it is possible to have an implicit ordering. Those "
"characteristics are not allowed for true relations."
msgstr ""

msgid ""
"The rules state that there must be a dynamic online catalog. Tarantool has "
"one but some metadata is missing from it."
msgstr ""

msgid ""
"The rules state that the data language must support authorization. "
"Tarantool's SQL does not. Authorization occurs via NoSQL requests."
msgstr ""

msgid ""
"The rules require that data must be physically independent (from underlying "
"storage changes) and logically independent (from application program "
"changes). So far we do not have enough experience to make this guarantee."
msgstr ""

msgid ""
"The rules require certain types of updatable views. Tarantool's views are "
"not updatable."
msgstr ""

msgid ""
"The rules state that it should be impossible to use a low-level language to "
"bypass integrity as defined in the relational-level language. In our case, "
"this is not true, for example one can execute a request with Tarantool's "
"NoSQL to violate a foreign-key constraint that was defined with Tarantool's "
"SQL."
msgstr ""
