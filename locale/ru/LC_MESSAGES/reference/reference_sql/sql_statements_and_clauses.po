
msgid "SQL statements and clauses"
msgstr ""

msgid ""
"The Statements and Clauses guide shows all Tarantool/SQL statements' "
"syntax and use."
msgstr ""

msgid "Heading"
msgstr ""

msgid "Summary"
msgstr ""

msgid ""
":ref:`Statements that change data definition "
"<sql_statements_change_definition>`"
msgstr ""

msgid ""
":ref:`ALTER TABLE <sql_alter_table>`, :ref:`CREATE TABLE "
"<sql_create_table>`, :ref:`DROP TABLE <sql_drop_table>`, :ref:`CREATE "
"VIEW <sql_create_view>`, :ref:`DROP VIEW <sql_drop_view>`, :ref:`CREATE "
"INDEX <sql_create_index>`, :ref:`DROP INDEX <sql_drop_index>`, "
":ref:`CREATE TRIGGER <sql_create_trigger>`, :ref:`DROP TRIGGER "
"<sql_drop_trigger>`"
msgstr ""

msgid ":ref:`Statements that change data <sql_statements_change_data>`"
msgstr ""

msgid ""
":ref:`INSERT <sql_insert>`, :ref:`UPDATE <sql_update>`, :ref:`DELETE "
"<sql_delete>`, :ref:`REPLACE <sql_replace>`, :ref:`TRUNCATE "
"<sql_truncate>`, :ref:`SET <sql_set>`"
msgstr ""

msgid ":ref:`Statements that retrieve data <sql_statements_retrieve_data>`"
msgstr ""

msgid ""
":ref:`SELECT <sql_select>`, :ref:`VALUES <sql_values>`, :ref:`PRAGMA "
"<sql_pragma>`, :ref:`EXPLAIN <sql_explain>`"
msgstr ""

msgid ":ref:`Statements for transactions <sql_transactions>`"
msgstr ""

msgid ""
":ref:`START TRANSACTION <sql_start_transaction>`, :ref:`COMMIT "
"<sql_commit>`, :ref:`SAVEPOINT <sql_savepoint>`, :ref:`RELEASE SAVEPOINT "
"<sql_release_savepoint>`, :ref:`ROLLBACK <sql_rollback>`"
msgstr ""

msgid ":ref:`Functions <sql_functions>`"
msgstr ""

msgid ""
"For example :ref:`CAST(...) <sql_function_cast>`, :ref:`LENGTH(...) "
"<sql_function_length>`, :ref:`VERSION() <sql_function_version>`"
msgstr ""

msgid "Statements that change data definition"
msgstr ""

msgid "ALTER TABLE"
msgstr ""

msgid "Syntax:"
msgstr ""

msgid ":samp:`ALTER TABLE {table-name} RENAME TO {new-table-name};`"
msgstr ""

msgid ""
":samp:`ALTER TABLE {table-name} ADD CONSTRAINT {constraint-name} "
"{constraint-definition};`"
msgstr ""

msgid ":samp:`ALTER TABLE {table-name} DROP CONSTRAINT {constraint-name};`"
msgstr ""

msgid ""
":samp:`ALTER TABLE {table-name} ENABLE|DISABLE CHECK CONSTRAINT "
"{constraint-name};`"
msgstr ""

msgid "|br|"
msgstr ""

msgid "ALTER is used to change a table's name or a table's constraints."
msgstr ""

msgid "**Examples:**"
msgstr ""

msgid ""
"For renaming a table with ``ALTER ... RENAME``, the *old-table* must "
"exist, the *new-table* must not exist. Example: |br| ``-- renaming a "
"table:`` ``ALTER TABLE t1 RENAME TO t2;``"
msgstr ""

msgid ""
"For adding a :ref:`table constraint <sql_table_constraint_def>` with "
"``ADD CONSTRAINT``, the table must exist, the table must be empty, the "
"constraint name must be unique within the table. Example with a :ref"
":`foreign-key constraint definition <sql_foreign_key>`: |br| ``ALTER "
"TABLE t1 ADD CONSTRAINT fk_s1_t1_1 FOREIGN KEY (s1) REFERENCES t1;`` |br|"
msgstr ""

msgid ""
"It is not possible to say ``CREATE TABLE table_a ... REFERENCES table_b "
"...`` if table ``b`` does not exist yet. This is a situation where "
"``ALTER TABLE`` is handy -- users can ``CREATE TABLE table_a`` without "
"the foreign key, then ``CREATE TABLE table_b``, then ``ALTER TABLE "
"table_a ... REFERENCES table_b ...``."
msgstr ""

msgid ""
"-- adding a primary-key constraint definition:\n"
"-- This is unusual because primary keys are created automatically\n"
"-- and it is illegal to have two primary keys for the same table.\n"
"-- However, it is possible to drop a primary-key index, and this\n"
"-- is a way to restore the primary key if that happens.\n"
"ALTER TABLE t1 ADD CONSTRAINT \"pk_unnamed_T1_1\" PRIMARY KEY (s1);\n"
"\n"
"-- adding a unique-constraint definition:\n"
"-- Alternatively, you can say CREATE UNIQUE INDEX unique_key ON t1 (s1);\n"
"ALTER TABLE t1 ADD CONSTRAINT \"unique_unnamed_T1_2\" UNIQUE (s1);\n"
"\n"
"-- Adding a check-constraint definition:\n"
"ALTER TABLE t1 ADD CONSTRAINT \"ck_unnamed_T1_1\" CHECK (s1 > 0);"
msgstr ""

msgid ""
"For ``ALTER ... DROP CONSTRAINT``, it is only legal to drop a named "
"constraint. (Tarantool generates the constraint names automatically if "
"the user does not provide them.) To remove a unique constraint, use use "
"either ``ALTER ... DROP CONSTRAINT`` or :ref:`DROP INDEX "
"<sql_drop_index>`, which will drop the constraint as well."
msgstr ""

msgid ""
"-- dropping a constraint:\n"
"ALTER TABLE t1 DROP CONSTRAINT \"fk_unnamed_JJ2_1\";"
msgstr ""

msgid ""
"For ``ALTER ... ENABLE|DISABLE CHECK CONSTRAINT``, it is only legal to "
"enable or disable a named constraint, and Tarantool only looks for names "
"of check constraints. By default a constraint is enabled. If a constraint"
" is disabled, then the check will not be performed."
msgstr ""

msgid ""
"-- disabling and re-enabling a constraint:\n"
"ALTER TABLE t1 DISABLE CHECK CONSTRAINT c;\n"
"ALTER TABLE t1 ENABLE CHECK CONSTRAINT c;"
msgstr ""

msgid "Limitations:"
msgstr ""

msgid ""
"It is not possible to add or drop a column. However, there is a plan to "
"make it possible to add a column for an empty table (`Issue#3075 "
"<https://github.com/tarantool/tarantool/issues/3075>`_)."
msgstr ""

msgid ""
"It is not possible to modify NOT NULL constraints or column properties "
"DEFAULT and :ref:`data type <sql_column_def_data_type>`. However, it is "
"possible to modify them with Tarantool/NOSQL, for example by calling "
":ref:`space_object:format() <box_space-format>` with a different "
"``is_nullable`` value."
msgstr ""

msgid "CREATE TABLE"
msgstr ""

msgid ""
":samp:`CREATE TABLE [IF NOT EXISTS] {table-name} (column-definition or "
"table-constraint list)` :samp:`[WITH ENGINE = {string}];`"
msgstr ""

msgid "Create a new base table, usually called a \"table\"."
msgstr ""

msgid ""
"A table is a *base table* if it is created with CREATE TABLE and contains"
" data in persistent storage."
msgstr ""

msgid ""
"A table is a *viewed table*, or just \"view\", if it is created with "
":ref:`CREATE VIEW <sql_create_view>` and gets its data from other views "
"or from base tables."
msgstr ""

msgid ""
"The *table-name* must be an identifier which is valid according to the "
"rules for identifiers, and must not be the name of an already existing "
"base table or view."
msgstr ""

msgid ""
"The *column-definition* or *table-constraint* list is a comma-separated "
"list of :ref:`column definitions <sql_column_def>` or :ref:`table "
"constraint definitions <sql_table_constraint_def>`. Column definitions "
"and table constraint definitions are sometimes called *table elements*."
msgstr ""

msgid "Rules:"
msgstr ""

msgid ""
"A primary key is necessary; it can be specified with a table constraint "
"PRIMARY KEY."
msgstr ""

msgid "There must be at least one column."
msgstr ""

msgid ""
"When IF NOT EXISTS is specified, and there is already a table with the "
"same name, the statement is ignored."
msgstr ""

msgid ""
"When :samp:`WITH ENGINE = {string}` is specified, where :samp:`{string}` "
"must be either 'memtx' or 'vinyl', the table is created with that "
":ref:`storage engine <engines-chapter>`. When this clause is not "
"specified, the table is created with the default engine, which is "
"ordinarily 'memtx' but may be changed by updating the "
":ref:`box.space._session_settings <box_space-session_settings>` system "
"table.."
msgstr ""

msgid "Actions:"
msgstr ""

msgid ""
"Tarantool evaluates each column definition and table-constraint, and "
"returns an error if any of the rules is violated."
msgstr ""

msgid "Tarantool makes a new definition in the schema."
msgstr ""

msgid ""
"Tarantool makes new indexes for PRIMARY KEY or UNIQUE constraints. A "
"unique index name is created automatically."
msgstr ""

msgid ""
"Usually Tarantool effectively executes a :ref:`COMMIT <sql_commit>` "
"statement."
msgstr ""

msgid "Examples:"
msgstr ""

msgid ""
"-- the simplest form, with one column and one constraint:\n"
"CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
"\n"
"-- you can see the effect of the statement by querying\n"
"-- Tarantool system spaces:\n"
"SELECT * FROM \"_space\" WHERE \"name\" = 'T1';\n"
"SELECT * FROM \"_index\" JOIN \"_space\" ON \"_index\".\"id\" = "
"\"_space\".\"id\"\n"
"         WHERE \"_space\".\"name\" = 'T1';\n"
"\n"
"-- variation of the simplest form, with delimited identifiers\n"
"-- and a bracketed comment:\n"
"CREATE TABLE \"T1\" (\"S1\" INT /* synonym of INTEGER */, PRIMARY KEY "
"(\"S1\"));\n"
"\n"
"-- two columns, one named constraint\n"
"CREATE TABLE t1 (s1 INTEGER, s2 STRING, CONSTRAINT pk_s1s2_t1_1 PRIMARY "
"KEY (s1, s2));"
msgstr ""

msgid "The maximum number of columns is 2000."
msgstr ""

msgid ""
"The maximum length of a row depends on the :ref:`memtx_max_tuple_size "
"<cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size  "
"<cfg_storage-memtx_max_tuple_size>` configuration option."
msgstr ""

msgid "Column definition"
msgstr ""

msgid ":samp:`column-name data-type [, column-constraint]`"
msgstr ""

msgid ""
"Define a column, which is a table-element used in a :ref:`CREATE TABLE "
"<sql_create_table>` statement."
msgstr ""

msgid ""
"The ``column-name`` must be an identifier which is valid according to the"
" rules for identifiers."
msgstr ""

msgid "Each ``column-name`` must be unique within a table."
msgstr ""

msgid "Column definition -- data type"
msgstr ""

msgid ""
"Every column has a data type: BOOLEAN or DOUBLE or INTEGER or NUMBER or "
"SCALAR or STRING or UNSIGNED or VARBINARY. The detailed description of "
"data types is in the section :ref:`Operands <sql_operands>`."
msgstr ""

msgid "Column definition -- the rules for the SCALAR data type"
msgstr ""

msgid ""
"SCALAR is a \"complex\" data type, unlike all the other data types which "
"are \"primitive\". Two column values in a SCALAR column can have two "
"different primitive data types."
msgstr ""

msgid ""
"Any item defined as SCALAR has an underlying primitive type. For example,"
" here:"
msgstr ""

msgid ""
"CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (55), ('41');"
msgstr ""

msgid ""
"the underlying primitive type of the item in the first row is INTEGER "
"because literal 55 has data type INTEGER, and the underlying primitive "
"type in the second row is STRING (the data type of a literal is always "
"clear from its format)."
msgstr ""

msgid ""
"An item's primitive type is far more important than its defined type. "
"Incidentally Tarantool might find the primitive type by looking at the "
"way MsgPack stores it, but that is an implementation detail."
msgstr ""

msgid ""
"A SCALAR definition may not include a maximum length, as there is no "
"suggested restriction."
msgstr ""

msgid ""
"A SCALAR definition may include a :ref:`COLLATE clause "
"<sql_collate_clause>`, which affects any items whose primitive data type "
"is STRING. The default collation is \"binary\"."
msgstr ""

msgid ""
"Some assignments are illegal when data types differ, but legal when the "
"target is a SCALAR item. For example ``UPDATE ... SET column1 = 'a'`` is "
"illegal if ``column1`` is defined as INTEGER, but is legal if ``column1``"
" is defined as SCALAR -- values which happen to be INTEGER will be "
"changed so their data type is STRING."
msgstr ""

msgid "There is no literal syntax which implies data type SCALAR."
msgstr ""

msgid ""
"TYPEOF(x) is never SCALAR, it is always the underlying data type. This is"
" true even if ``x`` is NULL (in that case the data type is BOOLEAN). In "
"fact there is no function that is guaranteed to return the defined data "
"type. For example, ``TYPEOF(CAST(1 AS SCALAR));`` returns INTEGER, not "
"SCALAR."
msgstr ""

msgid ""
"For any operation that requires implicit casting from an item defined as "
"SCALAR, the syntax is legal but the operation may fail at runtime. At "
"runtime, Tarantool detects the underlying primitive data type and applies"
" the rules for that. For example, if a definition is:"
msgstr ""

msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY, s2 INTEGER);"
msgstr ""

msgid ""
"and within any row ``s1 = 'a'``, that is, its underlying primitive type "
"is STRING to indicate character strings, then ``UPDATE t SET s2 = s1;`` "
"is illegal. Tarantool usually does not know that in advance."
msgstr ""

msgid ""
"For any dyadic operation that requires implicit casting for comparison, "
"the syntax is legal and the operation will not fail at runtime. Take this"
" situation: comparison with a primitive type VARBINARY and a primitive "
"type STRING."
msgstr ""

msgid ""
"CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (X'41');\n"
"SELECT * FROM t WHERE s1 > 'a';"
msgstr ""

msgid ""
"The comparison is valid, because Tarantool knows the ordering of X'41' "
"and 'a' in Tarantool/NoSQL 'scalar'."
msgstr ""

msgid ""
"The result data type of :ref:`min/max <sql_aggregate>` operation on a "
"column defined as SCALAR is the data type of the minimum/maximum operand,"
" unless the result value is NULL. For example:"
msgstr ""

msgid ""
"CREATE TABLE t (s1 INTEGER, s2 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (1, X'44'), (2, 11), (3, 1E4), (4, 'a');\n"
"SELECT min(s2), hex(max(s2)) FROM t;"
msgstr ""

msgid "The result is: ``- - [11, '44',]``"
msgstr ""

msgid ""
"That is only possible with Tarantool/NoSQL scalar rules, but ``SELECT "
"SUM(s2)`` would not be legal because addition would in this case require "
"implicit casting from VARBINARY to a number, which is not sensible."
msgstr ""

msgid ""
"The result data type of a primitive combination is never SCALAR because "
"we in effect use TYPEOF(item) not the defined data type. (Here we use the"
" word \"combination\" in the way that the standard document uses it for "
"section \"Result of data type combinations\".) Therefore for "
"``greatest(1E308, 'a', 0, X'00')`` the result is X'00'."
msgstr ""

msgid "Column definition -- relation to NoSQL"
msgstr ""

msgid ""
"All the SQL data types correspond to :ref:`Tarantool/NoSQL types with the"
" same name <box_space-index_field_types>`. For example an SQL STRING is "
"stored in a NoSQL space as type = 'string'."
msgstr ""

msgid ""
"Therefore specifying an SQL data type X determines that the storage will "
"be in a space with a format column saying that the NoSQL type is 'x'."
msgstr ""

msgid "The rules for that NoSQL type are applicable to the SQL data type."
msgstr ""

msgid ""
"If two items have SQL data types that have the same underlying type, then"
" they are compatible for all assignment or comparison purposes."
msgstr ""

msgid ""
"If two items have SQL data types that have different underlying types, "
"then the rules for explicit casts, or implicit (assignment) casts, or "
"implicit (comparison) casts, apply."
msgstr ""

msgid ""
"There is one floating-point value which is not handled by SQL: -nan is "
"seen as NULL."
msgstr ""

msgid ""
"There are also some Tarantool/NoSQL data types which have no "
"corresponding SQL data types. For example, ``SELECT \"flags\" FROM "
"\"_space\";`` will return a column whose data type is 'map'. Such columns"
" can only be manipulated in SQL by :ref:`invoking Lua functions "
"<sql_calling_lua>`."
msgstr ""

msgid "Column definition -- column-constraint or default clause"
msgstr ""

msgid "The column-constraint or default clause may be as follows:"
msgstr ""

msgid "Type"
msgstr ""

msgid "Comment"
msgstr ""

msgid "NOT NULL"
msgstr ""

msgid "means \"it is illegal to assign a NULL to this column\""
msgstr ""

msgid "PRIMARY KEY"
msgstr ""

msgid ""
"explained in the later section :ref:`\"Table Constraint Definition\" "
"<sql_table_constraint_def>`"
msgstr ""

msgid "UNIQUE"
msgstr ""

msgid "explained in the later section \"Table Constraint Definition\""
msgstr ""

msgid "CHECK (expression)"
msgstr ""

msgid "foreign-key-clause"
msgstr ""

msgid ""
"explained in the later section :ref:`\"Table Constraint Definition for "
"foreign keys\" <sql_foreign_key>`"
msgstr ""

msgid "DEFAULT expression"
msgstr ""

msgid ""
"means \"if INSERT does not assign to this column then assign expression "
"result to this column\" -- if there is no DEFAULT clause then DEFAULT "
"NULL is assumed."
msgstr ""

msgid ""
"If column-constraint is PRIMARY KEY, this is a shorthand for a separate "
":ref:`table-constraint definition <sql_table_constraint_def>`: \"PRIMARY "
"KEY (column-name)\"."
msgstr ""

msgid ""
"If column-constraint is UNIQUE, this is a shorthand for a separate :ref"
":`table-constraint definition <sql_table_constraint_def>`: \"UNIQUE "
"(column-name)\"."
msgstr ""

msgid ""
"If column-constraint is CHECK, this is a shorthand for a separate :ref"
":`table-constraint definition <sql_table_constraint_def>`: \"CHECK "
"(expression)\"."
msgstr ""

msgid "Columns defined with PRIMARY KEY are automatically NOT NULL."
msgstr ""

msgid ""
"To enforce some restrictions that Tarantool does not enforce "
"automatically, add CHECK clauses, like these:"
msgstr ""

msgid ""
"CREATE TABLE t (\"smallint\" INTEGER PRIMARY KEY CHECK (\"smallint\" <= "
"32767 AND \"smallint\" >= -32768));\n"
"CREATE TABLE t (\"shorttext\" STRING PRIMARY KEY CHECK "
"(length(\"shorttext\") <= 10));"
msgstr ""

msgid "but this may cause inserts or updates to be slow."
msgstr ""

msgid "Column definition -- examples"
msgstr ""

msgid ""
"These are shown within :ref:`CREATE TABLE <sql_create_table>` statements."
" Data types may also appear in :ref:`CAST <sql_function_cast>` functions."
msgstr ""

msgid ""
"-- the simple form with column-name and data-type\n"
"CREATE TABLE t (column1 INTEGER ...);\n"
"-- with column-name and data-type and column-constraint\n"
"CREATE TABLE t (column1 STRING PRIMARY KEY ...);\n"
"-- with column-name and data-type and collate-clause\n"
"CREATE TABLE t (column1 SCALAR COLLATE \"unicode\" ...);"
msgstr ""

msgid ""
"-- with all possible data types and aliases\n"
"CREATE TABLE t\n"
"(column1 BOOLEAN, column2 BOOL,\n"
" column3 INT PRIMARY KEY, column4 INTEGER,\n"
" column5 DOUBLE,\n"
" column6 NUMBER,\n"
" column7 STRING, column8 STRING COLLATE \"unicode\",\n"
" column9 TEXT, columna TEXT COLLATE \"unicode_sv_s1\",\n"
" columnb VARCHAR(0), columnc VARCHAR(100000) COLLATE \"binary\",\n"
" columnd VARBINARY,\n"
" columne SCALAR, columnf SCALAR COLLATE \"unicode_uk_s2\");"
msgstr ""

msgid ""
"-- with all possible column constraints and a default clause\n"
"CREATE TABLE t\n"
"(column1 INTEGER NOT NULL,\n"
" column2 INTEGER PRIMARY KEY,\n"
" column3 INTEGER UNIQUE,\n"
" column4 INTEGER CHECK (column3 > column2),\n"
" column5 INTEGER REFERENCES t,\n"
" column6 INTEGER DEFAULT NULL);"
msgstr ""

msgid "Table Constraint Definition"
msgstr ""

msgid ""
":samp:`[CONSTRAINT {constraint-name}] primary-key-constraint | unique-"
"constraint | check-constraint | foreign-key-constraint`"
msgstr ""

msgid ""
"Define a constraint, which is a table-element used in a CREATE TABLE "
"statement."
msgstr ""

msgid ""
"The constraint-name must be an identifier which is valid according to the"
" rules for identifiers. The constraint-name must be unique within the "
"table."
msgstr ""

msgid ""
"PRIMARY KEY constraints look like this: |br| :samp:`PRIMARY KEY ({column-"
"name} [, {column-name}...])`"
msgstr ""

msgid ""
"There is a shorthand: specifying PRIMARY KEY in a :ref:`column definition"
" <sql_column_def_constraint>`."
msgstr ""

msgid ""
"Every table must have one and only one primary key. |br| Primary-key "
"columns are automatically NOT NULL. |br| Primary-key columns are "
"automatically indexed. |br| Primary-key columns are unique, that is, it "
"is illegal to have two rows which have the same values for the columns "
"specified in the constraint."
msgstr ""

msgid ""
"-- this is a table with a one-column primary-key constraint\n"
"CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
"-- this is the column-definition shorthand for the same thing:\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY);\n"
"-- this is a table with a two-column primary-key constraint\n"
"CREATE TABLE t2 (s1 INTEGER, s2 INTEGER, PRIMARY KEY (s1, s2));\n"
"-- this is an example of an attempted primary-key violation\n"
"-- (the third INSERT will fail because 55, 'a' is a duplicate)\n"
"CREATE TABLE t3 (s1 INTEGER, s2 STRING, PRIMARY KEY (s1, s2));\n"
"INSERT INTO t3 VALUES (55, 'a');\n"
"INSERT INTO t3 VALUES (55, 'b');\n"
"INSERT INTO t3 VALUES (55, 'a');"
msgstr ""

msgid ""
"PRIMARY KEY plus AUTOINCREMENT modifier may be specified in one of two "
"ways: |br| - In a column definition after the words PRIMARY KEY, as in "
"``CREATE TABLE t (c INTEGER PRIMARY KEY AUTOINCREMENT);`` |br| - In a "
"PRIMARY KEY (column-list) after a column name, as in ``CREATE TABLE t (c "
"INTEGER, PRIMARY KEY (c AUTOINCREMENT));`` |br| When AUTOINCREMENT is "
"specified, the column must be a primary-key column and it must be INTEGER"
" or UNSIGNED. |br| Only one column in the table may be autoincrement. "
"However, it is legal to say ``PRIMARY KEY (a, b, c AUTOINCREMENT)`` -- in"
" that case, there are three columns in the primary key but only the first"
" column (``a``) is AUTOINCREMENT."
msgstr ""

msgid ""
"As the name suggests, values in an autoincrement column are automatically"
" incremented. That is: if a user inserts NULL in the column, then the "
"stored value will be the smallest non-negative integer that has not "
"already been used. This occurs because autoincrement columns are "
"associated with :doc:`sequences "
"</reference/reference_lua/box_schema_sequence/create_index>`."
msgstr ""

msgid ""
"UNIQUE constraints look like this: |br| :samp:`UNIQUE ({column-name} [, "
"{column-name}...])`"
msgstr ""

msgid ""
"There is a shorthand: specifying UNIQUE in a :ref:`column definition "
"<sql_column_def_constraint>`."
msgstr ""

msgid ""
"Unique constraints are similar to primary-key constraints, except that: a"
" table may have any number of unique keys, and unique keys are not "
"automatically NOT NULL. |br| Unique columns are automatically indexed. "
"|br| Unique columns are unique, that is, it is illegal to have two rows "
"with the same values in the unique-key columns."
msgstr ""

msgid ""
"-- this is a table with a one-column primary-key constraint\n"
"-- and a one-column unique constraint\n"
"CREATE TABLE t1 (s1 INTEGER, s2 INTEGER, PRIMARY KEY (s1), UNIQUE (s2));\n"
"-- this is the column-definition shorthand for the same thing:\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER UNIQUE);\n"
"-- this is a table with a two-column unique constraint\n"
"CREATE TABLE t2 (s1 INTEGER PRIMARY KEY, s2 INTEGER, UNIQUE (s2, s1));\n"
"-- this is an example of an attempted unique-key violation\n"
"-- (the third INSERT will not fail because NULL is not a duplicate)\n"
"-- (the fourth INSERT will fail because 'a' is a duplicate)\n"
"CREATE TABLE t3 (s1 INTEGER PRIMARY KEY, s2 STRING, UNIQUE (s2));\n"
"INSERT INTO t3 VALUES (1, 'a');\n"
"INSERT INTO t3 VALUES (2, NULL);\n"
"INSERT INTO t3 VALUES (3, NULL);\n"
"INSERT INTO t3 VALUES (4, 'a');"
msgstr ""

msgid "CHECK constraints look like this: |br| :samp:`CHECK ({expression})`"
msgstr ""

msgid ""
"There is a shorthand: specifying CHECK in a :ref:`column definition "
"<sql_column_def_constraint>`."
msgstr ""

msgid ""
"The expression may be anything that returns a BOOLEAN result = TRUE or "
"FALSE or UNKNOWN. |br| The expression may not contain a :ref:`subquery "
"<sql_subquery>`. |br| If the expression contains a column name, the "
"column must exist in the table. |br| If a CHECK constraint is specified, "
"the table must not contain rows where the expression is FALSE. (The table"
" may contain rows where the expression is either TRUE or UNKNOWN.) |br| "
"Constraint checking may be stopped with :ref:`ALTER TABLE ... DISABLE "
"CHECK CONSTRAINT <sql_alter_table>` and restarted with ALTER TABLE ... "
"ENABLE CHECK CONSTRAINT."
msgstr ""

msgid ""
"-- this is a table with a one-column primary-key constraint\n"
"-- and a check constraint\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER, CHECK (s2 <> s1));\n"
"-- this is an attempt to violate the constraint, it will fail\n"
"INSERT INTO t1 VALUES (1, 1);\n"
"-- this is okay because comparison with NULL will not return FALSE\n"
"INSERT INTO t1 VALUES (1, NULL);\n"
"-- a constraint that makes it difficult to insert lower case\n"
"CHECK (s1 = UPPER(s1))"
msgstr ""

msgid ""
"Limitations: (`Issue#3503 "
"<https://github.com/tarantool/tarantool/issues/3503>`_): |br| * ``CREATE "
"TABLE t99 (s1 INTEGER, UNIQUE(s1, s1),PRIMARY KEY(s1));`` causes no error"
" message, although (s1, s1) is probably a user error."
msgstr ""

msgid "Table Constraint Definition for foreign keys"
msgstr ""

msgid ""
"FOREIGN KEY constraints look like this: |br| :samp:`FOREIGN KEY "
"({referencing-column-name} [, {referencing-column-name}...]) REFERENCES "
"{referenced-table-name} [({referenced-column-name} [, {referenced-column-"
"name}...]]) [MATCH FULL] [update-or-delete-rules]`"
msgstr ""

msgid ""
"There is a shorthand: specifying REFERENCES in a :ref:`column definition "
"<sql_column_def_constraint>`."
msgstr ""

msgid ""
"The referencing column names must be defined in the table that is being "
"created. The referenced table name must refer to a table that already "
"exists, or to the table that is being created. The referenced column "
"names must be defined in the referenced table, and have similar data "
"types. There must be a PRIMARY KEY or UNIQUE constraint or UNIQUE index "
"on the referenced column names."
msgstr ""

msgid "The words MATCH FULL are optional and have no effect."
msgstr ""

msgid ""
"If a foreign-key constraint exists, then the values in the referencing "
"columns must equal values in the referenced columns of the referenced "
"table, or at least one of the referencing columns must contain NULL."
msgstr ""

msgid ""
"-- A foreign key referencing a primary key in the same table\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER, FOREIGN KEY (s2) "
"REFERENCES t1 (s1));\n"
"-- The same thing with column shorthand\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER REFERENCES t1(s1));\n"
"-- An attempt to violate the constraint -- this will fail\n"
"INSERT INTO t1 VALUES (1, 2);\n"
"-- A NULL in the referencing column -- this will succeed\n"
"INSERT INTO t1 VALUES (1, NULL);\n"
"-- A reference to a primary key that now exists -- this will succeed\n"
"INSERT INTO t1 VALUES (2, 1);"
msgstr ""

msgid ""
"The optional update-or-delete rules look like this: |br| ``ON "
"{UPDATE|DELETE} { CASCADE | SET DEFAULT | SET NULL | RESTRICT | NO "
"ACTION}`` |br| and the idea is: if something changes the referenced key, "
"then one of these possible \"referential actions\" takes place: |br| "
"``CASCADE``: the change that is applied for the referenced key is applied"
" for the referencing key. |br| ``SET DEFAULT``: the referencing key is "
"set to its default value. |br| ``SET NULL``: the referencing key is set "
"to NULL. |br| ``RESTRICT``: the UPDATE or DELETE fails if a referencing "
"key exists; checked immediately. |br| ``NO ACTION``: the UPDATE or DELETE"
" fails if a referencing key exists; checked at statement end. |br| The "
"default is ``NO ACTION``."
msgstr ""

msgid "For example:"
msgstr ""

msgid ""
"CREATE TABLE f1 (ordinal INTEGER PRIMARY KEY,\n"
"             referenced_planet STRING UNIQUE NOT NULL);\n"
"CREATE TABLE f2 (\n"
"    ordinal INTEGER PRIMARY KEY,\n"
"    referring_planet STRING DEFAULT 'Earth',\n"
"    FOREIGN KEY (referring_planet) REFERENCES f1 (referenced_planet)\n"
"        ON UPDATE SET DEFAULT\n"
"        ON DELETE CASCADE);\n"
"INSERT INTO f1 VALUES (1, 'Mercury'), (2,' Venus'), (3, 'Earth');\n"
"INSERT INTO f2 VALUES (1, 'Mercury'), (2, 'Mercury');\n"
"UPDATE f1 SET referenced_planet = 'Mars'\n"
"    WHERE referenced_planet = 'Mercury';\n"
"SELECT * FROM f2;\n"
"DELETE FROM f1 WHERE referenced_planet = 'Earth';\n"
"SELECT * FROM f2;\n"
"... In this example, the UPDATE statement changes the referenced key,\n"
"    and the clause is ON UPDATE SET DEFAULT, therefore both of the\n"
"    rows in f2 have referring_planet set to their default value,\n"
"    which is 'Earth'. The DELETE statement deletes the row that\n"
"    has 'Earth', and the clause is ON DELETE CASCADE,\n"
"    therefore both of the rows in f2 are deleted."
msgstr ""

msgid ""
"Limitations: |br| * Foreign keys can have a MATCH clause (`Issue#3455 "
"<https://github.com/tarantool/tarantool/issues/3455>`_)."
msgstr ""

msgid "DROP TABLE"
msgstr ""

msgid ":samp:`DROP TABLE [IF EXISTS] {table-name};`"
msgstr ""

msgid "Drop a table."
msgstr ""

msgid ""
"The *table-name* must identify a table that was created earlier with the "
":ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

msgid ""
"If there is a view that references the table, the drop will fail. Please "
"drop the referencing view with :ref:`DROP VIEW <sql_drop_view>` first."
msgstr ""

msgid ""
"If there is a foreign key that references the table, the drop will fail. "
"Please drop the referencing constraint with :ref:`ALTER TABLE ... DROP "
"<sql_alter_table_drop_constraint>` first."
msgstr ""

msgid ""
"Tarantool returns an error if the table does not exist and there is no "
"``IF EXISTS`` clause."
msgstr ""

msgid "The table and all its data are dropped."
msgstr ""

msgid "All indexes for the table are dropped."
msgstr ""

msgid "All triggers for the table are dropped."
msgstr ""

msgid ""
"-- the simple case:\n"
"DROP TABLE t31;\n"
"-- with an IF EXISTS clause:\n"
"DROP TABLE IF EXISTS t31;"
msgstr ""

msgid "See also: :ref:`DROP VIEW <sql_drop_view>`."
msgstr ""

msgid "CREATE VIEW"
msgstr ""

msgid ""
":samp:`CREATE VIEW [IF NOT EXISTS] {view-name} [(column-list)] AS "
"subquery;`"
msgstr ""

msgid "Create a new viewed table, usually called a \"view\"."
msgstr ""

msgid "The *view-name* must be valid according to the rules for identifiers."
msgstr ""

msgid ""
"The optional *column-list* must be a comma-separated list of names of "
"columns in the view."
msgstr ""

msgid ""
"The syntax of the subquery must be the same as the syntax of a "
":ref:`SELECT statement <sql_select>`, or of a VALUES clause."
msgstr ""

msgid ""
"There must not already be a base table or view with the same name as "
"*view-name*."
msgstr ""

msgid ""
"If *column-list* is specified, the number of columns in *column-list* "
"must be the same as the number of columns in the :ref:`select list "
"<sql_select_list>` of the subquery."
msgstr ""

msgid "Tarantool will throw an error if a rule is violated."
msgstr ""

msgid ""
"Tarantool will create a new persistent object with *column-names* equal "
"to the names in the *column-list* or the names in the subquery's *select "
"list*."
msgstr ""

msgid ""
"-- the simple case:\n"
"CREATE VIEW v AS SELECT column1, column2 FROM t;\n"
"-- with a column-list:\n"
"CREATE VIEW v (a,b) AS SELECT column1, column2 FROM t;"
msgstr ""

msgid ""
"It is not possible to insert or update or delete from a view, although "
"sometimes a possible substitution is to :ref:`create an INSTEAD OF "
"trigger <sql_create_trigger>`."
msgstr ""

msgid "DROP VIEW"
msgstr ""

msgid ":samp:`DROP VIEW [IF EXISTS] {view-name};`"
msgstr ""

msgid "Drop a view."
msgstr ""

msgid ""
"The *view-name* must identify a view that was created earlier with the "
":ref:`CREATE VIEW statement <sql_create_view>`."
msgstr ""

msgid "Rules: none"
msgstr ""

msgid ""
"Tarantool returns an error if the view does not exist and there is no "
"``IF EXISTS`` clause."
msgstr ""

msgid "The view is dropped."
msgstr ""

msgid "All triggers for the view are dropped."
msgstr ""

msgid ""
"-- the simple case:\n"
"DROP VIEW v31;\n"
"-- with an IF EXISTS clause:\n"
"DROP VIEW IF EXISTS v31;"
msgstr ""

msgid "See also: :ref:`DROP TABLE <sql_drop_table>`."
msgstr ""

msgid "CREATE INDEX"
msgstr ""

msgid ""
":samp:`CREATE [UNIQUE] INDEX [IF NOT EXISTS] {index-name} ON {table-name}"
" (column-list);`"
msgstr ""

msgid "Create an index."
msgstr ""

msgid "The *index-name* must be valid according to the rules for identifiers."
msgstr ""

msgid "The *table-name* must refer to an existing table."
msgstr ""

msgid ""
"The *column-list* must be a comma-separated list of names of columns in "
"the table."
msgstr ""

msgid ""
"There must not already be, for the same table, an index with the same "
"name as *index-name*. But there may already be, for a different table, an"
" index with the same name as *index-name*."
msgstr ""

msgid "The maximum number of indexes per table is 128."
msgstr ""

msgid ""
"If the new index is UNIQUE, Tarantool will throw an error if any row "
"exists with columns that have duplicate values."
msgstr ""

msgid "Tarantool will create a new index."
msgstr ""

msgid "Automatic indexes:"
msgstr ""

msgid ""
"Indexes may be created automatically for columns mentioned in the PRIMARY"
" KEY or UNIQUE clauses of a CREATE TABLE statement. If an index was "
"created automatically, then the *index-name* has four parts:"
msgstr ""

msgid ""
"``pk`` if this is for a PRIMARY KEY clause, ``unique`` if this is for a "
"UNIQUE clause;"
msgstr ""

msgid "``_unnamed_``;"
msgstr ""

msgid "the name of the table;"
msgstr ""

msgid ""
"``_`` and an ordinal number; the first index is 1, the second index is 2,"
" and so on."
msgstr ""

msgid ""
"For example, after ``CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER, "
"UNIQUE (s2));`` there are two indexes named ``pk_unnamed_T_1`` and "
"``unique_unnamed_T_2``. You can confirm this by saying ``SELECT * FROM "
"\"_index\";`` which will list all indexes on all tables. There is no need"
" to say ``CREATE INDEX`` for columns that already have automatic indexes."
msgstr ""

msgid ""
"-- the simple case\n"
"CREATE INDEX idx_column1_t_1 ON t (column1);\n"
"-- with IF NOT EXISTS clause\n"
"CREATE INDEX IF NOT EXISTS idx_column1_t_1 ON t (column1);\n"
"-- with UNIQUE specifier and more than one column\n"
"CREATE UNIQUE INDEX idx_unnamed_t_1 ON t (column1, column2);"
msgstr ""

msgid ""
"Dropping an automatic index created for a unique constraint will drop the"
" unique constraint as well."
msgstr ""

msgid "DROP INDEX"
msgstr ""

msgid ":samp:`DROP INDEX [IF EXISTS] index-name ON {table-name};`"
msgstr ""

msgid ""
"The *index-name* must be the name of an existing index, which was created"
" with :ref:`CREATE INDEX <sql_create_index>`. Or, the *index-name* must "
"be the name of an index that was created automatically due to a PRIMARY "
"KEY or UNIQUE clause in the :ref:`CREATE TABLE <sql_create_table>` "
"statement. To see what a table's indexes are, use :ref:`PRAGMA index_list"
"(table-name); <sql_pragma>`."
msgstr ""

msgid ""
"Tarantool throws an error if the index does not exist, or is an "
"automatically created index."
msgstr ""

msgid "Tarantool will drop the index."
msgstr ""

msgid "Example:"
msgstr ""

msgid ""
"-- the simplest form:\n"
"DROP INDEX idx_unnamed_t_1 ON t;"
msgstr ""

msgid "CREATE TRIGGER"
msgstr ""

msgid ""
":samp:`CREATE TRIGGER [IF NOT EXISTS] {trigger-name}` |br| "
":samp:`BEFORE|AFTER|INSTEAD OF` |br| :samp:`DELETE|INSERT|UPDATE ON "
"{table-name}` |br| :samp:`FOR EACH ROW` |br| :samp:`[WHEN search-"
"condition]` |br| :samp:`BEGIN` |br| :samp:`delete-statement | insert-"
"statement | replace-statement | select-statement | update-statement;` "
"|br| :samp:`[delete-statement | insert-statement | replace-statement | "
"select-statement | update-statement; ...]` |br| :samp:`END;`"
msgstr ""

msgid "The *trigger-name* must be valid according to the rules for identifiers."
msgstr ""

msgid ""
"If the trigger action time is BEFORE or AFTER, then the *table-name* must"
" refer to an existing base table."
msgstr ""

msgid ""
"If the trigger action time is INSTEAD OF, then the *table-name* must "
"refer to an existing view."
msgstr ""

msgid "There must not already be a trigger with the same name as *trigger-name*."
msgstr ""

msgid "Triggers on different tables or views share the same namespace."
msgstr ""

msgid ""
"The statements between BEGIN and END should not refer to the *table-name*"
" mentioned in the ON clause."
msgstr ""

msgid ""
"The statements between BEGIN and END should not contain an :ref:`INDEXED "
"BY <sql_indexed_by>` clause."
msgstr ""

msgid ""
"SQL triggers are not activated by Tarantool/NoSQL requests. This will "
"change in a future version."
msgstr ""

msgid ""
"On a :ref:`replica <Replication>`, effects of trigger execution are "
"applied, and the SQL triggers themselves are not activated upon "
"replication events."
msgstr ""

msgid ""
"NoSQL triggers are activated both on replica and master, thus if you have"
" a :ref:`NoSQL trigger <triggers>` on a replica, it is activated when "
"applying effects of an SQL trigger."
msgstr ""

msgid "Tarantool will create a new trigger."
msgstr ""

msgid ""
"-- the simple case:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with IF NOT EXISTS clause:\n"
"CREATE TRIGGER IF NOT EXISTS stores_before_insert BEFORE INSERT ON stores"
" FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with FOR EACH ROW and WHEN clauses:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW "
"WHEN a=5\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with multiple statements between BEGIN and END:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; INSERT INTO inventories VALUES (1); END;"
msgstr ""

msgid "Trigger extra clauses"
msgstr ""

msgid ":samp:`UPDATE OF column-list`"
msgstr ""

msgid ""
"After BEFORE|AFTER UPDATE it is optional to add ``OF column-list``. If "
"any of the columns in *column-list* is affected at the time the row is "
"processed, then the trigger will be activated for that row. For example:"
msgstr ""

msgid ""
"CREATE TRIGGER table1_before_update\n"
" BEFORE UPDATE  OF column1, column2 ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"UPDATE table1 SET column3 = column3 + 1; -- Trigger will not be activated"
"\n"
"UPDATE table1 SET column2 = column2 + 0; -- Trigger will be activated"
msgstr ""

msgid ":samp:`WHEN`"
msgstr ""

msgid ""
"After *table-name* FOR EACH ROW it is optional to add [``WHEN "
"expression``]. If the expression is true at the time the row is "
"processed, only then will the trigger will be activated for that row. For"
" example:"
msgstr ""

msgid ""
"CREATE TRIGGER table1_before_update BEFORE UPDATE ON table1 FOR EACH ROW\n"
" WHEN (SELECT COUNT(*) FROM table1) > 1\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;"
msgstr ""

msgid ""
"This trigger will not be activated unless there is more than one row in "
"``table1``."
msgstr ""

msgid ":samp:`OLD and NEW`"
msgstr ""

msgid ""
"The keywords OLD and NEW have special meaning in the context of trigger "
"action:"
msgstr ""

msgid "OLD.column-name refers to the value of *column-name* before the change."
msgstr ""

msgid "NEW.column-name refers to the value of *column-name* after the change."
msgstr ""

msgid ""
"CREATE TABLE table1 (column1 STRING, column2 INTEGER PRIMARY KEY);\n"
"CREATE TABLE table2 (column1 STRING, column2 STRING, column3 INTEGER "
"PRIMARY KEY);\n"
"INSERT INTO table1 VALUES ('old value', 1);\n"
"INSERT INTO table2 VALUES ('', '', 1);\n"
"CREATE TRIGGER table1_before_update BEFORE UPDATE ON table1 FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = old.column1, column2 = new.column1; "
"END;\n"
"UPDATE table1 SET column1 = 'new value';\n"
"SELECT * FROM table2;"
msgstr ""

msgid ""
"At the beginning of the UPDATE for the single row of ``table1``, the "
"value in ``column1`` is 'old value' -- so that is what is seen as "
"``old.column1``."
msgstr ""

msgid ""
"At the end of the UPDATE for the single row of ``table1``, the value in "
"``column1`` is 'new value' -- so that is what is seen as ``new.column1``."
" (OLD and NEW are qualifiers for ``table1``, not ``table2.``)"
msgstr ""

msgid ""
"Therefore, ``SELECT * FROM table2;`` returns ``['old value', 'new "
"value']``."
msgstr ""

msgid "``OLD.column-name`` does not exist for an INSERT trigger."
msgstr ""

msgid "``NEW.column-name`` does not exist for a DELETE trigger."
msgstr ""

msgid "OLD and NEW are read-only; you cannot change their values."
msgstr ""

msgid "Deprecated or illegal statements:"
msgstr ""

msgid ""
"It is illegal for the trigger action to include a qualified column "
"reference other than ``OLD.column-name`` or ``NEW.column-name``. For "
"example, ``CREATE TRIGGER ... BEGIN UPDATE table1 SET table1.column1 = 5;"
" END;`` is illegal."
msgstr ""

msgid ""
"It is illegal for the trigger action to include statements that include a"
" :ref:`WITH clause <sql_with>`, a DEFAULT VALUES clause, or an "
":ref:`INDEXED BY <sql_indexed_by>` clause."
msgstr ""

msgid ""
"It is usually not a good idea to have a trigger on ``table1`` which "
"causes a change on ``table2``, and at the same time have a trigger on "
"``table2`` which causes a change on ``table1``. For example:"
msgstr ""

msgid ""
"CREATE TRIGGER table1_before_update\n"
" BEFORE UPDATE ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"CREATE TRIGGER table2_before_update\n"
" BEFORE UPDATE ON table2\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table1 SET column1 = column1 + 1; END;"
msgstr ""

msgid ""
"Luckily ``UPDATE table1 ...`` will not cause an infinite loop, because "
"Tarantool recognizes when it has already updated so it will stop. "
"However, not every DBMS acts this way."
msgstr ""

msgid "Trigger activation"
msgstr ""

msgid "These are remarks concerning trigger activation."
msgstr ""

msgid "Standard terminology:"
msgstr ""

msgid "\"trigger action time\" = BEFORE or AFTER or INSTEAD OF"
msgstr ""

msgid "\"trigger event\" = INSERT or DELETE or UPDATE"
msgstr ""

msgid ""
"\"triggered statement\" = BEGIN ... DELETE|INSERT|REPLACE|SELECT|UPDATE "
"... END"
msgstr ""

msgid "\"triggered when clause\" = WHEN search-condition"
msgstr ""

msgid "\"activate\" = execute a triggered statement"
msgstr ""

msgid "some vendors use the word \"fire\" instead of \"activate\""
msgstr ""

msgid ""
"If there is more than one trigger for the same trigger event, Tarantool "
"may execute the triggers in any order."
msgstr ""

msgid ""
"It is possible for a triggered statement to cause activation of another "
"triggered statement. For example, this is legal:"
msgstr ""

msgid ""
"CREATE TRIGGER t1_before_delete BEFORE DELETE ON t1 FOR EACH ROW BEGIN "
"DELETE FROM t2; END;\n"
"CREATE TRIGGER t2_before_delete BEFORE DELETE ON t2 FOR EACH ROW BEGIN "
"DELETE FROM t3; END;"
msgstr ""

msgid ""
"Activation occurs FOR EACH ROW, not FOR EACH STATEMENT. Therefore, if no "
"rows are candidates for insert or update or delete, then no triggers are "
"activated."
msgstr ""

msgid "The BEFORE trigger is activated even if the trigger event fails."
msgstr ""

msgid ""
"If an UPDATE trigger event does not make a change, the trigger is "
"activated anyway. For example, if row 1 ``column1`` contains ``'a'``, and"
" the trigger event is ``UPDATE ... SET column1 = 'a';``, the trigger is "
"activated."
msgstr ""

msgid ""
"The triggered statement may refer to a function: ``RAISE(FAIL, error-"
"message)``. If a triggered statement invokes a ``RAISE(FAIL, error-"
"message)`` function, or if a triggered statement causes an error, then "
"statement execution stops immediately."
msgstr ""

msgid ""
"The triggered statement may refer to column values within the rows being "
"changed. in this case:"
msgstr ""

msgid ""
"The row \"as of before\" the change is called the \"old\" row (which "
"makes sense only for UPDATE and DELETE statements)."
msgstr ""

msgid ""
"The row \"as of after\" the change is called the \"new\" row (which makes"
" sense only for UPDATE and INSERT statements)."
msgstr ""

msgid ""
"This example shows how an INSERT can be done to a view by referring to "
"the \"new\" row:"
msgstr ""

msgid ""
"CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"CREATE VIEW v AS SELECT s1, s2 FROM t;\n"
"CREATE TRIGGER v_instead_of INSTEAD OF INSERT ON v\n"
"  FOR EACH ROW\n"
"  BEGIN INSERT INTO t VALUES (new.s1, new.s2); END;\n"
"INSERT INTO v VALUES (1, 2);"
msgstr ""

msgid ""
"Ordinarily saying ``INSERT INTO view_name ...`` is illegal in Tarantool, "
"so this is a workaround."
msgstr ""

msgid ""
"It is possible to generalize this so that all data-change statements on "
"views will change the base tables, provided that the view contains all "
"the columns of the base table, and provided that the triggers refer to "
"those columns when necessary, as in this example:"
msgstr ""

msgid ""
"CREATE TABLE base_table (primary_key_column INTEGER PRIMARY KEY, "
"value_column INTEGER);\n"
"CREATE VIEW viewed_table AS SELECT primary_key_column, value_column FROM "
"base_table;\n"
"CREATE TRIGGER viewed_table_instead_of_insert INSTEAD OF INSERT ON "
"viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    INSERT INTO base_table VALUES (new.primary_key_column, "
"new.value_column); END;\n"
"CREATE TRIGGER viewed_table_instead_of_update INSTEAD OF UPDATE ON "
"viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    UPDATE base_table\n"
"    SET primary_key_column = new.primary_key_column, value_column = "
"new.value_column\n"
"    WHERE primary_key_column = old.primary_key_column; END;\n"
"CREATE TRIGGER viewed_table_instead_of_delete INSTEAD OF DELETE ON "
"viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    DELETE FROM base_table WHERE primary_key_column = "
"old.primary_key_column; END;"
msgstr ""

msgid ""
"When INSERT or UPDATE or DELETE occurs for table ``X``, Tarantool usually"
" operates in this order (a basic scheme):"
msgstr ""

msgid ""
"For each row\n"
"  Perform constraint checks\n"
"  For each BEFORE trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the triggered statement.\n"
"  Insert or update or delete the row in table X.\n"
"  Perform more constraint checks\n"
"  For each AFTER trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the triggered statement."
msgstr ""

msgid ""
"However, Tarantool does not guarantee execution order when there are "
"multiple constraints, or multiple triggers for the same event (including "
"NoSQL :ref:`on_replace triggers <box_space-on_replace>` or SQL "
":ref:`INSTEAD OF triggers <sql_instead_of_triggers>` that affect a view "
"of table ``X``)."
msgstr ""

msgid "The maximum number of trigger activations per statement is 32."
msgstr ""

msgid "INSTEAD OF triggers"
msgstr ""

msgid ""
"A trigger which is created with the clause |br| :samp:`INSTEAD OF "
"{INSERT|UPDATE|DELETE} ON {view-name}` |br| is an INSTEAD OF trigger. For"
" each affected row, the trigger action is performed \"instead of\" the "
"INSERT or UPDATE or DELETE statement that causes trigger activation."
msgstr ""

msgid ""
"For example, ordinarily it is illegal to INSERT rows in a view, but it is"
" legal to create a trigger which intercepts attempts to INSERT, and puts "
"rows in the underlying base table:"
msgstr ""

msgid ""
"CREATE TABLE t1 (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
"CREATE VIEW v1 AS SELECT column1, column2 FROM t1;\n"
"CREATE TRIGGER v1_instead_of INSTEAD OF INSERT ON v1 FOR EACH ROW BEGIN\n"
" INSERT INTO t1 VALUES (NEW.column1, NEW.column2); END;\n"
"INSERT INTO v1 VALUES (1, 1);\n"
"-- ... The result will be: table t1 will contain a new row."
msgstr ""

msgid ""
"INSTEAD OF triggers are only legal for views, while BEFORE or AFTER "
"triggers are only legal for base tables."
msgstr ""

msgid "It is legal to create INSTEAD OF triggers with triggered WHEN clauses."
msgstr ""

msgid ""
"It is legal to create INSTEAD OF triggers with UPDATE OF *column-list* "
"clauses, but they are not standard SQL."
msgstr ""

msgid ""
"CREATE TRIGGER ev1_instead_of_update\n"
"  INSTEAD OF UPDATE OF column2,column1 ON ev1\n"
"  FOR EACH ROW BEGIN\n"
"  INSERT INTO et2 VALUES (NEW.column1, NEW.column2); END;"
msgstr ""

msgid "DROP TRIGGER"
msgstr ""

msgid ":samp:`DROP TRIGGER [IF EXISTS] {trigger-name};`"
msgstr ""

msgid "Drop a trigger."
msgstr ""

msgid ""
"The *trigger-name* must identify a trigger that was created earlier with "
"the :ref:`CREATE TRIGGER <sql_create_trigger>` statement."
msgstr ""

msgid ""
"Tarantool returns an error if the trigger does not exist and there is no "
"``IF EXISTS`` clause."
msgstr ""

msgid "The trigger is dropped."
msgstr ""

msgid ""
"-- the simple case:\n"
"DROP TRIGGER table1_before_insert;\n"
"-- with an IF EXISTS clause:\n"
"DROP TRIGGER IF EXISTS table1_before_insert;"
msgstr ""

msgid "Statements that change data"
msgstr ""

msgid "INSERT"
msgstr ""

msgid ""
":samp:`INSERT INTO {table-name} [(column-list)] VALUES (expression-list) "
"[, (expression-list)];`"
msgstr ""

msgid ":samp:`INSERT INTO {table-name} [(column-list)]  select-statement;`"
msgstr ""

msgid ":samp:`INSERT INTO {table-name} DEFAULT VALUES;`"
msgstr ""

msgid "Insert one or more new rows into a table."
msgstr ""

msgid ""
"The *table-name* must be a name of a table defined earlier with "
":ref:`CREATE TABLE <sql_create_table>`."
msgstr ""

msgid ""
"The optional *column-list* must be a comma-separated list of names of "
"columns in the table."
msgstr ""

msgid ""
"The *expression-list* must be a comma-separated list of expressions; each"
" expression may contain literals and operators and subqueries and "
"function invocations."
msgstr ""

msgid "The values in the *expression-list* are evaluated from left to right."
msgstr ""

msgid ""
"The order of the values in the *expression-list* must correspond to the "
"order of the columns in the table, or (if a *column-list* is specified) "
"to the order of the columns in the *column-list*."
msgstr ""

msgid ""
"The data type of the value should correspond to the :ref:`data type of "
"the column <sql_column_def_data_type>`, that is, the data type that was "
"specified with CREATE TABLE."
msgstr ""

msgid ""
"If a *column-list* is not specified, then the number of expressions must "
"be the same as the number of columns in the table."
msgstr ""

msgid ""
"If a *column-list* is specified, then some columns may be omitted; "
"omitted columns will get default values."
msgstr ""

msgid ""
"The parenthesized *expression-list* may be repeated -- ``(expression-list"
"),(expression-list),...`` -- for multiple rows."
msgstr ""

msgid ""
"Tarantool evaluates each expression in *expression-list*, and returns an "
"error if any of the rules is violated."
msgstr ""

msgid ""
"Tarantool creates zero or more new rows containing values based on the "
"values in the VALUES list or based on the results of the *select-"
"expression* or based on the default values."
msgstr ""

msgid ""
"Tarantool executes constraint checks and trigger actions and the actual "
"insertion."
msgstr ""

msgid ""
"-- the simplest form:\n"
"INSERT INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"INSERT INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"INSERT INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"INSERT INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

msgid "See also: :ref:`REPLACE statement <sql_replace>`."
msgstr ""

msgid "UPDATE"
msgstr ""

msgid ""
":samp:`UPDATE {table-name} SET column-name = expression [, column-name = "
"expression ...] [WHERE search-condition];`"
msgstr ""

msgid "Update zero or more existing rows in a table."
msgstr ""

msgid ""
"The *table-name* must be a name of a table defined earlier with "
":ref:`CREATE TABLE <sql_create_table>` or :ref:`CREATE VIEW "
"<sql_create_view>`."
msgstr ""

msgid "The *column-name* must be an updatable column in the table."
msgstr ""

msgid ""
"The *expression* may contain literals and operators and subqueries and "
"function invocations and column names."
msgstr ""

msgid "The values in the SET clause are evaluated from left to right."
msgstr ""

msgid ""
"If a *search-condition* is not specified, then all rows in the table will"
" be updated; otherwise only those rows which match the *search-condition*"
" will be updated."
msgstr ""

msgid ""
"Tarantool evaluates each expression in the SET clause, and returns an "
"error if any of the rules is violated. For each row that is found by the "
"WHERE clause, a temporary new row is formed based on the original "
"contents and the modifications caused by the SET clause."
msgstr ""

msgid ""
"Tarantool executes constraint checks and trigger actions and the actual "
"update."
msgstr ""

msgid ""
"-- the simplest form:\n"
"UPDATE t SET column1 = 1;\n"
"-- with more than one assignment in the SET clause:\n"
"UPDATE t SET column1 = 1, column2 = 2;\n"
"-- with a WHERE clause:\n"
"UPDATE t SET column1 = 5 WHERE column2 = 6;"
msgstr ""

msgid "Special cases:"
msgstr ""

msgid "It is legal to say SET (list of columns) = (list of values). For example:"
msgstr ""

msgid "UPDATE t SET (column1, column2, column3) = (1, 2, 3);"
msgstr ""

msgid "It is not legal to assign to a column more than once. For example:"
msgstr ""

msgid ""
"INSERT INTO t (column1) VALUES (0);\n"
"UPDATE t SET column1 = column1 + 1, column1 = column1 + 1;"
msgstr ""

msgid "The result is an error: \"duplicate column name\"."
msgstr ""

msgid "It is not legal to assign to a primary-key column."
msgstr ""

msgid "DELETE"
msgstr ""

msgid ":samp:`DELETE FROM {table-name} [WHERE search-condition];`"
msgstr ""

msgid "Delete zero or more existing rows in a table."
msgstr ""

msgid ""
"The *search-condition* may contain literals and operators and subqueries "
"and function invocations and column names."
msgstr ""

msgid ""
"If a search-condition is not specified, then all rows in the table will "
"be deleted; otherwise only those rows which match the *search-condition* "
"will be deleted."
msgstr ""

msgid ""
"Tarantool evaluates each expression in the *search-condition*, and "
"returns an error if any of the rules is violated."
msgstr ""

msgid "Tarantool finds the set of rows that are to be deleted."
msgstr ""

msgid ""
"Tarantool executes constraint checks and trigger actions and the actual "
"deletion."
msgstr ""

msgid ""
"-- the simplest form:\n"
"DELETE FROM t;\n"
"-- with a WHERE clause:\n"
"DELETE FROM t WHERE column2 = 6;"
msgstr ""

msgid "REPLACE"
msgstr ""

msgid ""
":samp:`REPLACE INTO {table-name} [(column-list)] VALUES (expression-list)"
" [, (expression-list)];`"
msgstr ""

msgid ":samp:`REPLACE INTO {table-name} [(column-list)] select-statement;`"
msgstr ""

msgid ":samp:`REPLACE INTO {table-name} DEFAULT VALUES;`"
msgstr ""

msgid "Insert one or more new rows into a table, or update existing rows."
msgstr ""

msgid ""
"If a row already exists (as determined by the primary key or any unique "
"key), then the action is delete + insert, and the rules are the same as "
"for a :ref:`DELETE statement <sql_delete>` followed by an :ref:`INSERT "
"statement <sql_insert>`. Otherwise the action is insert, and the rules "
"are the same as for the INSERT statement."
msgstr ""

msgid ""
"-- the simplest form:\n"
"REPLACE INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"REPLACE INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"REPLACE INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"REPLACE INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

msgid ""
"See also: :ref:`INSERT Statement <sql_insert>`, :ref:`UPDATE Statement "
"<sql_update>`."
msgstr ""

msgid "TRUNCATE"
msgstr ""

msgid ":samp:`TRUNCATE TABLE {table-name};`"
msgstr ""

msgid "Remove all rows in the table."
msgstr ""

msgid ""
"TRUNCATE is considered to be a schema-change rather than a data-change "
"statement, so it does not work within transactions (it cannot be "
":ref:`rolled back <sql_rollback>`)."
msgstr ""

msgid "It is illegal to truncate a table which is referenced by a foreign key."
msgstr ""

msgid ""
"It is illegal to truncate a table which is also a system space, such as "
"``_space``."
msgstr ""

msgid "The table must be a base table rather than a view."
msgstr ""

msgid ""
"All rows in the table are removed. Usually this is faster than "
":samp:`DELETE FROM {table-name};`."
msgstr ""

msgid ""
"If the table has an autoincrement primary key, its :doc:`sequence "
"</reference/reference_lua/box_schema_sequence/create_index>` is not reset"
" to zero, but that may occur in a future Tarantool version."
msgstr ""

msgid "There is no effect for any triggers associated with the table."
msgstr ""

msgid "There is no effect on the counts for the ``ROW_COUNT()`` function."
msgstr ""

msgid ""
"Only one action is written to the :ref:`write-ahead log <internals-wal>` "
"(with :samp:`DELETE FROM {table-name};` there would be one action for "
"each deleted row)."
msgstr ""

msgid "TRUNCATE TABLE t;"
msgstr ""

msgid "SET"
msgstr ""

msgid ":samp:`SET SESSION {setting-name} = {setting-value};`"
msgstr ""

msgid ""
"``SET SESSION`` is a shorthand way to update the "
":ref:`box.space._session_settings <box_space-session_settings>` temporary"
" system space."
msgstr ""

msgid ""
"``setting-name`` can be any one of ``\"error_marshaling_enabled\"``. "
"``\"sql_default_engine\"``. ``\"sql_defer_foreign_keys\"``, "
"``\"sql_full_column_names\"``, ``\"sql_full_metadata\"``, "
"``\"sql_parser_debug\"``, ``\"sql_recursive_triggers\"``, "
"``\"sql_reverse_unordered_selects\"``, ``\"sql_select_debug\"``, "
"``\"sql_vdbe_debug\"``. The quote marks are necessary."
msgstr ""

msgid ""
"If ``setting-name`` is ``\"sql_default_engine\"``, then ``setting-value``"
" can be either 'vinyl' or 'memtx'. Otherwise, ``setting-value`` can be "
"either TRUE or FALSE."
msgstr ""

msgid ""
"Example: ``SET SESSION \"sql_default_engine\" = 'vinyl';`` changes the "
"default engine to 'vinyl' instead of 'memtx', and returns:"
msgstr ""

msgid ""
"---\n"
"- row_count: 1\n"
"..."
msgstr ""

msgid ""
"It is functionally the same thing as an :ref:`UPDATE Statement "
"<sql_update>`:"
msgstr ""

msgid ""
"UPDATE \"_session_settings\"\n"
"SET \"value\" = 'vinyl'\n"
"WHERE \"name\" = 'sql_default_engine';"
msgstr ""

msgid "Statements that retrieve data"
msgstr ""

msgid "SELECT"
msgstr ""

msgid ""
":samp:`SELECT [ALL|DISTINCT] select list [from clause] [where clause] "
"[group-by clause] [having clause] [order-by clause];`"
msgstr ""

msgid "Select zero or more rows."
msgstr ""

msgid ""
"The clauses of the SELECT statement are discussed in the following five "
"sections."
msgstr ""

msgid "Select list"
msgstr ""

msgid ":samp:`select-list-column [, select-list-column ...]`"
msgstr ""

msgid "select-list-column:"
msgstr ""

msgid ""
"Define what will be in a result set; this is a clause in a :ref:`SELECT "
"statement <sql_select>`."
msgstr ""

msgid ""
"The *select list* is a comma-delimited list of expressions, or ``*`` "
"(asterisk). An expression can have an alias provided with an ``[[AS] "
"column-name]`` clause."
msgstr ""

msgid ""
"The ``*`` \"asterisk\" shorthand is valid if and only if the SELECT "
"statement also contains a :ref:`FROM clause <sql_from>` which specifies "
"the table or tables (details about the FROM clause are in the next "
"section). The simple form is ``*`` which means \"all columns\" -- for "
"example, if the select is done for a table which contains three columns "
"``s1`` ``s2`` ``s3``, then ``SELECT * ...`` is equivalent to ``SELECT s1,"
" s2, s3 ...``. The qualified form is ``table-name.*`` which means \"all "
"columns in the specified table\", which again must be a result of the "
"FROM clause -- for example, if the table is named ``table1``, then "
"``table1.*`` is equivalent to a list of the columns of ``table1``."
msgstr ""

msgid ""
"The ``[[AS] column-name]`` clause determines the column name. The column "
"name is useful for two reasons:"
msgstr ""

msgid "in a tabular display, the column names are the headings"
msgstr ""

msgid ""
"if the results of the SELECT are used when creating a new table (such as "
"a view), then the column names in the new table will be the column names "
"in the *select list*."
msgstr ""

msgid ""
"If ``[[AS] column-name]`` is missing, and the expression is not simply "
"the name of a column in the table, then Tarantool makes a name "
":samp:`COLUMN_{n}` where :samp:`{n}` is the number of the non-simple "
"expression within the select list, for example ``SELECT 5.88, table1.x, "
"'b' COLLATE \"unicode_ci\" FROM table1;`` will cause the column names to "
"be COLUMN_1, X, COLUMN_2. This is a behavior change in Tarantool 2.6, in "
"earlier versions the name would be equal to the expression, see "
"`Issue#3962 <https://github.com/tarantool/tarantool/issues/3962>`_. It is"
" still legal to define tables with column names like ``COLUMN_1`` but not"
" recommended."
msgstr ""

msgid ""
"-- the simple form:\n"
"SELECT 5;\n"
"-- with multiple expressions including operators:\n"
"SELECT 1, 2 * 2, 'Three' || 'Four';\n"
"-- with [[AS] column-name] clause:\n"
"SELECT 5 AS column1;\n"
"-- * which must be eventually followed by a FROM clause:\n"
"SELECT * FROM table1;\n"
"-- as a list:\n"
"SELECT 1 AS a, 2 AS b, table1.* FROM table1;"
msgstr ""

msgid "FROM clause"
msgstr ""

msgid ":samp:`FROM table-reference [, table-reference ...]`"
msgstr ""

msgid ""
"Specify the table or tables for the source of a :ref:`SELECT statement "
"<sql_select>`."
msgstr ""

msgid ""
"The *table-reference* must be a name of an existing table, or a subquery,"
" or a joined table."
msgstr ""

msgid "A joined table looks like this:"
msgstr ""

msgid ""
":samp:`table-reference-or-joined-table join-operator table-reference-or-"
"joined-table [join-specification]`"
msgstr ""

msgid ""
"A *join-operator* must be any of `the standard types "
"<https://en.wikipedia.org/wiki/Join_(SQL)>`_:"
msgstr ""

msgid "[NATURAL] LEFT [OUTER] JOIN,"
msgstr ""

msgid "[NATURAL] INNER JOIN, or"
msgstr ""

msgid "CROSS JOIN"
msgstr ""

msgid "A *join-specification* must be any of:"
msgstr ""

msgid "ON expression, or"
msgstr ""

msgid "USING (column-name [, column-name ...])"
msgstr ""

msgid "Parentheses are allowed, and ``[[AS] correlation-name]`` is allowed."
msgstr ""

msgid "The maximum number of joins in a FROM clause is 64."
msgstr ""

msgid ""
"-- the simplest form:\n"
"SELECT * FROM t;\n"
"-- with two tables, making a Cartesian join:\n"
"SELECT * FROM t1, t2;\n"
"-- with one table joined to itself, requiring correlation names:\n"
"SELECT a.*, b.* FROM t1 AS a, t1 AS b;\n"
"-- with a left outer join:\n"
"SELECT * FROM t1 LEFT JOIN t2;"
msgstr ""

msgid "WHERE clause"
msgstr ""

msgid ":samp:`WHERE condition;`"
msgstr ""

msgid ""
"Specify the condition for filtering rows from a table; this is a clause "
"in a :ref:`SELECT <sql_select>` or :ref:`UPDATE <sql_update>` or "
":ref:`DELETE <sql_delete>` statement."
msgstr ""

msgid ""
"The condition may contain any expression that returns a BOOLEAN (TRUE or "
"FALSE or UNKNOWN) value."
msgstr ""

msgid "For each row in the table:"
msgstr ""

msgid "if the condition is true, then the row is kept;"
msgstr ""

msgid "if the condition is false or unknown, then the row is ignored."
msgstr ""

msgid ""
"In effect, WHERE condition takes a table with n rows and returns a table "
"with n or fewer rows."
msgstr ""

msgid ""
"-- with a simple condition:\n"
"SELECT 1 FROM t WHERE column1 = 5;\n"
"-- with a condition that contains AND and OR and parentheses:\n"
"SELECT 1 FROM t WHERE column1 = 5 AND (x > 1 OR y < 1);"
msgstr ""

msgid "GROUP BY clause"
msgstr ""

msgid ":samp:`GROUP BY expression [, expression ...]`"
msgstr ""

msgid ""
"Make a grouped table; this is a clause in a :ref:`SELECT statement "
"<sql_select>`."
msgstr ""

msgid ""
"The expressions should be column names in the table, and each column "
"should be specified only once."
msgstr ""

msgid ""
"In effect, the GROUP BY clause takes a table with rows that may have "
"matching values, combines rows that have matching values into single "
"rows, and returns a table which, because it is the result of GROUP BY, is"
" called a grouped table."
msgstr ""

msgid "Thus, if the input is a table:"
msgstr ""

msgid ""
"a    b      c\n"
"-    -      -\n"
"1    'a'   'b\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'\n"
"1    'b'   'b'"
msgstr ""

msgid "then ``GROUP BY a, b`` will produce a grouped table:"
msgstr ""

msgid ""
"a    b      c\n"
"-    -      -\n"
"1    'a'   'b'\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'"
msgstr ""

msgid ""
"The rows where column ``a`` and column ``b`` have the same value have "
"been merged; column ``c`` has been preserved but its value should not be "
"depended on -- if the rows were not all 'b', Tarantool could pick any "
"value."
msgstr ""

msgid ""
"It is useful to envisage a grouped table as having hidden extra columns "
"for the aggregation of the values, for example:"
msgstr ""

msgid ""
"a    b      c    COUNT(a) SUM(a) MIN(c)\n"
"-    -      -    -------- ------ ------\n"
"1    'a'    'b'         2      2    'b'\n"
"1    'b'    'b'         1      1    'b'\n"
"2    'a'    'b'         1      2    'b'\n"
"     'a'    'b'         1      3    'b'"
msgstr ""

msgid ""
"These extra columns are what :ref:`aggregate functions <sql_aggregate>` "
"are for."
msgstr ""

msgid ""
"-- with a single column:\n"
"SELECT 1 FROM t GROUP BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t GROUP BY column1, column2;"
msgstr ""

msgid "``SELECT s1, s2 FROM t GROUP BY s1;`` is legal."
msgstr ""

msgid "``SELECT s1 AS q FROM t GROUP BY q;`` is legal."
msgstr ""

msgid "``SELECT s1 FROM t GROUP by 1;`` is legal."
msgstr ""

msgid "Aggregate functions"
msgstr ""

msgid ":samp:`function-name (one or more expressions)`"
msgstr ""

msgid ""
"Apply a built-in aggregate function to one or more expressions and return"
" a scalar value."
msgstr ""

msgid ""
"Aggregate functions are only legal in certain clauses of a :ref:`SELECT "
"statement <sql_select>` for grouped tables. (A table is a grouped table "
"if a GROUP BY clause is present.) Also, if an aggregate function is used "
"in a :ref:`select list <sql_select_list>` and the GROUP BY clause is "
"omitted, then Tarantool assumes ``SELECT ... GROUP BY [all columns];``."
msgstr ""

msgid "NULLs are ignored for all aggregate functions except COUNT(*)."
msgstr ""

msgid "``AVG([DISTINCT] expression)``"
msgstr ""

msgid "Return the average value of expression."
msgstr ""

msgid "Example: :samp:`AVG({column1})`"
msgstr ""

msgid "``COUNT([DISTINCT] expression)``"
msgstr ""

msgid "Return the number of occurrences of expression."
msgstr ""

msgid "Example: :samp:`COUNT({column1})`"
msgstr ""

msgid "``COUNT(*)``"
msgstr ""

msgid "Return the number of occurrences of a row."
msgstr ""

msgid "Example: :samp:`COUNT(*)`"
msgstr ""

msgid ""
"``GROUP_CONCAT(expression-1 [, expression-2])`` or "
"``GROUP_CONCAT(DISTINCT expression-1)``"
msgstr ""

msgid ""
"Return a list of *expression-1* values, separated by commas if "
"*expression-2* is omitted, or separated by the *expression-2* value if "
"*expression-2* is not omitted."
msgstr ""

msgid "Example: :samp:`GROUP_CONCAT({column1})`"
msgstr ""

msgid "``MAX([DISTINCT] expression)``"
msgstr ""

msgid "Return the maximum value of expression."
msgstr ""

msgid "Example: :samp:`MAX({column1})`"
msgstr ""

msgid "``MIN([DISTINCT] expression)``"
msgstr ""

msgid "Return the minimum value of expression."
msgstr ""

msgid "Example: :samp:`MIN({column1})`"
msgstr ""

msgid "``SUM([DISTINCT] expression)``"
msgstr ""

msgid "Return the sum of values of expression."
msgstr ""

msgid "Example: :samp:`SUM({column1})`"
msgstr ""

msgid "``TOTAL([DISTINCT] expression)``"
msgstr ""

msgid "Example: :samp:`TOTAL({column1})`"
msgstr ""

msgid "HAVING clause"
msgstr ""

msgid ":samp:`HAVING condition;`"
msgstr ""

msgid ""
"Specify the condition for filtering rows from a grouped table; this is a "
"clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

msgid ""
"The clause preceding the HAVING clause may be a GROUP BY clause. HAVING "
"operates on the table that the GROUP BY produces, which may contain "
"grouped columns and aggregates."
msgstr ""

msgid ""
"If the preceding clause is not a GROUP BY clause, then there is only one "
"group and the HAVING clause may only contain aggregate functions or "
"literals."
msgstr ""

msgid ""
"In effect, HAVING condition takes a table with n rows and returns a table"
" with n or fewer rows."
msgstr ""

msgid ""
"-- with a simple condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5;\n"
"-- with a more complicated condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5 OR column2 < 5;\n"
"-- with an aggregate:\n"
"SELECT x, SUM(y) FROM t GROUP BY x HAVING SUM(y) > 0;\n"
"-- with no GROUP BY and an aggregate:\n"
"SELECT SUM(y) FROM t GROUP BY x HAVING MIN(y) < MAX(y);"
msgstr ""

msgid "HAVING without GROUP BY is not supported for multiple tables."
msgstr ""

msgid "ORDER BY clause"
msgstr ""

msgid ":samp:`ORDER BY expression [ASC|DESC] [, expression [ASC|DESC] ...]`"
msgstr ""

msgid ""
"Put rows in order; this is a clause in a :ref:`SELECT statement "
"<sql_select>`."
msgstr ""

msgid "An ORDER BY expression has one of three types which are checked in order:"
msgstr ""

msgid ""
"Expression is a positive integer, representing the ordinal position of "
"the column in the :ref:`select list <sql_select_list>`. For example, in "
"the statement |br| ``SELECT x, y, z FROM t ORDER BY 2;`` |br| ``ORDER BY "
"2`` means \"order by the second column in the select list\", which is "
"``y``."
msgstr ""

msgid ""
"Expression is a name of a column in the select list, which is determined "
"by an AS clause. For example, in the statement |br| ``SELECT x, y AS x, z"
" FROM t ORDER BY x;`` |br| ``ORDER BY x`` means \"order by the column "
"explicitly named ``x`` in the select list\", which is the second column."
msgstr ""

msgid ""
"Expression contains a name of a column in a table of the FROM clause. For"
" example, in the statement |br| ``SELECT x, y FROM t1 JOIN t2 ORDER BY "
"z;`` |br| ``ORDER BY z`` means \"order by a column named ``z`` which is "
"expected to be in table ``t1`` or table ``t2``\"."
msgstr ""

msgid ""
"If both tables contain a column named ``z``, then Tarantool will choose "
"the first column that it finds."
msgstr ""

msgid ""
"The expression may also contain operators and function names and "
"literals. For example, in the statement |br| ``SELECT x, y FROM t ORDER "
"BY UPPER(z);`` |br| ``ORDER BY UPPER(z)`` means \"order by the uppercase "
"form of column ``t.z``\", which may be similar to doing ordering in a "
"case-insensitive manner."
msgstr ""

msgid ""
"Type 3 is illegal if the SELECT statement contains :ref:`UNION or EXCEPT "
"or INTERSECT <sql_union>`."
msgstr ""

msgid ""
"If an ORDER BY clause contains multiple expressions, then expressions on "
"the left are processed first and expressions on the right are processed "
"only if necessary for tie-breaking. For example, in the statement |br| "
"``SELECT x, y FROM t ORDER BY x, y;`` if there are two rows which both "
"have the same values for column ``x``, then an additional check is made "
"to see which row has a greater value for column ``y``."
msgstr ""

msgid ""
"In effect, ORDER BY clause takes a table with rows that may be out of "
"order, and returns a table with rows in order."
msgstr ""

msgid "Sorting order:"
msgstr ""

msgid ""
"The default order is ASC (ascending), the optional order is DESC "
"(descending)."
msgstr ""

msgid ""
"NULLs come first, then BOOLEANs, then numbers, then STRINGs, then "
"VARBINARYs."
msgstr ""

msgid "Within STRINGs, ordering is according to collation."
msgstr ""

msgid ""
"Collation may be specified with a :ref:`COLLATE clause "
"<sql_collate_clause>` within the ORDER BY column-list, or may be default."
msgstr ""

msgid ""
"-- with a single column:\n"
"SELECT 1 FROM t ORDER BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t ORDER BY column1, column2;\n"
"-- with a variety of data:\n"
"CREATE TABLE h (s1 NUMBER PRIMARY KEY, s2 SCALAR);\n"
"INSERT INTO h VALUES (7, 'A'), (4, 'a'), (-4, 'AZ'), (17, 17), (23, "
"NULL);\n"
"INSERT INTO h VALUES (17.5, 'Д'), (1e+300, 'A'), (0, ''), (-1, '');\n"
"SELECT * FROM h ORDER BY s2 COLLATE \"unicode_ci\", s1;\n"
"-- The result of the above SELECT will be:\n"
"- - [23, null]\n"
"  - [17, 17]\n"
"  - [-1, '']\n"
"  - [0, '']\n"
"  - [4, 'a']\n"
"  - [7, 'A']\n"
"  - [1e+300, 'A']\n"
"  - [-4, 'AZ']\n"
"  - [17.5, 'Д']\n"
"..."
msgstr ""

msgid "ORDER BY 1 is legal. This is common but is not standard SQL nowadays."
msgstr ""

msgid "LIMIT clause"
msgstr ""

msgid ":samp:`LIMIT limit-expression [OFFSET offset-expression]`"
msgstr ""

msgid ":samp:`LIMIT offset-expression, limit-expression`"
msgstr ""

msgid ""
"The above is not a typo: *offset-expression* and *limit-expression* are "
"in reverse order if a comma is used."
msgstr ""

msgid ""
"Specify a maximum number of rows and a start row; this is a clause in a "
":ref:`SELECT statement <sql_select>`."
msgstr ""

msgid ""
"Expressions may contain integers and arithmetic operators or functions, "
"for example ``ABS(-3 / 1)``. However, the result must be an integer value"
" greater than or equal to zero."
msgstr ""

msgid ""
"Usually the LIMIT clause follows an :ref:`ORDER BY clause "
"<sql_order_by>`, because otherwise Tarantool does not guarantee that rows"
" are in order."
msgstr ""

msgid ""
"-- simple case:\n"
"SELECT * FROM t LIMIT 3;\n"
"-- both limit and order:\n"
"SELECT * FROM t LIMIT 3 OFFSET 1;\n"
"-- applied to a UNIONed result (LIMIT clause must be the final clause):\n"
"SELECT column1 FROM table1 UNION SELECT column1 FROM table2 ORDER BY 1 "
"LIMIT 1;"
msgstr ""

msgid ""
"If ORDER BY ... LIMIT is used, then all order-by columns must be ASC or "
"all must be DESC."
msgstr ""

msgid "Subquery"
msgstr ""

msgid ":ref:`SELECT-statement <sql_select>` syntax"
msgstr ""

msgid ":ref:`VALUES-statement <sql_values>` syntax"
msgstr ""

msgid ""
"A subquery has the same syntax as a :ref:`SELECT statement <sql_select>` "
"or :ref:`VALUES statement <sql_values>` embedded inside a main statement."
msgstr ""

msgid ""
"The SELECT and VALUES statements are called \"queries\" because they "
"return answers, in the form of result sets."
msgstr ""

msgid ""
"Subqueries may be the second part of :ref:`INSERT statements "
"<sql_insert>`. For example:"
msgstr ""

msgid "INSERT INTO t2 SELECT a, b, c FROM t1;"
msgstr ""

msgid ""
"Subqueries may be in the :ref:`FROM clause <sql_from>` of SELECT "
"statements."
msgstr ""

msgid ""
"Subqueries may be expressions, or be inside expressions. In this case "
"they must be parenthesized, and usually the number of rows must be 1. For"
" example:"
msgstr ""

msgid "SELECT 1, (SELECT 5), 3 FROM t WHERE c1 * (SELECT COUNT(*) FROM t2) > 5;"
msgstr ""

msgid ""
"Subqueries may be expressions on the right side of certain comparison "
"operators, and in this unusual case the number of rows may be greater "
"than 1. The comparison operators are: [NOT] EXISTS and [NOT] IN. For "
"example:"
msgstr ""

msgid "DELETE FROM t WHERE s1 NOT IN (SELECT s2 FROM t);"
msgstr ""

msgid ""
"Subqueries may refer to values in the outer query. In this case, the "
"subquery is called a \"correlated subquery\"."
msgstr ""

msgid ""
"Subqueries may refer to rows which are being updated or deleted by the "
"main query. In that case, the subquery finds the matching rows first, "
"before starting to update or delete. For example, after:"
msgstr ""

msgid ""
"CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"INSERT INTO t VALUES (1, 3), (2, 1);\n"
"DELETE FROM t WHERE s2 NOT IN (SELECT s1 FROM t);"
msgstr ""

msgid "only one of the rows is deleted, not both rows."
msgstr ""

msgid "WITH clause"
msgstr ""

msgid "**WITH clause (common table expression)**"
msgstr ""

msgid ""
":samp:`WITH {temporary-table-name} AS (subquery)` |br| :samp:`[, "
"{temporary-table-name} AS (subquery)]` |br| :samp:`SELECT statement | "
"INSERT statement | DELETE statement | UPDATE statement | REPLACE "
"statement;`"
msgstr ""

msgid "WITH v AS (SELECT * FROM t) SELECT * FROM v;"
msgstr ""

msgid ""
"is equivalent to :ref:`creating a view <sql_create_view>` and selecting "
"from it:"
msgstr ""

msgid ""
"CREATE VIEW v AS SELECT * FROM t;\n"
"SELECT * FROM v;"
msgstr ""

msgid ""
"The difference is that a WITH-clause \"view\" is temporary and only "
"useful within the same statement. No CREATE privilege is required."
msgstr ""

msgid ""
"The WITH-clause can also be thought of as a :ref:`subquery "
"<sql_subquery>` that has a name. This is useful when the same subquery is"
" being repeated. For example:"
msgstr ""

msgid "SELECT * FROM t WHERE a < (SELECT s1 FROM x) AND b < (SELECT s1 FROM x);"
msgstr ""

msgid "can be replaced with:"
msgstr ""

msgid ""
"WITH s AS (SELECT s1 FROM x) SELECT * FROM t,s WHERE a < s.s1 AND b < "
"s.s1;"
msgstr ""

msgid ""
"This \"factoring out\" of a repeated expression is regarded as good "
"practice."
msgstr ""

msgid ""
"WITH cte AS (VALUES (7, '') INSERT INTO j SELECT * FROM cte;\n"
"WITH cte AS (SELECT s1 AS x FROM k) SELECT * FROM cte;\n"
"WITH cte AS (SELECT COUNT(*) FROM k WHERE s2 < 'x' GROUP BY s3)\n"
"  UPDATE j SET s2 = 5\n"
"  WHERE s1 = (SELECT s1 FROM cte) OR s3 = (SELECT s1 FROM cte);"
msgstr ""

msgid ""
"WITH can only be used at the beginning of a statement, therefore it "
"cannot be used at the beginning of a subquery or after a :ref:`set "
"operator <sql_union>` or inside a CREATE statement."
msgstr ""

msgid ""
"A WITH-clause \"view\" is read-only because Tarantool does not support "
"updatable views."
msgstr ""

msgid "WITH RECURSIVE"
msgstr ""

msgid "**WITH RECURSIVE clause (iterative common table expression)**"
msgstr ""

msgid ""
"The real power of WITH lies in the WITH RECURSIVE clause, which is useful"
" when it is combined with :ref:`UNION or UNION ALL <sql_union>`:"
msgstr ""

msgid ""
":samp:`WITH RECURSIVE recursive-table-name AS` |br| :samp:`(SELECT ... "
"FROM non-recursive-table-name ...` |br| :samp:`UNION [ALL]` |br| "
":samp:`SELECT ... FROM recursive-table-name ...)` |br| :samp:`statement-"
"that-uses-recursive-table-name;` |br|"
msgstr ""

msgid ""
"In non-SQL this can be read as: starting with a seed value from a non-"
"recursive table, produce a recursive viewed table, UNION that with "
"itself, UNION that with itself, UNION that with itself ... forever, or "
"until a condition in the WHERE clause says \"stop\"."
msgstr ""

msgid ""
"CREATE TABLE ts (s1 INTEGER PRIMARY KEY);\n"
"INSERT INTO ts VALUES (1);\n"
"WITH RECURSIVE w AS (\n"
"  SELECT s1 FROM ts\n"
"  UNION ALL\n"
"  SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
"SELECT * FROM w;"
msgstr ""

msgid "First, table ``w`` is seeded from ``t1``, so it has one row: [1]."
msgstr ""

msgid ""
"Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- "
"which contains [1] -- adds 1 because the select list says \"s1+1\", and "
"so it has one row: [2]."
msgstr ""

msgid ""
"Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- "
"which contains [2] -- adds 1 because the select list says \"s1+1\", and "
"so it has one row: [3]."
msgstr ""

msgid ""
"Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- "
"which contains [3] -- adds 1 because the select list says \"s1+1\", and "
"so it has one row: [4]."
msgstr ""

msgid ""
"Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- "
"which contains [4] -- and now the importance of the WHERE clause becomes "
"evident, because \"s1 < 4\" is false for this row, and therefore we have "
"reached the \"stop\" condition."
msgstr ""

msgid ""
"So, before the \"stop\", table ``w`` got 4 rows -- [1], [2], [3], [4] -- "
"and the result of the statement looks like:"
msgstr ""

msgid ""
"tarantool> WITH RECURSIVE w AS (\n"
"         >   SELECT s1 FROM ts\n"
"         >   UNION ALL\n"
"         >   SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
"         > SELECT * FROM w;\n"
"---\n"
"- - [1]\n"
"  - [2]\n"
"  - [3]\n"
"  - [4]\n"
"..."
msgstr ""

msgid ""
"In other words, this ``WITH RECURSIVE ... SELECT`` produces a table of "
"auto-incrementing values."
msgstr ""

msgid "UNION, EXCEPT, and INTERSECT clauses"
msgstr ""

msgid ""
":samp:`select-statement UNION [ALL] select-statement [ORDER BY clause] "
"[LIMIT clause];`"
msgstr ""

msgid ""
":samp:`select-statement EXCEPT select-statement [ORDER BY clause] [LIMIT "
"clause];`"
msgstr ""

msgid ""
":samp:`select-statement INTERSECT select-statement [ORDER BY clause] "
"[LIMIT clause];`"
msgstr ""

msgid ""
"UNION, EXCEPT, and INTERSECT are collectively called \"set operators\" or"
" \"table operators\". In particular:"
msgstr ""

msgid "``a UNION b`` means \"take rows which occur in a OR b\"."
msgstr ""

msgid "``a EXCEPT b`` means \"take rows which occur in a AND NOT b\"."
msgstr ""

msgid "``a INTERSECT b`` means \"take rows which occur in a AND b\"."
msgstr ""

msgid "Duplicate rows are eliminated unless ALL is specified."
msgstr ""

msgid ""
"The *select-statements* may be chained: ``SELECT ... SELECT ... SELECT "
"...;``"
msgstr ""

msgid "Each *select-statement* must result in the same number of columns."
msgstr ""

msgid ""
"The *select-statements* may be replaced with :ref:`VALUES statements "
"<sql_values>`."
msgstr ""

msgid "The maximum number of set operations is 50."
msgstr ""

msgid ""
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t2 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, NULL);\n"
"INSERT INTO t2 VALUES (1, 'A'), (2, 'C'), (3,NULL);\n"
"SELECT s2 FROM t1 UNION SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 UNION ALL SELECT s2 FROM t2 ORDER BY s2;\n"
"SELECT s2 FROM t1 EXCEPT SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 INTERSECT SELECT s2 FROM t2;"
msgstr ""

msgid "In this example:"
msgstr ""

msgid "The UNION query returns 4 rows: NULL, 'A', 'B', 'C'."
msgstr ""

msgid "The UNION ALL query returns 6 rows: NULL, NULL, 'A', 'A', 'B', 'C'."
msgstr ""

msgid "The EXCEPT query returns 1 row: 'B'."
msgstr ""

msgid "The INTERSECT query returns 2 rows: NULL, 'A'."
msgstr ""

msgid "Parentheses are not allowed."
msgstr ""

msgid "Evaluation is left to right, INTERSECT does not have precedence."
msgstr ""

msgid ""
"CREATE TABLE t01 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t02 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t03 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"INSERT INTO t01 VALUES (1, 'A');\n"
"INSERT INTO t02 VALUES (1, 'B');\n"
"INSERT INTO t03 VALUES (1, 'A');\n"
"SELECT s2 FROM t01 INTERSECT SELECT s2 FROM t03 UNION SELECT s2 FROM t02;"
"\n"
"SELECT s2 FROM t03 UNION SELECT s2 FROM t02 INTERSECT SELECT s2 FROM t03;"
"\n"
"-- ... results are different."
msgstr ""

msgid "INDEXED BY clause"
msgstr ""

msgid ":samp:`INDEXED BY {index-name}`"
msgstr ""

msgid ""
"The INDEXED BY clause may be used in a :ref:`SELECT <sql_select>`, "
":ref:`DELETE <sql_delete>`, or :ref:`UPDATE <sql_update>` statement, "
"immediately after the *table-name*. For example:"
msgstr ""

msgid "DELETE FROM table7 INDEXED BY index7 WHERE column1 = 'a';"
msgstr ""

msgid ""
"In this case the search for 'a' will take place within ``index7``. For "
"example:"
msgstr ""

msgid "SELECT * FROM table7 NOT INDEXED WHERE column1 = 'a';"
msgstr ""

msgid ""
"In this case the search for 'a' will be done via a search of the whole "
"table, what is sometimes called a \"full table scan\", even if there is "
"an index for ``column1``."
msgstr ""

msgid ""
"Ordinarily Tarantool chooses the appropriate index or lookup method "
"depending on a complex set of \"optimizer\" rules; the INDEXED BY clause "
"overrides the optimizer choice."
msgstr ""

msgid "Suppose a table has two columns:"
msgstr ""

msgid ""
"The first column is the primary key and therefore it has an automatic "
"index named ``pk_unnamed_T_1``."
msgstr ""

msgid "The second column has an index created by the user."
msgstr ""

msgid ""
"The user selects with ``INDEXED BY the-index-on-column1``, then selects "
"with ``INDEXED BY the-index-on-column-2``."
msgstr ""

msgid ""
"CREATE TABLE t (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
"CREATE INDEX idx_column2_t_1 ON t (column2);\n"
"INSERT INTO t VALUES (1, 2), (2, 1);\n"
"SELECT * FROM t INDEXED BY \"pk_unnamed_T_1\";\n"
"SELECT * FROM t INDEXED BY idx_column2_t_1;\n"
"-- Result for the first select: (1, 2), (2, 1)\n"
"-- Result for the second select: (2, 1), (1, 2)."
msgstr ""

msgid ""
"Limitations: |br| Often INDEXED BY has no effect. |br| Often INDEXED BY "
"affects a choice of covering index, but not a WHERE clause."
msgstr ""

msgid "VALUES"
msgstr ""

msgid ""
":samp:`VALUES (expression [, expression ...]) [, (expression [, "
"expression ...])`"
msgstr ""

msgid "Select one or more rows."
msgstr ""

msgid ""
"VALUES has the same effect as :ref:`SELECT <sql_select>`, that is, it "
"returns a result set, but VALUES statements may not have FROM or GROUP or"
" ORDER BY or LIMIT clauses."
msgstr ""

msgid ""
"VALUES may be used wherever SELECT may be used, for example in "
":ref:`subqueries <sql_subquery>`."
msgstr ""

msgid ""
"-- simple case:\n"
"VALUES (1);\n"
"-- equivalent to SELECT 1, 2, 3:\n"
"VALUES (1, 2, 3);\n"
"-- two rows:\n"
"VALUES (1, 2, 3), (4, 5, 6);"
msgstr ""

msgid "PRAGMA"
msgstr ""

msgid ":samp:`PRAGMA {pragma-name} (pragma-value);`"
msgstr ""

msgid "or :samp:`PRAGMA {pragma-name};`"
msgstr ""

msgid ""
"PRAGMA statements will give rudimentary information about database "
"'metadata' or server performance, although it is better to get metadata "
"via :ref:`system tables <sql_system_tables>`."
msgstr ""

msgid ""
"For PRAGMA statements that include (``pragma-value``), pragma values are "
"strings and can be specified inside ``\"\"`` double quotes, or without "
"quotes. When a string is used for searching, results must match according"
" to a binary collation. If the object being searched has a lower-case "
"name, use double quotes."
msgstr ""

msgid ""
"In an earlier version, there were some PRAGMA statements that determined "
"behavior. Now that does not happen. Behavior change is done by updating "
"the :ref:`box.space._session_settings <box_space-session_settings>` "
"system table."
msgstr ""

msgid "Pragma"
msgstr ""

msgid "Parameter"
msgstr ""

msgid "Effect"
msgstr ""

msgid "foreign_key_list"
msgstr ""

msgid "string |br| table-name"
msgstr ""

msgid ""
"Return a :ref:`result set <box-sql_result_sets>` with one row for each "
"foreign key of \"table-name\". Each row contains: |br| (INTEGER) id -- "
"identification number |br| (INTEGER) seq -- sequential number |br| "
"(STRING) table -- name of table |br| (STRING) from  -- referencing key "
"|br| (STRING) to -- referenced key |br| (STRING) on_update -- ON UPDATE "
"clause |br| (STRING) on_delete -- ON DELETE clause |br| (STRING) match --"
" MATCH clause |br| The system table is ``\"_fk_constraint\"``."
msgstr ""

msgid "collation_list"
msgstr ""

msgid ""
"Return a result set with one row for each supported collation. The first "
"four collations are ``'none'`` and ``'unicode'`` and ``'unicode_ci'`` and"
" ``'binary'``, then come about 270 predefined collations, the exact count"
" may vary because users can add their own collations. |br| The system "
"table is ``\"_collation\"``."
msgstr ""

msgid "index_info"
msgstr ""

msgid "string |br| table-name . index-name"
msgstr ""

msgid ""
"Return a result set with one row for each column in \"table-name.index-"
"name\". Each row contains: |br| (INTEGER) seqno -- the column's ordinal "
"position in the index (first column is 0) |br| (INTEGER) cid -- the "
"column's ordinal position in the table (first column is 0) |br| (STRING) "
"name -- name of the column |br| (INTEGER) desc -- 0 if ASC, 1 if DESC "
"|br| (STRING) collation name |br| (STRING) type -- data type |br|"
msgstr ""

msgid "index_list"
msgstr ""

msgid ""
"Return a result set with one row for each index of \"table-name\". Each "
"row contains: |br| (INTEGER) seq -- sequential number |br| (STRING) name "
"-- index name |br| (INTEGER) unique -- whether the index is unique, 0 = "
"false, 1 = true |br| The system table is ``\"_index\"``."
msgstr ""

msgid "stats"
msgstr ""

msgid ""
"Return a result set with one row for each index of each table. Each row "
"contains: |br| (STRING) table -- name of the table |br| (STRING) index --"
" name of the index |br| (INTEGER) width -- arbitrary information |br| "
"(INTEGER) height -- arbitrary information"
msgstr ""

msgid "table_info"
msgstr ""

msgid ""
"Return a result set with one row for each column in \"table-name\". Each "
"row contains: |br| (INTEGER) cid -- ordinal position in the table |br| "
"(first column number is 0) |br| (STRING) name -- column name |br| "
"(INTEGER) notnull -- whether the column is NOT NULL. 0 is false, 1 is "
"true. |br| (STRING) dflt_value -- default value |br| (INTEGER) pk -- "
"whether the column is a PRIMARY KEY column. 0 is false, 1 is true."
msgstr ""

msgid "Example: (not showing result set metadata)"
msgstr ""

msgid ""
"PRAGMA table_info('T');\n"
"---\n"
"- - [0, 's1', 'integer', 1, null, 1]\n"
"  - [1, 's2', 'integer', 0, null, 0]\n"
"..."
msgstr ""

msgid "EXPLAIN"
msgstr ""

msgid ":samp:`EXPLAIN explainable-statement;`"
msgstr ""

msgid ""
"EXPLAIN will show what steps Tarantool would take if it executed "
"explainable-statement. This is primarily a debugging and optimization aid"
" for the Tarantool team."
msgstr ""

msgid "Example: ``EXPLAIN DELETE FROM m;`` returns:"
msgstr ""

msgid ""
"- - [0, 'Init', 0, 3, 0, '', '00', 'Start at 3']\n"
"  - [1, 'Clear', 16416, 0, 0, '', '00', '']\n"
"  - [2, 'Halt', 0, 0, 0, '', '00', '']\n"
"  - [3, 'Transaction', 0, 1, 1, '0', '01', 'usesStmtJournal=0']\n"
"  - [4, 'Goto', 0, 1, 0, '', '00', '']"
msgstr ""

msgid "Variation: ``EXPLAIN QUERY PLAN statement;`` shows the steps of a search."
msgstr ""

msgid "Statements for transactions"
msgstr ""

msgid "START TRANSACTION"
msgstr ""

msgid ":samp:`START TRANSACTION;`"
msgstr ""

msgid ""
"Start a transaction. After ``START TRANSACTION;``, a transaction is "
"\"active\". If a transaction is already active, then ``START "
"TRANSACTION;`` is illegal."
msgstr ""

msgid ""
"Transactions should be active for fairly short periods of time, to avoid "
"concurrency issues. To end a transaction, say :ref:`COMMIT; <sql_commit>`"
" or :ref:`ROLLBACK; <sql_rollback>`."
msgstr ""

msgid ""
"Just as in NoSQL, transaction control statements are subject to "
"limitations set by the :ref:`storage engine <engines-chapter>` involved: "
"|br| * For the memtx storage engine, if a yield happens within an active "
"transaction, the transaction is rolled back. |br| * For the vinyl engine,"
" yields are allowed. |br| Also, although CREATE AND DROP and ALTER "
"statements are legal in transactions, there are a few exceptions. For "
"example, :samp:`CREATE INDEX ON {table_name} ...` will fail within a "
"multi-statement transaction if the table is not empty."
msgstr ""

msgid ""
"However,transaction control statements still may not work as you expect "
"when run over a network connection: a transaction is associated with a "
"fiber, not a network connection, and different transaction control "
"statements sent via the same network connection may be executed by "
"different fibers from the fiber pool."
msgstr ""

msgid ""
"In order to ensure that all statements are part of the intended "
"transaction, put all of them between ``START TRANSACTION;`` and "
"``COMMIT;`` or ``ROLLBACK;`` then send as a single batch. For example:"
msgstr ""

msgid ""
"Enclose each separate SQL statement in a :ref:`box.execute() <box-"
"sql_box_execute>` function."
msgstr ""

msgid ""
"Pass all the ``box.execute()`` functions to the server in a single "
"message."
msgstr ""

msgid ""
"If you are using a console, you can do this by writing everything on a "
"single line."
msgstr ""

msgid ""
"If you are using :ref:`net.box <net_box-module>`, you can do this by "
"putting all the function calls in a single string and calling "
":ref:`eval(string) <net_box-eval>`."
msgstr ""

msgid "START TRANSACTION;"
msgstr ""

msgid ""
"Example of a whole transaction sent to a server on ``localhost:3301`` "
"with ``eval(string)``:"
msgstr ""

msgid ""
"net_box = require('net.box')\n"
"conn = net_box.new('localhost', 3301)\n"
"s = 'box.execute([[START TRANSACTION;]]) '\n"
"s = s .. 'box.execute([[INSERT INTO t VALUES (1);]]) '\n"
"s = s .. 'box.execute([[ROLLBACK;]]) '\n"
"conn:eval(s)"
msgstr ""

msgid "COMMIT"
msgstr ""

msgid ":samp:`COMMIT;`"
msgstr ""

msgid ""
"Commit an active transaction, so all changes are made permanent and the "
"transaction ends."
msgstr ""

msgid ""
"COMMIT is illegal unless a transaction is active. If a transaction is not"
" active then SQL statements are committed automatically."
msgstr ""

msgid "COMMIT;"
msgstr ""

msgid "SAVEPOINT"
msgstr ""

msgid ":samp:`SAVEPOINT {savepoint-name};`"
msgstr ""

msgid ""
"Set a savepoint, so that :ref:`ROLLBACK TO savepoint-name <sql_rollback>`"
" is possible."
msgstr ""

msgid "SAVEPOINT is illegal unless a transaction is active."
msgstr ""

msgid ""
"If a savepoint with the same name already exists, it is released before "
"the new savepoint is set."
msgstr ""

msgid "SAVEPOINT x;"
msgstr ""

msgid "RELEASE SAVEPOINT"
msgstr ""

msgid ":samp:`RELEASE SAVEPOINT {savepoint-name};`"
msgstr ""

msgid ""
"Release (destroy) a savepoint created by a :ref:`SAVEPOINT statement "
"<sql_savepoint>`."
msgstr ""

msgid "RELEASE is illegal unless a transaction is active."
msgstr ""

msgid "Savepoints are released automatically when a transaction ends."
msgstr ""

msgid "RELEASE SAVEPOINT x;"
msgstr ""

msgid "ROLLBACK"
msgstr ""

msgid ":samp:`ROLLBACK [TO [SAVEPOINT] {savepoint-name}];`"
msgstr ""

msgid ""
"If ROLLBACK does not specify a *savepoint-name*, rollback an active "
"transaction, so all changes since :ref:`START TRANSACTION "
"<sql_start_transaction>` are cancelled, and the transaction ends."
msgstr ""

msgid ""
"If ROLLBACK does specify a *savepoint-name*, rollback an active "
"transaction, so all changes since :ref:`SAVEPOINT savepoint-name "
"<sql_savepoint>` are cancelled, and the transaction does not end."
msgstr ""

msgid "ROLLBACK is illegal unless a transaction is active."
msgstr ""

msgid ""
"-- the simple form:\n"
"ROLLBACK;\n"
"-- the form so changes before a savepoint are not cancelled:\n"
"ROLLBACK TO SAVEPOINT x;"
msgstr ""

msgid ""
"-- An example of a Lua function that will do a transaction\n"
"-- containing savepoint and rollback to savepoint.\n"
"function f()\n"
"box.execute([[DROP TABLE IF EXISTS t;]]) -- commits automatically\n"
"box.execute([[CREATE TABLE t (s1 STRING PRIMARY KEY);]]) -- commits "
"automatically\n"
"box.execute([[START TRANSACTION;]]) -- after this succeeds, a transaction"
" is active\n"
"box.execute([[INSERT INTO t VALUES ('Data change #1');]])\n"
"box.execute([[SAVEPOINT \"1\";]])\n"
"box.execute([[INSERT INTO t VALUES ('Data change #2');]])\n"
"box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) -- rollback Data change #2\n"
"box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) -- this is legal but does "
"nothing\n"
"box.execute([[COMMIT;]]) -- make Data change #1 permanent, end the "
"transaction\n"
"end"
msgstr ""

msgid "Functions"
msgstr ""

msgid "Explanation of functions"
msgstr ""

msgid ""
"Apply a built-in function to one or more expressions and return a scalar "
"value."
msgstr ""

msgid "Tarantool supports 32 built-in functions."
msgstr ""

msgid "The maximum number of operands for any function is 127."
msgstr ""

msgid ""
"The required privileges for built-in functions will likely change in a "
"future version."
msgstr ""

msgid "List of functions"
msgstr ""

msgid "ABS"
msgstr ""

msgid ":samp:`ABS({numeric-expression})`"
msgstr ""

msgid ""
"Return the absolute value of numeric-expression, which can be any numeric"
" type."
msgstr ""

msgid "Example: ``ABS(-1)`` is 1."
msgstr ""

msgid "CAST"
msgstr ""

msgid ":samp:`CAST({expression} AS {data-type})`"
msgstr ""

msgid ""
"Return the expression value after casting to the specified :ref:`data "
"type <sql_column_def_data_type>`."
msgstr ""

msgid "Examples: ``CAST('AB' AS VARBINARY)``, ``CAST(X'4142' AS STRING)``"
msgstr ""

msgid "CHAR"
msgstr ""

msgid ":samp:`CHAR([numeric-expression [,numeric-expression...])`"
msgstr ""

msgid ""
"Return the characters whose Unicode code point values are equal to the "
"numeric expressions."
msgstr ""

msgid "Short example:"
msgstr ""

msgid ""
"The first 128 Unicode characters are the \"ASCII\" characters, so "
"CHAR(65, 66, 67) is 'ABC'."
msgstr ""

msgid "Long example:"
msgstr ""

msgid ""
"For the current list of Unicode characters, in order by code point, see "
"`www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt "
"<http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt>`_. In that"
" list, there is a line for a Linear B ideogram"
msgstr ""

msgid "``100CC;LINEAR B IDEOGRAM B240 WHEELED CHARIOT ...``"
msgstr ""

msgid ""
"Therefore, for a string with a chariot in the middle, use the "
"concatenation operator ``||`` and the CHAR function"
msgstr ""

msgid "``'start of string ' || CHAR(0X100CC) || ' end of string'``."
msgstr ""

msgid "COALESCE"
msgstr ""

msgid ":samp:`COALESCE(expression, expression [, expression ...])`"
msgstr ""

msgid ""
"Return the value of the first non-NULL expression, or, if all expression "
"values are NULL, return NULL."
msgstr ""

msgid "``COALESCE(NULL, 17, 32)`` is 17."
msgstr ""

msgid "GREATEST"
msgstr ""

msgid ":samp:`GREATEST({expression-1}, {expression-2}, [{expression-3} ...])`"
msgstr ""

msgid ""
"Return the greatest value of the supplied expressions, or, if any "
"expression is NULL, return NULL. The reverse of ``GREATEST`` is "
":ref:`LEAST <sql_function_least>`."
msgstr ""

msgid ""
"Examples: ``GREATEST(7, 44, -1)`` is 44; ``GREATEST(1E308, 'a', 0, "
"X'00')`` is '\\0' = the nul character; ``GREATEST(3, NULL, 2)`` is NULL"
msgstr ""

msgid "HEX"
msgstr ""

msgid ":samp:`HEX(expression)`"
msgstr ""

msgid ""
"Return the hexadecimal code for each byte in **expression**, which may be"
" either a string or a byte sequence. For ASCII characters, this is "
"straightforward because the encoding is the same as the code point value."
" For non-ASCII characters, since character strings are usually encoded in"
" UTF-8, each character will require two or more bytes."
msgstr ""

msgid "``HEX('A')`` will return ``41``."
msgstr ""

msgid "``HEX('Д')`` will return ``D094``."
msgstr ""

msgid "IFNULL"
msgstr ""

msgid ":samp:`IFNULL(expression, expression)`"
msgstr ""

msgid ""
"Return the value of the first non-NULL expression, or, if both expression"
" values are NULL, return NULL. Thus ``IFNULL(expression, expression)`` is"
" the same as :ref:`COALESCE(expression, expression) "
"<sql_function_coalesce>`."
msgstr ""

msgid "``IFNULL(NULL, 17)`` is 17"
msgstr ""

msgid "LEAST"
msgstr ""

msgid ":samp:`LEAST({expression-1}, {expression-2}, [{expression-3} ...])`"
msgstr ""

msgid ""
"Return the least value of the supplied expressions, or, if any expression"
" is NULL, return NULL. The reverse of ``LEAST`` is :ref:`GREATEST "
"<sql_function_greatest>`."
msgstr ""

msgid ""
"Examples: ``LEAST(7, 44, -1)`` is -1; ``LEAST(1E308, 'a', 0, X'00')`` is "
"0; ``LEAST(3, NULL, 2)`` is NULL."
msgstr ""

msgid "LENGTH"
msgstr ""

msgid ":samp:`LENGTH(expression)`"
msgstr ""

msgid ""
"Return the number of characters in the **expression**, or the number of "
"bytes in the **expression**. It depends on the data type: strings with "
"data type STRING are counted in characters, byte sequences with data type"
" VARBINARY are counted in bytes and are not ended by the nul character. "
"There are two aliases for ``LENGTH(expression)`` -- "
"``CHAR_LENGTH(expression)`` and ``CHARACTER_LENGTH(expression)`` do the "
"same thing."
msgstr ""

msgid "``LENGTH('ДД')`` is 2, the string has 2 characters."
msgstr ""

msgid "``LENGTH(CAST('ДД' AS VARBINARY))`` is 4, the string has 4 bytes."
msgstr ""

msgid "``LENGTH(CHAR(0, 65))`` is 2, '\\0' does not mean 'end of string'."
msgstr ""

msgid "``LENGTH(X'410041')`` is 3, X'...' byte sequences have type VARBINARY."
msgstr ""

msgid "LIKELIHOOD"
msgstr ""

msgid ":samp:`LIKELIHOOD({expression}, {number literal})`"
msgstr ""

msgid ""
"Return the result of the expression, provided that the number literal is "
"between 0.0 and 1.0."
msgstr ""

msgid "Example: ``LIKELIHOOD('a' = 'b', .0)`` is FALSE"
msgstr ""

msgid "LIKELY"
msgstr ""

msgid ":samp:`LIKELY({expression})`"
msgstr ""

msgid "Return TRUE if the expression is probably true."
msgstr ""

msgid "Example: ``LIKELY('a' <= 'b')`` is TRUE"
msgstr ""

msgid "LOWER"
msgstr ""

msgid ":samp:`LOWER({string-expression})`"
msgstr ""

msgid ""
"Return the expression, with upper-case characters converted to lower "
"case. The reverse of ``LOWER`` is :ref:`UPPER <sql_function_upper>`."
msgstr ""

msgid "Example: ``LOWER('ДA')`` is 'дa'"
msgstr ""

msgid "NULLIF"
msgstr ""

msgid ":samp:`NULLIF(expression-1, expression-2)`"
msgstr ""

msgid ""
"Return *expression-1* if *expression-1* <> *expression-2*, otherwise "
"return NULL."
msgstr ""

msgid "``NULLIF('a', 'A')`` is 'a'."
msgstr ""

msgid "``NULLIF(1.00, 1)`` is NULL."
msgstr ""

msgid "POSITION"
msgstr ""

msgid ":samp:`POSITION({expression-1}, {expression-2})`"
msgstr ""

msgid ""
"Return the position of expression-1 within expression-2, or return 0 if "
"expression-1 does not appear within expression-2. The data types of the "
"expressions must be either STRING or VARBINARY. If the expressions have "
"data type STRING, then the result is the character position. If the "
"expressions have data type VARBINARY, then the result is the byte "
"position."
msgstr ""

msgid "Short example: ``POSITION('C', 'ABC')`` is 3"
msgstr ""

msgid ""
"Long example: The UTF-8 encoding for the Latin letter A is hexadecimal "
"41; the UTF-8 encoding for the Cyrillic letter Д is hexadecimal D094 -- "
"you can confirm this by saying SELECT HEX('ДA'); and seeing that the "
"result is 'D09441'. If you now execute ``SELECT POSITION('A', 'ДA');`` "
"the result will be 2, because 'A' is the second character in the string. "
"However, if you now execute ``SELECT POSITION(X'41', X'D09441');`` the "
"result will be 3, because X'41' is the third byte in the byte sequence."
msgstr ""

msgid "PRINTF"
msgstr ""

msgid ":samp:`PRINTF(string-expression [, expression ...])`"
msgstr ""

#, python-format
msgid ""
"Return a string formatted according to the rules of the C ``sprintf()`` "
"function, where ``%d%s`` means the next two arguments are a number and a "
"string, and so on."
msgstr ""

msgid "If an argument is missing or is NULL, it becomes:"
msgstr ""

msgid "'0' if the format requires an integer,"
msgstr ""

msgid "'0.0' if the format requires a number with a decimal point,"
msgstr ""

msgid "'' if the format requires a string."
msgstr ""

#, python-format
msgid "Example: ``PRINTF('%da', 5)`` is '5a'."
msgstr ""

msgid "QUOTE"
msgstr ""

msgid ":samp:`QUOTE(string-literal)`"
msgstr ""

msgid ""
"Return a string with enclosing quotes if necessary, and with quotes "
"inside the enclosing quotes if necessary. This function is useful for "
"creating strings which are part of SQL statements, because of SQL's rules"
" that string literals are enclosed by single quotes, and single quotes "
"inside such strings are shown as two single quotes in a row."
msgstr ""

msgid "Example: ``QUOTE('a')`` is ``'a'``."
msgstr ""

msgid "RAISE"
msgstr ""

msgid ":samp:`RAISE(FAIL, {error-message})`"
msgstr ""

msgid ""
"This may only be used within a triggered statement. See also "
":ref:`Trigger Activation <sql_trigger_activation>`."
msgstr ""

msgid "RANDOM"
msgstr ""

msgid "Syntax: :samp:`RANDOM()`"
msgstr ""

msgid ""
"Return a 19-digit integer which is generated by a pseudo-random number "
"generator,"
msgstr ""

msgid "Example: ``RANDOM()`` is 6832175749978026034, or it is any other integer"
msgstr ""

msgid "RANDOMBLOB"
msgstr ""

msgid ":samp:`RANDOMBLOB({n})`"
msgstr ""

msgid ""
"Return a byte sequence, n bytes long, data type = VARBINARY, containing "
"bytes generated by a pseudo-random byte generator. The result can be "
"translated to hexadecimal. If n is less than 1 or is NULL or is infinity,"
" then NULL is returned."
msgstr ""

msgid ""
"Example: ``HEX(RANDOMBLOB(3))`` is '9EAAA8', or it is the hex value for "
"any other three-byte string"
msgstr ""

msgid ":samp:`REPLACE({expression-1}, {expression-2}, {expression-3})`"
msgstr ""

msgid ""
"Return expression-1, except that wherever expression-1 contains "
"expression-2, replace expression-2 with expression-3. The expressions "
"should all have data type STRING or VARBINARY."
msgstr ""

msgid "Example: ``REPLACE('AAABCCCBD', 'B', '!')`` is 'AAA!CCC!D'"
msgstr ""

msgid "ROUND"
msgstr ""

msgid ":samp:`ROUND({numeric-expression-1} [, {numeric-expression-2}])`"
msgstr ""

msgid ""
"Return the rounded value of numeric-expression-1, always rounding .5 "
"upward for floating-point positive numbers or downward for negative "
"numbers. If numeric-expression-2 is supplied then rounding is to the "
"nearest numeric-expression-2 digits after the decimal point; if numeric-"
"expression-2 is not supplied then rounding is to the nearest integer."
msgstr ""

msgid "Example: ``ROUND(-1.5)`` is -2, ``ROUND(1.7766E1,2)`` is 17.77."
msgstr ""

msgid "ROW_COUNT"
msgstr ""

msgid ":samp:`ROW_COUNT()`"
msgstr ""

msgid ""
"Return the number of rows that were inserted / updated / deleted by the "
"last :ref:`INSERT <sql_insert>` or :ref:`UPDATE <sql_update>` or "
":ref:`DELETE <sql_delete>` or :ref:`REPLACE <sql_replace>` statement. "
"Rows which were updated by an UPDATE statement are counted even if there "
"was no change. Rows which were inserted / updated / deleted due to "
"foreign-key action are not counted. Rows which were inserted / updated / "
"deleted due to a view's :ref:`INSTEAD OF triggers "
"<sql_instead_of_triggers>` are  not counted. After a CREATE or DROP "
"statement, ROW_COUNT() is 1. After other statements,  ROW_COUNT() is 0."
msgstr ""

msgid "Example: ``ROW_COUNT()`` is 1 after a successful INSERT of a single row."
msgstr ""

msgid ""
"Special rule if there are BEFORE or AFTER triggers: In effect the "
"ROW_COUNT() counter is pushed at the beginning of a series of triggered "
"statements, and popped at the end. Therefore, after the following "
"statements:"
msgstr ""

msgid ""
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY);\n"
"CREATE TABLE t2 (s1 INTEGER, s2 STRING, s3 INTEGER, PRIMARY KEY (s1, s2, "
"s3));\n"
"CREATE TRIGGER tt1 BEFORE DELETE ON t1 FOR EACH ROW BEGIN\n"
"  INSERT INTO t2 VALUES (old.s1, '#2 Triggered', ROW_COUNT());\n"
"  INSERT INTO t2 VALUES (old.s1, '#3 Triggered', ROW_COUNT());\n"
"  END;\n"
"INSERT INTO t1 VALUES (1),(2),(3);\n"
"DELETE FROM t1;\n"
"INSERT INTO t2 VALUES (4, '#4 Untriggered', ROW_COUNT());\n"
"SELECT * FROM t2;"
msgstr ""

msgid "The result is:"
msgstr ""

msgid ""
"---\n"
"- - [1, '#2 Triggered', 3]\n"
"  - [1, '#3 Triggered', 1]\n"
"  - [2, '#2 Triggered', 3]\n"
"  - [2, '#3 Triggered', 1]\n"
"  - [3, '#2 Triggered', 3]\n"
"  - [3, '#3 Triggered', 1]\n"
"  - [4, '#4 Untriggered', 3]\n"
"..."
msgstr ""

msgid "SOUNDEX"
msgstr ""

msgid ":samp:`SOUNDEX(string-expression)`"
msgstr ""

msgid ""
"Return a four-character string which represents the sound of ``string-"
"expression``. Often words and names which have different spellings will "
"have the same Soundex representation if they are pronounced similarly, so"
" it is possible to search by what they sound like. The algorithm works "
"with characters in the Latin alphabet and works best with English words."
msgstr ""

msgid ""
"Example: ``SOUNDEX('Crater')`` and ``SOUNDEX('Creature')`` both return "
"``C636``."
msgstr ""

msgid "SUBSTR"
msgstr ""

msgid ""
":samp:`SUBSTR({expression-1}, {numeric-expression-1} [, {numeric-"
"expression-2}])`"
msgstr ""

msgid ""
"If expression-1 has data type STRING, then return the substring which "
"begins at character position numeric-expression-1 and continues for "
"numeric-expression-2 characters (if numeric-expression-2 is supplied), or"
" continues till the end of string-expression-1 (if numeric-expression-2 "
"is not supplied)."
msgstr ""

msgid ""
"If expression-1 has data type VARBINARY rather than data type STRING, "
"then positioning and counting is by bytes rather than by characters."
msgstr ""

msgid "Example: ``SUBSTR('ABCDEFG', 3, 2)`` is 'CD'"
msgstr ""

msgid "TRIM"
msgstr ""

msgid ""
":samp:`TRIM([[LEADING|TRAILING|BOTH] [{expression-1}] FROM] "
"{expression-2})`"
msgstr ""

msgid ""
"Return expression-2 after removing all leading and/or trailing characters"
" or bytes. The expressions should have data type STRING or VARBINARY. If "
"LEADING|TRAILING|BOTH is omitted, the default is BOTH. If expression-1 is"
" omitted, the default is ' ' (space) for data type STRING or X'00' (nul) "
"for data type VARBINARY."
msgstr ""

msgid ""
"``TRIM('a' FROM 'abaaaaa')`` is 'b' -- all repetitions of 'a' are removed"
" on both sides; ``TRIM(TRAILING 'ב' FROM 'אב')`` is 'א' -- if all "
"characters are Hebrew, TRAILING means \"left\"; ``TRIM(X'004400')`` is "
"X'44' -- the default byte sequence to trim is X'00' when data type is "
"VARBINARY; ``TRIM(LEADING 'abc' FROM 'abcd')`` is 'd' -- expression-1 can"
" have more than 1 character."
msgstr ""

msgid "TYPEOF"
msgstr ""

msgid ":samp:`TYPEOF({expression})`"
msgstr ""

msgid "Return the :ref:`data type <sql_column_def_data_type>` of the expression."
msgstr ""

msgid ""
"``TYPEOF('A')`` returns 'string'; ``TYPEOF(RANDOMBLOB(1))`` returns "
"'varbinary'; ``TYPEOF(1e44)`` returns 'double' or 'number'; "
"``TYPEOF(-44)`` returns 'integer'; ``TYPEOF(NULL)`` returns 'boolean'"
msgstr ""

msgid "UNICODE"
msgstr ""

msgid ":samp:`UNICODE(string-expression)`"
msgstr ""

msgid ""
"Return the Unicode code point value of the first character of **string-"
"expression**. If *string-expression* is empty, the return is NULL. This "
"is the reverse of :ref:`CHAR(integer) <sql_function_char>`."
msgstr ""

msgid "Example: ``UNICODE('Щ')`` is 1065 (hexadecimal 0429)."
msgstr ""

msgid "UNLIKELY"
msgstr ""

msgid ":samp:`UNLIKELY({expression})`"
msgstr ""

msgid ""
"Return TRUE if the expression is probably false. Limitation: in fact "
"``UNLIKELY`` may return the same thing as :ref:`LIKELY "
"<sql_function_likely>`."
msgstr ""

msgid "Example: ``UNLIKELY('a' <= 'b')`` is TRUE."
msgstr ""

msgid "UPPER"
msgstr ""

msgid ":samp:`UPPER(string-expression)`"
msgstr ""

msgid ""
"Return the expression, with lower-case characters converted to upper "
"case. The reverse of ``UPPER`` is :ref:`LOWER <sql_function_lower>`."
msgstr ""

msgid "Example: ``UPPER('-4щl')`` is '-4ЩL'."
msgstr ""

msgid "VERSION"
msgstr ""

msgid ":samp:`VERSION()`"
msgstr ""

msgid "Return the Tarantool version."
msgstr ""

msgid "Example: for a February 2020 build VERSION() is ``'2.4.0-35-g57f6fc932'``."
msgstr ""

msgid "ZEROBLOB"
msgstr ""

msgid ":samp:`ZEROBLOB({n})`"
msgstr ""

msgid "Return a byte sequence, data type = VARBINARY, n bytes long."
msgstr ""

msgid "COLLATE clause"
msgstr ""

msgid ":samp:`COLLATE collation-name`"
msgstr ""

msgid "The collation-name must identify an existing collation."
msgstr ""

msgid ""
"The COLLATE clause is allowed for STRING or SCALAR items: |br| () in "
":ref:`CREATE INDEX <sql_create_index>` |br| () in :ref:`CREATE TABLE "
"<sql_create_table>` as part of :ref:`column definition <sql_column_def>` "
"|br| () in CREATE TABLE as part of :ref:`UNIQUE definition "
"<sql_table_constraint_def>` |br| () in string expressions |br|"
msgstr ""

msgid ""
"-- In CREATE INDEX\n"
"CREATE INDEX idx_unicode_mb_1 ON mb (s1 COLLATE \"unicode\");\n"
"-- In CREATE TABLE\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 STRING COLLATE "
"\"unicode_ci\");\n"
"-- In CREATE TABLE ... UNIQUE\n"
"CREATE TABLE mb (a STRING, b STRING, PRIMARY KEY(a), UNIQUE(b COLLATE "
"\"unicode_ci\" DESC));\n"
"-- In string expressions\n"
"SELECT 'a' = 'b' COLLATE \"unicode\"\n"
"    FROM t\n"
"    WHERE s1 = 'b' COLLATE \"unicode\"\n"
"    ORDER BY s1 COLLATE \"unicode\";"
msgstr ""

msgid ""
"The list of collations can be seen with: :ref:`PRAGMA collation_list; "
"<sql_pragma>`"
msgstr ""

msgid ""
"The collation rules comply completely with the Unicode Technical Standard"
" #10 (`\"Unicode Collation Algorithm\" "
"<http://unicode.org/reports/tr10/>`_) and the default character order is "
"as in the `Default Unicode Collation Element Table (DUCET) "
"<https://www.unicode.org/Public/UCA/8.0.0/allkeys.txt>`_. There are many "
"permanent collations; the commonly used ones include: |br| |nbsp| |nbsp| "
"``\"none\"`` (not applicable) |br| |nbsp| |nbsp| ``\"unicode\"`` "
"(characters are in DUCET order with strength = 'tertiary') |br| |nbsp| "
"|nbsp| ``\"unicode_ci\"`` (characters are in DUCET order with strength = "
"'primary') |br| |nbsp| |nbsp| ``\"binary\"`` (characters are in code "
"point order) |br| These identifiers must be quoted and in lower case "
"because they are in lower case in :ref:`Tarantool/NoSQL collations "
"<index-collation>`."
msgstr ""

msgid ""
"If one says ``COLLATE \"binary\"``, this is equivalent to asking for what"
" is sometimes called \"code point order\" because, if the contents are in"
" the UTF-8 character set, characters with larger code points will appear "
"after characters with lower code points."
msgstr ""

msgid ""
"In an expression, ``COLLATE`` is an operator with higher precedence than "
"anything except ``~``. This is fine because there are no other useful "
"operators except ``||`` and comparison. After ``||``, collation is "
"preserved."
msgstr ""

msgid ""
"In an expression with more than one ``COLLATE`` clause, if the collation "
"names differ, there is an error: \"Illegal mix of collations\". In an "
"expression with no ``COLLATE`` clauses, literals have collation "
"``\"binary\"``, columns have the collation specified by ``CREATE TABLE``."
msgstr ""

msgid ""
"In other words, to pick a collation, we use: |br| the first ``COLLATE`` "
"clause in an expression if it was specified, |br| else the the column's "
"``COLLATE`` clause if it was specified, |br| else ``\"binary\"``."
msgstr ""

msgid ""
"However, for searches and sometimes for sorting, the collation may be an "
"index's collation, so all non-index ``COLLATE`` clauses are ignored."
msgstr ""

msgid ""
":ref:`EXPLAIN <sql_explain>` will not show the name of what collation was"
" used, but will show the collation's characteristics."
msgstr ""

msgid ""
"Example with Swedish collation: |br| Knowing that \"sv\" is the two-"
"letter code for Swedish, |br| and knowing that \"s1\" means strength = 1,"
" |br| and seeing with ``PRAGMA collation_list;`` that there is a "
"collation named unicode_sv_s1, |br| check whether two strings are equal "
"according to Swedish rules (yes they are): |br| ``SELECT 'ÄÄ' = 'ĘĘ' "
"COLLATE \"unicode_sv_s1\";``"
msgstr ""

msgid ""
"Example with Russian and Ukrainian and Kyrgyz collations: |br| Knowing "
"that Russian collation is practically the same as Unicode default, |br| "
"and knowing that the two-letter codes for Ukrainian and Kyrgyz are 'uk' "
"and 'ky', |br| and knowing that in Russian (but not Ukrainian) 'Г' = 'Ґ' "
"with strength=primary, |br| and knowing that in Russian (but not Kyrgyz) "
"'Е' = 'Ё' with strength=primary, |br| the three SELECT statements here "
"will return results in three different orders: |br| ``CREATE TABLE things"
" (remark STRING PRIMARY KEY);`` |br| ``INSERT INTO things VALUES ('Е2'), "
"('Ё1');`` |br| ``INSERT INTO things VALUES ('Г2'), ('Ґ1');`` |br| "
"``SELECT remark FROM things ORDER BY remark COLLATE \"unicode\";`` |br| "
"``SELECT remark FROM things ORDER BY remark COLLATE \"unicode_uk_s1\";`` "
"|br| ``SELECT remark FROM things ORDER BY remark COLLATE "
"\"unicode_ky_s1\";``"
msgstr ""
