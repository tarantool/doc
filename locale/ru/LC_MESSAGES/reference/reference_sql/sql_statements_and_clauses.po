
msgid "SQL statements and clauses"
msgstr ""

msgid ""
"The Statements and Clauses guide shows all Tarantool/SQL statements' syntax "
"and use."
msgstr ""

msgid "Heading"
msgstr ""

msgid "Summary"
msgstr "Введение"

msgid ""
":ref:`Statements that change data definition "
"<sql_statements_change_definition>`"
msgstr ""

msgid ""
":ref:`ALTER TABLE <sql_alter_table>`, :ref:`CREATE TABLE "
"<sql_create_table>`, :ref:`DROP TABLE <sql_drop_table>`, :ref:`CREATE VIEW "
"<sql_create_view>`, :ref:`DROP VIEW <sql_drop_view>`, :ref:`CREATE INDEX "
"<sql_create_index>`, :ref:`DROP INDEX <sql_drop_index>`, :ref:`CREATE "
"TRIGGER <sql_create_trigger>`, :ref:`DROP TRIGGER <sql_drop_trigger>`"
msgstr ""

msgid ":ref:`Statements that change data <sql_statements_change_data>`"
msgstr ""

msgid ""
":ref:`INSERT <sql_insert>`, :ref:`UPDATE <sql_update>`,  :ref:`DELETE "
"<sql_delete>`, :ref:`REPLACE <sql_replace>`, :ref:`TRUNCATE <sql_truncate>`,"
" :ref:`SET <sql_set>`"
msgstr ""

msgid ":ref:`Statements that retrieve data <sql_statements_retrieve_data>`"
msgstr ""

msgid ""
":ref:`SELECT <sql_select>`, :ref:`VALUES <sql_values>`, :ref:`PRAGMA "
"<sql_pragma>`, :ref:`EXPLAIN <sql_explain>`"
msgstr ""

msgid ":ref:`Statements for transactions <sql_transactions>`"
msgstr ""

msgid ""
":ref:`START TRANSACTION <sql_start_transaction>`, :ref:`COMMIT "
"<sql_commit>`, :ref:`SAVEPOINT <sql_savepoint>`, :ref:`RELEASE SAVEPOINT "
"<sql_release_savepoint>`, :ref:`ROLLBACK <sql_rollback>`"
msgstr ""

msgid ":ref:`Functions <sql_functions>`"
msgstr ""

msgid ""
"For example :ref:`CAST(...) <sql_function_cast>`, :ref:`LENGTH(...) "
"<sql_function_length>`, :ref:`VERSION() <sql_function_version>`"
msgstr ""

msgid "Statements that change data definition"
msgstr ""

msgid "ALTER TABLE"
msgstr ""

msgid "Syntax:"
msgstr ""

msgid ":samp:`ALTER TABLE {table-name} RENAME TO {new-table-name};`"
msgstr ""

msgid ""
":samp:`ALTER TABLE {table-name} ADD COLUMN {column-name} {column-"
"definition};`"
msgstr ""

msgid ""
":samp:`ALTER TABLE {table-name} ADD CONSTRAINT {constraint-name} "
"{constraint-definition};`"
msgstr ""

msgid ":samp:`ALTER TABLE {table-name} DROP CONSTRAINT {constraint-name};`"
msgstr ""

msgid ""
":samp:`ALTER TABLE {table-name} ENABLE|DISABLE CHECK CONSTRAINT {constraint-"
"name};`"
msgstr ""

msgid "|br|"
msgstr "|br|"

msgid "ALTER is used to change a table's name or a table's elements."
msgstr ""

msgid "**Examples:**"
msgstr "**Примеры:**"

msgid ""
"For renaming a table with ``ALTER ... RENAME``, the *old-table* must exist, "
"the *new-table* must not exist. Example: |br| ``-- renaming a table:`` "
"``ALTER TABLE t1 RENAME TO t2;``"
msgstr ""

msgid ""
"For adding a :ref:`column <sql_column_def>` with ``ADD COLUMN``, the table "
"must exist, the table must be empty, the column name must be unique within "
"the table. Example with a STRING column that must start with X:"
msgstr ""

msgid "ALTER TABLE t1 ADD COLUMN s4 STRING CHECK (s4 LIKE 'X%');"
msgstr ""

msgid ""
"``ALTER TABLE ... ADD COLUMN`` support was added in version :doc:`2.7.1 "
"</release/2.7.1>`."
msgstr ""

msgid ""
"For adding a :ref:`table constraint <sql_table_constraint_def>` with ``ADD "
"CONSTRAINT``, the table must exist, the table must be empty, the constraint "
"name must be unique within the table. Example with a :ref:`foreign-key "
"constraint definition <sql_foreign_key>`: |br| ``ALTER TABLE t1 ADD "
"CONSTRAINT fk_s1_t1_1 FOREIGN KEY (s1) REFERENCES t1;`` |br|"
msgstr ""

msgid ""
"It is not possible to say ``CREATE TABLE table_a ... REFERENCES table_b "
"...`` if table ``b`` does not exist yet. This is a situation where ``ALTER "
"TABLE`` is handy -- users can ``CREATE TABLE table_a`` without the foreign "
"key, then ``CREATE TABLE table_b``, then ``ALTER TABLE table_a ... "
"REFERENCES table_b ...``."
msgstr ""

msgid ""
"-- adding a primary-key constraint definition:\n"
"-- This is unusual because primary keys are created automatically\n"
"-- and it is illegal to have two primary keys for the same table.\n"
"-- However, it is possible to drop a primary-key index, and this\n"
"-- is a way to restore the primary key if that happens.\n"
"ALTER TABLE t1 ADD CONSTRAINT \"pk_unnamed_T1_1\" PRIMARY KEY (s1);\n"
"\n"
"-- adding a unique-constraint definition:\n"
"-- Alternatively, you can say CREATE UNIQUE INDEX unique_key ON t1 (s1);\n"
"ALTER TABLE t1 ADD CONSTRAINT \"unique_unnamed_T1_2\" UNIQUE (s1);\n"
"\n"
"-- Adding a check-constraint definition:\n"
"ALTER TABLE t1 ADD CONSTRAINT \"ck_unnamed_T1_1\" CHECK (s1 > 0);"
msgstr ""

msgid ""
"For ``ALTER ... DROP CONSTRAINT``, it is only legal to drop a named "
"constraint. (Tarantool generates the constraint names automatically if the "
"user does not provide them.) Since version :doc:`2.4.1 </release/2.4.1>`, it"
" is possible to drop any of the named table constraints, namely, PRIMARY "
"KEY, UNIQUE, FOREIGN KEY, and CHECK."
msgstr ""

msgid ""
"To remove a unique constraint, use either ``ALTER ... DROP CONSTRAINT`` or "
":ref:`DROP INDEX <sql_drop_index>`, which will drop the constraint as well."
msgstr ""

msgid ""
"-- dropping a constraint:\n"
"ALTER TABLE t1 DROP CONSTRAINT \"fk_unnamed_JJ2_1\";"
msgstr ""

msgid ""
"For ``ALTER ... ENABLE|DISABLE CHECK CONSTRAINT``, it is only legal to "
"enable or disable a named constraint, and Tarantool only looks for names of "
"check constraints. By default a constraint is enabled. If a constraint is "
"disabled, then the check will not be performed."
msgstr ""

msgid ""
"-- disabling and re-enabling a constraint:\n"
"ALTER TABLE t1 DISABLE CHECK CONSTRAINT c;\n"
"ALTER TABLE t1 ENABLE CHECK CONSTRAINT c;"
msgstr ""

msgid "Limitations:"
msgstr ""

msgid "It is not possible to drop a column."
msgstr ""

msgid ""
"It is not possible to modify NOT NULL constraints or column properties "
"DEFAULT and :ref:`data type <sql_column_def_data_type>`. However, it is "
"possible to modify them with Tarantool/NOSQL, for example by calling "
":ref:`space_object:format() <box_space-format>` with a different "
"``is_nullable`` value."
msgstr ""

msgid "CREATE TABLE"
msgstr ""

msgid ""
":samp:`CREATE TABLE [IF NOT EXISTS] {table-name} (column-definition or "
"table-constraint list)` :samp:`[WITH ENGINE = {string}];`"
msgstr ""

msgid "Create a new base table, usually called a \"table\"."
msgstr ""

msgid ""
"A table is a *base table* if it is created with CREATE TABLE and contains "
"data in persistent storage."
msgstr ""

msgid ""
"A table is a *viewed table*, or just \"view\", if it is created with "
":ref:`CREATE VIEW <sql_create_view>` and gets its data from other views or "
"from base tables."
msgstr ""

msgid ""
"The *table-name* must be an identifier which is valid according to the rules"
" for identifiers, and must not be the name of an already existing base table"
" or view."
msgstr ""

msgid ""
"The *column-definition* or *table-constraint* list is a comma-separated list"
" of :ref:`column definitions <sql_column_def>` or :ref:`table constraint "
"definitions <sql_table_constraint_def>`. Column definitions and table "
"constraint definitions are sometimes called *table elements*."
msgstr ""

msgid "Rules:"
msgstr ""

msgid ""
"A primary key is necessary; it can be specified with a table constraint "
"PRIMARY KEY."
msgstr ""

msgid "There must be at least one column."
msgstr ""

msgid ""
"When IF NOT EXISTS is specified, and there is already a table with the same "
"name, the statement is ignored."
msgstr ""

msgid ""
"When :samp:`WITH ENGINE = {string}` is specified, where :samp:`{string}` "
"must be either 'memtx' or 'vinyl', the table is created with that "
":ref:`storage engine <engines-chapter>`. When this clause is not specified, "
"the table is created with the default engine, which is ordinarily 'memtx' "
"but may be changed by updating the :ref:`box.space._session_settings "
"<box_space-session_settings>` system table.."
msgstr ""

msgid "Actions:"
msgstr ""

msgid ""
"Tarantool evaluates each column definition and table-constraint, and returns"
" an error if any of the rules is violated."
msgstr ""

msgid "Tarantool makes a new definition in the schema."
msgstr ""

msgid ""
"Tarantool makes new indexes for PRIMARY KEY or UNIQUE constraints. A unique "
"index name is created automatically."
msgstr ""

msgid ""
"Usually Tarantool effectively executes a :ref:`COMMIT <sql_commit>` "
"statement."
msgstr ""

msgid "Examples:"
msgstr "Примеры:"

msgid ""
"-- the simplest form, with one column and one constraint:\n"
"CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
"\n"
"-- you can see the effect of the statement by querying\n"
"-- Tarantool system spaces:\n"
"SELECT * FROM \"_space\" WHERE \"name\" = 'T1';\n"
"SELECT * FROM \"_index\" JOIN \"_space\" ON \"_index\".\"id\" = \"_space\".\"id\"\n"
"         WHERE \"_space\".\"name\" = 'T1';\n"
"\n"
"-- variation of the simplest form, with delimited identifiers\n"
"-- and a bracketed comment:\n"
"CREATE TABLE \"T1\" (\"S1\" INT /* synonym of INTEGER */, PRIMARY KEY (\"S1\"));\n"
"\n"
"-- two columns, one named constraint\n"
"CREATE TABLE t1 (s1 INTEGER, s2 STRING, CONSTRAINT pk_s1s2_t1_1 PRIMARY KEY (s1, s2));"
msgstr ""

msgid "The maximum number of columns is 2000."
msgstr ""

msgid ""
"The maximum length of a row depends on the :ref:`memtx_max_tuple_size "
"<cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size  "
"<cfg_storage-memtx_max_tuple_size>` configuration option."
msgstr ""

msgid "Column definition"
msgstr ""

msgid ":samp:`column-name data-type [, column-constraint]`"
msgstr ""

msgid ""
"Define a column, which is a table element used in a :ref:`CREATE TABLE "
"<sql_create_table>` statement."
msgstr ""

msgid ""
"The ``column-name`` must be an identifier which is valid according to the "
"rules for identifiers."
msgstr ""

msgid "Each ``column-name`` must be unique within a table."
msgstr ""

msgid "Column definition -- data type"
msgstr ""

#, fuzzy
msgid ""
"Every column has a data type: ANY or ARRAY or BOOLEAN or DECIMAL or DOUBLE "
"or INTEGER or MAP or NUMBER or SCALAR or STRING or UNSIGNED or UUID or "
"VARBINARY. The detailed description of data types is in the section "
":ref:`Operands <sql_operands>`."
msgstr ""
"У каждого столбца есть тип данных: BOOLEAN, DOUBLE, INTEGER, NUMBER, SCALAR,"
" STRING, UNSIGNED, UUID или VARBINARY. Подробное описание типов данных вы "
"найдёте в разделе :ref:`Операнды <sql_operands>`."

msgid "Column definition -- the rules for the SCALAR data type"
msgstr ""

#, fuzzy
msgid ""
"The rules for the SCALAR data type were significantly changed in Tarantool "
"version :tarantool-release:`2.10.0`."
msgstr ""
"Правила для типа данных SCALAR были значительно изменены в версии Tarantool "
":tarantool-release:`2.10.0-beta1`."

msgid ""
"SCALAR is a \"complex\" data type, unlike all the other data types which are"
" \"primitive\". Two column values in a SCALAR column can have two different "
"primitive data types."
msgstr ""

msgid ""
"Any item defined as SCALAR has an underlying primitive type. For example, "
"here:"
msgstr ""

msgid ""
"CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (55), ('41');"
msgstr ""

msgid ""
"the underlying primitive type of the item in the first row is INTEGER "
"because literal 55 has data type INTEGER, and the underlying primitive type "
"in the second row is STRING (the data type of a literal is always clear from"
" its format)."
msgstr ""

msgid ""
"An item's primitive type is far less important than its defined type. "
"Incidentally Tarantool might find the primitive type by looking at the way "
"MsgPack stores it, but that is an implementation detail."
msgstr ""
"Примитивный тип элемента гораздо менее важен, чем его установленный тип. "
"Tarantool может определить примитивный тип по тому, как MsgPack хранит его, "
"но это уже детали реализации."

msgid ""
"A SCALAR definition may not include a maximum length, as there is no "
"suggested restriction."
msgstr ""

msgid ""
"A SCALAR definition may include a :ref:`COLLATE clause "
"<sql_collate_clause>`, which affects any items whose primitive data type is "
"STRING. The default collation is \"binary\"."
msgstr ""

msgid ""
"Some assignments are illegal when data types differ, but legal when the "
"target is a SCALAR item. For example ``UPDATE ... SET column1 = 'a'`` is "
"illegal if ``column1`` is defined as INTEGER, but is legal if ``column1`` is"
" defined as SCALAR -- values which happen to be INTEGER will be changed so "
"their data type is SCALAR."
msgstr ""
"Некоторые присваивания недопустимы, когда типы данных различаются, но "
"разрешены, если речь об элементе типа SCALAR. Например, инструкция ``UPDATE "
"... SET column1 = 'a'`` выдаст ошибку, если столбец ``column1`` определен "
"как INTEGER. Однако она может быть выполнена, если ``column1`` определен как"
" SCALAR, при этом все значения типа INTEGER будут приведены к типу данных "
"SCALAR."

msgid "There is no literal syntax which implies data type SCALAR."
msgstr ""

msgid ""
"TYPEOF(x) is always 'scalar' or 'NULL', it is never the underlying data "
"type. In fact there is no function that is guaranteed to return the "
"underlying data type. For example, ``TYPEOF(CAST(1 AS SCALAR));`` returns "
"'scalar', not 'integer'."
msgstr ""
"Результат ``TYPEOF(x)`` --- всегда ``'scalar'`` или ``'NULL'``, а не базовый"
" тип данных. Не существует функции, которая гарантированно возвращает "
"базовый тип данных. Например, ``TYPEOF(CAST(1 AS SCALAR));`` возвращает "
"``'scalar'``, а не ``'integer'``."

msgid ""
"For any operation that requires implicit casting from an item defined as "
"SCALAR, the operation will fail at runtime. For example, if a definition is:"
msgstr ""
"Любая операция, которая требует неявного приведения элемента, определенного "
"как SCALAR, завершится ошибкой во время выполнения. Например, если "
"определение имеет вид:"

msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY, s2 INTEGER);"
msgstr "CREATE TABLE t (s1 SCALAR PRIMARY KEY, s2 INTEGER);"

msgid ""
"and the only row in table T has s1 = 1, that is, its underlying primitive "
"type is INTEGER, then ``UPDATE t SET s2 = s1;`` is illegal."
msgstr ""
"и единственная строка в таблице T содержит значение ``s1 = 1``, то есть "
"примитивный тип этого значения --- INTEGER, то операция ``UPDATE t SET s2 = "
"s1;`` все равно не разрешена."

msgid ""
"For any dyadic operation that requires implicit casting for comparison, the "
"syntax is legal and the operation will not fail at runtime. Take this "
"situation: comparison with a primitive type VARBINARY and a primitive type "
"STRING."
msgstr ""

msgid ""
"CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (X'41');\n"
"SELECT * FROM t WHERE s1 > 'a';"
msgstr ""

msgid ""
"The comparison is valid, because Tarantool knows the ordering of X'41' and "
"'a' in Tarantool/NoSQL 'scalar' -- this is a case where the primitive type "
"matters."
msgstr ""
"Такое сравнение корректно, поскольку Tarantool знает, в каком порядке стоят "
"значения ``X'41'`` и ``'a'`` типа ``'scalar'`` в Tarantool/NoSQL. В этом "
"случае примитивный тип имеет значение."

msgid ""
"The result data type of :ref:`min/max <sql_aggregate>` operation on a column"
" defined as SCALAR is SCALAR. Users will need to know the underlying "
"primitive type of the result in advance. For example:"
msgstr ""
"Результат операции :ref:`min/max <sql_aggregate>` над столбцом, определенным"
" как SCALAR, тоже будет иметь тип SCALAR. Пользователям необходимо заранее "
"знать примитивный тип результата. Пример:"

msgid ""
"CREATE TABLE t (s1 INTEGER, s2 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (1, X'44'), (2, 11), (3, 1E4), (4, 'a');\n"
"SELECT cast(min(s2) AS INTEGER), hex(cast(max(s2) as VARBINARY)) FROM t;"
msgstr ""
"CREATE TABLE t (s1 INTEGER, s2 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (1, X'44'), (2, 11), (3, 1E4), (4, 'a');\n"
"SELECT cast(min(s2) AS INTEGER), hex(cast(max(s2) as VARBINARY)) FROM t;"

msgid "The result is: ``- - [11, '44',]``"
msgstr ""

msgid ""
"That is only possible with Tarantool/NoSQL scalar rules, but ``SELECT "
"SUM(s2)`` would not be legal because addition would in this case require "
"implicit casting from VARBINARY to a numeric, which is not sensible."
msgstr ""
"Это возможно только с правилами Tarantool/NoSQL для типа ``scalar``. Однако "
"вызов ``SELECT SUM(s2)`` не будет допустим: суммирование в этом случае "
"потребует неявного приведения VARBINARY к числовому значению, что неразумно."

#, fuzzy
msgid ""
"The result data type of a primitive combination is sometimes SCALAR although"
" Tarantool in effect uses the primitive data type not the defined data type."
" (Here the word \"combination\" is used in the way that the standard "
"document uses it for section \"Result of data type combinations\".) "
"Therefore for ``greatest(1E308, 'a', 0, X'00')`` the result is X'00' but "
"``typeof(greatest(1E308, 'a', 0, X'00')`` is 'scalar'."
msgstr ""
"В случае комбинации примитивных типов результат иногда имеет тип данных "
"SCALAR, хотя на самом деле используется примитивный тип данных, а не "
"установленный тип данных. Здесь под комбинацией подразумевается то же, что и"
" в стандарте SQL в разделе \"Результат комбинации типов данных\". Поэтому "
"для ``greatest(1E308, 'a', 0, X'00')`` результатом будет ``X'00'``, но "
"результат ``typeof(greatest(1E308, 'a', 0, X'00')`` будет ``'scalar'``."

msgid ""
"The union of two SCALARs is sometimes the primitive type. For example, "
"``SELECT TYPEOF((SELECT CAST('a' AS SCALAR) UNION SELECT CAST('a' AS "
"SCALAR)));`` returns 'string'."
msgstr ""
"Объединение двух значений типа SCALAR иногда представляется примитивным "
"типом. Например, ``SELECT TYPEOF((SELECT CAST('a' AS SCALAR) UNION SELECT "
"CAST('a' AS SCALAR)));`` вернет ``'string'``."

msgid "Column definition -- relation to NoSQL"
msgstr ""

#, fuzzy
msgid ""
"All of the SQL data types except SCALAR correspond to :ref:`Tarantool/NoSQL "
"types with the same name <index-box_indexed-field-types>`. For example an "
"SQL STRING is stored in a NoSQL space as type = 'string'."
msgstr ""
"Все типы данных SQL, кроме SCALAR, соответствуют :ref:`типам в "
"Tarantool/NoSQL с тем же именем <box_space-index_field_types>`. Например, "
"тип SQL STRING хранится в пространстве NoSQL как тип ``'string'``."

msgid ""
"Therefore specifying an SQL data type X determines that the storage will be "
"in a space with a format column saying that the NoSQL type is 'x'."
msgstr ""

msgid "The rules for that NoSQL type are applicable to the SQL data type."
msgstr ""

msgid ""
"If two items have SQL data types that have the same underlying type, then "
"they are compatible for all assignment or comparison purposes."
msgstr ""

msgid ""
"If two items have SQL data types that have different underlying types, then "
"the rules for explicit casts, or implicit (assignment) casts, or implicit "
"(comparison) casts, apply."
msgstr ""

msgid ""
"There is one floating-point value which is not handled by SQL: -nan is seen "
"as NULL although its data type is 'double'."
msgstr ""
"Существует одно значение с плавающей точкой, которое не обрабатывается SQL: "
"``-NaN`` воспринимается как ``NULL``, хотя его тип данных --- ``'double'``."

#, fuzzy
msgid ""
"Before Tarantool :tarantool-release:`2.10.0`, there were also some "
"Tarantool/NoSQL data types which had no corresponding SQL data types. For "
"example, ``SELECT \"flags\" FROM \"_vspace\";`` would return a column whose "
"SQL data type is VARBINARY rather than MAP. Such columns can only be "
"manipulated in SQL by :ref:`invoking Lua functions <sql_calling_lua>`."
msgstr ""
"В Tarantool/NoSQL также есть типы, которым не соответствует ни один тип "
"данных в SQL. Например, ``SELECT \"flags\" FROM \"_vspace\";`` вернет "
"столбец, тип которого ``'varbinary'``, а не ``'map'``. Такими столбцами "
"можно оперировать в SQL, только :ref:`вызывая Lua-функции "
"<sql_calling_lua>`."

msgid "Column definition -- column-constraint or default clause"
msgstr ""

msgid "The column-constraint or default clause may be as follows:"
msgstr ""

msgid "Type"
msgstr "Тип"

msgid "Comment"
msgstr ""

msgid "NOT NULL"
msgstr ""

msgid "means \"it is illegal to assign a NULL to this column\""
msgstr ""

msgid "PRIMARY KEY"
msgstr ""

msgid ""
"explained in the :ref:`Table constraint definition "
"<sql_table_constraint_def>` section"
msgstr ""

msgid "UNIQUE"
msgstr ""

msgid "CHECK (expression)"
msgstr ""

msgid "foreign-key-clause"
msgstr ""

msgid ""
"explained in the :ref:`Table constraint definition for foreign keys "
"<sql_foreign_key>` section"
msgstr ""

msgid "DEFAULT expression"
msgstr ""

msgid ""
"means \"if INSERT does not assign to this column then assign expression "
"result to this column\" -- if there is no DEFAULT clause then DEFAULT NULL "
"is assumed"
msgstr ""

msgid ""
"If column-constraint is PRIMARY KEY, this is a shorthand for a separate "
":ref:`table-constraint definition <sql_table_constraint_def>`: \"PRIMARY KEY"
" (column-name)\"."
msgstr ""

msgid ""
"If column-constraint is UNIQUE, this is a shorthand for a separate "
":ref:`table-constraint definition <sql_table_constraint_def>`: \"UNIQUE "
"(column-name)\"."
msgstr ""

msgid ""
"If column-constraint is CHECK, this is a shorthand for a separate "
":ref:`table-constraint definition <sql_table_constraint_def>`: \"CHECK "
"(expression)\"."
msgstr ""

msgid "Columns defined with PRIMARY KEY are automatically NOT NULL."
msgstr ""

msgid ""
"To enforce some restrictions that Tarantool does not enforce automatically, "
"add CHECK clauses, like these:"
msgstr ""

msgid ""
"CREATE TABLE t (\"smallint\" INTEGER PRIMARY KEY CHECK (\"smallint\" <= 32767 AND \"smallint\" >= -32768));\n"
"CREATE TABLE t (\"shorttext\" STRING PRIMARY KEY CHECK (length(\"shorttext\") <= 10));"
msgstr ""

msgid "but this may cause inserts or updates to be slow."
msgstr ""

msgid "Column definition -- examples"
msgstr ""

msgid ""
"These are shown within :ref:`CREATE TABLE <sql_create_table>` statements. "
"Data types may also appear in :ref:`CAST <sql_function_cast>` functions."
msgstr ""

msgid ""
"-- the simple form with column-name and data-type\n"
"CREATE TABLE t (column1 INTEGER ...);\n"
"-- with column-name and data-type and column-constraint\n"
"CREATE TABLE t (column1 STRING PRIMARY KEY ...);\n"
"-- with column-name and data-type and collate-clause\n"
"CREATE TABLE t (column1 SCALAR COLLATE \"unicode\" ...);"
msgstr ""

#, fuzzy
msgid ""
"-- with all possible data types and aliases\n"
"CREATE TABLE t\n"
"(column1 BOOLEAN, column2 BOOL,\n"
" column3 INT PRIMARY KEY, column4 INTEGER,\n"
" column5 DOUBLE,\n"
" column6 NUMBER,\n"
" column7 STRING, column8 STRING COLLATE \"unicode\",\n"
" column9 TEXT, columna TEXT COLLATE \"unicode_sv_s1\",\n"
" columnb VARCHAR(0), columnc VARCHAR(100000) COLLATE \"binary\",\n"
" columnd UUID,\n"
" columne VARBINARY,\n"
" columnf SCALAR, columng SCALAR COLLATE \"unicode_uk_s2\",\n"
" columnh DECIMAL,\n"
" columni ARRAY,\n"
" columnj MAP,\n"
" columnk ANY);"
msgstr ""
"-- со всеми возможными типами данных и алиасами\n"
"CREATE TABLE t\n"
"(column1 BOOLEAN, column2 BOOL,\n"
" column3 INT PRIMARY KEY, column4 INTEGER,\n"
" column5 DOUBLE,\n"
" column6 NUMBER,\n"
" column7 STRING, column8 STRING COLLATE \"unicode\",\n"
" column9 TEXT, columna TEXT COLLATE \"unicode_sv_s1\",\n"
" columnb VARCHAR(0), columnc VARCHAR(100000) COLLATE \"binary\",\n"
" columnd UUID,\n"
" columne VARBINARY,\n"
" columnf SCALAR, columng SCALAR COLLATE \"unicode_uk_s2\",\n"
" columnh DECIMAL);"

msgid ""
"-- with all possible column constraints and a default clause\n"
"CREATE TABLE t\n"
"(column1 INTEGER NOT NULL,\n"
" column2 INTEGER PRIMARY KEY,\n"
" column3 INTEGER UNIQUE,\n"
" column4 INTEGER CHECK (column3 > column2),\n"
" column5 INTEGER REFERENCES t,\n"
" column6 INTEGER DEFAULT NULL);"
msgstr ""

msgid "Table constraint definition"
msgstr ""

msgid ""
"A table :ref:`constraint <index-constraints>` restricts the data you can add"
" to the table. If you try to insert invalid data on a column, Tarantool "
"throws an error."
msgstr ""

msgid "A table constraint has the following syntax:"
msgstr ""

msgid ""
"[CONSTRAINT [name]] constraint_expression\n"
"\n"
"constraint_expression:\n"
"  | PRIMARY KEY (column_name, ...)\n"
"  | UNIQUE (column_name, ...)\n"
"  | CHECK (expression)\n"
"  | FOREIGN KEY (column_name, ...) foreign_key_clause"
msgstr ""

msgid ""
"Define a constraint, which is a table element used in a CREATE TABLE "
"statement."
msgstr ""

msgid ""
"A constraint name must be an identifier that is valid according to the rules"
" for identifiers. A constraint name must be unique within the table for a "
"specific constraint type. For example, the CHECK and FOREIGN KEY constraints"
" can have the same name."
msgstr ""

msgid "**PRIMARY KEY constraints**"
msgstr ""

msgid "PRIMARY KEY constraints look like this:"
msgstr ""

msgid "PRIMARY KEY (column_name, ...)"
msgstr ""

msgid ""
"There is a shorthand: specifying PRIMARY KEY in a :ref:`column definition "
"<sql_column_def_constraint>`."
msgstr ""

msgid "Every table must have one and only one primary key."
msgstr ""

msgid "Primary-key columns are automatically ``NOT NULL``."
msgstr ""

msgid "Primary-key columns are automatically indexed."
msgstr ""

msgid ""
"Primary-key columns are unique. That means it is illegal to have two rows "
"with the same values for the columns specified in the constraint."
msgstr ""

msgid "**Example 1: one-column primary key**"
msgstr ""

msgid "Create an ``author`` table with the ``id`` primary key column:"
msgstr ""

msgid ""
"CREATE TABLE author (\n"
"    id INTEGER PRIMARY KEY,\n"
"    name STRING NOT NULL\n"
");\n"
msgstr ""

msgid "Insert data into this table:"
msgstr ""

msgid ""
"INSERT INTO author VALUES (1, 'Leo Tolstoy'),\n"
"                          (2, 'Fyodor Dostoevsky');\n"
msgstr ""

msgid ""
"On an attempt to add an author with the existing id, the following error is "
"raised:"
msgstr ""

msgid ""
"INSERT INTO author VALUES (2, 'Alexander Pushkin');\n"
"/*\n"
"- Duplicate key exists in unique index \"pk_unnamed_AUTHOR_1\" in space \"AUTHOR\" with\n"
"  old tuple - [2, \"Fyodor Dostoevsky\"] and new tuple - [2, \"Alexander Pushkin\"]\n"
"*/\n"
msgstr ""

msgid "**Example 2: two-column primary key**"
msgstr ""

msgid "Create a ``book`` table with the primary key defined on two columns:"
msgstr ""

msgid ""
"CREATE TABLE book (\n"
"    id INTEGER,\n"
"    title STRING NOT NULL,\n"
"    PRIMARY KEY (id, title)\n"
");\n"
msgstr ""

msgid ""
"INSERT INTO book VALUES (1, 'War and Peace'),\n"
"                        (2, 'Crime and Punishment');\n"
msgstr ""

msgid "On an attempt to add the existing book, the following error is raised:"
msgstr ""

msgid ""
"INSERT INTO book VALUES (2, 'Crime and Punishment');\n"
"/*\n"
"- Duplicate key exists in unique index \"pk_unnamed_BOOK_1\" in space \"BOOK\" with old\n"
"  tuple - [2, \"Crime and Punishment\"] and new tuple - [2, \"Crime and Punishment\"]\n"
"*/\n"
msgstr ""

msgid ""
"PRIMARY KEY with the AUTOINCREMENT modifier may be specified in one of two "
"ways:"
msgstr ""

msgid ""
"In a column definition after the words PRIMARY KEY, as in ``CREATE TABLE t "
"(c INTEGER PRIMARY KEY AUTOINCREMENT);``"
msgstr ""

msgid ""
"In a PRIMARY KEY (column-list) after a column name, as in ``CREATE TABLE t "
"(c INTEGER, PRIMARY KEY (c AUTOINCREMENT));``"
msgstr ""

msgid ""
"When AUTOINCREMENT is specified, the column must be a primary-key column and"
" it must be INTEGER or UNSIGNED."
msgstr ""

msgid ""
"Only one column in the table may be autoincrement. However, it is legal to "
"say ``PRIMARY KEY (a, b, c AUTOINCREMENT)`` -- in that case, there are three"
" columns in the primary key but only the third column (``c``) is "
"AUTOINCREMENT."
msgstr ""

msgid ""
"As the name suggests, values in an autoincrement column are automatically "
"incremented. That is: if a user inserts NULL in the column, then the stored "
"value will be the smallest non-negative integer that has not already been "
"used. This occurs because autoincrement columns are associated with "
":doc:`sequences "
"</reference/reference_lua/box_schema_sequence/create_index>`."
msgstr ""

msgid "**UNIQUE constraints**"
msgstr ""

msgid "UNIQUE constraints look like this:"
msgstr ""

msgid "UNIQUE (column_name, ...)"
msgstr ""

msgid ""
"There is a shorthand: specifying UNIQUE in a :ref:`column definition "
"<sql_column_def_constraint>`."
msgstr ""

msgid ""
"Unique constraints are similar to primary-key constraints, except that:"
msgstr ""

msgid ""
"A table may have any number of unique keys, and unique keys are not "
"automatically NOT NULL."
msgstr ""

msgid "Unique columns are automatically indexed."
msgstr ""

msgid ""
"Unique columns are unique. That means it is illegal to have two rows with "
"the same values in the unique-key columns."
msgstr ""

msgid "**Example 1: one-column unique constraint**"
msgstr ""

msgid "Create an ``author`` table with the unique ``name`` column:"
msgstr ""

#, fuzzy
msgid ""
"CREATE TABLE author (\n"
"    id INTEGER PRIMARY KEY,\n"
"    name STRING UNIQUE\n"
");\n"
msgstr "CREATE TABLE t (s1 SCALAR PRIMARY KEY, s2 INTEGER);"

msgid ""
"On an attempt to add an author with the same name, the following error is "
"raised:"
msgstr ""

msgid ""
"INSERT INTO author VALUES (3, 'Leo Tolstoy');\n"
"/*\n"
"- Duplicate key exists in unique index \"unique_unnamed_AUTHOR_2\" in space \"AUTHOR\"\n"
"  with old tuple - [1, \"Leo Tolstoy\"] and new tuple - [3, \"Leo Tolstoy\"]\n"
"*/\n"
msgstr ""

msgid "**Example 2: two-column unique constraint**"
msgstr ""

msgid ""
"Create a ``book`` table with the unique constraint defined on two columns:"
msgstr ""

msgid ""
"CREATE TABLE book (\n"
"    id INTEGER PRIMARY KEY,\n"
"    title STRING NOT NULL,\n"
"    author_id INTEGER UNIQUE,\n"
"    UNIQUE (title, author_id)\n"
");\n"
msgstr ""

msgid ""
"INSERT INTO book VALUES (1, 'War and Peace', 1),\n"
"                        (2, 'Crime and Punishment', 2);\n"
msgstr ""

msgid ""
"On an attempt to add a book with duplicated values, the following error is "
"raised:"
msgstr ""

msgid ""
"INSERT INTO book VALUES (3, 'War and Peace', 1);\n"
"/*\n"
"- Duplicate key exists in unique index \"unique_unnamed_BOOK_2\" in space \"BOOK\" with\n"
"  old tuple - [1, \"War and Peace\", 1] and new tuple - [3, \"War and Peace\", 1]\n"
"*/\n"
msgstr ""

msgid "**CHECK constraints**"
msgstr ""

msgid ""
"The CHECK constraint is used to limit the value range that a column can "
"store. CHECK constraints look like this:"
msgstr ""

msgid ""
"There is a shorthand: specifying CHECK in a :ref:`column definition "
"<sql_column_def_constraint>`."
msgstr ""

msgid ""
"The expression may be anything that returns a BOOLEAN result = TRUE or FALSE"
" or UNKNOWN. |br| The expression may not contain a :ref:`subquery "
"<sql_subquery>`. |br| If the expression contains a column name, the column "
"must exist in the table. |br| If a CHECK constraint is specified, the table "
"must not contain rows where the expression is FALSE. (The table may contain "
"rows where the expression is either TRUE or UNKNOWN.) |br| Constraint "
"checking may be stopped with :ref:`ALTER TABLE ... DISABLE CHECK CONSTRAINT "
"<sql_alter_table>` and restarted with ALTER TABLE ... ENABLE CHECK "
"CONSTRAINT."
msgstr ""

#, fuzzy
msgid "**Example**"
msgstr "**Примеры:**"

msgid ""
"Create an ``author`` table with the ``name`` column that should contain "
"values longer than 4 characters:"
msgstr ""

msgid ""
"CREATE TABLE author (\n"
"    id INTEGER PRIMARY KEY,\n"
"    name STRING,\n"
"    CONSTRAINT check_name_length CHECK (CHAR_LENGTH(name) > 4)\n"
");\n"
msgstr ""

msgid ""
"On an attempt to add an author with a name shorter than 5 characters, the "
"following error is raised:"
msgstr ""

msgid ""
"INSERT INTO author VALUES (3, 'Alex');\n"
"/*\n"
"- Check constraint 'CHECK_NAME_LENGTH' failed for tuple\n"
"*/\n"
msgstr ""

msgid "Table constraint definition for foreign keys"
msgstr ""

msgid ""
"A :ref:`foreign key <index-box_foreign_keys>` is a :ref:`constraint <index-"
"constraints>` that can be used to enforce data integrity across related "
"tables. A foreign key constraint is defined on the child table that "
"references the parent table's column values."
msgstr ""

msgid "Foreign key constraints look like this:"
msgstr ""

msgid ""
"FOREIGN KEY (referencing_column_name, ...)\n"
"    REFERENCES referenced_table_name (referenced_column_name, ...)"
msgstr ""

msgid ""
"You can also add a reference in a :ref:`column definition "
"<sql_column_def_constraint>`:"
msgstr ""

msgid ""
"referencing_column_name column_definition\n"
"    REFERENCES referenced_table_name(referenced_column_name)"
msgstr ""

msgid ""
"Since :doc:`2.11.0 </release/2.11.0>`, the following referencing options "
"aren't supported anymore:"
msgstr ""

msgid ""
"The ``ON UPDATE`` and ``ON DELETE`` triggers. The ``RESTRICT`` trigger "
"action is used implicitly."
msgstr ""

msgid "The ``MATCH`` subclause. ``MATCH FULL`` is used implicitly."
msgstr ""

msgid ""
"``DEFERRABLE`` constraints. The ``INITIALLY IMMEDIATE`` constraint check "
"time rule is used implicitly."
msgstr ""

msgid ""
"Note that a referenced column should meet one of the following requirements:"
msgstr ""

msgid "A referenced column is a PRIMARY KEY column."
msgstr ""

msgid "A referenced column has a UNIQUE constraint."
msgstr ""

msgid "A referenced column has a UNIQUE index."
msgstr ""

msgid ""
"Note that before the :doc:`2.11.0 </release/2.11.0>` version, an index "
"existence for the referenced columns is checked when creating a constraint "
"(for example, using ``CREATE TABLE`` or ``ALTER TABLE``). Starting with "
"2.11.0, this check is weakened and the existence of an index is checked "
"during data insertion."
msgstr ""

msgid ""
"This example shows how to create a relation between the parent and child "
"tables through a single-column foreign key:"
msgstr ""

msgid "First, create a parent ``author`` table:"
msgstr ""

msgid ""
"Create a child ``book`` table whose ``author_id`` column references the "
"``id`` column from the ``author`` table:"
msgstr ""

msgid ""
"CREATE TABLE book (\n"
"    id INTEGER PRIMARY KEY,\n"
"    title STRING NOT NULL,\n"
"    author_id INTEGER NOT NULL UNIQUE,\n"
"    FOREIGN KEY (author_id)\n"
"        REFERENCES author (id)\n"
");\n"
msgstr ""

msgid "Alternatively, you can add a reference in a column definition:"
msgstr ""

msgid ""
"CREATE TABLE book (\n"
"    id INTEGER PRIMARY KEY,\n"
"    title STRING NOT NULL,\n"
"    author_id INTEGER NOT NULL UNIQUE REFERENCES author(id)\n"
");"
msgstr ""

msgid "Insert data to the ``book`` table:"
msgstr ""

msgid ""
"Check how the created foreign key constraint enforces data integrity. The "
"following error is raised on an attempt to insert a new book with the "
"``author_id`` value that doesn't exist in the parent ``author`` table:"
msgstr ""

msgid ""
"INSERT INTO book VALUES (3, 'Eugene Onegin', 3);\n"
"/*\n"
"- 'Foreign key constraint ''fk_unnamed_BOOK_1'' failed: foreign tuple was not found'\n"
"*/\n"
msgstr ""

msgid ""
"On an attempt to delete an author that already has books in the ``book`` "
"table, the following error is raised:"
msgstr ""

msgid ""
"DELETE FROM author WHERE id = 2;\n"
"/*\n"
"- 'Foreign key ''fk_unnamed_BOOK_1'' integrity check failed: tuple is referenced'\n"
"*/\n"
msgstr ""

msgid "DROP TABLE"
msgstr ""

msgid ":samp:`DROP TABLE [IF EXISTS] {table-name};`"
msgstr ""

msgid "Drop a table."
msgstr ""

msgid ""
"The *table-name* must identify a table that was created earlier with the "
":ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

msgid ""
"If there is a view that references the table, the drop will fail. Please "
"drop the referencing view with :ref:`DROP VIEW <sql_drop_view>` first."
msgstr ""

msgid ""
"If there is a foreign key that references the table, the drop will fail. "
"Please drop the referencing constraint with :ref:`ALTER TABLE ... DROP "
"<sql_alter_table_drop_constraint>` first."
msgstr ""

msgid ""
"Tarantool returns an error if the table does not exist and there is no ``IF "
"EXISTS`` clause."
msgstr ""

msgid "The table and all its data are dropped."
msgstr ""

msgid "All indexes for the table are dropped."
msgstr ""

msgid "All triggers for the table are dropped."
msgstr ""

msgid ""
"-- the simple case:\n"
"DROP TABLE t31;\n"
"-- with an IF EXISTS clause:\n"
"DROP TABLE IF EXISTS t31;"
msgstr ""

msgid "See also: :ref:`DROP VIEW <sql_drop_view>`."
msgstr ""

msgid "CREATE VIEW"
msgstr ""

msgid ""
":samp:`CREATE VIEW [IF NOT EXISTS] {view-name} [(column-list)] AS subquery;`"
msgstr ""

msgid "Create a new viewed table, usually called a \"view\"."
msgstr ""

msgid "The *view-name* must be valid according to the rules for identifiers."
msgstr ""

msgid ""
"The optional *column-list* must be a comma-separated list of names of "
"columns in the view."
msgstr ""

msgid ""
"The syntax of the subquery must be the same as the syntax of a :ref:`SELECT "
"statement <sql_select>`, or of a VALUES clause."
msgstr ""

msgid ""
"There must not already be a base table or view with the same name as *view-"
"name*."
msgstr ""

msgid ""
"If *column-list* is specified, the number of columns in *column-list* must "
"be the same as the number of columns in the :ref:`select list "
"<sql_select_list>` of the subquery."
msgstr ""

msgid "Tarantool will throw an error if a rule is violated."
msgstr ""

msgid ""
"Tarantool will create a new persistent object with *column-names* equal to "
"the names in the *column-list* or the names in the subquery's *select list*."
msgstr ""

msgid ""
"-- the simple case:\n"
"CREATE VIEW v AS SELECT column1, column2 FROM t;\n"
"-- with a column-list:\n"
"CREATE VIEW v (a,b) AS SELECT column1, column2 FROM t;"
msgstr ""

msgid ""
"It is not possible to insert or update or delete from a view, although "
"sometimes a possible substitution is to :ref:`create an INSTEAD OF trigger "
"<sql_create_trigger>`."
msgstr ""

msgid "DROP VIEW"
msgstr ""

msgid ":samp:`DROP VIEW [IF EXISTS] {view-name};`"
msgstr ""

msgid "Drop a view."
msgstr ""

msgid ""
"The *view-name* must identify a view that was created earlier with the "
":ref:`CREATE VIEW statement <sql_create_view>`."
msgstr ""

msgid "Rules: none"
msgstr ""

msgid ""
"Tarantool returns an error if the view does not exist and there is no ``IF "
"EXISTS`` clause."
msgstr ""

msgid "The view is dropped."
msgstr ""

msgid "All triggers for the view are dropped."
msgstr ""

msgid ""
"-- the simple case:\n"
"DROP VIEW v31;\n"
"-- with an IF EXISTS clause:\n"
"DROP VIEW IF EXISTS v31;"
msgstr ""

msgid "See also: :ref:`DROP TABLE <sql_drop_table>`."
msgstr ""

msgid "CREATE INDEX"
msgstr ""

msgid ""
":samp:`CREATE [UNIQUE] INDEX [IF NOT EXISTS] {index-name} ON {table-name} "
"(column-list);`"
msgstr ""

msgid "Create an index."
msgstr ""

msgid "The *index-name* must be valid according to the rules for identifiers."
msgstr ""

msgid "The *table-name* must refer to an existing table."
msgstr ""

msgid ""
"The *column-list* must be a comma-separated list of names of columns in the "
"table."
msgstr ""

msgid ""
"There must not already be, for the same table, an index with the same name "
"as *index-name*. But there may already be, for a different table, an index "
"with the same name as *index-name*."
msgstr ""

msgid "The maximum number of indexes per table is 128."
msgstr ""

msgid ""
"If the new index is UNIQUE, Tarantool will throw an error if any row exists "
"with columns that have duplicate values."
msgstr ""

msgid "Tarantool will create a new index."
msgstr ""

msgid "Automatic indexes:"
msgstr ""

msgid ""
"Indexes may be created automatically for columns mentioned in the PRIMARY "
"KEY or UNIQUE clauses of a CREATE TABLE statement. If an index was created "
"automatically, then the *index-name* has four parts:"
msgstr ""

msgid ""
"``pk`` if this is for a PRIMARY KEY clause, ``unique`` if this is for a "
"UNIQUE clause;"
msgstr ""

msgid "``_unnamed_``;"
msgstr ""

msgid "the name of the table;"
msgstr ""

msgid ""
"``_`` and an ordinal number; the first index is 1, the second index is 2, "
"and so on."
msgstr ""

msgid ""
"For example, after ``CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER, "
"UNIQUE (s2));`` there are two indexes named ``pk_unnamed_T_1`` and "
"``unique_unnamed_T_2``. You can confirm this by saying ``SELECT * FROM "
"\"_index\";`` which will list all indexes on all tables. There is no need to"
" say ``CREATE INDEX`` for columns that already have automatic indexes."
msgstr ""

msgid ""
"-- the simple case\n"
"CREATE INDEX idx_column1_t_1 ON t (column1);\n"
"-- with IF NOT EXISTS clause\n"
"CREATE INDEX IF NOT EXISTS idx_column1_t_1 ON t (column1);\n"
"-- with UNIQUE specifier and more than one column\n"
"CREATE UNIQUE INDEX idx_unnamed_t_1 ON t (column1, column2);"
msgstr ""

msgid ""
"Dropping an automatic index created for a unique constraint will drop the "
"unique constraint as well."
msgstr ""

msgid "DROP INDEX"
msgstr ""

msgid ":samp:`DROP INDEX [IF EXISTS] index-name ON {table-name};`"
msgstr ""

msgid ""
"The *index-name* must be the name of an existing index, which was created "
"with :ref:`CREATE INDEX <sql_create_index>`. Or, the *index-name* must be "
"the name of an index that was created automatically due to a PRIMARY KEY or "
"UNIQUE clause in the :ref:`CREATE TABLE <sql_create_table>` statement. To "
"see what a table's indexes are, use :ref:`PRAGMA index_list(table-name); "
"<sql_pragma>`."
msgstr ""

msgid ""
"Tarantool throws an error if the index does not exist, or is an "
"automatically created index."
msgstr ""

msgid "Tarantool will drop the index."
msgstr ""

msgid "Example:"
msgstr "Пример:"

msgid ""
"-- the simplest form:\n"
"DROP INDEX idx_unnamed_t_1 ON t;"
msgstr ""

msgid "CREATE TRIGGER"
msgstr ""

msgid ""
":samp:`CREATE TRIGGER [IF NOT EXISTS] {trigger-name}` |br| "
":samp:`BEFORE|AFTER|INSTEAD OF` |br| :samp:`DELETE|INSERT|UPDATE ON {table-"
"name}` |br| :samp:`FOR EACH ROW` |br| :samp:`[WHEN search-condition]` |br| "
":samp:`BEGIN` |br| :samp:`delete-statement | insert-statement | replace-"
"statement | select-statement | update-statement;` |br| :samp:`[delete-"
"statement | insert-statement | replace-statement | select-statement | "
"update-statement; ...]` |br| :samp:`END;`"
msgstr ""

msgid ""
"The *trigger-name* must be valid according to the rules for identifiers."
msgstr ""

msgid ""
"If the trigger action time is BEFORE or AFTER, then the *table-name* must "
"refer to an existing base table."
msgstr ""

msgid ""
"If the trigger action time is INSTEAD OF, then the *table-name* must refer "
"to an existing view."
msgstr ""

msgid ""
"There must not already be a trigger with the same name as *trigger-name*."
msgstr ""

msgid "Triggers on different tables or views share the same namespace."
msgstr ""

msgid ""
"The statements between BEGIN and END should not refer to the *table-name* "
"mentioned in the ON clause."
msgstr ""

msgid ""
"The statements between BEGIN and END should not contain an :ref:`INDEXED BY "
"<sql_indexed_by>` clause."
msgstr ""

msgid ""
"SQL triggers are not activated by Tarantool/NoSQL requests. This will change"
" in a future version."
msgstr ""

msgid ""
"On a :ref:`replica <Replication>`, effects of trigger execution are applied,"
" and the SQL triggers themselves are not activated upon replication events."
msgstr ""

msgid ""
"NoSQL triggers are activated both on replica and master, thus if you have a "
":ref:`NoSQL trigger <triggers>` on a replica, it is activated when applying "
"effects of an SQL trigger."
msgstr ""

msgid "Tarantool will create a new trigger."
msgstr ""

msgid ""
"-- the simple case:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with IF NOT EXISTS clause:\n"
"CREATE TRIGGER IF NOT EXISTS stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with FOR EACH ROW and WHEN clauses:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW WHEN a=5\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with multiple statements between BEGIN and END:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; INSERT INTO inventories VALUES (1); END;"
msgstr ""

msgid "Trigger extra clauses"
msgstr ""

msgid ":samp:`UPDATE OF column-list`"
msgstr ""

msgid ""
"After BEFORE|AFTER UPDATE it is optional to add ``OF column-list``. If any "
"of the columns in *column-list* is affected at the time the row is "
"processed, then the trigger will be activated for that row. For example:"
msgstr ""

msgid ""
"CREATE TRIGGER table1_before_update\n"
" BEFORE UPDATE  OF column1, column2 ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"UPDATE table1 SET column3 = column3 + 1; -- Trigger will not be activated\n"
"UPDATE table1 SET column2 = column2 + 0; -- Trigger will be activated"
msgstr ""

msgid ":samp:`WHEN`"
msgstr ""

msgid ""
"After *table-name* FOR EACH ROW it is optional to add [``WHEN expression``]."
" If the expression is true at the time the row is processed, only then will "
"the trigger will be activated for that row. For example:"
msgstr ""

msgid ""
"CREATE TRIGGER table1_before_update BEFORE UPDATE ON table1 FOR EACH ROW\n"
" WHEN (SELECT COUNT(*) FROM table1) > 1\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;"
msgstr ""

msgid ""
"This trigger will not be activated unless there is more than one row in "
"``table1``."
msgstr ""

msgid ":samp:`OLD and NEW`"
msgstr ""

msgid ""
"The keywords OLD and NEW have special meaning in the context of trigger "
"action:"
msgstr ""

msgid ""
"OLD.column-name refers to the value of *column-name* before the change."
msgstr ""

msgid "NEW.column-name refers to the value of *column-name* after the change."
msgstr ""

msgid "For example:"
msgstr "Пример:"

msgid ""
"CREATE TABLE table1 (column1 STRING, column2 INTEGER PRIMARY KEY);\n"
"CREATE TABLE table2 (column1 STRING, column2 STRING, column3 INTEGER PRIMARY KEY);\n"
"INSERT INTO table1 VALUES ('old value', 1);\n"
"INSERT INTO table2 VALUES ('', '', 1);\n"
"CREATE TRIGGER table1_before_update BEFORE UPDATE ON table1 FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = old.column1, column2 = new.column1; END;\n"
"UPDATE table1 SET column1 = 'new value';\n"
"SELECT * FROM table2;"
msgstr ""

msgid ""
"At the beginning of the UPDATE for the single row of ``table1``, the value "
"in ``column1`` is 'old value' -- so that is what is seen as ``old.column1``."
msgstr ""

msgid ""
"At the end of the UPDATE for the single row of ``table1``, the value in "
"``column1`` is 'new value' -- so that is what is seen as ``new.column1``. "
"(OLD and NEW are qualifiers for ``table1``, not ``table2.``)"
msgstr ""

msgid ""
"Therefore, ``SELECT * FROM table2;`` returns ``['old value', 'new value']``."
msgstr ""

msgid "``OLD.column-name`` does not exist for an INSERT trigger."
msgstr ""

msgid "``NEW.column-name`` does not exist for a DELETE trigger."
msgstr ""

msgid "OLD and NEW are read-only; you cannot change their values."
msgstr ""

msgid "Deprecated or illegal statements:"
msgstr ""

msgid ""
"It is illegal for the trigger action to include a qualified column reference"
" other than ``OLD.column-name`` or ``NEW.column-name``. For example, "
"``CREATE TRIGGER ... BEGIN UPDATE table1 SET table1.column1 = 5; END;`` is "
"illegal."
msgstr ""

msgid ""
"It is illegal for the trigger action to include statements that include a "
":ref:`WITH clause <sql_with>`, a DEFAULT VALUES clause, or an :ref:`INDEXED "
"BY <sql_indexed_by>` clause."
msgstr ""

msgid ""
"It is usually not a good idea to have a trigger on ``table1`` which causes a"
" change on ``table2``, and at the same time have a trigger on ``table2`` "
"which causes a change on ``table1``. For example:"
msgstr ""

msgid ""
"CREATE TRIGGER table1_before_update\n"
" BEFORE UPDATE ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"CREATE TRIGGER table2_before_update\n"
" BEFORE UPDATE ON table2\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table1 SET column1 = column1 + 1; END;"
msgstr ""

msgid ""
"Luckily ``UPDATE table1 ...`` will not cause an infinite loop, because "
"Tarantool recognizes when it has already updated so it will stop. However, "
"not every DBMS acts this way."
msgstr ""

msgid "Trigger activation"
msgstr ""

msgid "These are remarks concerning trigger activation."
msgstr ""

msgid "Standard terminology:"
msgstr ""

msgid "\"trigger action time\" = BEFORE or AFTER or INSTEAD OF"
msgstr ""

msgid "\"trigger event\" = INSERT or DELETE or UPDATE"
msgstr ""

msgid ""
"\"triggered statement\" = BEGIN ... DELETE|INSERT|REPLACE|SELECT|UPDATE ... "
"END"
msgstr ""

msgid "\"triggered when clause\" = WHEN search-condition"
msgstr ""

msgid "\"activate\" = execute a triggered statement"
msgstr ""

msgid "some vendors use the word \"fire\" instead of \"activate\""
msgstr ""

msgid ""
"If there is more than one trigger for the same trigger event, Tarantool may "
"execute the triggers in any order."
msgstr ""

msgid ""
"It is possible for a triggered statement to cause activation of another "
"triggered statement. For example, this is legal:"
msgstr ""

msgid ""
"CREATE TRIGGER t1_before_delete BEFORE DELETE ON t1 FOR EACH ROW BEGIN DELETE FROM t2; END;\n"
"CREATE TRIGGER t2_before_delete BEFORE DELETE ON t2 FOR EACH ROW BEGIN DELETE FROM t3; END;"
msgstr ""

msgid ""
"Activation occurs FOR EACH ROW, not FOR EACH STATEMENT. Therefore, if no "
"rows are candidates for insert or update or delete, then no triggers are "
"activated."
msgstr ""

msgid "The BEFORE trigger is activated even if the trigger event fails."
msgstr ""

msgid ""
"If an UPDATE trigger event does not make a change, the trigger is activated "
"anyway. For example, if row 1 ``column1`` contains ``'a'``, and the trigger "
"event is ``UPDATE ... SET column1 = 'a';``, the trigger is activated."
msgstr ""

msgid ""
"The triggered statement may refer to a function: ``RAISE(FAIL, error-"
"message)``. If a triggered statement invokes a ``RAISE(FAIL, error-"
"message)`` function, or if a triggered statement causes an error, then "
"statement execution stops immediately."
msgstr ""

msgid ""
"The triggered statement may refer to column values within the rows being "
"changed. in this case:"
msgstr ""

msgid ""
"The row \"as of before\" the change is called the \"old\" row (which makes "
"sense only for UPDATE and DELETE statements)."
msgstr ""

msgid ""
"The row \"as of after\" the change is called the \"new\" row (which makes "
"sense only for UPDATE and INSERT statements)."
msgstr ""

msgid ""
"This example shows how an INSERT can be done to a view by referring to the "
"\"new\" row:"
msgstr ""

msgid ""
"CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"CREATE VIEW v AS SELECT s1, s2 FROM t;\n"
"CREATE TRIGGER v_instead_of INSTEAD OF INSERT ON v\n"
"  FOR EACH ROW\n"
"  BEGIN INSERT INTO t VALUES (new.s1, new.s2); END;\n"
"INSERT INTO v VALUES (1, 2);"
msgstr ""

msgid ""
"Ordinarily saying ``INSERT INTO view_name ...`` is illegal in Tarantool, so "
"this is a workaround."
msgstr ""

msgid ""
"It is possible to generalize this so that all data-change statements on "
"views will change the base tables, provided that the view contains all the "
"columns of the base table, and provided that the triggers refer to those "
"columns when necessary, as in this example:"
msgstr ""

msgid ""
"CREATE TABLE base_table (primary_key_column INTEGER PRIMARY KEY, value_column INTEGER);\n"
"CREATE VIEW viewed_table AS SELECT primary_key_column, value_column FROM base_table;\n"
"CREATE TRIGGER viewed_table_instead_of_insert INSTEAD OF INSERT ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    INSERT INTO base_table VALUES (new.primary_key_column, new.value_column); END;\n"
"CREATE TRIGGER viewed_table_instead_of_update INSTEAD OF UPDATE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    UPDATE base_table\n"
"    SET primary_key_column = new.primary_key_column, value_column = new.value_column\n"
"    WHERE primary_key_column = old.primary_key_column; END;\n"
"CREATE TRIGGER viewed_table_instead_of_delete INSTEAD OF DELETE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    DELETE FROM base_table WHERE primary_key_column = old.primary_key_column; END;"
msgstr ""

msgid ""
"When INSERT or UPDATE or DELETE occurs for table ``X``, Tarantool usually "
"operates in this order (a basic scheme):"
msgstr ""

msgid ""
"For each row\n"
"  Perform constraint checks\n"
"  For each BEFORE trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the triggered statement.\n"
"  Insert or update or delete the row in table X.\n"
"  Perform more constraint checks\n"
"  For each AFTER trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the triggered statement."
msgstr ""

msgid ""
"However, Tarantool does not guarantee execution order when there are "
"multiple constraints, or multiple triggers for the same event (including "
"NoSQL :ref:`on_replace triggers <box_space-on_replace>` or SQL :ref:`INSTEAD"
" OF triggers <sql_instead_of_triggers>` that affect a view of table ``X``)."
msgstr ""

msgid "The maximum number of trigger activations per statement is 32."
msgstr ""

msgid "INSTEAD OF triggers"
msgstr ""

msgid ""
"A trigger which is created with the clause |br| :samp:`INSTEAD OF "
"{INSERT|UPDATE|DELETE} ON {view-name}` |br| is an INSTEAD OF trigger. For "
"each affected row, the trigger action is performed \"instead of\" the INSERT"
" or UPDATE or DELETE statement that causes trigger activation."
msgstr ""

msgid ""
"For example, ordinarily it is illegal to INSERT rows in a view, but it is "
"legal to create a trigger which intercepts attempts to INSERT, and puts rows"
" in the underlying base table:"
msgstr ""

msgid ""
"CREATE TABLE t1 (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
"CREATE VIEW v1 AS SELECT column1, column2 FROM t1;\n"
"CREATE TRIGGER v1_instead_of INSTEAD OF INSERT ON v1 FOR EACH ROW BEGIN\n"
" INSERT INTO t1 VALUES (NEW.column1, NEW.column2); END;\n"
"INSERT INTO v1 VALUES (1, 1);\n"
"-- ... The result will be: table t1 will contain a new row."
msgstr ""

msgid ""
"INSTEAD OF triggers are only legal for views, while BEFORE or AFTER triggers"
" are only legal for base tables."
msgstr ""

msgid "It is legal to create INSTEAD OF triggers with triggered WHEN clauses."
msgstr ""

msgid ""
"It is legal to create INSTEAD OF triggers with UPDATE OF *column-list* "
"clauses, but they are not standard SQL."
msgstr ""

msgid ""
"CREATE TRIGGER ev1_instead_of_update\n"
"  INSTEAD OF UPDATE OF column2,column1 ON ev1\n"
"  FOR EACH ROW BEGIN\n"
"  INSERT INTO et2 VALUES (NEW.column1, NEW.column2); END;"
msgstr ""

msgid "DROP TRIGGER"
msgstr ""

msgid ":samp:`DROP TRIGGER [IF EXISTS] {trigger-name};`"
msgstr ""

msgid "Drop a trigger."
msgstr ""

msgid ""
"The *trigger-name* must identify a trigger that was created earlier with the"
" :ref:`CREATE TRIGGER <sql_create_trigger>` statement."
msgstr ""

msgid ""
"Tarantool returns an error if the trigger does not exist and there is no "
"``IF EXISTS`` clause."
msgstr ""

msgid "The trigger is dropped."
msgstr ""

msgid ""
"-- the simple case:\n"
"DROP TRIGGER table1_before_insert;\n"
"-- with an IF EXISTS clause:\n"
"DROP TRIGGER IF EXISTS table1_before_insert;"
msgstr ""

msgid "Statements that change data"
msgstr ""

msgid "INSERT"
msgstr "INSERT"

msgid ""
":samp:`INSERT INTO {table-name} [(column-list)] VALUES (expression-list) [, "
"(expression-list)];`"
msgstr ""

msgid ":samp:`INSERT INTO {table-name} [(column-list)]  select-statement;`"
msgstr ""

msgid ":samp:`INSERT INTO {table-name} DEFAULT VALUES;`"
msgstr ""

msgid "Insert one or more new rows into a table."
msgstr ""

msgid ""
"The *table-name* must be a name of a table defined earlier with :ref:`CREATE"
" TABLE <sql_create_table>`."
msgstr ""

msgid ""
"The optional *column-list* must be a comma-separated list of names of "
"columns in the table."
msgstr ""

msgid ""
"The *expression-list* must be a comma-separated list of expressions; each "
"expression may contain literals and operators and subqueries and function "
"invocations."
msgstr ""

msgid "The values in the *expression-list* are evaluated from left to right."
msgstr ""

msgid ""
"The order of the values in the *expression-list* must correspond to the "
"order of the columns in the table, or (if a *column-list* is specified) to "
"the order of the columns in the *column-list*."
msgstr ""

msgid ""
"The data type of the value should correspond to the :ref:`data type of the "
"column <sql_column_def_data_type>`, that is, the data type that was "
"specified with CREATE TABLE."
msgstr ""

msgid ""
"If a *column-list* is not specified, then the number of expressions must be "
"the same as the number of columns in the table."
msgstr ""

msgid ""
"If a *column-list* is specified, then some columns may be omitted; omitted "
"columns will get default values."
msgstr ""

msgid ""
"The parenthesized *expression-list* may be repeated -- ``(expression-"
"list),(expression-list),...`` -- for multiple rows."
msgstr ""

msgid ""
"Tarantool evaluates each expression in *expression-list*, and returns an "
"error if any of the rules is violated."
msgstr ""

msgid ""
"Tarantool creates zero or more new rows containing values based on the "
"values in the VALUES list or based on the results of the *select-expression*"
" or based on the default values."
msgstr ""

msgid ""
"Tarantool executes constraint checks and trigger actions and the actual "
"insertion."
msgstr ""

msgid ""
"-- the simplest form:\n"
"INSERT INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"INSERT INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"INSERT INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"INSERT INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

msgid "See also: :ref:`REPLACE statement <sql_replace>`."
msgstr ""

msgid "UPDATE"
msgstr "UPDATE"

msgid ""
":samp:`UPDATE {table-name} SET column-name = expression [, column-name = "
"expression ...] [WHERE search-condition];`"
msgstr ""

msgid "Update zero or more existing rows in a table."
msgstr ""

msgid ""
"The *table-name* must be a name of a table defined earlier with :ref:`CREATE"
" TABLE <sql_create_table>` or :ref:`CREATE VIEW <sql_create_view>`."
msgstr ""

msgid "The *column-name* must be an updatable column in the table."
msgstr ""

msgid ""
"The *expression* may contain literals and operators and subqueries and "
"function invocations and column names."
msgstr ""

msgid "The values in the SET clause are evaluated from left to right."
msgstr ""

msgid ""
"If a *search-condition* is not specified, then all rows in the table will be"
" updated; otherwise only those rows which match the *search-condition* will "
"be updated."
msgstr ""

msgid ""
"Tarantool evaluates each expression in the SET clause, and returns an error "
"if any of the rules is violated. For each row that is found by the WHERE "
"clause, a temporary new row is formed based on the original contents and the"
" modifications caused by the SET clause."
msgstr ""

msgid ""
"Tarantool executes constraint checks and trigger actions and the actual "
"update."
msgstr ""

msgid ""
"-- the simplest form:\n"
"UPDATE t SET column1 = 1;\n"
"-- with more than one assignment in the SET clause:\n"
"UPDATE t SET column1 = 1, column2 = 2;\n"
"-- with a WHERE clause:\n"
"UPDATE t SET column1 = 5 WHERE column2 = 6;"
msgstr ""

msgid "Special cases:"
msgstr ""

msgid ""
"It is legal to say SET (list of columns) = (list of values). For example:"
msgstr ""

msgid "UPDATE t SET (column1, column2, column3) = (1, 2, 3);"
msgstr ""

msgid "It is not legal to assign to a column more than once. For example:"
msgstr ""

msgid ""
"INSERT INTO t (column1) VALUES (0);\n"
"UPDATE t SET column1 = column1 + 1, column1 = column1 + 1;"
msgstr ""

msgid "The result is an error: \"duplicate column name\"."
msgstr ""

msgid "It is not legal to assign to a primary-key column."
msgstr ""

msgid "DELETE"
msgstr "DELETE"

msgid ":samp:`DELETE FROM {table-name} [WHERE search-condition];`"
msgstr ""

msgid "Delete zero or more existing rows in a table."
msgstr ""

msgid ""
"The *search-condition* may contain literals and operators and subqueries and"
" function invocations and column names."
msgstr ""

msgid ""
"If a search-condition is not specified, then all rows in the table will be "
"deleted; otherwise only those rows which match the *search-condition* will "
"be deleted."
msgstr ""

msgid ""
"Tarantool evaluates each expression in the *search-condition*, and returns "
"an error if any of the rules is violated."
msgstr ""

msgid "Tarantool finds the set of rows that are to be deleted."
msgstr ""

msgid ""
"Tarantool executes constraint checks and trigger actions and the actual "
"deletion."
msgstr ""

msgid ""
"-- the simplest form:\n"
"DELETE FROM t;\n"
"-- with a WHERE clause:\n"
"DELETE FROM t WHERE column2 = 6;"
msgstr ""

msgid "REPLACE"
msgstr "REPLACE"

msgid ""
":samp:`REPLACE INTO {table-name} [(column-list)] VALUES (expression-list) [,"
" (expression-list)];`"
msgstr ""

msgid ":samp:`REPLACE INTO {table-name} [(column-list)] select-statement;`"
msgstr ""

msgid ":samp:`REPLACE INTO {table-name} DEFAULT VALUES;`"
msgstr ""

msgid "Insert one or more new rows into a table, or update existing rows."
msgstr ""

msgid ""
"If a row already exists (as determined by the primary key or any unique "
"key), then the action is delete + insert, and the rules are the same as for "
"a :ref:`DELETE statement <sql_delete>` followed by an :ref:`INSERT statement"
" <sql_insert>`. Otherwise the action is insert, and the rules are the same "
"as for the INSERT statement."
msgstr ""

msgid ""
"-- the simplest form:\n"
"REPLACE INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"REPLACE INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"REPLACE INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"REPLACE INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

msgid ""
"See also: :ref:`INSERT Statement <sql_insert>`, :ref:`UPDATE Statement "
"<sql_update>`."
msgstr ""

msgid "TRUNCATE"
msgstr ""

msgid ":samp:`TRUNCATE TABLE {table-name};`"
msgstr ""

msgid "Remove all rows in the table."
msgstr ""

msgid ""
"TRUNCATE is considered to be a schema-change rather than a data-change "
"statement, so it does not work within transactions (it cannot be "
":ref:`rolled back <sql_rollback>`)."
msgstr ""

msgid ""
"It is illegal to truncate a table which is referenced by a foreign key."
msgstr ""

msgid ""
"It is illegal to truncate a table which is also a system space, such as "
"``_space``."
msgstr ""

msgid "The table must be a base table rather than a view."
msgstr ""

msgid ""
"All rows in the table are removed. Usually this is faster than :samp:`DELETE"
" FROM {table-name};`."
msgstr ""

msgid ""
"If the table has an autoincrement primary key, its :doc:`sequence "
"</reference/reference_lua/box_schema_sequence/create_index>` is not reset to"
" zero, but that may occur in a future Tarantool version."
msgstr ""

msgid "There is no effect for any triggers associated with the table."
msgstr ""

msgid "There is no effect on the counts for the ``ROW_COUNT()`` function."
msgstr ""

msgid ""
"Only one action is written to the :ref:`write-ahead log <internals-wal>` "
"(with :samp:`DELETE FROM {table-name};` there would be one action for each "
"deleted row)."
msgstr ""

msgid "TRUNCATE TABLE t;"
msgstr ""

msgid "SET"
msgstr ""

msgid ":samp:`SET SESSION {setting-name} = {setting-value};`"
msgstr ""

msgid ""
"``SET SESSION`` is a shorthand way to update the "
":ref:`box.space._session_settings <box_space-session_settings>` temporary "
"system space."
msgstr ""

msgid "``setting-name`` can have the following values:"
msgstr ""

msgid "``\"sql_default_engine\"``"
msgstr ""

msgid "``\"sql_full_column_names\"``"
msgstr ""

msgid "``\"sql_full_metadata\"``"
msgstr ""

msgid "``\"sql_parser_debug\"``"
msgstr ""

msgid "``\"sql_recursive_triggers\"``"
msgstr ""

msgid "``\"sql_reverse_unordered_selects\"``"
msgstr ""

msgid "``\"sql_select_debug\"``"
msgstr ""

msgid "``\"sql_vdbe_debug\"``"
msgstr ""

msgid ""
"``\"sql_defer_foreign_keys\"`` (removed in :doc:`2.11.0 </release/2.11.0>`)"
msgstr ""

msgid ""
"``\"error_marshaling_enabled\"`` (removed in :doc:`2.10.0 "
"</release/2.10.0>`)"
msgstr ""

msgid "The quote marks are necessary."
msgstr ""

msgid ""
"If ``setting-name`` is ``\"sql_default_engine\"``, then ``setting-value`` "
"can be either 'vinyl' or 'memtx'. Otherwise, ``setting-value`` can be either"
" TRUE or FALSE."
msgstr ""

msgid ""
"Example: ``SET SESSION \"sql_default_engine\" = 'vinyl';`` changes the "
"default engine to 'vinyl' instead of 'memtx', and returns:"
msgstr ""

msgid ""
"---\n"
"- row_count: 1\n"
"..."
msgstr ""

msgid ""
"It is functionally the same thing as an :ref:`UPDATE Statement "
"<sql_update>`:"
msgstr ""

msgid ""
"UPDATE \"_session_settings\"\n"
"SET \"value\" = 'vinyl'\n"
"WHERE \"name\" = 'sql_default_engine';"
msgstr ""

msgid "Statements that retrieve data"
msgstr ""

msgid "SELECT"
msgstr "SELECT"

msgid ""
":samp:`SELECT [ALL|DISTINCT] select list [from clause] [where clause] "
"[group-by clause] [having clause] [order-by clause];`"
msgstr ""

msgid "Select zero or more rows."
msgstr ""

msgid ""
"The clauses of the SELECT statement are discussed in the following five "
"sections."
msgstr ""

msgid "Select list"
msgstr ""

msgid ":samp:`select-list-column [, select-list-column ...]`"
msgstr ""

msgid "select-list-column:"
msgstr ""

msgid ""
"Define what will be in a result set; this is a clause in a :ref:`SELECT "
"statement <sql_select>`."
msgstr ""

msgid ""
"The *select list* is a comma-delimited list of expressions, or ``*`` "
"(asterisk). An expression can have an alias provided with an ``[[AS] column-"
"name]`` clause."
msgstr ""

msgid ""
"The ``*`` \"asterisk\" shorthand is valid if and only if the SELECT "
"statement also contains a :ref:`FROM clause <sql_from>` which specifies the "
"table or tables (details about the FROM clause are in the next section). The"
" simple form is ``*`` which means \"all columns\" -- for example, if the "
"select is done for a table which contains three columns ``s1`` ``s2`` "
"``s3``, then ``SELECT * ...`` is equivalent to ``SELECT s1, s2, s3 ...``. "
"The qualified form is ``table-name.*`` which means \"all columns in the "
"specified table\", which again must be a result of the FROM clause -- for "
"example, if the table is named ``table1``, then ``table1.*`` is equivalent "
"to a list of the columns of ``table1``."
msgstr ""

msgid ""
"The ``[[AS] column-name]`` clause determines the column name. The column "
"name is useful for two reasons:"
msgstr ""

msgid "in a tabular display, the column names are the headings"
msgstr ""

msgid ""
"if the results of the SELECT are used when creating a new table (such as a "
"view), then the column names in the new table will be the column names in "
"the *select list*."
msgstr ""

msgid ""
"If ``[[AS] column-name]`` is missing, and the expression is not simply the "
"name of a column in the table, then Tarantool makes a name "
":samp:`COLUMN_{n}` where :samp:`{n}` is the number of the non-simple "
"expression within the select list, for example ``SELECT 5.88, table1.x, 'b' "
"COLLATE \"unicode_ci\" FROM table1;`` will cause the column names to be "
"COLUMN_1, X, COLUMN_2. This is a behavior change since version :doc:`2.5.1 "
"</release/2.5.1>`. In earlier versions, the name would be equal to the "
"expression; see `Issue#3962 "
"<https://github.com/tarantool/tarantool/issues/3962>`_. It is still legal to"
" define tables with column names like ``COLUMN_1`` but not recommended."
msgstr ""

msgid ""
"-- the simple form:\n"
"SELECT 5;\n"
"-- with multiple expressions including operators:\n"
"SELECT 1, 2 * 2, 'Three' || 'Four';\n"
"-- with [[AS] column-name] clause:\n"
"SELECT 5 AS column1;\n"
"-- * which must be eventually followed by a FROM clause:\n"
"SELECT * FROM table1;\n"
"-- as a list:\n"
"SELECT 1 AS a, 2 AS b, table1.* FROM table1;"
msgstr ""

msgid "FROM clause"
msgstr ""

msgid ":samp:`FROM [SEQSCAN] table-reference [, table-reference ...]`"
msgstr ""

msgid ""
"Specify the table or tables for the source of a :ref:`SELECT statement "
"<sql_select>`."
msgstr ""

msgid ""
"The *table-reference* must be a name of an existing table, or a subquery, or"
" a joined table."
msgstr ""

msgid "A joined table looks like this:"
msgstr ""

msgid ""
":samp:`table-reference-or-joined-table join-operator table-reference-or-"
"joined-table [join-specification]`"
msgstr ""

msgid ""
"A *join-operator* must be any of `the standard types "
"<https://en.wikipedia.org/wiki/Join_(SQL)>`_:"
msgstr ""

msgid "[NATURAL] LEFT [OUTER] JOIN,"
msgstr ""

msgid "[NATURAL] INNER JOIN, or"
msgstr ""

msgid "CROSS JOIN"
msgstr ""

msgid "A *join-specification* must be any of:"
msgstr ""

msgid "ON expression, or"
msgstr ""

msgid "USING (column-name [, column-name ...])"
msgstr ""

msgid "Parentheses are allowed, and ``[[AS] correlation-name]`` is allowed."
msgstr ""

msgid "The maximum number of joins in a FROM clause is 64."
msgstr ""

msgid ""
"The ``SEQSCAN`` keyword (since :doc:`2.11 </release/2.11.0>`) marks the "
"queries that perform sequential scans during the execution. It happens if "
"the query can't use indexes, and goes through all the table rows one by one,"
" sometimes causing a heavy load. Such queries are called *scan queries*. If "
"a scan query doesn't have the ``SEQSCAN`` keyword, Tarantool raises an "
"error. ``SEQSCAN`` must precede all names of the tables that the query "
"scans."
msgstr ""

msgid ""
"To find out if a query performs a sequential scan, use ``EXPLAIN QUERY "
"PLAN``. For scan queries, the result contains ``SCAN TABLE table_name``."
msgstr ""

msgid ""
"For backward compatibility, the scan queries without the ``SEQSCAN`` keyword"
" are allowed in Tarantool 2.11. The errors on scan queries are the default "
"behavior starting from 3.0. You can change the default behavior of scan "
"queries using the :ref:`compat option sql_seq_scan <compat-option-sql-"
"scan>`."
msgstr ""

msgid ""
"-- the simplest form:\n"
"SELECT * FROM SEQSCAN t;\n"
"-- with two tables, making a Cartesian join:\n"
"SELECT * FROM SEQSCAN t1, SEQSCAN t2;\n"
"-- with one table joined to itself, requiring correlation names:\n"
"SELECT a.*, b.* FROM SEQSCAN t1 AS a, SEQSCAN t1 AS b;\n"
"-- with a left outer join:\n"
"SELECT * FROM SEQSCAN t1 LEFT JOIN SEQSCAN t2;"
msgstr ""

msgid "WHERE clause"
msgstr ""

msgid ":samp:`WHERE condition;`"
msgstr ""

msgid ""
"Specify the condition for filtering rows from a table; this is a clause in a"
" :ref:`SELECT <sql_select>` or :ref:`UPDATE <sql_update>` or :ref:`DELETE "
"<sql_delete>` statement."
msgstr ""

msgid ""
"The condition may contain any expression that returns a BOOLEAN (TRUE or "
"FALSE or UNKNOWN) value."
msgstr ""

msgid "For each row in the table:"
msgstr ""

msgid "if the condition is true, then the row is kept;"
msgstr ""

msgid "if the condition is false or unknown, then the row is ignored."
msgstr ""

msgid ""
"In effect, WHERE condition takes a table with n rows and returns a table "
"with n or fewer rows."
msgstr ""

msgid ""
"-- with a simple condition:\n"
"SELECT 1 FROM t WHERE column1 = 5;\n"
"-- with a condition that contains AND and OR and parentheses:\n"
"SELECT 1 FROM t WHERE column1 = 5 AND (x > 1 OR y < 1);"
msgstr ""

msgid "GROUP BY clause"
msgstr ""

msgid ":samp:`GROUP BY expression [, expression ...]`"
msgstr ""

msgid ""
"Make a grouped table; this is a clause in a :ref:`SELECT statement "
"<sql_select>`."
msgstr ""

msgid ""
"The expressions should be column names in the table, and each column should "
"be specified only once."
msgstr ""

msgid ""
"In effect, the GROUP BY clause takes a table with rows that may have "
"matching values, combines rows that have matching values into single rows, "
"and returns a table which, because it is the result of GROUP BY, is called a"
" grouped table."
msgstr ""

msgid "Thus, if the input is a table:"
msgstr ""

msgid ""
"a    b      c\n"
"-    -      -\n"
"1    'a'   'b\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'\n"
"1    'b'   'b'"
msgstr ""

msgid "then ``GROUP BY a, b`` will produce a grouped table:"
msgstr ""

msgid ""
"a    b      c\n"
"-    -      -\n"
"1    'a'   'b'\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'"
msgstr ""

msgid ""
"The rows where column ``a`` and column ``b`` have the same value have been "
"merged; column ``c`` has been preserved but its value should not be depended"
" on -- if the rows were not all 'b', Tarantool could pick any value."
msgstr ""

msgid ""
"It is useful to envisage a grouped table as having hidden extra columns for "
"the aggregation of the values, for example:"
msgstr ""

msgid ""
"a    b      c    COUNT(a) SUM(a) MIN(c)\n"
"-    -      -    -------- ------ ------\n"
"1    'a'    'b'         2      2    'b'\n"
"1    'b'    'b'         1      1    'b'\n"
"2    'a'    'b'         1      2    'b'\n"
"     'a'    'b'         1      3    'b'"
msgstr ""

msgid ""
"These extra columns are what :ref:`aggregate functions <sql_aggregate>` are "
"for."
msgstr ""

msgid ""
"-- with a single column:\n"
"SELECT 1 FROM t GROUP BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t GROUP BY column1, column2;"
msgstr ""

msgid "``SELECT s1, s2 FROM t GROUP BY s1;`` is legal."
msgstr ""

msgid "``SELECT s1 AS q FROM t GROUP BY q;`` is legal."
msgstr ""

msgid "``SELECT s1 FROM t GROUP by 1;`` is legal."
msgstr ""

msgid "Aggregate functions"
msgstr ""

msgid ":samp:`function-name (one or more expressions)`"
msgstr ""

msgid ""
"Apply a built-in aggregate function to one or more expressions and return a "
"scalar value."
msgstr ""

msgid ""
"Aggregate functions are only legal in certain clauses of a :ref:`SELECT "
"statement <sql_select>` for grouped tables. (A table is a grouped table if a"
" GROUP BY clause is present.) Also, if an aggregate function is used in a "
":ref:`select list <sql_select_list>` and the GROUP BY clause is omitted, "
"then Tarantool assumes ``SELECT ... GROUP BY [all columns];``."
msgstr ""

msgid "NULLs are ignored for all aggregate functions except COUNT(*)."
msgstr ""

msgid "``AVG([DISTINCT] expression)``"
msgstr ""

msgid "Return the average value of expression."
msgstr ""

msgid "Example: :samp:`AVG({column1})`"
msgstr ""

msgid "``COUNT([DISTINCT] expression)``"
msgstr ""

msgid "Return the number of occurrences of expression."
msgstr ""

msgid "Example: :samp:`COUNT({column1})`"
msgstr ""

msgid "``COUNT(*)``"
msgstr ""

msgid "Return the number of occurrences of a row."
msgstr ""

msgid "Example: :samp:`COUNT(*)`"
msgstr ""

msgid ""
"``GROUP_CONCAT(expression-1 [, expression-2])`` or ``GROUP_CONCAT(DISTINCT "
"expression-1)``"
msgstr ""

msgid ""
"Return a list of *expression-1* values, separated by commas if "
"*expression-2* is omitted, or separated by the *expression-2* value if "
"*expression-2* is not omitted."
msgstr ""

msgid "Example: :samp:`GROUP_CONCAT({column1})`"
msgstr ""

msgid "``MAX([DISTINCT] expression)``"
msgstr ""

msgid "Return the maximum value of expression."
msgstr ""

msgid "Example: :samp:`MAX({column1})`"
msgstr ""

msgid "``MIN([DISTINCT] expression)``"
msgstr ""

msgid "Return the minimum value of expression."
msgstr ""

msgid "Example: :samp:`MIN({column1})`"
msgstr ""

msgid "``SUM([DISTINCT] expression)``"
msgstr ""

msgid "Return the sum of values of expression, or NULL if there are no rows."
msgstr "Возвращает сумму значений выражения или ``NULL``, если строк не было."

msgid "Example: :samp:`SUM({column1})`"
msgstr ""

msgid "``TOTAL([DISTINCT] expression)``"
msgstr ""

msgid "Return the sum of values of expression, or zero if there are no rows."
msgstr "Возвращает сумму значений выражения или ноль, если строк не было."

msgid "Example: :samp:`TOTAL({column1})`"
msgstr ""

msgid "HAVING clause"
msgstr ""

msgid ":samp:`HAVING condition;`"
msgstr ""

msgid ""
"Specify the condition for filtering rows from a grouped table; this is a "
"clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

msgid ""
"The clause preceding the HAVING clause may be a GROUP BY clause. HAVING "
"operates on the table that the GROUP BY produces, which may contain grouped "
"columns and aggregates."
msgstr ""

msgid ""
"If the preceding clause is not a GROUP BY clause, then there is only one "
"group and the HAVING clause may only contain aggregate functions or "
"literals."
msgstr ""

msgid ""
"In effect, HAVING condition takes a table with n rows and returns a table "
"with n or fewer rows."
msgstr ""

msgid ""
"-- with a simple condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5;\n"
"-- with a more complicated condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5 OR column2 < 5;\n"
"-- with an aggregate:\n"
"SELECT x, SUM(y) FROM t GROUP BY x HAVING SUM(y) > 0;\n"
"-- with no GROUP BY and an aggregate:\n"
"SELECT SUM(y) FROM t GROUP BY x HAVING MIN(y) < MAX(y);"
msgstr ""

msgid "HAVING without GROUP BY is not supported for multiple tables."
msgstr ""

msgid "ORDER BY clause"
msgstr ""

msgid ":samp:`ORDER BY expression [ASC|DESC] [, expression [ASC|DESC] ...]`"
msgstr ""

msgid ""
"Put rows in order; this is a clause in a :ref:`SELECT statement "
"<sql_select>`."
msgstr ""

msgid ""
"An ORDER BY expression has one of three types which are checked in order:"
msgstr ""

msgid ""
"Expression is a positive integer, representing the ordinal position of the "
"column in the :ref:`select list <sql_select_list>`. For example, in the "
"statement |br| ``SELECT x, y, z FROM t ORDER BY 2;`` |br| ``ORDER BY 2`` "
"means \"order by the second column in the select list\", which is ``y``."
msgstr ""

msgid ""
"Expression is a name of a column in the select list, which is determined by "
"an AS clause. For example, in the statement |br| ``SELECT x, y AS x, z FROM "
"t ORDER BY x;`` |br| ``ORDER BY x`` means \"order by the column explicitly "
"named ``x`` in the select list\", which is the second column."
msgstr ""

msgid ""
"Expression contains a name of a column in a table of the FROM clause. For "
"example, in the statement |br| ``SELECT x, y FROM t1 JOIN t2 ORDER BY z;`` "
"|br| ``ORDER BY z`` means \"order by a column named ``z`` which is expected "
"to be in table ``t1`` or table ``t2``\"."
msgstr ""

msgid ""
"If both tables contain a column named ``z``, then Tarantool will choose the "
"first column that it finds."
msgstr ""

msgid ""
"The expression may also contain operators and function names and literals. "
"For example, in the statement |br| ``SELECT x, y FROM t ORDER BY UPPER(z);``"
" |br| ``ORDER BY UPPER(z)`` means \"order by the uppercase form of column "
"``t.z``\", which may be similar to doing ordering with one of Tarantool's "
"case-insensitive collations."
msgstr ""
"Выражение может содержать операторы и имена функций, а также конкретные "
"значения. Например, в инструкции ``SELECT x, y FROM t ORDER BY UPPER(z);`` "
"часть ``ORDER BY UPPER(z)`` означает \"упорядочить по значениям столбца "
"``t.z``, представленным в заглавном регистре\". Вероятно, эта операция "
"аналогична упорядочиванию с помощью одной из нечувствительных к регистру "
"сортировок Tarantool."

msgid ""
"Type 3 is illegal if the SELECT statement contains :ref:`UNION or EXCEPT or "
"INTERSECT <sql_union>`."
msgstr ""

msgid ""
"If an ORDER BY clause contains multiple expressions, then expressions on the"
" left are processed first and expressions on the right are processed only if"
" necessary for tie-breaking. For example, in the statement |br| ``SELECT x, "
"y FROM t ORDER BY x, y;`` if there are two rows which both have the same "
"values for column ``x``, then an additional check is made to see which row "
"has a greater value for column ``y``."
msgstr ""

msgid ""
"In effect, ORDER BY clause takes a table with rows that may be out of order,"
" and returns a table with rows in order."
msgstr ""

msgid "Sorting order:"
msgstr ""

msgid ""
"The default order is ASC (ascending), the optional order is DESC "
"(descending)."
msgstr ""

msgid ""
"NULLs come first, then BOOLEANs, then numerics, then STRINGs, then "
"VARBINARYs, then UUIDs."
msgstr ""
"Первыми идут значения NULL, затем значения типа BOOLEAN, числовые значения, "
"STRING, VARBINARY и, наконец, UUID."

msgid ""
"Ordering does not matter for ARRAYs or MAPs or ANYs because they are not "
"legal for comparisons."
msgstr ""

msgid "Within STRINGs, ordering is according to collation."
msgstr ""

msgid ""
"Collation may be specified with a :ref:`COLLATE clause <sql_collate_clause>`"
" within the ORDER BY column-list, or may be default."
msgstr ""

msgid ""
"-- with a single column:\n"
"SELECT 1 FROM t ORDER BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t ORDER BY column1, column2;\n"
"-- with a variety of data:\n"
"CREATE TABLE h (s1 NUMBER PRIMARY KEY, s2 SCALAR);\n"
"INSERT INTO h VALUES (7, 'A'), (4, 'a'), (-4, 'AZ'), (17, 17), (23, NULL);\n"
"INSERT INTO h VALUES (17.5, 'Д'), (1e+300, 'A'), (0, ''), (-1, '');\n"
"SELECT * FROM h ORDER BY s2 COLLATE \"unicode_ci\", s1;\n"
"-- The result of the above SELECT will be:\n"
"- - [23, null]\n"
"  - [17, 17]\n"
"  - [-1, '']\n"
"  - [0, '']\n"
"  - [4, 'a']\n"
"  - [7, 'A']\n"
"  - [1e+300, 'A']\n"
"  - [-4, 'AZ']\n"
"  - [17.5, 'Д']\n"
"..."
msgstr ""

msgid "ORDER BY 1 is legal. This is common but is not standard SQL nowadays."
msgstr ""

msgid "LIMIT clause"
msgstr ""

msgid ":samp:`LIMIT limit-expression [OFFSET offset-expression]`"
msgstr ""

msgid ":samp:`LIMIT offset-expression, limit-expression`"
msgstr ""

msgid ""
"The above is not a typo: *offset-expression* and *limit-expression* are in "
"reverse order if a comma is used."
msgstr ""

msgid ""
"Specify a maximum number of rows and a start row; this is a clause in a "
":ref:`SELECT statement <sql_select>`."
msgstr ""

msgid ""
"Expressions may contain integers and arithmetic operators or functions, for "
"example ``ABS(-3 / 1)``. However, the result must be an integer value "
"greater than or equal to zero."
msgstr ""

msgid ""
"Usually the LIMIT clause follows an :ref:`ORDER BY clause <sql_order_by>`, "
"because otherwise Tarantool does not guarantee that rows are in order."
msgstr ""

msgid ""
"-- simple case:\n"
"SELECT * FROM t LIMIT 3;\n"
"-- both limit and order:\n"
"SELECT * FROM t LIMIT 3 OFFSET 1;\n"
"-- applied to a UNIONed result (LIMIT clause must be the final clause):\n"
"SELECT column1 FROM table1 UNION SELECT column1 FROM table2 ORDER BY 1 LIMIT 1;"
msgstr ""

msgid ""
"If ORDER BY ... LIMIT is used, then all order-by columns must be ASC or all "
"must be DESC."
msgstr ""

msgid "Subquery"
msgstr ""

msgid ":ref:`SELECT-statement <sql_select>` syntax"
msgstr ""

msgid ":ref:`VALUES-statement <sql_values>` syntax"
msgstr ""

msgid ""
"A subquery has the same syntax as a :ref:`SELECT statement <sql_select>` or "
":ref:`VALUES statement <sql_values>` embedded inside a main statement."
msgstr ""

msgid ""
"The SELECT and VALUES statements are called \"queries\" because they return "
"answers, in the form of result sets."
msgstr ""

msgid ""
"Subqueries may be the second part of :ref:`INSERT statements <sql_insert>`. "
"For example:"
msgstr ""

msgid "INSERT INTO t2 SELECT a, b, c FROM t1;"
msgstr ""

msgid ""
"Subqueries may be in the :ref:`FROM clause <sql_from>` of SELECT statements."
msgstr ""

msgid ""
"Subqueries may be expressions, or be inside expressions. In this case they "
"must be parenthesized, and usually the number of rows must be 1. For "
"example:"
msgstr ""

msgid ""
"SELECT 1, (SELECT 5), 3 FROM t WHERE c1 * (SELECT COUNT(*) FROM t2) > 5;"
msgstr ""

msgid ""
"Subqueries may be expressions on the right side of certain comparison "
"operators, and in this unusual case the number of rows may be greater than "
"1. The comparison operators are: [NOT] EXISTS and [NOT] IN. For example:"
msgstr ""

msgid "DELETE FROM t WHERE s1 NOT IN (SELECT s2 FROM t);"
msgstr ""

msgid ""
"Subqueries may refer to values in the outer query. In this case, the "
"subquery is called a \"correlated subquery\"."
msgstr ""

msgid ""
"Subqueries may refer to rows which are being updated or deleted by the main "
"query. In that case, the subquery finds the matching rows first, before "
"starting to update or delete. For example, after:"
msgstr ""

msgid ""
"CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"INSERT INTO t VALUES (1, 3), (2, 1);\n"
"DELETE FROM t WHERE s2 NOT IN (SELECT s1 FROM t);"
msgstr ""

msgid "only one of the rows is deleted, not both rows."
msgstr ""

msgid "WITH clause"
msgstr ""

msgid "**WITH clause (common table expression)**"
msgstr ""

msgid ""
":samp:`WITH {temporary-table-name} AS (subquery)` |br| :samp:`[, {temporary-"
"table-name} AS (subquery)]` |br| :samp:`SELECT statement | INSERT statement "
"| DELETE statement | UPDATE statement | REPLACE statement;`"
msgstr ""

msgid "WITH v AS (SELECT * FROM t) SELECT * FROM v;"
msgstr ""

msgid ""
"is equivalent to :ref:`creating a view <sql_create_view>` and selecting from"
" it:"
msgstr ""

msgid ""
"CREATE VIEW v AS SELECT * FROM t;\n"
"SELECT * FROM v;"
msgstr ""

msgid ""
"The difference is that a WITH-clause \"view\" is temporary and only useful "
"within the same statement. No CREATE privilege is required."
msgstr ""

msgid ""
"The WITH-clause can also be thought of as a :ref:`subquery <sql_subquery>` "
"that has a name. This is useful when the same subquery is being repeated. "
"For example:"
msgstr ""

msgid ""
"SELECT * FROM t WHERE a < (SELECT s1 FROM x) AND b < (SELECT s1 FROM x);"
msgstr ""

msgid "can be replaced with:"
msgstr ""

msgid ""
"WITH s AS (SELECT s1 FROM x) SELECT * FROM t,s WHERE a < s.s1 AND b < s.s1;"
msgstr ""

msgid ""
"This \"factoring out\" of a repeated expression is regarded as good "
"practice."
msgstr ""

msgid ""
"WITH cte AS (VALUES (7, '') INSERT INTO j SELECT * FROM cte;\n"
"WITH cte AS (SELECT s1 AS x FROM k) SELECT * FROM cte;\n"
"WITH cte AS (SELECT COUNT(*) FROM k WHERE s2 < 'x' GROUP BY s3)\n"
"  UPDATE j SET s2 = 5\n"
"  WHERE s1 = (SELECT s1 FROM cte) OR s3 = (SELECT s1 FROM cte);"
msgstr ""

msgid ""
"WITH can only be used at the beginning of a statement, therefore it cannot "
"be used at the beginning of a subquery or after a :ref:`set operator "
"<sql_union>` or inside a CREATE statement."
msgstr ""

msgid ""
"A WITH-clause \"view\" is read-only because Tarantool does not support "
"updatable views."
msgstr ""

msgid "WITH RECURSIVE"
msgstr ""

msgid "**WITH RECURSIVE clause (iterative common table expression)**"
msgstr ""

msgid ""
"The real power of WITH lies in the WITH RECURSIVE clause, which is useful "
"when it is combined with :ref:`UNION or UNION ALL <sql_union>`:"
msgstr ""

msgid ""
":samp:`WITH RECURSIVE recursive-table-name AS` |br| :samp:`(SELECT ... FROM "
"non-recursive-table-name ...` |br| :samp:`UNION [ALL]` |br| :samp:`SELECT "
"... FROM recursive-table-name ...)` |br| :samp:`statement-that-uses-"
"recursive-table-name;` |br|"
msgstr ""

msgid ""
"In non-SQL this can be read as: starting with a seed value from a non-"
"recursive table, produce a recursive viewed table, UNION that with itself, "
"UNION that with itself, UNION that with itself ... forever, or until a "
"condition in the WHERE clause says \"stop\"."
msgstr ""

msgid ""
"CREATE TABLE ts (s1 INTEGER PRIMARY KEY);\n"
"INSERT INTO ts VALUES (1);\n"
"WITH RECURSIVE w AS (\n"
"  SELECT s1 FROM ts\n"
"  UNION ALL\n"
"  SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
"SELECT * FROM w;"
msgstr ""

msgid "First, table ``w`` is seeded from ``t1``, so it has one row: [1]."
msgstr ""

msgid ""
"Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which"
" contains [1] -- adds 1 because the select list says \"s1+1\", and so it has"
" one row: [2]."
msgstr ""

msgid ""
"Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which"
" contains [2] -- adds 1 because the select list says \"s1+1\", and so it has"
" one row: [3]."
msgstr ""

msgid ""
"Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which"
" contains [3] -- adds 1 because the select list says \"s1+1\", and so it has"
" one row: [4]."
msgstr ""

msgid ""
"Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which"
" contains [4] -- and now the importance of the WHERE clause becomes evident,"
" because \"s1 < 4\" is false for this row, and therefore the \"stop\" "
"condition has been reached."
msgstr ""

msgid ""
"So, before the \"stop\", table ``w`` got 4 rows -- [1], [2], [3], [4] -- and"
" the result of the statement looks like:"
msgstr ""

msgid ""
"tarantool> WITH RECURSIVE w AS (\n"
"         >   SELECT s1 FROM ts\n"
"         >   UNION ALL\n"
"         >   SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
"         > SELECT * FROM w;\n"
"---\n"
"- - [1]\n"
"  - [2]\n"
"  - [3]\n"
"  - [4]\n"
"..."
msgstr ""

msgid ""
"In other words, this ``WITH RECURSIVE ... SELECT`` produces a table of auto-"
"incrementing values."
msgstr ""

msgid "UNION, EXCEPT, and INTERSECT clauses"
msgstr ""

msgid ""
":samp:`select-statement UNION [ALL] select-statement [ORDER BY clause] "
"[LIMIT clause];`"
msgstr ""

msgid ""
":samp:`select-statement EXCEPT select-statement [ORDER BY clause] [LIMIT "
"clause];`"
msgstr ""

msgid ""
":samp:`select-statement INTERSECT select-statement [ORDER BY clause] [LIMIT "
"clause];`"
msgstr ""

msgid ""
"UNION, EXCEPT, and INTERSECT are collectively called \"set operators\" or "
"\"table operators\". In particular:"
msgstr ""

msgid "``a UNION b`` means \"take rows which occur in a OR b\"."
msgstr ""

msgid "``a EXCEPT b`` means \"take rows which occur in a AND NOT b\"."
msgstr ""

msgid "``a INTERSECT b`` means \"take rows which occur in a AND b\"."
msgstr ""

msgid "Duplicate rows are eliminated unless ALL is specified."
msgstr ""

msgid ""
"The *select-statements* may be chained: ``SELECT ... SELECT ... SELECT "
"...;``"
msgstr ""

msgid "Each *select-statement* must result in the same number of columns."
msgstr ""

msgid ""
"The *select-statements* may be replaced with :ref:`VALUES statements "
"<sql_values>`."
msgstr ""

msgid "The maximum number of set operations is 50."
msgstr ""

msgid ""
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t2 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, NULL);\n"
"INSERT INTO t2 VALUES (1, 'A'), (2, 'C'), (3,NULL);\n"
"SELECT s2 FROM t1 UNION SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 UNION ALL SELECT s2 FROM t2 ORDER BY s2;\n"
"SELECT s2 FROM t1 EXCEPT SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 INTERSECT SELECT s2 FROM t2;"
msgstr ""

msgid "In this example:"
msgstr "В данном примере:"

msgid "The UNION query returns 4 rows: NULL, 'A', 'B', 'C'."
msgstr ""

msgid "The UNION ALL query returns 6 rows: NULL, NULL, 'A', 'A', 'B', 'C'."
msgstr ""

msgid "The EXCEPT query returns 1 row: 'B'."
msgstr ""

msgid "The INTERSECT query returns 2 rows: NULL, 'A'."
msgstr ""

msgid "Parentheses are not allowed."
msgstr ""

msgid "Evaluation is left to right, INTERSECT does not have precedence."
msgstr ""

msgid ""
"CREATE TABLE t01 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t02 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t03 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"INSERT INTO t01 VALUES (1, 'A');\n"
"INSERT INTO t02 VALUES (1, 'B');\n"
"INSERT INTO t03 VALUES (1, 'A');\n"
"SELECT s2 FROM t01 INTERSECT SELECT s2 FROM t03 UNION SELECT s2 FROM t02;\n"
"SELECT s2 FROM t03 UNION SELECT s2 FROM t02 INTERSECT SELECT s2 FROM t03;\n"
"-- ... results are different."
msgstr ""

msgid "INDEXED BY clause"
msgstr ""

msgid ":samp:`INDEXED BY {index-name}`"
msgstr ""

msgid ""
"The INDEXED BY clause may be used in a :ref:`SELECT <sql_select>`, "
":ref:`DELETE <sql_delete>`, or :ref:`UPDATE <sql_update>` statement, "
"immediately after the *table-name*. For example:"
msgstr ""

msgid "DELETE FROM table7 INDEXED BY index7 WHERE column1 = 'a';"
msgstr ""

msgid ""
"In this case the search for 'a' will take place within ``index7``. For "
"example:"
msgstr ""

msgid "SELECT * FROM table7 NOT INDEXED WHERE column1 = 'a';"
msgstr ""

msgid ""
"In this case the search for 'a' will be done via a search of the whole "
"table, what is sometimes called a \"full table scan\", even if there is an "
"index for ``column1``."
msgstr ""

msgid ""
"Ordinarily Tarantool chooses the appropriate index or lookup method "
"depending on a complex set of \"optimizer\" rules; the INDEXED BY clause "
"overrides the optimizer choice. If the index was defined with the "
":ref:`exclude_null <key_part_exclude_null>` parts option, it will only be "
"used if the user specifies it."
msgstr ""

msgid "Suppose a table has two columns:"
msgstr ""

msgid ""
"The first column is the primary key and therefore it has an automatic index "
"named ``pk_unnamed_T_1``."
msgstr ""

msgid "The second column has an index created by the user."
msgstr ""

msgid ""
"The user selects with ``INDEXED BY the-index-on-column1``, then selects with"
" ``INDEXED BY the-index-on-column-2``."
msgstr ""

msgid ""
"CREATE TABLE t (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
"CREATE INDEX idx_column2_t_1 ON t (column2);\n"
"INSERT INTO t VALUES (1, 2), (2, 1);\n"
"SELECT * FROM t INDEXED BY \"pk_unnamed_T_1\";\n"
"SELECT * FROM t INDEXED BY idx_column2_t_1;\n"
"-- Result for the first select: (1, 2), (2, 1)\n"
"-- Result for the second select: (2, 1), (1, 2)."
msgstr ""

msgid ""
"Limitations: |br| Often INDEXED BY has no effect. |br| Often INDEXED BY "
"affects a choice of covering index, but not a WHERE clause."
msgstr ""

msgid "VALUES"
msgstr ""

msgid ""
":samp:`VALUES (expression [, expression ...]) [, (expression [, expression "
"...])`"
msgstr ""

msgid "Select one or more rows."
msgstr ""

msgid ""
"VALUES has the same effect as :ref:`SELECT <sql_select>`, that is, it "
"returns a result set, but VALUES statements may not have FROM or GROUP or "
"ORDER BY or LIMIT clauses."
msgstr ""

msgid ""
"VALUES may be used wherever SELECT may be used, for example in "
":ref:`subqueries <sql_subquery>`."
msgstr ""

msgid ""
"-- simple case:\n"
"VALUES (1);\n"
"-- equivalent to SELECT 1, 2, 3:\n"
"VALUES (1, 2, 3);\n"
"-- two rows:\n"
"VALUES (1, 2, 3), (4, 5, 6);"
msgstr ""

msgid "PRAGMA"
msgstr ""

msgid ":samp:`PRAGMA {pragma-name} (pragma-value);`"
msgstr ""

msgid "or :samp:`PRAGMA {pragma-name};`"
msgstr ""

msgid ""
"PRAGMA statements will give rudimentary information about database "
"'metadata' or server performance, although it is better to get metadata via "
":ref:`system tables <sql_system_tables>`."
msgstr ""

msgid ""
"For PRAGMA statements that include (``pragma-value``), pragma values are "
"strings and can be specified inside ``\"\"`` double quotes, or without "
"quotes. When a string is used for searching, results must match according to"
" a binary collation. If the object being searched has a lower-case name, use"
" double quotes."
msgstr ""

msgid ""
"In an earlier version, there were some PRAGMA statements that determined "
"behavior. Now that does not happen. Behavior change is done by updating the "
":ref:`box.space._session_settings <box_space-session_settings>` system "
"table."
msgstr ""

msgid "Pragma"
msgstr ""

msgid "Parameter"
msgstr ""

msgid "Effect"
msgstr "Эффект"

msgid "foreign_key_list"
msgstr ""

msgid "string |br| table-name"
msgstr ""

msgid ""
"Return a :ref:`result set <box-sql_result_sets>` with one row for each "
"foreign key of \"table-name\". Each row contains: |br| (INTEGER) id -- "
"identification number |br| (INTEGER) seq -- sequential number |br| (STRING) "
"table -- name of table |br| (STRING) from  -- referencing key |br| (STRING) "
"to -- referenced key |br| (STRING) on_update -- ON UPDATE clause |br| "
"(STRING) on_delete -- ON DELETE clause |br| (STRING) match -- MATCH clause "
"|br| The system table is ``\"_fk_constraint\"``."
msgstr ""

msgid "collation_list"
msgstr ""

msgid ""
"Return a result set with one row for each supported collation. The first "
"four collations are ``'none'`` and ``'unicode'`` and ``'unicode_ci'`` and "
"``'binary'``, then come about 270 predefined collations, the exact count may"
" vary because users can add their own collations. |br| The system table is "
"``\"_collation\"``."
msgstr ""

msgid "index_info"
msgstr ""

msgid "string |br| table-name . index-name"
msgstr ""

msgid ""
"Return a result set with one row for each column in \"table-name.index-"
"name\". Each row contains: |br| (INTEGER) seqno -- the column's ordinal "
"position in the index (first column is 0) |br| (INTEGER) cid -- the column's"
" ordinal position in the table (first column is 0) |br| (STRING) name -- "
"name of the column |br| (INTEGER) desc -- 0 is ASC, 1 is DESC |br| (STRING) "
"collation name |br| (STRING) type -- data type"
msgstr ""

msgid "index_list"
msgstr ""

#, fuzzy
msgid ""
"Return a result set with one row for each index of \"table-name\". Each row "
"contains: |br| (INTEGER) seq -- sequential number |br| (STRING) name -- "
"index name |br| (INTEGER) unique -- whether the index is unique, 0 is false,"
" 1 is true |br| The system table is ``\"_index\"``."
msgstr ""
"Возвращает результат запроса с одной строкой для каждого столбца \"table-"
"name\". Каждая строка содержит: |br| (INTEGER) cid — порядковая позиция в "
"таблице |br| (для первого столбца 0) |br| (STRING) name — имя столбца |br| "
"(STRING) type |br| (INTEGER) notnull — является ли столбец NOT NULL. 0 если "
"не является, 1 если является. |br| (STRING) dflt_value — значение по "
"умолчанию |br| (INTEGER) pk — является ли столбец PRIMARY KEY. 0 если не "
"является, 1 если является."

msgid "stats"
msgstr ""

msgid ""
"Return a result set with one row for each index of each table. Each row "
"contains: |br| (STRING) table -- name of the table |br| (STRING) index -- "
"name of the index |br| (INTEGER) width -- arbitrary information |br| "
"(INTEGER) height -- arbitrary information"
msgstr ""

msgid "table_info"
msgstr ""

#, fuzzy
msgid ""
"Return a result set with one row for each column in \"table-name\". Each row"
" contains: |br| (INTEGER) cid -- ordinal position in the table |br| (first "
"column number is 0) |br| (STRING) name -- column name |br| (STRING) type "
"|br| (INTEGER) notnull -- whether the column is NOT NULL, 0 is false, 1 is "
"true. |br| (STRING) dflt_value -- default value |br| (INTEGER) pk -- whether"
" the column is a PRIMARY KEY column, 0 is false, 1 is true."
msgstr ""
"Возвращает результат запроса с одной строкой для каждого столбца \"table-"
"name\". Каждая строка содержит: |br| (INTEGER) cid — порядковая позиция в "
"таблице |br| (для первого столбца 0) |br| (STRING) name — имя столбца |br| "
"(STRING) type |br| (INTEGER) notnull — является ли столбец NOT NULL. 0 если "
"не является, 1 если является. |br| (STRING) dflt_value — значение по "
"умолчанию |br| (INTEGER) pk — является ли столбец PRIMARY KEY. 0 если не "
"является, 1 если является."

msgid "Example: (not showing result set metadata)"
msgstr ""

msgid ""
"PRAGMA table_info(T);\n"
"---\n"
"- - [0, 's1', 'integer', 1, null, 1]\n"
"  - [1, 's2', 'integer', 0, null, 0]\n"
"..."
msgstr ""
"PRAGMA table_info(T);\n"
"---\n"
"- - [0, 's1', 'integer', 1, null, 1]\n"
"  - [1, 's2', 'integer', 0, null, 0]\n"
"..."

msgid "EXPLAIN"
msgstr ""

msgid ":samp:`EXPLAIN explainable-statement;`"
msgstr ""

msgid ""
"EXPLAIN will show what steps Tarantool would take if it executed "
"explainable-statement. This is primarily a debugging and optimization aid "
"for the Tarantool team."
msgstr ""

msgid "Example: ``EXPLAIN DELETE FROM m;`` returns:"
msgstr ""

msgid ""
"- - [0, 'Init', 0, 3, 0, '', '00', 'Start at 3']\n"
"  - [1, 'Clear', 16416, 0, 0, '', '00', '']\n"
"  - [2, 'Halt', 0, 0, 0, '', '00', '']\n"
"  - [3, 'Transaction', 0, 1, 1, '0', '01', 'usesStmtJournal=0']\n"
"  - [4, 'Goto', 0, 1, 0, '', '00', '']"
msgstr ""

msgid ""
"Variation: ``EXPLAIN QUERY PLAN statement;`` shows the steps of a search."
msgstr ""

msgid "Statements for transactions"
msgstr ""

msgid "START TRANSACTION"
msgstr ""

msgid ":samp:`START TRANSACTION;`"
msgstr ""

msgid ""
"Start a transaction. After ``START TRANSACTION;``, a transaction is "
"\"active\". If a transaction is already active, then ``START TRANSACTION;`` "
"is illegal."
msgstr ""

msgid ""
"Transactions should be active for fairly short periods of time, to avoid "
"concurrency issues. To end a transaction, say :ref:`COMMIT; <sql_commit>` or"
" :ref:`ROLLBACK; <sql_rollback>`."
msgstr ""

msgid ""
"Just as in NoSQL, transaction control statements are subject to limitations "
"set by the :ref:`storage engine <engines-chapter>` involved: |br| * For the "
"memtx storage engine, if a yield happens within an active transaction, the "
"transaction is rolled back. |br| * For the vinyl engine, yields are allowed."
" |br| Also, although CREATE AND DROP and ALTER statements are legal in "
"transactions, there are a few exceptions. For example, :samp:`CREATE INDEX "
"ON {table_name} ...` will fail within a multi-statement transaction if the "
"table is not empty."
msgstr ""

msgid ""
"However, transaction control statements still may not work as you expect "
"when run over a network connection: a transaction is associated with a "
"fiber, not a network connection, and different transaction control "
"statements sent via the same network connection may be executed by different"
" fibers from the fiber pool."
msgstr ""
"Однако инструкции управления транзакциями всё еще могут работать не так, как"
" вы ожидаете при запуске через сетевое соединение: транзакция связана с "
"файбером, а не с сетевым соединением, и разные инструкции управления "
"транзакциями, отправленные через одно и то же сетевое соединение, могут быть"
" выполнены разными файберами из пула файберов."

msgid ""
"In order to ensure that all statements are part of the intended transaction,"
" put all of them between ``START TRANSACTION;`` and ``COMMIT;`` or "
"``ROLLBACK;`` then send as a single batch. For example:"
msgstr ""

msgid ""
"Enclose each separate SQL statement in a :ref:`box.execute() <box-"
"sql_box_execute>` function."
msgstr ""

msgid ""
"Pass all the ``box.execute()`` functions to the server in a single message."
msgstr ""

msgid ""
"If you are using a console, you can do this by writing everything on a "
"single line."
msgstr ""

msgid ""
"If you are using :ref:`net.box <net_box-module>`, you can do this by putting"
" all the function calls in a single string and calling :ref:`eval(string) "
"<net_box-eval>`."
msgstr ""

msgid "START TRANSACTION;"
msgstr ""

msgid ""
"Example of a whole transaction sent to a server on ``localhost:3301`` with "
"``eval(string)``:"
msgstr ""

msgid ""
"net_box = require('net.box')\n"
"conn = net_box.new('localhost', 3301)\n"
"s = 'box.execute([[START TRANSACTION;]]) '\n"
"s = s .. 'box.execute([[INSERT INTO t VALUES (1);]]) '\n"
"s = s .. 'box.execute([[ROLLBACK;]]) '\n"
"conn:eval(s)"
msgstr ""

msgid "COMMIT"
msgstr ""

msgid ":samp:`COMMIT;`"
msgstr ""

msgid ""
"Commit an active transaction, so all changes are made permanent and the "
"transaction ends."
msgstr ""

msgid ""
"COMMIT is illegal unless a transaction is active. If a transaction is not "
"active then SQL statements are committed automatically."
msgstr ""

msgid "COMMIT;"
msgstr ""

msgid "SAVEPOINT"
msgstr ""

msgid ":samp:`SAVEPOINT {savepoint-name};`"
msgstr ""

msgid ""
"Set a savepoint, so that :ref:`ROLLBACK TO savepoint-name <sql_rollback>` is"
" possible."
msgstr ""

msgid "SAVEPOINT is illegal unless a transaction is active."
msgstr ""

msgid ""
"If a savepoint with the same name already exists, it is released before the "
"new savepoint is set."
msgstr ""

msgid "SAVEPOINT x;"
msgstr ""

msgid "RELEASE SAVEPOINT"
msgstr ""

msgid ":samp:`RELEASE SAVEPOINT {savepoint-name};`"
msgstr ""

msgid ""
"Release (destroy) a savepoint created by a :ref:`SAVEPOINT statement "
"<sql_savepoint>`."
msgstr ""

msgid "RELEASE is illegal unless a transaction is active."
msgstr ""

msgid "Savepoints are released automatically when a transaction ends."
msgstr ""

msgid "RELEASE SAVEPOINT x;"
msgstr ""

msgid "ROLLBACK"
msgstr ""

msgid ":samp:`ROLLBACK [TO [SAVEPOINT] {savepoint-name}];`"
msgstr ""

msgid ""
"If ROLLBACK does not specify a *savepoint-name*, rollback an active "
"transaction, so all changes since :ref:`START TRANSACTION "
"<sql_start_transaction>` are cancelled, and the transaction ends."
msgstr ""

msgid ""
"If ROLLBACK does specify a *savepoint-name*, rollback an active transaction,"
" so all changes since :ref:`SAVEPOINT savepoint-name <sql_savepoint>` are "
"cancelled, and the transaction does not end."
msgstr ""

msgid "ROLLBACK is illegal unless a transaction is active."
msgstr ""

msgid ""
"-- the simple form:\n"
"ROLLBACK;\n"
"-- the form so changes before a savepoint are not cancelled:\n"
"ROLLBACK TO SAVEPOINT x;"
msgstr ""

msgid ""
"-- An example of a Lua function that will do a transaction\n"
"-- containing savepoint and rollback to savepoint.\n"
"function f()\n"
"box.execute([[DROP TABLE IF EXISTS t;]]) -- commits automatically\n"
"box.execute([[CREATE TABLE t (s1 STRING PRIMARY KEY);]]) -- commits automatically\n"
"box.execute([[START TRANSACTION;]]) -- after this succeeds, a transaction is active\n"
"box.execute([[INSERT INTO t VALUES ('Data change #1');]])\n"
"box.execute([[SAVEPOINT \"1\";]])\n"
"box.execute([[INSERT INTO t VALUES ('Data change #2');]])\n"
"box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) -- rollback Data change #2\n"
"box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) -- this is legal but does nothing\n"
"box.execute([[COMMIT;]]) -- make Data change #1 permanent, end the transaction\n"
"end"
msgstr ""

msgid "Functions"
msgstr ""

msgid "Explanation of functions"
msgstr ""

msgid ""
"Apply a built-in function to one or more expressions and return a scalar "
"value."
msgstr ""

msgid "Tarantool supports 33 built-in functions."
msgstr "Tarantool поддерживает 33 встроенные функции."

msgid "The maximum number of operands for any function is 127."
msgstr ""

msgid ""
"The required privileges for built-in functions will likely change in a "
"future version."
msgstr ""

msgid "List of functions"
msgstr ""

msgid ""
"These are Tarantool/SQL's built-in functions. Starting with Tarantool 2.10, "
"for functions that require numeric arguments, function arguments with NUMBER"
" data type are illegal."
msgstr ""
"Ниже приведены встроенные функции Tarantool/SQL. Начиная с Tarantool 2.10 "
"для функций, требующих числовые аргументы, аргументы с типом данных NUMBER "
"недопустимы."

msgid "ABS"
msgstr ""

msgid ":samp:`ABS({numeric-expression})`"
msgstr ""

msgid ""
"Return the absolute value of numeric-expression, which can be any numeric "
"type."
msgstr ""

msgid "Example: ``ABS(-1)`` is 1."
msgstr ""

msgid "CAST"
msgstr ""

msgid ":samp:`CAST({expression} AS {data-type})`"
msgstr ""

msgid ""
"Return the expression value after casting to the specified :ref:`data type "
"<sql_column_def_data_type>`."
msgstr ""

msgid "CAST to/from UUID may change some components to/from little-endian."
msgstr ""
"CAST в или из UUID может поменять порядок байтов на little-endian или "
"обратно."

msgid "Examples: ``CAST('AB' AS VARBINARY)``, ``CAST(X'4142' AS STRING)``"
msgstr ""

msgid "CHAR"
msgstr ""

msgid ":samp:`CHAR([numeric-expression [,numeric-expression...])`"
msgstr ""

msgid ""
"Return the characters whose Unicode code point values are equal to the "
"numeric expressions."
msgstr ""

msgid "Short example:"
msgstr ""

msgid ""
"The first 128 Unicode characters are the \"ASCII\" characters, so CHAR(65, "
"66, 67) is 'ABC'."
msgstr ""

msgid "Long example:"
msgstr ""

msgid ""
"For the current list of Unicode characters, in order by code point, see "
"`www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt "
"<http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt>`_. In that "
"list, there is a line for a Linear B ideogram"
msgstr ""

msgid "``100CC;LINEAR B IDEOGRAM B240 WHEELED CHARIOT ...``"
msgstr ""

msgid ""
"Therefore, for a string with a chariot in the middle, use the concatenation "
"operator ``||`` and the CHAR function"
msgstr ""

msgid "``'start of string ' || CHAR(0X100CC) || ' end of string'``."
msgstr ""

msgid "COALESCE"
msgstr ""

msgid ":samp:`COALESCE(expression, expression [, expression ...])`"
msgstr ""

msgid ""
"Return the value of the first non-NULL expression, or, if all expression "
"values are NULL, return NULL."
msgstr ""

msgid "``COALESCE(NULL, 17, 32)`` is 17."
msgstr ""

msgid "DATE_PART"
msgstr ""

msgid ":samp:`DATE_PART(value_requested , datetime)`"
msgstr ""

msgid "Since :doc:`2.10.0 </release/2.10.0>`."
msgstr ""

msgid ""
"The ``DATE_PART()`` function returns the requested information from a "
"DATETIME value. It takes two arguments: the first one tells us what "
"information is requested, the second is a DATETIME value."
msgstr ""

msgid ""
"Below is a list of supported values of the first argument and what "
"information is returned:"
msgstr ""

msgid "``millennium`` -- millennium"
msgstr ""

msgid "``century`` -- century"
msgstr ""

msgid "``decade`` -- decade"
msgstr ""

msgid "``year`` -- year"
msgstr ""

msgid "``quarter`` -- quarter of year"
msgstr ""

msgid "``month`` -- month of year"
msgstr ""

msgid "``week`` -- week of year"
msgstr ""

msgid "``day`` -- day of month"
msgstr ""

msgid "``dow`` -- day of week"
msgstr ""

msgid "``doy`` -- day of year"
msgstr ""

msgid "``hour`` -- hour of day"
msgstr ""

msgid "``minute`` -- minute of hour"
msgstr ""

msgid "``second`` -- second of minute"
msgstr ""

msgid "``millisecond`` -- millisecond of second"
msgstr ""

msgid "``microsecond`` -- microsecond of second"
msgstr ""

msgid "``nanosecond`` -- nanosecond of second"
msgstr ""

msgid "``epoch`` -- epoch"
msgstr ""

msgid "``timezone_offset`` -- time zone offset from the UTC, in minutes."
msgstr ""

msgid ""
"tarantool> select date_part('millennium', cast({'year': 2000, 'month': 4, 'day': 5, 'hour': 6, 'min': 33, 'sec': 22, 'nsec': 523999111} as datetime));\n"
"---\n"
"- metadata:\n"
"  - name: COLUMN_1\n"
"    type: integer\n"
"  rows:\n"
"  - [2]\n"
"...\n"
"\n"
"tarantool> select date_part('day', cast({'year': 2000, 'month': 4, 'day': 5, 'hour': 6, 'min': 33, 'sec': 22, 'nsec': 523999111} as datetime));\n"
"---\n"
"- metadata:\n"
"  - name: COLUMN_1\n"
"    type: integer\n"
"  rows:\n"
"  - [5]\n"
"...\n"
"\n"
"tarantool> select date_part('nanosecond', cast({'year': 2000, 'month': 4, 'day': 5, 'hour': 6, 'min': 33, 'sec': 22, 'nsec': 523999111} as datetime));\n"
"---\n"
"- metadata:\n"
"  - name: COLUMN_1\n"
"    type: integer\n"
"  rows:\n"
"  - [523999111]\n"
"..."
msgstr ""

msgid "GREATEST"
msgstr ""

msgid ":samp:`GREATEST({expression-1}, {expression-2}, [{expression-3} ...])`"
msgstr ""

msgid ""
"Return the greatest value of the supplied expressions, or, if any expression"
" is NULL, return NULL. The reverse of ``GREATEST`` is :ref:`LEAST "
"<sql_function_least>`."
msgstr ""

msgid ""
"Examples: ``GREATEST(7, 44, -1)`` is 44; ``GREATEST(1E308, 'a', 0, X'00')`` "
"is '\\0' = the nul character; ``GREATEST(3, NULL, 2)`` is NULL"
msgstr ""

msgid "HEX"
msgstr ""

msgid ":samp:`HEX(expression)`"
msgstr ""

msgid "Return the hexadecimal code for each byte in **expression**."
msgstr ""
"Возвращает шестнадцатеричный код для каждого байта выражения **expression**."

msgid ""
"Starting with Tarantool version 2.10.0, the expression must be a byte "
"sequence (data type VARBINARY)."
msgstr ""
"Начиная с версии Tarantool 2.10.0 выражение должно быть последовательностью "
"байтов (тип данных VARBINARY)."

msgid ""
"In earlier versions of Tarantool, the expression could be either a string or"
" a byte sequence. For ASCII characters, this was straightforward because the"
" encoding is the same as the code point value. For non-ASCII characters, "
"since character strings are usually encoded in UTF-8, each character will "
"require two or more bytes."
msgstr ""
"В предыдущих версиях Tarantool выражение могло быть либо строкой, либо "
"последовательностью байтов. Для символов ASCII оно выполнялось довольно "
"прямолинейно, поскольку значение каждого символа в кодировке ASCII совпадает"
" с его значением в шестнадцатеричной схеме. В случае с символами, не "
"входящими в таблицу ASCII, для каждого символа потребуется два байта или "
"более, поскольку строки символов обычно кодируются в UTF-8."

msgid "``HEX(X'41')`` will return ``41``."
msgstr "``HEX(X'41')`` вернет ``41``."

msgid "``HEX(CAST('Д' AS VARBINARY))`` will return ``D094``."
msgstr "``HEX(CAST('Д' AS VARBINARY))`` вернет ``D094``."

msgid "IFNULL"
msgstr ""

msgid ":samp:`IFNULL(expression, expression)`"
msgstr ""

msgid ""
"Return the value of the first non-NULL expression, or, if both expression "
"values are NULL, return NULL. Thus ``IFNULL(expression, expression)`` is the"
" same as :ref:`COALESCE(expression, expression) <sql_function_coalesce>`."
msgstr ""

msgid "``IFNULL(NULL, 17)`` is 17"
msgstr ""

msgid "LEAST"
msgstr ""

msgid ":samp:`LEAST({expression-1}, {expression-2}, [{expression-3} ...])`"
msgstr ""

msgid ""
"Return the least value of the supplied expressions, or, if any expression is"
" NULL, return NULL. The reverse of ``LEAST`` is :ref:`GREATEST "
"<sql_function_greatest>`."
msgstr ""

msgid ""
"Examples: ``LEAST(7, 44, -1)`` is -1; ``LEAST(1E308, 'a', 0, X'00')`` is 0; "
"``LEAST(3, NULL, 2)`` is NULL."
msgstr ""

msgid "LENGTH"
msgstr ""

msgid ":samp:`LENGTH(expression)`"
msgstr ""

msgid ""
"Return the number of characters in the **expression**, or the number of "
"bytes in the **expression**. It depends on the data type: strings with data "
"type STRING are counted in characters, byte sequences with data type "
"VARBINARY are counted in bytes and are not ended by the nul character. There"
" are two aliases for ``LENGTH(expression)`` -- ``CHAR_LENGTH(expression)`` "
"and ``CHARACTER_LENGTH(expression)`` do the same thing."
msgstr ""

msgid "``LENGTH('ДД')`` is 2, the string has 2 characters."
msgstr ""

msgid "``LENGTH(CAST('ДД' AS VARBINARY))`` is 4, the string has 4 bytes."
msgstr ""

msgid "``LENGTH(CHAR(0, 65))`` is 2, '\\0' does not mean 'end of string'."
msgstr ""

msgid "``LENGTH(X'410041')`` is 3, X'...' byte sequences have type VARBINARY."
msgstr ""

msgid "LIKELIHOOD"
msgstr ""

msgid ":samp:`LIKELIHOOD({expression}, {DOUBLE literal})`"
msgstr ":samp:`LIKELIHOOD({expression}, {DOUBLE literal})`"

msgid ""
"Return the expression without change, provided that the numeric literal is "
"between 0.0 and 1.0."
msgstr ""
"Возвращает выражение без изменений, при условии, что числовое значение "
"находится в диапазоне от 0.0 до 1.0."

msgid "Example: ``LIKELIHOOD('a' = 'b', .0)`` is FALSE"
msgstr ""

msgid "LIKELY"
msgstr ""

msgid ":samp:`LIKELY({expression})`"
msgstr ""

msgid "Return TRUE if the expression is probably true."
msgstr ""

msgid "Example: ``LIKELY('a' <= 'b')`` is TRUE"
msgstr ""

msgid "LOWER"
msgstr ""

msgid ":samp:`LOWER({string-expression})`"
msgstr ""

msgid ""
"Return the expression, with upper-case characters converted to lower case. "
"The reverse of ``LOWER`` is :ref:`UPPER <sql_function_upper>`."
msgstr ""

msgid "Example: ``LOWER('ДA')`` is 'дa'"
msgstr ""

msgid "NOW"
msgstr ""

msgid ":samp:`NOW()`"
msgstr ""

msgid ""
"The NOW() function returns the current date and time as a DATETIME value."
msgstr ""

msgid ""
"If the function is called more than once in a query, it returns the same "
"result until the query completes, unless a yield has occurred. On yield, the"
" value returned by NOW() is changing."
msgstr ""

msgid ""
"tarantool> select now(), now(), now()\n"
"---\n"
"- metadata:\n"
"  - name: COLUMN_1\n"
"    type: datetime\n"
"  - name: COLUMN_2\n"
"    type: datetime\n"
"  - name: COLUMN_3\n"
"    type: datetime\n"
"  rows:\n"
"  - ['2022-07-20T19:02:02.010812282+0300', '2022-07-20T19:02:02.010812282+0300', '2022-07-20T19:02:02.010812282+0300']\n"
"..."
msgstr ""

msgid "NULLIF"
msgstr ""

msgid ":samp:`NULLIF(expression-1, expression-2)`"
msgstr ""

msgid ""
"Return *expression-1* if *expression-1* <> *expression-2*, otherwise return "
"NULL."
msgstr ""

msgid "``NULLIF('a', 'A')`` is 'a'."
msgstr ""

msgid "``NULLIF(1.00, 1)`` is NULL."
msgstr ""

msgid ""
"Before :doc:`/release/2.10.4`, the type of the result was always ``SCALAR``."
" Since :doc:`/release/2.10.4`, the result of ``NULLIF`` matches the type of "
"the first argument. If the first argument is the ``NULL`` literal, then the "
"result has the ``SCALAR`` type."
msgstr ""

msgid "POSITION"
msgstr ""

msgid ":samp:`POSITION({expression-1}, {expression-2})`"
msgstr ""

msgid ""
"Return the position of expression-1 within expression-2, or return 0 if "
"expression-1 does not appear within expression-2. The data types of the "
"expressions must be either STRING or VARBINARY. If the expressions have data"
" type STRING, then the result is the character position. If the expressions "
"have data type VARBINARY, then the result is the byte position."
msgstr ""

msgid "Short example: ``POSITION('C', 'ABC')`` is 3"
msgstr ""

msgid ""
"Long example: The UTF-8 encoding for the Latin letter A is hexadecimal 41; "
"the UTF-8 encoding for the Cyrillic letter Д is hexadecimal D094 -- you can "
"confirm this by saying SELECT HEX('ДA'); and seeing that the result is "
"'D09441'. If you now execute ``SELECT POSITION('A', 'ДA');`` the result will"
" be 2, because 'A' is the second character in the string. However, if you "
"now execute ``SELECT POSITION(X'41', X'D09441');`` the result will be 3, "
"because X'41' is the third byte in the byte sequence."
msgstr ""

msgid "PRINTF"
msgstr ""

msgid ":samp:`PRINTF(string-expression [, expression ...])`"
msgstr ""

#, python-format
msgid ""
"Return a string formatted according to the rules of the C ``sprintf()`` "
"function, where ``%d%s`` means the next two arguments are a numeric and a "
"string, and so on."
msgstr ""
"Возвращает строку, отформатированную по правилам функции C ``sprintf()``, "
"где ``%d%s`` означает, что следующие два аргумента --- числовой и строка, и "
"так далее."

msgid "If an argument is missing or is NULL, it becomes:"
msgstr ""

msgid "'0' if the format requires an integer,"
msgstr ""

msgid "'0.0' if the format requires a numeric with a decimal point,"
msgstr ""
"``'0.0'``, если формат требует числового значения с десятичной точкой,"

msgid "'' if the format requires a string."
msgstr ""

#, python-format
msgid "Example: ``PRINTF('%da', 5)`` is '5a'."
msgstr ""

msgid "QUOTE"
msgstr ""

msgid ":samp:`QUOTE(string-argument)`"
msgstr ":samp:`QUOTE(string)`"

msgid ""
"Return a string with enclosing quotes if necessary, and with quotes inside "
"the enclosing quotes if necessary. This function is useful for creating "
"strings which are part of SQL statements, because of SQL's rules that string"
" literals are enclosed by single quotes, and single quotes inside such "
"strings are shown as two single quotes in a row."
msgstr ""

msgid ""
"Starting with Tarantool version 2.10, arguments with numeric data types are "
"returned without change."
msgstr ""
"Начиная с версии Tarantool 2.10 аргументы с числовыми типами данных "
"возвращаются без изменений."

msgid "Example: ``QUOTE('a')`` is ``'a'``. ``QUOTE(5)`` is ``5``."
msgstr "Примеры: ``QUOTE('a')`` вернет ``'a'``, ``QUOTE(5)`` вернет ``5``."

msgid "RAISE"
msgstr ""

msgid ":samp:`RAISE(FAIL, {error-message})`"
msgstr ""

msgid ""
"This may only be used within a triggered statement. See also :ref:`Trigger "
"Activation <sql_trigger_activation>`."
msgstr ""

msgid "RANDOM"
msgstr ""

msgid "Syntax: :samp:`RANDOM()`"
msgstr ""

msgid ""
"Return a 19-digit integer which is generated by a pseudo-random number "
"generator,"
msgstr ""

msgid ""
"Example: ``RANDOM()`` is 6832175749978026034, or it is any other integer"
msgstr ""

msgid "RANDOMBLOB"
msgstr ""

msgid ":samp:`RANDOMBLOB({n})`"
msgstr ""

msgid ""
"Return a byte sequence, n bytes long, data type = VARBINARY, containing "
"bytes generated by a pseudo-random byte generator. The result can be "
"translated to hexadecimal. If n is less than 1 or is NULL or is infinity, "
"then NULL is returned."
msgstr ""

msgid ""
"Example: ``HEX(RANDOMBLOB(3))`` is '9EAAA8', or it is the hex value for any "
"other three-byte string"
msgstr ""

msgid ":samp:`REPLACE({expression-1}, {expression-2}, {expression-3})`"
msgstr ""

msgid ""
"Return expression-1, except that wherever expression-1 contains "
"expression-2, replace expression-2 with expression-3. The expressions should"
" all have data type STRING or VARBINARY."
msgstr ""

msgid "Example: ``REPLACE('AAABCCCBD', 'B', '!')`` is 'AAA!CCC!D'"
msgstr ""

msgid "ROUND"
msgstr ""

msgid ":samp:`ROUND({numeric-expression-1} [, {numeric-expression-2}])`"
msgstr ""

msgid ""
"Return the rounded value of numeric-expression-1, always rounding .5 upward "
"for positive numerics or downward for negative numerics. If numeric-"
"expression-2 is supplied then rounding is to the nearest numeric-"
"expression-2 digits after the decimal point; if numeric-expression-2 is not "
"supplied then rounding is to the nearest integer."
msgstr ""
"Возвращает округленное значение первого числового выражения. Положительные "
"числа округляются до 0,5 в большую сторону, отрицательные --- до 0,5 в "
"меньшую. Если задано второе числовое выражение, то первое округляется до "
"ближайших цифр после десятичной точки второго выражения. Если второе "
"выражение не задано, первое округляется до ближайшего целого числа."

msgid "Example: ``ROUND(-1.5)`` is -2, ``ROUND(1.7766E1,2)`` is 17.77."
msgstr ""

msgid "ROW_COUNT"
msgstr ""

msgid ":samp:`ROW_COUNT()`"
msgstr ""

msgid ""
"Return the number of rows that were inserted / updated / deleted by the last"
" :ref:`INSERT <sql_insert>` or :ref:`UPDATE <sql_update>` or :ref:`DELETE "
"<sql_delete>` or :ref:`REPLACE <sql_replace>` statement. Rows which were "
"updated by an UPDATE statement are counted even if there was no change. Rows"
" which were inserted / updated / deleted due to foreign-key action are not "
"counted. Rows which were inserted / updated / deleted due to a view's "
":ref:`INSTEAD OF triggers <sql_instead_of_triggers>` are  not counted. After"
" a CREATE or DROP statement, ROW_COUNT() is 1. After other statements,  "
"ROW_COUNT() is 0."
msgstr ""

msgid ""
"Example: ``ROW_COUNT()`` is 1 after a successful INSERT of a single row."
msgstr ""

msgid ""
"Special rule if there are BEFORE or AFTER triggers: In effect the "
"ROW_COUNT() counter is pushed at the beginning of a series of triggered "
"statements, and popped at the end. Therefore, after the following "
"statements:"
msgstr ""

msgid ""
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY);\n"
"CREATE TABLE t2 (s1 INTEGER, s2 STRING, s3 INTEGER, PRIMARY KEY (s1, s2, s3));\n"
"CREATE TRIGGER tt1 BEFORE DELETE ON t1 FOR EACH ROW BEGIN\n"
"  INSERT INTO t2 VALUES (old.s1, '#2 Triggered', ROW_COUNT());\n"
"  INSERT INTO t2 VALUES (old.s1, '#3 Triggered', ROW_COUNT());\n"
"  END;\n"
"INSERT INTO t1 VALUES (1),(2),(3);\n"
"DELETE FROM t1;\n"
"INSERT INTO t2 VALUES (4, '#4 Untriggered', ROW_COUNT());\n"
"SELECT * FROM t2;"
msgstr ""

msgid "The result is:"
msgstr ""

msgid ""
"---\n"
"- - [1, '#2 Triggered', 3]\n"
"  - [1, '#3 Triggered', 1]\n"
"  - [2, '#2 Triggered', 3]\n"
"  - [2, '#3 Triggered', 1]\n"
"  - [3, '#2 Triggered', 3]\n"
"  - [3, '#3 Triggered', 1]\n"
"  - [4, '#4 Untriggered', 3]\n"
"..."
msgstr ""

msgid "SOUNDEX"
msgstr ""

msgid ":samp:`SOUNDEX(string-expression)`"
msgstr ""

msgid ""
"Return a four-character string which represents the sound of ``string-"
"expression``. Often words and names which have different spellings will have"
" the same Soundex representation if they are pronounced similarly, so it is "
"possible to search by what they sound like. The algorithm works with "
"characters in the Latin alphabet and works best with English words."
msgstr ""

msgid ""
"Example: ``SOUNDEX('Crater')`` and ``SOUNDEX('Creature')`` both return "
"``C636``."
msgstr ""

msgid "SUBSTR"
msgstr ""

msgid ""
":samp:`SUBSTR({string-or-varbinary-value}, {numeric-start-position} [, "
"{numeric-length}])`"
msgstr ""

msgid ""
"If string-or-varbinary-value has data type STRING, then return the substring"
" which begins at character position numeric-start-position and continues for"
" numeric-length characters (if numeric-length is supplied), or continues "
"till the end of string-or-varbinary-value (if numeric-length is not "
"supplied)."
msgstr ""

msgid ""
"If numeric-start-position is less than 1, or if numeric-start-position + "
"numeric-length is greater than the length of string-or-varbinary-value, then"
" the result is not an error, anything which would be before the start or "
"after the end is ignored. There are no symbols with index <= 0 or with index"
" greater than the length of the first argument."
msgstr ""

msgid "If numeric-length is less than 0, then the result is an error."
msgstr ""

msgid ""
"If string-or-varbinary-value has data type VARBINARY rather than data type "
"STRING, then positioning and counting is by bytes rather than by characters."
msgstr ""

msgid ""
"Examples: ``SUBSTR('ABCDEF', 3, 2)`` is 'CD', ``SUBSTR('абвгде', -1, 4)`` is"
" 'аб'"
msgstr ""

msgid "TRIM"
msgstr ""

msgid ""
":samp:`TRIM([[LEADING|TRAILING|BOTH] [{expression-1}] FROM] {expression-2})`"
msgstr ""

msgid ""
"Return expression-2 after removing all leading and/or trailing characters or"
" bytes. The expressions should have data type STRING or VARBINARY. If "
"LEADING|TRAILING|BOTH is omitted, the default is BOTH. If expression-1 is "
"omitted, the default is ' ' (space) for data type STRING or X'00' (nul) for "
"data type VARBINARY."
msgstr ""

msgid ""
"``TRIM('a' FROM 'abaaaaa')`` is 'b' -- all repetitions of 'a' are removed on"
" both sides; ``TRIM(TRAILING 'ב' FROM 'אב')`` is 'א' -- if all characters "
"are Hebrew, TRAILING means \"left\"; ``TRIM(X'004400')`` is X'44' -- the "
"default byte sequence to trim is X'00' when data type is VARBINARY; "
"``TRIM(LEADING 'abc' FROM 'abcd')`` is 'd' -- expression-1 can have more "
"than 1 character."
msgstr ""

msgid "TYPEOF"
msgstr ""

msgid ":samp:`TYPEOF({expression})`"
msgstr ""

msgid ""
"Return 'NULL' if the expression is NULL, or return 'scalar' if the "
"expression is the name of a column defined as SCALAR, or return the "
":ref:`data type <sql_column_def_data_type>` of the expression."
msgstr ""
"Возвращает ``'NULL'``, если выражение равно ``NULL``. Возвращает "
"``'scalar'``, если выражение --- это имя колонки, определенной как SCALAR. В"
" остальных случаях возвращает :ref:`тип данных <sql_column_def_data_type>` "
"выражения."

msgid ""
"``TYPEOF('A')`` returns 'string'; ``TYPEOF(RANDOMBLOB(1))`` returns "
"'varbinary'; ``TYPEOF(1e44)`` returns 'double' or 'number'; ``TYPEOF(-44)`` "
"returns 'integer'; ``TYPEOF(NULL)`` returns 'NULL'"
msgstr ""
"``TYPEOF('A')`` вернет ``'string'``; ``TYPEOF(RANDOMBLOB(1))`` вернет "
"``'varbinary'``; ``TYPEOF(1e44)`` вернет ``'double'`` или ``'number'``; "
"``TYPEOF(-44)`` вернет ``'integer'``; ``TYPEOF(NULL)`` вернет ``'NULL'``."

msgid ""
"Prior to Tarantool version 2.10, ``TYPEOF(expression)`` simply returned the "
"data type of the expression for all cases."
msgstr ""
"До версии Tarantool 2.10 ``TYPEOF(выражение)`` возвращало тип данных "
"результата выражения во всех случаях."

msgid "UNICODE"
msgstr ""

msgid ":samp:`UNICODE(string-expression)`"
msgstr ""

msgid ""
"Return the Unicode code point value of the first character of **string-"
"expression**. If *string-expression* is empty, the return is NULL. This is "
"the reverse of :ref:`CHAR(integer) <sql_function_char>`."
msgstr ""

msgid "Example: ``UNICODE('Щ')`` is 1065 (hexadecimal 0429)."
msgstr ""

msgid "UNLIKELY"
msgstr ""

msgid ":samp:`UNLIKELY({expression})`"
msgstr ""

msgid ""
"Return TRUE if the expression is probably false. Limitation: in fact "
"``UNLIKELY`` may return the same thing as :ref:`LIKELY "
"<sql_function_likely>`."
msgstr ""

msgid "Example: ``UNLIKELY('a' <= 'b')`` is TRUE."
msgstr ""

msgid "UPPER"
msgstr ""

msgid ":samp:`UPPER(string-expression)`"
msgstr ""

msgid ""
"Return the expression, with lower-case characters converted to upper case. "
"The reverse of ``UPPER`` is :ref:`LOWER <sql_function_lower>`."
msgstr ""

msgid "Example: ``UPPER('-4щl')`` is '-4ЩL'."
msgstr ""

msgid "UUID"
msgstr "UUID"

msgid ":samp:`UUID([integer])`"
msgstr ":samp:`UUID([integer])`"

msgid ""
"Return a Universal Unique Identifier, data type UUID. Optionally one can "
"specify a version number; however, at this time the only allowed version is "
"4, which is the default. UUID support in SQL was added in Tarantool version "
"2.9.1."
msgstr ""
"Возвращает универсальный уникальный идентификатор, тип данных UUID. "
"Опционально можно указать номер версии, однако на данный момент единственной"
" возможной версией является 4, которая установлена по умолчанию. Поддержка "
"UUID в SQL была добавлена в версии Tarantool 2.9.1."

msgid "Example: ``UUID()`` or ``UUID(4)``"
msgstr "Пример: ``UUID()`` или ``UUID(4)``"

msgid "VERSION"
msgstr ""

msgid ":samp:`VERSION()`"
msgstr ""

msgid "Return the Tarantool version."
msgstr ""

msgid ""
"Example: for a February 2020 build VERSION() is ``'2.4.0-35-g57f6fc932'``."
msgstr ""

msgid "ZEROBLOB"
msgstr ""

msgid ":samp:`ZEROBLOB({n})`"
msgstr ""

msgid "Return a byte sequence, data type = VARBINARY, n bytes long."
msgstr ""

msgid "COLLATE clause"
msgstr ""

msgid ":samp:`COLLATE collation-name`"
msgstr ""

msgid "The collation-name must identify an existing collation."
msgstr ""

msgid ""
"The COLLATE clause is allowed for STRING or SCALAR items: |br| () in "
":ref:`CREATE INDEX <sql_create_index>` |br| () in :ref:`CREATE TABLE "
"<sql_create_table>` as part of :ref:`column definition <sql_column_def>` "
"|br| () in CREATE TABLE as part of :ref:`UNIQUE definition "
"<sql_table_constraint_def>` |br| () in string expressions |br|"
msgstr ""

msgid ""
"-- In CREATE INDEX\n"
"CREATE INDEX idx_unicode_mb_1 ON mb (s1 COLLATE \"unicode\");\n"
"-- In CREATE TABLE\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 STRING COLLATE \"unicode_ci\");\n"
"-- In CREATE TABLE ... UNIQUE\n"
"CREATE TABLE mb (a STRING, b STRING, PRIMARY KEY(a), UNIQUE(b COLLATE \"unicode_ci\" DESC));\n"
"-- In string expressions\n"
"SELECT 'a' = 'b' COLLATE \"unicode\"\n"
"    FROM t\n"
"    WHERE s1 = 'b' COLLATE \"unicode\"\n"
"    ORDER BY s1 COLLATE \"unicode\";"
msgstr ""

msgid ""
"The list of collations can be seen with: :ref:`PRAGMA collation_list; "
"<sql_pragma>`"
msgstr ""

msgid ""
"The collation rules comply completely with the Unicode Technical Standard "
"#10 (`\"Unicode Collation Algorithm\" <http://unicode.org/reports/tr10/>`_) "
"and the default character order is as in the `Default Unicode Collation "
"Element Table (DUCET) "
"<https://www.unicode.org/Public/UCA/8.0.0/allkeys.txt>`_. There are many "
"permanent collations; the commonly used ones include: |br| |nbsp| |nbsp| "
"``\"none\"`` (not applicable) |br| |nbsp| |nbsp| ``\"unicode\"`` (characters"
" are in DUCET order with strength = 'tertiary') |br| |nbsp| |nbsp| "
"``\"unicode_ci\"`` (characters are in DUCET order with strength = 'primary')"
" |br| |nbsp| |nbsp| ``\"binary\"`` (characters are in code point order) |br|"
" These identifiers must be quoted and in lower case because they are in "
"lower case in :ref:`Tarantool/NoSQL collations <index-collation>`."
msgstr ""

msgid ""
"If one says ``COLLATE \"binary\"``, this is equivalent to asking for what is"
" sometimes called \"code point order\" because, if the contents are in the "
"UTF-8 character set, characters with larger code points will appear after "
"characters with lower code points."
msgstr ""

msgid ""
"In an expression, ``COLLATE`` is an operator with higher precedence than "
"anything except ``~``. This is fine because there are no other useful "
"operators except ``||`` and comparison. After ``||``, collation is "
"preserved."
msgstr ""

msgid ""
"In an expression with more than one ``COLLATE`` clause, if the collation "
"names differ, there is an error: \"Illegal mix of collations\". In an "
"expression with no ``COLLATE`` clauses, literals have collation "
"``\"binary\"``, columns have the collation specified by ``CREATE TABLE``."
msgstr ""

msgid ""
"In other words, to pick a collation, Tarantool uses: |br| the first "
"``COLLATE`` clause in an expression if it was specified, |br| else the "
"column's ``COLLATE`` clause if it was specified, |br| else ``\"binary\"``."
msgstr ""

msgid ""
"However, for searches and sometimes for sorting, the collation may be an "
"index's collation, so all non-index ``COLLATE`` clauses are ignored."
msgstr ""

msgid ""
":ref:`EXPLAIN <sql_explain>` will not show the name of what collation was "
"used, but will show the collation's characteristics."
msgstr ""

msgid ""
"Example with Swedish collation: |br| Knowing that \"sv\" is the two-letter "
"code for Swedish, |br| and knowing that \"s1\" means strength = 1, |br| and "
"seeing with ``PRAGMA collation_list;`` that there is a collation named "
"unicode_sv_s1, |br| check whether two strings are equal according to Swedish"
" rules (yes they are): |br| ``SELECT 'ÄÄ' = 'ĘĘ' COLLATE "
"\"unicode_sv_s1\";``"
msgstr ""

msgid ""
"Example with Russian and Ukrainian and Kyrgyz collations: |br| Knowing that "
"Russian collation is practically the same as Unicode default, |br| and "
"knowing that the two-letter codes for Ukrainian and Kyrgyz are 'uk' and "
"'ky', |br| and knowing that in Russian (but not Ukrainian) 'Г' = 'Ґ' with "
"strength=primary, |br| and knowing that in Russian (but not Kyrgyz) 'Е' = "
"'Ё' with strength=primary, |br| the three SELECT statements here will return"
" results in three different orders: |br| ``CREATE TABLE things (remark "
"STRING PRIMARY KEY);`` |br| ``INSERT INTO things VALUES ('Е2'), ('Ё1');`` "
"|br| ``INSERT INTO things VALUES ('Г2'), ('Ґ1');`` |br| ``SELECT remark FROM"
" things ORDER BY remark COLLATE \"unicode\";`` |br| ``SELECT remark FROM "
"things ORDER BY remark COLLATE \"unicode_uk_s1\";`` |br| ``SELECT remark "
"FROM things ORDER BY remark COLLATE \"unicode_ky_s1\";``"
msgstr ""

msgid "Default function parameters"
msgstr "Параметры функций по умолчанию"

#, fuzzy
msgid ""
"Starting in Tarantool 2.10, if a parameter for an :ref:`aggregate function "
"<sql_aggregate>` or a :ref:`built-in scalar SQL function <sql_functions>` is"
" one of the ``extra-parameters`` that can appear in "
":ref:`box.execute(...[,extra-parameters]) <box-sql_box_execute>` requests, "
"default data type is calculated thus: |br| * When there is only one possible"
" data type, it is default. |br| Example: ``box.execute([[SELECT "
"TYPEOF(LOWER(?));]],{x})`` is 'string'. |br| * When possible data types are "
"INTEGER or DOUBLE or DECIMAL, DECIMAL is default. |br| Example: "
"``box.execute([[SELECT TYPEOF(AVG(?));]],{x})`` is 'decimal'. |br| * When "
"possible data types are STRING or VARBINARY, STRING is default. |br| "
"Example: ``box.execute([[SELECT TYPEOF(LENGTH(?));]],{x})`` is 'string'. "
"|br| * When possible data types are any other scalar data type, SCALAR is "
"default. |br| Example: ``box.execute([[SELECT "
"TYPEOF(GREATEST(?,5));]],{x})`` is 'scalar'. |br| * When possible data type "
"is a non-scalar data type, such as ARRAY, result is undefined. |br| * "
"Otherwise, there is no default. |br| Example: ``box.execute([[SELECT "
"TYPEOF(LIKELY(?));]],{x})`` is the name of one of the primitive data types."
msgstr ""
"Начиная с Tarantool 2.10 действует следующее поведение. Если параметр "
":ref:`агрегатной функции <sql_aggregate>` или :ref:`встроенных функций SQL "
"для scalar <sql_functions>` --- один из дополнительных параметров ``extra-"
"parameters``, которые могут появляться в запросах "
":ref:`box.execute(...[,extra-parameters]) <box-sql_box_execute>`, тип данных"
" по умолчанию определяется следующим образом: |br| * Если возможен только "
"один тип данных, он используется по умолчанию. |br| Пример: "
"``box.execute([[SELECT TYPEOF(LOWER(?));]],{x})``, тип --- ``'string'``. "
"|br| * Если возможные типы данных --- INTEGER, DOUBLE или DECIMAL, по "
"умолчанию используется DECIMAL. |br| Пример: ``box.execute([[SELECT "
"TYPEOF(AVG(?));]],{x})``, тип --- ``'decimal'``. |br| * Если возможные типы "
"данных --- STRING или VARBINARY, по умолчанию используется STRING. |br| "
"Пример: ``box.execute([[SELECT TYPEOF(LENGTH(?));]],{x})``, тип --- "
"``'string'``. |br| * Если возможны любые другие скалярные типы данных, по "
"умолчанию используется SCALAR. |br| Пример: ``box.execute([[SELECT "
"TYPEOF(GREATEST(?,5));]],{x})``, тип --- ``'scalar'``. |br| * Для всех "
"остальных случаев значения по умолчанию нет. |br| Пример: "
"``box.execute([[SELECT TYPEOF(LIKELY(?));]],{x})`` --- имя одного из "
"примитивных типов данных."

#~ msgid ""
#~ ":ref:`INSERT <sql_insert>`, :ref:`UPDATE <sql_update>`, :ref:`DELETE "
#~ "<sql_delete>`, :ref:`REPLACE <sql_replace>`, :ref:`TRUNCATE <sql_truncate>`,"
#~ " :ref:`SET <sql_set>`"
#~ msgstr ""

#~ msgid ""
#~ "Define a column, which is a table-element used in a :ref:`CREATE TABLE "
#~ "<sql_create_table>` statement."
#~ msgstr ""

#~ msgid ""
#~ "explained in the later section :ref:`\"Table Constraint Definition\" "
#~ "<sql_table_constraint_def>`"
#~ msgstr ""

#~ msgid "explained in the later section \"Table Constraint Definition\""
#~ msgstr ""

#~ msgid ""
#~ "explained in the later section :ref:`\"Table Constraint Definition for "
#~ "foreign keys\" <sql_foreign_key>`"
#~ msgstr ""

#~ msgid ""
#~ "means \"if INSERT does not assign to this column then assign expression "
#~ "result to this column\" -- if there is no DEFAULT clause then DEFAULT NULL "
#~ "is assumed."
#~ msgstr ""

#~ msgid "Table Constraint Definition"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`[CONSTRAINT {constraint-name}] primary-key-constraint | unique-"
#~ "constraint | check-constraint | foreign-key-constraint`"
#~ msgstr ""

#~ msgid ""
#~ "Define a constraint, which is a table-element used in a CREATE TABLE "
#~ "statement."
#~ msgstr ""

#~ msgid ""
#~ "The constraint-name must be an identifier which is valid according to the "
#~ "rules for identifiers. The constraint-name must be unique within the table."
#~ msgstr ""

#~ msgid ""
#~ "PRIMARY KEY constraints look like this: |br| :samp:`PRIMARY KEY ({column-"
#~ "name} [, {column-name}...])`"
#~ msgstr ""

#~ msgid ""
#~ "Every table must have one and only one primary key. |br| Primary-key columns"
#~ " are automatically NOT NULL. |br| Primary-key columns are automatically "
#~ "indexed. |br| Primary-key columns are unique, that is, it is illegal to have"
#~ " two rows which have the same values for the columns specified in the "
#~ "constraint."
#~ msgstr ""

#~ msgid ""
#~ "-- this is a table with a one-column primary-key constraint\n"
#~ "CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
#~ "-- this is the column-definition shorthand for the same thing:\n"
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY);\n"
#~ "-- this is a table with a two-column primary-key constraint\n"
#~ "CREATE TABLE t2 (s1 INTEGER, s2 INTEGER, PRIMARY KEY (s1, s2));\n"
#~ "-- this is an example of an attempted primary-key violation\n"
#~ "-- (the third INSERT will fail because 55, 'a' is a duplicate)\n"
#~ "CREATE TABLE t3 (s1 INTEGER, s2 STRING, PRIMARY KEY (s1, s2));\n"
#~ "INSERT INTO t3 VALUES (55, 'a');\n"
#~ "INSERT INTO t3 VALUES (55, 'b');\n"
#~ "INSERT INTO t3 VALUES (55, 'a');"
#~ msgstr ""

#~ msgid ""
#~ "PRIMARY KEY plus AUTOINCREMENT modifier may be specified in one of two ways:"
#~ " |br| - In a column definition after the words PRIMARY KEY, as in ``CREATE "
#~ "TABLE t (c INTEGER PRIMARY KEY AUTOINCREMENT);`` |br| - In a PRIMARY KEY "
#~ "(column-list) after a column name, as in ``CREATE TABLE t (c INTEGER, "
#~ "PRIMARY KEY (c AUTOINCREMENT));`` |br| When AUTOINCREMENT is specified, the "
#~ "column must be a primary-key column and it must be INTEGER or UNSIGNED. |br|"
#~ " Only one column in the table may be autoincrement. However, it is legal to "
#~ "say ``PRIMARY KEY (a, b, c AUTOINCREMENT)`` -- in that case, there are three"
#~ " columns in the primary key but only the first column (``a``) is "
#~ "AUTOINCREMENT."
#~ msgstr ""

#~ msgid ""
#~ "UNIQUE constraints look like this: |br| :samp:`UNIQUE ({column-name} [, "
#~ "{column-name}...])`"
#~ msgstr ""

#~ msgid ""
#~ "Unique constraints are similar to primary-key constraints, except that: a "
#~ "table may have any number of unique keys, and unique keys are not "
#~ "automatically NOT NULL. |br| Unique columns are automatically indexed. |br| "
#~ "Unique columns are unique, that is, it is illegal to have two rows with the "
#~ "same values in the unique-key columns."
#~ msgstr ""

#~ msgid ""
#~ "-- this is a table with a one-column primary-key constraint\n"
#~ "-- and a one-column unique constraint\n"
#~ "CREATE TABLE t1 (s1 INTEGER, s2 INTEGER, PRIMARY KEY (s1), UNIQUE (s2));\n"
#~ "-- this is the column-definition shorthand for the same thing:\n"
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER UNIQUE);\n"
#~ "-- this is a table with a two-column unique constraint\n"
#~ "CREATE TABLE t2 (s1 INTEGER PRIMARY KEY, s2 INTEGER, UNIQUE (s2, s1));\n"
#~ "-- this is an example of an attempted unique-key violation\n"
#~ "-- (the third INSERT will not fail because NULL is not a duplicate)\n"
#~ "-- (the fourth INSERT will fail because 'a' is a duplicate)\n"
#~ "CREATE TABLE t3 (s1 INTEGER PRIMARY KEY, s2 STRING, UNIQUE (s2));\n"
#~ "INSERT INTO t3 VALUES (1, 'a');\n"
#~ "INSERT INTO t3 VALUES (2, NULL);\n"
#~ "INSERT INTO t3 VALUES (3, NULL);\n"
#~ "INSERT INTO t3 VALUES (4, 'a');"
#~ msgstr ""

#~ msgid "CHECK constraints look like this: |br| :samp:`CHECK ({expression})`"
#~ msgstr ""

#~ msgid ""
#~ "-- this is a table with a one-column primary-key constraint\n"
#~ "-- and a check constraint\n"
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER, CHECK (s2 <> s1));\n"
#~ "-- this is an attempt to violate the constraint, it will fail\n"
#~ "INSERT INTO t1 VALUES (1, 1);\n"
#~ "-- this is okay because comparison with NULL will not return FALSE\n"
#~ "INSERT INTO t1 VALUES (1, NULL);\n"
#~ "-- a constraint that makes it difficult to insert lower case\n"
#~ "CHECK (s1 = UPPER(s1))"
#~ msgstr ""

#~ msgid ""
#~ "Limitations: (`Issue#3503 "
#~ "<https://github.com/tarantool/tarantool/issues/3503>`_): |br| * ``CREATE "
#~ "TABLE t99 (s1 INTEGER, UNIQUE(s1, s1),PRIMARY KEY(s1));`` causes no error "
#~ "message, although (s1, s1) is probably a user error."
#~ msgstr ""

#~ msgid "Table Constraint Definition for foreign keys"
#~ msgstr ""

#~ msgid ""
#~ "FOREIGN KEY constraints look like this: |br| :samp:`FOREIGN KEY "
#~ "({referencing-column-name} [, {referencing-column-name}...]) REFERENCES "
#~ "{referenced-table-name} [({referenced-column-name} [, {referenced-column-"
#~ "name}...]]) [MATCH FULL] [update-or-delete-rules]`"
#~ msgstr ""

#~ msgid ""
#~ "There is a shorthand: specifying REFERENCES in a :ref:`column definition "
#~ "<sql_column_def_constraint>`."
#~ msgstr ""

#~ msgid ""
#~ "The referencing column names must be defined in the table that is being "
#~ "created. The referenced table name must refer to a table that already "
#~ "exists, or to the table that is being created. The referenced column names "
#~ "must be defined in the referenced table, and have similar data types. There "
#~ "must be a PRIMARY KEY or UNIQUE constraint or UNIQUE index on the referenced"
#~ " column names."
#~ msgstr ""

#~ msgid "The words MATCH FULL are optional and have no effect."
#~ msgstr ""

#~ msgid ""
#~ "If a foreign-key constraint exists, then the values in the referencing "
#~ "columns must equal values in the referenced columns of the referenced table,"
#~ " or at least one of the referencing columns must contain NULL."
#~ msgstr ""

#~ msgid ""
#~ "-- A foreign key referencing a primary key in the same table\n"
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER, FOREIGN KEY (s2) REFERENCES t1 (s1));\n"
#~ "-- The same thing with column shorthand\n"
#~ "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER REFERENCES t1(s1));\n"
#~ "-- An attempt to violate the constraint -- this will fail\n"
#~ "INSERT INTO t1 VALUES (1, 2);\n"
#~ "-- A NULL in the referencing column -- this will succeed\n"
#~ "INSERT INTO t1 VALUES (1, NULL);\n"
#~ "-- A reference to a primary key that now exists -- this will succeed\n"
#~ "INSERT INTO t1 VALUES (2, 1);"
#~ msgstr ""

#~ msgid ""
#~ "The optional update-or-delete rules look like this: |br| ``ON "
#~ "{UPDATE|DELETE} { CASCADE | SET DEFAULT | SET NULL | RESTRICT | NO ACTION}``"
#~ " |br| and the idea is: if something changes the referenced key, then one of "
#~ "these possible \"referential actions\" takes place: |br| ``CASCADE``: the "
#~ "change that is applied for the referenced key is applied for the referencing"
#~ " key. |br| ``SET DEFAULT``: the referencing key is set to its default value."
#~ " |br| ``SET NULL``: the referencing key is set to NULL. |br| ``RESTRICT``: "
#~ "the UPDATE or DELETE fails if a referencing key exists; checked immediately."
#~ " |br| ``NO ACTION``: the UPDATE or DELETE fails if a referencing key exists;"
#~ " checked at statement end. |br| The default is ``NO ACTION``."
#~ msgstr ""

#~ msgid ""
#~ "CREATE TABLE f1 (ordinal INTEGER PRIMARY KEY,\n"
#~ "             referenced_planet STRING UNIQUE NOT NULL);\n"
#~ "CREATE TABLE f2 (\n"
#~ "    ordinal INTEGER PRIMARY KEY,\n"
#~ "    referring_planet STRING DEFAULT 'Earth',\n"
#~ "    FOREIGN KEY (referring_planet) REFERENCES f1 (referenced_planet)\n"
#~ "        ON UPDATE SET DEFAULT\n"
#~ "        ON DELETE CASCADE);\n"
#~ "INSERT INTO f1 VALUES (1, 'Mercury'), (2,' Venus'), (3, 'Earth');\n"
#~ "INSERT INTO f2 VALUES (1, 'Mercury'), (2, 'Mercury');\n"
#~ "UPDATE f1 SET referenced_planet = 'Mars'\n"
#~ "    WHERE referenced_planet = 'Mercury';\n"
#~ "SELECT * FROM f2;\n"
#~ "DELETE FROM f1 WHERE referenced_planet = 'Earth';\n"
#~ "SELECT * FROM f2;\n"
#~ "... In this example, the UPDATE statement changes the referenced key,\n"
#~ "    and the clause is ON UPDATE SET DEFAULT, therefore both of the\n"
#~ "    rows in f2 have referring_planet set to their default value,\n"
#~ "    which is 'Earth'. The DELETE statement deletes the row that\n"
#~ "    has 'Earth', and the clause is ON DELETE CASCADE,\n"
#~ "    therefore both of the rows in f2 are deleted."
#~ msgstr ""

#~ msgid ""
#~ "Limitations: |br| * Foreign keys can have a MATCH clause (`Issue#3455 "
#~ "<https://github.com/tarantool/tarantool/issues/3455>`_)."
#~ msgstr ""

#~ msgid ""
#~ "``setting-name`` can be any one of ``\"error_marshaling_enabled\"``. "
#~ "``\"sql_default_engine\"``. ``\"sql_defer_foreign_keys\"``, "
#~ "``\"sql_full_column_names\"``, ``\"sql_full_metadata\"``, "
#~ "``\"sql_parser_debug\"``, ``\"sql_recursive_triggers\"``, "
#~ "``\"sql_reverse_unordered_selects\"``, ``\"sql_select_debug\"``, "
#~ "``\"sql_vdbe_debug\"``. The quote marks are necessary."
#~ msgstr ""

#~ msgid ":samp:`FROM table-reference [, table-reference ...]`"
#~ msgstr ""

#~ msgid ""
#~ "-- the simplest form:\n"
#~ "SELECT * FROM t;\n"
#~ "-- with two tables, making a Cartesian join:\n"
#~ "SELECT * FROM t1, t2;\n"
#~ "-- with one table joined to itself, requiring correlation names:\n"
#~ "SELECT a.*, b.* FROM t1 AS a, t1 AS b;\n"
#~ "-- with a left outer join:\n"
#~ "SELECT * FROM t1 LEFT JOIN t2;"
#~ msgstr ""

#~ msgid ""
#~ "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which"
#~ " contains [4] -- and now the importance of the WHERE clause becomes evident,"
#~ " because \"s1 < 4\" is false for this row, and therefore we have reached the"
#~ " \"stop\" condition."
#~ msgstr ""

#~ msgid ""
#~ "Ordinarily Tarantool chooses the appropriate index or lookup method "
#~ "depending on a complex set of \"optimizer\" rules; the INDEXED BY clause "
#~ "overrides the optimizer choice. If the index was defined with the "
#~ ":ref:`exclude_null <box_space-is_nullable>` parts option, it will only be "
#~ "used if the user specifies it."
#~ msgstr ""

#~ msgid ""
#~ "Return a result set with one row for each column in \"table-name.index-"
#~ "name\". Each row contains: |br| (INTEGER) seqno -- the column's ordinal "
#~ "position in the index (first column is 0) |br| (INTEGER) cid -- the column's"
#~ " ordinal position in the table (first column is 0) |br| (STRING) name -- "
#~ "name of the column |br| (INTEGER) desc -- 0 if ASC, 1 if DESC |br| (STRING) "
#~ "collation name |br| (STRING) type -- data type |br|"
#~ msgstr ""

#~ msgid ""
#~ "Return a result set with one row for each index of \"table-name\". Each row "
#~ "contains: |br| (INTEGER) seq -- sequential number |br| (STRING) name -- "
#~ "index name |br| (INTEGER) unique -- whether the index is unique, 0 = false, "
#~ "1 = true |br| The system table is ``\"_index\"``."
#~ msgstr ""

#~ msgid ""
#~ ":samp:`SUBSTR({expression-1}, {numeric-expression-1} [, {numeric-"
#~ "expression-2}])`"
#~ msgstr ""

#~ msgid ""
#~ "If expression-1 has data type STRING, then return the substring which begins"
#~ " at character position numeric-expression-1 and continues for numeric-"
#~ "expression-2 characters (if numeric-expression-2 is supplied), or continues "
#~ "till the end of string-expression-1 (if numeric-expression-2 is not "
#~ "supplied)."
#~ msgstr ""

#~ msgid ""
#~ "If expression-1 has data type VARBINARY rather than data type STRING, then "
#~ "positioning and counting is by bytes rather than by characters."
#~ msgstr ""

#~ msgid "Example: ``SUBSTR('ABCDEFG', 3, 2)`` is 'CD'"
#~ msgstr ""

#~ msgid ""
#~ "In other words, to pick a collation, we use: |br| the first ``COLLATE`` "
#~ "clause in an expression if it was specified, |br| else the the column's "
#~ "``COLLATE`` clause if it was specified, |br| else ``\"binary\"``."
#~ msgstr ""
