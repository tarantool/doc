
msgid "LuaJIT getmetrics"
msgstr "Метрики LuaJIT"

msgid ""
"Tarantool can return metrics of a current instance via the Lua API or the C "
"API."
msgstr ""
"Tarantool может возвращать метрики текущего экземпляра через Lua API или C "
"API."

msgid "misc.getmetrics()"
msgstr "misc.getmetrics()"

msgid "Get the metrics values into a table."
msgstr "Получение значений метрик в виде таблицы."

msgid "Parameters: none"
msgstr "Параметры: нет"

msgid "return"
msgstr "возвращает"

msgid "table"
msgstr "таблицу"

msgid "Example: ``metrics_table = misc.getmetrics()``"
msgstr "Пример: ``metrics_table = misc.getmetrics()``"

msgid "getmetrics table values"
msgstr "Значения в таблице getmetrics"

msgid ""
"The metrics table contains 19 values. All values have type = 'number' and "
"are the result of a cast to double, so there may be a very slight precision "
"loss. Values whose names begin with ``gc_`` are associated with the `LuaJIT "
"garbage collector <http://wiki.luajit.org/New-Garbage-Collector/>`_; a "
"fuller study of the garbage collector can be found at `a Lua-users wiki page"
" <http://lua-users.org/wiki/EmergencyGarbageCollector>`_ and `a slide from "
"the creator of Lua "
"<https://www.lua.org/wshop18/Ierusalimschy.pdf#page=16>`_. Values whose "
"names begin with ``jit_`` are associated with the `\"phases\" "
"<https://en.wikipedia.org/wiki/Tracing_just-in-time_compilation>`_ of the "
"just-in-time compilation process; a fuller study of JIT phases can be found "
"at `A masters thesis from cern.ch "
"<http://cds.cern.ch/record/2692915/files/CERN-"
"THESIS-2019-152.pdf?version=1>`_."
msgstr ""
"Таблица метрик содержит 19 значений типа ``number``. Они получены в "
"результате приведения к вещественному типу двойной точности (double), что "
"позволяет практически не терять в точности исходных значений. Значения, "
"имена которых начинаются на ``gc_``, связаны со `сборщиком мусора в LuaJIT "
"<http://wiki.luajit.org/New-Garbage-Collector/>`_. Полную информацию о "
"сборщике мусора можно найти на `вики-странице lua-users <http://lua-"
"users.org/wiki/EmergencyGarbageCollector>`_ и `слайде от создателя языка Lua"
" <https://www.lua.org/wshop18/Ierusalimschy.pdf#page=16>`_. Значения, имена "
"которых начинаются на ``jit_``, связаны с `фазами "
"<https://en.wikipedia.org/wiki/Tracing_just-in-time_compilation>`_ JIT-"
"компиляции. Более подробно фазы описаны в `научной работе, написанной в "
"рамках одного из проектов ЦЕРН "
"<http://cds.cern.ch/record/2692915/files/CERN-"
"THESIS-2019-152.pdf?version=1>`_."

msgid ""
"Values described as \"monotonic\" are cumulative, that is, they are \"totals"
" since all operations began\", rather than \"since the last getmetrics() "
"call\". Overflow is possible."
msgstr ""
"Монотонными называются суммарные значения, которые подсчитываются с момента "
"начала работы, а не с момента последнего вызова getmetrics(). Возможно "
"переполнение значений."

msgid ""
"Because many values are monotonic, a typical analysis involves calling "
"``getmetrics()``, saving the table, calling ``getmetrics()`` again and "
"comparing the table to what was saved. The difference is a \"slope curve\". "
"An interesting slope curve is one that shows acceleration, for example the "
"difference between the latest value and the previous value keeps increasing."
" Some of the table members shown here are used in the examples that come "
"later in this section."
msgstr ""
"Поскольку многие значения монотонны, анализ обычно проходит так: вызывается "
"``getmetrics()``, полученная таблица сохраняется, а затем ``getmetrics()`` "
"вызывается вновь и новая таблица сравнивается с сохраненной. Разницу между "
"значениями, измеренными в два момента времени, называют кривой наклона. "
"Интерес может представлять, например, кривая наклона, которая демонстрирует "
"ускорение. Разница между последним и предыдущим значениями на такой кривой "
"все время увеличивается. Для некоторых элементов таблицы ниже будут "
"приведены примеры."

msgid "Name"
msgstr "Имя"

msgid "Content"
msgstr "Содержимое"

msgid "Monotonic?"
msgstr "Монотонное?"

msgid "gc_allocated"
msgstr "gc_allocated"

msgid "number of bytes of allocated memory"
msgstr "количество выделенной памяти в байтах"

msgid "yes"
msgstr "да"

msgid "gc_cdatanum"
msgstr "gc_cdatanum"

msgid "number of allocated cdata objects"
msgstr "количество размещенных объектов cdata"

msgid "no"
msgstr "нет"

msgid "gc_freed"
msgstr "gc_freed"

msgid "number of bytes of freed memory"
msgstr "количество освобожденной памяти в байтах"

msgid "gc_steps_atomic"
msgstr "gc_steps_atomic"

msgid "number of steps of garbage collector, atomic phases, incremental"
msgstr "количество шагов сборщика мусора, фаза atomic, инкрементальная"

msgid "gc_steps_finalize"
msgstr "gc_steps_finalize"

msgid "number of steps of garbage collector, finalize"
msgstr "количество шагов сборщика мусора, фаза finalize"

msgid "gc_steps_pause"
msgstr "gc_steps_pause"

msgid "number of steps of garbage collector, pauses"
msgstr "количество шагов сборщика мусора, фаза pauses"

msgid "gc_steps_propagate"
msgstr "gc_steps_propagate"

msgid "number of steps of garbage collector, propagate"
msgstr "количество шагов сборщика мусора, фаза propagate"

msgid "gc_steps_sweep"
msgstr "gc_steps_sweep"

#, fuzzy
msgid ""
"number of steps of garbage collector, sweep phases (see the `Sweep phase "
"description`_)"
msgstr ""
"количество шагов сборщика мусора, фаза sweep. См. `описание фазы sweep`_"

msgid "gc_steps_sweepstring"
msgstr "gc_steps_sweepstring"

msgid "number of steps of garbage collector, sweep phases for strings"
msgstr "количество шагов сборщика мусора, фаза sweep для строк"

msgid "gc_strnum"
msgstr "gc_strnum"

msgid "number of allocated string objects"
msgstr "количество размещенных объектов-строк"

msgid "gc_tabnum"
msgstr "gc_tabnum"

msgid "number of allocated table objects"
msgstr "количество размещенных объектов-таблиц"

msgid "gc_total"
msgstr "gc_total"

msgid ""
"number of bytes of currently allocated memory (normally equals gc_allocated "
"minus gc_freed)"
msgstr ""
"текущее количество выделенной памяти в байтах (обычно равно разности "
"gc_allocated и gc_freed)"

msgid "gc_udatanum"
msgstr "gc_udatanum"

msgid "number of allocated udata objects"
msgstr "количество размещенных объектов udata"

msgid "jit_mcode_size"
msgstr "jit_mcode_size"

msgid "total size of all allocated machine code areas"
msgstr "общий объем выделенного машинного кода"

msgid "jit_snap_restore"
msgstr "jit_snap_restore"

msgid ""
"overall number of snap restores, based on the number of guard assertions "
"leading to stopping trace executions (see external `Snap tutorial`_)"
msgstr ""
"общее количество восстановлений стека по снимку (сработавших защитных "
"утверждений, которые привели к остановке выполнения трассы). См. внешнее "
"`руководство по SNAP`_."

msgid "jit_trace_abort"
msgstr "jit_trace_abort"

msgid "overall number of aborted traces"
msgstr "общее количество прерванных трассировок"

msgid "jit_trace_num"
msgstr "jit_trace_num"

msgid "number of JIT traces"
msgstr "количество JIT-трассировок"

msgid "strhash_hit"
msgstr "strhash_hit"

msgid ""
"number of strings being interned because, if a string with the same value is"
" found via the hash, a new one is not created / allocated"
msgstr ""
"количество интернированных строк (если строка уже есть в пуле, новая копия "
"не создается и память под нее не выделяется)"

msgid "strhash_miss"
msgstr "strhash_miss"

msgid "total number of strings allocations during the platform lifetime"
msgstr ""
"общее количество памяти, выделенной для строк за время жизни платформы"

msgid ""
"Note: Although value names are similar to value names in `ujit.getmetrics() "
"<https://ujit.readthedocs.io/en/latest/public/ujit-024.html#ujit-"
"getmetrics>`_ the values are not the same, primarily because many ujit "
"numbers are not monotonic."
msgstr ""
"Примечание. Функция `ujit.getmetrics() "
"<https://ujit.readthedocs.io/en/latest/public/ujit-024.html#ujit-"
"getmetrics>`_ возвращает похожие имена. Однако многие значения, используемые"
" в uJIT, не монотонны."

#, fuzzy
msgid ""
"Note: Although value names are similar to value names in :ref:`LuaJIT "
"metrics <metrics-reference-luajit>`, and the values are exactly the same, "
"misc.getmetrics() is slightly easier because there is no need to ‘require’ "
"the misc module."
msgstr ""
"Примечание. В :ref:`LuaJIT metrics <metrics-luajit>` используются похожие "
"имена и аналогичные значения. Отличие функции misc.getmetrics() в том, что "
"она не требует вызывать ``require`` для модуля misc."

msgid "getmetrics C API"
msgstr "C API для getmetrics"

msgid ""
"The Lua ``getmetrics()`` function is a wrapper for the C function "
"``luaM_metrics()``."
msgstr ""
"Lua-функция ``getmetrics()`` --- обертка для C-функции ``luaM_metrics()``."

msgid ""
"C programs may include a header named ``libmisclib.h``. The definitions in "
"``libmisclib.h`` include the following lines:"
msgstr ""
"Программы на C могут включать заголовок ``libmisclib.h``, куда входят "
"следующие определения:"

msgid ""
"struct luam_Metrics { /* the names described earlier for Lua */ }\n"
"\n"
"LUAMISC_API void luaM_metrics(lua_State *L, struct luam_Metrics *metrics);"
msgstr ""
"struct luam_Metrics { /* имена, описанные ранее для Lua */ }\n"
"\n"
"LUAMISC_API void luaM_metrics(lua_State *L, struct luam_Metrics *metrics);"

msgid ""
"The names of ``struct luam_Metrics`` members are the same as Lua's "
":ref:`getmetrics table values <luajit_getmetrics_tablevalues>` names. The "
"data types of ``struct luam_Metrics`` members are all ``size_t``. The "
"``luaM_metrics()`` function will fill the ``*metrics`` structure with the "
"metrics related to the Lua state anchored to the ``L`` coroutine."
msgstr ""
"Имена элементов структуры ``luam_Metrics`` совпадают с именами в "
":ref:`таблице значений getmetrics <luajit_getmetrics_tablevalues>` для Lua. "
"У всех элементов структуры ``luam_Metrics`` тип данных — ``size_t``. Функция"
" ``luaM_metrics()`` заполняет структуру ``*metrics`` метриками, относящимися"
" к Lua-состоянию, которое связано с корутиной ``L``."

msgid "**Example with a C program**"
msgstr "**Пример с программой на языке C**"

msgid ""
"Go through the :ref:`C stored procedures <f_c_tutorial-c_stored_procedures>`"
" tutorial. Replace the easy.c example with"
msgstr ""
"В руководстве Tarantool по :ref:`хранимым процедурам на языке C "
"<f_c_tutorial-c_stored_procedures>` перейдите к примеру с файлом ``easy.c``."
" Удалите содержимое файла и вставьте следующий код:"

#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <lmisclib.h>\n"
"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  lua_State *ls = luaT_state();\n"
"  struct luam_Metrics m;\n"
"  luaM_metrics(ls, &m);\n"
"  printf(\"allocated memory = %lu\\n\", m.gc_allocated);\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include <lmisclib.h>\n"
"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  lua_State *ls = luaT_state();\n"
"  struct luam_Metrics m;\n"
"  luaM_metrics(ls, &m);\n"
"  printf(\"allocated memory = %lu\\n\", m.gc_allocated);\n"
"  return 0;\n"
"}"

msgid ""
"Now when you go back to the client and execute the requests up to and "
"including the line ``capi_connection:call('easy')`` you will see that the "
"display is something like \"allocated memory = 4431950\" although the number"
" will vary."
msgstr ""
"Теперь, как в исходном примере, выполните через клиент запросы до "
"``capi_connection:call('easy')`` включительно. На экране появится следующее:"
" ``allocated memory = 4431950`` (число приведено для примера)."

msgid "Example with gc_strnum, strhash_miss, and strhash_hit"
msgstr "Пример с gc_strnum, strhash_miss и strhash_hit"

msgid "To track new string object allocations:"
msgstr "Отслеживать размещение новых строковых объектов можно так:"

msgid ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  local table_of_strings = {}\n"
"  for i = 3000, 4000 do table.insert(table_of_strings, tostring(i)) end\n"
"  for i = 3900, 4100 do table.insert(table_of_strings, tostring(i)) end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"gc_strnum diff = \" .. newm.gc_strnum - oldm.gc_strnum)\n"
"  print(\"strhash_miss diff = \" .. newm.strhash_miss - oldm.strhash_miss)\n"
"  print(\"strhash_hit diff = \" .. newm.strhash_hit - oldm.strhash_hit)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  local table_of_strings = {}\n"
"  for i = 3000, 4000 do table.insert(table_of_strings, tostring(i)) end\n"
"  for i = 3900, 4100 do table.insert(table_of_strings, tostring(i)) end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"gc_strnum diff = \" .. newm.gc_strnum - oldm.gc_strnum)\n"
"  print(\"strhash_miss diff = \" .. newm.strhash_miss - oldm.strhash_miss)\n"
"  print(\"strhash_hit diff = \" .. newm.strhash_hit - oldm.strhash_hit)\n"
"end\n"
"f()"

msgid ""
"The result will probably be: \"gc_strnum diff = 1100\" because we added 1202"
" strings but 101 were duplicates, \"strhash_miss_diff = 1100\" for the same "
"reason, \"strhash_hit_diff = 101\" plus some overhead, for the same reason. "
"(There is always a slight overhead amount for ``strhash_hit``, which can be "
"ignored.)"
msgstr ""
"Вероятный результат --- ``gc_strnum diff = 1101``, так как мы добавили 1202 "
"строки, 101 из которых были дубликатами. По той же причине ``strhash_miss = "
"1101``, а ``strhash_hit = 101`` плюс некоторые издержки. (``strhash_hit`` "
"всегда предполагает небольшие издержки, которые можно игнорировать.) "

msgid ""
"We say \"probably\" because there is a chance that the strings were already "
"allocated somewhere. It is a good thing if the slope curve of "
"``strhash_miss`` is less than the slope curve of ``strhash_hit``."
msgstr ""
"Результат лишь вероятный, поскольку память для строк могла быть выделена "
"ранее. Хорошо, если кривая наклона ``strhash_miss`` менее крутая, чем у "
"``strhash_hit``."

msgid ""
"The other ``gc_*num`` values -- ``gc_cdatanum``, ``gc_tabnum``, "
"``gc_udatanum`` -- can be accessed in a similar way. Any of the ``gc_*num`` "
"values can be useful when looking for memory leaks – the total number of "
"these objects should not grow nonstop. A more general way to look for memory"
" leaks is to watch ``gc_total``. Also ``jit_mcode_size`` can be used to "
"watch the amount of allocated memory for machine code traces."
msgstr ""
"Доступ к остальным значениям ``gc_*num`` --- ``gc_cdatanum``, ``gc_tabnum`` "
"и ``gc_udatanum`` можно получить аналогичным образом. Любое значение "
"``gc_*num`` поможет при поиске утечки памяти: общее количество этих объектов"
" не должно постоянно расти. Более общий способ искать утечки памяти --- "
"наблюдать за переменной ``gc_total``. Также можно отслеживать значение "
"``jit_mcode_size``, отражающее объем памяти, выделенной для трасс машинного "
"кода."

msgid "Example with gc_allocated and gc_freed"
msgstr "Пример с gc_allocated и gc_freed"

msgid ""
"To track an application's effect on the garbage collector (less is better):"
msgstr ""
"Чем меньше работает сборщик мусора, тем лучше. Отслеживать, насколько его "
"нагружает приложение, можно так:"

msgid ""
"function f()\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local oldm = misc.getmetrics()\n"
"  local newm = misc.getmetrics()\n"
"  oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  newm = misc.getmetrics()\n"
"  print(\"gc_allocated diff = \" .. newm.gc_allocated - oldm.gc_allocated)\n"
"  print(\"gc_freed diff = \" .. newm.gc_freed - oldm.gc_freed)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local oldm = misc.getmetrics()\n"
"  local newm = misc.getmetrics()\n"
"  oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  newm = misc.getmetrics()\n"
"  print(\"gc_allocated diff = \" .. newm.gc_allocated - oldm.gc_allocated)\n"
"  print(\"gc_freed diff = \" .. newm.gc_freed - oldm.gc_freed)\n"
"end\n"
"f()"

msgid ""
"The result will be: ``gc_allocated diff = 800``, ``gc_freed diff = 800``. "
"This shows that ``local ... = getmetrics()`` itself causes memory allocation"
" (because it is creating a table and assigning to it), and shows that when "
"the name of a variable (in this case the ``oldm`` variable) is used again, "
"that causes freeing. Ordinarily the freeing would not occur immediately, but"
" ``collectgarbage(\"collect\")`` forces it to happen so we can see the "
"effect."
msgstr ""
"Результат: ``gc_allocated diff = 800``, ``gc_freed diff = 800``. Отсюда "
"видно, что строка ``local ... = getmetrics()`` вызывает аллокацию памяти, "
"поскольку создает таблицу и наполняет ее значениями. Когда имя переменной (в"
" данном случае ``oldm``) используется повторно, память освобождается. Обычно"
" это происходит не сразу, однако ``collectgarbage(\"collect\")`` "
"принудительно запускает сборку мусора, благодаря чему можно немедленно "
"увидеть результат."

msgid "Example with gc_allocated and a space optimization"
msgstr "Пример с gc_allocated и оптимизацией по памяти"

msgid "To test whether optimizing for space is possible with tables:"
msgstr ""
"Этот пример показывает, что можно оптимизировать расход памяти для таблиц."

msgid ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  local t = {}\n"
"  for i = 1, 513 do\n"
"    t[i] = i\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.gc_allocated - oldm.gc_allocated\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  local t = {}\n"
"  for i = 1, 513 do\n"
"    t[i] = i\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.gc_allocated - oldm.gc_allocated\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"

msgid "The result will show that diff equals approximately 18000."
msgstr "Результат покажет, что значение diff примерно равно 18000."

msgid "Now see what happens if the table initialization is different:"
msgstr "Если инициализировать таблицу по-другому, получится вот что:"

msgid ""
"function f()\n"
"  local table_new = require \"table.new\"\n"
"  local oldm = misc.getmetrics()\n"
"  local t = table_new(513, 0)\n"
"  for i = 1, 513 do\n"
"    t[i] = i\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.gc_allocated - oldm.gc_allocated\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  local table_new = require \"table.new\"\n"
"  local oldm = misc.getmetrics()\n"
"  local t = table_new(513, 0)\n"
"  for i = 1, 513 do\n"
"    t[i] = i\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.gc_allocated - oldm.gc_allocated\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"

msgid "The result will show that diff equals approximately 6000."
msgstr "Результат покажет, что значение diff примерно равно 6000."

msgid "gc_steps_atomic and gc_steps_propagate"
msgstr "gc_steps_atomic и gc_steps_propagate"

msgid ""
"The slope curves of ``gc_steps_*`` items can be used for tracking pressure "
"on the garbage collector too. During long-running routines, ``gc_steps_*`` "
"values will increase, but long times between ``gc_steps_atomic`` increases "
"are a good sign, And, since ``gc_steps_atomic`` increases only once per "
"garbage-collector cycle, it shows how many garbage-collector cycles have "
"occurred."
msgstr ""
"Нагрузку на сборщик мусора помогают отслеживать кривые наклона метрик "
"``gc_steps_*``. Во время долго выполняющихся процедур значения "
"``gc_steps_*`` увеличиваются. При этом большие промежутки времени между "
"увеличениями ``gc_steps_atomic`` --- хороший признак. Поскольку "
"``gc_steps_atomic`` увеличивается только раз в цикл сбора мусора, можно "
"увидеть, сколько циклов прошло."

msgid ""
"Also, increases in the ``gc_steps_propagate`` number can be used to estimate"
" indirectly how many objects there are. These values also correlate with the"
" garbage collector's `step multiplier "
"<https://www.lua.org/manual/5.4/manual.html#2.5.1>`_. For example, the "
"number of incremental steps can grow, but according to the step multiplier "
"configuration, one step can process only a small number of objects. So these"
" metrics should be considered when configuring the garbage collector."
msgstr ""
"Кроме того, по тому, насколько выросло значение ``gc_steps_propagate``, "
"можно косвенно оценить количество объектов. Это значение также коррелирует с"
" `множителем шага сборщика мусора "
"<https://www.lua.org/manual/5.4/manual.html#2.5.1>`_. Например, количество "
"инкрементальных шагов может увеличиваться, однако множитель шага настроен "
"так, что за каждый шаг можно обработать лишь небольшое количество объектов. "
"Поэтому при настройке сборщика мусора следует учитывать эти показатели."

msgid ""
"The following function takes a casual look whether an SQL statement causes "
"much pressure:"
msgstr ""
"Следующая функция оценивает, вызывает ли оператор SQL большую нагрузку:"

msgid ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  box.execute([[DROP TABLE _vindex;]])\n"
"  local newm = misc.getmetrics()\n"
"  print(\"gc_steps_atomic = \" .. newm.gc_steps_atomic - oldm.gc_steps_atomic)\n"
"  print(\"gc_steps_finalize = \" .. newm.gc_steps_finalize - oldm.gc_steps_finalize)\n"
"  print(\"gc_steps_pause = \" .. newm.gc_steps_pause - oldm.gc_steps_pause)\n"
"  print(\"gc_steps_propagate = \" .. newm.gc_steps_propagate - oldm.gc_steps_propagate)\n"
"  print(\"gc_steps_sweep = \" .. newm.gc_steps_sweep - oldm.gc_steps_sweep)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  box.execute([[DROP TABLE _vindex;]])\n"
"  local newm = misc.getmetrics()\n"
"  print(\"gc_steps_atomic = \" .. newm.gc_steps_atomic - oldm.gc_steps_atomic)\n"
"  print(\"gc_steps_finalize = \" .. newm.gc_steps_finalize - oldm.gc_steps_finalize)\n"
"  print(\"gc_steps_pause = \" .. newm.gc_steps_pause - oldm.gc_steps_pause)\n"
"  print(\"gc_steps_propagate = \" .. newm.gc_steps_propagate - oldm.gc_steps_propagate)\n"
"  print(\"gc_steps_sweep = \" .. newm.gc_steps_sweep - oldm.gc_steps_sweep)\n"
"end\n"
"f()"

msgid ""
"And the display will show that the ``gc_steps_*`` metrics are not "
"significantly different from what they would be if the ``box.execute()`` was"
" absent."
msgstr ""
"Очевидно, значения метрик ``gc_steps_ *``, полученные до вызова "
"``box.execute()``, существенно не отличаются от значений, полученных после "
"этого вызова."

msgid "Example with jit_trace_num and jit_trace_abort"
msgstr "Пример с jit_trace_num и jit_trace_abort"

msgid ""
"Just-in-time compilers will \"trace\" code looking for opportunities to "
"compile. ``jit_trace_abort`` can show how often there was a failed attempt "
"(less is better), and ``jit_trace_num`` can show how many traces were "
"generated since the last flush (usually more is better)."
msgstr ""
"JIT-компиляторы трассируют код, пытаясь найти возможность для компиляции, "
"чтобы повысить производительность. Значение ``jit_trace_abort`` показывает, "
"как часто эти попытки оканчиваются неудачей (чем меньше это значение, тем "
"лучше), а ``jit_trace_num`` --- как много трассировок сгенерировано с "
"момента последнего выполнения операции flush (обычно чем больше значение, "
"тем лучше)."

msgid ""
"The following function does not contain code that can cause trouble for "
"LuaJIT:"
msgstr "Код следующей функции будет успешно трассирован:"

msgid ""
"function f()\n"
"  jit.flush()\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  local sum = 0\n"
"  for i = 1, 57 do\n"
"    sum = sum + 57\n"
"  end\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"trace_num = \" .. newm.jit_trace_num - oldm.jit_trace_num)\n"
"  print(\"trace_abort = \" .. newm.jit_trace_abort - oldm.jit_trace_abort)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  jit.flush()\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  local sum = 0\n"
"  for i = 1, 57 do\n"
"    sum = sum + 57\n"
"  end\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"trace_num = \" .. newm.jit_trace_num - oldm.jit_trace_num)\n"
"  print(\"trace_abort = \" .. newm.jit_trace_abort - oldm.jit_trace_abort)\n"
"end\n"
"f()"

msgid "The result is: trace_num = 1, trace_abort = 0. Fine."
msgstr "Результат: ``trace_num = 1``, ``trace_abort = 0``. Отлично."

msgid ""
"The following function seemingly does contain code that can cause trouble "
"for LuaJIT:"
msgstr ""
"А в следующей функции, похоже, есть код, способный вызвать у LuaJIT "
"проблемы:"

msgid ""
"jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"_G.globalthing = 5\n"
"function f()\n"
"  jit.flush()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  local sum = 0\n"
"  for i = 1, box.space._vindex:count()+ _G.globalthing do\n"
"    box.execute([[SELECT RANDOMBLOB(0);]])\n"
"    require('buffer').ibuf()\n"
"    _G.globalthing = _G.globalthing - 1\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"trace_num = \" .. newm.jit_trace_num - oldm.jit_trace_num)\n"
"  print(\"trace_abort = \" .. newm.jit_trace_abort - oldm.jit_trace_abort)\n"
"end\n"
"f()"
msgstr ""
"jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"_G.globalthing = 5\n"
"function f()\n"
"  jit.flush()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  local sum = 0\n"
"  for i = 1, box.space._vindex:count()+ _G.globalthing do\n"
"    box.execute([[SELECT RANDOMBLOB(0);]])\n"
"    require('buffer').ibuf()\n"
"    _G.globalthing = _G.globalthing - 1\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"trace_num = \" .. newm.jit_trace_num - oldm.jit_trace_num)\n"
"  print(\"trace_abort = \" .. newm.jit_trace_abort - oldm.jit_trace_abort)\n"
"end\n"
"f()"

msgid ""
"The result is: trace_num = between 2 and 4, trace_abort = 1. This means that"
" up to four traces needed to be generated instead of one, and this means "
"that something made LuaJIT give up in despair. Tracing more will reveal that"
" the problem is not the suspicious-looking statements within the function, "
"it is the ``jit.opt.start`` call. (A look at a jit.dump file might help in "
"examining the trace compilation process.)"
msgstr ""
"Результат: ``trace_num`` --- от ``2`` до ``4``, ``trace_abort = 1``. Это "
"означает, что нужно было сгенерировать до четырех трассировок вместо одной, "
"причем что-то заставило LuaJIT прекратить попытки. Дальнейшая трассировка "
"показывает, что проблема не в подозрительно выглядящих операторах внутри "
"функции, а в вызове ``jit.opt.start``. (Содержимое файла ``jit.dump`` может "
"помочь разобраться, как протекала компиляция трасс.)"

msgid "Example with jit_snap_restore and a performance unoptimization"
msgstr "Пример с jit_snap_restore и деоптимизацией производительности"

msgid ""
"If the slope curves of the ``jit_snap_restore`` metric grow after changes to"
" old code, that can mean LuaJIT is stopping trace execution more frequently,"
" and that can mean performance is degraded."
msgstr ""
"Если кривая наклона метрики ``jit_snap_restore`` после изменений в старом "
"коде растет, это может означать, что LuaJIT чаще останавливает выполнение "
"кода на трассах. А это, в свою очередь, может указывать на снижение "
"производительности."

msgid "Start with this code:"
msgstr "Рассмотрим следующий код:"

msgid ""
"function f()\n"
"  local function foo(i)\n"
"    return i <= 5 and i or tostring(i)\n"
"  end\n"
"  -- minstitch option needs to emulate nonstitching behaviour\n"
"  jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"  local sum = 0\n"
"  local oldm = misc.getmetrics()\n"
"  for i = 1, 10 do\n"
"    sum = sum + foo(i)\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.jit_snap_restore - oldm.jit_snap_restore\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  local function foo(i)\n"
"    return i <= 5 and i or tostring(i)\n"
"  end\n"
"  -- параметр minstitch нужен, чтобы эмулировать поведение non-stitching\n"
"  jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"  local sum = 0\n"
"  local oldm = misc.getmetrics()\n"
"  for i = 1, 10 do\n"
"    sum = sum + foo(i)\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.jit_snap_restore - oldm.jit_snap_restore\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"

msgid ""
"The result will be: diff = 3, because there is one side exit when the loop "
"ends, and there are two side exits to the interpreter before LuaJIT may "
"decide that the chunk of code is \"hot\" (the default value of the hotloop "
"parameter is 56 according to `Running LuaJIT  "
"<https://luajit.org/running.html#opt_O>`_)."
msgstr ""
"Результат: ``diff = 3``, поскольку при выполнении трассы возможны три "
"сторонних выхода. Один находится в конце цикла. Другие два переключают "
"выполнение на интерпретатор, прежде чем LuaJIT решит, что фрагмент кода "
"\"горячий\" (значение параметра ``hotloop`` по умолчанию равно ``56`` "
"согласно `документации LuaJIT  <https://luajit.org/running.html#opt_O>`_)."

msgid ""
"And now change only one line within function ``local foo``, so now the code "
"is:"
msgstr ""
"А теперь изменим единственную строку в функции ``local foo``, чтобы получить"
" следующий код:"

msgid ""
"function f()\n"
"  local function foo(i)\n"
"    -- math.fmod is not yet compiled!\n"
"    return i <= 5 and i or math.fmod(i, 11)\n"
"  end\n"
"  -- minstitch option needs to emulate nonstitching behaviour\n"
"  jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"  local sum = 0\n"
"  local oldm = misc.getmetrics()\n"
"  for i = 1, 10 do\n"
"    sum = sum + foo(i)\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.jit_snap_restore - oldm.jit_snap_restore\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  local function foo(i)\n"
"    -- функция math.fmod еще не скомпилирована\n"
"    return i <= 5 and i or math.fmod(i, 11)\n"
"  end\n"
"  -- параметр minstitch нужен, чтобы эмулировать поведение non-stitching\n"
"  jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"  local sum = 0\n"
"  local oldm = misc.getmetrics()\n"
"  for i = 1, 10 do\n"
"    sum = sum + foo(i)\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.jit_snap_restore - oldm.jit_snap_restore\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"

msgid ""
"The result will be: diff is larger, because there are more side exits. So "
"this test indicates that changing the code affected the performance."
msgstr ""
"Результат: значение ``diff`` увеличилось, так как сторонних выходов стало "
"больше. Этот тест показывает, что измение кода влияет на производительность."
