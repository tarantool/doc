# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-01-23 10:58+0000\n"
"PO-Revision-Date: 2019-10-23 18:45+0400\n"
"Last-Translator: \n"
"Language: ru\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../doc/tutorials/c_tutorial.rst:3
msgid "C tutorial"
msgstr "Практическое задание на C"

#: ../doc/tutorials/c_tutorial.rst:5
msgid ""
"Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-"
"c_stored_procedures>`."
msgstr ""
"Ниже приводится практическое занятие на языке C: :ref:`Хранимые процедуры"
" на языке C <f_c_tutorial-c_stored_procedures>`."

#: ../doc/tutorials/c_tutorial.rst:12
msgid "C stored procedures"
msgstr "Хранимые процедуры на языке C"

#: ../doc/tutorials/c_tutorial.rst:14
msgid ""
"Tarantool can call C code with :ref:`modules <app_server-modules>`, or "
"with :ref:`ffi <cookbook-ffi_printf>`, or with C stored procedures. This "
"tutorial only is about the third option, C stored procedures. In fact the"
" routines are always \"C functions\" but the phrase \"stored procedure\" "
"is commonly used for historical reasons."
msgstr ""
"Tarantool может вызывать код на языке C с помощью :ref:`модулей "
"<app_server-modules>`, :ref:`ffi <cookbook-ffi_printf>` или хранимых "
"процедур на C. В данном практическом задании рассматривается только "
"третий метод, хранимые процедуры на языке C. На самом деле, программы "
"всегда представляют собой функции на языке C, но исторически сложилось "
"так, что широко используется фраза \"хранимая процедура\"."

#: ../doc/tutorials/c_tutorial.rst:21
msgid ""
"In this tutorial, which can be followed by anyone with a Tarantool "
"development package and a C compiler, there are five tasks:"
msgstr ""
"Данное практическое задание могут выполнить те, у кого есть пакет "
"программ для разработки Tarantool'а и компилятор языка программирования "
"C. Оно состоит из пяти задач:"

#: ../doc/tutorials/c_tutorial.rst:24
msgid ":ref:`easy.c <f_c_tutorial-easy>` -- prints \"hello world\";"
msgstr ":ref:`easy.c <f_c_tutorial-easy>` -- выводит \"hello world\";"

#: ../doc/tutorials/c_tutorial.rst:25
msgid ":ref:`harder.c <f_c_tutorial-harder>` -- decodes a passed parameter value;"
msgstr ""
":ref:`harder.c <f_c_tutorial-harder>` -- декодирует переданное значение "
"параметра;"

#: ../doc/tutorials/c_tutorial.rst:26
msgid ""
":ref:`hardest.c <f_c_tutorial-hardest>` -- uses the C API to do a DBMS "
"insert;"
msgstr ""
":ref:`hardest.c <f_c_tutorial-hardest>` -- использует API для языка C для"
" вставки в базу данных;"

#: ../doc/tutorials/c_tutorial.rst:27
msgid ":ref:`read.c <f_c_tutorial-read>` -- uses the C API to do a DBMS select;"
msgstr ""
":ref:`read.c <f_c_tutorial-read>` -- использует API для языка C для "
"выборки из базы данных;"

#: ../doc/tutorials/c_tutorial.rst:28
msgid ""
":ref:`write.c <f_c_tutorial-write>` -- uses the C API to do a DBMS "
"replace."
msgstr ""
":ref:`write.c <f_c_tutorial-write>` -- использует API для языка C для "
"замены в базе данных."

#: ../doc/tutorials/c_tutorial.rst:30
msgid ""
"After following the instructions, and seeing that the results are what is"
" described here, users should feel confident about writing their own "
"stored procedures."
msgstr ""
"По окончании задания, вы увидите описанные здесь результаты и сможете "
"самостоятельно написать хранимые процедуры."

#: ../doc/tutorials/c_tutorial.rst:34
msgid "**Preparation**"
msgstr "**Подготовка**"

#: ../doc/tutorials/c_tutorial.rst:36
msgid "Check that these items exist on the computer:"
msgstr "Проверьте наличие следующих элементов на компьютере:"

#: ../doc/tutorials/c_tutorial.rst:38
msgid "Tarantool 1.10"
msgstr "Tarantool 1.10"

#: ../doc/tutorials/c_tutorial.rst:39
msgid "A gcc compiler, any modern version should work"
msgstr "Компилятор GCC, подойдет любая современная версия"

#: ../doc/tutorials/c_tutorial.rst:40
msgid "``module.h`` and files #included in it"
msgstr "``module.h`` и включенные в него файлы"

#: ../doc/tutorials/c_tutorial.rst:41
msgid "``msgpuck.h``"
msgstr "``msgpuck.h``"

#: ../doc/tutorials/c_tutorial.rst:42
msgid "``libmsgpuck.a`` (only for some recent msgpuck versions)"
msgstr "``libmsgpuck.a`` (только для некоторых последних версий msgpuck)"

#: ../doc/tutorials/c_tutorial.rst:44
msgid ""
"The ``module.h`` file will exist if Tarantool was installed from source. "
"Otherwise Tarantool's \"developer\" package must be installed. For "
"example on Ubuntu say:"
msgstr ""
"Файл ``module.h`` есть в системе, если Tarantool был установлен из "
"исходных файлов. В противном случае, следует установить пакет Tarantool'а"
" \"developer\". Например, на Ubuntu введите команду:"

#: ../doc/tutorials/c_tutorial.rst:48
msgid "$ sudo apt-get install tarantool-dev"
msgstr "$ sudo apt-get install tarantool-dev"

#: ../doc/tutorials/c_tutorial.rst:52
msgid "or on Fedora say:"
msgstr "или на Fedora введите команду:"

#: ../doc/tutorials/c_tutorial.rst:54
msgid "$ dnf -y install tarantool-devel"
msgstr "$ dnf -y install tarantool-devel"

#: ../doc/tutorials/c_tutorial.rst:58
msgid ""
"The ``msgpuck.h`` file will exist if Tarantool was installed from source."
" Otherwise the \"msgpuck\" package must be installed from "
"`https://github.com/rtsisyk/msgpuck "
"<https://github.com/rtsisyk/msgpuck>`_."
msgstr ""
"Файл ``msgpuck.h`` есть в системе, если Tarantool был установлен из "
"исходных файлов. В противном случае, следует установить пакет \"msgpuck\""
" по ссылке `https://github.com/rtsisyk/msgpuck "
"<https://github.com/rtsisyk/msgpuck>`_."

#: ../doc/tutorials/c_tutorial.rst:62
msgid ""
"Both ``module.h`` and ``msgpuck.h`` must be on the include path for the C"
" compiler to see them. For example, if ``module.h`` address is "
"``/usr/local/include/tarantool/module.h``, and ``msgpuck.h`` address is "
"``/usr/local/include/msgpuck/msgpuck.h``, and they are not currently on "
"the include path, say:"
msgstr ""
"Чтобы компилятор C увидел файлы ``module.h`` и ``msgpuck.h``, путь к ним "
"следует сохранить в переменной. Например, если адрес файла ``module.h`` "
"-- ``/usr/local/include/tarantool/module.h``, а адрес файла ``msgpuck.h``"
" -- ``/usr/local/include/msgpuck/msgpuck.h``, введите команду:"

#: ../doc/tutorials/c_tutorial.rst:68
msgid "$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"
msgstr "$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"

#: ../doc/tutorials/c_tutorial.rst:72
msgid ""
"The ``libmsgpuck.a`` static library is necessary with msgpuck versions "
"produced after February 2017. If and only if you encounter linking "
"problems when using the gcc statements in the examples for this tutorial,"
" you should put ``libmsgpuck.a`` on the path (``libmsgpuck.a`` is "
"produced from both msgpuck and Tarantool source downloads so it should be"
" easy to find). For example, instead of \":code:`gcc -shared -o harder.so"
" -fPIC harder.c`\" for the second example below, you will need to say "
"\":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."
msgstr ""
"Статическая библиотека ``libmsgpuck.a`` нужна для версий msgpuck старше "
"февраля 2017 года. Только в том случае, если встречаются проблемы "
"соединения при использовании операторов GCC в примерах данного "
"практического задания, в пути следует указывать ``libmsgpuck.a`` "
"(``libmsgpuck.a`` создан из исходных файлов загрузки msgpuck и Tarantool,"
" поэтому его легко найти). Например, вместо \":code:`gcc -shared -o "
"harder.so -fPIC harder.c`\" во втором примере ниже, необходимо ввести "
"\":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."

#: ../doc/tutorials/c_tutorial.rst:81
msgid ""
"Requests will be done using Tarantool as a :ref:`client <admin-"
"using_tarantool_as_a_client>`. Start Tarantool, and enter these requests."
msgstr ""
"Tarantool выполняет запросы в качестве :ref:`клиента <admin-"
"using_tarantool_as_a_client>`. Запустите Tarantool и введите эти запросы."

#: ../doc/tutorials/c_tutorial.rst:85
msgid ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"

#: ../doc/tutorials/c_tutorial.rst:93
msgid ""
"In plainer language: create a space named ``capi_test``, and make a "
"connection to self named ``capi_connection``."
msgstr ""
"Проще говоря: создайте спейс под названием ``capi_test``, и выполните "
"соединение с одноименным ``capi_connection``."

#: ../doc/tutorials/c_tutorial.rst:96
msgid ""
"Leave the client running. It will be necessary to enter more requests "
"later."
msgstr "Не закрывайте клиент. Он понадобится для последующих запросов."

#: ../doc/tutorials/c_tutorial.rst:100
msgid "**easy.c**"
msgstr "**easy.c**"

#: ../doc/tutorials/c_tutorial.rst:102
msgid ""
"Start another shell. Change directory (``cd``) so that it is the same as "
"the directory that the client is running on."
msgstr ""
"Запустите еще один терминал. Измените директорию (``cd``), чтобы она "
"совпадала с директорией, где запущен клиент."

#: ../doc/tutorials/c_tutorial.rst:105
msgid "Create a file. Name it ``easy.c``. Put these six lines in it."
msgstr ""
"Создайте файл. Назовите его ``easy.c``. Запишите в него следующие шесть "
"строк."

#: ../doc/tutorials/c_tutorial.rst:107
msgid ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}\n"
"int easy2(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  printf(\"hello world -- easy2\\n\");\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}\n"
"int easy2(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  printf(\"hello world -- easy2\\n\");\n"
"  return 0;\n"
"}"

#: ../doc/tutorials/c_tutorial.rst:122
msgid "Compile the program, producing a library file named ``easy.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``easy.so``:"

#: ../doc/tutorials/c_tutorial.rst:124
msgid "$ gcc -shared -o easy.so -fPIC easy.c"
msgstr "$ gcc -shared -o easy.so -fPIC easy.c"

#: ../doc/tutorials/c_tutorial.rst:128 ../doc/tutorials/c_tutorial.rst:216
#: ../doc/tutorials/c_tutorial.rst:303 ../doc/tutorials/c_tutorial.rst:407
#: ../doc/tutorials/c_tutorial.rst:488
msgid "Now go back to the client and execute these requests:"
msgstr "Теперь вернитесь в клиент и выполните следующие запросы:"

#: ../doc/tutorials/c_tutorial.rst:130
msgid ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"

#: ../doc/tutorials/c_tutorial.rst:136
msgid ""
"If these requests appear unfamiliar, re-read the descriptions of "
":ref:`box.schema.func.create() <box_schema-func_create>`, "
":ref:`box.schema.user.grant() <box_schema-user_grant>` and "
":ref:`conn:call() <net_box-call>`."
msgstr ""
"Если эти запросы вам незнакомы, перечитайте описание "
":ref:`box.schema.func.create() <box_schema-func_create>`, "
":ref:`box.schema.user.grant() <box_schema-user_grant>` и "
":ref:`conn:call() <net_box-call>`."

#: ../doc/tutorials/c_tutorial.rst:142
msgid "The function that matters is ``capi_connection:call('easy')``."
msgstr "Важна функция ``capi_connection:call('easy')``."

#: ../doc/tutorials/c_tutorial.rst:144
msgid ""
"Its first job is to find the 'easy' function, which should be easy "
"because by default Tarantool looks on the current directory for a file "
"named ``easy.so``."
msgstr ""
"Во-первых, она ищет функцию easy, что должно быть легко, потому что по "
"умолчанию Tarantool ищет в текущей директории файл под названием "
"``easy.so``."

#: ../doc/tutorials/c_tutorial.rst:148
msgid ""
"Its second job is to call the 'easy' function. Since the ``easy()`` "
"function in ``easy.c`` begins with ``printf(\"hello world\\n\")``, the "
"words \"hello world\" will appear on the screen."
msgstr ""
"Во-вторых, она вызывает функцию easy. Поскольку функция ``easy()`` в "
"``easy.c`` начинается с ``printf(\"hello world\\n\")``, слова \"hello "
"world\" появятся на экране."

#: ../doc/tutorials/c_tutorial.rst:152
msgid ""
"Its third job is to check that the call was successful. Since the "
"``easy()`` function in ``easy.c`` ends with :code:`return 0`, there is no"
" error message to display and the request is over."
msgstr ""
"В-третьих, она проверяет, что вызов прошел успешно. Поскольку функция "
"``easy()`` в ``easy.c`` оканчивается на :code:`return 0`, сообщение об "
"ошибке отсутствует, и запрос выполнен."

#: ../doc/tutorials/c_tutorial.rst:156 ../doc/tutorials/c_tutorial.rst:332
msgid "The result should look like this:"
msgstr "Результат должен выглядеть следующим образом:"

#: ../doc/tutorials/c_tutorial.rst:158
msgid ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."

#: ../doc/tutorials/c_tutorial.rst:166
msgid ""
"Now let's call the other function in easy.c -- ``easy2()``. This is "
"almost the same as the ``easy()`` function, but there's a detail: when "
"the file name is not the same as the function name, then we have to "
"specify :samp:`{file-name}.{function-name}`."
msgstr ""
"Теперь вызовем другую функцию в easy.c -- ``easy2()``. Она практически "
"совпадает с функцией ``easy()``, но есть небольшое отличие: если имя "
"файла не совпадет с именем функции, нужно будет указать "
":samp:`{имя-файла}.{имя-функции}`."

#: ../doc/tutorials/c_tutorial.rst:172
msgid ""
"box.schema.func.create('easy.easy2', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"capi_connection:call('easy.easy2')"
msgstr ""
"box.schema.func.create('easy.easy2', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"capi_connection:call('easy.easy2')"

#: ../doc/tutorials/c_tutorial.rst:178
msgid "... and this time the result will be \"hello world -- easy2\"."
msgstr "... и на этот раз результатом будет: \"hello world -- easy2\"."

#: ../doc/tutorials/c_tutorial.rst:180
msgid "Conclusion: calling a C function is easy."
msgstr "Вывод: вызвать C-функцию легко."

#: ../doc/tutorials/c_tutorial.rst:184
msgid "**harder.c**"
msgstr "**harder.c**"

#: ../doc/tutorials/c_tutorial.rst:186
msgid "Go back to the shell where the ``easy.c`` program was created."
msgstr "Вернитесь в терминал, где была создана программа ``easy.c``."

#: ../doc/tutorials/c_tutorial.rst:188
msgid "Create a file. Name it ``harder.c``. Put these 17 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``harder.c``. Запишите в него следующие 17 "
"строк:"

#: ../doc/tutorials/c_tutorial.rst:190
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"

#: ../doc/tutorials/c_tutorial.rst:210
msgid "Compile the program, producing a library file named ``harder.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``harder.so``:"

#: ../doc/tutorials/c_tutorial.rst:212
msgid "$ gcc -shared -o harder.so -fPIC harder.c"
msgstr "$ gcc -shared -o harder.so -fPIC harder.c"

#: ../doc/tutorials/c_tutorial.rst:218
msgid ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"
msgstr ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"

#: ../doc/tutorials/c_tutorial.rst:228
msgid ""
"This time the call is passing a Lua table (``passable_table``) to the "
"``harder()`` function. The ``harder()`` function will see it, it's in the"
" :code:`char *args` parameter."
msgstr ""
"На этот раз вызов передает Lua-таблицу (``passable_table``) в функцию "
"``harder()``. Функция``harder()`` увидит это, как указано в параметре "
":code:`char *args`."

#: ../doc/tutorials/c_tutorial.rst:232
msgid ""
"At this point the ``harder()`` function will start using functions "
"defined in `msgpuck.h <http://rtsisyk.github.io/msgpuck>`_. The routines "
"that begin with \"mp\" are msgpuck functions that handle data formatted "
"according to the MsgPack_ specification. Passes and returns are always "
"done with this format so one must become acquainted with msgpuck to "
"become proficient with the C API."
msgstr ""
"На данный момент функция ``harder()`` начнет использовать функции, "
"определенные в `msgpuck.h <http://rtsisyk.github.io/msgpuck>`_. "
"Процедуры, которые начинаются с \"mp\" -- это функции msgpuck, которые "
"обрабатывают данные в формате MsgPack_. Передача и возврат всегда "
"осуществляются в этом формате, поэтому следует ознакомиться с msgpuck для"
" того, чтобы овладеть навыками работы с API для языка C."

#: ../doc/tutorials/c_tutorial.rst:240
msgid ""
"For now, though, it's enough to know that ``mp_decode_array()`` returns "
"the number of elements in an array, and ``mp_decode_uint`` returns an "
"unsigned integer, from :code:`args`. And there's a side effect: when the "
"decoding finishes, :code:`args` has changed and is now pointing to the "
"next element."
msgstr ""
"Однако, пока достаточно понимать, что функция ``mp_decode_array()`` "
"возвращает количество элементов в массиве, а функция ``mp_decode_uint`` "
"возвращает целое число без знака из :code:`args`. Есть также побочный "
"эффект: по окончании декодирования :code:`args` изменился и теперь "
"указывает на следующий элемент."

#: ../doc/tutorials/c_tutorial.rst:246
msgid ""
"Therefore the first displayed line will be \"arg_count = 1\" because "
"there was only one item passed: ``passable_table``. |br| The second "
"displayed line will be \"field_count = 3\" because there are three items "
"in the table. |br| The next three lines will be \"1\" and \"2\" and \"3\""
" because those are the values in the items in the table."
msgstr ""
"Таким образом, первой будет отображена строка \"arg_count = 1\", "
"поскольку был передан только один элемент: ``passable_table``. |br| "
"Второй будет отображена строка \"field_count = 3\", потому что в таблице "
"находятся три элемента. |br| Следующие три строки будут \"1\", \"2\" и "
"\"3\", потому что это значения элементов в таблице."

#: ../doc/tutorials/c_tutorial.rst:253
msgid "And now the screen looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/tutorials/c_tutorial.rst:255
msgid ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."

#: ../doc/tutorials/c_tutorial.rst:267
msgid ""
"Conclusion: decoding parameter values passed to a C function is not easy "
"at first, but there are routines to do the job, and they're documented, "
"and there aren't very many of them."
msgstr ""
"Вывод: на первый взгляд, декодирование значений параметров, переданных в "
"C-функцию непросто, но существуют документированные процедуры для этих "
"целей, и их не так много."

#: ../doc/tutorials/c_tutorial.rst:274
msgid "**hardest.c**"
msgstr "**hardest.c**"

#: ../doc/tutorials/c_tutorial.rst:276
msgid ""
"Go back to the shell where the ``easy.c`` and the ``harder.c`` programs "
"were created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c`` и "
"``harder.c``."

#: ../doc/tutorials/c_tutorial.rst:279
msgid "Create a file. Name it ``hardest.c``. Put these 13 lines in it:"
msgstr ""
"Создайте файл. Назовите его ```hardest.c``. Запишите в него следующие 13 "
"строк:"

#: ../doc/tutorials/c_tutorial.rst:281
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"

#: ../doc/tutorials/c_tutorial.rst:297
msgid "Compile the program, producing a library file named ``hardest.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``hardest.so``:"

#: ../doc/tutorials/c_tutorial.rst:299
msgid "$ gcc -shared -o hardest.so -fPIC hardest.c"
msgstr "$ gcc -shared -o hardest.so -fPIC hardest.c"

#: ../doc/tutorials/c_tutorial.rst:305
msgid ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"

#: ../doc/tutorials/c_tutorial.rst:312
msgid "This time the C function is doing three things:"
msgstr "На этот раз C-функция выполняет три действия:"

#: ../doc/tutorials/c_tutorial.rst:314
msgid ""
"finding the numeric identifier of the ``capi_test`` space by calling "
"``box_space_id_by_name()``;"
msgstr ""
"найдет числовой идентификатор спейса ``capi_test`` путем вызова "
"``box_space_id_by_name()``;"

#: ../doc/tutorials/c_tutorial.rst:316
msgid "formatting a tuple using more ``msgpuck.h`` functions;"
msgstr "форматирует кортеж, используя другие функции ``msgpuck.h``;"

#: ../doc/tutorials/c_tutorial.rst:317
msgid "inserting a tuple using ``box_insert()``."
msgstr "вставит кортеж с помощью ``box_insert()``."

#: ../doc/tutorials/c_tutorial.rst:321
msgid ""
"``char tuple[1024];`` is used here as just a quick way of saying "
"\"allocate more than enough bytes\". For serious programs the developer "
"must be careful to allow enough space for all the bytes that the "
"``mp_encode`` routines will use up."
msgstr ""
"``char tuple[1024];`` используется здесь просто в качестве быстрого "
"способа ввода команды \"выделить байтов с запасом\". В серьезных "
"программах разработчику следует обратить внимание на то, чтобы выделить "
"достаточно места, которое будут использовать процедуры ``mp_encode``."

#: ../doc/tutorials/c_tutorial.rst:326
msgid "Now, still on the client, execute this request:"
msgstr "Затем всё еще в клиенте выполните следующий запрос:"

#: ../doc/tutorials/c_tutorial.rst:328
msgid "box.space.capi_test:select()"
msgstr "box.space.capi_test:select()"

#: ../doc/tutorials/c_tutorial.rst:334
msgid ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."

#: ../doc/tutorials/c_tutorial.rst:341
msgid ""
"This proves that the ``hardest()`` function succeeded, but where did "
":ref:`box_space_id_by_name() <box-box_space_id_by_name>` and "
":ref:`box_insert() <box-box_insert>` come from? Answer: the :ref:`C API "
"<index-c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``hardest()`` была успешно выполнена, но "
"откуда взялись :ref:`box_space_id_by_name() <box-box_space_id_by_name>` и"
" :ref:`box_insert() <box-box_insert>`? Ответ: :ref:`API для языка C "
"<index-c_api_reference>`."

#: ../doc/tutorials/c_tutorial.rst:348
msgid "**read.c**"
msgstr "**read.c**"

#: ../doc/tutorials/c_tutorial.rst:350
msgid ""
"Go back to the shell where the ``easy.c`` and the ``harder.c`` and the "
"``hardest.c`` programs were created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c``, ``harder.c``"
" и ``hardest.c``."

#: ../doc/tutorials/c_tutorial.rst:353
msgid "Create a file. Name it ``read.c``. Put these 43 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``read.c``. Запишите в него следующие 43 "
"строки:"

#: ../doc/tutorials/c_tutorial.rst:355
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  char tuple_buf[1024];      /* where the raw MsgPack tuple will be "
"stored */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* The number of the space's first index */\n"
"  uint32_t key = 10000;      /* The key value that box_insert() used */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* Pass key_buf = encoded key = 1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Get the tuple. There's no box_select() but there's this. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Get each field of the tuple + display what you get. */\n"
"  int field_no;             /* The first field number is 0. */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* if (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  char tuple_buf[1024];      /* здесь будет храниться тапл в сыром "
"MsgPack-формате */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* номер первого индекса спейса */\n"
"  uint32_t key = 10000;      /* значение ключа, используемое box_insert()"
" */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* передаем key_buf = закодированный ключ = "
"1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Получить тапл. У нас нет box_select(), но есть вот это. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Получить каждое поле тапла + показать полученное значение */\n"
"  int field_no;             /* номер первого поля = 0 */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* если (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"

#: ../doc/tutorials/c_tutorial.rst:401
msgid "Compile the program, producing a library file named ``read.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``read.so``:"

#: ../doc/tutorials/c_tutorial.rst:403
msgid "$ gcc -shared -o read.so -fPIC read.c"
msgstr "$ gcc -shared -o read.so -fPIC read.c"

#: ../doc/tutorials/c_tutorial.rst:409
msgid ""
"box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"
msgstr ""
"box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"

#: ../doc/tutorials/c_tutorial.rst:416
msgid "This time the C function is doing four things:"
msgstr "На этот раз C-функция выполняет четыре действия:"

#: ../doc/tutorials/c_tutorial.rst:418 ../doc/tutorials/c_tutorial.rst:499
msgid ""
"once again, finding the numeric identifier of the ``capi_test`` space by "
"calling ``box_space_id_by_name()``;"
msgstr ""
"снова найдет числовой идентификатор спейса ``capi_test`` путем вызова "
"``box_space_id_by_name()``;"

#: ../doc/tutorials/c_tutorial.rst:420
msgid "formatting a search key = 10000 using more ``msgpuck.h`` functions;"
msgstr "форматирует ключ поиска = 10 000, используя другие функции ``msgpuck.h``;"

#: ../doc/tutorials/c_tutorial.rst:421
msgid "getting a tuple using ``box_index_get()``;"
msgstr "получает кортеж с помощью ``box_index_get()``;"

#: ../doc/tutorials/c_tutorial.rst:422
msgid ""
"going through the tuple's fields with ``box_tuple_get()`` and then "
"decoding each field depending on its type. In this case, since what we "
"are getting is the tuple that we inserted with ``hardest.c``, we know in "
"advance that the type is either MP_UINT or MP_STR; however, it's very "
"common to have a case statement here with one option for each possible "
"type."
msgstr ""
"проходит по полям каждого кортежа с помощью ``box_tuple_get()``. а затем "
"декодирует каждое поле в зависимости от его типа. В данном случае, "
"поскольку мы получаем кортеж, который сами вставили с помощью "
"``hardest.c``, мы знаем заранее, что его тип будет MP_UINT или MP_STR. "
"Однако, весьма часто здесь употребляется оператор выбора case с одной "
"опцией для каждого возможного типа."

#: ../doc/tutorials/c_tutorial.rst:429
msgid "The result of ``capi_connection:call('read')`` should look like this:"
msgstr "В результате вызова ``capi_connection:call('read')`` должны получить:"

#: ../doc/tutorials/c_tutorial.rst:431
msgid ""
"tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."

#: ../doc/tutorials/c_tutorial.rst:440
msgid ""
"This proves that the ``read()`` function succeeded. Once again the "
"important functions that start with `box` -- :ref:`box_index_get() "
"<c_api-box_index-box_index_get>` and :ref:`box_tuple_field() <c_api-"
"tuple-box_tuple_field>` -- came from the :ref:`C API <index-"
"c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``read()`` была успешно выполнена. И снова "
"важные функции, которые начинаются с `box` -- :ref:`box_index_get() "
"<c_api-box_index-box_index_get>` и :ref:`box_tuple_field() <c_api-tuple-"
"box_tuple_field>` -- пришли из :ref:`API для языка C <index-"
"c_api_reference>`."

#: ../doc/tutorials/c_tutorial.rst:448
msgid "**write.c**"
msgstr "**write.c**"

#: ../doc/tutorials/c_tutorial.rst:450
msgid ""
"Go back to the shell where the programs ``easy.c``, ``harder.c``, "
"``hardest.c`` and ``read.c`` were created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c``, "
"``harder.c``, ``hardest.c`` и ``read.c``."

#: ../doc/tutorials/c_tutorial.rst:453
msgid "Create a file. Name it ``write.c``. Put these 24 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``write.c``. Запишите в него следующие 24 "
"строки:"

#: ../doc/tutorials/c_tutorial.rst:455
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int write(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  static const char *space = \"capi_test\";\n"
"  char tuple_buf[1024]; /* Must be big enough for mp_encode results */\n"
"  uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"  if (space_id == BOX_ID_NIL) {\n"
"    return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"    \"Can't find space %s\", \"capi_test\");\n"
"  }\n"
"  char *tuple_end = tuple_buf;\n"
"  tuple_end = mp_encode_array(tuple_end, 2);\n"
"  tuple_end = mp_encode_uint(tuple_end, 1);\n"
"  tuple_end = mp_encode_uint(tuple_end, 22);\n"
"  box_txn_begin();\n"
"  if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"    return -1;\n"
"  box_txn_commit();\n"
"  fiber_sleep(0.001);\n"
"  struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                      tuple_buf, tuple_end);\n"
"  return box_return_tuple(ctx, tuple);\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int write(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  static const char *space = \"capi_test\";\n"
"  char tuple_buf[1024]; /* Должен быть достаточно большим, чтобы вместить"
" результат mp_encode */\n"
"  uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"  if (space_id == BOX_ID_NIL) {\n"
"    return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"    \"Can't find space %s\", \"capi_test\");\n"
"  }\n"
"  char *tuple_end = tuple_buf;\n"
"  tuple_end = mp_encode_array(tuple_end, 2);\n"
"  tuple_end = mp_encode_uint(tuple_end, 1);\n"
"  tuple_end = mp_encode_uint(tuple_end, 22);\n"
"  box_txn_begin();\n"
"  if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"    return -1;\n"
"  box_txn_commit();\n"
"  fiber_sleep(0.001);\n"
"  struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                      tuple_buf, tuple_end);\n"
"  return box_return_tuple(ctx, tuple);\n"
"}"

#: ../doc/tutorials/c_tutorial.rst:482
msgid "Compile the program, producing a library file named ``write.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``write.so``:"

#: ../doc/tutorials/c_tutorial.rst:484
msgid "$ gcc -shared -o write.so -fPIC write.c"
msgstr "$ gcc -shared -o write.so -fPIC write.c"

#: ../doc/tutorials/c_tutorial.rst:490
msgid ""
"box.schema.func.create('write', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('write')"
msgstr ""
"box.schema.func.create('write', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('write')"

#: ../doc/tutorials/c_tutorial.rst:497
msgid "This time the C function is doing six things:"
msgstr "На этот раз C-функция выполняет шесть действий:"

#: ../doc/tutorials/c_tutorial.rst:501
msgid "making a new tuple;"
msgstr "создает новый кортеж;"

#: ../doc/tutorials/c_tutorial.rst:502
msgid "starting a transaction;"
msgstr "начинает транзакцию;"

#: ../doc/tutorials/c_tutorial.rst:503
msgid "replacing a tuple in ``box.space.capi_test``"
msgstr "заменяет кортеж в ``box.space.capi_test``"

#: ../doc/tutorials/c_tutorial.rst:504
msgid "ending a transaction;"
msgstr "заканчивает транзакцию;"

#: ../doc/tutorials/c_tutorial.rst:505
msgid ""
"the final line is a replacement for the loop in ``read.c`` -- instead of "
"getting each field and printing it, use the ``box_return_tuple(...)`` "
"function to return the entire tuple to the caller and let the caller "
"display it."
msgstr ""
"последняя строка заменяет цикл ``read.c`` -- вместо получения и вывода "
"каждого поля, использует функцию ``box_return_tuple(...)`` для возврата "
"всего кортежа вызывающему клиенту, чтобы вывести его на экран."

#: ../doc/tutorials/c_tutorial.rst:510
msgid "The result of ``capi_connection:call('write')`` should look like this:"
msgstr "В результате вызова ``capi_connection:call('write')`` должны получить:"

#: ../doc/tutorials/c_tutorial.rst:512
msgid ""
"tarantool> capi_connection:call('write')\n"
"---\n"
"- [[1, 22]]\n"
"..."
msgstr ""
"tarantool> capi_connection:call('write')\n"
"---\n"
"- [[1, 22]]\n"
"..."

#: ../doc/tutorials/c_tutorial.rst:519
msgid ""
"This proves that the ``write()`` function succeeded. Once again the "
"important functions that start with `box` -- :ref:`box_txn_begin() <txn-"
"box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` and "
":ref:`box_return_tuple() <box-box_return_tuple>` -- came from the :ref:`C"
" API <index-c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``write()`` была успешно выполнена. И снова "
"важные функции, которые начинаются с `box` -- :ref:`box_txn_begin() <txn-"
"box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` и "
":ref:`box_return_tuple() <box-box_return_tuple>` -- пришли из :ref:`API "
"для языка C <index-c_api_reference>`."

#: ../doc/tutorials/c_tutorial.rst:526
msgid ""
"Conclusion: the long description of the whole C API is there for a good "
"reason. All of the functions in it can be called from C functions which "
"are called from Lua. So C \"stored procedures\" have full access to the "
"database."
msgstr ""
"Вывод: длинное описание всего API для языка C необходимо в силу весомых "
"причин. Все функции можно вызвать из C-функций, которые вызываются из "
"Lua. Таким образом, хранимые процедуры на языке C получают полный доступ "
"к базе данных."

#: ../doc/tutorials/c_tutorial.rst:532
msgid "**Cleaning up**"
msgstr "**Очистка данных**"

#: ../doc/tutorials/c_tutorial.rst:534
msgid ""
"Get rid of each of the function tuples with :ref:`box.schema.func.drop "
"<box_schema-func_drop>`."
msgstr ""
"Удалите все кортежи с функцией с помощью :ref:`box.schema.func.drop "
"<box_schema-func_drop>`."

#: ../doc/tutorials/c_tutorial.rst:536
msgid ""
"Get rid of the ``capi_test`` space with :ref:`box.schema.capi_test:drop()"
" <box_space-drop>`."
msgstr ""
"Удалите спейс ``capi_test`` с помощью :ref:`box.schema.capi_test:drop() "
"<box_space-drop>`."

#: ../doc/tutorials/c_tutorial.rst:538
msgid "Remove the ``.c`` and ``.so`` files that were created for this tutorial."
msgstr ""
"Удалите файлы с разрешением ``.c`` и ``.so``, созданные для данного "
"практического задания."

#: ../doc/tutorials/c_tutorial.rst:541
msgid "**An example in the test suite**"
msgstr "**Пример из набора тестов**"

#: ../doc/tutorials/c_tutorial.rst:543
msgid ""
"Download the source code of Tarantool. Look in a subdirectory "
":code:`test/box`. Notice that there is a file named "
":code:`tuple_bench.test.lua` and another file named "
":code:`tuple_bench.c`. Examine the Lua file and observe that it is "
"calling a function in the C file, using the same techniques that this "
"tutorial has shown."
msgstr ""
"Скачайте исходный код Tarantool'а. Откройте поддиректорию "
":code:`test/box`. Проверьте наличие файла под названием "
":code:`tuple_bench.test.lua` и еще одного файла под названием "
":code:`tuple_bench.c`. Изучите Lua-файл на предмет вызова функции в "
"C-файле с использованием методов, описанных в данном практическом "
"задании."

#: ../doc/tutorials/c_tutorial.rst:550
msgid ""
"Conclusion: parts of the standard test suite use C stored procedures, and"
" they must work, because releases don't happen if Tarantool doesn't pass "
"the tests."
msgstr ""
"Вывод: некоторые тесты из стандартного набора используют хранимые "
"процедуры на языке C, а они должны работать, поскольку мы не можем "
"выпустить Tarantool, если он не прошел тестирование."

#: ../doc/tutorials/index.rst:5
msgid "Tutorials"
msgstr "Практикум"

#: ../doc/tutorials/libslave.rst:5
msgid "`libslave` tutorial"
msgstr "Практические задания по `libslave`"

#: ../doc/tutorials/libslave.rst:7
msgid ""
"``libslave`` is a C++ library for reading data changes done by MysQL and,"
" optionally, writing them to a Tarantool database. It works by acting as "
"a replication slave. The MySQL server writes data-change information to a"
" \"binary log\", and transfers the information to any client that says "
"\"I want to see the information starting with this file and this record, "
"continuously\". So, ``libslave`` is primarily good for making a Tarantool"
" database replica (much faster than using a conventional MySQL slave "
"server), and for keeping track of data changes so they can be searched."
msgstr ""
"``libslave`` представляет собой библиотеку C++ для считывания изменений "
"данных, внесенных с помощью MySQL, а также -- опционально -- для записи "
"их в базу данных Tarantool'а. Она выступает в качестве ведомого в схеме "
"репликации. Сервер MySQL записывает информацию об изменении данных в "
"бинарный журнал и передает ее на любой клиент, который запрашивает: "
"\"Хочу увидеть всю информацию, начиная с этого файла и этой записи, "
"безостановочно\". Таким образом, библиотека ``libslave``, прежде всего, "
"используется для создания реплик базы данных Tarantool'а (намного "
"быстрее, чем используя традиционный ведомый сервер MySQL) и для "
"отслеживания изменений данных, чтобы они были пригодны для поиска."

#: ../doc/tutorials/libslave.rst:18
msgid ""
"We will not go into the many details here -- the `API documentation "
"<https://github.com/vozbu/libslave/wiki/API>`_ has them. We will only "
"show an exercise: a minimal program that uses the library."
msgstr ""
"Здесь мы не будем подробно рассматривать библиотеку -- информация есть в "
"`документации по API <https://github.com/vozbu/libslave/wiki/API>`_. Мы "
"лишь дадим упражнение: минимальная программа с использованием библиотеки."

#: ../doc/tutorials/libslave.rst:24
msgid "Use a test machine. Do not use a production machine."
msgstr "Используйте тестовый сервер. Не используйте боевой сервер."

#: ../doc/tutorials/libslave.rst:26
msgid "STEP 1: Make sure you have:"
msgstr "ШАГ 1: Убедитесь в наличии следующего:"

#: ../doc/tutorials/libslave.rst:28
msgid "a recent version of Linux (versions such as Ubuntu 14.04 will not do),"
msgstr "последняя версия Linux (например, Ubuntu версии 14.04 не подойдет),"

#: ../doc/tutorials/libslave.rst:29
msgid "a recent version of MySQL 5.6 or MySQL 5.7 server (MariaDB will not do),"
msgstr "сервер MySQL версии 5.6 или 5.7 (MariaDB не подойдет),"

#: ../doc/tutorials/libslave.rst:30
msgid ""
"MySQL client development package. For example, on Ubuntu you can download"
" it with this command:"
msgstr ""
"пакет программ для разработки клиента MySQL. Например, на Ubuntu можно "
"загрузить его с помощью следующей команды:"

#: ../doc/tutorials/libslave.rst:33
msgid "$ sudo apt-get install mysql-client-core-5.7"
msgstr "$ sudo apt-get install mysql-client-core-5.7"

#: ../doc/tutorials/libslave.rst:37
msgid "STEP 2: Download ``libslave``."
msgstr "ШАГ 2: Установите ``libslave``."

#: ../doc/tutorials/libslave.rst:39
msgid ""
"The recommended source is https://github.com/tarantool/libslave/. "
"Downloads include the source code only."
msgstr ""
"Рекомендуется источник по ссылке https://github.com/tarantool/libslave/. "
"Загрузки включают в себя только исходный код."

#: ../doc/tutorials/libslave.rst:42
msgid ""
"$ sudo apt-get install libboost-all-dev\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"$ cd tarantool-libslave\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make"
msgstr ""
"$ sudo apt-get install libboost-all-dev\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"$ cd tarantool-libslave\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make"

#: ../doc/tutorials/libslave.rst:53
msgid ""
"If you see an error message mentioning the word \"vector\", edit "
"``field.h`` and add this line:"
msgstr ""
"Если система выдаст сообщение с ошибкой со словом \"vector\", "
"отредактируйте ``field.h``, добавив следующую строку:"

#: ../doc/tutorials/libslave.rst:56
msgid "#include <vector>"
msgstr "#include <vector>"

#: ../doc/tutorials/libslave.rst:60
msgid ""
"STEP 3: Start the MySQL server. On the command line, add appropriate "
"switches for doing replication. For example:"
msgstr ""
"ШАГ 3: Запустите сервер MySQL. В командной строке добавьте "
"соответствующие коммутаторы для выполнения репликации. Например:"

#: ../doc/tutorials/libslave.rst:63
msgid "$ mysqld --log-bin=mysql-bin --server-id=1"
msgstr "$ mysqld --log-bin=mysql-bin --server-id=1"

#: ../doc/tutorials/libslave.rst:67
msgid "STEP 4: For purposes of this exercise, we are assuming you have:"
msgstr "ШАГ 4: Для целей данного упражнения, предполагаем, что у вас есть:"

#: ../doc/tutorials/libslave.rst:69
msgid "a \"root\" user with password \"root\" with privileges,"
msgstr "пользователь \"root\" с паролем \"root\" с правами,"

#: ../doc/tutorials/libslave.rst:70
msgid "a \"test\" database with a table named \"test\","
msgstr "тестовая база данных \"test\" с тестовой таблицей под названием \"test\","

#: ../doc/tutorials/libslave.rst:71
msgid "a binary log named \"mysql-bin\","
msgstr "бинарный журнал под названием \"mysql-bin\","

#: ../doc/tutorials/libslave.rst:72
msgid "a server with server id = 1."
msgstr "сервер с идентификатором 1."

#: ../doc/tutorials/libslave.rst:74
msgid ""
"The values are hard-coded in the program, though of course you can change"
" the program -- it's easy to see their settings."
msgstr ""
"Значения заданы в программе, хотя программу, конечно, можно изменить -- "
"посмотреть настройки несложно."

#: ../doc/tutorials/libslave.rst:77
msgid "STEP 5: Look at the program:"
msgstr "ШАГ 5: Обратите внимание на программу:"

#: ../doc/tutorials/libslave.rst:79
#, fuzzy
msgid ""
"#include <unistd.h>\n"
"#include <iostream>\n"
"#include <sstream>\n"
"#include \"Slave.h\"\n"
"#include \"DefaultExtState.h\"\n"
"\n"
"slave::Slave* sl = NULL;\n"
"\n"
"void callback(const slave::RecordSet& event) {\n"
"    slave::Position sBinlogPos = sl->getLastBinlogPos();\n"
"    switch (event.type_event) {\n"
"    case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; "
"break;\n"
"    case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; "
"break;\n"
"    case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; "
"break;\n"
"    default: break;\n"
"    }\n"
"}\n"
"\n"
"bool isStopping()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"    slave::MasterInfo masterinfo;\n"
"    slave::Position position(\"mysql-bin\", 0);\n"
"    masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"    masterinfo.conn_options.mysql_port = 3306;\n"
"    masterinfo.conn_options.mysql_user = \"root\";\n"
"    masterinfo.conn_options.mysql_pass = \"root\";\n"
"    bool error = false;\n"
"    try {\n"
"        slave::DefaultExtState sDefExtState;\n"
"        slave::Slave slave(masterinfo, sDefExtState);\n"
"        sl = &slave;\n"
"        sDefExtState.setMasterPosition(position);\n"
"        slave.setCallback(\"test\", \"test\", callback);\n"
"        slave.init();\n"
"        slave.createDatabaseStructure();\n"
"        try {\n"
"            slave.get_remote_binlog(isStopping);\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"    } catch (std::exception& ex) {\n"
"        std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"        error = true;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"#include <unistd.h>\n"
"#include <iostream>\n"
"#include <sstream>\n"
"#include \"Slave.h\"\n"
"#include \"DefaultExtState.h\"\n"
"\n"
"slave::Slave* sl = NULL;\n"
"\n"
"void callback(const slave::RecordSet& event) {\n"
"    slave::Slave::binlog_pos_t sBinlogPos = sl->getLastBinlog();\n"
"    switch (event.type_event) {\n"
"    case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; "
"break;\n"
"    case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; "
"break;\n"
"    case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; "
"break;\n"
"    default: break;\n"
"    }\n"
"}\n"
"\n"
"bool isStopping()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"    slave::MasterInfo masterinfo;\n"
"    masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"    masterinfo.conn_options.mysql_port = 3306;\n"
"    masterinfo.conn_options.mysql_user = \"root\";\n"
"    masterinfo.conn_options.mysql_pass = \"root\";\n"
"    bool error = false;\n"
"    try {\n"
"        slave::DefaultExtState sDefExtState;\n"
"        slave::Slave slave(masterinfo, sDefExtState);\n"
"        sl = &slave;\n"
"        sDefExtState.setMasterLogNamePos(\"mysql-bin\", 0);\n"
"        slave.setCallback(\"test\", \"test\", callback);\n"
"        slave.init();\n"
"        slave.createDatabaseStructure();\n"
"        try {\n"
"            slave.get_remote_binlog(isStopping);\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"    } catch (std::exception& ex) {\n"
"        std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"        error = true;\n"
"    }\n"
"    return 0;\n"
"}"

#: ../doc/tutorials/libslave.rst:134
msgid ""
"Everything unnecessary has been stripped so that you can see quickly how "
"it works. At the start of ``main()``, there are some settings used for "
"connecting -- host, port, user, password. Then there is an initialization"
" call with the binary log file name = \"mysql-bin\". Pay particular "
"attention to the ``setCallback`` statement, which passes database name = "
"\"test\", table name = \"test\", and callback function address = "
"callback. The program will be looping and invoking this callback "
"function. See how, earlier in the program, the callback function prints "
"\"UPDATE\" or \"DELETE\" or \"INSERT\" depending on what is passed to it."
msgstr ""
"Всё лишнее почистили, чтобы можно было ясно увидеть, как это работает. В "
"начале функции ``main()`` есть некоторые настройки, используемые для "
"установки соединения -- хост, порт, пользователь, пароль. Затем есть "
"вызов инициализации с именем файла бинарного журнала = \"mysql-bin\". "
"Обратите особое внимание на оператор ``setCallback``, который передает "
"имя базы данных = \"test\", имя таблицы = \"test\" и адрес функции "
"обратного вызова = callback. Программа войдет в цикл и будет вызывать эту"
" функцию обратного вызова. Посмотрите, как на ранних этапах программы "
"функция обратного вызова выводит \"UPDATE\", \"DELETE\" или \"INSERT\" в "
"зависимости от переданных данных."

#: ../doc/tutorials/libslave.rst:145
msgid ""
"STEP 5: Put the program in the ``tarantool-libslave`` directory and name "
"it ``example.cpp``."
msgstr ""
"ШАГ 5: Поместите программу в директорию ``tarantool-libslave`` и назовите"
" ее ``example.cpp``."

#: ../doc/tutorials/libslave.rst:148
msgid "Step 6: Compile and build:"
msgstr "ШАГ 6: Выполните компиляцию и сборку:"

#: ../doc/tutorials/libslave.rst:150
msgid ""
"$ g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a "
"-ldl -lpthread"
msgstr ""
"$ g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a "
"-ldl -lpthread"

#: ../doc/tutorials/libslave.rst:156
msgid "Replace ``tarantool-libslave/include`` with the full directory name."
msgstr "Замените ``tarantool-libslave/include`` на полное имя директории."

#: ../doc/tutorials/libslave.rst:158
msgid ""
"Notice that the name of the static library is ``libslave_a.a``, not "
"``libslave.a``."
msgstr ""
"Обратите внимание, что имя статической библиотеки -- ``libslave_a.a``, а "
"не ``libslave.a``."

#: ../doc/tutorials/libslave.rst:161
msgid "Step 7: Run:"
msgstr "ШАГ 7: Выполните:"

#: ../doc/tutorials/libslave.rst:163
msgid "$ ./example"
msgstr "$ ./example"

#: ../doc/tutorials/libslave.rst:167
msgid ""
"The result will be nothing -- the program is looping, waiting for the "
"MySQL server to write to the replication binary log."
msgstr ""
"Результат нет -- программа в цикле ожидает, пока сервер MySQL запишет "
"данные в бинарный журнал репликации."

#: ../doc/tutorials/libslave.rst:170
msgid ""
"Step 8: Start a MySQL client program -- any client program will do. Enter"
" these statements:"
msgstr ""
"ШАГ 8: Запустите клиентскую программу MySQL -- подойдет любая клиентская "
"программа. Введите следующие операторы:"

#: ../doc/tutorials/libslave.rst:173
msgid ""
"USE test\n"
"INSERT INTO test VALUES ('A');\n"
"INSERT INTO test VALUES ('B');\n"
"DELETE FROM test;"
msgstr ""
"USE test\n"
"INSERT INTO test VALUES ('A');\n"
"INSERT INTO test VALUES ('B');\n"
"DELETE FROM test;"

#: ../doc/tutorials/libslave.rst:180
msgid "Watch what happens in ``example.cpp`` output -- it displays:"
msgstr ""
"Проверьте, что происходит в выводе программы ``example.cpp`` -- "
"отображается следующее:"

#: ../doc/tutorials/libslave.rst:182
msgid ""
"INSERT\n"
"INSERT\n"
"DELETE\n"
"DELETE"
msgstr ""
"INSERT\n"
"INSERT\n"
"DELETE\n"
"DELETE"

#: ../doc/tutorials/libslave.rst:189
msgid ""
"This is row-based replication, so you see two DELETEs, because there are "
"two rows."
msgstr ""
"Репликация является построчной, поэтому видим DELETE два раза -- потому "
"что есть две строки."

#: ../doc/tutorials/libslave.rst:192
msgid "What the exercise has shown is:"
msgstr "В результате выполнения упражнения видим:"

#: ../doc/tutorials/libslave.rst:194
msgid "the library can be built, and"
msgstr "можно собрать библиотеку, а "

#: ../doc/tutorials/libslave.rst:195
msgid ""
"programs that use the library can access everything that the MySQL server"
" dumps."
msgstr ""
"программы, которые используют библиотеку, могут получить доступ ко всему,"
" что сохраняет сервер MySQL."

#: ../doc/tutorials/libslave.rst:198
msgid "For the many details and examples of usage in the field, see:"
msgstr "Более подробную информацию и примеры использования см. ниже:"

#: ../doc/tutorials/libslave.rst
msgid "Our downloadable ``libslave`` version:"
msgstr "Загрузить нашу версию ``libslave`` можно по ссылке:"

#: ../doc/tutorials/libslave.rst
msgid "https://github.com/tarantool/libslave"
msgstr "https://github.com/tarantool/libslave"

#: ../doc/tutorials/libslave.rst
msgid "The version it was forked from (with a different README):"
msgstr "Ответвление сделано из версии по ссылке (с другим файлом README):"

#: ../doc/tutorials/libslave.rst
msgid "https://github.com/vozbu/libslave/wiki/API"
msgstr "https://github.com/vozbu/libslave/wiki/API"

#: ../doc/tutorials/libslave.rst:206
msgid ""
"`How to speed up your MySQL with replication to in-memory database "
"<http://highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-"
"with-replication-to-in-memory-dat.html>`_ article"
msgstr ""
"Статья `How to speed up your MySQL with replication to in-memory database"
" <http://highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-"
"with-replication-to-in-memory-dat.html>`_ (на английском)"

#: ../doc/tutorials/libslave.rst:208
msgid ""
"`Replicating data from MySQL to Tarantool "
"<https://habrahabr.ru/company/mailru/blog/323870/>`_ article (in Russian)"
msgstr ""
"Статья `Репликация из MySQL в Tarantool "
"<https://habrahabr.ru/company/mailru/blog/323870/>`_"

#: ../doc/tutorials/libslave.rst:210
msgid ""
"`Asynchronous replication uncensored <https://habrahabr.ru/company/oleg-"
"bunin/blog/313594/>`_ article (in Russian)"
msgstr ""
"Статья `Асинхронная репликация без цензуры <https://habrahabr.ru/company"
"/oleg-bunin/blog/313594/>`_"

#: ../doc/tutorials/lua_tutorials.rst:5
msgid "Lua tutorials"
msgstr "Практические задания на Lua"

#: ../doc/tutorials/lua_tutorials.rst:7
msgid "Here are three tutorials on using Lua stored procedures with Tarantool:"
msgstr ""
"Практические задания по использованию хранимых процедур на языке Lua в "
"работе с Tarantool'ом:"

#: ../doc/tutorials/lua_tutorials.rst:9
msgid ""
":ref:`Insert one million tuples with a Lua stored procedure "
"<c_lua_tutorial-insert_one_million_tuples>`,"
msgstr ""
":ref:`Вставка 1 млн кортежей с помощью хранимой процедуры на языке Lua "
"<c_lua_tutorial-insert_one_million_tuples>`,"

#: ../doc/tutorials/lua_tutorials.rst:10
msgid ":ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>`,"
msgstr ""
":ref:`Подсчет суммы по JSON-полям во всех кортежах <c_lua_tutorial-"
"sum_a_json_field>`,"

#: ../doc/tutorials/lua_tutorials.rst:11
msgid ":ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>`."
msgstr ""
":ref:`Индексированный поиск по шаблонам <c_lua_tutorial-"
"indexed_pattern_search>`."

#: ../doc/tutorials/lua_tutorials.rst:17
msgid "Insert one million tuples with a Lua stored procedure"
msgstr "Вставка 1 млн кортежей с помощью хранимой процедуры на языке Lua"

#: ../doc/tutorials/lua_tutorials.rst:19
msgid ""
"This is an exercise assignment: “Insert one million tuples. Each tuple "
"should have a constantly-increasing numeric primary-key field and a "
"random alphabetic 10-character string field.”"
msgstr ""
"Задание по данному практикуму: “Вставьте 1 миллион кортежей. В каждом "
"кортеже должно быть поле, которое соответствует ключу в первичном "
"индексе, в виде постоянно возрастающего числа, а также поле в виде "
"буквенной строки со случайным значением из 10 символов.”"

#: ../doc/tutorials/lua_tutorials.rst:23
msgid ""
"The purpose of the exercise is to show what Lua functions look like "
"inside Tarantool. It will be necessary to employ the Lua math library, "
"the Lua string library, the Tarantool box library, the Tarantool "
"box.tuple library, loops, and concatenations. It should be easy to follow"
" even for a person who has not used either Lua or Tarantool before. The "
"only requirement is a knowledge of how other programming languages work "
"and a memory of the first two chapters of this manual. But for better "
"understanding, follow the comments and the links, which point to the Lua "
"manual or to elsewhere in this Tarantool manual. To further enhance "
"learning, type the statements in with the tarantool client while reading "
"along."
msgstr ""
"Цель данного упражнения состоит в том, чтобы показать, как выглядят "
"Lua-функции в Tarantool'е. Необходимо будет работать с математической "
"библиотекой Lua, библиотекой для работы со строками интерпретатора Lua, "
"Tarantool-библиотекой ``box``, Tarantool-библиотекой ``box.tuple``, "
"циклами и конкатенацией. Инструкции легко будет выполнять даже тем, кто "
"никогда не использовал раньше Lua или Tarantool. Единственное требование "
"-- знание того, как работают другие языки программирования, и изучение "
"первых двух глав данного руководства. Но для лучшего понимания можно "
"следовать по комментариям и ссылкам на руководство по Lua или другим "
"пунктам в данном руководстве по Tarantool'у. А чтобы облегчить изучение, "
"читайте инструкции параллельно с вводом операторов в Tarantool-клиент."

#: ../doc/tutorials/lua_tutorials.rst:35
msgid "Configure"
msgstr "Настройка"

#: ../doc/tutorials/lua_tutorials.rst:37
msgid ""
"We are going to use the Tarantool sandbox that was created for our "
":ref:`\"Getting started\" exercises <getting_started>`. So there is a "
"single space, and a numeric primary key, and a running Tarantool server "
"instance which also serves as a client."
msgstr ""
"Будем использовать Tarantool-песочницу, которую создавали для "
":ref:`упражнений раздела \"Руководство для начинающих\" "
"<getting_started>`. Таким образом, у нас есть один спейс и числовой ключ "
"первичного индекса, а также экземпляр Tarantool'а, который также "
"выступает в виде клиента."

#: ../doc/tutorials/lua_tutorials.rst:44
msgid "Delimiter"
msgstr "Разделитель"

#: ../doc/tutorials/lua_tutorials.rst:46
msgid ""
"In earlier versions of Tarantool, multi-line functions had to be enclosed"
" within \"delimiters\". They are no longer necessary, and so they will "
"not be used in this tutorial. However, they are still supported. Users "
"who wish to use delimiters, or users of older versions of Tarantool, "
"should check the syntax description for :ref:`declaring a delimiter "
"<console-delimiter>` before proceeding."
msgstr ""
"В более ранних версиях Tarantool'а многострочные функции обрамляются "
"символами-разделителями. Сейчас в них нет необходимости, поэтому в данном"
" практическом задании они использоваться не будут. Однако они все еще "
"поддерживаются. Если вы хотите использовать разделители или используете "
"более раннюю версию Tarantool'а, перед работой проверьте описание "
"синтаксиса для :ref:`объявления разделителя <console-delimiter>`."

#: ../doc/tutorials/lua_tutorials.rst:55
msgid "Create a function that returns a string"
msgstr "Создание функции, которая возвращает строку"

#: ../doc/tutorials/lua_tutorials.rst:57
msgid ""
"We will start by making a function that returns a fixed string, “Hello "
"world”."
msgstr ""
"Начнем с создания функции, которая возвращает заданную строку -- “Hello "
"world”."

#: ../doc/tutorials/lua_tutorials.rst:59
msgid ""
"function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""
"function string_function()\n"
"  return \"hello world\"\n"
"end"

#: ../doc/tutorials/lua_tutorials.rst:65
msgid ""
"The word \"``function``\" is a Lua keyword -- we're about to go into Lua."
" The function name is string_function. The function has one executable "
"statement, ``return \"hello world\"``. The string \"hello world\" is "
"enclosed in double quotes here, although Lua doesn't care -- one could "
"use single quotes instead. The word \"``end``\" means “this is the end of"
" the Lua function declaration.” To confirm that the function works, we "
"can say"
msgstr ""
"Слово \"``function``\" (функция) -- ключевое слово в языке Lua. "
"Рассмотрим подробно работу с языком Lua. Имя функции -- string_function "
"(строковая_функция). В функции есть один исполняемый оператор, ``return "
"\"hello world\"`` (вернуть \"hello world\"). Строка \"hello world\" здесь"
" заключена в двойные кавычки, хотя в Lua это не имеет значения, можно "
"использовать одинарные кавычки. Слово \"``end``\" означает, что “это "
"конец объявления Lua-функции.” Чтобы проверить работу функции, можем "
"выполнить команду"

#: ../doc/tutorials/lua_tutorials.rst:72
msgid "string_function()"
msgstr "string_function()"

#: ../doc/tutorials/lua_tutorials.rst:76
msgid ""
"Sending ``function-name()`` means “invoke the Lua function.” The effect "
"is that the string which the function returns will end up on the screen."
msgstr ""
"Отправка ``function-name()`` (имя-функции) означает команду вызова "
"Lua-функции. В результате возвращаемая функцией строка появится на "
"экране."

#: ../doc/tutorials/lua_tutorials.rst:79
msgid ""
"For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . "
"For more about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""
"Для получения подробной информации о строках в языке Lua, см.  `Главу 2.4"
" \"Строки\"`_ в руководстве по языку Lua. Для получения подробной "
"информации о функциях см. Главу 5 \"Функции\" в руководстве по языку Lua "
"(`chapter 5 \"Functions\"`_)."

#: ../doc/tutorials/lua_tutorials.rst:85 ../doc/tutorials/lua_tutorials.rst:129
#: ../doc/tutorials/lua_tutorials.rst:181
#: ../doc/tutorials/lua_tutorials.rst:237
#: ../doc/tutorials/lua_tutorials.rst:283
#: ../doc/tutorials/lua_tutorials.rst:343
#: ../doc/tutorials/lua_tutorials.rst:436
msgid "The screen now looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/tutorials/lua_tutorials.rst:87
msgid ""
"tarantool> function string_function()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_function()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"

#: ../doc/tutorials/lua_tutorials.rst:102
msgid "Create a function that calls another function and sets a variable"
msgstr "Создание функции, которая вызывает другую функцию и определяет переменную"

#: ../doc/tutorials/lua_tutorials.rst:104
msgid ""
"Now that ``string_function`` exists, we can invoke it from another "
"function."
msgstr ""
"Теперь у нас есть функция ``string_function``, и можно вызвать ее с "
"помощью другой функции."

#: ../doc/tutorials/lua_tutorials.rst:107
msgid ""
"function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""
"function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"

#: ../doc/tutorials/lua_tutorials.rst:115
msgid ""
"We begin by declaring a variable \"``string_value``\". The word "
"\"``local``\" means that string_value appears only in ``main_function``. "
"If we didn't use \"``local``\" then ``string_value`` would be visible "
"everywhere - even by other users using other clients connected to this "
"server instance! Sometimes that's a very desirable feature for inter-"
"client communication, but not this time."
msgstr ""
"Сначала объявим переменную \"``string_value``\" (значение_строки). Слово "
"\"``local``\" (локально) означает, что string_value появится только в "
"``main_function`` (основная_функция). Если бы мы не использовали "
"\"``local``\", то ``string_value`` увидели бы даже пользователи других "
"клиентов, которые подключились к данному экземпляру! Иногда это может "
"быть очень полезно при взаимодействии клиентов, но не в нашем случае."

#: ../doc/tutorials/lua_tutorials.rst:121
msgid ""
"Then we assign a value to ``string_value``, namely, the result of "
"``string_function()``. Soon we will invoke ``main_function()`` to check "
"that it got the value."
msgstr ""
"Затем определим значение для ``string_value``, а именно, результат "
"функции ``string_function()``. Сейчас вызовем ``main_function()``, чтобы "
"проверить, что значение определено."

#: ../doc/tutorials/lua_tutorials.rst:125
msgid ""
"For more about Lua variables see Lua manual `chapter 4.2 \"Local "
"Variables and Blocks\"`_ ."
msgstr ""
"Для получения подробной информации о переменных в языке Lua, см. Главу "
"4.2 \"Локальные переменные и блоки\" в руководстве по языку Lua (`chapter"
" 4.2 \"Local Variables and Blocks\"`_)."

#: ../doc/tutorials/lua_tutorials.rst:131
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"

#: ../doc/tutorials/lua_tutorials.rst:148
msgid "Modify the function so it returns a one-letter random string"
msgstr "Изменение функции для возврата строки из одной случайной буквы"

#: ../doc/tutorials/lua_tutorials.rst:150
msgid ""
"Now that it's a bit clearer how to make a variable, we can change "
"``string_function()`` so that, instead of returning a fixed literal "
"\"Hello world\", it returns a random letter between 'A' and 'Z'."
msgstr ""
"Сейчас стало понятно, как задавать переменную, поэтому можно изменить "
"функцию ``string_function()`` так, чтобы вместо возврата заданной фразы "
"\"Hello world\", она возвращала случайным образом выбранную букву от 'A' "
"до 'Z'."

#: ../doc/tutorials/lua_tutorials.rst:154
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"

#: ../doc/tutorials/lua_tutorials.rst:164
msgid ""
"It is not necessary to destroy the old ``string_function()`` contents, "
"they're simply overwritten. The first assignment invokes a random-number "
"function in Lua's math library; the parameters mean “the number must be "
"an integer between 65 and 90.” The second assignment invokes an integer-"
"to-character function in Lua's string library; the parameter is the code "
"point of the character. Luckily the ASCII value of 'A' is 65 and the "
"ASCII value of 'Z' is 90 so the result will always be a letter between A "
"and Z."
msgstr ""
"Нет необходимости стирать содержание старой функции "
"``string_function()``, оно просто перезаписывается. Первый оператор "
"вызывает функцию из математической библиотеки Lua, которая возвращает "
"случайное число; параметры означают, что число должно быть целым от 65 до"
" 90. Второй оператор вызывает функцию из библиотеки Lua для работы со "
"строками, которая преобразует число в символ; параметр представляет собой"
" кодовую точку символа. К счастью, в кодировке ASCII символу 'A' "
"соответствует значение 65, а 'Z' -- 90, так что в результате всегда "
"получим букву от A до Z."

#: ../doc/tutorials/lua_tutorials.rst:172
msgid ""
"For more about Lua math-library functions see Lua users \"`Math Library "
"Tutorial`_\". For more about Lua string-library functions see Lua users "
"\"`String Library Tutorial`_\" ."
msgstr ""
"Для получения подробной информации о функциях математической библиотеки в"
" языке Lua, см. Практическое задание по математической библиотеке для "
"пользователей Lua (`Math Library Tutorial`_). Для получения подробной "
"информации о функциях библиотеки для работы со строками в языке Lua, см."
"  Практическое задание по библиотеке для работы со строками для "
"пользователей Lua (`String Library Tutorial`_)."

#: ../doc/tutorials/lua_tutorials.rst:178
msgid ""
"Once again the ``string_function()`` can be invoked from main_function() "
"which can be invoked with ``main_function()``."
msgstr ""
"И снова функцию ``string_function()`` можно вызвать из main_function(), "
"которую можно вызвать с помощью ``main_function()``."

#: ../doc/tutorials/lua_tutorials.rst:183
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"

#: ../doc/tutorials/lua_tutorials.rst:200
msgid ""
"... Well, actually it won't always look like this because "
"``math.random()`` produces random numbers. But for the illustration "
"purposes it won't matter what the random string values are."
msgstr ""
"... На самом деле, вывод не всегда будет именно таким, поскольку функция "
"``math.random()`` вызывает случайные числа. Но для наглядности случайные "
"значения в строке не важны."

#: ../doc/tutorials/lua_tutorials.rst:206
msgid "Modify the function so it returns a ten-letter random string"
msgstr "Изменение функции для возврата строки из десяти случайных букв"

#: ../doc/tutorials/lua_tutorials.rst:208
msgid ""
"Now that it's clear how to produce one-letter random strings, we can "
"reach our goal of producing a ten-letter string by concatenating ten one-"
"letter strings, in a loop."
msgstr ""
"Сейчас стало понятно, как вызывать строки из одной случайной буквы, "
"поэтому можно перейти к нашей цели -- возврату строки из десяти букв с "
"помощью конкатенации десяти строк из одной случайной буквы в цикле."

#: ../doc/tutorials/lua_tutorials.rst:212
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"

#: ../doc/tutorials/lua_tutorials.rst:225
msgid ""
"The words \"for x = 1,10,1\" mean “start with x equals 1, loop until x "
"equals 10, increment x by 1 for each iteration.” The symbol \"..\" means "
"\"concatenate\", that is, add the string on the right of the \"..\" sign "
"to the string on the left of the \"..\" sign. Since we start by saying "
"that random_string is \"\" (a blank string), the end result is that "
"random_string has 10 random letters. Once again the ``string_function()``"
" can be invoked from ``main_function()`` which can be invoked with "
"``main_function()``."
msgstr ""
"Слова \"for x = 1,10,1\" означают: “начать с x, равного 1, зацикливать до"
" тех пор, пока x не будет равен 10, увеличивать x на 1 на каждом шаге "
"цикла”. Символ \"..\" означает \"конкатенацию\", то есть добавление "
"строки справа от знака \"..\" к строке слева от знака \"..\". Поскольку в"
" начале определяется, что random_string (случайная_строка) представляет "
"собой \"\" (пустую строку), в результате получим, что в random_string 10 "
"случайных букв. И снова функцию ``string_function()`` можно вызвать из "
"``main_function()``, которую можно вызвать с помощью ``main_function()``."

#: ../doc/tutorials/lua_tutorials.rst:233
msgid "For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr ""
"Для получения подробной информации о циклах в языке Lua, см. Главу 4.3.4 "
"\"Числовой оператор for\" в руководстве по языку Lua (`chapter 4.3.4 "
"\"Numeric for\"`_)."

#: ../doc/tutorials/lua_tutorials.rst:239
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"

#: ../doc/tutorials/lua_tutorials.rst:261
msgid "Make a tuple out of a number and a string"
msgstr "Составление кортежа из числа и строки"

#: ../doc/tutorials/lua_tutorials.rst:263
msgid ""
"Now that it's clear how to make a 10-letter random string, it's possible "
"to make a tuple that contains a number and a 10-letter random string, by "
"invoking a function in Tarantool's library of Lua functions."
msgstr ""
"Сейчас стало понятно, как создать строку из 10 случайных букв, поэтому "
"можно создать кортеж, который будет содержать число и строку из 10 "
"случайных букв, с помощью функции в Tarantool-библиотеке Lua-функций."

#: ../doc/tutorials/lua_tutorials.rst:267
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"

#: ../doc/tutorials/lua_tutorials.rst:276
msgid ""
"Once this is done, t will be the value of a new tuple which has two "
"fields. The first field is numeric: 1. The second field is a random "
"string. Once again the ``string_function()`` can be invoked from "
"``main_function()`` which can be invoked with  ``main_function()``."
msgstr ""
"После этого, \"t\" будет представлять собой значение нового кортежа с "
"двумя полями. Первое поле является числовым: \"1\". Второе поле "
"представляет собой случайную строку. И снова функцию "
"``string_function()`` можно вызвать из ``main_function()``, которую можно"
" вызвать с помощью ``main_function()``."

#: ../doc/tutorials/lua_tutorials.rst:281
msgid ""
"For more about Tarantool tuples see Tarantool manual section "
":ref:`Submodule box.tuple <box_tuple>`."
msgstr ""
"Для получения подробной информации о кортежах в Tarantool'е, см. раздел "
":ref:`Вложенный модуль box.tuple <box_tuple>` руководства по Tarantool'у."

#: ../doc/tutorials/lua_tutorials.rst:285
msgid ""
"tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"

#: ../doc/tutorials/lua_tutorials.rst:303
msgid "Modify main_function to insert a tuple into the database"
msgstr "Изменение основной функции main_function для вставки кортежа в базу данных"

#: ../doc/tutorials/lua_tutorials.rst:305
msgid ""
"Now that it's clear how to make a tuple that contains a number and a "
"10-letter random string, the only trick remaining is putting that tuple "
"into tester. Remember that tester is the first space that was defined in "
"the sandbox, so it's like a database table."
msgstr ""
"Сейчас стало понятно, как создавать кортеж, который содержит число и "
"строку из десяти случайных букв, поэтому осталось только поместить этот "
"кортеж в спейс tester. Следует отметить, что tester -- это первый спейс, "
"определенный в песочнице, поэтому он представляет собой таблицу в базе "
"данных."

#: ../doc/tutorials/lua_tutorials.rst:310
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"

#: ../doc/tutorials/lua_tutorials.rst:319
msgid ""
"The new line here is ``box.space.tester:replace(t)``. The name contains "
"'tester' because the insertion is going to be to tester. The second "
"parameter is the tuple value. To be perfectly correct we could have said "
"``box.space.tester:insert(t)`` here, rather than "
"``box.space.tester:replace(t)``, but \"replace\" means “insert even if "
"there is already a tuple whose primary-key value is a duplicate”, and "
"that makes it easier to re-run the exercise even if the sandbox database "
"isn't empty. Once this is done, tester will contain a tuple with two "
"fields. The first field will be 1. The second field will be a random "
"10-letter string. Once again the ``string_function(``) can be invoked "
"from ``main_function()`` which can be invoked with ``main_function()``. "
"But ``main_function()`` won't tell the whole story, because it does not "
"return t, it only puts t into the database. To confirm that something got"
" inserted, we'll use a SELECT request."
msgstr ""
"Здесь новая строка -- ``box.space.tester:replace(t)``. Имя содержит слово"
" 'tester', потому что вставка будет осуществляться в спейс tester. Второй"
" параметр представляет собой значение в кортеже. Для абсолютной точности "
"мы могли ввести команду ``box.space.tester:insert(t)``, а не "
"``box.space.tester:replace(t)``, но слово \"replace\" (заменить) означает"
" “вставить, даже если уже существует кортеж, у которого значение "
"первичного ключа совпадает”, и это облегчит повтор упражнения, даже если "
"песочница не пуста. После того, как это будет выполнено, спейс tester "
"будет содержать кортеж с двумя полями. Первое поле будет 1. Второе поле "
"будет представлять собой строку из десяти случайных букв. И снова функцию"
" ``string_function()`` можно вызвать из ``main_function()``, которую "
"можно вызвать с помощью ``main_function()``. Но функция "
"``main_function()`` не может полностью отразить ситуацию, поскольку она "
"не возвращает t, она только размещает t в базе данных. Чтобы убедиться, "
"что произошла вставка, используем SELECT-запрос."

#: ../doc/tutorials/lua_tutorials.rst:333
msgid ""
"main_function()\n"
"box.space.tester:select{1}"
msgstr ""
"main_function()\n"
"         box.space.tester:select{1}"

#: ../doc/tutorials/lua_tutorials.rst:338
msgid ""
"For more about Tarantool insert and replace calls, see Tarantool manual "
"section :ref:`Submodule box.space <box_space>`, "
":ref:`space_object:insert() <box_space-insert>`, and "
":ref:`space_object:replace() <box_space-replace>`."
msgstr ""
"Для получения подробной информации о вызовах insert и replace в "
"Tarantool'е, см. разделы :ref:`Вложенный модуль box.space <box_space>`, "
":ref:`space_object:insert() <box_space-insert>` и "
":ref:`space_object:replace() <box_space-replace>` руководства по "
"Tarantool'у."

#: ../doc/tutorials/lua_tutorials.rst:345
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"

#: ../doc/tutorials/lua_tutorials.rst:366
msgid "Modify main_function to insert a million tuples into the database"
msgstr ""
"Изменение основной функции main_function для вставки миллиона кортежей в "
"базу данных"

#: ../doc/tutorials/lua_tutorials.rst:368
msgid ""
"Now that it's clear how to insert one tuple into the database, it's no "
"big deal to figure out how to scale up: instead of inserting with a "
"literal value = 1 for the primary key, insert with a variable value = "
"between 1 and 1 million, in a loop. Since we already saw how to loop, "
"that's a simple thing. The only extra wrinkle that we add here is a "
"timing function."
msgstr ""
"Сейчас стало понятно, как вставить кортеж в базу данных, поэтому несложно"
" догадаться, как можно увеличить масштаб: вместо того, чтобы вставлять "
"значение 1 для первичного ключа, вставьте значение переменной от 1 до "
"миллиона в цикле. Поскольку уже рассматривалось, как заводить цикл, это "
"будет несложно. Мы лишь добавим небольшой штрих -- функцию распределения "
"во времени."

#: ../doc/tutorials/lua_tutorials.rst:374
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"

#: ../doc/tutorials/lua_tutorials.rst:389
msgid ""
"The standard Lua function `os.clock() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_ will return "
"the number of CPU seconds since the start. Therefore, by getting "
"start_time = number of seconds just before the inserting, and then "
"getting end_time = number of seconds just after the inserting, we can "
"calculate (end_time - start_time) = elapsed time in seconds. We will "
"display that value by putting it in a request without any assignments, "
"which causes Tarantool to send the value to the client, which prints it. "
"(Lua's answer to the C ``printf()`` function, which is ``print()``, will "
"also work.)"
msgstr ""
"Стандартная Lua-функция `os.clock() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_ вернет время "
"ЦП в секундах с момента начала программы. Таким образом, выводя "
"start_time = number of seconds (время_начала = число секунд) прямо перед "
"вставкой, а затем выводя end_time = number of seconds (время_окончания = "
"число секунд) сразу после вставки, можно рассчитать (время_окончания - "
"время_начала) = затраченное время в секундах. Отобразим это значение "
"путем ввода в запрос без операторов, что приведет к тому, что Tarantool "
"отправит значение на клиент, который выведет это значение. (Ответ Lua на "
"C-функцию ``printf()``, а именно ``print()``, также сработает.)"

#: ../doc/tutorials/lua_tutorials.rst:399
msgid ""
"For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and "
"Time\"`_. For more on Lua print() see Lua manual `chapter 5 "
"\"Functions\"`_."
msgstr ""
"Для получения подробной информации о функции ``os.clock()`` см. Главу "
"22.1 \"Дата и время\" в руководстве по языку Lua (`chapter 22.1 \"Date "
"and Time\"`_). Для получения подробной информации о функции print() см. "
"Главу 5 \"Функции\" в руководстве по языку Lua (`chapter 5 "
"\"Functions\"`_)."

#: ../doc/tutorials/lua_tutorials.rst:405
msgid ""
"Since this is the grand finale, we will redo the final versions of all "
"the necessary requests: the request that created ``string_function()``, "
"the request that created ``main_function()``, and the request that "
"invokes ``main_function()``."
msgstr ""
"И поскольку наступает кульминация -- повторно введем окончательные "
"варианты всех необходимых запросов: запрос, который создает "
"``string_function()``, запрос, который создает ``main_function()``, и "
"запрос, который вызывает ``main_function()``."

#: ../doc/tutorials/lua_tutorials.rst:410
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""
"function string_function()\n"
"           local random_number\n"
"           local random_string\n"
"           random_string = \"\"\n"
"           for x = 1,10,1 do\n"
"             random_number = math.random(65, 90)\n"
"             random_string = random_string .. string.char(random_number)\n"
"           end\n"
"           return random_string\n"
"         end\n"
"         \n"
"         function main_function()\n"
"           local string_value, t\n"
"           for i = 1,1000000,1 do\n"
"             string_value = string_function()\n"
"             t = box.tuple.new({i,string_value})\n"
"             box.space.tester:replace(t)\n"
"           end\n"
"         end\n"
"         start_time = os.clock()\n"
"         main_function()\n"
"         end_time = os.clock()\n"
"         'insert done in ' .. end_time - start_time .. ' seconds'"

#: ../doc/tutorials/lua_tutorials.rst:438
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"

#: ../doc/tutorials/lua_tutorials.rst:477
msgid ""
"What has been shown is that Lua functions are quite expressive (in fact "
"one can do more with Tarantool's Lua stored procedures than one can do "
"with stored procedures in some SQL DBMSs), and that it's straightforward "
"to combine Lua-library functions and Tarantool-library functions."
msgstr ""
"Итак, мы доказали, что возможности Lua-функций довольно многообразны (на "
"самом деле, с помощью хранимых процедур на языке Lua в Tarantool'е можно "
"сделать больше, чем с помощью хранимых процедур в некоторых SQL СУБД), и "
"несложно комбинировать функции Lua-библиотек и функции "
"Tarantool-библиотек."

#: ../doc/tutorials/lua_tutorials.rst:482
msgid ""
"What has also been shown is that inserting a million tuples took 37 "
"seconds. The host computer was a Linux laptop. By changing :ref:`wal_mode"
" <cfg_binary_logging_snapshots-wal_mode>` to 'none' before running the "
"test, one can reduce the elapsed time to 4 seconds."
msgstr ""
"Также мы показали, что вставка миллиона кортежей заняла 37 секунд. Хостом"
" выступил ноутбук с ОС Linux. А изменив значение  :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>` на 'none' перед запуском теста, "
"можно уменьшить затраченное время до 4 секунд."

#: ../doc/tutorials/lua_tutorials.rst:490
msgid "Sum a JSON field for all tuples"
msgstr "Подсчет суммы по JSON-полям во всех кортежах"

#: ../doc/tutorials/lua_tutorials.rst:492
msgid ""
"This is an exercise assignment: “Assume that inside every tuple there is "
"a string formatted as JSON. Inside that string there is a JSON numeric "
"field. For each tuple, find the numeric field's value and add it to a "
"'sum' variable. At end, return the 'sum' variable.” The purpose of the "
"exercise is to get experience in one way to read and process tuples."
msgstr ""
"Задание по данному практикуму: “Предположим, что в каждом кортеже есть "
"строка в формате JSON. В каждой строке есть числовое поле формата JSON. "
"Для каждого кортежа необходимо найти значение числового поля и прибавить "
"его к переменной 'sum' (сумма). В конце функция должна вернуть переменную"
" 'sum'.” Цель данного упражнения -- получить опыт в прочтении и обработке"
" кортежей одновременно."

#: ../doc/tutorials/lua_tutorials.rst:498
msgid ""
"json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end"
"\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""
"json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end"
"\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"

#: ../doc/tutorials/lua_tutorials.rst:515
msgid ""
"**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will"
" be used in the function. Actually it's not necessary to declare all "
"variables at the start, and in a long function it would be better to "
"declare variables just before using them. In fact it's not even necessary"
" to declare variables at all, but an undeclared variable is \"global\". "
"That's not desirable for any of the variables that are declared in line "
"1, because all of them are for use only within the function."
msgstr ""
"**СТРОКА 3: ЗАЧЕМ НУЖЕН \"LOCAL\".** Эта строка объявляет все переменные,"
" которые будут использоваться в функции. На самом деле, нет необходимости"
" в начале объявлять все переменные, а в длинной функции лучше объявить "
"переменные прямо перед их использованием. Фактически объявлять переменные"
" вообще необязательно, но необъявленная переменная будет \"глобальной\". "
"Это представляется нежелательным для всех переменных, объявленных в "
"строке 1, поскольку все они используются только в рамках функции."

#: ../doc/tutorials/lua_tutorials.rst:522
msgid ""
"**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and "
"there are two ways to do it: with :ref:`box.space.space_object:pairs() "
"<box_space-pairs>` or with ``variable = select(...)`` followed by "
":samp:`for i, {n}, 1 do {some-function}(variable[i]) end`. We preferred "
"``pairs()`` for this example."
msgstr ""
"**СТРОКА 5: ЗАЧЕМ НУЖЕН \"PAIRS()\".** Наша задача -- пройти по всем "
"строкам, что можно сделать двумя способами: с помощью "
":ref:`box.space.space_object:pairs() <box_space-pairs>` или с помощью "
"``variable = select(...)`` с указанием :samp:`for i, {n}, 1 do "
"{некая-функция}(variable[i]) end`. Для данного примера мы предпочли "
"использовать ``pairs()``."

#: ../doc/tutorials/lua_tutorials.rst:527
msgid ""
"**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop "
"will be repeated as long as there is another index key. A tuple is "
"fetched and can be referenced with variable :code:`t`."
msgstr ""
"**СТРОКА 5: НАЧАЛО ОСНОВНОГО ЦИКЛА.** Всё внутри цикла \"``for``\" будет "
"повторяться до тех пор, пока не кончатся индекс-ключи. На полученный "
"кортеж можно сослаться с помощью переменной :code:`t`."

#: ../doc/tutorials/lua_tutorials.rst:531
msgid ""
"**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = "
"json.decode(t[2]))``, then the function would abort with an error if it "
"encountered something wrong with the JSON string - a missing colon, for "
"example. By putting the function inside \"``pcall``\" (`protected "
"call`_), we're saying: we want to intercept that sort of error, so if "
"there's a problem just set ``is_valid_json = false`` and we will know "
"what to do about it later."
msgstr ""
"**СТРОКА 6: ЗАЧЕМ НУЖЕН \"PCALL\".** Если бы мы просто ввели ``lua_table "
"= json.decode(t[2]))``, то функция завершила бы работу с ошибкой, "
"обнаружив любое несоответствие в JSON-строке, например отсутствие "
"запятой. Заключив функцию в \"``pcall``\" (`protected call`_ -- "
"защищенный вызов), мы заявляем следующее: хотим перехватывать ошибки "
"такого рода, поэтому в случае ошибки следует просто указать "
"``is_valid_json = false``, и позднее мы решим, что с этим делать."

#: ../doc/tutorials/lua_tutorials.rst:538
msgid ""
"**LINE 6: MEANING.** The function is :ref:`json.decode <json-decode>` "
"which means decode a JSON string, and the parameter is t[2] which is a "
"reference to a JSON string. There's a bit of hard coding here, we're "
"assuming that the second field in the tuple is where the JSON string was "
"inserted. For example, we're assuming a tuple looks like"
msgstr ""
"**СТРОКА 6: ЗНАЧЕНИЕ.** Функция :ref:`json.decode <json-decode>` означает"
" декодирование JSON-строки, а параметр t[2] представляет собой ссылку на "
"JSON-строку. Здесь есть заранее заданные значения, а мы предполагаем, что"
" JSON-строка была вставлена во второе поле кортежа. Например, "
"предположим, что кортеж выглядит следующим образом:"

#: ../doc/tutorials/lua_tutorials.rst:582
msgid ""
"field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""
"field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"

#: ../doc/tutorials/lua_tutorials.rst:551
msgid ""
"meaning that the tuple's first field, the primary key field, is a number "
"while the tuple's second field, the JSON string, is a string. Thus the "
"entire statement means \"decode ``t[2]`` (the tuple's second field) as a "
"JSON string; if there's an error set ``is_valid_json = false``; if "
"there's no error set ``is_valid_json = true`` and set ``lua_table =`` a "
"Lua table which has the decoded string\"."
msgstr ""
"что означает, что первое поле кортежа, первичное поле, представляет собой"
" число, а второе поле кортежа, JSON-строка, является строкой. Таким "
"образом, значение оператора будет следующим: \"декодировать ``t[2]`` "
"(второе поле кортежа) как JSON-строку; если обнаружится ошибка, то "
"указать ``is_valid_json = false``; если ошибок нет, указать "
"``is_valid_json = true`` и ``lua_table =`` Lua-таблица, в которой "
"находится декодированная строка\"."

#: ../doc/tutorials/lua_tutorials.rst:557
msgid ""
"**LINE 8.** At last we are ready to get the JSON field value from the Lua"
" table that came from the JSON string. The value in field_name, which is "
"the parameter for the whole function, must be a name of a JSON field. For"
" example, inside the JSON string ``'{\"Hello\": \"world\", \"Quantity\": "
"15}'``, there are two JSON fields: \"Hello\" and \"Quantity\". If the "
"whole function is invoked with ``sum_json_field(\"Quantity\")``, then "
"``field_value = lua_table[field_name]`` is effectively the same as "
"``field_value = lua_table[\"Quantity\"]`` or even ``field_value = "
"lua_table.Quantity``. Those are just three different ways of saying: for "
"the Quantity field in the Lua table, get the value and put it in variable"
" :code:`field_value`."
msgstr ""
"**СТРОКА 8.** Наконец, мы готовы получить значение JSON-поля из "
"Lua-таблицы, взятое из JSON-строки. Значение в field_name (имя_поля), "
"которое является параметром всей функции, должно представлять собой "
"JSON-поле. Например, в JSON-строке ``'{\"Hello\": \"world\", "
"\"Quantity\": 15}'`` есть два JSON-поля: \"Hello\" и \"Quantity\". Если "
"вся функция вызывается с помощью ``sum_json_field(\"Quantity\")``, тогда "
"``field_value = lua_table[field_name]`` (значение_поля = "
"Lua_таблица[имя_поля]) по сути аналогично ``field_value = "
"lua_table[\"Quantity\"]`` или даже ``field_value = lua_table.Quantity``. "
"Итак, этими тремя способами можно ввести следующую команду: получить "
"значение поля Quantity в Lua-таблице и поместить его в переменную "
":code:`field_value`."

#: ../doc/tutorials/lua_tutorials.rst:567
msgid ""
"**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but "
"the JSON field is not a number, or is missing. In that case, the function"
" would be aborted when there was an attempt to add it to the sum. By "
"first checking ``type(field_value) == \"number\"``, we avoid that "
"abortion. Anyone who knows that the database is in perfect shape can skip"
" this kind of thing."
msgstr ""
"**СТРОКА 9: ЗАЧЕМ НУЖЕН \"IF\".** Предположим, что JSON-строка не "
"содержит синтаксических ошибок, но JSON-поле не является числовым или "
"вовсе отсутствует. В таком случае выполнение функции прервется при "
"попытке прибавить значение к сумме. Если сначала проверить, "
"``type(field_value) == \"number\"`` (тип(значение_поля) == \"число\"), "
"можно избежать прерывания функции. Если вы уверены, что база данных в "
"идеальном состоянии, этот шаг можно пропустить."

#: ../doc/tutorials/lua_tutorials.rst:573
msgid ""
"And the function is complete. Time to test it. Starting with an empty "
"database, defined the same way as the sandbox database in our "
":ref:`\"Getting started\" exercises <getting_started>`,"
msgstr ""
"И функция готова. Пора протестировать ее. Начинаем с пустой базы данных "
"так же, как с песочницы в :ref:`упражнения в \"Руководстве для "
"начинающих\" <getting_started>`,"

#: ../doc/tutorials/lua_tutorials.rst:577
msgid ""
"-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"
msgstr ""
"-- если спейс tester остался от предыдущего задания, удалите его\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"

#: ../doc/tutorials/lua_tutorials.rst:584
msgid ""
"then add some tuples where the first field is a number and the second "
"field is a string."
msgstr ""
"затем добавим несколько кортежей, где первое поле является числовым, а "
"второе поле представляет собой строку."

#: ../doc/tutorials/lua_tutorials.rst:587
msgid ""
"box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": "
"\"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": "
"3}'}"
msgstr ""
"box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": "
"\"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": "
"3}'}"

#: ../doc/tutorials/lua_tutorials.rst:594
msgid ""
"Since this is a test, there are deliberate errors. The \"golf club\" and "
"the \"waffle iron\" do not have numeric Quantity fields, so must be "
"ignored. Therefore the real sum of the Quantity field in the JSON strings"
" should be: 15 + 7 = 22."
msgstr ""
"Для целей практики здесь допущены ошибки. В \"golf club\" и \"waffle "
"iron\" поля Quantity не являются числовыми, поэтому будут игнорироваться."
" Таким образом, итоговая сумма для полей Quantity в JSON-строках должна "
"быть следующей: 15 + 7 = 22."

#: ../doc/tutorials/lua_tutorials.rst:599
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr "Вызовите функцию с помощью ``sum_json_field(\"Quantity\")``."

#: ../doc/tutorials/lua_tutorials.rst:601
msgid ""
"tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""
"tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."

#: ../doc/tutorials/lua_tutorials.rst:608
msgid ""
"It works. We'll just leave, as exercises for future improvement, the "
"possibility that the \"hard coding\" assumptions could be removed, that "
"there might have to be an overflow check if some field values are huge, "
"and that the function should contain a :ref:`yield <atomic-"
"threads_fibers_yields>` instruction if the count of tuples is huge."
msgstr ""
"Сработало. Для дополнительной отработки материала можно убрать заранее "
"заданные значения, добавить проверку потенциально возможного "
"арифметического переполнения при наличии больших значений некоторых "
"полей, а также команду :ref:`передачи управления <atomic-"
"threads_fibers_yields>` при огромном количестве кортежей."

#: ../doc/tutorials/lua_tutorials.rst:617
msgid "Indexed pattern search"
msgstr "Индексированный поиск по шаблонам"

#: ../doc/tutorials/lua_tutorials.rst:619
msgid ""
"Here is a generic function which takes a field identifier and a search "
"pattern, and returns all tuples that match. |br| * The field must be the "
"first field of a TREE index. |br| * The function will use `Lua pattern "
"matching <http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, which "
"allows \"magic characters\" in regular expressions. |br| * The initial "
"characters in the pattern, as far as the first magic character, will be "
"used as an index search key. For each tuple that is found via the index, "
"there will be a match of the whole pattern. |br| * To be "
":ref:`cooperative <atomic-cooperative_multitasking>`, the function should"
" yield after every 10 tuples, unless there is a reason to delay yielding."
" |br| With this function, we can take advantage of Tarantool's indexes "
"for speed, and take advantage of Lua's pattern matching for flexibility. "
"It does everything that an SQL \"LIKE\" search can do, and far more."
msgstr ""
"Здесь приведена обобщенная функция, которая берет идентификатор поля и "
"шаблон поиска, а затем возвращает все кортежи, которые подходят под "
"критерии. |br| * Поле должно быть первым полем в TREE-индексе. |br| * "
"Функция применяет `шаблоны в языке Lua "
"<http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, что позволяет "
"использовать \"магические символы\" в регулярных выражениях. |br| * "
"Начальные символы в шаблоне до самого первого магического символа будут "
"использоваться в качестве ключа поиска по индексу. Каждый кортеж, "
"обнаруженный по индексу, будет соответствовать всему шаблону. |br| * В "
"целях :ref:`кооперативной многозадачности <atomic-"
"cooperative_multitasking>` функция должна передавать управление через "
"каждые 10 кортежей, если только нет причин отложить передачу управления. "
"|br| С помощью данной функции можно воспользоваться индексами Tarantool'а"
" для ускорения и шаблонами на языке Lua для гибкости. Поддерживаются все "
"возможности поиска LIKE в SQL -- и многие другие."

#: ../doc/tutorials/lua_tutorials.rst:636
msgid ""
"Read the following Lua code to see how it works. The comments that begin "
"with \"SEE NOTE ...\" refer to long explanations that follow the code."
msgstr ""
"Прочитайте следующий Lua-код, чтобы понять, как он работает. Комментарии,"
" которые начинаются с \"СМ. ПРИМЕЧАНИЕ ...\" ссылаются на подробные "
"объяснения, приведенные ниже."

#: ../doc/tutorials/lua_tutorials.rst:640
msgid ""
"function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"string\")) "
"then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == "
"\".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == "
"\"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too "
"short\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- SEE NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\""
"\n"
"      number_of_tuples_since_last_yield = "
"number_of_tuples_since_last_yield + 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- SEE NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\""
"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set +"
" 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"
msgstr ""
"function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- СМ. ПРИМЕЧАНИЕ №1 \"ПОИСК НУЖНОГО ИНДЕКСА\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"string\")) "
"then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- СМ. ПРИМЕЧАНИЕ №2 \"ПОЛУЧЕНИЕ КЛЮЧА ИНДЕКСНОГО ПОИСКА ИЗ ШАБЛОНА\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == "
"\".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == "
"\"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too "
"short\")\n"
"    return nil\n"
"  end\n"
"  -- СМ. ПРИМЕЧАНИЕ №3 \"ВНЕШНИЙ ЦИКЛ: НАЧАЛО\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- СМ. ПРИМЕЧАНИЕ №4 \"ВНУТРЕННИЙ ЦИКЛ: ИТЕРАТОР\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- СМ. ПРИМЕЧАНИЕ №5 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ, ЕСЛИ КЛЮЧ "
"ИНДЕКСА СЛИШКОМ БОЛЬШОЙ\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- СМ. ПРИМЕЧАНИЕ №6 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ ПОСЛЕ КАЖДЫХ "
"ДЕСЯТИ КОРТЕЖЕЙ -- ВОЗМОЖНО\"\n"
"      number_of_tuples_since_last_yield = "
"number_of_tuples_since_last_yield + 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- СМ. ПРИМЕЧАНИЕ №7 \"ВНУТРЕННИЙ ЦИКЛ: ДОБАВЛЕНИЕ В РЕЗУЛЬТАТ, "
"ЕСЛИ ШАБЛОН СОВПАДЕТ\"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set +"
" 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- СМ. ПРИМЕЧАНИЕ №8 \"ВНЕШНИЙ ЦИКЛ: ПРЕРЫВАНИЕ ИЛИ ПЕРЕДАЧА "
"УПРАВЛЕНИЯ И ПРОДОЛЖЕНИЕ\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"

#: ../doc/tutorials/lua_tutorials.rst:731
msgid ""
"NOTE #1 \"FIND AN APPROPRIATE INDEX\" |br| The caller has passed "
"space_name (a string) and field_no (a number). The requirements are: |br|"
" (a) index type must be \"TREE\" because for other index types (HASH, "
"BITSET, RTREE) a search with :ref:`iterator=GE <box_index-iterator-"
"types>` will not return strings in order by string value; |br| (b) "
"field_no must be the first index part; |br| (c) the field must contain "
"strings, because for other data types (such as \"unsigned\") pattern "
"searches are not possible; |br| If these requirements are not met by any "
"index, then print an error message and return nil."
msgstr ""
"ПРИМЕЧАНИЕ №1 \"ПОИСК НУЖНОГО ИНДЕКСА\" |br| Вызывающий клиент передал "
"space_name (имя_спейса -- строка) и field_no (номер_поля -- число). "
"Требования следующие: |br| (a) тип индекса должен быть \"TREE\", "
"поскольку для других типов индекса (HASH, BITSET, RTREE) поиск с "
":ref:`итератором=GE <box_index-iterator-types>` не вернет строки, "
"упорядоченные по строковому значению; |br| (b) field_no должен "
"представлять собой первую часть индекса; |br| (c) поле должно содержать "
"строки, потому что для других типов данных (как \"unsigned\") шаблоны "
"поиска не применяются; |br| Если индекс не удовлетворяет этим "
"требованиям, выдать сообщение об ошибке и вернуть нулевое значение nil."

#: ../doc/tutorials/lua_tutorials.rst:743
msgid ""
"NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\" |br| The caller has "
"passed pattern (a string). The index search key will be the characters in"
" the pattern as far as the first magic character. Lua's magic characters "
"are % ^ $ ( ) . [ ] * + - ?. For example, if the pattern is \"ABC.E\", "
"the period is a magic character and therefore the index search key will "
"be \"ABC\". But there is a complication ... If we see \"%\" followed by a"
" punctuation character, that punctuation character is \"escaped\" so "
"remove the \"%\" when making the index search key. For example, if the "
"pattern is \"AB%$E\", the dollar sign is escaped and therefore the index "
"search key will be \"AB$E\". Finally there is a check that the index "
"search key length must be at least three -- this is an arbitrary number, "
"and in fact zero would be okay, but short index search keys will cause "
"long search times."
msgstr ""
"ПРИМЕЧАНИЕ №2 \"ПОЛУЧЕНИЕ КЛЮЧА ИНДЕКСНОГО ПОИСКА ИЗ ШАБЛОНА\" |br| "
"Вызывающий клиент передал шаблон (строку). Ключом поиска по индексу "
"являются символы в шаблоне до первого магического символа. Магические "
"символы в Lua: % ^ $ ( ) . [ ] * + - ?. Например, если задан шаблон "
"\"ABC.E\", точка будет магическим символом, и ключом поиска по индексу "
"будет \"ABC\". Однако есть затруднение ... Если символ \"%\" будет идти "
"следом за знаком препинания, этот знак препинания экранируется, поэтому "
"следует убрать \"%\" из ключа поиска по индексу. Например, если задан "
"шаблон \"AB%$E\", знак доллара экранируется, поэтому ключом поиска по "
"индексу будет \"AB$E\". Наконец, есть проверка длины ключа поиска по "
"индексу -- не менее трех символов, причем это число выбрано произвольно, "
"и даже ноль здесь подойдет, но по короткому ключу поиск займет длительное"
" время."

#: ../doc/tutorials/lua_tutorials.rst:760
msgid ""
"NOTE #3 -- \"OUTER LOOP: INITIATE\" |br| The function's job is to return "
"a result set, just as `box.space...select <box_space-select>` would. We "
"will fill it within an outer loop that contains an inner loop. The outer "
"loop's job is to execute the inner loop, and possibly :ref:`yield "
"<atomic-threads_fibers_yields>`, until the search ends. The inner loop's "
"job is to find tuples via the index, and put them in the result set if "
"they match the pattern."
msgstr ""
"ПРИМЕЧАНИЕ №3 \"ВНЕШНИЙ ЦИКЛ: НАЧАЛО\" |br| Назначение функции -- вернуть"
" результирующий набор данных, как вернул бы запрос `box.space...select "
"<box_space-select>`. Мы внесем ее во внешний цикл, который включает в "
"себя внутренний цикл. Назначение внешнего цикла -- выполнять внутренний "
"цикл и, при необходимости, :ref:`передачу управления <atomic-"
"threads_fibers_yields>`, пока поиск не будет завершен. Назначение "
"внутреннего цикла -- находить кортежи по индексу и включать их в "
"результирующий набор данных, если они подходят под шаблон."

#: ../doc/tutorials/lua_tutorials.rst:769
msgid ""
"NOTE #4 \"INNER LOOP: ITERATOR\" |br| The for loop here is using pairs(),"
" see the :ref:`explanation of what index iterators are <box_index-"
"index_pairs>`. Within the inner loop, there will be a local variable "
"named \"tuple\" which contains the latest tuple found via the index "
"search key."
msgstr ""
"ПРИМЕЧАНИЕ №4 \"ВНУТРЕННИЙ ЦИКЛ: ИТЕРАТОР\" |br| Цикл for здесь "
"использует pairs(), см. :ref:`объяснение, что такое итераторы <box_index-"
"index_pairs>`. Во внутреннем цикле будет локальная переменная под "
"названием \"tuple\" (кортеж), которая содержит последний кортеж, "
"обнаруженный в ходе поиска по индексу."

#: ../doc/tutorials/lua_tutorials.rst:776
msgid ""
"NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\" |br| The iterator"
" is GE (Greater or Equal), and we must be more specific: if the search "
"index key has N characters, then the leftmost N characters of the "
"result's index field must not be greater than the search index key. For "
"example, if the search index key is 'ABC', then 'ABCDE' is a potential "
"match, but 'ABD' is a signal that no more matches are possible."
msgstr ""
"ПРИМЕЧАНИЕ №5 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ, ЕСЛИ КЛЮЧ ИНДЕКСА СЛИШКОМ "
"БОЛЬШОЙ\" |br| Используется итератор GE (Greater or Equal - больше или "
"равно), поэтому необходимо уточнить: если ключ поиска по индексу включает"
" в себя N символов, то крайние N символов слева от найденного поля "
"индекса не должны быть больше ключа поиска. Например, если ключом поиска "
"является  'ABC', то 'ABCDE' потенциально подходит, а 'ABD' означает, что "
"в дальнейшем совпадений не будет."

#: ../doc/tutorials/lua_tutorials.rst:785
msgid ""
"NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\" |br| This "
"chunk of code is for cooperative multitasking. The number 10 is "
"arbitrary, and usually a larger number would be okay. The simple rule "
"would be \"after checking 10 tuples, yield, and then resume the search "
"(that is, do the inner loop again) starting after the last value that was"
" found\". However, if the index is non-unique or if there is more than "
"one field in the index, then we might have duplicates -- for example "
"{\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", 3}\" -- and it would be difficult to"
" decide which \"ABC\" tuple to resume with. Therefore, if the result's "
"index field is the same as the previous result's index field, there is no"
" break."
msgstr ""
"ПРИМЕЧАНИЕ №6 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ ПОСЛЕ КАЖДЫХ ДЕСЯТИ КОРТЕЖЕЙ "
"-- ВОЗМОЖНО\" |br| Эта часть кода предназначена для кооперативной "
"многозадачности. Число 10 выбрано произвольно, и как правило, большее "
"число также подойдет. Простое правило гласит: \"после проверки 10 "
"кортежей передать управление, а затем возобновить поиск (то есть снова "
"выполнять внутренний цикл), начиная с последнего обнаруженного "
"значения\". Однако, если индекс не уникален, или в индексе более одного "
"поля, можно получить дублирующиеся результаты, например, {\"ABC\",1}, "
"{\"ABC\", 2}, {\"ABC\", 3}\" -- и будет трудно решить, с какого кортежа "
"\"ABC\" возобновлять поиск. Таким образом, если найденное поле индекса "
"совпадает с предыдущим найденным полем индекса, цикл не прерывается."

#: ../doc/tutorials/lua_tutorials.rst:798
msgid ""
"NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\" |br| Compare"
" the result's index field to the entire pattern. For example, suppose "
"that the caller passed pattern \"ABC.E\" and there is an indexed field "
"containing \"ABCDE\". Therefore the initial index search key is \"ABC\". "
"Therefore a tuple containing an indexed field with \"ABCDE\" will be "
"found by the iterator, because \"ABCDE\" > \"ABC\". In that case "
"string.match will return a value which is not nil. Therefore this tuple "
"can be added to the result set."
msgstr ""
"ПРИМЕЧАНИЕ №7 \"ВНУТРЕННИЙ ЦИКЛ: ДОБАВЛЕНИЕ В РЕЗУЛЬТАТ, ЕСЛИ ШАБЛОН "
"СОВПАДЕТ\" |br| Сравнение найденного поля индекса с шаблоном. Например, "
"предположим, что вызывающий клиент передает шаблон \"ABC.E\", и "
"существует поле индекса, содержащее \"ABCDE\". В таком случае, начальный "
"ключ поиска будет \"ABC\". Таким образом, кортеж, содержащий поле индекса"
" с \"ABCDE\" будет обнаружен итератором, поскольку \"ABCDE\" > \"ABC\". В"
" этом случае, string.match вернет значение, отличное от нулевого nil. В "
"итоге, этот кортеж можно добавить в результирующий набор данных."

#: ../doc/tutorials/lua_tutorials.rst:808
msgid ""
"NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\" |br| There are three"
" conditions which will cause a break from the inner loop: (1) the for "
"loop ends naturally because there are no more index keys which are "
"greater than or equal to the index search key, (2) the index key is too "
"great as described in NOTE #5, (3) it is time for a yield as described in"
" NOTE #6. If condition (1) or condition (2) is true, then there is "
"nothing more to do, the outer loop ends too. If and only if condition (3)"
" is true, the outer loop must yield and then continue. If it does "
"continue, then the inner loop -- the iterator search -- will happen again"
" with a new value for the index search key."
msgstr ""
"ПРИМЕЧАНИЕ №8 \"ВНЕШНИЙ ЦИКЛ: ПРЕРЫВАНИЕ ИЛИ ПЕРЕДАЧА УПРАВЛЕНИЯ И "
"ПРОДОЛЖЕНИЕ\" |br| Существуют три условия, которые вызовут прерывание из "
"внутреннего цикла: (1) цикл for заканчивается закономерно, потому что "
"отсутствуют ключи индекса, которые больше или равны ключу поиска по "
"индексу, (2) ключ индекса слишком большой, как описано в ПРИМЕЧАНИИ №5, "
"(3) пора передавать управление, как описано в ПРИМЕЧАНИИ №6. Если условие"
" (1) или условие (2) соблюдается, другие действия не требуются, и внешний"
" цикл также заканчивается. Только в том случае, если справедливо условие "
"(3), внешний цикл должен передать управление, а затем продолжить "
"выполнение. Если он продолжит выполнение, то внутренний цикл -- поиск с "
"итератором -- будет выполняться снова с новым значением для ключа поиска "
"по индексу."

#: ../doc/tutorials/lua_tutorials.rst:821
msgid "EXAMPLE:"
msgstr "ПРИМЕР:"

#: ../doc/tutorials/lua_tutorials.rst:823
msgid ""
"Start Tarantool, cut and paste the code for function "
"``indexed_pattern_search()``, and try the following:"
msgstr ""
"Запустите Tarantool, скопируйте и вставьте код для функции "
"``indexed_pattern_search()`` и попробуйте выполнить следующее:"

#: ../doc/tutorials/lua_tutorials.rst:863
msgid ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,parts={2,'string',3,'string'}})"
"\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"
msgstr ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,parts={2,'string',3,'string'}})"
"\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"

#: ../doc/tutorials/lua_tutorials.rst:843
msgid "The result will be:"
msgstr "Получим следующий результат:"

#: ../doc/tutorials/lua_tutorials.rst:845
msgid ""
"tarantool> indexed_pattern_search(\"t\", 2, \"ABC.E.\")\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."
msgstr ""
"tarantool> indexed_pattern_search(\"t\", 2, \"ABC.E.\")\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."

