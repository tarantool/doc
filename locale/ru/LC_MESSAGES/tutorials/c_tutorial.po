
msgid "C tutorial"
msgstr "Практическое задание на C"

msgid ""
"Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-"
"c_stored_procedures>`."
msgstr ""
"Ниже приводится практическое занятие на языке C: :ref:`Хранимые процедуры"
" на языке C <f_c_tutorial-c_stored_procedures>`."

msgid "C stored procedures"
msgstr "Хранимые процедуры на языке C"

msgid ""
"Tarantool can call C code with :ref:`modules <app_server-modules>`, or "
"with :ref:`ffi <cookbook-ffi_printf>`, or with C stored procedures. This "
"tutorial only is about the third option, C stored procedures. In fact the"
" routines are always \"C functions\" but the phrase \"stored procedure\" "
"is commonly used for historical reasons."
msgstr ""
"Tarantool может вызывать код на языке C с помощью :ref:`модулей "
"<app_server-modules>`, :ref:`ffi <cookbook-ffi_printf>` или хранимых "
"процедур на C. В данном практическом задании рассматривается только "
"третий метод, хранимые процедуры на языке C. На самом деле, программы "
"всегда представляют собой функции на языке C, но исторически сложилось "
"так, что широко используется фраза \"хранимая процедура\"."

msgid ""
"In this tutorial, which can be followed by anyone with a Tarantool "
"development package and a C compiler, there are five tasks:"
msgstr ""
"Данное практическое задание могут выполнить те, у кого есть пакет "
"программ для разработки Tarantool'а и компилятор языка программирования "
"C. Оно состоит из пяти задач:"

msgid ":ref:`easy.c <f_c_tutorial-easy>` -- prints \"hello world\";"
msgstr ":ref:`easy.c <f_c_tutorial-easy>` -- выводит \"hello world\";"

msgid ":ref:`harder.c <f_c_tutorial-harder>` -- decodes a passed parameter value;"
msgstr ""
":ref:`harder.c <f_c_tutorial-harder>` -- декодирует переданное значение "
"параметра;"

msgid ""
":ref:`hardest.c <f_c_tutorial-hardest>` -- uses the C API to do a DBMS "
"insert;"
msgstr ""
":ref:`hardest.c <f_c_tutorial-hardest>` -- использует API для языка C для"
" вставки в базу данных;"

msgid ":ref:`read.c <f_c_tutorial-read>` -- uses the C API to do a DBMS select;"
msgstr ""
":ref:`read.c <f_c_tutorial-read>` -- использует API для языка C для "
"выборки из базы данных;"

msgid ""
":ref:`write.c <f_c_tutorial-write>` -- uses the C API to do a DBMS "
"replace."
msgstr ""
":ref:`write.c <f_c_tutorial-write>` -- использует API для языка C для "
"замены в базе данных."

msgid ""
"After following the instructions, and seeing that the results are what is"
" described here, users should feel confident about writing their own "
"stored procedures."
msgstr ""
"По окончании задания, вы увидите описанные здесь результаты и сможете "
"самостоятельно написать хранимые процедуры."

msgid "**Preparation**"
msgstr "**Подготовка**"

msgid "Check that these items exist on the computer:"
msgstr "Проверьте наличие следующих элементов на компьютере:"

msgid "Tarantool 1.10"
msgstr "Tarantool 1.10"

msgid "A gcc compiler, any modern version should work"
msgstr "Компилятор GCC, подойдет любая современная версия"

msgid "``module.h`` and files #included in it"
msgstr "``module.h`` и включенные в него файлы"

msgid "``msgpuck.h``"
msgstr "``msgpuck.h``"

msgid "``libmsgpuck.a`` (only for some recent msgpuck versions)"
msgstr "``libmsgpuck.a`` (только для некоторых последних версий msgpuck)"

msgid ""
"The ``module.h`` file will exist if Tarantool was installed from source. "
"Otherwise Tarantool's \"developer\" package must be installed. For "
"example on Ubuntu say:"
msgstr ""
"Файл ``module.h`` есть в системе, если Tarantool был установлен из "
"исходных файлов. В противном случае, следует установить пакет Tarantool'а"
" \"developer\". Например, на Ubuntu введите команду:"

msgid "$ sudo apt-get install tarantool-dev"
msgstr "$ sudo apt-get install tarantool-dev"

msgid "or on Fedora say:"
msgstr "или на Fedora введите команду:"

msgid "$ dnf -y install tarantool-devel"
msgstr "$ dnf -y install tarantool-devel"

#, fuzzy
msgid ""
"The ``msgpuck.h`` file will exist if Tarantool was installed from source."
" Otherwise the \"msgpuck\" package must be installed from "
"`https://github.com/tarantool/msgpuck "
"<https://github.com/tarantool/msgpuck>`_."
msgstr ""
"Файл ``msgpuck.h`` есть в системе, если Tarantool был установлен из "
"исходных файлов. В противном случае, следует установить пакет \"msgpuck\""
" по ссылке `https://github.com/rtsisyk/msgpuck "
"<https://github.com/rtsisyk/msgpuck>`_."

msgid ""
"Both ``module.h`` and ``msgpuck.h`` must be on the include path for the C"
" compiler to see them. For example, if ``module.h`` address is "
"``/usr/local/include/tarantool/module.h``, and ``msgpuck.h`` address is "
"``/usr/local/include/msgpuck/msgpuck.h``, and they are not currently on "
"the include path, say:"
msgstr ""
"Чтобы компилятор C увидел файлы ``module.h`` и ``msgpuck.h``, путь к ним "
"следует сохранить в переменной. Например, если адрес файла ``module.h`` "
"-- ``/usr/local/include/tarantool/module.h``, а адрес файла ``msgpuck.h``"
" -- ``/usr/local/include/msgpuck/msgpuck.h``, введите команду:"

msgid "$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"
msgstr "$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"

msgid ""
"The ``libmsgpuck.a`` static library is necessary with msgpuck versions "
"produced after February 2017. If and only if you encounter linking "
"problems when using the gcc statements in the examples for this tutorial,"
" you should put ``libmsgpuck.a`` on the path (``libmsgpuck.a`` is "
"produced from both msgpuck and Tarantool source downloads so it should be"
" easy to find). For example, instead of \":code:`gcc -shared -o harder.so"
" -fPIC harder.c`\" for the second example below, you will need to say "
"\":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."
msgstr ""
"Статическая библиотека ``libmsgpuck.a`` нужна для версий msgpuck старше "
"февраля 2017 года. Только в том случае, если встречаются проблемы "
"соединения при использовании операторов GCC в примерах данного "
"практического задания, в пути следует указывать ``libmsgpuck.a`` "
"(``libmsgpuck.a`` создан из исходных файлов загрузки msgpuck и Tarantool,"
" поэтому его легко найти). Например, вместо \":code:`gcc -shared -o "
"harder.so -fPIC harder.c`\" во втором примере ниже, необходимо ввести "
"\":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."

msgid ""
"Requests will be done using Tarantool as a :ref:`client <admin-"
"using_tarantool_as_a_client>`. Start Tarantool, and enter these requests."
msgstr ""
"Tarantool выполняет запросы в качестве :ref:`клиента <admin-"
"using_tarantool_as_a_client>`. Запустите Tarantool и введите эти запросы."

msgid ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"

msgid ""
"In plainer language: create a space named ``capi_test``, and make a "
"connection to self named ``capi_connection``."
msgstr ""
"Проще говоря: создайте спейс под названием ``capi_test``, и выполните "
"соединение с одноименным ``capi_connection``."

msgid ""
"Leave the client running. It will be necessary to enter more requests "
"later."
msgstr "Не закрывайте клиент. Он понадобится для последующих запросов."

msgid "**easy.c**"
msgstr "**easy.c**"

msgid ""
"Start another shell. Change directory (``cd``) so that it is the same as "
"the directory that the client is running on."
msgstr ""
"Запустите еще один терминал. Измените директорию (``cd``), чтобы она "
"совпадала с директорией, где запущен клиент."

msgid "Create a file. Name it ``easy.c``. Put these six lines in it."
msgstr ""
"Создайте файл. Назовите его ``easy.c``. Запишите в него следующие шесть "
"строк."

msgid ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}\n"
"int easy2(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  printf(\"hello world -- easy2\\n\");\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}\n"
"int easy2(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  printf(\"hello world -- easy2\\n\");\n"
"  return 0;\n"
"}"

msgid "Compile the program, producing a library file named ``easy.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``easy.so``:"

msgid "$ gcc -shared -o easy.so -fPIC easy.c"
msgstr "$ gcc -shared -o easy.so -fPIC easy.c"

msgid "Now go back to the client and execute these requests:"
msgstr "Теперь вернитесь в клиент и выполните следующие запросы:"

msgid ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"

msgid ""
"If these requests appear unfamiliar, re-read the descriptions of "
":doc:`/reference/reference_lua/box_schema/func_create`, "
":doc:`/reference/reference_lua/box_schema/user_grant` and "
":ref:`conn:call() <net_box-call>`."
msgstr ""
"Если эти запросы вам незнакомы, перечитайте описание "
":doc:`/reference/reference_lua/box_schema/func_create`, "
":doc:`/reference/reference_lua/box_schema/user_grant` и :ref:`conn:call()"
" <net_box-call>`."

msgid "The function that matters is ``capi_connection:call('easy')``."
msgstr "Важна функция ``capi_connection:call('easy')``."

msgid ""
"Its first job is to find the 'easy' function, which should be easy "
"because by default Tarantool looks on the current directory for a file "
"named ``easy.so``."
msgstr ""
"Во-первых, она ищет функцию easy, что должно быть легко, потому что по "
"умолчанию Tarantool ищет в текущей директории файл под названием "
"``easy.so``."

msgid ""
"Its second job is to call the 'easy' function. Since the ``easy()`` "
"function in ``easy.c`` begins with ``printf(\"hello world\\n\")``, the "
"words \"hello world\" will appear on the screen."
msgstr ""
"Во-вторых, она вызывает функцию easy. Поскольку функция ``easy()`` в "
"``easy.c`` начинается с ``printf(\"hello world\\n\")``, слова \"hello "
"world\" появятся на экране."

msgid ""
"Its third job is to check that the call was successful. Since the "
"``easy()`` function in ``easy.c`` ends with :code:`return 0`, there is no"
" error message to display and the request is over."
msgstr ""
"В-третьих, она проверяет, что вызов прошел успешно. Поскольку функция "
"``easy()`` в ``easy.c`` оканчивается на :code:`return 0`, сообщение об "
"ошибке отсутствует, и запрос выполнен."

msgid "The result should look like this:"
msgstr "Результат должен выглядеть следующим образом:"

msgid ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."

msgid ""
"Now let's call the other function in easy.c -- ``easy2()``. This is "
"almost the same as the ``easy()`` function, but there's a detail: when "
"the file name is not the same as the function name, then we have to "
"specify :samp:`{file-name}.{function-name}`."
msgstr ""
"Теперь вызовем другую функцию в easy.c -- ``easy2()``. Она практически "
"совпадает с функцией ``easy()``, но есть небольшое отличие: если имя "
"файла не совпадет с именем функции, нужно будет указать "
":samp:`{имя-файла}.{имя-функции}`."

msgid ""
"box.schema.func.create('easy.easy2', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"capi_connection:call('easy.easy2')"
msgstr ""
"box.schema.func.create('easy.easy2', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"capi_connection:call('easy.easy2')"

msgid "... and this time the result will be \"hello world -- easy2\"."
msgstr "... и на этот раз результатом будет: \"hello world -- easy2\"."

msgid "Conclusion: calling a C function is easy."
msgstr "Вывод: вызвать C-функцию легко."

msgid "**harder.c**"
msgstr "**harder.c**"

msgid "Go back to the shell where the ``easy.c`` program was created."
msgstr "Вернитесь в терминал, где была создана программа ``easy.c``."

msgid "Create a file. Name it ``harder.c``. Put these 17 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``harder.c``. Запишите в него следующие 17 "
"строк:"

#, python-format
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"

msgid "Compile the program, producing a library file named ``harder.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``harder.so``:"

msgid "$ gcc -shared -o harder.so -fPIC harder.c"
msgstr "$ gcc -shared -o harder.so -fPIC harder.c"

msgid ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"
msgstr ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"

msgid ""
"This time the call is passing a Lua table (``passable_table``) to the "
"``harder()`` function. The ``harder()`` function will see it, it's in the"
" :code:`char *args` parameter."
msgstr ""
"На этот раз вызов передает Lua-таблицу (``passable_table``) в функцию "
"``harder()``. Функция``harder()`` увидит это, как указано в параметре "
":code:`char *args`."

msgid ""
"At this point the ``harder()`` function will start using functions "
"defined in `msgpuck.h <https://github.com/tarantool/msgpuck>`_. The "
"routines that begin with \"mp\" are msgpuck functions that handle data "
"formatted according to the MsgPack_ specification. Passes and returns are"
" always done with this format so one must become acquainted with msgpuck "
"to become proficient with the C API."
msgstr ""

msgid ""
"For now, though, it's enough to know that ``mp_decode_array()`` returns "
"the number of elements in an array, and ``mp_decode_uint`` returns an "
"unsigned integer, from :code:`args`. And there's a side effect: when the "
"decoding finishes, :code:`args` has changed and is now pointing to the "
"next element."
msgstr ""
"Однако, пока достаточно понимать, что функция ``mp_decode_array()`` "
"возвращает количество элементов в массиве, а функция ``mp_decode_uint`` "
"возвращает целое число без знака из :code:`args`. Есть также побочный "
"эффект: по окончании декодирования :code:`args` изменился и теперь "
"указывает на следующий элемент."

msgid ""
"Therefore the first displayed line will be \"arg_count = 1\" because "
"there was only one item passed: ``passable_table``. |br| The second "
"displayed line will be \"field_count = 3\" because there are three items "
"in the table. |br| The next three lines will be \"1\" and \"2\" and \"3\""
" because those are the values in the items in the table."
msgstr ""
"Таким образом, первой будет отображена строка \"arg_count = 1\", "
"поскольку был передан только один элемент: ``passable_table``. |br| "
"Второй будет отображена строка \"field_count = 3\", потому что в таблице "
"находятся три элемента. |br| Следующие три строки будут \"1\", \"2\" и "
"\"3\", потому что это значения элементов в таблице."

msgid "And now the screen looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

msgid ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."

msgid ""
"Conclusion: decoding parameter values passed to a C function is not easy "
"at first, but there are routines to do the job, and they're documented, "
"and there aren't very many of them."
msgstr ""
"Вывод: на первый взгляд, декодирование значений параметров, переданных в "
"C-функцию непросто, но существуют документированные процедуры для этих "
"целей, и их не так много."

msgid "**hardest.c**"
msgstr "**hardest.c**"

msgid ""
"Go back to the shell where the ``easy.c`` and the ``harder.c`` programs "
"were created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c`` и "
"``harder.c``."

msgid "Create a file. Name it ``hardest.c``. Put these 13 lines in it:"
msgstr ""
"Создайте файл. Назовите его ```hardest.c``. Запишите в него следующие 13 "
"строк:"

msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"

msgid "Compile the program, producing a library file named ``hardest.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``hardest.so``:"

msgid "$ gcc -shared -o hardest.so -fPIC hardest.c"
msgstr "$ gcc -shared -o hardest.so -fPIC hardest.c"

msgid ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"

msgid "This time the C function is doing three things:"
msgstr "На этот раз C-функция выполняет три действия:"

msgid ""
"finding the numeric identifier of the ``capi_test`` space by calling "
"``box_space_id_by_name()``;"
msgstr ""
"найдет числовой идентификатор спейса ``capi_test`` путем вызова "
"``box_space_id_by_name()``;"

msgid "formatting a tuple using more ``msgpuck.h`` functions;"
msgstr "форматирует кортеж, используя другие функции ``msgpuck.h``;"

msgid "inserting a tuple using ``box_insert()``."
msgstr "вставит кортеж с помощью ``box_insert()``."

msgid ""
"``char tuple[1024];`` is used here as just a quick way of saying "
"\"allocate more than enough bytes\". For serious programs the developer "
"must be careful to allow enough space for all the bytes that the "
"``mp_encode`` routines will use up."
msgstr ""
"``char tuple[1024];`` используется здесь просто в качестве быстрого "
"способа ввода команды \"выделить байтов с запасом\". В серьезных "
"программах разработчику следует обратить внимание на то, чтобы выделить "
"достаточно места, которое будут использовать процедуры ``mp_encode``."

msgid "Now, still on the client, execute this request:"
msgstr "Затем всё еще в клиенте выполните следующий запрос:"

msgid "box.space.capi_test:select()"
msgstr "box.space.capi_test:select()"

msgid ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."

msgid ""
"This proves that the ``hardest()`` function succeeded, but where did "
":ref:`box_space_id_by_name() <box-box_space_id_by_name>` and "
":ref:`box_insert() <box-box_insert>` come from? Answer: the :ref:`C API "
"<index-c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``hardest()`` была успешно выполнена, но "
"откуда взялись :ref:`box_space_id_by_name() <box-box_space_id_by_name>` и"
" :ref:`box_insert() <box-box_insert>`? Ответ: :ref:`API для языка C "
"<index-c_api_reference>`."

msgid "**read.c**"
msgstr "**read.c**"

msgid ""
"Go back to the shell where the ``easy.c`` and the ``harder.c`` and the "
"``hardest.c`` programs were created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c``, ``harder.c``"
" и ``hardest.c``."

msgid "Create a file. Name it ``read.c``. Put these 43 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``read.c``. Запишите в него следующие 43 "
"строки:"

#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  char tuple_buf[1024];      /* where the raw MsgPack tuple will be "
"stored */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* The number of the space's first index */\n"
"  uint32_t key = 10000;      /* The key value that box_insert() used */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* Pass key_buf = encoded key = 1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Get the tuple. There's no box_select() but there's this. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Get each field of the tuple + display what you get. */\n"
"  int field_no;             /* The first field number is 0. */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* if (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  char tuple_buf[1024];      /* здесь будет храниться тапл в сыром "
"MsgPack-формате */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* номер первого индекса спейса */\n"
"  uint32_t key = 10000;      /* значение ключа, используемое box_insert()"
" */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* передаем key_buf = закодированный ключ = "
"1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Получить тапл. У нас нет box_select(), но есть вот это. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Получить каждое поле тапла + показать полученное значение */\n"
"  int field_no;             /* номер первого поля = 0 */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* если (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"

msgid "Compile the program, producing a library file named ``read.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``read.so``:"

msgid "$ gcc -shared -o read.so -fPIC read.c"
msgstr "$ gcc -shared -o read.so -fPIC read.c"

msgid ""
"box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"
msgstr ""
"box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"

msgid "This time the C function is doing four things:"
msgstr "На этот раз C-функция выполняет четыре действия:"

msgid ""
"once again, finding the numeric identifier of the ``capi_test`` space by "
"calling ``box_space_id_by_name()``;"
msgstr ""
"снова найдет числовой идентификатор спейса ``capi_test`` путем вызова "
"``box_space_id_by_name()``;"

msgid "formatting a search key = 10000 using more ``msgpuck.h`` functions;"
msgstr "форматирует ключ поиска = 10 000, используя другие функции ``msgpuck.h``;"

msgid "getting a tuple using ``box_index_get()``;"
msgstr "получает кортеж с помощью ``box_index_get()``;"

msgid ""
"going through the tuple's fields with ``box_tuple_get()`` and then "
"decoding each field depending on its type. In this case, since what we "
"are getting is the tuple that we inserted with ``hardest.c``, we know in "
"advance that the type is either MP_UINT or MP_STR; however, it's very "
"common to have a case statement here with one option for each possible "
"type."
msgstr ""
"проходит по полям каждого кортежа с помощью ``box_tuple_get()``. а затем "
"декодирует каждое поле в зависимости от его типа. В данном случае, "
"поскольку мы получаем кортеж, который сами вставили с помощью "
"``hardest.c``, мы знаем заранее, что его тип будет MP_UINT или MP_STR. "
"Однако, весьма часто здесь употребляется оператор выбора case с одной "
"опцией для каждого возможного типа."

msgid "The result of ``capi_connection:call('read')`` should look like this:"
msgstr "В результате вызова ``capi_connection:call('read')`` должны получить:"

msgid ""
"tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."

msgid ""
"This proves that the ``read()`` function succeeded. Once again the "
"important functions that start with `box` -- :ref:`box_index_get() "
"<c_api-box_index-box_index_get>` and :ref:`box_tuple_field() <c_api-"
"tuple-box_tuple_field>` -- came from the :ref:`C API <index-"
"c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``read()`` была успешно выполнена. И снова "
"важные функции, которые начинаются с `box` -- :ref:`box_index_get() "
"<c_api-box_index-box_index_get>` и :ref:`box_tuple_field() <c_api-tuple-"
"box_tuple_field>` -- пришли из :ref:`API для языка C <index-"
"c_api_reference>`."

msgid "**write.c**"
msgstr "**write.c**"

msgid ""
"Go back to the shell where the programs ``easy.c``, ``harder.c``, "
"``hardest.c`` and ``read.c`` were created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c``, "
"``harder.c``, ``hardest.c`` и ``read.c``."

msgid "Create a file. Name it ``write.c``. Put these 24 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``write.c``. Запишите в него следующие 24 "
"строки:"

#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int write(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  static const char *space = \"capi_test\";\n"
"  char tuple_buf[1024]; /* Must be big enough for mp_encode results */\n"
"  uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"  if (space_id == BOX_ID_NIL) {\n"
"    return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"    \"Can't find space %s\", \"capi_test\");\n"
"  }\n"
"  char *tuple_end = tuple_buf;\n"
"  tuple_end = mp_encode_array(tuple_end, 2);\n"
"  tuple_end = mp_encode_uint(tuple_end, 1);\n"
"  tuple_end = mp_encode_uint(tuple_end, 22);\n"
"  box_txn_begin();\n"
"  if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"    return -1;\n"
"  box_txn_commit();\n"
"  fiber_sleep(0.001);\n"
"  struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                      tuple_buf, tuple_end);\n"
"  return box_return_tuple(ctx, tuple);\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int write(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  static const char *space = \"capi_test\";\n"
"  char tuple_buf[1024]; /* Должен быть достаточно большим, чтобы вместить"
" результат mp_encode */\n"
"  uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"  if (space_id == BOX_ID_NIL) {\n"
"    return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"    \"Can't find space %s\", \"capi_test\");\n"
"  }\n"
"  char *tuple_end = tuple_buf;\n"
"  tuple_end = mp_encode_array(tuple_end, 2);\n"
"  tuple_end = mp_encode_uint(tuple_end, 1);\n"
"  tuple_end = mp_encode_uint(tuple_end, 22);\n"
"  box_txn_begin();\n"
"  if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"    return -1;\n"
"  box_txn_commit();\n"
"  fiber_sleep(0.001);\n"
"  struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                      tuple_buf, tuple_end);\n"
"  return box_return_tuple(ctx, tuple);\n"
"}"

msgid "Compile the program, producing a library file named ``write.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``write.so``:"

msgid "$ gcc -shared -o write.so -fPIC write.c"
msgstr "$ gcc -shared -o write.so -fPIC write.c"

msgid ""
"box.schema.func.create('write', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('write')"
msgstr ""
"box.schema.func.create('write', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('write')"

msgid "This time the C function is doing six things:"
msgstr "На этот раз C-функция выполняет шесть действий:"

msgid "making a new tuple;"
msgstr "создает новый кортеж;"

msgid "starting a transaction;"
msgstr "начинает транзакцию;"

msgid "replacing a tuple in ``box.space.capi_test``"
msgstr "заменяет кортеж в ``box.space.capi_test``"

msgid "ending a transaction;"
msgstr "заканчивает транзакцию;"

msgid ""
"the final line is a replacement for the loop in ``read.c`` -- instead of "
"getting each field and printing it, use the ``box_return_tuple(...)`` "
"function to return the entire tuple to the caller and let the caller "
"display it."
msgstr ""
"последняя строка заменяет цикл ``read.c`` -- вместо получения и вывода "
"каждого поля, использует функцию ``box_return_tuple(...)`` для возврата "
"всего кортежа вызывающему клиенту, чтобы вывести его на экран."

msgid "The result of ``capi_connection:call('write')`` should look like this:"
msgstr "В результате вызова ``capi_connection:call('write')`` должны получить:"

msgid ""
"tarantool> capi_connection:call('write')\n"
"---\n"
"- [[1, 22]]\n"
"..."
msgstr ""
"tarantool> capi_connection:call('write')\n"
"---\n"
"- [[1, 22]]\n"
"..."

msgid ""
"This proves that the ``write()`` function succeeded. Once again the "
"important functions that start with `box` -- :ref:`box_txn_begin() <txn-"
"box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` and "
":ref:`box_return_tuple() <box-box_return_tuple>` -- came from the :ref:`C"
" API <index-c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``write()`` была успешно выполнена. И снова "
"важные функции, которые начинаются с `box` -- :ref:`box_txn_begin() <txn-"
"box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` и "
":ref:`box_return_tuple() <box-box_return_tuple>` -- пришли из :ref:`API "
"для языка C <index-c_api_reference>`."

msgid ""
"Conclusion: the long description of the whole C API is there for a good "
"reason. All of the functions in it can be called from C functions which "
"are called from Lua. So C \"stored procedures\" have full access to the "
"database."
msgstr ""
"Вывод: длинное описание всего API для языка C необходимо в силу весомых "
"причин. Все функции можно вызвать из C-функций, которые вызываются из "
"Lua. Таким образом, хранимые процедуры на языке C получают полный доступ "
"к базе данных."

msgid "**Cleaning up**"
msgstr "**Очистка данных**"

msgid ""
"Get rid of each of the function tuples with "
":doc:`/reference/reference_lua/box_schema/func_drop`."
msgstr ""
"Удалите все кортежи с функцией с помощью "
":doc:`/reference/reference_lua/box_schema/func_drop`."

msgid ""
"Get rid of the ``capi_test`` space with :ref:`box.schema.capi_test:drop()"
" <box_space-drop>`."
msgstr ""
"Удалите спейс ``capi_test`` с помощью :ref:`box.schema.capi_test:drop() "
"<box_space-drop>`."

msgid "Remove the ``.c`` and ``.so`` files that were created for this tutorial."
msgstr ""
"Удалите файлы с разрешением ``.c`` и ``.so``, созданные для данного "
"практического задания."

msgid "**An example in the test suite**"
msgstr "**Пример из набора тестов**"

msgid ""
"Download the source code of Tarantool. Look in a subdirectory "
":code:`test/box`. Notice that there is a file named "
":code:`tuple_bench.test.lua` and another file named "
":code:`tuple_bench.c`. Examine the Lua file and observe that it is "
"calling a function in the C file, using the same techniques that this "
"tutorial has shown."
msgstr ""
"Скачайте исходный код Tarantool'а. Откройте поддиректорию "
":code:`test/box`. Проверьте наличие файла под названием "
":code:`tuple_bench.test.lua` и еще одного файла под названием "
":code:`tuple_bench.c`. Изучите Lua-файл на предмет вызова функции в "
"C-файле с использованием методов, описанных в данном практическом "
"задании."

msgid ""
"Conclusion: parts of the standard test suite use C stored procedures, and"
" they must work, because releases don't happen if Tarantool doesn't pass "
"the tests."
msgstr ""
"Вывод: некоторые тесты из стандартного набора используют хранимые "
"процедуры на языке C, а они должны работать, поскольку мы не можем "
"выпустить Tarantool, если он не прошел тестирование."

#~ msgid ""
#~ "At this point the ``harder()`` function"
#~ " will start using functions defined "
#~ "in `msgpuck.h <http://rtsisyk.github.io/msgpuck>`_. "
#~ "The routines that begin with \"mp\" "
#~ "are msgpuck functions that handle data"
#~ " formatted according to the MsgPack_ "
#~ "specification. Passes and returns are "
#~ "always done with this format so "
#~ "one must become acquainted with msgpuck"
#~ " to become proficient with the C "
#~ "API."
#~ msgstr ""
#~ "На данный момент функция ``harder()`` "
#~ "начнет использовать функции, определенные в"
#~ " `msgpuck.h <http://rtsisyk.github.io/msgpuck>`_. "
#~ "Процедуры, которые начинаются с \"mp\" "
#~ "-- это функции msgpuck, которые "
#~ "обрабатывают данные в формате MsgPack_. "
#~ "Передача и возврат всегда осуществляются "
#~ "в этом формате, поэтому следует "
#~ "ознакомиться с msgpuck для того, чтобы"
#~ " овладеть навыками работы с API для"
#~ " языка C."
