
msgid "`libslave` tutorial"
msgstr "Практические задания по `libslave`"

msgid ""
"``libslave`` is a C++ library for reading data changes done by MysQL and, "
"optionally, writing them to a Tarantool database. It works by acting as a "
"replication slave. The MySQL server writes data-change information to a "
"\"binary log\", and transfers the information to any client that says \"I "
"want to see the information starting with this file and this record, "
"continuously\". So, ``libslave`` is primarily good for making a Tarantool "
"database replica (much faster than using a conventional MySQL slave server),"
" and for keeping track of data changes so they can be searched."
msgstr ""
"``libslave`` представляет собой библиотеку C++ для считывания изменений "
"данных, внесенных с помощью MySQL, а также -- опционально -- для записи их в"
" базу данных Tarantool. Она выступает в качестве ведомого в схеме "
"репликации. Сервер MySQL записывает информацию об изменении данных в "
"бинарный журнал и передает ее на любой клиент, который запрашивает: \"Хочу "
"увидеть всю информацию, начиная с этого файла и этой записи, "
"безостановочно\". Таким образом, библиотека ``libslave``, прежде всего, "
"используется для создания реплик базы данных Tarantool (намного быстрее, "
"чем используя традиционный ведомый сервер MySQL) и для отслеживания "
"изменений данных, чтобы они были пригодны для поиска."

msgid ""
"We will not go into the many details here -- the `API documentation "
"<https://github.com/vozbu/libslave/wiki/API>`_ has them. We will only show "
"an exercise: a minimal program that uses the library."
msgstr ""
"Здесь мы не будем подробно рассматривать библиотеку -- информация есть в "
"`документации по API <https://github.com/vozbu/libslave/wiki/API>`_. Мы лишь"
" дадим упражнение: минимальная программа с использованием библиотеки."

msgid "Use a test machine. Do not use a production machine."
msgstr "Используйте тестовый сервер. Не используйте боевой сервер."

msgid "STEP 1: Make sure you have:"
msgstr "ШАГ 1: Убедитесь в наличии следующего:"

msgid "a recent version of Linux (versions such as Ubuntu 14.04 will not do),"
msgstr "последняя версия Linux (например, Ubuntu версии 14.04 не подойдет),"

msgid ""
"a recent version of MySQL 5.6 or MySQL 5.7 server (MariaDB will not do),"
msgstr "сервер MySQL версии 5.6 или 5.7 (MariaDB не подойдет),"

msgid ""
"MySQL client development package. For example, on Ubuntu you can download it"
" with this command:"
msgstr ""
"пакет программ для разработки клиента MySQL. Например, на Ubuntu можно "
"загрузить его с помощью следующей команды:"

msgid "$ sudo apt-get install mysql-client-core-5.7"
msgstr "$ sudo apt-get install mysql-client-core-5.7"

msgid "STEP 2: Download ``libslave``."
msgstr "ШАГ 2: Установите ``libslave``."

msgid ""
"The recommended source is https://github.com/tarantool/libslave/. Downloads "
"include the source code only."
msgstr ""
"Рекомендуется источник по ссылке https://github.com/tarantool/libslave/. "
"Загрузки включают в себя только исходный код."

msgid ""
"$ sudo apt-get install libboost-all-dev\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"$ cd tarantool-libslave\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make"
msgstr ""
"$ sudo apt-get install libboost-all-dev\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"$ cd tarantool-libslave\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make"

msgid ""
"If you see an error message mentioning the word \"vector\", edit ``field.h``"
" and add this line:"
msgstr ""
"Если система выдаст сообщение с ошибкой со словом \"vector\", отредактируйте"
" ``field.h``, добавив следующую строку:"

msgid "#include <vector>"
msgstr "#include <vector>"

msgid ""
"STEP 3: Start the MySQL server. On the command line, add appropriate "
"switches for doing replication. For example:"
msgstr ""
"ШАГ 3: Запустите сервер MySQL. В командной строке добавьте соответствующие "
"коммутаторы для выполнения репликации. Например:"

msgid "$ mysqld --log-bin=mysql-bin --server-id=1"
msgstr "$ mysqld --log-bin=mysql-bin --server-id=1"

msgid "STEP 4: For purposes of this exercise, we are assuming you have:"
msgstr "ШАГ 4: Для целей данного упражнения, предполагаем, что у вас есть:"

msgid "a \"root\" user with password \"root\" with privileges,"
msgstr "пользователь \"root\" с паролем \"root\" с правами,"

msgid "a \"test\" database with a table named \"test\","
msgstr "тестовая база данных \"test\" с тестовой таблицей под названием \"test\","

msgid "a binary log named \"mysql-bin\","
msgstr "бинарный журнал под названием \"mysql-bin\","

msgid "a server with server id = 1."
msgstr "сервер с идентификатором 1."

msgid ""
"The values are hard-coded in the program, though of course you can change "
"the program -- it's easy to see their settings."
msgstr ""
"Значения заданы в программе, хотя программу, конечно, можно изменить -- "
"посмотреть настройки несложно."

msgid "STEP 5: Look at the program:"
msgstr "ШАГ 5: Обратите внимание на программу:"

msgid ""
"#include <unistd.h>\n"
"#include <iostream>\n"
"#include <sstream>\n"
"#include \"Slave.h\"\n"
"#include \"DefaultExtState.h\"\n"
"\n"
"slave::Slave* sl = NULL;\n"
"\n"
"void callback(const slave::RecordSet& event) {\n"
"    slave::Position sBinlogPos = sl->getLastBinlogPos();\n"
"    switch (event.type_event) {\n"
"    case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; break;\n"
"    default: break;\n"
"    }\n"
"}\n"
"\n"
"bool isStopping()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"    slave::MasterInfo masterinfo;\n"
"    slave::Position position(\"mysql-bin\", 0);\n"
"    masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"    masterinfo.conn_options.mysql_port = 3306;\n"
"    masterinfo.conn_options.mysql_user = \"root\";\n"
"    masterinfo.conn_options.mysql_pass = \"root\";\n"
"    bool error = false;\n"
"    try {\n"
"        slave::DefaultExtState sDefExtState;\n"
"        slave::Slave slave(masterinfo, sDefExtState);\n"
"        sl = &slave;\n"
"        sDefExtState.setMasterPosition(position);\n"
"        slave.setCallback(\"test\", \"test\", callback);\n"
"        slave.init();\n"
"        slave.createDatabaseStructure();\n"
"        try {\n"
"            slave.get_remote_binlog(isStopping);\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"    } catch (std::exception& ex) {\n"
"        std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"        error = true;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"#include <unistd.h>\n"
"#include <iostream>\n"
"#include <sstream>\n"
"#include \"Slave.h\"\n"
"#include \"DefaultExtState.h\"\n"
"\n"
"slave::Slave* sl = NULL;\n"
"\n"
"void callback(const slave::RecordSet& event) {\n"
"    slave::Position sBinlogPos = sl->getLastBinlogPos();\n"
"    switch (event.type_event) {\n"
"    case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; break;\n"
"    default: break;\n"
"    }\n"
"}\n"
"\n"
"bool isStopping()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"    slave::MasterInfo masterinfo;\n"
"    slave::Position position(\"mysql-bin\", 0);\n"
"    masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"    masterinfo.conn_options.mysql_port = 3306;\n"
"    masterinfo.conn_options.mysql_user = \"root\";\n"
"    masterinfo.conn_options.mysql_pass = \"root\";\n"
"    bool error = false;\n"
"    try {\n"
"        slave::DefaultExtState sDefExtState;\n"
"        slave::Slave slave(masterinfo, sDefExtState);\n"
"        sl = &slave;\n"
"        sDefExtState.setMasterPosition(position);\n"
"        slave.setCallback(\"test\", \"test\", callback);\n"
"        slave.init();\n"
"        slave.createDatabaseStructure();\n"
"        try {\n"
"            slave.get_remote_binlog(isStopping);\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"    } catch (std::exception& ex) {\n"
"        std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"        error = true;\n"
"    }\n"
"    return 0;\n"
"}"

msgid ""
"Everything unnecessary has been stripped so that you can see quickly how it "
"works. At the start of ``main()``, there are some settings used for "
"connecting -- host, port, user, password. Then there is an initialization "
"call with the binary log file name = \"mysql-bin\". Pay particular attention"
" to the ``setCallback`` statement, which passes database name = \"test\", "
"table name = \"test\", and callback function address = callback. The program"
" will be looping and invoking this callback function. See how, earlier in "
"the program, the callback function prints \"UPDATE\" or \"DELETE\" or "
"\"INSERT\" depending on what is passed to it."
msgstr ""
"Всё лишнее почистили, чтобы можно было ясно увидеть, как это работает. В "
"начале функции ``main()`` есть некоторые настройки, используемые для "
"установки соединения -- хост, порт, пользователь, пароль. Затем есть вызов "
"инициализации с именем файла бинарного журнала = \"mysql-bin\". Обратите "
"особое внимание на оператор ``setCallback``, который передает имя базы "
"данных = \"test\", имя таблицы = \"test\" и адрес функции обратного вызова ="
" callback. Программа войдет в цикл и будет вызывать эту функцию обратного "
"вызова. Посмотрите, как на ранних этапах программы функция обратного вызова "
"выводит \"UPDATE\", \"DELETE\" или \"INSERT\" в зависимости от переданных "
"данных."

msgid ""
"STEP 5: Put the program in the ``tarantool-libslave`` directory and name it "
"``example.cpp``."
msgstr ""
"ШАГ 5: Поместите программу в директорию ``tarantool-libslave`` и назовите ее"
" ``example.cpp``."

msgid "Step 6: Compile and build:"
msgstr "ШАГ 6: Выполните компиляцию и сборку:"

msgid ""
"$ g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a -ldl"
" -lpthread"
msgstr ""
"$ g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a -ldl"
" -lpthread"

msgid "Replace ``tarantool-libslave/include`` with the full directory name."
msgstr "Замените ``tarantool-libslave/include`` на полное имя директории."

msgid ""
"Notice that the name of the static library is ``libslave_a.a``, not "
"``libslave.a``."
msgstr ""
"Обратите внимание, что имя статической библиотеки -- ``libslave_a.a``, а не "
"``libslave.a``."

msgid "Step 7: Run:"
msgstr "ШАГ 7: Выполните:"

msgid "$ ./example"
msgstr "$ ./example"

msgid ""
"The result will be nothing -- the program is looping, waiting for the MySQL "
"server to write to the replication binary log."
msgstr ""
"Результат нет -- программа в цикле ожидает, пока сервер MySQL запишет данные"
" в бинарный журнал репликации."

msgid ""
"Step 8: Start a MySQL client program -- any client program will do. Enter "
"these statements:"
msgstr ""
"ШАГ 8: Запустите клиентскую программу MySQL -- подойдет любая клиентская "
"программа. Введите следующие операторы:"

msgid ""
"USE test\n"
"INSERT INTO test VALUES ('A');\n"
"INSERT INTO test VALUES ('B');\n"
"DELETE FROM test;"
msgstr ""
"USE test\n"
"INSERT INTO test VALUES ('A');\n"
"INSERT INTO test VALUES ('B');\n"
"DELETE FROM test;"

msgid "Watch what happens in ``example.cpp`` output -- it displays:"
msgstr ""
"Проверьте, что происходит в выводе программы ``example.cpp`` -- отображается"
" следующее:"

msgid ""
"INSERT\n"
"INSERT\n"
"DELETE\n"
"DELETE"
msgstr ""
"INSERT\n"
"INSERT\n"
"DELETE\n"
"DELETE"

msgid ""
"This is row-based replication, so you see two DELETEs, because there are two"
" rows."
msgstr ""
"Репликация является построчной, поэтому видим DELETE два раза -- потому что "
"есть две строки."

msgid "What the exercise has shown is:"
msgstr "В результате выполнения упражнения видим:"

msgid "the library can be built, and"
msgstr "можно собрать библиотеку, а "

msgid ""
"programs that use the library can access everything that the MySQL server "
"dumps."
msgstr ""
"программы, которые используют библиотеку, могут получить доступ ко всему, "
"что сохраняет сервер MySQL."

msgid "For the many details and examples of usage in the field, see:"
msgstr "Более подробную информацию и примеры использования см. ниже:"

msgid "Our downloadable ``libslave`` version:"
msgstr "Загрузить нашу версию ``libslave`` можно по ссылке:"

msgid "https://github.com/tarantool/libslave"
msgstr "https://github.com/tarantool/libslave"

msgid "The version it was forked from (with a different README):"
msgstr "Ответвление сделано из версии по ссылке (с другим файлом README):"

msgid "https://github.com/vozbu/libslave/wiki/API"
msgstr "https://github.com/vozbu/libslave/wiki/API"

msgid ""
"`How to speed up your MySQL with replication to in-memory database "
"<http://highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-with-"
"replication-to-in-memory-dat.html>`_ article"
msgstr ""
"Статья `How to speed up your MySQL with replication to in-memory database "
"<http://highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-with-"
"replication-to-in-memory-dat.html>`_ (на английском)"

msgid ""
"`Replicating data from MySQL to Tarantool "
"<https://habrahabr.ru/company/mailru/blog/323870/>`_ article (in Russian)"
msgstr ""
"Статья `Репликация из MySQL в Tarantool "
"<https://habrahabr.ru/company/mailru/blog/323870/>`_"

msgid ""
"`Asynchronous replication uncensored <https://habrahabr.ru/company/oleg-"
"bunin/blog/313594/>`_ article (in Russian)"
msgstr ""
"Статья `Асинхронная репликация без цензуры "
"<https://habrahabr.ru/company/oleg-bunin/blog/313594/>`_"
