# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 2.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-23 10:32+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../doc/tutorials/c_tutorial.rst:3
msgid "C tutorial"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:5
msgid "Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-c_stored_procedures>`."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:12
msgid "C stored procedures"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:14
msgid "Tarantool can call C code with :ref:`modules <app_server-modules>`, or with :ref:`ffi <cookbook-ffi_printf>`, or with C stored procedures. This tutorial only is about the third option, C stored procedures. In fact the routines are always \"C functions\" but the phrase \"stored procedure\" is commonly used for historical reasons."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:21
msgid "In this tutorial, which can be followed by anyone with a Tarantool development package and a C compiler, there are five tasks:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:24
msgid ":ref:`easy.c <f_c_tutorial-easy>` -- prints \"hello world\";"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:25
msgid ":ref:`harder.c <f_c_tutorial-harder>` -- decodes a passed parameter value;"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:26
msgid ":ref:`hardest.c <f_c_tutorial-hardest>` -- uses the C API to do a DBMS insert;"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:27
msgid ":ref:`read.c <f_c_tutorial-read>` -- uses the C API to do a DBMS select;"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:28
msgid ":ref:`write.c <f_c_tutorial-write>` -- uses the C API to do a DBMS replace."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:30
msgid "After following the instructions, and seeing that the results are what is described here, users should feel confident about writing their own stored procedures."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:34
msgid "**Preparation**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:36
msgid "Check that these items exist on the computer:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:38
msgid "Tarantool 2.1"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:39
msgid "A gcc compiler, any modern version should work"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:40
msgid "``module.h`` and files #included in it"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:41
msgid "``msgpuck.h``"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:42
msgid "``libmsgpuck.a`` (only for some recent msgpuck versions)"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:44
msgid "The ``module.h`` file will exist if Tarantool was installed from source. Otherwise Tarantool's \"developer\" package must be installed. For example on Ubuntu say:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:48
msgid "$ sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:52
msgid "or on Fedora say:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:54
msgid "$ dnf -y install tarantool-devel"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:58
msgid "The ``msgpuck.h`` file will exist if Tarantool was installed from source. Otherwise the \"msgpuck\" package must be installed from `https://github.com/rtsisyk/msgpuck <https://github.com/rtsisyk/msgpuck>`_."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:62
msgid "Both ``module.h`` and ``msgpuck.h`` must be on the include path for the C compiler to see them. For example, if ``module.h`` address is ``/usr/local/include/tarantool/module.h``, and ``msgpuck.h`` address is ``/usr/local/include/msgpuck/msgpuck.h``, and they are not currently on the include path, say:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:68
msgid "$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:72
msgid "The ``libmsgpuck.a`` static library is necessary with msgpuck versions produced after February 2017. If and only if you encounter linking problems when using the gcc statements in the examples for this tutorial, you should put ``libmsgpuck.a`` on the path (``libmsgpuck.a`` is produced from both msgpuck and Tarantool source downloads so it should be easy to find). For example, instead of \":code:`gcc -shared -o harder.so -fPIC harder.c`\" for the second example below, you will need to say \":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:81
msgid "Requests will be done using Tarantool as a :ref:`client <admin-using_tarantool_as_a_client>`. Start Tarantool, and enter these requests."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:85
msgid "box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:93
msgid "In plainer language: create a space named ``capi_test``, and make a connection to self named ``capi_connection``."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:96
msgid "Leave the client running. It will be necessary to enter more requests later."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:100
msgid "**easy.c**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:102
msgid "Start another shell. Change directory (``cd``) so that it is the same as the directory that the client is running on."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:105
msgid "Create a file. Name it ``easy.c``. Put these six lines in it."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:107
msgid "#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}\n"
"int easy2(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world -- easy2\\n\");\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:122
msgid "Compile the program, producing a library file named ``easy.so``:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:124
msgid "$ gcc -shared -o easy.so -fPIC easy.c"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:128
#: ../doc/tutorials/c_tutorial.rst:216
#: ../doc/tutorials/c_tutorial.rst:303
#: ../doc/tutorials/c_tutorial.rst:407
#: ../doc/tutorials/c_tutorial.rst:488
msgid "Now go back to the client and execute these requests:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:130
msgid "box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:136
msgid "If these requests appear unfamiliar, re-read the descriptions of :ref:`box.schema.func.create() <box_schema-func_create>`, :ref:`box.schema.user.grant() <box_schema-user_grant>` and :ref:`conn:call() <net_box-call>`."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:142
msgid "The function that matters is ``capi_connection:call('easy')``."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:144
msgid "Its first job is to find the 'easy' function, which should be easy because by default Tarantool looks on the current directory for a file named ``easy.so``."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:148
msgid "Its second job is to call the 'easy' function. Since the ``easy()`` function in ``easy.c`` begins with ``printf(\"hello world\\n\")``, the words \"hello world\" will appear on the screen."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:152
msgid "Its third job is to check that the call was successful. Since the ``easy()`` function in ``easy.c`` ends with :code:`return 0`, there is no error message to display and the request is over."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:156
#: ../doc/tutorials/c_tutorial.rst:332
msgid "The result should look like this:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:158
msgid "tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:166
msgid "Now let's call the other function in easy.c -- ``easy2()``. This is almost the same as the ``easy()`` function, but there's a detail: when the file name is not the same as the function name, then we have to specify :samp:`{file-name}.{function-name}`."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:172
msgid "box.schema.func.create('easy.easy2', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"capi_connection:call('easy.easy2')"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:178
msgid "... and this time the result will be \"hello world -- easy2\"."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:180
msgid "Conclusion: calling a C function is easy."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:184
msgid "**harder.c**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:186
msgid "Go back to the shell where the ``easy.c`` program was created."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:188
msgid "Create a file. Name it ``harder.c``. Put these 17 lines in it:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:190
msgid "#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:210
msgid "Compile the program, producing a library file named ``harder.so``:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:212
msgid "$ gcc -shared -o harder.so -fPIC harder.c"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:218
msgid "box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:228
msgid "This time the call is passing a Lua table (``passable_table``) to the ``harder()`` function. The ``harder()`` function will see it, it's in the :code:`char *args` parameter."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:232
msgid "At this point the ``harder()`` function will start using functions defined in `msgpuck.h <http://rtsisyk.github.io/msgpuck>`_. The routines that begin with \"mp\" are msgpuck functions that handle data formatted according to the MsgPack_ specification. Passes and returns are always done with this format so one must become acquainted with msgpuck to become proficient with the C API."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:240
msgid "For now, though, it's enough to know that ``mp_decode_array()`` returns the number of elements in an array, and ``mp_decode_uint`` returns an unsigned integer, from :code:`args`. And there's a side effect: when the decoding finishes, :code:`args` has changed and is now pointing to the next element."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:246
msgid "Therefore the first displayed line will be \"arg_count = 1\" because there was only one item passed: ``passable_table``. |br| The second displayed line will be \"field_count = 3\" because there are three items in the table. |br| The next three lines will be \"1\" and \"2\" and \"3\" because those are the values in the items in the table."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:253
msgid "And now the screen looks like this:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:255
msgid "tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:267
msgid "Conclusion: decoding parameter values passed to a C function is not easy at first, but there are routines to do the job, and they're documented, and there aren't very many of them."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:274
msgid "**hardest.c**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:276
msgid "Go back to the shell where the ``easy.c`` and the ``harder.c`` programs were created."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:279
msgid "Create a file. Name it ``hardest.c``. Put these 13 lines in it:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:281
msgid "#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"  char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:297
msgid "Compile the program, producing a library file named ``hardest.so``:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:299
msgid "$ gcc -shared -o hardest.so -fPIC hardest.c"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:305
msgid "box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:312
msgid "This time the C function is doing three things:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:314
msgid "finding the numeric identifier of the ``capi_test`` space by calling ``box_space_id_by_name()``;"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:316
msgid "formatting a tuple using more ``msgpuck.h`` functions;"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:317
msgid "inserting a tuple using ``box_insert()``."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:321
msgid "``char tuple[1024];`` is used here as just a quick way of saying \"allocate more than enough bytes\". For serious programs the developer must be careful to allow enough space for all the bytes that the ``mp_encode`` routines will use up."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:326
msgid "Now, still on the client, execute this request:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:328
msgid "box.space.capi_test:select()"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:334
msgid "tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:341
msgid "This proves that the ``hardest()`` function succeeded, but where did :ref:`box_space_id_by_name() <box-box_space_id_by_name>` and :ref:`box_insert() <box-box_insert>` come from? Answer: the :ref:`C API <index-c_api_reference>`."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:348
msgid "**read.c**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:350
msgid "Go back to the shell where the ``easy.c`` and the ``harder.c`` and the ``hardest.c`` programs were created."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:353
msgid "Create a file. Name it ``read.c``. Put these 43 lines in it:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:355
msgid "#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  char tuple_buf[1024];      /* where the raw MsgPack tuple will be stored */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* The number of the space's first index */\n"
"  uint32_t key = 10000;      /* The key value that box_insert() used */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* Pass key_buf = encoded key = 1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Get the tuple. There's no box_select() but there's this. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Get each field of the tuple + display what you get. */\n"
"  int field_no;             /* The first field number is 0. */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* if (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:401
msgid "Compile the program, producing a library file named ``read.so``:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:403
msgid "$ gcc -shared -o read.so -fPIC read.c"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:409
msgid "box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:416
msgid "This time the C function is doing four things:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:418
#: ../doc/tutorials/c_tutorial.rst:499
msgid "once again, finding the numeric identifier of the ``capi_test`` space by calling ``box_space_id_by_name()``;"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:420
msgid "formatting a search key = 10000 using more ``msgpuck.h`` functions;"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:421
msgid "getting a tuple using ``box_index_get()``;"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:422
msgid "going through the tuple's fields with ``box_tuple_get()`` and then decoding each field depending on its type. In this case, since what we are getting is the tuple that we inserted with ``hardest.c``, we know in advance that the type is either MP_UINT or MP_STR; however, it's very common to have a case statement here with one option for each possible type."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:429
msgid "The result of ``capi_connection:call('read')`` should look like this:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:431
msgid "tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:440
msgid "This proves that the ``read()`` function succeeded. Once again the important functions that start with `box` -- :ref:`box_index_get() <c_api-box_index-box_index_get>` and :ref:`box_tuple_field() <c_api-tuple-box_tuple_field>` -- came from the :ref:`C API <index-c_api_reference>`."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:448
msgid "**write.c**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:450
msgid "Go back to the shell where the programs ``easy.c``, ``harder.c``, ``hardest.c`` and ``read.c`` were created."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:453
msgid "Create a file. Name it ``write.c``. Put these 24 lines in it:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:455
msgid "#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int write(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  static const char *space = \"capi_test\";\n"
"  char tuple_buf[1024]; /* Must be big enough for mp_encode results */\n"
"  uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"  if (space_id == BOX_ID_NIL) {\n"
"    return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"    \"Can't find space %s\", \"capi_test\");\n"
"  }\n"
"  char *tuple_end = tuple_buf;\n"
"  tuple_end = mp_encode_array(tuple_end, 2);\n"
"  tuple_end = mp_encode_uint(tuple_end, 1);\n"
"  tuple_end = mp_encode_uint(tuple_end, 22);\n"
"  box_txn_begin();\n"
"  if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"    return -1;\n"
"  box_txn_commit();\n"
"  fiber_sleep(0.001);\n"
"  struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                      tuple_buf, tuple_end);\n"
"  return box_return_tuple(ctx, tuple);\n"
"}"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:482
msgid "Compile the program, producing a library file named ``write.so``:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:484
msgid "$ gcc -shared -o write.so -fPIC write.c"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:490
msgid "box.schema.func.create('write', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('write')"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:497
msgid "This time the C function is doing six things:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:501
msgid "making a new tuple;"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:502
msgid "starting a transaction;"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:503
msgid "replacing a tuple in ``box.space.capi_test``"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:504
msgid "ending a transaction;"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:505
msgid "the final line is a replacement for the loop in ``read.c`` -- instead of getting each field and printing it, use the ``box_return_tuple(...)`` function to return the entire tuple to the caller and let the caller display it."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:510
msgid "The result of ``capi_connection:call('write')`` should look like this:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:512
msgid "tarantool> capi_connection:call('write')\n"
"---\n"
"- [[1, 22]]\n"
"..."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:519
msgid "This proves that the ``write()`` function succeeded. Once again the important functions that start with `box` -- :ref:`box_txn_begin() <txn-box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` and :ref:`box_return_tuple() <box-box_return_tuple>` -- came from the :ref:`C API <index-c_api_reference>`."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:526
msgid "Conclusion: the long description of the whole C API is there for a good reason. All of the functions in it can be called from C functions which are called from Lua. So C \"stored procedures\" have full access to the database."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:532
msgid "**Cleaning up**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:534
msgid "Get rid of each of the function tuples with :ref:`box.schema.func.drop <box_schema-func_drop>`."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:536
msgid "Get rid of the ``capi_test`` space with :ref:`box.schema.capi_test:drop() <box_space-drop>`."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:538
msgid "Remove the ``.c`` and ``.so`` files that were created for this tutorial."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:541
msgid "**An example in the test suite**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:543
msgid "Download the source code of Tarantool. Look in a subdirectory :code:`test/box`. Notice that there is a file named :code:`tuple_bench.test.lua` and another file named :code:`tuple_bench.c`. Examine the Lua file and observe that it is calling a function in the C file, using the same techniques that this tutorial has shown."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:550
msgid "Conclusion: parts of the standard test suite use C stored procedures, and they must work, because releases don't happen if Tarantool doesn't pass the tests."
msgstr ""

#: ../doc/tutorials/index.rst:5
msgid "Tutorials"
msgstr ""

#: ../doc/tutorials/libslave.rst:5
msgid "`libslave` tutorial"
msgstr ""

#: ../doc/tutorials/libslave.rst:7
msgid "``libslave`` is a C++ library for reading data changes done by MysQL and, optionally, writing them to a Tarantool database. It works by acting as a replication slave. The MySQL server writes data-change information to a \"binary log\", and transfers the information to any client that says \"I want to see the information starting with this file and this record, continuously\". So, ``libslave`` is primarily good for making a Tarantool database replica (much faster than using a conventional MySQL slave server), and for keeping track of data changes so they can be searched."
msgstr ""

#: ../doc/tutorials/libslave.rst:18
msgid "We will not go into the many details here -- the `API documentation <https://github.com/vozbu/libslave/wiki/API>`_ has them. We will only show an exercise: a minimal program that uses the library."
msgstr ""

#: ../doc/tutorials/libslave.rst:24
msgid "Use a test machine. Do not use a production machine."
msgstr ""

#: ../doc/tutorials/libslave.rst:26
msgid "STEP 1: Make sure you have:"
msgstr ""

#: ../doc/tutorials/libslave.rst:28
msgid "a recent version of Linux (versions such as Ubuntu 14.04 will not do),"
msgstr ""

#: ../doc/tutorials/libslave.rst:29
msgid "a recent version of MySQL 5.6 or MySQL 5.7 server (MariaDB will not do),"
msgstr ""

#: ../doc/tutorials/libslave.rst:30
msgid "MySQL client development package. For example, on Ubuntu you can download it with this command:"
msgstr ""

#: ../doc/tutorials/libslave.rst:33
msgid "$ sudo apt-get install mysql-client-core-5.7"
msgstr ""

#: ../doc/tutorials/libslave.rst:37
msgid "STEP 2: Download ``libslave``."
msgstr ""

#: ../doc/tutorials/libslave.rst:39
msgid "The recommended source is https://github.com/tarantool/libslave/. Downloads include the source code only."
msgstr ""

#: ../doc/tutorials/libslave.rst:42
msgid "$ sudo apt-get install libboost-all-dev\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"$ cd tarantool-libslave\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make"
msgstr ""

#: ../doc/tutorials/libslave.rst:53
msgid "If you see an error message mentioning the word \"vector\", edit ``field.h`` and add this line:"
msgstr ""

#: ../doc/tutorials/libslave.rst:56
msgid "#include <vector>"
msgstr ""

#: ../doc/tutorials/libslave.rst:60
msgid "STEP 3: Start the MySQL server. On the command line, add appropriate switches for doing replication. For example:"
msgstr ""

#: ../doc/tutorials/libslave.rst:63
msgid "$ mysqld --log-bin=mysql-bin --server-id=1"
msgstr ""

#: ../doc/tutorials/libslave.rst:67
msgid "STEP 4: For purposes of this exercise, we are assuming you have:"
msgstr ""

#: ../doc/tutorials/libslave.rst:69
msgid "a \"root\" user with password \"root\" with privileges,"
msgstr ""

#: ../doc/tutorials/libslave.rst:70
msgid "a \"test\" database with a table named \"test\","
msgstr ""

#: ../doc/tutorials/libslave.rst:71
msgid "a binary log named \"mysql-bin\","
msgstr ""

#: ../doc/tutorials/libslave.rst:72
msgid "a server with server id = 1."
msgstr ""

#: ../doc/tutorials/libslave.rst:74
msgid "The values are hard-coded in the program, though of course you can change the program -- it's easy to see their settings."
msgstr ""

#: ../doc/tutorials/libslave.rst:77
msgid "STEP 5: Look at the program:"
msgstr ""

#: ../doc/tutorials/libslave.rst:79
msgid "#include <unistd.h>\n"
"#include <iostream>\n"
"#include <sstream>\n"
"#include \"Slave.h\"\n"
"#include \"DefaultExtState.h\"\n"
"\n"
"slave::Slave* sl = NULL;\n"
"\n"
"void callback(const slave::RecordSet& event) {\n"
"    slave::Slave::binlog_pos_t sBinlogPos = sl->getLastBinlog();\n"
"    switch (event.type_event) {\n"
"    case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; break;\n"
"    default: break;\n"
"    }\n"
"}\n"
"\n"
"bool isStopping()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"    slave::MasterInfo masterinfo;\n"
"    masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"    masterinfo.conn_options.mysql_port = 3306;\n"
"    masterinfo.conn_options.mysql_user = \"root\";\n"
"    masterinfo.conn_options.mysql_pass = \"root\";\n"
"    bool error = false;\n"
"    try {\n"
"        slave::DefaultExtState sDefExtState;\n"
"        slave::Slave slave(masterinfo, sDefExtState);\n"
"        sl = &slave;\n"
"        sDefExtState.setMasterLogNamePos(\"mysql-bin\", 0);\n"
"        slave.setCallback(\"test\", \"test\", callback);\n"
"        slave.init();\n"
"        slave.createDatabaseStructure();\n"
"        try {\n"
"            slave.get_remote_binlog(isStopping);\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"    } catch (std::exception& ex) {\n"
"        std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"        error = true;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""

#: ../doc/tutorials/libslave.rst:133
msgid "Everything unnecessary has been stripped so that you can see quickly how it works. At the start of ``main()``, there are some settings used for connecting -- host, port, user, password. Then there is an initialization call with the binary log file name = \"mysql-bin\". Pay particular attention to the ``setCallback`` statement, which passes database name = \"test\", table name = \"test\", and callback function address = callback. The program will be looping and invoking this callback function. See how, earlier in the program, the callback function prints \"UPDATE\" or \"DELETE\" or \"INSERT\" depending on what is passed to it."
msgstr ""

#: ../doc/tutorials/libslave.rst:144
msgid "STEP 5: Put the program in the ``tarantool-libslave`` directory and name it ``example.cpp``."
msgstr ""

#: ../doc/tutorials/libslave.rst:147
msgid "Step 6: Compile and build:"
msgstr ""

#: ../doc/tutorials/libslave.rst:149
msgid "$ g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a -ldl -lpthread"
msgstr ""

#: ../doc/tutorials/libslave.rst:155
msgid "Replace ``tarantool-libslave/include`` with the full directory name."
msgstr ""

#: ../doc/tutorials/libslave.rst:157
msgid "Notice that the name of the static library is ``libslave_a.a``, not ``libslave.a``."
msgstr ""

#: ../doc/tutorials/libslave.rst:160
msgid "Step 7: Run:"
msgstr ""

#: ../doc/tutorials/libslave.rst:162
msgid "$ ./example"
msgstr ""

#: ../doc/tutorials/libslave.rst:166
msgid "The result will be nothing -- the program is looping, waiting for the MySQL server to write to the replication binary log."
msgstr ""

#: ../doc/tutorials/libslave.rst:169
msgid "Step 8: Start a MySQL client program -- any client program will do. Enter these statements:"
msgstr ""

#: ../doc/tutorials/libslave.rst:172
msgid "USE test\n"
"INSERT INTO test VALUES ('A');\n"
"INSERT INTO test VALUES ('B');\n"
"DELETE FROM test;"
msgstr ""

#: ../doc/tutorials/libslave.rst:179
msgid "Watch what happens in ``example.cpp`` output -- it displays:"
msgstr ""

#: ../doc/tutorials/libslave.rst:181
msgid "INSERT\n"
"INSERT\n"
"DELETE\n"
"DELETE"
msgstr ""

#: ../doc/tutorials/libslave.rst:188
msgid "This is row-based replication, so you see two DELETEs, because there are two rows."
msgstr ""

#: ../doc/tutorials/libslave.rst:191
msgid "What the exercise has shown is:"
msgstr ""

#: ../doc/tutorials/libslave.rst:193
msgid "the library can be built, and"
msgstr ""

#: ../doc/tutorials/libslave.rst:194
msgid "programs that use the library can access everything that the MySQL server dumps."
msgstr ""

#: ../doc/tutorials/libslave.rst:197
msgid "For the many details and examples of usage in the field, see:"
msgstr ""

#: ../doc/tutorials/libslave.rst:0
msgid "Our downloadable ``libslave`` version:"
msgstr ""

#: ../doc/tutorials/libslave.rst:0
msgid "https://github.com/tarantool/libslave"
msgstr ""

#: ../doc/tutorials/libslave.rst:0
msgid "The version it was forked from (with a different README):"
msgstr ""

#: ../doc/tutorials/libslave.rst:0
msgid "https://github.com/vozbu/libslave/wiki/API"
msgstr ""

#: ../doc/tutorials/libslave.rst:205
msgid "`How to speed up your MySQL with replication to in-memory database <http://highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-with-replication-to-in-memory-dat.html>`_ article"
msgstr ""

#: ../doc/tutorials/libslave.rst:207
msgid "`Replicating data from MySQL to Tarantool <https://habrahabr.ru/company/mailru/blog/323870/>`_ article (in Russian)"
msgstr ""

#: ../doc/tutorials/libslave.rst:209
msgid "`Asynchronous replication uncensored <https://habrahabr.ru/company/oleg-bunin/blog/313594/>`_ article (in Russian)"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:5
msgid "Lua tutorials"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:7
msgid "Here are three tutorials on using Lua stored procedures with Tarantool:"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:9
msgid ":ref:`Insert one million tuples with a Lua stored procedure <c_lua_tutorial-insert_one_million_tuples>`,"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:10
msgid ":ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>`,"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:11
msgid ":ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>`."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:17
msgid "Insert one million tuples with a Lua stored procedure"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:19
msgid "This is an exercise assignment: “Insert one million tuples. Each tuple should have a constantly-increasing numeric primary-key field and a random alphabetic 10-character string field.”"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:23
msgid "The purpose of the exercise is to show what Lua functions look like inside Tarantool. It will be necessary to employ the Lua math library, the Lua string library, the Tarantool box library, the Tarantool box.tuple library, loops, and concatenations. It should be easy to follow even for a person who has not used either Lua or Tarantool before. The only requirement is a knowledge of how other programming languages work and a memory of the first two chapters of this manual. But for better understanding, follow the comments and the links, which point to the Lua manual or to elsewhere in this Tarantool manual. To further enhance learning, type the statements in with the tarantool client while reading along."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:35
msgid "Configure"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:37
msgid "We are going to use the Tarantool sandbox that was created for our :ref:`\"Getting started\" exercises <getting_started>`. So there is a single space, and a numeric primary key, and a running Tarantool server instance which also serves as a client."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:44
msgid "Delimiter"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:46
msgid "In earlier versions of Tarantool, multi-line functions had to be enclosed within \"delimiters\". They are no longer necessary, and so they will not be used in this tutorial. However, they are still supported. Users who wish to use delimiters, or users of older versions of Tarantool, should check the syntax description for :ref:`declaring a delimiter <console-delimiter>` before proceeding."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:55
msgid "Create a function that returns a string"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:57
msgid "We will start by making a function that returns a fixed string, “Hello world”."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:59
msgid "function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:65
msgid "The word \"``function``\" is a Lua keyword -- we're about to go into Lua. The function name is string_function. The function has one executable statement, ``return \"hello world\"``. The string \"hello world\" is enclosed in double quotes here, although Lua doesn't care -- one could use single quotes instead. The word \"``end``\" means “this is the end of the Lua function declaration.” To confirm that the function works, we can say"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:72
msgid "string_function()"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:76
msgid "Sending ``function-name()`` means “invoke the Lua function.” The effect is that the string which the function returns will end up on the screen."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:79
msgid "For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . For more about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:85
#: ../doc/tutorials/lua_tutorials.rst:129
#: ../doc/tutorials/lua_tutorials.rst:181
#: ../doc/tutorials/lua_tutorials.rst:237
#: ../doc/tutorials/lua_tutorials.rst:283
#: ../doc/tutorials/lua_tutorials.rst:343
#: ../doc/tutorials/lua_tutorials.rst:436
msgid "The screen now looks like this:"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:87
msgid "tarantool> function string_function()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:102
msgid "Create a function that calls another function and sets a variable"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:104
msgid "Now that ``string_function`` exists, we can invoke it from another function."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:107
msgid "function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:115
msgid "We begin by declaring a variable \"``string_value``\". The word \"``local``\" means that string_value appears only in ``main_function``. If we didn't use \"``local``\" then ``string_value`` would be visible everywhere - even by other users using other clients connected to this server instance! Sometimes that's a very desirable feature for inter-client communication, but not this time."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:121
msgid "Then we assign a value to ``string_value``, namely, the result of ``string_function()``. Soon we will invoke ``main_function()`` to check that it got the value."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:125
msgid "For more about Lua variables see Lua manual `chapter 4.2 \"Local Variables and Blocks\"`_ ."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:131
msgid "tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:148
msgid "Modify the function so it returns a one-letter random string"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:150
msgid "Now that it's a bit clearer how to make a variable, we can change ``string_function()`` so that, instead of returning a fixed literal \"Hello world\", it returns a random letter between 'A' and 'Z'."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:154
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:164
msgid "It is not necessary to destroy the old ``string_function()`` contents, they're simply overwritten. The first assignment invokes a random-number function in Lua's math library; the parameters mean “the number must be an integer between 65 and 90.” The second assignment invokes an integer-to-character function in Lua's string library; the parameter is the code point of the character. Luckily the ASCII value of 'A' is 65 and the ASCII value of 'Z' is 90 so the result will always be a letter between A and Z."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:172
msgid "For more about Lua math-library functions see Lua users \"`Math Library Tutorial`_\". For more about Lua string-library functions see Lua users \"`String Library Tutorial`_\" ."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:178
msgid "Once again the ``string_function()`` can be invoked from main_function() which can be invoked with ``main_function()``."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:183
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:200
msgid "... Well, actually it won't always look like this because ``math.random()`` produces random numbers. But for the illustration purposes it won't matter what the random string values are."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:206
msgid "Modify the function so it returns a ten-letter random string"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:208
msgid "Now that it's clear how to produce one-letter random strings, we can reach our goal of producing a ten-letter string by concatenating ten one-letter strings, in a loop."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:212
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:225
msgid "The words \"for x = 1,10,1\" mean “start with x equals 1, loop until x equals 10, increment x by 1 for each iteration.” The symbol \"..\" means \"concatenate\", that is, add the string on the right of the \"..\" sign to the string on the left of the \"..\" sign. Since we start by saying that random_string is \"\" (a blank string), the end result is that random_string has 10 random letters. Once again the ``string_function()`` can be invoked from ``main_function()`` which can be invoked with ``main_function()``."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:233
msgid "For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:239
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:261
msgid "Make a tuple out of a number and a string"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:263
msgid "Now that it's clear how to make a 10-letter random string, it's possible to make a tuple that contains a number and a 10-letter random string, by invoking a function in Tarantool's library of Lua functions."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:267
msgid "function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:276
msgid "Once this is done, t will be the value of a new tuple which has two fields. The first field is numeric: 1. The second field is a random string. Once again the ``string_function()`` can be invoked from ``main_function()`` which can be invoked with  ``main_function()``."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:281
msgid "For more about Tarantool tuples see Tarantool manual section :ref:`Submodule box.tuple <box_tuple>`."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:285
msgid "tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:303
msgid "Modify main_function to insert a tuple into the database"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:305
msgid "Now that it's clear how to make a tuple that contains a number and a 10-letter random string, the only trick remaining is putting that tuple into tester. Remember that tester is the first space that was defined in the sandbox, so it's like a database table."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:310
msgid "function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:319
msgid "The new line here is ``box.space.tester:replace(t)``. The name contains 'tester' because the insertion is going to be to tester. The second parameter is the tuple value. To be perfectly correct we could have said ``box.space.tester:insert(t)`` here, rather than ``box.space.tester:replace(t)``, but \"replace\" means “insert even if there is already a tuple whose primary-key value is a duplicate”, and that makes it easier to re-run the exercise even if the sandbox database isn't empty. Once this is done, tester will contain a tuple with two fields. The first field will be 1. The second field will be a random 10-letter string. Once again the ``string_function(``) can be invoked from ``main_function()`` which can be invoked with ``main_function()``. But ``main_function()`` won't tell the whole story, because it does not return t, it only puts t into the database. To confirm that something got inserted, we'll use a SELECT request."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:333
msgid "main_function()\n"
"box.space.tester:select{1}"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:338
msgid "For more about Tarantool insert and replace calls, see Tarantool manual section :ref:`Submodule box.space <box_space>`, :ref:`space_object:insert() <box_space-insert>`, and :ref:`space_object:replace() <box_space-replace>`."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:345
msgid "tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:366
msgid "Modify main_function to insert a million tuples into the database"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:368
msgid "Now that it's clear how to insert one tuple into the database, it's no big deal to figure out how to scale up: instead of inserting with a literal value = 1 for the primary key, insert with a variable value = between 1 and 1 million, in a loop. Since we already saw how to loop, that's a simple thing. The only extra wrinkle that we add here is a timing function."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:374
msgid "function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:389
msgid "The standard Lua function `os.clock() <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_ will return the number of CPU seconds since the start. Therefore, by getting start_time = number of seconds just before the inserting, and then getting end_time = number of seconds just after the inserting, we can calculate (end_time - start_time) = elapsed time in seconds. We will display that value by putting it in a request without any assignments, which causes Tarantool to send the value to the client, which prints it. (Lua's answer to the C ``printf()`` function, which is ``print()``, will also work.)"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:399
msgid "For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and Time\"`_. For more on Lua print() see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:405
msgid "Since this is the grand finale, we will redo the final versions of all the necessary requests: the request that created ``string_function()``, the request that created ``main_function()``, and the request that invokes ``main_function()``."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:410
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:438
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:477
msgid "What has been shown is that Lua functions are quite expressive (in fact one can do more with Tarantool's Lua stored procedures than one can do with stored procedures in some SQL DBMSs), and that it's straightforward to combine Lua-library functions and Tarantool-library functions."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:482
msgid "What has also been shown is that inserting a million tuples took 37 seconds. The host computer was a Linux laptop. By changing :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` to 'none' before running the test, one can reduce the elapsed time to 4 seconds."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:490
msgid "Sum a JSON field for all tuples"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:492
msgid "This is an exercise assignment: “Assume that inside every tuple there is a string formatted as JSON. Inside that string there is a JSON numeric field. For each tuple, find the numeric field's value and add it to a 'sum' variable. At end, return the 'sum' variable.” The purpose of the exercise is to get experience in one way to read and process tuples."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:498
msgid "json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:515
msgid "**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will be used in the function. Actually it's not necessary to declare all variables at the start, and in a long function it would be better to declare variables just before using them. In fact it's not even necessary to declare variables at all, but an undeclared variable is \"global\". That's not desirable for any of the variables that are declared in line 1, because all of them are for use only within the function."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:522
msgid "**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and there are two ways to do it: with :ref:`box.space.space_object:pairs() <box_space-pairs>` or with ``variable = select(...)`` followed by :samp:`for i, {n}, 1 do {some-function}(variable[i]) end`. We preferred ``pairs()`` for this example."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:527
msgid "**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop will be repeated as long as there is another index key. A tuple is fetched and can be referenced with variable :code:`t`."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:531
msgid "**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = json.decode(t[2]))``, then the function would abort with an error if it encountered something wrong with the JSON string - a missing colon, for example. By putting the function inside \"``pcall``\" (`protected call`_), we're saying: we want to intercept that sort of error, so if there's a problem just set ``is_valid_json = false`` and we will know what to do about it later."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:538
msgid "**LINE 6: MEANING.** The function is :ref:`json.decode <json-decode>` which means decode a JSON string, and the parameter is t[2] which is a reference to a JSON string. There's a bit of hard coding here, we're assuming that the second field in the tuple is where the JSON string was inserted. For example, we're assuming a tuple looks like"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:582
msgid "field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:551
msgid "meaning that the tuple's first field, the primary key field, is a number while the tuple's second field, the JSON string, is a string. Thus the entire statement means \"decode ``t[2]`` (the tuple's second field) as a JSON string; if there's an error set ``is_valid_json = false``; if there's no error set ``is_valid_json = true`` and set ``lua_table =`` a Lua table which has the decoded string\"."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:557
msgid "**LINE 8.** At last we are ready to get the JSON field value from the Lua table that came from the JSON string. The value in field_name, which is the parameter for the whole function, must be a name of a JSON field. For example, inside the JSON string ``'{\"Hello\": \"world\", \"Quantity\": 15}'``, there are two JSON fields: \"Hello\" and \"Quantity\". If the whole function is invoked with ``sum_json_field(\"Quantity\")``, then ``field_value = lua_table[field_name]`` is effectively the same as ``field_value = lua_table[\"Quantity\"]`` or even ``field_value = lua_table.Quantity``. Those are just three different ways of saying: for the Quantity field in the Lua table, get the value and put it in variable :code:`field_value`."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:567
msgid "**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but the JSON field is not a number, or is missing. In that case, the function would be aborted when there was an attempt to add it to the sum. By first checking ``type(field_value) == \"number\"``, we avoid that abortion. Anyone who knows that the database is in perfect shape can skip this kind of thing."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:573
msgid "And the function is complete. Time to test it. Starting with an empty database, defined the same way as the sandbox database in our :ref:`\"Getting started\" exercises <getting_started>`,"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:577
msgid "-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:584
msgid "then add some tuples where the first field is a number and the second field is a string."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:587
msgid "box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": \"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": 3}'}"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:594
msgid "Since this is a test, there are deliberate errors. The \"golf club\" and the \"waffle iron\" do not have numeric Quantity fields, so must be ignored. Therefore the real sum of the Quantity field in the JSON strings should be: 15 + 7 = 22."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:599
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:601
msgid "tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:608
msgid "It works. We'll just leave, as exercises for future improvement, the possibility that the \"hard coding\" assumptions could be removed, that there might have to be an overflow check if some field values are huge, and that the function should contain a :ref:`yield <atomic-threads_fibers_yields>` instruction if the count of tuples is huge."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:617
msgid "Indexed pattern search"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:619
msgid "Here is a generic function which takes a field identifier and a search pattern, and returns all tuples that match. |br| * The field must be the first field of a TREE index. |br| * The function will use `Lua pattern matching <http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, which allows \"magic characters\" in regular expressions. |br| * The initial characters in the pattern, as far as the first magic character, will be used as an index search key. For each tuple that is found via the index, there will be a match of the whole pattern. |br| * To be :ref:`cooperative <atomic-cooperative_multitasking>`, the function should yield after every 10 tuples, unless there is a reason to delay yielding. |br| With this function, we can take advantage of Tarantool's indexes for speed, and take advantage of Lua's pattern matching for flexibility. It does everything that an SQL \"LIKE\" search can do, and far more."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:636
msgid "Read the following Lua code to see how it works. The comments that begin with \"SEE NOTE ...\" refer to long explanations that follow the code."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:640
msgid "function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"string\")) then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == \".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == \"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too short\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- SEE NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\"\n"
"      number_of_tuples_since_last_yield = number_of_tuples_since_last_yield + 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- SEE NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set + 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:731
msgid "NOTE #1 \"FIND AN APPROPRIATE INDEX\" |br| The caller has passed space_name (a string) and field_no (a number). The requirements are: |br| (a) index type must be \"TREE\" because for other index types (HASH, BITSET, RTREE) a search with :ref:`iterator=GE <box_index-iterator-types>` will not return strings in order by string value; |br| (b) field_no must be the first index part; |br| (c) the field must contain strings, because for other data types (such as \"unsigned\") pattern searches are not possible; |br| If these requirements are not met by any index, then print an error message and return nil."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:743
msgid "NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\" |br| The caller has passed pattern (a string). The index search key will be the characters in the pattern as far as the first magic character. Lua's magic characters are % ^ $ ( ) . [ ] * + - ?. For example, if the pattern is \"ABC.E\", the period is a magic character and therefore the index search key will be \"ABC\". But there is a complication ... If we see \"%\" followed by a punctuation character, that punctuation character is \"escaped\" so remove the \"%\" when making the index search key. For example, if the pattern is \"AB%$E\", the dollar sign is escaped and therefore the index search key will be \"AB$E\". Finally there is a check that the index search key length must be at least three -- this is an arbitrary number, and in fact zero would be okay, but short index search keys will cause long search times."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:760
msgid "NOTE #3 -- \"OUTER LOOP: INITIATE\" |br| The function's job is to return a result set, just as `box.space...select <box_space-select>` would. We will fill it within an outer loop that contains an inner loop. The outer loop's job is to execute the inner loop, and possibly :ref:`yield <atomic-threads_fibers_yields>`, until the search ends. The inner loop's job is to find tuples via the index, and put them in the result set if they match the pattern."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:769
msgid "NOTE #4 \"INNER LOOP: ITERATOR\" |br| The for loop here is using pairs(), see the :ref:`explanation of what index iterators are <box_index-index_pairs>`. Within the inner loop, there will be a local variable named \"tuple\" which contains the latest tuple found via the index search key."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:776
msgid "NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\" |br| The iterator is GE (Greater or Equal), and we must be more specific: if the search index key has N characters, then the leftmost N characters of the result's index field must not be greater than the search index key. For example, if the search index key is 'ABC', then 'ABCDE' is a potential match, but 'ABD' is a signal that no more matches are possible."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:785
msgid "NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\" |br| This chunk of code is for cooperative multitasking. The number 10 is arbitrary, and usually a larger number would be okay. The simple rule would be \"after checking 10 tuples, yield, and then resume the search (that is, do the inner loop again) starting after the last value that was found\". However, if the index is non-unique or if there is more than one field in the index, then we might have duplicates -- for example {\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", 3}\" -- and it would be difficult to decide which \"ABC\" tuple to resume with. Therefore, if the result's index field is the same as the previous result's index field, there is no break."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:798
msgid "NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\" |br| Compare the result's index field to the entire pattern. For example, suppose that the caller passed pattern \"ABC.E\" and there is an indexed field containing \"ABCDE\". Therefore the initial index search key is \"ABC\". Therefore a tuple containing an indexed field with \"ABCDE\" will be found by the iterator, because \"ABCDE\" > \"ABC\". In that case string.match will return a value which is not nil. Therefore this tuple can be added to the result set."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:808
msgid "NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\" |br| There are three conditions which will cause a break from the inner loop: (1) the for loop ends naturally because there are no more index keys which are greater than or equal to the index search key, (2) the index key is too great as described in NOTE #5, (3) it is time for a yield as described in NOTE #6. If condition (1) or condition (2) is true, then there is nothing more to do, the outer loop ends too. If and only if condition (3) is true, the outer loop must yield and then continue. If it does continue, then the inner loop -- the iterator search -- will happen again with a new value for the index search key."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:821
msgid "EXAMPLE:"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:823
msgid "Start Tarantool, cut and paste the code for function ``indexed_pattern_search()``, and try the following:"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:863
msgid "box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,parts={2,'string',3,'string'}})\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:843
#: ../doc/tutorials/sql_tutorial.rst:118
#: ../doc/tutorials/sql_tutorial.rst:138
#: ../doc/tutorials/sql_tutorial.rst:200
#: ../doc/tutorials/sql_tutorial.rst:229
#: ../doc/tutorials/sql_tutorial.rst:272
#: ../doc/tutorials/sql_tutorial.rst:322
#: ../doc/tutorials/sql_tutorial.rst:421
#: ../doc/tutorials/sql_tutorial.rst:509
#: ../doc/tutorials/sql_tutorial.rst:536
msgid "The result will be:"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:845
msgid "tarantool> indexed_pattern_search(\"t\", 2, \"ABC.E.\")\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:5
msgid "SQL tutorial"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:7
msgid "This tutorial is a demonstration of the SQL feature introduced in Tarantool 2.x series. There are two ways to go through this tutorial:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:10
msgid "read what we say the results are and take our word for it, or"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:11
msgid "copy and paste each section and see everything work with Tarantool 2.1."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:13
msgid "You will encounter all the functionality that you'd encounter in an \"SQL-101\" course."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:20
msgid "Starting up with a first table and SELECTs"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:24
msgid "Initialize"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:26
msgid "Requests will be done using Tarantool as a :ref:`client <admin-using_tarantool_as_a_client>`. Start Tarantool and, optionally, enter the Tarantool configuration request, for example:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:31
msgid "tarantool> box.cfg{}"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:35
msgid "Before Tarantool 2.0 you needed to say ``box.cfg{...}`` prior to performing any database operations. Now you can start working with the database outright. Tarantool initiates the database module and applies :ref:`default settings <box_introspection-box_cfg>`."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:43
msgid "\\set"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:45
msgid "A feature of the client console program is that you can switch languages and specify the end-of-statement delimiter."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:48
msgid "Here we say: default language is SQL and statements end with semicolons."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:50
msgid "tarantool> \\set language sql\n"
"tarantool> \\set delimiter ;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:57
msgid "CREATE, INSERT, UPDATE, SELECT"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:59
msgid "Start with simple SQL statements just to be sure they're there."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:61
msgid "CREATE TABLE table1 (column1 INTEGER PRIMARY KEY, column2 VARCHAR(100));\n"
"INSERT INTO table1 VALUES (1, 'A');\n"
"UPDATE table1 SET column2 = 'B';\n"
"SELECT * FROM table1 WHERE column1 = 1;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:68
msgid "The result of the ``SELECT`` statement will look like this:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:70
msgid "tarantool> SELECT * FROM table1 WHERE column1 = 1;\n"
"---\n"
"- - [1, 'B']\n"
"..."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:77
msgid "Reality check: actually the result will include include initial fields called \"metadata\", the names and data types of each column. For all SELECT examples we show only the result rows without showing the metadata."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:83
msgid "CREATE TABLE"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:85
msgid "Here is ``CREATE TABLE`` with more details:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:87
msgid "There are multiple columns, with different data types."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:88
msgid "There is a ``PRIMARY KEY`` (unique and not-null) for two of the columns."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:90
msgid "CREATE TABLE table2 (column1 INTEGER,\n"
"                     column2 VARCHAR(100),\n"
"                     column3 SCALAR,\n"
"                     column4 FLOAT,\n"
"                     PRIMARY KEY (column1, column2));"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:98
#: ../doc/tutorials/sql_tutorial.rst:253
msgid "The result will be: \"``rowcount: 1``\" (no error)."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:102
msgid "INSERT"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:104
msgid "Try to put 5 rows in the table:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:106
msgid "The INTEGER and FLOAT columns get numbers."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:107
msgid "The VARCHAR and SCALAR columns get strings (the SCALAR strings are expressed as hexadecimals)."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:110
msgid "INSERT INTO table2 VALUES (1, 'AB', X'4142', 5.5);\n"
"INSERT INTO table2 VALUES (1, 'CD', X'2020', 1E4);\n"
"INSERT INTO table2 VALUES (1, 'AB', X'A5', -5.5);\n"
"INSERT INTO table2 VALUES (2, 'AB', X'2020', 12.34567);\n"
"INSERT INTO table2 VALUES (-1000, '', X'', 0.0);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:120
msgid "The third ``INSERT`` will fail because of a primary-key violation (``1, 'AB'`` is a duplication)."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:122
msgid "The other four ``INSERT`` statements will succeed."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:126
msgid "SELECT with ORDER BY clause"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:128
msgid "Retrieve the 4 rows in the table, in descending order by ``column2``, then (where the ``column2`` values are the same) in ascending order by column4."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:132
msgid "\"*\" is short for \"all columns\"."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:134
msgid "SELECT * FROM table2 ORDER BY column2 DESC, column4 ASC;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:140
msgid "- - [1, 'CD', '  ', 10000]\n"
"  - [1, 'AB', 'AB', 5.5]\n"
"  - [2, 'AB', '  ', 12.34567]\n"
"  - [-1000, '', '', 0]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:149
msgid "SELECT with WHERE clauses"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:151
msgid "Retrieve some of what you inserted:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:153
msgid "The first statement uses the ``LIKE`` comparison operator which is asking for \"first character must be 'A', the next characters can be anything.\""
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:156
msgid "The second statement uses logical operators and parentheses, so the ANDed expressions must be true, or the ORed expression must be true. Notice the columns don't have to be indexed."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:160
msgid "SELECT column1, column2, column1 * column4 FROM table2 WHERE column2\n"
"LIKE 'A%';\n"
"SELECT column1, column2, column3, column4 FROM table2\n"
"    WHERE (column1 < 2 AND column4 < 10)\n"
"    OR column3 = X'2020';"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:168
msgid "The results will be:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:170
msgid "- - [1, 'AB', 5.5]\n"
"  - [2, 'AB', 24.69134]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:175
msgid "and"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:177
msgid "- - [-1000, '', '', 0]\n"
"  - [1, 'AB', 'AB', 5.5]\n"
"  - [1, 'CD', '  ', 10000]\n"
"  - [2, 'AB', '  ', 12.34567]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:186
msgid "SELECT with GROUP BY and aggregating"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:188
msgid "Retrieve with grouping."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:190
msgid "The rows which have the same values for ``column2`` are grouped and are aggregated -- summed, counted, averaged -- for ``column4``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:194
msgid "SELECT column2, SUM(column4), COUNT(column4), AVG(column4)\n"
"FROM table2\n"
"GROUP BY column2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:202
msgid "- - ['', 0, 1, 0]\n"
"  - ['AB', 17.84567, 2, 8.922835]\n"
"  - ['CD', 10000, 1, 10000]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:212
msgid "Complications and complex SELECTs"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:216
msgid "NULLs"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:218
msgid "Insert more rows, containing NULL values."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:220
msgid "NULL is not the same as Lua nil; it commonly is used in SQL for unknown or not-applicable."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:223
msgid "INSERT INTO table2 VALUES (1, NULL, X'4142', 5.5);\n"
"INSERT INTO table2 VALUES (0, '!!@', NULL, NULL);\n"
"INSERT INTO table2 VALUES (0, '!!!', X'00', NULL);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:231
msgid "The first ``INSERT`` will fail because NULL is not permitted for a column that was defined with a ``PRIMARY KEY`` clause."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:234
msgid "The other ``INSERT`` statements will succeed."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:238
msgid "Indexes"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:240
msgid "Make a new index on column4."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:242
msgid "There already is an index for the primary key. Indexes are useful for making queries faster. In this case, the index also acts as a constraint, because it prevents two rows from having the same values in ``column4``. However, it is not an error that ``column4`` has multiple occurrences of NULLs."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:249
msgid "CREATE UNIQUE INDEX i ON table2 (column4);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:257
msgid "Create a subset table"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:259
msgid "Make a table which will have some of the columns of ``table2``, and some of the rows of ``table2``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:262
msgid "You can do this by combining ``INSERT`` with ``SELECT``. Then select everything in the resultant subset table."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:265
msgid "CREATE TABLE table3 (column1 INTEGER, column2 VARCHAR(100), PRIMARY KEY\n"
"(column2));\n"
"INSERT INTO table3 SELECT column1, column2 FROM table2 WHERE column1 <> 2;\n"
"SELECT * FROM table3;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:274
msgid "- - [-1000, '']\n"
"  - [0, '!!!']\n"
"  - [0, '!!@']\n"
"  - [1, 'AB']\n"
"  - [1, 'CD']"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:284
msgid "SELECT with a subquery"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:286
msgid "A subquery is a query within a query."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:288
msgid "Here we find all the rows in ``table2`` whose ``(column1, column2)`` values are not in ``table3``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:291
msgid "SELECT * FROM table2 WHERE (column1, column2) NOT IN (SELECT column1,\n"
"column2 FROM table3);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:296
msgid "The result is, unsurprisingly, the single row which we deliberately excluded when we inserted the rows in the ``INSERT ... SELECT`` statement:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:300
msgid "- - [2, 'AB', '  ', 12.34567]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:306
msgid "SELECT with a join"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:308
msgid "A join is a combination of two tables. There is more than one way to do them in Tarantool: \"Cartesian joins\", \"left outer joins\", etc."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:312
msgid "Here we're just showing the most typical case, where column values from one table match column values from another table."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:316
msgid "SELECT * FROM table2, table3\n"
"    WHERE table2.column1 = table3.column1 AND table2.column2 = table3.column2\n"
"    ORDER BY table2.column4;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:324
msgid "- - [0, '!!!', \"\\0\", null, 0, '!!!']\n"
"  - [0, '!!@', null, null, 0, '!!@']\n"
"  - [-1000, '', '', 0, -1000, '']\n"
"  - [1, 'AB', 'AB', 5.5, 1, 'AB']\n"
"  - [1, 'CD', ' ', 10000, 1, 'CD']"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:336
msgid "Constraints affecting updates"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:340
msgid "CREATE TABLE, with a CHECK clause"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:342
msgid "First we make a table which includes a \"constraint\" that there must not be any rows containing 13 in ``column2``. Then we try to insert such a row."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:346
msgid "CREATE TABLE table4 (column1 INTEGER PRIMARY KEY, column2 INTEGER, CHECK\n"
"(column2 <> 13));\n"
"INSERT INTO table4 VALUES (12, 13);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:352
msgid "Result: the insert fails, as it should, with the message \"``error: 'CHECK constraint failed: TABLE4'``\"."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:357
msgid "CREATE TABLE, with a FOREIGN KEY clause"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:359
msgid "First we make a table which includes a \"constraint\" that there must not be any rows containing values that do not appear in ``table2``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:363
msgid "When we made ``table2``, we specified that its \"primary key\" columns were ``(column1, column2)``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:366
msgid "CREATE TABLE table5 (column1 INTEGER, column2 VARCHAR(100),\n"
"    PRIMARY KEY (column1),\n"
"    FOREIGN KEY (column1, column2) REFERENCES table2 (column1, column2));\n"
"INSERT INTO table5 VALUES (2,'AB');\n"
"INSERT INTO table5 VALUES (3,'AB');"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:374
#: ../doc/tutorials/sql_tutorial.rst:477
msgid "Result:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:376
msgid "The first ``INSERT`` statement succeeds because ``table3`` contains a row with ``[2, 'AB', ' ', 12.34567]``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:378
msgid "The second INSERT statement, correctly, fails with the message \"``error: FOREIGN KEY constraint failed``\"."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:383
msgid "UPDATE"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:385
msgid "Due to earlier INSERT statements, these values are in ``table2 column4``: ``{0, NULL, NULL, 5.5, 10000, 12.34567}``. We will add 5 to every one of them except the one with 0. (Adding 5 to NULL will result in NULL, as SQL arithmetic requires.) Then we'll use ``SELECT`` to see what happened to ``column4``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:391
msgid "UPDATE table2 SET column4 = column4 + 5 WHERE column4 <> 0;\n"
"SELECT column4 FROM table2 ORDER BY column4;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:396
msgid "The result is: ``{NULL, NULL, 0, 10.5, 17.34567, 10005}``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:400
msgid "DELETE"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:402
msgid "Due to earlier ``INSERT`` statements, there are now 6 rows in ``table2``:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:404
msgid "- - [-1000, '', '', 0]\n"
"  - [0, '!!!', \"\\0\", null]\n"
"  - [0, '!!@', null, null]\n"
"  - [1, 'AB', 'AB', 10.5]\n"
"  - [1, 'CD', '  ', 10005]\n"
"  - [2, 'AB', '  ', 17.34567]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:413
msgid "We will try to delete the last and first of these rows."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:415
msgid "DELETE FROM table2 WHERE column1 = 2;\n"
"DELETE FROM table2 WHERE column1 = -1000;\n"
"SELECT COUNT(column1) FROM table2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:423
msgid "The first ``DELETE`` statement causes an error message because (remember?) there's a foreign-key constraint."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:425
msgid "The second ``DELETE`` statement succeeds."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:426
msgid "The ``SELECT`` statement shows that there are now only 5 rows remaining."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:430
msgid "ALTER TABLE, with a FOREIGN KEY clause"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:432
msgid "Now we want to make another \"constraint\", that there must not be any rows in ``table1`` containing values that do not appear in ``table5``. We couldn't do this when we created ``table1`` because at that time ``table5`` did not exist. But we can add constraints to existing tables with the ALTER TABLE statement."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:440
msgid "ALTER TABLE table1 ADD CONSTRAINT c\n"
"    FOREIGN KEY (column1) REFERENCES table5 (column1);\n"
"DELETE FROM table1;\n"
"ALTER TABLE table1 ADD CONSTRAINT c\n"
"    FOREIGN KEY (column1) REFERENCES table5 (column1);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:448
msgid "Result: the ``ALTER TABLE`` statement fails the first time because there is a row in ``table1``, and ADD CONSTRAINT requires that the table be empty. But after we delete that row, the ``ALTER TABLE`` statement succeeds the second time. Thus we have set up a chain of references, from ``table1`` to ``table5`` and from ``table5`` to ``table2``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:457
msgid "Triggers"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:459
msgid "The idea of a trigger is: if a change (``INSERT`` or ``UPDATE`` or ``DELETE``) happens, then a further action -- perhaps another ``INSERT`` or ``UPDATE`` or ``DELETE`` -- will happen."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:463
msgid "There are many variants, the one we'll illustrate here is: just after doing an update in ``table3``, do an update in ``table2``. We will specify this as ``FOR EACH ROW``, so (since there are 5 rows in ``table3``) the trigger will be activated 5 times."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:469
msgid "SELECT column4 FROM table2 WHERE column1 = 2;\n"
"CREATE TRIGGER tr AFTER UPDATE ON table3 FOR EACH ROW\n"
"BEGIN UPDATE table2 SET column4 = column4 + 1 WHERE column1 = 2; END;\n"
"UPDATE table3 SET column2 = column2;\n"
"SELECT column4 FROM table2 WHERE column1 = 2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:479
msgid "The first ``SELECT`` shows that the original value of ``column4`` in ``table2`` where ``column1 = 2`` was: 17.34567."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:481
msgid "The second ``SELECT`` returns:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:483
msgid "- - [22.34567]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:491
msgid "Operators and functions"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:495
msgid "String operations"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:497
msgid "You can manipulate string data (usually defined with CHAR or VARCHAR data types) in many ways."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:500
#: ../doc/tutorials/sql_tutorial.rst:527
msgid "We'll illustrate here:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:502
msgid "the ``||`` operator for concatenation and"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:503
msgid "the ``SUBSTR`` function for extraction."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:505
msgid "SELECT column2, column2 || column2, SUBSTR(column2, 2, 1) FROM table2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:511
msgid "- - ['!!!', '!!!!!!', '!']\n"
"  - ['!!@', '!!@!!@', '!']\n"
"  - ['AB', 'ABAB', 'B']\n"
"  - ['CD', 'CDCD', 'D']\n"
"  - ['AB', 'ABAB', 'B']"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:522
msgid "Number operations"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:524
msgid "You can also manipulate number data (usually defined with INTEGER or FLOAT data types) in many ways."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:529
msgid "the ``<<`` operator for shift left and"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:530
msgid "the ``%`` operator for modulo."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:532
msgid "SELECT column1, column1 << 1, column1 << 2, column1 % 2 FROM table2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:538
msgid "- - [0, 0, 0, 0]\n"
"  - [0, 0, 0, 0]\n"
"  - [1, 2, 4, 1]\n"
"  - [1, 2, 4, 1]\n"
"  - [2, 4, 8, 0]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:548
msgid "Ranges and limits"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:550
msgid "Tarantool can handle:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:552
msgid "integers anywhere in the 4-byte integer range,"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:553
msgid "approximate-numerics anywhere in the 8-byte IEEE floating point range,"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:554
msgid "any Unicode characters, with UTF-8 encoding and a choice of collations."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:556
msgid "Here we will insert some such values in a new table, and see what happens when we select them, with arithmetic on a number column and ordering by a string column."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:560
msgid "CREATE TABLE t6 (column1 INTEGER, column2 VARCHAR(10), column4 FLOAT,\n"
"PRIMARY KEY (column1));\n"
"INSERT INTO t6 VALUES (-1234567890, 'АБВГД', 123456.123456);\n"
"INSERT INTO t6 VALUES (+1234567890, 'GD', 1e30);\n"
"INSERT INTO t6 VALUES (10, 'FADEW?', 0.000001);\n"
"INSERT INTO t6 VALUES (5, 'ABCDEFG', NULL);\n"
"SELECT column1 + 1, column2, column4 * 2 FROM t6 ORDER BY column2;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:570
#: ../doc/tutorials/sql_tutorial.rst:596
#: ../doc/tutorials/sql_tutorial.rst:781
msgid "The result is:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:572
msgid "- - [6, 'ABCDEFG', null]\n"
"  - [11, 'FADEW?', 2e-06]\n"
"  - [1234567891, 'GD', 2e+30]\n"
"  - [-1234567889, 'АБВГД', 246912.246912]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:581
msgid "Views"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:583
msgid "A view, or \"viewed table\", is virtual, that is, its rows aren't physically in the database, their values are calculated from other tables."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:587
msgid "Here we'll create a view ``v3`` based on ``table3``, then we select from it."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:590
msgid "CREATE VIEW v3 AS SELECT SUBSTR(column2,1,2), column4 FROM t6 WHERE\n"
"column4 >= 0;\n"
"SELECT * FROM v3;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:598
#: ../doc/tutorials/sql_tutorial.rst:623
msgid "- - ['АБ', 123456.123456]\n"
"  - ['FA', 1e-06]\n"
"  - ['GD', 1e+30]"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:606
msgid "Common table expressions"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:608
msgid "By putting ``WITH`` + ``SELECT`` in front of a ``SELECT``, we can make a sort of temporary view that lasts for the duration of the statement."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:612
msgid "Here we'll select from the sort of temporary view."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:614
msgid "WITH cte AS (\n"
"             SELECT SUBSTR(column2,1,2), column4 FROM t6 WHERE column4\n"
"             >= 0)\n"
"SELECT * FROM cte;"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:621
msgid "Result: the same as the result we got with ``CREATE VIEW`` earlier:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:631
msgid "VALUES"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:633
msgid "Tarantool can handle statements like ``SELECT 55;`` (select without ``FROM``) like some other popular DBMSs. But it also handles the more standard statement ``VALUES (expression [, expression ...]);``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:638
msgid "Here we'll use both styles."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:640
msgid "SELECT 55 * 55, 'The rain in Spain';\n"
"VALUES (55 * 55, 'The rain in Spain');"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:645
msgid "The result of either statement will be:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:647
msgid "- - [3025, 'The rain in Spain']"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:653
msgid "Metadata"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:655
msgid "What database objects have we created? We can find out about:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:657
msgid "tables with ``SELECT * FROM \"_space\";``"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:658
msgid "indexes with ``SELECT * FROM \"_index\";``"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:659
msgid "triggers with ``SELECT * FROM \"_trigger\";`` (These names will be familiar to old Tarantool users because we're actually selecting from NoSQL \"system spaces\".)"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:663
msgid "Here we will select from ``_space``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:665
msgid "SELECT \"id\", \"name\", \"owner\", \"engine\" FROM \"_space\" WHERE \"name\"='TABLE3';"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:669
msgid "The result is (we know we will get a row because we created ``table3`` earlier):"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:671
msgid "- - [517, 'table3', 1, 'memtx']"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:679
msgid "Calling from a host language to make a big table"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:683
msgid "box.execute()"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:685
msgid "Now we will change the settings so that the console accepts statements written in Lua instead of statements written in SQL. (More ways to switch languages will exist in Tarantool clients in our next version.)"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:690
msgid "This doesn't mean we have left the SQL world though, because we can invoke SQL statements using a Lua function: ``box.execute(string)``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:694
msgid "Here we'll switch languages, and ask to select again what's in ``table3``. These statements must be entered separately."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:698
msgid "tarantool> \\set language lua\n"
"tarantool> box.execute([[SELECT * FROM table3;]]);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:703
msgid "Showing both the statements and the results:"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:705
msgid "tarantool> \\set language lua\n"
"---\n"
"...\n"
"tarantool> box.execute([[SELECT * FROM table3;]]);\n"
"---\n"
"- - [-1000, '']\n"
"  - [0, '!!!']\n"
"  - [0, '!!@']\n"
"  - [1, 'AB']\n"
"  - [1, 'CD']\n"
"..."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:721
msgid "Create a million-row table"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:723
msgid "We've illustrated a lot of SQL, but does it scale? To answer that, let's make a bigger table."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:726
msgid "For this we are going to use Lua. We will not explain the Lua, because that's in the Lua section of the Tarantool manual. Just copy-and-paste these instructions and wait for about a minute."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:731
msgid "box.execute(\"CREATE TABLE tester (s1 INT PRIMARY KEY, s2 VARCHAR(10))\");\n"
"\n"
"function string_function()\n"
"   local random_number\n"
"   local random_string\n"
"   random_string = \"\"\n"
"   for x = 1,10,1 do\n"
"     random_number = math.random(65, 90)\n"
"     random_string = random_string .. string.char(random_number)\n"
"   end\n"
"   return random_string\n"
"end;\n"
"\n"
"function main_function()\n"
"   local string_value, t, sql_statement\n"
"   for i = 1,1000000,1 do\n"
"     string_value = string_function()\n"
"     sql_statement = \"INSERT INTO tester VALUES (\" .. i .. \",'\" .. string_value .. \"')\"\n"
"     box.execute(sql_statement)\n"
"   end\n"
"end;\n"
"start_time = os.clock();\n"
"main_function();\n"
"end_time = os.clock();\n"
"'insert done in ' .. end_time - start_time .. ' seconds';"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:759
msgid "The result is: you now have a table with a million rows, with a message saying \"``insert done in 88.570578 seconds``\"."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:764
msgid "Select from a million-row table"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:766
msgid "Now that we have something a bit larger to play with, let's see how long it takes to SELECT."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:769
msgid "The first query we'll do will automatically go via an index, because ``s1`` is the primary key."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:772
msgid "The second query we'll do will not go via an index, because for ``s2`` we didn't say ``CREATE INDEX xxxx ON tester (s2);``."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:776
msgid "box.execute([[SELECT * FROM tester WHERE s1 = 73446;]]);\n"
"box.execute([[SELECT * FROM tester WHERE s2 LIKE 'QFML%';]]);"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:783
msgid "the first statement will finish instantaneously,"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:784
msgid "the second statement will be noticeably slower but still a fraction of a second."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:789
msgid "Cleanup and exit"
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:791
msgid "We're done. We've shown that Tarantool 2.1 has a very reasonable subset of SQL, and it works."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:794
msgid "The rest of these commands will simply destroy all the database objects that were created so that you can do the demonstration again. These statements must be entered separately."
msgstr ""

#: ../doc/tutorials/sql_tutorial.rst:799
msgid "tarantool> \\set language sql\n"
"tarantool> DROP TABLE tester;\n"
"tarantool> DROP TABLE table1;\n"
"tarantool> DROP VIEW v3;\n"
"tarantool> DROP TRIGGER tr;\n"
"tarantool> DROP TABLE table5;\n"
"tarantool> DROP TABLE table4;\n"
"tarantool> DROP TABLE table3;\n"
"tarantool> DROP TABLE table2;\n"
"tarantool> DROP TABLE t6;\n"
"tarantool> \\set language lua\n"
"tarantool> os.exit();"
msgstr ""

