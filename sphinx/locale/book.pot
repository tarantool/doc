# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-07-26 11:39+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../book/administration.rst:28
msgid "Server administration"
msgstr ""

#: ../book/administration.rst:30
msgid "Typical server administration tasks include starting and stopping the server, reloading configuration, taking snapshots, log rotation."
msgstr ""

#: ../book/administration.rst:35
msgid "Server signal handling"
msgstr ""

#: ../book/administration.rst:37
msgid "The server processes these signals during the main thread event loop:"
msgstr ""

#: ../book/administration.rst:40
msgid "SIGHUP"
msgstr ""

#: ../book/administration.rst:42
msgid "may cause log file rotation, see :ref:`the example in section \"Logging\" <cfg_logging-logging_example>`."
msgstr ""

#: ../book/administration.rst:44
msgid "SIGUSR1"
msgstr ""

#: ../book/administration.rst:46
msgid "may cause saving of a snapshot, see the description of :ref:`box.snapshot <admin-snapshot>`."
msgstr ""

#: ../book/administration.rst:48
msgid "SIGTERM"
msgstr ""

#: ../book/administration.rst:50
msgid "may cause graceful shutdown (information will be saved first)."
msgstr ""

#: ../book/administration.rst:51
msgid "SIGINT"
msgstr ""

#: ../book/administration.rst:53
msgid "(also known as keyboard interrupt) may cause graceful shutdown."
msgstr ""

#: ../book/administration.rst:54
msgid "SIGKILL"
msgstr ""

#: ../book/administration.rst:56
msgid "causes shutdown."
msgstr ""

#: ../book/administration.rst:58
msgid "Other signals will result in behavior defined by the operating system. Signals other than SIGKILL may be ignored, especially if the server is executing a long-running procedure which prevents return to the main thread event loop."
msgstr ""

#: ../book/administration.rst:66
msgid "Process title"
msgstr ""

#: ../book/administration.rst:68
msgid "Linux and FreeBSD operating systems allow a running process to modify its title, which otherwise contains the program name. Tarantool uses this feature to help meet the needs of system administration, such as figuring out what services are running on a host, their status, and so on."
msgstr ""

#: ../book/administration.rst:73
msgid "A Tarantool server's process title has these components:"
msgstr ""

#: ../book/administration.rst:78
msgid "**program_name** [**initialization_file_name**] **<role_name>** [**custom_proc_title**]"
msgstr ""

#: ../book/administration.rst:80
msgid "**program_name** is typically \"tarantool\"."
msgstr ""

#: ../book/administration.rst:81
msgid "**initialization_file_name** is the name of an :ref:`initialization file <index-init_label>` if one was specified."
msgstr ""

#: ../book/administration.rst:82
msgid "**role_name** is: - \"running\" (ordinary node \"ready to accept requests\"), - \"loading\" (ordinary node recovering from old snap and wal files), - \"orphan\" (not in a cluster), - \"hot_standby\" (see section :ref:`local hot standby <book_cfg_local_hot_standby>`), or - \"dumper\" + process-id (saving a snapshot)."
msgstr ""

#: ../book/administration.rst:88
msgid "**custom_proc_title** is taken from the :ref:`custom_proc_title <cfg_basic-custom_proc_title>` configuration parameter, if one was specified."
msgstr ""

#: ../book/administration.rst:90
msgid "For example:"
msgstr ""

#: ../book/administration.rst:92
msgid "$ ps -AF | grep tarantool\n"
"1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool script.lua <running>"
msgstr ""

#: ../book/administration.rst:102
msgid "Using ``tarantool`` as a client"
msgstr ""

#: ../book/administration.rst:106
msgid "If ``tarantool`` is started without an :ref:`initialization file <index-init_label>`, or if the initialization file contains :ref:`console.start() <console-start>`, then ``tarantool`` enters interactive mode. There will be a prompt (\"``tarantool>``\") and it will be possible to enter requests. When used this way, ``tarantool`` can be a client for a remote server."
msgstr ""

#: ../book/administration.rst:112
msgid "This section shows all legal syntax for the tarantool program, with short notes and examples. Other client programs may have similar options and request syntaxes. Some of the information in this section is duplicated in the :ref:`book-cfg <index-book_cfg>` chapter."
msgstr ""

#: ../book/administration.rst:119
msgid "Conventions used in this section"
msgstr ""

#: ../book/administration.rst:121
msgid "Tokens are character sequences which are treated as syntactic units within requests. Square brackets [ and ] enclose optional syntax. Three dots in a row ... mean the preceding tokens may be repeated. A vertical bar | means the preceding and following tokens are mutually exclusive alternatives."
msgstr ""

#: ../book/administration.rst:128
msgid "Options when starting client from the command line"
msgstr ""

#: ../book/administration.rst:130
msgid "General form:"
msgstr ""

#: ../book/administration.rst:135
msgid "$ **tarantool**\n"
"OR\n"
"$ **tarantool** *options*\n"
"OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../book/administration.rst:141
msgid "*lua-initialization-file* can be any script containing code for initializing. Effect: The code in the file is executed during startup. Example: ``init.lua``. Notes: If a script is used, there will be no prompt. The script should contain configuration information including ``box.cfg{...listen=...}`` or ``box.listen(...)`` so that a separate program can connect to the server via one of the ports."
msgstr ""

#: ../book/administration.rst:148
msgid "Option is one of the following (in alphabetical order by the long form of the option):"
msgstr ""

#: ../book/administration.rst:153
msgid "Client displays a help message including a list of options. Example: ``tarantool --help``. The program stops after displaying the help."
msgstr ""

#: ../book/administration.rst:159
msgid "Client displays version information. Example: ``tarantool --version``. The program stops after displaying the version."
msgstr ""

#: ../book/administration.rst:165
msgid "Tokens, requests, and special key combinations"
msgstr ""

#: ../book/administration.rst:167
msgid "Procedure identifiers are: Any sequence of letters, digits, or underscores which is legal according to the rules for Lua identifiers. Procedure identifiers are also called function names. Notes: function names are case sensitive so ``insert`` and ``Insert`` are not the same thing."
msgstr ""

#: ../book/administration.rst:172
msgid "String literals are: Any sequence of zero or more characters enclosed in single quotes. Double quotes are legal but single quotes are preferred. Enclosing in double square brackets is good for multi-line strings as described in `Lua documentation`_. Examples: 'Hello, world', 'A', [[A\\\\B!]]."
msgstr ""

#: ../book/administration.rst:179
msgid "Numeric literals are: Character sequences containing only digits, optionally preceded by + or -. Large or floating-point numeric literals may include decimal points, exponential notation, or suffixes. Examples: 500, -500, 5e2, 500.1, 5LL, 5ULL. Notes: Tarantool NUM data type is unsigned, so -1 is understood as a large unsigned number."
msgstr ""

#: ../book/administration.rst:185
msgid "Single-byte tokens are: , or ( or ) or arithmetic operators. Examples: * , ( )."
msgstr ""

#: ../book/administration.rst:187
msgid "Tokens must be separated from each other by one or more spaces, except that spaces are not necessary around single-byte tokens or string literals."
msgstr ""

#: ../book/administration.rst:194
msgid "Requests"
msgstr ""

#: ../book/administration.rst:196
msgid "Generally requests are entered following the prompt in interactive mode while ``tarantool`` is running. (A prompt will be the word tarantool and a greater-than sign, for example ``tarantool>``). The end-of-request marker is by default a newline (line feed)."
msgstr ""

#: ../book/administration.rst:201
msgid "For multi-line requests, it is possible to change the end-of-request marker. Syntax: :samp:`console = require('console'); console.delimiter({string-literal})`. The string-literal must be a value in single quotes. Effect: string becomes end-of-request delimiter, so newline alone is not treated as end of request. To go back to normal mode: :samp:`console.delimiter(''){string-literal}`. Delimiters are usually not necessary because Tarantool can tell when a multi-line request has not ended (for example, if it sees that a function declaration does not have an ``end`` keyword). Example:"
msgstr ""

#: ../book/administration.rst:210
msgid "console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"  statement_1 = 'a'\n"
"  statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"
msgstr ""

#: ../book/administration.rst:219
msgid "For a condensed Backus-Naur Form [BNF] description of the suggested form of client requests, see http://tarantool.org/doc/dev_guide/box-protocol.html."
msgstr ""

#: ../book/administration.rst:222
msgid "In *interactive* mode, one types requests and gets results. Typically the requests are typed in by the user following prompts. Here is an example of an interactive-mode tarantool client session:"
msgstr ""

#: ../book/administration.rst:226
msgid "$ tarantool\n"
"[ tarantool will display an introductory message\n"
"  including version number here ]\n"
"tarantool> box.cfg{listen = 3301}\n"
"[ tarantool will display configuration information\n"
"  here ]\n"
"tarantool> s = box.schema.space.create('tester')\n"
"[ tarantool may display an in-progress message here ]\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{1,'My first tuple'}\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:select(1)\n"
"---\n"
"- - [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:drop()\n"
"---\n"
"...\n"
"tarantool> os.exit()\n"
"2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master shutdown\n"
"$"
msgstr ""

#: ../book/administration.rst:256
msgid "Explanatory notes about what tarantool displayed in the above example:"
msgstr ""

#: ../book/administration.rst:258
msgid "Many requests return typed objects. In the case of \"``box.cfg{listen=3301}``\", this result is displayed on the screen. If the request had assigned the result to a variable, for example \"``c = box.cfg{listen=3301}``\", then the result would not have been displayed on the screen."
msgstr ""

#: ../book/administration.rst:262
msgid "A display of an object always begins with \"``---``\" and ends with \"``...``\"."
msgstr ""

#: ../book/administration.rst:263
msgid "The insert request returns an object of type = tuple, so the object display line begins with a single dash ('``-``'). However, the select request returns an object of type = table of tuples, so the object display line begins with two dashes ('``- -``')."
msgstr ""

#: ../book/administration.rst:269
msgid "Utility ``tarantoolctl``"
msgstr ""

#: ../book/administration.rst:273
msgid "With ``tarantoolctl`` one can say: \"start an instance of the Tarantool server which runs a single user-written Lua program, allocating disk resources specifically for that program, via a standardized deployment method.\" If Tarantool was installed with Debian or Red Hat installation packages, the script is in :file:`/usr/bin/tarantoolctl` or :file:`/usr/local/bin/tarantoolctl`. The script handles such things as: starting, stopping, rotating logs, logging in to the application's console, and checking status."
msgstr ""

#: ../book/administration.rst:283
msgid "The use of tarantoolctl as a client is described in a separate section, :ref:`tarantoolctl connect <administration-tarantoolctl_connect>`."
msgstr ""

#: ../book/administration.rst:288
msgid "configuring for tarantoolctl"
msgstr ""

#: ../book/administration.rst:290
msgid "\"The :codenormal:`tarantoolctl` script will look for a configuration file in the current directory (:codenormal:`$PWD/.tarantoolctl`). If that fails, it looks in the current user's home directory (:codenormal:`$HOME/.config/tarantool/tarantool`). If that fails, it looks in the SYSCONFDIR directory (usually :codenormal:`/etc/sysconfig/tarantool` but it may be different on some platforms). Most of the settings are similar to the settings used by ``box.cfg{...};`` however, tarantoolctl adjusts some of them by adding an application name. A copy of :file:`usr/local/etc/default/tarantool`, with defaults for all settings, would look like this:"
msgstr ""

#: ../book/administration.rst:301
msgid "default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\",\n"
"    wal_dir    = \"/var/lib/tarantool\",\n"
"    snap_dir   = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    logger     = \"/var/log/tarantool\",\n"
"    username   = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""

#: ../book/administration.rst:313
msgid "The settings in the above script are:"
msgstr ""

#: ../book/administration.rst:317
msgid "``pid_file``"
msgstr ""

#: ../book/administration.rst:316
msgid "The directory for the pid file and control-socket file. The script will add \":samp:`/{instance-name}`\" to the directory name."
msgstr ""

#: ../book/administration.rst:321
msgid "``wal_dir``"
msgstr ""

#: ../book/administration.rst:320
msgid "The directory for the write-ahead :file:`*.xlog` files. The script will add \":samp:`/{instance-name}`\" to the directory-name."
msgstr ""

#: ../book/administration.rst:325
msgid "``snap_dir``"
msgstr ""

#: ../book/administration.rst:324
msgid "The directory for the snapshot :file:`*.snap` files. The script will add \":samp:`/{instance-name}`\" to the directory-name."
msgstr ""

#: ../book/administration.rst:329
msgid "``vinyl_dir``"
msgstr ""

#: ../book/administration.rst:328
msgid "The directory for the vinyl-storage-engine files. The script will add \":samp:`/vinyl/{instance-name}`\" to the directory-name."
msgstr ""

#: ../book/administration.rst:333
msgid "``logger``"
msgstr ""

#: ../book/administration.rst:332
msgid "The place where the application log will go. The script will add \":samp:`/{instance-name}.log`\" to the name."
msgstr ""

#: ../book/administration.rst:337
msgid "``username``"
msgstr ""

#: ../book/administration.rst:336
msgid "The user that runs the tarantool server. This is the operating-system user name rather than the Tarantool-client user name."
msgstr ""

#: ../book/administration.rst:345
msgid "``instance_dir``"
msgstr ""

#: ../book/administration.rst:340
msgid "The directory where all applications for this host are stored. The user who writes an application for :program:`tarantoolctl` must put the application's source code in this directory, or a symbolic link. For examples in this section the application name my_app will be used, and its source will have to be in :samp:`{instance_dir}/my_app.lua`."
msgstr ""

#: ../book/administration.rst:349
msgid "commands for tarantoolctl"
msgstr ""

#: ../book/administration.rst:351
msgid "The command format is :samp:`tarantoolctl {operation} {application_name}`, where operation is one of: start, stop, enter, logrotate, status, eval. Thus ..."
msgstr ""

#: ../book/administration.rst:356
msgid "Start application *<application>*"
msgstr ""

#: ../book/administration.rst:360
msgid "Stop application"
msgstr ""

#: ../book/administration.rst:364
msgid "Show application's admin console"
msgstr ""

#: ../book/administration.rst:368
msgid "Rotate application's log files (make new, remove old)"
msgstr ""

#: ../book/administration.rst:372
msgid "Check application's status"
msgstr ""

#: ../book/administration.rst:376
msgid "Execute code from *<scriptname>* on an instance of application"
msgstr ""

#: ../book/administration.rst:380
msgid "typical code snippets for tarantoolctl"
msgstr ""

#: ../book/administration.rst:382
msgid "A user can check whether my_app is running with these lines:"
msgstr ""

#: ../book/administration.rst:384
msgid "if tarantoolctl status my_app; then\n"
"...\n"
"fi"
msgstr ""

#: ../book/administration.rst:390
msgid "A user can initiate, for boot time, an init.d set of instructions:"
msgstr ""

#: ../book/administration.rst:392
msgid "for (each file mentioned in the instance_dir directory):\n"
"    tarantoolctl start `basename $ file .lua`"
msgstr ""

#: ../book/administration.rst:397
msgid "A user can set up a further configuration file for log rotation, like this:"
msgstr ""

#: ../book/administration.rst:402
msgid "/path/to/tarantool/\\*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /path/to/tarantoolctl logrotate `basename $ 1 .log`\n"
"    endscript\n"
"}"
msgstr ""

#: ../book/administration.rst:417
msgid "A detailed example for tarantoolctl"
msgstr ""

#: ../book/administration.rst:419
msgid "The example's objective is: make a temporary directory where tarantoolctl can start a long-running application and monitor it."
msgstr ""

#: ../book/administration.rst:422
msgid "The assumptions are: the root password is known, the computer is only being used for tests, the Tarantool server is ready to run but is not currently running, tarantoolctl is installed along the user's path, and there currently is no directory named :file:`tarantool_test`."
msgstr ""

#: ../book/administration.rst:427
msgid "Create a directory named /tarantool_test:"
msgstr ""

#: ../book/administration.rst:429
msgid "$ sudo mkdir /tarantool_test"
msgstr ""

#: ../book/administration.rst:433
msgid "Edit /usr/local/etc/default/tarantool. It might be necessary to say :codenormal:`sudo mkdir /usr/local/etc/default` first. Let the new file contents be:"
msgstr ""

#: ../book/administration.rst:436
msgid "default_cfg = {\n"
"    pid_file = \"/tarantool_test/my_app.pid\",\n"
"    wal_dir = \"/tarantool_test\",\n"
"    snap_dir = \"/tarantool_test\",\n"
"    vinyl_dir = \"/tarantool_test\",\n"
"    logger = \"/tarantool_test/log\",\n"
"    username = \"tarantool\",\n"
"}\n"
"instance_dir = \"/tarantool_test\""
msgstr ""

#: ../book/administration.rst:448
msgid "Make the my_app application file, that is, :file:`/tarantool_test/my_app.lua`. Let the file contents be:"
msgstr ""

#: ../book/administration.rst:450
msgid "box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""

#: ../book/administration.rst:466
msgid "Tell tarantoolctl to start the application ..."
msgstr ""

#: ../book/administration.rst:468
msgid "$ cd /tarantool_test\n"
"$ sudo tarantoolctl start my_app"
msgstr ""

#: ../book/administration.rst:473
msgid "... expect to see messages indicating that the instance has started. Then ..."
msgstr ""

#: ../book/administration.rst:475
msgid "$ ls -l /tarantool_test/my_app"
msgstr ""

#: ../book/administration.rst:479
msgid "... expect to see the .snap file and the .xlog file. Then ..."
msgstr ""

#: ../book/administration.rst:481
msgid "$ sudo less /tarantool_test/log/my_app.log"
msgstr ""

#: ../book/administration.rst:485
msgid "... expect to see the contents of my_app's log, including error messages, if any. Then ..."
msgstr ""

#: ../book/administration.rst:487
msgid "$ cd /tarantool_test\n"
"$ # assume that 'tarantool' invokes the tarantool server\n"
"$ sudo tarantool\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../book/administration.rst:497
msgid "... expect to see several tuples that my_app has created."
msgstr ""

#: ../book/administration.rst:499
msgid "Stop. The only clean way to stop my_app is with tarantoolctl, thus:"
msgstr ""

#: ../book/administration.rst:501
msgid "$ sudo tarantoolctl stop my_app"
msgstr ""

#: ../book/administration.rst:505
msgid "Clean up. Restore the original contents of :file:`/usr/local/etc/default/tarantool`, and ..."
msgstr ""

#: ../book/administration.rst:507
msgid "$ cd /\n"
"$ sudo rm -R tarantool_test"
msgstr ""

#: ../book/administration.rst:516
msgid "Utility ``tarantoolctl connect``"
msgstr ""

#: ../book/administration.rst:518
msgid "The ``tarantoolctl connect`` utility is a client program. Use it to connect to a tarantool server and pass requests."
msgstr ""

#: ../book/administration.rst:521
msgid "To invoke the utility one says: |br| :codenormal:`tarantoolctl connect` :codeitalic:`URI` |br| and the format of a URI is described :ref:`in the URI section <index-uri>`."
msgstr ""

#: ../book/administration.rst:525
msgid "Example:"
msgstr ""

#: ../book/administration.rst:527
msgid "$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr ""

#: ../book/administration.rst:531
msgid "There are alternatives to ``tarantoolctl connect`` -- one can use the :ref:`console package <console-package>` or the :ref:`net.box package <net_box-package>` from a Tarantool server. Also one can write one's one client programs with any of the Connectors. However, most of the examples in this manual illustrate usage with either ``tarantoolctl connect`` or with :ref:`using the tarantool server as a client <administration-using_tarantool_as_a_client>`."
msgstr ""

#: ../book/administration.rst:538
msgid "Statements about :ref:`console.connect() <console-connect>` behavior are usually applicable for ``tarantoolctl connect`` as well. For example, an :ref:`authentication trigger <triggers-authentication_triggers>` will be activated whenever ``tarantoolctl connect`` starts or ends."
msgstr ""

#: ../book/administration.rst:548
msgid "Admin ports"
msgstr ""

#: ../book/administration.rst:551
msgid "\"Admin port\", \"admin console\", and \"text protocol\" all refer to the same thing: a connection which is set up with :ref:`console.listen(...) <console-listen>` for entry of requests by administrators."
msgstr ""

#: ../book/administration.rst:555
msgid "\"Binary port\", \"binary protocol\", and \"primary port\" all refer to a different thing: a connection which is set up with :ref:`box.cfg{listen=...} <cfg_basic-listen>` for entry of requests by anyone."
msgstr ""

#: ../book/administration.rst:559
msgid "Ordinary connections to the Tarantool server should go via a binary port. But admin ports are useful for special cases involving security."
msgstr ""

#: ../book/administration.rst:562
msgid "When one connects to an admin port: |br| * No password is necessary |br| * The user is automatically 'admin', a user with many privileges. |br| Therefore one must set up admin ports very cautiously. If it is a TCP port, it should only be opened for a specific IP. Ideally it should not be a TCP port at all, it should be a Unix domain socket, so that access to the server machine is required. Thus a typical setup for an admin port is: |br| :codenormal:`console.listen('/var/lib/tarantool/socket_name.sock')` |br| and a typical connection :ref:`URI <index-uri>` is: |br| :codenormal:`admin:any_string@/var/lib/tarantool/socket_name.sock` |br| if the listener has the privilege to write on /var/lib/tarantool and the connector has the privilege to read on /var/lib/tarantool. Alternatively both setup and connection can be done with :ref:`tarantoolctl <administration-tarantoolctl>`."
msgstr ""

#: ../book/administration.rst:578
msgid "If no administrator password exists which could be given out to users, and admin ports are restricted or are sockets, then requests which require 'admin' privileges can only occur locally, and are subject to Unix security and monitoring."
msgstr ""

#: ../book/administration.rst:583
msgid "For additional security, some requests are illegal. For example, :ref:`\"conn:eval\" <net_box-eval>`  will result in the error message \"- error: console does not support this request type\" because conn:eval requires the binary protocol."
msgstr ""

#: ../book/administration.rst:588
msgid "If security via admin ports is not necessary, it is still possible to be an admin user by :ref:`using the tarantool server as a client <administration-using_tarantool_as_a_client>`, or by connecting to a binary port with a valid password."
msgstr ""

#: ../book/administration.rst:593
msgid "To find out whether a TCP port is an admin port, use telnet. For example: |br| :codenormal:`$` :codebold:`telnet 0 3303` |br| :codenormal:`Trying 0.0.0.0...` |br| :codenormal:`Connected to 0.` |br| :codenormal:`Escape character is '^]'.` |br| :codenormal:`Tarantool 1.7.1-70-gbc479ad (Lua console)` |br| :codenormal:`type 'help' for interactive help` |br| In this example the response does not include the word \"binary\" and does include the words \"Lua console\". Therefore it is clear that this is a successful connection to an admin port, and admin requests can now be entered on this terminal."
msgstr ""

#: ../book/administration.rst:608
msgid "System-specific administration notes"
msgstr ""

#: ../book/administration.rst:610
msgid "This section will contain information about issue or features which exist on some platforms but not others - for example, on certain versions of a particular Linux distribution."
msgstr ""

#: ../book/administration.rst:616
msgid "Administrating with Debian GNU/Linux and Ubuntu"
msgstr ""

#: ../book/administration.rst:618
msgid "Setting up an instance:"
msgstr ""

#: ../book/administration.rst:620
msgid "$ ln -s /etc/tarantool/instances.available/instance-name.cfg /etc/tarantool/instances.enabled/"
msgstr ""

#: ../book/administration.rst:624
msgid "Starting all instances:"
msgstr ""

#: ../book/administration.rst:626
msgid "$ service tarantool start"
msgstr ""

#: ../book/administration.rst:630
msgid "Stopping all instances:"
msgstr ""

#: ../book/administration.rst:632
msgid "$ service tarantool stop"
msgstr ""

#: ../book/administration.rst:636
msgid "Starting/stopping one instance:"
msgstr ""

#: ../book/administration.rst:638
msgid "$ service tarantool-instance-name start/stop"
msgstr ""

#: ../book/administration.rst:644
msgid "Fedora, RHEL, CentOS"
msgstr ""

#: ../book/administration.rst:646
msgid "There are no known permanent issues. For transient issues, go to http://github.com/tarantool/tarantool/issues and enter \"RHEL\" or \"CentOS\" or \"Fedora\" or \"Red Hat\" in the search box."
msgstr ""

#: ../book/administration.rst:652
msgid "FreeBSD"
msgstr ""

#: ../book/administration.rst:654
msgid "There are no known permanent issues. For transient issues, go to http://github.com/tarantool/tarantool/issues and enter \"FreeBSD\" in the search box."
msgstr ""

#: ../book/administration.rst:660
msgid "Mac OS X"
msgstr ""

#: ../book/administration.rst:662
msgid "There are no known permanent issues. For transient issues, go to http://github.com/tarantool/tarantool/issues and enter \"OS X\" in the search box."
msgstr ""

#: ../book/administration.rst:668
msgid "Notes for systemd users"
msgstr ""

#: ../book/administration.rst:670
msgid "The Tarantool package fully supports :program:`systemd` for managing instances and supervising database daemons."
msgstr ""

#: ../book/administration.rst:675
msgid "Instance management"
msgstr ""

#: ../book/administration.rst:677
msgid "Tarantool package was designed to have multiple running instances of Tarantool on the same machine. Use :samp:`systemctl {start|stop|restart|status} tarantool@${MYAPP}` to manage your databases and Lua applications."
msgstr ""

#: ../book/administration.rst:683
msgid "creating instances"
msgstr ""

#: ../book/administration.rst:685
msgid "Simply put your Lua configuration to :file:`/etc/tarantool/instances.available/${MYAPP}.lua`:"
msgstr ""

#: ../book/administration.rst:687
msgid "box.cfg{listen = 3313}\n"
"require('myappcode').start()"
msgstr ""

#: ../book/administration.rst:692
msgid "(this minimal example is sufficient)."
msgstr ""

#: ../book/administration.rst:694
msgid "Another starting point could be the :file:`example.lua` script that ships with Tarantool and defines all options."
msgstr ""

#: ../book/administration.rst:699
msgid "starting instances"
msgstr ""

#: ../book/administration.rst:701
msgid "Use :samp:`systemctl start tarantool@${MYAPP}` to start ``${MYAPP}`` instance:"
msgstr ""

#: ../book/administration.rst:703
msgid "$ systemctl start tarantool@example\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool example.lua <running>"
msgstr ""

#: ../book/administration.rst:709
msgid "(console examples here and further on are for Fedora)."
msgstr ""

#: ../book/administration.rst:711
msgid "Use :samp:`systemctl enable tarantool@${MYAPP}` to enable ``${MYAPP}`` instance for auto-load during system startup."
msgstr ""

#: ../book/administration.rst:716
msgid "monitoring instances"
msgstr ""

#: ../book/administration.rst:718
msgid "Use :samp:`systemctl status tarantool@${MYAPP}` to check information about ``${MYAPP}`` instance:"
msgstr ""

#: ../book/administration.rst:721
msgid "$ systemctl status tarantool@example\n"
"tarantool@example.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"+ 5350 tarantool example.lua <running>"
msgstr ""

#: ../book/administration.rst:734
msgid "Use :samp:`journalctl -u tarantool@${MYAPP}` to check the boot log:"
msgstr ""

#: ../book/administration.rst:736
msgid "$ journalctl -u tarantool@example -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database Server"
msgstr ""

#: ../book/administration.rst:748
msgid "attaching to instances"
msgstr ""

#: ../book/administration.rst:750
msgid "You can attach to a running Tarantool instance and evaluate some Lua code using the :program:`tarantoolctl` utility:"
msgstr ""

#: ../book/administration.rst:753
msgid "$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/example.control>"
msgstr ""

#: ../book/administration.rst:767
msgid "checking logs"
msgstr ""

#: ../book/administration.rst:769
msgid "Tarantool logs important events to :file:`/var/log/tarantool/${MYAPP}.log`."
msgstr ""

#: ../book/administration.rst:771
msgid "Let's write something to the log file:"
msgstr ""

#: ../book/administration.rst:773
msgid "$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for README.systemd readers\")\n"
"---\n"
"..."
msgstr ""

#: ../book/administration.rst:783
msgid "Then check the logs:"
msgstr ""

#: ../book/administration.rst:785
msgid "$ tail /var/log/tarantool/example.log\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
"2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept requests\n"
"2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead UNIX socket: /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> started\n"
"2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
"2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: connected\n"
"2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README.systemd readers\n"
"2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: disconnected"
msgstr ""

#: ../book/administration.rst:799
msgid "Log rotation is enabled by default if you have :program:`logrotate` installed. Please configure :file:`/etc/logrotate.d/tarantool` to change the default behavior."
msgstr ""

#: ../book/administration.rst:804
msgid "stopping instances"
msgstr ""

#: ../book/administration.rst:806
msgid "Use :samp:`systemctl stop tarantool@${MYAPP}` to see information about the running ``${MYAPP}`` instance."
msgstr ""

#: ../book/administration.rst:809
msgid "$ systemctl stop tarantool@example"
msgstr ""

#: ../book/administration.rst:815
msgid "Daemon supervision"
msgstr ""

#: ../book/administration.rst:817
msgid "All instances are automatically restarted by :program:`systemd` in case of failure."
msgstr ""

#: ../book/administration.rst:819
msgid "Let's try to destroy an instance:"
msgstr ""

#: ../book/administration.rst:821
msgid "$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed connection"
msgstr ""

#: ../book/administration.rst:832
msgid "Now let's make sure that :program:`systemd` has revived our Tarantool instance:"
msgstr ""

#: ../book/administration.rst:834
msgid "$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""

#: ../book/administration.rst:839
msgid "Finally, let's check the boot logs:"
msgstr ""

#: ../book/administration.rst:841
msgid "$ journalctl -u tarantool@example -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database Server."
msgstr ""

#: ../book/administration.rst:856
msgid "Customizing the service file"
msgstr ""

#: ../book/administration.rst:858
msgid "Please don't modify the :file:`tarantool@.service` file in-place, because it will be overwritten during package upgrades. It is recommended to copy this file to :file:`/etc/systemd/system` and then modify the required settings. Alternatively, you can create a directory named :file:`unit.d/` within :file:`/etc/systemd/system` and put there a drop-in file :file:`name.conf` that only changes the required settings. Please see ``systemd.unit(5)`` manual page for additional information."
msgstr ""

#: ../book/administration.rst:867
msgid "Debugging"
msgstr ""

#: ../book/administration.rst:869
msgid ":program:`coredumpctl` automatically saves core dumps and stack traces in case of a crash. Here is how it works:"
msgstr ""

#: ../book/administration.rst:872
msgid "$ # !!! please never do this on the production system !!!\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed connection"
msgstr ""

#: ../book/administration.rst:882
msgid ":samp:`coredumpctl list /usr/bin/tarantool` displays the latest crashes of the Tarantool daemon:"
msgstr ""

#: ../book/administration.rst:884
msgid "$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""

#: ../book/administration.rst:891
msgid ":samp:`coredumpctl info <pid>` shows the stack trace and other useful information:"
msgstr ""

#: ../book/administration.rst:893
msgid "$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool example.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"         Unit: tarantool@example.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c _ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""

#: ../book/administration.rst:928
msgid ":samp:`coredumpctl -o filename.core info <pid>` saves the core dump into a file."
msgstr ""

#: ../book/administration.rst:930
msgid ":samp:`coredumpctl gdb <pid>` starts :program:`gdb` on the core dump."
msgstr ""

#: ../book/administration.rst:932
msgid "It is highly recommended to install the ``tarantool-debuginfo`` package to improve :program:`gdb` experience. Example:"
msgstr ""

#: ../book/administration.rst:935
msgid "$ dnf debuginfo-install tarantool"
msgstr ""

#: ../book/administration.rst:942
msgid ":program:`gdb` also provides information about the ``debuginfo`` packages you need to install:"
msgstr ""

#: ../book/administration.rst:944
msgid "$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""

#: ../book/administration.rst:955
msgid "Symbol names are present in stack traces even if you don't have the ``tarantool-debuginfo`` package installed."
msgstr ""

#: ../book/administration.rst:957
msgid "For additional information, please refer to the documentation provided with your Linux distribution."
msgstr ""

#: ../book/administration.rst:961
msgid "Precautions"
msgstr ""

#: ../book/administration.rst:963
msgid "Please don't use ``tarantoolctl {start,stop,restart}`` to control instances started by :program:`systemd`. It is still possible to use :program:`tarantoolctl` to start and stop instances from your local directories (e.g. :file:`${HOME}`) without obtaining ``ROOT`` access."
msgstr ""

#: ../book/administration.rst:967
msgid ":program:`tarantoolctl` is configured to work properly with ;program:`systemd`. Please don't modify system-wide settings of :program:`tarantoolctl`, such as paths, directory permissions and usernames. Otherwise, you have a chance to shoot yourself in the foot."
msgstr ""

#: ../book/administration.rst:971
msgid ":program:`systemd` scripts are maintained by the Tarantool Team (http://tarantool.org). Please file tickets directly to the upstream's bug tracker rather than to your Linux distribution."
msgstr ""

#: ../book/administration.rst:976
msgid "Updating Tarantool in production"
msgstr ""

#: ../book/administration.rst:978
msgid "First, put your application's business logic in a Tarantool-Lua module that exports its functions for CALL."
msgstr ""

#: ../book/administration.rst:980
msgid "For example, :file:`/usr/share/tarantool/myapp.lua`:"
msgstr ""

#: ../book/administration.rst:982
msgid "local function start()\n"
"-- Initial version\n"
"box.once(\"myapp:.1.0\", function()\n"
"box.schema.space.create(\"somedata\")\n"
"box.space.somedata:create_index(\"primary\")\n"
"...\n"
"end\n"
"\n"
"-- migration code from 1.0 to 1.1\n"
"box.once(\"myapp:.v1.1\", function()\n"
"box.space.somedata.index.primary:alter(...)\n"
"...\n"
"end\n"
"\n"
"-- migration code from 1.1 to 1.2\n"
"box.once(\"myapp:.v1.2\", function()\n"
"box.space.somedata.space:alter(...)\n"
"box.space.somedata:insert(...)\n"
"...\n"
"end\n"
"\n"
"-- start some background fibers if you need\n"
"\n"
"local function stop()\n"
"-- stop all background fibers and cleanup resources\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"-- do some business\n"
"end\n"
"\n"
"return {\n"
"start = start;\n"
"stop = stop;\n"
"api_for_call = api_for_call;\n"
"}"
msgstr ""

#: ../book/administration.rst:1021
msgid "This file is maintained by the application's developers. On its side, Tarantool Team provides templates for you to `assemble deb/rpm packages`_ and utilities to quickly `assemble packages for specific platforms`_. If needed, you can split applications into standalone files and/or modules."
msgstr ""

#: ../book/administration.rst:1030
msgid "Second, put an initialization script to the :file:`/etc/tarantool/instances.available` directory."
msgstr ""

#: ../book/administration.rst:1032
msgid "For example, :file:`/etc/tarantool/instances.available/myappcfg.lua`:"
msgstr ""

#: ../book/administration.rst:1034
msgid "#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"listen = 3301;\n"
"}\n"
"\n"
"if myapp ~= nil then\n"
"-- hot code reload using tarantoolctl or dofile()\n"
"\n"
"-- unload old application\n"
"myapp.stop()\n"
"-- clear cache for loaded modules and dependencies\n"
"package.loaded['myapp'] = nil\n"
"package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
"end\n"
"\n"
"-- load a new version of app and all dependencies\n"
"myapp = require('myapp').start({some app options controlled by sysadmins})"
msgstr ""

#: ../book/administration.rst:1056
msgid "As a more detailed example, you can take the :file:`example.lua` script that ships with Tarantool and defines all configuration options."
msgstr ""

#: ../book/administration.rst:1059
msgid "This initialization script is actually a configuration file and should be maintained by system administrators, while developers only provide a template."
msgstr ""

#: ../book/administration.rst:1063
msgid "Now update your app file in :file:`/usr/share/tarantool`. Replace your application file (for example, :file:`/usr/share/tarantool/myapp.lua`) and manually reload the :file:`myappcfg.lua` initialization script using :program:`tarantoolctl`:"
msgstr ""

#: ../book/administration.rst:1067
msgid "$ tarantoolctl eval /etc/tarantool/instance.enabled/myappcfg.lua"
msgstr ""

#: ../book/administration.rst:1071
msgid "After that, you need to manually flush the cache of ``package.loaded`` modules."
msgstr ""

#: ../book/administration.rst:1073
msgid "For deb/rpm packages, you can add the ``tarantoolctl eval`` instruction directly into Tarantool's specification in :file:`RPM.spec` and the :file:`/debian` directory."
msgstr ""

#: ../book/administration.rst:1076
msgid "Finally, clients make a CALL to ``myapp.api_for_call`` and other API functions."
msgstr ""

#: ../book/administration.rst:1078
msgid "In the case of ``tarantool-http``, there is no need to start the binary protocol at all."
msgstr ""

#: ../book/administration.rst:1084
msgid "Modules, LuaRocks, and requiring packages"
msgstr ""

#: ../book/administration.rst:1086
msgid "To extend Tarantool there are packages, which are also called \"modules\", which in Lua are also called \"rocks\". Users who are unfamiliar with Lua modules may benefit from following the Lua-Modules-Tutorial_ before reading this section."
msgstr ""

#: ../book/administration.rst:1092
msgid "**Install a module**"
msgstr ""

#: ../book/administration.rst:1094
msgid "The modules that come from Tarantool developers and community contributors are on rocks.tarantool.org_. Some of them -- :ref:`expirationd <expirationd-package>`, :ref:`mysql <dbms_packages-mysql-example>`, :ref:`postgresql <dbms_packages-postgresql-example>`, :ref:`shard <shard-package>` -- are discussed elsewhere in this manual."
msgstr ""

#: ../book/administration.rst:1102
msgid "Step 1: Install LuaRocks. A general description for installing LuaRocks on a Unix system is in the LuaRocks-Quick-Start-Guide_. For example on Ubuntu one could say: |br| :codenormal:`$` :codebold:`sudo apt-get install luarocks`"
msgstr ""

#: ../book/administration.rst:1108
msgid "Step 2: Add the Tarantool repository to the list of rocks servers. This is done by putting rocks.tarantool.org in the .luarocks/config.lua file: |br| :codenormal:`$` :codebold:`mkdir ~/.luarocks` |br| :codenormal:`$` :codebold:`echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> ~/.luarocks/config.lua` |br|"
msgstr ""

#: ../book/administration.rst:1113
msgid "Once these steps are complete, the repositories can be searched with |br| :codenormal:`$` :codebold:`luarocks search` :codeitalic:`module-name` |br| and new modules can be added to the local repository with |br| :codenormal:`$` :codebold:`luarocks install` :codeitalic:`module-name` :codenormal:`--local` |br| and any package/module can be loaded for Tarantool with |br| :codenormal:`tarantool>` :codeitalic:`local-name` :codenormal:`=` :codebold:`require('`:codeitalic:`module-name`:codenormal:`')` |br| ... and that is why the examples in the manual's Packages section often begin with `require` requests. See rocks_ on github.com/tarantool for more examples and information about contributing."
msgstr ""

#: ../book/administration.rst:1123
msgid "**Example: making a new Lua module locally**"
msgstr ""

#: ../book/administration.rst:1125
msgid "In this example, create a new Lua file named `mymodule.lua`, containing a named function which will be exported. Then, in Tarantool: load, examine, and call."
msgstr ""

#: ../book/administration.rst:1129
msgid "The Lua file should look like this:"
msgstr ""

#: ../book/administration.rst:1131
msgid "-- mymodule - a simple Tarantool module\n"
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"    print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""

#: ../book/administration.rst:1140
msgid "The requests to load and examine and call look like this: |br| :codenormal:`tarantool>`:codebold:`mymodule = require('mymodule')` |br| :codenormal:`>---` |br| :codenormal:`>...` |br| |br| :codenormal:`tarantool>`:codebold:`mymodule` |br| :codenormal:`---` |br| :codenormal:`>- myfun: 'function: 0x405edf20'` |br| :codenormal:`>...` |br| :codenormal:`tarantool>`:codebold:`mymodule.myfun(os.getenv('USER'))` |br| :codenormal:`Hello world` |br| :codenormal:`>---` |br| :codenormal:`>...`"
msgstr ""

#: ../book/administration.rst:1154
msgid "**Example: making a new C/C++ module locally**"
msgstr ""

#: ../book/administration.rst:1156
msgid "In this example, create a new C file named `mycmodule.c`, containing a named function which will be exported. Then, in Tarantool: load, examine, and call."
msgstr ""

#: ../book/administration.rst:1160
msgid "Prerequisite: install `tarantool-dev` first."
msgstr ""

#: ../book/administration.rst:1162
msgid "The C file should look like this:"
msgstr ""

#: ../book/administration.rst:1164
msgid "/* mycmodule - a simple Tarantool module */\n"
"#include <lua.h>\n"
"#include <lauxlib.h>\n"
"#include <lualib.h>\n"
"#include <tarantool.h>\n"
"static int\n"
"myfun(lua_State *L)\n"
"{\n"
"    if (lua_gettop(L) < 1)\n"
"        return luaL_error(L, \"Usage: myfun(name)\");\n"
"\n"
"    /* Get first argument */\n"
"    const char *name = lua_tostring(L, 1);\n"
"\n"
"    /* Push one result to Lua stack */\n"
"    lua_pushfstring(L, \"Hello, %s\", name);\n"
"    return 1; /* the function returns one result */\n"
"}\n"
"LUA_API int\n"
"luaopen_mycmodule(lua_State *L)\n"
"{\n"
"    static const struct luaL_reg reg[] = {\n"
"        { \"myfun\", myfun },\n"
"        { NULL, NULL }\n"
"    };\n"
"    luaL_register(L, \"mycmodule\", reg);\n"
"    return 1;\n"
"}"
msgstr ""

#: ../book/administration.rst:1195
msgid "Use :codenormal:`gcc` to compile the code for a shared library (without a \"lib\" prefix), then use :codenormal:`ls` to examine it: |br|"
msgstr ""

#: ../book/administration.rst:1198
msgid ":codenormal:`$` :codebold:`gcc mycmodule.c -shared -fPIC -I/usr/include/tarantool -o mycmodule.so` |br| :codenormal:`$` :codebold:`ls mycmodule.so -l` |br| :codenormal:`-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so`"
msgstr ""

#: ../book/administration.rst:1202
msgid "Tarantool's developers recommend use of Tarantool's CMake-scripts_ which will handle some of the build steps automatically."
msgstr ""

#: ../book/administration.rst:1205
msgid "The requests to load and examine and call look like this: |br| :codenormal:`tarantool>`:codebold:`mymodule = require('mymodule')` |br| :codenormal:`---` |br| :codenormal:`...` |br| :codenormal:`tarantool>`:codebold:`mymodule` |br| :codenormal:`---` |br| :codenormal:`- myfun: 'function: 0x4100ec98'` |br| :codenormal:`...` |br| :codenormal:`tarantool>`:codebold:`mycmodule.myfun(os.getenv('USER'))` |br| :codenormal:`---` |br| :codenormal:`- Hello, world` |br| :codenormal:`...` |br|"
msgstr ""

#: ../book/administration.rst:1218
msgid "One can also make modules with C++, provided that the code does not throw exceptions."
msgstr ""

#: ../book/administration.rst:1220
msgid "**Tips for special situations**"
msgstr ""

#: ../book/administration.rst:1222
msgid "Lua caches all loaded modules in the :code:`package.loaded` table. To reload a module from disk, set its key to `nil`: |br| :codenormal:`tarantool>` :codebold:`package.loaded['`:codeitalic:`modulename`:codebold:`'] = nil`"
msgstr ""

#: ../book/administration.rst:1226
msgid "Use ``package.path`` to search for ``.lua`` modules, and use ``package.cpath`` to search for C binary modules. |br| :codenormal:`tarantool>`:codebold:`package.path` |br| :codenormal:`---` |br| :codenormal:`- ./?.lua;./?/init.lua;/home/roman/.luarocks/share/lua/5.1/?.lua;/home/roman/.luarocks/share/lua/5.1/?/init.lua;/home/roman/.luarocks/share/lua/?.lua;/home/roman/.luarocks/share/lua/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/init.lua;./?.lua;/usr/local/share/luajit-2.0.3/?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua` |br| :codenormal:`...` :codenormal:`tarantool>`:codebold:`package.cpath` |br| :codenormal:`---` |br| :codenormal:`- ./?.so;/home/roman/.luarocks/lib/lua/5.1/?.so;/home/roman/.luarocks/lib/lua/?.so;/usr/lib/tarantool/?.so;./?.so;/usr/local/lib/lua/5.1/?.so;/usr/local/lib/lua/5.1/loadall.so` |br| :codenormal:`...` |br| Substitute question-mark with :code:`modulename` when calling :code:`require('modulename')`."
msgstr ""

#: ../book/administration.rst:1239
msgid "To see the internal state from within a Lua module, use `state` and create a local variable inside the scope of the file:"
msgstr ""

#: ../book/administration.rst:1242
msgid "-- mymodule\n"
"local exports = {}\n"
"local state = {}\n"
"exports.myfun = function()\n"
"    state.x = 42 -- use state\n"
"end\n"
"return exports"
msgstr ""

#: ../book/administration.rst:1252
msgid "Notice that the Lua examples use local variables. Use global variables with caution, since the module's users may be unaware of them."
msgstr ""

#: ../book/administration.rst:1256
msgid "To see a sample Lua + C module, go to http_ on github.com/tarantool."
msgstr ""

#: ../book/administration.rst:1260
msgid "Backups"
msgstr ""

#: ../book/administration.rst:1262
msgid "The exact procedure for backing up a database depends on: how up-to-date the database must be, how frequently backups must be taken, whether it is okay to disrupt other users, and whether the procedure should be optimized for size (saving disk space) or for speed (saving time). So there is a spectrum of possible policies, ranging from cold-and-simple to hot-and-difficult."
msgstr ""

#: ../book/administration.rst:1269
msgid "**Cold Backup**"
msgstr ""

#: ../book/administration.rst:1271
msgid "In essence: The last snapshot file is a backup of the entire database; and the WAL files that are made after the last snapshot are incremental backups. Therefore taking a backup is a matter of copying the snapshot and WAL files. |br| (1) Prevent all users from writing to the database.This can be done by shutting down the server, or by saying :codenormal:`box.cfg{read_only=true}` and then ensuring that all earlier writes are complete (fsync can be used for this purpose). |br| (2) If this is a backup of the whole database, say :codenormal:`box.snapshot()`. |br| (3) Use tar to make a (possibly compressed) copy of the latest .snap and .xlog files on the :ref:`snap_dir <cfg_basic-snap_dir>` and :ref:`wal_dir <cfg_basic-wal_dir>` directories. |br| (4) If there is a security policy, encrypt the tar file. |br| (5) Copy the tar file to a safe place. |br| ... Later, restoring the database is a matter of taking the tar file and putting its contents back in the snap_dir and wal_dir directories."
msgstr ""

#: ../book/administration.rst:1290
msgid "**Continuous remote backup**"
msgstr ""

#: ../book/administration.rst:1292
msgid "In essence: :ref:`replication <index-box_replication>` is useful for backup as well as for load balancing. Therefore taking a backup is a matter of ensuring that any given replica is up to date, and doing a cold backup on it. Since all the other replicas continue to operate, this is not a cold backup from the end user's point of view. This could be done on a regular basis, with a cron job or with a Tarantool fiber."
msgstr ""

#: ../book/administration.rst:1300
msgid "**Hot backup**"
msgstr ""

#: ../book/administration.rst:1302
msgid "In essence: The logged changes done since the last cold backup must be secured, while the system is running."
msgstr ""

#: ../book/administration.rst:1306
msgid "For this purpose one needs a \"file copy\" utility that will do the copying remotely and continuously, copying only the parts of a file that are changing. One such utility is rsync_."
msgstr ""

#: ../book/administration.rst:1311
msgid "Alternatively, one needs an ordinary file copy utility, but there should be frequent production of new snapshot files or new WAL files as changes occur, so that only the new files need to be copied."
msgstr ""

#: ../book/administration.rst:1316
msgid "Note re storage engines: vinyl databases require additional steps."
msgstr ""

#: ../book/administration.rst:1320
msgid "Upgrades"
msgstr ""

#: ../book/administration.rst:1322
msgid "This information applies for users who created databases with older versions of the Tarantool server, and have now installed a newer version. The request to make in this case is: :codenormal:`box.schema.upgrade()`."
msgstr ""

#: ../book/administration.rst:1326
msgid "For example, here is what happens when one runs :codenormal:`box.schema.upgrade()` with a database that was created in early 2015. Only a small part of the output is shown. |br| :codenormal:`tarantool>` :codebold:`box.schema.upgrade()` |br| :codenormal:`alter index primary on _space set options to {\"unique\":true}, parts to [[0,\"num\"]]` |br| :codenormal:`alter space _schema set options to {}` |br| :codenormal:`create view _vindex...` |br| :codenormal:`grant read access to 'public' role for _vindex view` |br| :codenormal:`set schema version to 1.7.0` |br| :codenormal:`---` |br| :codenormal:`...` |br|"
msgstr ""

#: ../book/app/a_errcodes.rst:28
msgid "Appendix A. List of error codes"
msgstr ""

#: ../book/app/a_errcodes.rst:30
msgid "In the current version of the binary protocol, error message, which is normally more descriptive than error code, is not present in server response. The actual message may contain a file name, a detailed reason or operating system error code. All such messages, however, are logged in the error log. Below follow only general descriptions of some popular codes. A complete list of errors can be found in file `errcode.h`_ in the source tree."
msgstr ""

#: ../book/app/a_errcodes.rst:41
msgid "**List of error codes**"
msgstr ""

#: ../book/app/a_errcodes.rst:47
msgid "ER_NONMASTER"
msgstr ""

#: ../book/app/a_errcodes.rst:47
msgid "Can't modify data on a replication slave."
msgstr ""

#: ../book/app/a_errcodes.rst:49
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../book/app/a_errcodes.rst:49
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../book/app/a_errcodes.rst:52
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../book/app/a_errcodes.rst:52
msgid "Out of memory: :ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` limit has been reached."
msgstr ""

#: ../book/app/a_errcodes.rst:56
msgid "ER_WAL_IO"
msgstr ""

#: ../book/app/a_errcodes.rst:56
msgid "Failed to write to disk. May mean: failed to record a change in the write-ahead log. Some sort of disk error."
msgstr ""

#: ../book/app/a_errcodes.rst:60
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../book/app/a_errcodes.rst:60
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../book/app/a_errcodes.rst:63
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../book/app/a_errcodes.rst:63
msgid "The specified space does not exist."
msgstr ""

#: ../book/app/a_errcodes.rst:66
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../book/app/a_errcodes.rst:66
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../book/app/a_errcodes.rst:69
msgid "ER_PROC_LUA"
msgstr ""

#: ../book/app/a_errcodes.rst:69
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../book/app/a_errcodes.rst:72
msgid "ER_FIBER_STACK"
msgstr ""

#: ../book/app/a_errcodes.rst:72
msgid "The recursion limit was reached when creating a new fiber. This usually indicates that a stored procedure is recursively invoking itself too often."
msgstr ""

#: ../book/app/a_errcodes.rst:77
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../book/app/a_errcodes.rst:77
msgid "An error occurred during update of a field."
msgstr ""

#: ../book/app/a_errcodes.rst:80
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../book/app/a_errcodes.rst:80
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../book/app/b_internals.rst:30
msgid "Appendix B. Internals"
msgstr ""

#: ../book/app/b_internals.rst:32
msgid "This section is for advanced users or users who wish to know more about how the Tarantool program works. The discussion here is technical but generalized. The ultimate authority is the code."
msgstr ""

#: ../book/app/b_internals.rst:39
msgid "Data persistence and the WAL file format"
msgstr ""

#: ../book/app/b_internals.rst:41
msgid "To maintain data persistence, Tarantool writes each data change request (INSERT, UPDATE, DELETE, REPLACE) into a write-ahead log (WAL) file in the :ref:`wal_dir <cfg_basic-wal_dir>` directory. A new WAL file is created for every :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>` records. Each data change request gets assigned a continuously growing 64-bit log sequence number. The name of the WAL file is based on the log sequence number of the first record in the file, plus an extension ``.xlog``."
msgstr ""

#: ../book/app/b_internals.rst:49
msgid "Apart from a log sequence number and the data change request (its format is the same as in the binary protocol and is described in `doc/dev_guide/box-protocol.html`_), each WAL record contains a header, some metadata, and then the data formatted according to `msgpack`_ rules. For example this is what the WAL file looks like after the first INSERT request (\"s:insert({1})\") for the introductory sandbox exercise \":ref:`Starting Tarantool and making your first database <user_guide_getting_started-first_database>` . On the left are the hexadecimal bytes that one would see with:"
msgstr ""

#: ../book/app/b_internals.rst:57
msgid "$ hexdump 00000000000000000000.xlog"
msgstr ""

#: ../book/app/b_internals.rst:61
msgid "and on the right are comments."
msgstr ""

#: ../book/app/b_internals.rst:63
msgid "Hex dump of WAL file       Comment\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             File header: \"XLOG\\n\"\n"
"30 2e 31 32 0a             File header: \"0.12\\n\" = version\n"
"...                        (not shown = more header + tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5 if version 0.12\n"
"19 00                      Length, not including length of header, = 25 bytes\n"
"ce 16 a4 38 6f             Record header: previous crc32, current crc32,\n"
"a7 cc 73 7f 00 00 66 39\n"
"84                         msgpack code meaning \"Map of 4 elements\" follows\n"
"00 02                         element#1: tag=request type, value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte \"Double\"\n"
"82                         msgpack code meaning \"map of 2 elements\" follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big byte first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed array={1}"
msgstr ""

#: ../book/app/b_internals.rst:83
msgid "Tarantool processes requests atomically: a change is either accepted and recorded in the WAL, or discarded completely. Let's clarify how this happens, using the REPLACE request as an example:"
msgstr ""

#: ../book/app/b_internals.rst:87
msgid "The server attempts to locate the original tuple by primary key. If found, a reference to the tuple is retained for later use."
msgstr ""

#: ../book/app/b_internals.rst:90
msgid "The new tuple is validated. If for example it does not contain an indexed field, or it has an indexed field whose type does not match the type according to the index definition, the change is aborted."
msgstr ""

#: ../book/app/b_internals.rst:94
msgid "The new tuple replaces the old tuple in all existing indexes."
msgstr ""

#: ../book/app/b_internals.rst:96
msgid "A message is sent to WAL writer running in a separate thread, requesting that the change be recorded in the WAL. The server switches to work on the next request until the write is acknowledged."
msgstr ""

#: ../book/app/b_internals.rst:100
msgid "On success, a confirmation is sent to the client. On failure, a rollback procedure is begun. During the rollback procedure, the transaction processor rolls back all changes to the database which occurred after the first failed change, from latest to oldest, up to the first failed change. All rolled back requests are aborted with :errcode:`ER_WAL_IO <ER_WAL_IO>` error. No new change is applied while rollback is in progress. When the rollback procedure is finished, the server restarts the processing pipeline."
msgstr ""

#: ../book/app/b_internals.rst:108
msgid "One advantage of the described algorithm is that complete request pipelining is achieved, even for requests on the same value of the primary key. As a result, database performance doesn't degrade even if all requests refer to the same key in the same space."
msgstr ""

#: ../book/app/b_internals.rst:113
msgid "The transaction processor thread communicates with the WAL writer thread using asynchronous (yet reliable) messaging; the transaction processor thread, not being blocked on WAL tasks, continues to handle requests quickly even at high volumes of disk I/O. A response to a request is sent as soon as it is ready, even if there were earlier incomplete requests on the same connection. In particular, SELECT performance, even for SELECTs running on a connection packed with UPDATEs and DELETEs, remains unaffected by disk load."
msgstr ""

#: ../book/app/b_internals.rst:121
msgid "The WAL writer employs a number of durability modes, as defined in configuration variable :ref:`wal_mode <index-wal_mode>`. It is possible to turn the write-ahead log completely off, by setting :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` to *none*. Even without the write-ahead log it's still possible to take a persistent copy of the entire data set with the :ref:`box.snapshot() <admin-snapshot>` request."
msgstr ""

#: ../book/app/b_internals.rst:127
msgid "An .xlog file always contains changes based on the primary key. Even if the client requested an update or delete using a secondary key, the record in the .xlog file will contain the primary key."
msgstr ""

#: ../book/app/b_internals.rst:133
msgid "The snapshot file format"
msgstr ""

#: ../book/app/b_internals.rst:135
msgid "The format of a snapshot .snap file is nearly the same as the format of a WAL .xlog file. However, the snapshot header differs: it contains the server's global unique identifier and the snapshot file's position in history, relative to earlier snapshot files. Also, the content differs: an .xlog file may contain records for any data-change requests (inserts, updates, upserts, and deletes), a .snap file may only contain records of inserts to memtx spaces."
msgstr ""

#: ../book/app/b_internals.rst:142
msgid "Primarily, the .snap file's records are ordered by space id. Therefore the records of system spaces, such as _schema and _space and _index and _func and _priv and _cluster, will be at the start of the .snap file, before the records of any spaces that were created by users."
msgstr ""

#: ../book/app/b_internals.rst:147
msgid "Secondarily, the .snap file's records are ordered by primary key within space id."
msgstr ""

#: ../book/app/b_internals.rst:151
msgid "The Recovery Process"
msgstr ""

#: ../book/app/b_internals.rst:153
msgid "The recovery process begins when box.cfg{} happens for the first time after the Tarantool server starts."
msgstr ""

#: ../book/app/b_internals.rst:156
msgid "The recovery process must recover the databases as of the moment when the server was last shut down. For this it may use the latest snapshot file and any WAL files that were written after the snapshot. One complicating factor is that Tarantool has two engines -- the memtx data must be reconstructed entirely from the snapshot and the WAL files, while the vinyl data will be on disk but might require updating around the time of a checkpoint. (When a snapshot happens, Tarantool tells the vinyl engine to make a checkpoint, and the snapshot operation is rolled back if anything goes wrong, so vinyl's checkpoint is at least as fresh as the snapshot file.)"
msgstr ""

#: ../book/app/b_internals.rst:173
msgid "Step 1"
msgstr ""

#: ../book/app/b_internals.rst:169
msgid "Read the configuration parameters in the ``box.cfg{}`` request. Parameters which affect recovery may include :ref:`work_dir <cfg_basic-work_dir>`, :ref:`wal_dir <cfg_basic-wal_dir>`, :ref:`snap_dir <cfg_basic-snap_dir>`, :ref:`vinyl_dir <cfg_basic-vinyl_dir>`, :ref:`panic_on_snap_error <cfg_binary_logging_snapshots-panic_on_snap_error>`, and :ref:`panic_on_wal_error <cfg_binary_logging_snapshots-panic_on_wal_error>`."
msgstr ""

#: ../book/app/b_internals.rst:177
#: ../book/app/b_internals.rst:199
msgid "Step 2"
msgstr ""

#: ../book/app/b_internals.rst:176
msgid "Find the latest snapshot file. Use its data to reconstruct the in-memory databases. Instruct the vinyl engine to recover to the latest checkpoint."
msgstr ""

#: ../book/app/b_internals.rst:179
msgid "There are actually two variations of the reconstruction procedure for the memtx databases, depending whether the recovery process is \"default\"."
msgstr ""

#: ../book/app/b_internals.rst:182
msgid "If it is default (``panic_on_snap_error`` is ``true`` and ``panic_on_wal_error`` is ``true``), memtx can read data in the snapshot with all indexes disabled. First, all tuples are read into memory. Then, primary keys are built in bulk, taking advantage of the fact that the data is already sorted by primary key within each space."
msgstr ""

#: ../book/app/b_internals.rst:188
msgid "If it is not default (``panic_on_snap_error`` is ``false`` or ``panic_on_wal_error`` is ``false``), Tarantool performs additional checking. Indexes are enabled at the start, and tuples are added one by one. This means that any unique-key constraint violations will be caught, and any duplicates will be skipped. Normally there will be no constraint violations or duplicates, so these checks are only made if an error has occurred."
msgstr ""

#: ../book/app/b_internals.rst:196
msgid "Find the WAL file that was made at the time of, or after, the snapshot file. Read its log entries until the log-entry LSN is greater than the LSN of the snapshot, or greater than the LSN of the vinyl checkpoint. This is the recovery process's \"start position\"; it matches the current state of the engines."
msgstr ""

#: ../book/app/b_internals.rst:203
msgid "Step 3"
msgstr ""

#: ../book/app/b_internals.rst:202
msgid "Redo the log entries, from the start position to the end of the WAL. The engine skips a redo instruction if it is older than the engine's checkpoint."
msgstr ""

#: ../book/app/b_internals.rst:206
msgid "Step 4"
msgstr ""

#: ../book/app/b_internals.rst:206
msgid "For the memtx engine, re-create all secondary indexes."
msgstr ""

#: ../book/app/b_internals.rst:212
msgid "Server Startup With Replication"
msgstr ""

#: ../book/app/b_internals.rst:214
msgid "In addition to the recovery process described above, the server must take additional steps and precautions if :ref:`replication <index-box_replication>` is enabled."
msgstr ""

#: ../book/app/b_internals.rst:218
msgid "Once again the startup procedure is initiated by the ``box.cfg{}`` request. One of the box.cfg parameters may be :ref:`replication_source <cfg_replication-replication_source>`. We will refer to this server, which is starting up due to box.cfg, as the \"local\" server to distinguish it from the other servers in a cluster, which we will refer to as \"distant\" servers."
msgstr ""

#: ../book/app/b_internals.rst:224
msgid "*If there is no snapshot .snap file and replication_source is empty*: |br| then the local server assumes it is an unreplicated \"standalone\" server, or is the first server of a new replication cluster. It will generate new UUIDs for itself and for the cluster. The server UUID is stored in the _cluster space; the cluster UUID is stored in the _schema space. Since a snapshot contains all the data in all the spaces, that means the local server's snapshot will contain the server UUID and the cluster UUID. Therefore, when the local server restarts on later occasions, it will be able to recover these UUIDs when it reads the .snap file."
msgstr ""

#: ../book/app/b_internals.rst:234
msgid "*If there is no snapshot .snap file and replication_source is not empty and the _cluster space contains no other server UUIDs*: |br| then the local server assumes it is not a standalone server, but is not yet part of a cluster. It must now join the cluster. It will send its server UUID to the first distant server which is listed in replication_source, which will act as a master. This is called the \"join request\". When a distant server receives a join request, it will send back:"
msgstr ""

#: ../book/app/b_internals.rst:242
msgid "the distant server's cluster UUID,"
msgstr ""

#: ../book/app/b_internals.rst:243
msgid "the contents of the distant server's .snap file. |br| When the local server receives this information, it puts the cluster UUID in its _schema space, puts the distant server's UUID and connection information in its _cluster space, and makes a snapshot containing all the data sent by the distant server. Then, if the local server has data in its WAL .xlog files, it sends that data to the distant server. The distant server will receive this and update its own copy of the data, and add the local server's UUID to its _cluster space."
msgstr ""

#: ../book/app/b_internals.rst:252
msgid "*If there is no snapshot .snap file and replication_source is not empty and the _cluster space contains other server UUIDs*: |br| then the local server assumes it is not a standalone server, and is already part of a cluster. It will send its server UUID and cluster UUID to all the distant servers which are listed in replication_source. This is called the \"on-connect handshake\". When a distant server receives an on-connect handshake: |br|"
msgstr ""

#: ../book/app/b_internals.rst:259
msgid "the distant server compares its own copy of the cluster UUID to the one in the on-connect handshake. If there is no match, then the handshake fails and the local server will display an error."
msgstr ""

#: ../book/app/b_internals.rst:262
msgid "the distant server looks for a record of the connecting instance in its _cluster space. If there is none, then the handshake fails. |br| Otherwise the handshake is successful. The distant server will read any new information from its own .snap and .xlog files, and send the new requests to the local server."
msgstr ""

#: ../book/app/b_internals.rst:268
msgid "In the end ... the local server knows what cluster it belongs to, the distant server knows that the local server is a member of the cluster, and both servers have the same database contents."
msgstr ""

#: ../book/app/b_internals.rst:272
msgid "*If there is a snapshot file and replication source is not empty*: |br| first the local server goes through the recovery process described in the previous section, using its own .snap and .xlog files. Then it sends a \"subscribe\" request to all the other servers of the cluster. The subscribe request contains the server vector clock. The vector clock has a collection of pairs 'server id, lsn' for every server in the _cluster system space. Each distant server, upon receiving a subscribe request, will read its .xlog files' requests and send them to the local server if (lsn of .xlog file request) is greater than (lsn of the vector clock in the subscribe request). After all the other servers of the cluster have responded to the local server's subscribe request, the server startup is complete."
msgstr ""

#: ../book/app/b_internals.rst:284
msgid "The following temporary limitations apply for version 1.7:"
msgstr ""

#: ../book/app/b_internals.rst:286
msgid "The URIs in replication_source should all be in the same order on all servers. This is not mandatory but is an aid to consistency."
msgstr ""

#: ../book/app/b_internals.rst:288
msgid "The servers of a cluster should be started up at slightly different times. This is not mandatory but prevents a situation where each server is waiting for the other server to be ready."
msgstr ""

#: ../book/app/b_internals.rst:291
msgid "The maximum number of entries in the _cluster space is 32. Tuples for out-of-date replicas are not automatically re-used, so if this 32-replica limit is reached, users may have to reorganize the _cluster space manually."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:29
msgid "Appendix C. Lua tutorials"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:31
msgid "There are three tutorials: :ref:`Insert one million tuples with a Lua stored procedure <c_lua_tutorial-insert_one_million_tuples>`, :ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>`, :ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>`."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:40
msgid "Insert one million tuples with a Lua stored procedure"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:42
msgid "This is an exercise assignment: Insert one million tuples. Each tuple should have a constantly-increasing numeric primary-key field and a random alphabetic 10-character string field."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:46
msgid "The purpose of the exercise is to show what Lua functions look like inside Tarantool. It will be necessary to employ the Lua math library, the Lua string library, the Tarantool box library, the Tarantool box.tuple library, loops, and concatenations. It should be easy to follow even for a person who has not used either Lua or Tarantool before. The only requirement is a knowledge of how other programming languages work and a memory of the first two chapters of this manual. But for better understanding, follow the comments and the links, which point to the Lua manual or to elsewhere in this Tarantool manual. To further enhance learning, type the statements in with the tarantool client while reading along."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:58
msgid "Configure"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:60
msgid "We are going to use the \"tarantool_sandbox\" that was created in section :ref:`first database <user_guide_getting_started-first_database>`. So there is a single space, and a numeric primary key, and a running tarantool server which also serves as a client."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:66
msgid "Delimiter"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:68
msgid "In earlier versions of Tarantool, multi-line functions had to be enclosed within \"delimiters\". They are no longer necessary, and so they will not be used in this tutorial. However, they are still supported. Users who wish to use delimiters, or users of older versions of Tarantool, should check the syntax description for :ref:`declaring a delimiter <administration-setting_delimiter>` before proceeding."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:77
msgid "Create a function that returns a string"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:79
msgid "We will start by making a function that returns a fixed string, Hello world."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:81
msgid "function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:87
msgid "The word \"``function``\" is a Lua keyword -- we're about to go into Lua. The function name is string_function. The function has one executable statement, ``return \"hello world\"``. The string \"hello world\" is enclosed in double quotes here, although Lua doesn't care -- one could use single quotes instead. The word \"``end``\" means this is the end of the Lua function declaration. To confirm that the function works, we can say"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:94
msgid "string_function()"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:98
msgid "Sending ``function-name()`` means invoke the Lua function. The effect is that the string which the function returns will end up on the screen."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:101
msgid "For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . For more about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:107
#: ../book/app/c_lua_tutorial.rst:151
#: ../book/app/c_lua_tutorial.rst:203
#: ../book/app/c_lua_tutorial.rst:259
#: ../book/app/c_lua_tutorial.rst:306
#: ../book/app/c_lua_tutorial.rst:364
#: ../book/app/c_lua_tutorial.rst:455
#: ../book/replication/index.rst:923
msgid "The screen now looks like this:"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:109
msgid "tarantool> function string_funciton()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:124
msgid "Create a function that calls another function and sets a variable"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:126
msgid "Now that ``string_function`` exists, we can invoke it from another function."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:129
msgid "function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:137
msgid "We begin by declaring a variable \"``string_value``\". The word \"``local``\" means that string_value appears only in ``main_function``. If we didn't use \"``local``\" then ``string_value`` would be visible everywhere - even by other users using other clients connected to this server! Sometimes that's a very desirable feature for inter-client communication, but not this time."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:143
msgid "Then we assign a value to ``string_value``, namely, the result of ``string_function()``. Soon we will invoke ``main_function()`` to check that it got the value."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:147
msgid "For more about Lua variables see Lua manual `chapter 4.2 \"Local Variables and Blocks\"`_ ."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:153
msgid "tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:170
msgid "Modify the function so it returns a one-letter random string"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:172
msgid "Now that it's a bit clearer how to make a variable, we can change ``string_function()`` so that, instead of returning a fixed literal 'Hello world\", it returns a random letter between 'A' and 'Z'."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:176
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:186
msgid "It is not necessary to destroy the old ``string_function()`` contents, they're simply overwritten. The first assignment invokes a random-number function in Lua's math library; the parameters mean the number must be an integer between 65 and 90. The second assignment invokes an integer-to-character function in Lua's string library; the parameter is the code point of the character. Luckily the ASCII value of 'A' is 65 and the ASCII value of 'Z' is 90 so the result will always be a letter between A and Z."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:194
msgid "For more about Lua math-library functions see Lua users \"`Math Library Tutorial`_\". For more about Lua string-library functions see Lua users \"`String Library Tutorial`_\" ."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:200
msgid "Once again the ``string_function()`` can be invoked from main_function() which can be invoked with ``main_function()``."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:205
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:222
msgid "... Well, actually it won't always look like this because ``math.random()`` produces random numbers. But for the illustration purposes it won't matter what the random string values are."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:228
msgid "Modify the function so it returns a ten-letter random string"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:230
msgid "Now that it's clear how to produce one-letter random strings, we can reach our goal of producing a ten-letter string by concatenating ten one-letter strings, in a loop."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:234
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:247
msgid "The words \"for x = 1,10,1\" mean start with x equals 1, loop until x equals 10, increment x by 1 for each iteration. The symbol \"..\" means \"concatenate\", that is, add the string on the right of the \"..\" sign to the string on the left of the \"..\" sign. Since we start by saying that random_string is \"\" (a blank string), the end result is that random_string has 10 random letters. Once again the ``string_function()`` can be invoked from ``main_function()`` which can be invoked with ``main_function()``."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:255
msgid "For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:261
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:284
msgid "Make a tuple out of a number and a string"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:286
msgid "Now that it's clear how to make a 10-letter random string, it's possible to make a tuple that contains a number and a 10-letter random string, by invoking a function in Tarantool's library of Lua functions."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:290
msgid "function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:299
msgid "Once this is done, t will be the value of a new tuple which has two fields. The first field is numeric: 1. The second field is a random string. Once again the ``string_function()`` can be invoked from ``main_function()`` which can be invoked with  ``main_function()``."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:304
msgid "For more about Tarantool tuples see Tarantool manual section :ref:`Package box.tuple <box_tuple>`."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:308
msgid "tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:326
msgid "Modify main_function to insert a tuple into the database"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:328
msgid "Now that it's clear how to make a tuple that contains a number and a 10-letter random string, the only trick remaining is putting that tuple into tester. Remember that tester is the first space that was defined in the sandbox, so it's like a database table."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:333
msgid "function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:342
msgid "The new line here is ``box.space.tester:replace(t)``. The name contains 'tester' because the insertion is going to be to tester. The second parameter is the tuple value. To be perfectly correct we could have said ``box.space.tester:insert(t)`` here, rather than ``box.space.tester:replace(t)``, but \"replace\" means insert even if there is already a tuple whose primary-key value is a duplicate, and that makes it easier to re-run the exercise even if the sandbox database isn't empty. Once this is done, tester will contain a tuple with two fields. The first field will be 1. The second field will be a random 10-letter string. Once again the ``string_function(``) can be invoked from ``main_function()`` which can be invoked with ``main_function()``. But ``main_function()`` won't tell the whole story, because it does not return t, it only puts t into the database. To confirm that something got inserted, we'll use a SELECT request."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:356
msgid "main_function()\n"
"box.space.tester:select{1}"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:361
msgid "For more about Tarantool insert and replace calls, see Tarantool manual section :ref:`Package box.space <box_space>`."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:366
msgid "tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:387
msgid "Modify main_function to insert a million tuples into the database"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:389
msgid "Now that it's clear how to insert one tuple into the database, it's no big deal to figure out how to scale up: instead of inserting with a literal value = 1 for the primary key, insert with a variable value = between 1 and 1 million, in a loop. Since we already saw how to loop, that's a simple thing. The only extra wrinkle that we add here is a timing function."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:395
msgid "function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:410
msgid "The :ref:`os.clock() <os-clock>` function will return the number of CPU seconds since the start. Therefore, by getting start_time = number of seconds just before the inserting, and then getting end_time = number of seconds just after the inserting, we can calculate (end_time - start_time) = elapsed time in seconds. We will display that value by putting it in a request without any assignments, which causes Tarantool to send the value to the client, which prints it. (Lua's answer to the C ``printf()`` function, which is ``print()``, will also work.)"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:418
msgid "For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and Time\"`_. For more on Lua print() see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:424
msgid "Since this is the grand finale, we will redo the final versions of all the necessary requests: the request that created ``string_function()``, the request that created ``main_function()``, and the request that invokes ``main_function()``."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:429
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:457
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:496
msgid "What has been shown is that Lua functions are quite expressive (in fact one can do more with Tarantool's Lua stored procedures than one can do with stored procedures in some SQL DBMSs), and that it's straightforward to combine Lua-library functions and Tarantool-library functions."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:501
msgid "What has also been shown is that inserting a million tuples took 37 seconds. The host computer was a Linux laptop. By changing :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` to 'none' before running the test, one can reduce the elapsed time to 4 seconds."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:509
msgid "Sum a JSON field for all tuples"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:511
msgid "This is an exercise assignment: Assume that inside every tuple there is a string formatted as JSON. Inside that string there is a JSON numeric field. For each tuple, find the numeric field's value and add it to a 'sum' variable. At end, return the 'sum' variable. The purpose of the exercise is to get experience in one way to read and process tuples."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:517
msgid "json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:534
msgid "**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will be used in the function. Actually it's not necessary to declare all variables at the start, and in a long function it would be better to declare variables just before using them. In fact it's not even necessary to declare variables at all, but an undeclared variable is \"global\". That's not desirable for any of the variables that are declared in line 1, because all of them are for use only within the function."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:541
msgid "**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and there are two ways to do it: with :ref:`box.space.space_object:pairs() <box_space-pairs>` or with ``variable = select(...)`` followed by :samp:`for i, {n}, 1 do {some-function}(variable[i]) end`. We preferred ``pairs()`` for this example."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:546
msgid "**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop will be repeated as long as there is another index key. A tuple is fetched and can be referenced with variable :code:`t`."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:550
msgid "**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = json.decode(t[2]))``, then the function would abort with an error if it encountered something wrong with the JSON string - a missing colon, for example. By putting the function inside \"``pcall``\" (`protected call`_), we're saying: we want to intercept that sort of error, so if there's a problem just set ``is_valid_json = false`` and we will know what to do about it later."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:557
msgid "**LINE 6: MEANING.** The function is :ref:`json.decode <json-decode>` which means decode a JSON string, and the parameter is t[2] which is a reference to a JSON string. There's a bit of hard coding here, we're assuming that the second field in the tuple is where the JSON string was inserted. For example, we're assuming a tuple looks like"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:567
msgid "field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:570
msgid "meaning that the tuple's first field, the primary key field, is a number while the tuple's second field, the JSON string, is a string. Thus the entire statement means \"decode ``t[2]`` (the tuple's second field) as a JSON string; if there's an error set ``is_valid_json = false``; if there's no error set ``is_valid_json = true`` and set ``lua_table =`` a Lua table which has the decoded string\"."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:576
msgid "**LINE 8.** At last we are ready to get the JSON field value from the Lua table that came from the JSON string. The value in field_name, which is the parameter for the whole function, must be a name of a JSON field. For example, inside the JSON string ``'{\"Hello\": \"world\", \"Quantity\": 15}'``, there are two JSON fields: \"Hello\" and \"Quantity\". If the whole function is invoked with ``sum_json_field(\"Quantity\")``, then ``field_value = lua_table[field_name]`` is effectively the same as ``field_value = lua_table[\"Quantity\"]`` or even ``field_value = lua_table.Quantity``. Those are just three different ways of saying: for the Quantity field in the Lua table, get the value and put it in variable :code:`field_value`."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:586
msgid "**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but the JSON field is not a number, or is missing. In that case, the function would be aborted when there was an attempt to add it to the sum. By first checking ``type(field_value) == \"number\"``, we avoid that abortion. Anyone who knows that the database is in perfect shape can skip this kind of thing."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:592
msgid "And the function is complete. Time to test it. Starting with an empty database, defined the same way as the sandbox database that was introduced in :ref:`first database <user_guide_getting_started-first_database>`,"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:596
msgid "-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'NUM'}})"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:603
msgid "then add some tuples where the first field is a number and the second field is a string."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:606
msgid "box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": \"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": 3}'}"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:613
msgid "Since this is a test, there are deliberate errors. The \"golf club\" and the \"waffle iron\" do not have numeric Quantity fields, so must be ignored. Therefore the real sum of the Quantity field in the JSON strings should be: 15 + 7 = 22."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:618
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:620
msgid "tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:627
msgid "It works. We'll just leave, as exercises for future improvement, the possibility that the \"hard coding\" assumptions could be removed, that there might have to be an overflow check if some field values are huge, and that the function should contain a \"yield\" instruction if the count of tuples is huge."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:636
msgid "Indexed Pattern Search"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:638
msgid "Here is a generic function which takes a field identifier and a search pattern, and returns all tuples that match. |br| * The field must be the first field of a TREE index. |br| * The function will use `Lua pattern matching <http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, which allows \"magic characters\" in regular expressions. |br| * The initial characters in the pattern, as far as the first magic character, will be used as an index search key. For each tuple that is found via the index, there will be a match of the whole pattern. |br| * To be :ref:`cooperative <atomic-cooperative_multitasking>`, the function should yield after every 10 tuples, unless there is a reason to delay yielding. |br| With this function, we can take advantage of Tarantool's indexes for speed, and take advantage of Lua's pattern matching for flexibility. It does everything that an SQL \"LIKE\" search can do, and far more."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:653
msgid "Read the following Lua code to see how it works. The comments that begin with \"SEE NOTE ...\" refer to long explanations that follow the code."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:657
msgid "function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"SCALAR\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"STR\")) then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == \".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == \"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too short\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- SEE NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\"\n"
"      number_of_tuples_since_last_yield = number_of_tuples_since_last_yield + 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- SEE NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set + 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:748
msgid "NOTE #1 \"FIND AN APPROPRIATE INDEX\" |br| The caller has passed space_name (a string) and field_no (a number). The requirements are: |br| (a) index type must be \"TREE\" because for other index types (HASH, BITSET, RTREE) a search with iterator=GE will not return strings in order by string value; |br| (b) field_no must be the first index part; |br| (c) the field must contain strings, because for other data types (such as \"NUM\") pattern searches are not possible; |br| If these requirements are not met by any index, then print an error message and return nil."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:760
msgid "NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\" |br| The caller has passed pattern (a string). The index search key will be the characters in the pattern as far as the first magic character. Lua's magic characters are % ^ $ ( ) . [ ] * + - ?. For example, if the pattern is \"ABC.E\", the period is a magic character and therefore the index search key will be \"ABC\". But there is a complication ... If we see \"%\" followed by a punctuation character, that punctuation character is \"escaped\" so remove the \"%\" when making the index search key. For example, if the pattern is \"AB%$E\", the dollar sign is escaped and therefore the index search key will be \"AB$E\". Finally there is a check that the index search key length must be at least three -- this is an arbitrary number, and in fact zero would be okay, but short index search keys will cause long search times."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:777
msgid "NOTE #3 -- \"OUTER LOOP: INITIATE\" |br| The function's job is to return a result set, just as box.space.select would. We will fill it within an outer loop that contains an inner loop. The outer loop's job is to execute the inner loop, and possibly yield, until the search ends. The inner loop's job is to find tuples via the index, and put them in the result set if they match the pattern."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:786
msgid "NOTE #4 \"INNER LOOP: ITERATOR\" |br| The for loop here is using pairs(), see the :ref:`explanation of what index iterators are <box_index-index_pairs>`. Within the inner loop, there will be a local variable named \"tuple\" which contains the latest tuple found via the index search key."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:793
msgid "NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\" |br| The iterator is GE (Greater or Equal), and we must be more specific: if the search index key has N characters, then the leftmost N characters of the result's index field must not be greater than the search index key. For example, if the search index key is 'ABC', then 'ABCDE' is a potential match, but 'ABD' is a signal that no more matches are possible."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:802
msgid "NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\" |br| This chunk of code is for cooperative multitasking. The number 10 is arbitrary, and usually a larger number would be okay. The simple rule would be \"after checking 10 tuples, yield, and then resume the search (that is, do the inner loop again) starting after the last value that was found\". However, if the index is non-unique or if there is more than one field in the index, then we might have duplicates -- for example {\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", 3}\" -- and it would be difficult to decide which \"ABC\" tuple to resume with. Therefore, if the result's index field is the same as the previous result's index field, there is no break."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:815
msgid "NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\" |br| Compare the result's index field to the entire pattern. For example, suppose that the caller passed pattern \"ABC.E\" and there is an indexed field containing \"ABCDE\". Therefore the initial index search key is \"ABC\". Therefore a tuple containing an indexed field with \"ABCDE\" will be found by the iterator, because \"ABCDE\" > \"ABC\". In that case string.match will return a value which is not nil. Therefore this tuple can be added to the result set."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:825
msgid "NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\" |br| There are three conditions which will cause a break from the inner loop: (1) the for loop ends naturally because there are no more index keys which are greater than or equal to the index search key, (2) the index key is too great as described in NOTE #5, (3) it is time for a yield as described in NOTE #6. If condition (1) or condition (2) is true, then there is nothing more to do, the outer loop ends too. If and only if condition (3) is true, the outer loop must yield and then continue. If it does continue, then the inner loop -- the iterator search -- will happen again with a new value for the index search key."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:838
msgid "EXAMPLE:"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:840
msgid "Start tarantool, cut and paste the code for function indexed_pattern_search, and try the following: |br| :codebold:`box.space.t:drop()` |br| :codebold:`box.schema.space.create('t')` |br| :codebold:`box.space.t:create_index('primary',{})` |br| :codebold:`box.space.t:create_index('secondary',{unique=false,parts={2,'STR',3,'STR'}})` |br| :codebold:`box.space.t:insert{1,'A','a'}` |br| :codebold:`box.space.t:insert{2,'AB',''}` |br| :codebold:`box.space.t:insert{3,'ABC','a'}` |br| :codebold:`box.space.t:insert{4,'ABCD',''}` |br| :codebold:`box.space.t:insert{5,'ABCDE','a'}` |br| :codebold:`box.space.t:insert{6,'ABCDE',''}` |br| :codebold:`box.space.t:insert{7,'ABCDEF','a'}` |br| :codebold:`box.space.t:insert{8,'ABCDF',''}` |br| :codebold:`indexed_pattern_search(\"t\", 2, \"ABC.E.\")` |br| The result will be: |br| :codenormal:`tarantool>` :codebold:`indexed_pattern_search(\"t\", 2, \"ABC.E.\")` |br| :codenormal:`---` |br| :codenormal:`- - [7, 'ABCDEF', 'a']` |br| :codenormal:`...` |br|"
msgstr ""

#: ../book/app/d_vinyl/index.rst:30
msgid "Appendix D. Vinyl"
msgstr ""

#: ../book/app/d_vinyl/index.rst:34
msgid "Introduction"
msgstr ""

#: ../book/app/d_vinyl/index.rst:36
msgid "Vinyl's features are:"
msgstr ""

#: ../book/app/d_vinyl/index.rst:38
msgid "Full ACID compliance"
msgstr ""

#: ../book/app/d_vinyl/index.rst:39
msgid "Multi-Version Concurrency Control (MVCC)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:40
msgid "Pure Append-Only"
msgstr ""

#: ../book/app/d_vinyl/index.rst:41
msgid "Multi-threaded (Client access and Engine scalability)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:42
msgid "Multi-databases support (Single environment and WAL)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:43
msgid "Multi-Statement and Single-Statement Transactions (Snapshot Isolation (SI), multi-databases)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:44
msgid "Asynchronous or synchronous transaction execution (Callback triggered versus blocking)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:45
msgid "Separate storage formats: key-value (Default), or document (Keys are part of value)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:46
msgid "Update without read"
msgstr ""

#: ../book/app/d_vinyl/index.rst:47
msgid "Consistent Cursors"
msgstr ""

#: ../book/app/d_vinyl/index.rst:48
msgid "Prefix search"
msgstr ""

#: ../book/app/d_vinyl/index.rst:49
msgid "Point-in-Time Snapshots"
msgstr ""

#: ../book/app/d_vinyl/index.rst:50
msgid "Versional database creation and asynchronous shutdown/drop"
msgstr ""

#: ../book/app/d_vinyl/index.rst:51
msgid "Asynchronous Online/Hot Backup"
msgstr ""

#: ../book/app/d_vinyl/index.rst:52
msgid "Compression (Per region, both lz4 and zstd are supported)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:53
msgid "Metadata Compression (By default)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:54
msgid "Key Compression (Compress key duplicates, including suffixes)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:55
msgid "Easy to use (Minimalist API)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:56
msgid "Easy to integrate (Native support of using as storage engine)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:57
msgid "Easy to write bindings (Very FFI-friendly, API designed to be stable in future)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:58
msgid "Easy to build in (Amalgamated, compiles into two C files)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:59
msgid "Event loop friendly"
msgstr ""

#: ../book/app/d_vinyl/index.rst:60
msgid "Zero-Configuration (Tuned by default)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:61
msgid "Implemented as a small library **written in C** with zero dependencies"
msgstr ""

#: ../book/app/d_vinyl/index.rst:62
msgid "BSD Licensed"
msgstr ""

#: ../book/app/d_vinyl/index.rst:64
msgid "It is appropriate for databases that cannot fit in memory, where access via secondary keys is not required."
msgstr ""

#: ../book/app/d_vinyl/index.rst:66
msgid "In vinyl terminology:"
msgstr ""

#: ../book/app/d_vinyl/index.rst:68
msgid "There is one **Environment**."
msgstr ""

#: ../book/app/d_vinyl/index.rst:69
msgid "An Environment has N **Databases** - a vinyl database is like a Tarantool `space`."
msgstr ""

#: ../book/app/d_vinyl/index.rst:70
msgid "A Database has N **Ranges**."
msgstr ""

#: ../book/app/d_vinyl/index.rst:71
msgid "A Range has one **Range File**."
msgstr ""

#: ../book/app/d_vinyl/index.rst:72
msgid "A Range File has N **Runs**."
msgstr ""

#: ../book/app/d_vinyl/index.rst:73
msgid "A Run has N **Regions** - a vinyl Region is like a B-tree `page`."
msgstr ""

#: ../book/app/d_vinyl/index.rst:74
msgid "A Region has **keys** and **values** - a vinyl key-value is like a Tarantool `tuple`."
msgstr ""

#: ../book/app/d_vinyl/index.rst:76
msgid "A key and its associated value are together, so when one accesses a key one gets the whole tuple. In other words, in vinyl the data is stored in the index. There are up to two in-memory copies of an index, as well as the copy in the Range File."
msgstr ""

#: ../book/app/d_vinyl/index.rst:80
msgid "For operations that insert or update tuples - called Set operations in vinyl - vinyl makes changes to in-memory copies of the index, and writes to Tarantool's Write-ahead Log. A scheduler assigns tasks to multiple background threads for transferring index data from memory to disk, and for reorganizing Runs. To support transactions, Set operations can be delayed until an explicit commit. If multiple users access the same tuples simultaneously, the concurrency control method is `MVCC`_ and the isolation level is `Snapshot`_."
msgstr ""

#: ../book/app/d_vinyl/index.rst:91
msgid "Formally, in terms of disk accesses, vinyl has the following algorithmic complexity:"
msgstr ""

#: ../book/app/d_vinyl/index.rst:93
msgid "**Set** - the worst case is O(*1*) append-only key writes to the Write-Ahead Log + in-memory Range index searches + in-memory index inserts"
msgstr ""

#: ../book/app/d_vinyl/index.rst:95
msgid "**Delete** - the worst case is O(*1*) key writes and in-memory index inserts (the same as **Set**)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:97
msgid "**Get** - the worst case is `amortized`_ O(*max\\_run\\_count\\_per\\_node*) random Region reads from a single Range file, which itself does in-memory index search + in-memory Region search"
msgstr ""

#: ../book/app/d_vinyl/index.rst:100
msgid "**Range** - queries, the worst case of full Database scan is amortized O(*total\\_Region\\_count*) + in-memory key-index searches for each Range"
msgstr ""

#: ../book/app/d_vinyl/index.rst:107
msgid "Under the hood"
msgstr ""

#: ../book/app/d_vinyl/index.rst:109
msgid "In this section, to illustrate internals, we will discuss this example:"
msgstr ""

#: ../book/app/d_vinyl/index.rst:111
msgid "filling an empty database with one million tuples (we'll call them \"keys\" to emphasize the indexed nature)"
msgstr ""

#: ../book/app/d_vinyl/index.rst:113
msgid "reading all stored tuples in the original order."
msgstr ""

#: ../book/app/d_vinyl/index.rst:117
msgid "Inserting the first 200.000 keys"
msgstr ""

#: ../book/app/d_vinyl/index.rst:119
msgid "During the first 200,000 Set operations, inserted keys first go to the in-memory index. To maintain persistence, information about each Set operation is written to Tarantool's Write-ahead Log."
msgstr ""

#: ../book/app/d_vinyl/index.rst:127
msgid "At this point we have keys in an in-memory index and records in the Write-ahead Log."
msgstr ""

#: ../book/app/d_vinyl/index.rst:132
msgid "Inserting the next 300.000 keys"
msgstr ""

#: ../book/app/d_vinyl/index.rst:134
msgid "As the in-memory index becomes too large for available memory, the index must be copied from memory to disk. The on-disk copy of the in-memory index is called a Run. To save the Run, a new file is created, the Range File. We will call it **db file** for this example."
msgstr ""

#: ../book/app/d_vinyl/index.rst:139
msgid "The scheduler wakes a worker thread in the background, a Run Creation Thread. The thread creates a second in-memory index. If there are Set operations taking place while the thread is working, their contention effect will be small because they will operate on the second in-memory index."
msgstr ""

#: ../book/app/d_vinyl/index.rst:148
msgid "When the Run Creation Thread finishes the task, the first in-memory index is freed."
msgstr ""

#: ../book/app/d_vinyl/index.rst:157
msgid "Inserting the next 200.000 keys"
msgstr ""

#: ../book/app/d_vinyl/index.rst:159
msgid "Several times, the in-memory index becomes too large and a Run Creation Thread transfers the keys to a Run. The Runs have been appended to the end of db file. The number of created Runs becomes large."
msgstr ""

#: ../book/app/d_vinyl/index.rst:168
msgid "There is a user-settable maximum number of Runs per Range. When the number of Runs reaches this maximum, the vinyl scheduler wakes a **Compaction Thread** for the db file. The Compaction Thread merges the keys in all the Runs, and creates one or more new db files."
msgstr ""

#: ../book/app/d_vinyl/index.rst:177
msgid "Now there are multiple pairs of in-memory indexes, and each pair has an associated db file. The combination of the in-memory indexes and the db file is called a **Range**, and the db file is called a **Range File**."
msgstr ""

#: ../book/app/d_vinyl/index.rst:185
msgid "Thus the contents of a Range are: a range of sorted key values, stored in Runs of a Range File and (when necessary) in memory. Since the ranges do not overlap, each Range can be handled independently. Therefore, while one of the background threads is working on Range 1, another background thread can be working on Range 2, without contention. That means that all the background operations (Run Creation, Compaction, Garbage Collection, and Backup) can take place in parallel on multiple threads."
msgstr ""

#: ../book/app/d_vinyl/index.rst:193
msgid "The foregoing explanation will now be repeated with different wording."
msgstr ""

#: ../book/app/d_vinyl/index.rst:195
msgid "Before the Compaction there was one Range, which was created automatically when the Database was initialized. The Range had:"
msgstr ""

#: ../book/app/d_vinyl/index.rst:198
msgid "an in-memory index with some keys in it,"
msgstr ""

#: ../book/app/d_vinyl/index.rst:199
msgid "a Range File with several Runs,"
msgstr ""

#: ../book/app/d_vinyl/index.rst:200
msgid "a Write-Ahead Log file recording the Set operations, in the order they happened."
msgstr ""

#: ../book/app/d_vinyl/index.rst:202
msgid "The number of Runs became too big, so the vinyl scheduler starts the Compaction Thread and creates two new Ranges."
msgstr ""

#: ../book/app/d_vinyl/index.rst:209
msgid "So, each of the two new Range Files contains half of the keys that were in the original Range. The Range's in-memory indexes are split in the same way."
msgstr ""

#: ../book/app/d_vinyl/index.rst:212
msgid "After the splitting, vinyl must take into account that: while the Compaction was going on in the background, there might have been more Set operations taking place in parallel. These Set operations would have changed one of the in-memory indexes, and these changes too will be merged."
msgstr ""

#: ../book/app/d_vinyl/index.rst:217
msgid "When the Compaction Thread finishes, the original Range is deleted, and information about the new Ranges is inserted into an in-memory **Range Index**."
msgstr ""

#: ../book/app/d_vinyl/index.rst:224
msgid "This Range Index is used for all Set operations and all searches. Since the Range Index has the minimum and maximum key values that are in each Range, it is straightforward to scan it to find what Range would contain a particular key value."
msgstr ""

#: ../book/app/d_vinyl/index.rst:234
msgid "Inserting the last 300.000 keys"
msgstr ""

#: ../book/app/d_vinyl/index.rst:236
msgid "The final 300,000 Set operations take place; the background threads continue to create new Runs and do more Compactions. After the millionth insertion, the Database has four Ranges."
msgstr ""

#: ../book/app/d_vinyl/index.rst:244
msgid "The inserting is done. Now, because the words \"memory\" and \"disk\" have appeared in this explanation several times, here are a few words about how vinyl is designed to use these resources most efficiently:"
msgstr ""

#: ../book/app/d_vinyl/index.rst:248
msgid "If there is more memory available, then Run Creation and Compaction will be less frequent, and there will be fewer disk accesses."
msgstr ""

#: ../book/app/d_vinyl/index.rst:250
msgid "The best vinyl performance will occur if there is no setting of a memory limit, but this must be balanced against other considerations, such as requirements for the memtx storage engine. If there is a setting of a memory limit, the vinyl scheduler will give priority to the Ranges that have the largest in-memory indexes, so that the largest memory blocks are freed first."
msgstr ""

#: ../book/app/d_vinyl/index.rst:255
msgid "To make the most of hard drives and Flash, vinyl will delay operations that require disk access (except the writing of the Write-ahead Log which is specially tunable), so that the accesses are done in large sequential blocks."
msgstr ""

#: ../book/app/d_vinyl/index.rst:258
msgid "Overwriting does not occur; vinyl is an \"append-only\" engine."
msgstr ""

#: ../book/app/d_vinyl/index.rst:262
msgid "Reading million keys"
msgstr ""

#: ../book/app/d_vinyl/index.rst:264
msgid "We will now start to read the million rows in the order that they were inserted, which was random."
msgstr ""

#: ../book/app/d_vinyl/index.rst:271
msgid "During the Get (search), vinyl first finds the correct Range by looking in the Range Index. Then it searches the Range's first in-memory index, and/or the Range's second in-memory index, and/or each Run of the Range, starting from the end of the Range File."
msgstr ""

#: ../book/app/d_vinyl/index.rst:276
msgid "Remember that a Run is divided into Regions, which are like what would be called \"pages\" or \"blocks\" in a B-tree. For each Run, there is a list of the Regions and their minimum/maximum key values - the Region Index - as well as some metadata."
msgstr ""

#: ../book/app/d_vinyl/index.rst:285
msgid "Region Indexes are loaded into memory when the Database is opened. Since the Database's Range Index and the Region Indexes are normally in-memory, searching and retrieving a tuple might require only zero or one disk accesses. However, when memory is limited and there are many Runs, search time may rise. For each additional Run there is a possible additional disk access during a search. Also, it is impossible to maintain memory limits without doing a Run Creation process, because new Set operations might occur more quickly than the Compaction process can run."
msgstr ""

#: ../book/app/d_vinyl/index.rst:298
msgid "Vinyl is read optimized. It is very likely that the most recently created Runs (hot data) will be in the file system cache. The scheduler will give priority to the Ranges which have the largest in-memory indexes and the most Runs."
msgstr ""

#: ../book/app/d_vinyl/index.rst:303
msgid "The scheduler may also try to arrange that a Range will have only one Run, which will ensure the average number of disk seeks for each search is O(*1*)."
msgstr ""

#: ../book/box/admin.rst:28
msgid "Administrative requests"
msgstr ""

#: ../book/box/admin.rst:30
msgid "To learn which functions are considered to be administrative, type ``help()``. A reference description also follows below:"
msgstr ""

#: ../book/box/admin.rst:37
msgid "Take a snapshot of all data and store it in :ref:`snap_dir <cfg_basic-snap_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first enters the delayed garbage collection mode for all data. In this mode, tuples which were allocated before the snapshot has started are not freed until the snapshot has finished. To preserve consistency of the primary key, used to iterate over tuples, a copy-on-write technique is employed. If the master process changes part of a primary key, the corresponding process page is split, and the snapshot process obtains an old copy of the page. In effect, the snapshot process uses multi-version concurrency control in order to avoid copying changes which are superseded while it is running."
msgstr ""

#: ../book/box/admin.rst:48
msgid "Since a snapshot is written sequentially, one can expect a very high write performance (averaging to 80MB/second on modern disks), which means an average database instance gets saved in a matter of minutes. Note: as long as there are any changes to the parent index memory through concurrent updates, there are going to be page splits, and therefore one needs to have some extra free memory to run this command. 10% of :ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` is, on average, sufficient. This statement waits until a snapshot is taken and returns operation result."
msgstr ""

#: ../book/box/admin.rst:57
msgid "Change Notice: prior to Tarantool version 1.6.6, the snapshot process caused a fork, which could cause occasional latency spikes. Starting with Tarantool version 1.6.6, the snapshot process creates a consistent read view and writes this view to the snapshot file from a separate thread."
msgstr ""

#: ../book/box/admin.rst:62
msgid "Although box.snapshot() does not cause a fork, there is a separate fiber which may produce snapshots at regular intervals -- see the discussion of the :ref:`snapshot daemon <book_cfg_snapshot_daemon>`."
msgstr ""

#: ../book/box/admin.rst:66
#: ../book/box/authentication.rst:178
#: ../book/box/authentication.rst:302
#: ../book/box/box_index.rst:70
#: ../book/box/box_index.rst:431
#: ../book/box/box_index.rst:567
#: ../book/box/box_index.rst:596
#: ../book/box/box_index.rst:625
#: ../book/box/box_index.rst:654
#: ../book/box/box_index.rst:682
#: ../book/box/box_index.rst:751
#: ../book/box/box_index.rst:773
#: ../book/box/box_index.rst:794
#: ../book/box/box_introspection.rst:43
#: ../book/box/box_introspection.rst:86
#: ../book/box/box_introspection.rst:143
#: ../book/box/box_schema.rst:147
#: ../book/box/box_schema.rst:161
#: ../book/box/box_schema.rst:210
#: ../book/box/box_schema.rst:241
#: ../book/box/box_schema.rst:271
#: ../book/box/box_schema.rst:282
#: ../book/box/box_schema.rst:327
#: ../book/box/box_schema.rst:361
#: ../book/box/box_schema.rst:372
#: ../book/box/box_space.rst:232
#: ../book/box/box_space.rst:262
#: ../book/box/box_space.rst:340
#: ../book/box/box_space.rst:361
#: ../book/box/box_space.rst:380
#: ../book/box/box_space.rst:416
#: ../book/box/box_space.rst:484
#: ../book/box/box_space.rst:619
#: ../book/box/box_space.rst:642
#: ../book/box/box_space.rst:670
#: ../book/box/box_space.rst:708
#: ../book/box/box_space.rst:727
#: ../book/box/box_space.rst:750
#: ../book/box/box_space.rst:767
#: ../book/box/box_space.rst:795
#: ../book/box/box_space.rst:827
#: ../book/box/box_space.rst:851
#: ../book/box/box_space.rst:887
#: ../book/box/box_space.rst:927
#: ../book/box/box_space.rst:971
#: ../book/box/box_tuple.rst:59
#: ../book/box/triggers.rst:82
#: ../book/box/triggers.rst:109
#: ../book/box/triggers.rst:181
#: ../book/box/triggers.rst:211
#: ../book/box/triggers.rst:229
msgid "**Example:**"
msgstr ""

#: ../book/box/admin.rst:68
msgid "tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../book/box/admin.rst:83
msgid "Taking a snapshot does not cause the server to start a new write-ahead log. Once a snapshot is taken, old WALs can be deleted as long as all replicas are up to date. But the WAL which was current at the time ``box.snapshot()`` started must be kept for recovery, since it still contains log records written after the start of ``box.snapshot()``."
msgstr ""

#: ../book/box/admin.rst:89
msgid "An alternative way to save a snapshot is to send the server SIGUSR1 UNIX signal. While this approach could be handy, it is not recommended for use in automation: a signal provides no way to find out whether the snapshot was taken successfully or not."
msgstr ""

#: ../book/box/admin.rst:96
msgid "Fork and dump a core. Since Tarantool stores all tuples in memory, it can take some time. Mainly useful for debugging."
msgstr ""

#: ../book/box/atomic.rst:30
msgid "Atomic execution"
msgstr ""

#: ../book/box/atomic.rst:32
msgid "In several places in this manual it's been noted that Lua processes occur in fibers on a single thread. That is why there can be a guarantee of execution atomicity. That requires emphasis."
msgstr ""

#: ../book/box/atomic.rst:41
msgid "Cooperative multitasking environment"
msgstr ""

#: ../book/box/atomic.rst:43
msgid "Tarantool uses cooperative multitasking: unless a running fiber deliberately yields control, it is not preempted by some other fiber. But a running fiber will deliberately yield when it encounters a \"yield point\": an explicit `yield()` request, or an implicit yield due to an operating-system call. Any system call which can block will be performed asynchronously, and any running fiber which must wait for a system call will be preempted so that another ready-to-run fiber takes its place and becomes the new running fiber. This model makes all programmatic locks unnecessary: cooperative multitasking ensures that there will be no concurrency around a resource, no race conditions, and no memory consistency issues."
msgstr ""

#: ../book/box/atomic.rst:54
msgid "When requests are small, for example simple UPDATE or INSERT or DELETE or SELECT, fiber scheduling is fair: it takes only a little time to process the request, schedule a disk write, and yield to a fiber serving the next client."
msgstr ""

#: ../book/box/atomic.rst:58
msgid "However, a function might perform complex computations or might be written in such a way that yields do not occur for a long time. This can lead to unfair scheduling, when a single client throttles the rest of the system, or to apparent stalls in request processing. Avoiding this situation is the responsibility of the function's author. For the default memtx storage engine some of the box calls, including the data-change requests :ref:`box.space...insert <box_space-insert>` or :ref:`box.space...update <box_space-update>` or :ref:`box.space...delete <box_space-delete>`, will usually cause yielding; however, :ref:`box.space...select <box_space-select>` will not. A fuller description will appear in section :ref:`The Implicit Yield Rules <atomic-the_implicit_yield_rules>`."
msgstr ""

#: ../book/box/atomic.rst:70
msgid "Note re storage engine: vinyl has different rules: insert or update or delete will very rarely cause a yield, but select can cause a yield."
msgstr ""

#: ../book/box/atomic.rst:73
msgid "In the absence of transactions, any function that contains yield points may see changes in the database state caused by fibers that preempt. Then the only safe atomic functions for memtx databases would be functions which contain only one database request, or functions which contain a select request followed by a data-change request."
msgstr ""

#: ../book/box/atomic.rst:79
msgid "At this point an objection could arise: \"It's good that a single data-change request will commit and yield, but surely there are times when multiple data-change requests must happen without yielding.\" The standard example is the money-transfer, where $1 is withdrawn from account #1 and deposited into account #2. If something interrupted after the withdrawal, then the institution would be out of balance. For such cases, the ``begin ... commit|rollback`` block was designed."
msgstr ""

#: ../book/box/atomic.rst:91
msgid "Begin the transaction. Disable implicit yields until the transaction ends. Signal that writes to the write-ahead log will be deferred until the transaction ends. In effect the fiber which executes ``box.begin()`` is starting an \"active multi-request transaction\", blocking all other fibers."
msgstr ""

#: ../book/box/atomic.rst:100
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../book/box/atomic.rst:107
msgid "End the transaction, but cancel all its data-change operations. An explicit call to functions outside ``box.space`` that always yield, such as ``fiber.yield`` or ``fiber.sleep``, will have the same effect."
msgstr ""

#: ../book/box/atomic.rst:111
msgid "The **requests in a transaction must be sent to the server as a single block**. It is not enough to enclose them between ``begin`` and ``commit`` or ``rollback``. To ensure they are sent as a single block: put them in a function, or put them all on one line, or use a delimiter so that multi-line requests are handled together."
msgstr ""

#: ../book/box/atomic.rst:116
msgid "**All database operations in a transaction should use the same storage engine**. It is not safe to access tuple sets that are defined with ``{engine='vinyl'}`` and also access tuple sets that are defined with ``{engine='memtx'}``, in the same transaction."
msgstr ""

#: ../book/box/atomic.rst:123
#: ../book/box/box_schema.rst:92
#: ../book/box/box_session.rst:82
#: ../book/box/box_tuple.rst:306
#: ../book/box/index.rst:170
#: ../book/box/triggers.rst:120
#: ../book/box/triggers.rst:238
#: ../book/configuration/index.rst:121
msgid "Example"
msgstr ""

#: ../book/box/atomic.rst:125
msgid "Assuming that in tuple set 'tester' there are tuples in which the third field represents a positive dollar amount ... Start a transaction, withdraw from tuple#1, deposit in tuple#2, and end the transaction, making its effects permanent."
msgstr ""

#: ../book/box/atomic.rst:129
msgid "tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""

#: ../book/box/atomic.rst:149
msgid "The Implicit Yield Rules"
msgstr ""

#: ../book/box/atomic.rst:151
msgid "The only explicit yield requests are :ref:`fiber.sleep() <fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other requests \"imply\" yields because Tarantool is designed to avoid blocking."
msgstr ""

#: ../book/box/atomic.rst:155
msgid "The implicit yield requests are: :ref:`insert <box_space-insert>` :ref:`replace <box_space-replace>` :ref:`update <box_space-update>` :ref:`upsert <box_space-upsert>` :ref:`delete <box_space-delete>` (the \"data-change\" requests), and functions in package :ref:`fio <fio-section>`, :ref:`net_box <net_box-package>`, :ref:`console <console-package>`, or :ref:`socket <socket-package>` (the \"os\" and \"network\" requests). Note re storage engine: with Vinyl :ref:`select <box_space-select>` is an implicit yield request, but data-change requests may not be."
msgstr ""

#: ../book/box/atomic.rst:167
msgid "The yield occurs just before a blocking syscall, such as a write to the Write-Ahead Log (WAL) or a network message reception."
msgstr ""

#: ../book/box/atomic.rst:170
msgid "Implicit yield requests are disabled by :ref:`box.begin <atomic-box_begin>`, and enabled again by :ref:`commit <atomic-box_commit>`. Therefore the sequence` |br| :codenormal:`begin` |br| :codenormal:`implicit yield request #1` |br| :codenormal:`implicit yield request #2` |br| :codenormal:`implicit yield request #3` |br| :codenormal:`commit` |br| will not cause implicit yield until the commit occurs (specifically: just before the writes to the WAL, which are delayed until commit time). The commit request is not itself an implicit yield request, it only enables yields caused by earlier implicit yield requests."
msgstr ""

#: ../book/box/atomic.rst:183
msgid "Despite their resemblance to implicit yield requests, :ref:`truncate <box_space-truncate>` and :ref:`drop <box_space-drop>` do not cause implicit yield. Despite their resemblance to functions of the fio package, functions of the :ref:`os <os-package>` package do not cause implicit yield. Despite its resemblance to commit, :ref:`rollback <atomic-box_rollback>` does not enable yields."
msgstr ""

#: ../book/box/atomic.rst:190
msgid "If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = 'none', then implicit yielding is disabled, because there are no writes to the WAL."
msgstr ""

#: ../book/box/atomic.rst:193
msgid "If a task is interactive -- sending requests to the server and receiving responses -- then it involves network IO, and therefore there is an implicit yield, even if the request that is sent to the server is not itself an implicit yield request. Therefore the sequence |br| :codenormal:`select` |br| :codenormal:`select` |br| :codenormal:`select` |br| causes blocking if it is inside a function or Lua program being executed on the server, but causes yielding if it is done as a series of transmissions from a client, including a client which operates via telnet, via one of the connectors, or via the MySQL and PostgreSQL rocks, or via the interactive mode when :ref:`\"Using tarantool as a client\" <administration-using_tarantool_as_a_client>`."
msgstr ""

#: ../book/box/atomic.rst:208
msgid "After a fiber has yielded and then has regained control, it immediately issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""

#: ../book/box/authentication.rst:30
msgid "Access control"
msgstr ""

#: ../book/box/authentication.rst:32
msgid "Understanding the details of security is primarily an issue for administrators, but ordinary users should at least skim this section so that they will have an idea of how Tarantool makes it possible for administrators to prevent unauthorized access to the database and to certain functions."
msgstr ""

#: ../book/box/authentication.rst:37
msgid "Briefly: there is a method to guarantee with password checks that users really are who they say they are (\"authentication\"). There is a _user space where user names and password-hashes are stored. There are functions for saying that certain users are allowed to do certain things (\"privileges\"). There is a _priv space where privileges are stored. Whenever a user tries to do an operation, there is a check whether the user has the privilege to do the operation (\"access control\")."
msgstr ""

#: ../book/box/authentication.rst:47
msgid "Passwords"
msgstr ""

#: ../book/box/authentication.rst:49
msgid "Each user may have a password. The password is any alphanumeric string. Administrators should advise users to choose long unobvious passwords, but it is ultimately up to the users to choose or change their own passwords."
msgstr ""

#: ../book/box/authentication.rst:53
msgid "Tarantool passwords are stored in the _user space with a `Cryptographic hash function`_ so that, if the password is 'x', the stored hashed-password is a long string like '``lL3OvhkIPOKh+Vn9Avlkx69M/Ck=``'. When a client connects to a Tarantool server, the server sends a random `Salt Value`_ which the client must mix with the hashed-password before sending to the server. Thus the original value 'x' is never stored anywhere except in the user's head, and the hashed value is never passed down a network wire except when mixed with a random salt. This system prevents malicious onlookers from finding passwords by snooping in the log files or snooping on the wire. It is the same system that `MySQL introduced several years ago`_ which has proved adequate for medium-security installations. Nevertheless administrators should warn users that no system is foolproof against determined long-term attacks, so passwords should be guarded and changed occasionally."
msgstr ""

#: ../book/box/authentication.rst:66
msgid "Notes: To get the hash-password of a string 'X', say ``box.schema.user.password('X')``. To see more about the details of the algorithm for the purpose of writing a new client application, read the `scramble.h`_ header file."
msgstr ""

#: ../book/box/authentication.rst:79
msgid "Users and the _user space"
msgstr ""

#: ../book/box/authentication.rst:81
msgid "The fields in the _user space are:"
msgstr ""

#: ../book/box/authentication.rst:83
msgid "the numeric id of the tuple"
msgstr ""

#: ../book/box/authentication.rst:84
msgid "the numeric id of the tuple's creator"
msgstr ""

#: ../book/box/authentication.rst:85
msgid "the user name"
msgstr ""

#: ../book/box/authentication.rst:86
msgid "the type"
msgstr ""

#: ../book/box/authentication.rst:87
msgid "optional password"
msgstr ""

#: ../book/box/authentication.rst:89
msgid "There are four special tuples in the _user space: 'guest', 'admin', 'public', and 'replication'."
msgstr ""

#: ../book/box/authentication.rst:99
#: ../book/box/box_schema.rst:60
#: ../book/box/box_space.rst:49
#: ../book/box/box_space.rst:163
msgid "Name"
msgstr ""

#: ../book/box/authentication.rst:99
msgid "ID"
msgstr ""

#: ../book/box/authentication.rst:99
#: ../book/box/box_index.rst:154
#: ../book/box/box_index.rst:207
#: ../book/box/box_index.rst:241
#: ../book/box/box_index.rst:277
#: ../book/box/box_schema.rst:60
#: ../book/box/box_space.rst:163
msgid "Type"
msgstr ""

#: ../book/box/authentication.rst:99
#: ../book/box/box_index.rst:154
#: ../book/box/box_index.rst:207
#: ../book/box/box_index.rst:241
#: ../book/box/box_index.rst:277
msgid "Description"
msgstr ""

#: ../book/box/authentication.rst:101
msgid "guest"
msgstr ""

#: ../book/box/authentication.rst:101
msgid "0"
msgstr ""

#: ../book/box/authentication.rst:101
#: ../book/box/authentication.rst:104
#: ../book/box/box_schema.rst:75
msgid "user"
msgstr ""

#: ../book/box/authentication.rst:101
msgid "Default when connecting remotely. Usually an untrusted user with few privileges."
msgstr ""

#: ../book/box/authentication.rst:104
msgid "admin"
msgstr ""

#: ../book/box/authentication.rst:104
msgid "1"
msgstr ""

#: ../book/box/authentication.rst:104
msgid "Default when using ``tarantool`` as a console. Usually an administrative user with all privileges."
msgstr ""

#: ../book/box/authentication.rst:107
msgid "public"
msgstr ""

#: ../book/box/authentication.rst:107
msgid "2"
msgstr ""

#: ../book/box/authentication.rst:107
#: ../book/box/authentication.rst:110
msgid "role"
msgstr ""

#: ../book/box/authentication.rst:107
#: ../book/box/authentication.rst:110
msgid "Not a user in the usual sense. Described later in section `Roles`_."
msgstr ""

#: ../book/box/authentication.rst:110
msgid "replication"
msgstr ""

#: ../book/box/authentication.rst:110
msgid "3"
msgstr ""

#: ../book/box/authentication.rst:115
msgid "To select a row from the _user space, use ``box.space._user:select``. For example, here is what happens with a select for user id = 0, which is the 'guest' user, which by default has no password:"
msgstr ""

#: ../book/box/authentication.rst:119
msgid "tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:126
msgid "To change tuples in the _user space, do not use ordinary ``box.space`` functions for insert or update or delete - the _user space is special so there are special functions which have appropriate error checking."
msgstr ""

#: ../book/box/authentication.rst:130
msgid "To create a new user, say:"
msgstr ""

#: ../book/box/authentication.rst:135
msgid "box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})."
msgstr ""

#: ../book/box/authentication.rst:139
msgid "The :samp:`password={password}` specification is good because in a :ref:`URI <index-uri>` (Uniform Resource Identifier) it is usually illegal to include a user-name without a password."
msgstr ""

#: ../book/box/authentication.rst:142
msgid "To change the user's password, say:"
msgstr ""

#: ../book/box/authentication.rst:147
msgid "-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../book/box/authentication.rst:153
msgid "(Usually it is only the admin user who can change a different user's password.)"
msgstr ""

#: ../book/box/authentication.rst:155
msgid "To drop a user, say:"
msgstr ""

#: ../book/box/authentication.rst:160
msgid "box.schema.user.drop(*user-name*)."
msgstr ""

#: ../book/box/authentication.rst:162
msgid "To check whether a user exists, say:"
msgstr ""

#: ../book/box/authentication.rst:167
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../book/box/authentication.rst:169
msgid "which returns true or false."
msgstr ""

#: ../book/box/authentication.rst:171
msgid "To find what privileges a user has, say:"
msgstr ""

#: ../book/box/authentication.rst:176
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../book/box/authentication.rst:180
msgid "Here is a session which creates a new user with a strong password, selects a tuple in the _user space, and then drops the user."
msgstr ""

#: ../book/box/authentication.rst:183
msgid "tarantool> box.schema.user.create('JeanMartin', {password = 'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': 't3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:198
msgid "The maximum number of users is 32."
msgstr ""

#: ../book/box/authentication.rst:204
msgid "Privileges and the _priv space"
msgstr ""

#: ../book/box/authentication.rst:206
msgid "The fields in the _priv space are:"
msgstr ""

#: ../book/box/authentication.rst:208
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../book/box/authentication.rst:209
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../book/box/authentication.rst:210
msgid "the type of object - \"space\" or \"function\" or \"universe\","
msgstr ""

#: ../book/box/authentication.rst:211
msgid "the numeric id of the object,"
msgstr ""

#: ../book/box/authentication.rst:212
msgid "the type of operation - \"read\" = 1, or \"write\" = 2, or \"execute\" = 4, or a combination such as \"read,write,execute\"."
msgstr ""

#: ../book/box/authentication.rst:215
msgid "The function for granting a privilege is:"
msgstr ""

#: ../book/box/authentication.rst:221
msgid "box.schema.user.grant(*grantee*, *operation*, *object-type*, *object-name*[, *options*])\n"
"-- OR\n"
"box.schema.user.grant(*grantee*, *operation*, 'universe' [, nil, *options*])"
msgstr ""

#: ../book/box/authentication.rst:225
#: ../book/box/authentication.rst:238
msgid "where 'universe' means 'all objects', and the optional grant-option can be:"
msgstr ""

#: ../book/box/authentication.rst:227
msgid ":samp:`grantor={grantor_name_or_id}` - string or number, for custom grantor"
msgstr ""

#: ../book/box/authentication.rst:228
msgid ":samp:`if_not_exists=true|false` - bool, do not throw error if user already has the privilege"
msgstr ""

#: ../book/box/authentication.rst:230
msgid "The function for revoking a privilege is:"
msgstr ""

#: ../book/box/authentication.rst:235
msgid "box.schema.user.revoke(*grantee*, *operation*, *object-type*, *object-name*[, *options*])\n"
"box.schema.user.revoke(*grantee*, *operation*, 'universe'[, nil, *options*])"
msgstr ""

#: ../book/box/authentication.rst:240
msgid ":samp:`if_not_exists=true|false` - bool, do not throw error if user already lacks the privilege"
msgstr ""

#: ../book/box/authentication.rst:242
msgid "For example, here is a session where the admin user gave the guest user the privilege to read from a space named ``space55``, and then took the privilege away:"
msgstr ""

#: ../book/box/authentication.rst:245
msgid "tarantool> box.schema.user.grant('guest', 'read', 'space', 'space55')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'read', 'space', 'space55')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:256
msgid "Generally privileges are granted or revoked by the owner of the object (the user who created it), or by the 'admin' user. Before dropping any objects or users, steps should be taken to ensure that all their associated privileges have been revoked."
msgstr ""

#: ../book/box/authentication.rst:263
msgid "Only the 'admin' user can grant privileges for the 'universe'."
msgstr ""

#: ../book/box/authentication.rst:267
msgid "Only the creator of a space can drop, alter, or truncate the space. Only the creator of a user can change a different user's password."
msgstr ""

#: ../book/box/authentication.rst:274
msgid "Functions and the _func space"
msgstr ""

#: ../book/box/authentication.rst:276
msgid "The fields in the _func space are:"
msgstr ""

#: ../book/box/authentication.rst:278
msgid "the numeric function id, a number,"
msgstr ""

#: ../book/box/authentication.rst:279
msgid "the function name"
msgstr ""

#: ../book/box/authentication.rst:280
msgid "flag"
msgstr ""

#: ../book/box/authentication.rst:281
msgid "possibly a language name."
msgstr ""

#: ../book/box/authentication.rst:283
msgid "The _func space does not include the function's body. One continues to create Lua functions in the usual way, by saying \":samp:`function {function_name} () ... end`\", without adding anything in the _func space. The _func space only exists for storing function tuples so that their names can be used within grant/revoke functions."
msgstr ""

#: ../book/box/authentication.rst:289
msgid "The function for creating a _func tuple is:"
msgstr ""

#: ../book/box/authentication.rst:294
msgid "box.schema.func.create(*function-name* [, *options*])"
msgstr ""

#: ../book/box/authentication.rst:296
msgid "The possible options are:"
msgstr ""

#: ../book/box/authentication.rst:298
msgid ":samp:`if_not_exists = {true|false}` - default = false,"
msgstr ""

#: ../book/box/authentication.rst:299
msgid ":samp:`setuid = {true|false}` - default = false,"
msgstr ""

#: ../book/box/authentication.rst:300
msgid ":samp:`language = {'LUA'|'C'}` - default = 'LUA'."
msgstr ""

#: ../book/box/authentication.rst:304
msgid "box.schema.func.create('f', {language = 'C', setuid = false})"
msgstr ""

#: ../book/box/authentication.rst:308
msgid "Specifying :code:`if_not_exists=true` would cause ``error: Function '...' already exists`` if the function already exists."
msgstr ""

#: ../book/box/authentication.rst:311
msgid "Specifying :code:`setuid=true` would cause the setuid flag (the fourth field in the _func tuple) to have a value meaning \"true\", and the effect of that is that the function's caller is treated as the function's creator, with full privileges. The setuid behavior does not apply for users who connect via :code:`console.connect`."
msgstr ""

#: ../book/box/authentication.rst:316
msgid "Specifying :code:`language='C'` would cause the language field (the fifth field in the _func tuple) to have a value 'C', which means the function was written in C. Tarantool functions are normally written in Lua but can be written in C as well."
msgstr ""

#: ../book/box/authentication.rst:320
msgid "The function for dropping a _func tuple is:"
msgstr ""

#: ../book/box/authentication.rst:325
msgid "box.schema.func.drop(*function-name*)"
msgstr ""

#: ../book/box/authentication.rst:327
msgid "The function for checking whether a _func tuple exists is:"
msgstr ""

#: ../book/box/authentication.rst:332
msgid "box.schema.func.exists(*function-name*)"
msgstr ""

#: ../book/box/authentication.rst:335
msgid "In the following example, a function named 'f7' is created, then it is put in the _func space, then it is used in a ``box.schema.user.grant`` function, then it is dropped:"
msgstr ""

#: ../book/box/authentication.rst:339
msgid "tarantool> function f7()\n"
"         >   box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.func.drop('f7')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:361
msgid "``box.session`` and security"
msgstr ""

#: ../book/box/authentication.rst:363
msgid "After a connection has taken place, the user has access to a \"session\" object which has several functions. The ones which are of interest for security purposes are:"
msgstr ""

#: ../book/box/authentication.rst:370
msgid "box.session.uid()         -- returns the id of the current user\n"
"box.session.user()        -- returns the name of the current user\n"
"box.session.su(*user-name*) -- allows changing current user to 'user-name'"
msgstr ""

#: ../book/box/authentication.rst:374
msgid "If a user types requests directly on the Tarantool server in its :ref:`interactive mode <administration-using_tarantool_as_a_client>`, or if a user connects to the :ref:`admin port <administration-admin_ports>`, then the user by default is 'admin' and has many privileges. If a user connects from an application program via one of the :ref:`connectors <index-box_connectors>`, then the user by default is 'guest' and has few privileges. Typically an admin user will set up and configure objects, then grant privileges to appropriate non-admin users. Typically a guest user will use ``box.session.su()`` to change into a non-generic user to whom admin has granted more than the default privileges. For example, admin might say:"
msgstr ""

#: ../book/box/authentication.rst:387
msgid "box.space._user:insert{123456,0,'manager','user'}\n"
"box.schema.user.grant('manager', 'read', 'space', '_space')\n"
"box.schema.user.grant('manager', 'read', 'space', 'payroll')"
msgstr ""

#: ../book/box/authentication.rst:393
msgid "and later a guest user, who wishes to see the payroll, might say:"
msgstr ""

#: ../book/box/authentication.rst:395
msgid "box.session.su('manager')\n"
"box.space.payroll:select{'Jones'}"
msgstr ""

#: ../book/box/authentication.rst:404
msgid "Roles"
msgstr ""

#: ../book/box/authentication.rst:406
msgid "A role is a container for privileges which can be granted to regular users. Instead of granting and revoking individual privileges, one can put all the privileges in a role and then grant or revoke the role. Role information is in the _user space but the third field - the type field - is 'role' rather than 'user'."
msgstr ""

#: ../book/box/authentication.rst:414
msgid "If a role R1 is granted a privilege X, and user U1 is granted a privilege \"role R1\", then user U1 in effect has privilege X. Then if a role R2 is granted a privilege Y, and role R1 is granted a privilege \"role R2\", then user U1 in effect has both privilege X and privilege Y. In other words, a user gets all the privileges that are granted to a user's roles, directly or indirectly."
msgstr ""

#: ../book/box/authentication.rst:425
msgid "Create a new role."
msgstr ""

#: ../book/box/authentication.rst:429
msgid "Put a privilege in a role."
msgstr ""

#: ../book/box/authentication.rst:433
msgid "Take a privilege out of a role."
msgstr ""

#: ../book/box/authentication.rst:437
msgid "Drop a role."
msgstr ""

#: ../book/box/authentication.rst:441
msgid "Grant a role to a role."
msgstr ""

#: ../book/box/authentication.rst:445
msgid "Revoke a role from a role."
msgstr ""

#: ../book/box/authentication.rst:449
msgid "Check whether a role exists. Returns (type = boolean) true if role-name identifies a role, otherwise false."
msgstr ""

#: ../book/box/authentication.rst:456
msgid "Grant a role to a user."
msgstr ""

#: ../book/box/authentication.rst:460
msgid "Revoke a role from a user."
msgstr ""

#: ../book/box/authentication.rst:462
msgid "There are two predefined roles. The first predefined role, named 'public', is automatically assigned to new users when they are created with :samp:`box.schema.user.create({user-name})` - Therefore a convenient way to grant 'read' on space 't' to every user that will ever exist is: :code:`box.schema.role.grant('public','read','space','t')`. The second predefined role, named 'replication', can be assigned by the 'admin' user to users who need to use replication features."
msgstr ""

#: ../book/box/authentication.rst:472
msgid "Example showing a role within a role"
msgstr ""

#: ../book/box/authentication.rst:474
msgid "In this example, a new user named U1 will insert a new tuple into a new space named T, and will succeed even though user U1 has no direct privilege to do such an insert -- that privilege is inherited from role R1, which in turn inherits from role R2."
msgstr ""

#: ../book/box/authentication.rst:479
msgid "-- This example will work for a user with many privileges, such as 'admin'\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create a user U1 so that later it's possible to say box.session.su('U1')\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to U1 (order doesn't matter)\n"
"box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
"box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
"-- Grant read and execute privileges to R2 (but not to R1 and not to U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"box.schema.role.grant('R2', 'execute', 'universe')\n"
"-- Use box.session.su to say \"now become user U1\"\n"
"box.session.su('U1')\n"
"-- Next insert succeeds because U1 in effect has write privilege on T\n"
"box.space.T:insert{1}"
msgstr ""

#: ../book/box/box_index.rst:30
msgid "Package `box.index`"
msgstr ""

#: ../book/box/box_index.rst:32
msgid "The ``box.index`` package provides read-only access for index definitions and index keys. Indexes are contained in :samp:`box.space.{space-name}.index` array within each space object. They provide an API for ordered iteration over tuples. This API is a direct binding to corresponding methods of index objects of type ``box.index`` in the storage engine."
msgstr ""

#: ../book/box/box_index.rst:44
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../book/box/box_index.rst:46
#: ../book/box/box_index.rst:56
#: ../book/box/box_index.rst:64
#: ../book/box/box_index.rst:114
#: ../book/box/box_index.rst:419
#: ../book/box/box_index.rst:582
#: ../book/box/box_index.rst:611
#: ../book/box/box_index.rst:642
#: ../book/box/box_index.rst:670
#: ../book/box/box_index.rst:703
#: ../book/box/box_index.rst:722
#: ../book/box/box_index.rst:737
#: ../book/box/box_index.rst:764
#: ../book/box/box_index.rst:785
#: ../book/box/box_index.rst:808
msgid "Parameters:"
msgstr ""

#: ../book/box/box_index.rst:48
#: ../book/box/box_index.rst:58
#: ../book/box/box_index.rst:66
#: ../book/box/box_index.rst:766
#: ../book/box/box_index.rst:810
msgid ":samp:`{index_object}` = an :ref:`object reference <index-object_reference>`."
msgstr ""

#: ../book/box/box_index.rst:50
#: ../book/box/box_schema.rst:62
#: ../book/box/box_schema.rst:68
#: ../book/box/box_space.rst:171
#: ../book/box/box_space.rst:173
#: ../book/box/index.rst:176
msgid "boolean"
msgstr ""

#: ../book/box/box_index.rst:54
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../book/box/box_index.rst:62
msgid "An array describing index key fields."
msgstr ""

#: ../book/box/box_index.rst:68
#: ../book/box/box_introspection.rst:84
#: ../book/box/box_schema.rst:77
#: ../book/box/box_space.rst:725
msgid "table"
msgstr ""

#: ../book/box/box_index.rst:72
msgid "tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: NUM\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:90
msgid "This method provides iteration support within an index. The :codeitalic:`bitset-value` or :codeitalic:`search-value` parameter specifies what must match within the index. The :codeitalic:`iterator-type` parameter specifies the rule for matching and ordering. Different index types support different iterators. For example, a TREE index maintains a strict order of keys and can return all tuples in ascending or descending order, starting from the specified key. Other index types, however, do not support ordering."
msgstr ""

#: ../book/box/box_index.rst:100
msgid "To understand consistency of tuples returned by an iterator, it's essential to know the principles of the Tarantool transaction processing subsystem. An iterator in Tarantool does not own a consistent read view. Instead, each procedure is granted exclusive access to all tuples and spaces until there is a \"context switch\": which may happen due to :ref:`the-implicit-yield-rules <atomic-the_implicit_yield_rules>`, or by an explicit call to :ref:`fiber.yield <fiber-yield>`. When the execution flow returns to the yielded procedure, the data set could have changed significantly. Iteration, resumed after a yield point, does not preserve the read view, but continues with the new content of the database. The tutorial :ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>` shows one way that iterators and yields can be used together."
msgstr ""

#: ../book/box/box_index.rst:116
#: ../book/box/box_index.rst:421
#: ../book/box/box_index.rst:584
#: ../book/box/box_index.rst:613
#: ../book/box/box_index.rst:644
#: ../book/box/box_index.rst:672
#: ../book/box/box_index.rst:705
#: ../book/box/box_index.rst:724
#: ../book/box/box_index.rst:739
#: ../book/box/box_index.rst:787
msgid ":samp:`{index_object}` = an :ref:`object reference <index-object_reference>`;"
msgstr ""

#: ../book/box/box_index.rst:117
msgid ":samp:`{bitset-value} | {search-value...}` = what to search for"
msgstr ""

#: ../book/box/box_index.rst:118
msgid ":samp:`{iterator-type}` = as defined in tables below."
msgstr ""

#: ../book/box/box_index.rst:120
msgid "this method returns an iterator closure, i.e. a function which can be used to get the next value on each invocation"
msgstr ""

#: ../book/box/box_index.rst:122
#: ../book/box/box_space.rst:849
msgid "function, tuple"
msgstr ""

#: ../book/box/box_index.rst:124
msgid "Possible errors: Selected iteration type is not supported for the index type, or search value is not supported for the iteration type."
msgstr ""

#: ../book/box/box_index.rst:127
#: ../book/box/box_index.rst:802
msgid "Complexity Factors: Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../book/box/box_index.rst:129
msgid "A search-value can be a number (for example ``1234``), a string (for example ``'abcd'``), or a table of numbers and strings (for example ``{1234, 'abcd'}``). Each part of a search-value will be compared to each part of an index key."
msgstr ""

#: ../book/box/box_index.rst:136
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../book/box/box_index.rst:138
msgid "Note: Formally the logic for TREE index searches is: |br| comparison-operator is = or >= or > or <= or < depending on iterator-type |br| for i = 1 to number-of-parts-of-search-value |br| |nbsp|  if (search-value-part[i] is ``nil`` and <comparison-operator> is \"=\") |br| |nbsp|  or (search-value-part[i] <comparison-operator> index-key-part[i] is true) |br| |nbsp|  then comparison-result[i] is true |br| if all comparison-results are true, then search-value \"matches\" index key. |br| Notice how, according to this logic, regardless what the index-key-part contains, the comparison-result for equality is always true when a search-value-part is ``nil`` or is missing. This behavior of searches with nil is subject to change."
msgstr ""

#: ../book/box/box_index.rst:154
#: ../book/box/box_index.rst:207
#: ../book/box/box_index.rst:241
#: ../book/box/box_index.rst:277
msgid "Arguments"
msgstr ""

#: ../book/box/box_index.rst:156
#: ../book/box/box_index.rst:214
#: ../book/box/box_index.rst:247
#: ../book/box/box_index.rst:282
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../book/box/box_index.rst:156
#: ../book/box/box_index.rst:162
#: ../book/box/box_index.rst:167
#: ../book/box/box_index.rst:174
#: ../book/box/box_index.rst:181
#: ../book/box/box_index.rst:185
#: ../book/box/box_index.rst:191
#: ../book/box/box_index.rst:214
#: ../book/box/box_index.rst:220
#: ../book/box/box_index.rst:282
#: ../book/box/box_index.rst:290
#: ../book/box/box_index.rst:295
#: ../book/box/box_index.rst:300
#: ../book/box/box_index.rst:305
#: ../book/box/box_index.rst:315
msgid "search value"
msgstr ""

#: ../book/box/box_index.rst:156
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. Tuples are returned in ascending order by index key. This is the default."
msgstr ""

#: ../book/box/box_index.rst:162
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../book/box/box_index.rst:162
msgid "Matching is the same as for ``box.index.EQ``. Tuples are returned in descending order by index key."
msgstr ""

#: ../book/box/box_index.rst:167
#: ../book/box/box_index.rst:220
#: ../book/box/box_index.rst:290
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../book/box/box_index.rst:167
msgid "The comparison operator is '>' (greater than). If an index key is greater than a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../book/box/box_index.rst:174
#: ../book/box/box_index.rst:295
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../book/box/box_index.rst:174
msgid "The comparison operator is '>=' (greater than or equal to). If an index key is greater than or equal to a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../book/box/box_index.rst:181
#: ../book/box/box_index.rst:243
#: ../book/box/box_index.rst:279
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../book/box/box_index.rst:181
msgid "Same as box.index.GE."
msgstr ""

#: ../book/box/box_index.rst:185
#: ../book/box/box_index.rst:300
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../book/box/box_index.rst:185
msgid "The comparison operator is '<' (less than). If an index key is less than a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../book/box/box_index.rst:191
#: ../book/box/box_index.rst:305
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../book/box/box_index.rst:191
msgid "The comparison operator is '<=' (less than or equal to). If an index key is less than or equal to a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../book/box/box_index.rst:200
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../book/box/box_index.rst:209
msgid "box.index.ALL"
msgstr ""

#: ../book/box/box_index.rst:209
#: ../book/box/box_index.rst:243
#: ../book/box/box_index.rst:279
msgid "none"
msgstr ""

#: ../book/box/box_index.rst:209
msgid "All index keys match. Tuples are returned in ascending order by hash of index key, which will appear to be random."
msgstr ""

#: ../book/box/box_index.rst:214
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. The number of returned tuples will be 0 or 1. This is the default."
msgstr ""

#: ../book/box/box_index.rst:220
msgid "The comparison operator is '>' (greater than). If a hash of an index key is greater than a hash of a search value, it matches. Tuples are returned in ascending order by hash of index key, which will appear to be random. Provided that the space is not being updated, one can retrieve all the tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} in each search, and using the last returned value from the previous result as the start search value for the next search."
msgstr ""

#: ../book/box/box_index.rst:234
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../book/box/box_index.rst:243
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:247
#: ../book/box/box_index.rst:252
#: ../book/box/box_index.rst:257
#: ../book/box/box_index.rst:262
msgid "bitset value"
msgstr ""

#: ../book/box/box_index.rst:247
msgid "If an index key is equal to a bitset value, it matches. Tuples are returned in their order within the space. This is the default."
msgstr ""

#: ../book/box/box_index.rst:252
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../book/box/box_index.rst:252
msgid "If all of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:257
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../book/box/box_index.rst:257
msgid "If any of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:262
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../book/box/box_index.rst:262
msgid "If all of the bits which are 1 in the bitset value are 0 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:270
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../book/box/box_index.rst:279
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:282
msgid "If all points of the rectangle-or-box defined by the search value are the same as the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space. \"Rectangle-or-box\" means \"rectangle-or-box as explained in section about :ref:`RTREE <box_index-rtree>`\". This is the default."
msgstr ""

#: ../book/box/box_index.rst:290
msgid "If all points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:295
msgid "If all points of the rectangle-or-box defined by the search value are within, or at the side of, the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:300
msgid "If all points of the rectangle-or-box defined by the index key are within the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:305
msgid "If all points of the rectangle-or-box defined by the index key are within, or at the side of, the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:310
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../book/box/box_index.rst:310
msgid "search values"
msgstr ""

#: ../book/box/box_index.rst:310
msgid "If some points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:315
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../book/box/box_index.rst:315
msgid "If some points of the rectangle-or-box defined by the defined by the key are within, or at the side of, defined by the index key, it matches. Tuples are returned in order: nearest neighbor first."
msgstr ""

#: ../book/box/box_index.rst:321
msgid "**First Example of index pairs():**"
msgstr ""

#: ../book/box/box_index.rst:323
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../book/box/box_index.rst:325
msgid "tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'STR', 2, 'STR'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:371
msgid "**Second Example of index pairs():**"
msgstr ""

#: ../book/box/box_index.rst:373
msgid "This Lua code finds all the tuples whose primary key values begin with 'XY'. The assumptions include that there is a one-part primary-key TREE index on the first field, which must be a string. The iterator loop ensures that the search will return tuples where the first value is greater than or equal to 'XY'. The conditional statement within the loop ensures that the looping will stop when the first two letters are not 'XY'."
msgstr ""

#: ../book/box/box_index.rst:381
msgid "for tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:389
msgid "**Third Example of index pairs():**"
msgstr ""

#: ../book/box/box_index.rst:391
msgid "This Lua code finds all the tuples whose primary key values are greater than or equal to 1000, and less than or equal to 1999 (this type of request is sometimes called a \"range search\" or a \"between search\"). The assumptions include that there is a one-part primary-key TREE index on the first field, which must be a number. The iterator loop ensures that the search will return tuples where the first value is greater than or equal to 1000. The conditional statement within the loop ensures that the looping will stop when the first value is greater than 1999."
msgstr ""

#: ../book/box/box_index.rst:401
msgid "for tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:413
msgid "This is an alternative to :ref:`box.space...select() <box_space-select>` which goes via a particular index and can make use of additional parameters that specify the iterator type, and the limit (that is, the maximum number of tuples to return) and the offset (that is, which tuple to start with in the list)."
msgstr ""

#: ../book/box/box_index.rst:422
msgid ":samp:`search-key` = values to be matched against the index key;"
msgstr ""

#: ../book/box/box_index.rst:426
msgid ":samp:`option(s)` any or all of"
msgstr ""

#: ../book/box/box_index.rst:424
msgid ":samp:`iterator = {iterator-type}`,"
msgstr ""

#: ../book/box/box_index.rst:425
msgid ":samp:`limit = {maximum-number-of-tuples}`,"
msgstr ""

#: ../book/box/box_index.rst:426
msgid ":samp:`offset = {start-tuple-number}`."
msgstr ""

#: ../book/box/box_index.rst:428
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../book/box/box_index.rst:429
msgid "tuple set as a Lua table"
msgstr ""

#: ../book/box/box_index.rst:433
msgid "-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'NUM' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'STR'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:459
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../book/box/box_index.rst:461
msgid "---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:470
msgid ":samp:`index.{index-name}` is optional. If it is omitted, then the assumed index is the first (primary-key) index. Therefore, for the example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would have returned the same two rows, via the 'primary' index."
msgstr ""

#: ../book/box/box_index.rst:477
msgid ":samp:`iterator = {iterator-type}` is optional. If it is omitted, then ``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../book/box/box_index.rst:482
msgid ":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, then every key in the index is considered to be a match, regardless of iterator type. Therefore, for the example above, ``box.space.tester:select{}`` will select every tuple in the tester space via the first (primary-key) index."
msgstr ""

#: ../book/box/box_index.rst:492
msgid ":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That is, ``get`` can be used as a convenient shorthand to get the first tuple in the tuple set that would be returned by ``select``. However, if there is more than one tuple in the tuple set, then ``get`` returns an error."
msgstr ""

#: ../book/box/box_index.rst:500
msgid "**Example with BITSET index:**"
msgstr ""

#: ../book/box/box_index.rst:502
msgid "The following script shows creation and search with a BITSET index. Notice: BITSET cannot be unique, so first a primary-key index is created. Notice: bit values are entered as hexadecimal literals for easier reading."
msgstr ""

#: ../book/box/box_index.rst:506
msgid "tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'STR'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'NUM'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:553
msgid "Search for a tuple via the given index, as described :ref:`earlier <box_index-note>`."
msgstr ""

#: ../book/box/box_index.rst:555
#: ../book/box/box_space.rst:247
#: ../book/box/box_space.rst:320
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = key to be matched against the index key, which may be multi-part."
msgstr ""

#: ../book/box/box_index.rst:559
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

#: ../book/box/box_index.rst:560
#: ../book/box/box_index.rst:590
#: ../book/box/box_index.rst:619
#: ../book/box/box_index.rst:648
#: ../book/box/box_index.rst:712
#: ../book/box/box_index.rst:729
#: ../book/box/box_space.rst:227
#: ../book/box/box_space.rst:256
#: ../book/box/box_space.rst:325
#: ../book/box/box_space.rst:406
#: ../book/box/box_space.rst:465
#: ../book/box/box_space.rst:636
#: ../book/box/box_space.rst:820
#: ../book/box/box_tuple.rst:53
#: ../book/box/box_tuple.rst:197
#: ../book/box/box_tuple.rst:198
#: ../book/box/box_tuple.rst:289
#: ../book/box/index.rst:182
msgid "tuple"
msgstr ""

#: ../book/box/box_index.rst:562
msgid "Possible errors: No such index; wrong type; more than one tuple matches."
msgstr ""

#: ../book/box/box_index.rst:564
msgid "Complexity Factors: Index size, Index type. See also :ref:`space_object:get() <box_space-get>`."
msgstr ""

#: ../book/box/box_index.rst:569
msgid "tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:580
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../book/box/box_index.rst:585
#: ../book/box/box_index.rst:614
msgid ":samp:`key-value`."
msgstr ""

#: ../book/box/box_index.rst:587
msgid "the tuple for the first key in the index. If optional ``key-value`` is supplied, returns the first key which is greater than or equal to ``key-value``."
msgstr ""

#: ../book/box/box_index.rst:592
#: ../book/box/box_index.rst:621
msgid "Possible errors: index is not of type 'TREE'."
msgstr ""

#: ../book/box/box_index.rst:594
#: ../book/box/box_index.rst:623
#: ../book/box/box_index.rst:650
msgid "Complexity Factors: Index size, Index type."
msgstr ""

#: ../book/box/box_index.rst:598
msgid "tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:609
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../book/box/box_index.rst:616
msgid "the tuple for the last key in the index. If optional ``key-value`` is supplied, returns the last key which is less than or equal to ``key-value``."
msgstr ""

#: ../book/box/box_index.rst:627
msgid "tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:638
msgid "Find a random value in the specified index. This method is useful when it's important to get insight into data distribution in an index without having to iterate over the entire data set."
msgstr ""

#: ../book/box/box_index.rst:645
msgid ":samp:`random-value` (type = number) = an arbitrary non-negative integer."
msgstr ""

#: ../book/box/box_index.rst:647
msgid "the tuple for the random key in the index."
msgstr ""

#: ../book/box/box_index.rst:652
msgid "Note re storage engine: vinyl does not support ``random()``."
msgstr ""

#: ../book/box/box_index.rst:656
msgid "tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:667
msgid "Iterate over an index, counting the number of tuples which match the key-value."
msgstr ""

#: ../book/box/box_index.rst:673
msgid ":samp:`{key-value}` (type = Lua table or scalar) = the value which must match the key(s) in the specified index. The type may be a list of field-values, or a tuple containing only the field-values;  :codeitalic:`iterator` = comparison method."
msgstr ""

#: ../book/box/box_index.rst:678
msgid "the number of matching index keys."
msgstr ""

#: ../book/box/box_index.rst:679
#: ../book/box/box_index.rst:813
#: ../book/box/box_schema.rst:64
#: ../book/box/box_schema.rst:66
#: ../book/box/box_session.rst:41
#: ../book/box/box_session.rst:46
#: ../book/box/box_session.rst:71
#: ../book/box/box_space.rst:169
#: ../book/box/box_tuple.rst:85
#: ../book/box/box_tuple.rst:110
#: ../book/box/box_tuple.rst:159
#: ../book/box/index.rst:172
msgid "number"
msgstr ""

#: ../book/box/box_index.rst:684
msgid "tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = 'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:697
#: ../book/box/box_space.rst:426
#: ../book/box/box_tuple.rst:274
msgid "Update a tuple."
msgstr ""

#: ../book/box/box_index.rst:699
msgid "Same as :ref:`box.space...update() <box_space-update>`, but key is searched in this index instead of primary key. This index ought to be unique."
msgstr ""

#: ../book/box/box_index.rst:706
msgid ":samp:`{key}` (type = Lua table or scalar) = key to be matched against the index key;"
msgstr ""

#: ../book/box/box_index.rst:708
msgid ":samp:`{operator, field_no, value}` (type = Lua table) = update operations (see: :ref:`box.space...update() <box_space-update>`)."
msgstr ""

#: ../book/box/box_index.rst:711
#: ../book/box/box_space.rst:464
msgid "the updated tuple."
msgstr ""

#: ../book/box/box_index.rst:716
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../book/box/box_index.rst:718
msgid "Same as :ref:`box.space...delete() <box_space-delete>`, but key is searched in this index instead of in the primary-key index. This index ought to be unique."
msgstr ""

#: ../book/box/box_index.rst:725
msgid ":samp:`key` (type = Lua table or scalar) = key to be matched against the index key."
msgstr ""

#: ../book/box/box_index.rst:728
msgid "the deleted tuple."
msgstr ""

#: ../book/box/box_index.rst:735
msgid "Alter an index."
msgstr ""

#: ../book/box/box_index.rst:740
msgid ":samp:`{options}` = options list, same as the options list for :ref:`create_index <box_space-create_index>`."
msgstr ""

#: ../book/box/box_index.rst:743
#: ../book/box/box_index.rst:790
#: ../book/box/box_schema.rst:128
#: ../book/box/box_schema.rst:256
#: ../book/box/box_schema.rst:344
#: ../book/box/box_space.rst:354
#: ../book/box/box_space.rst:376
#: ../book/box/box_space.rst:791
#: ../book/box/index.rst:178
#: ../book/box/index.rst:178
#: ../book/box/triggers.rst:177
#: ../book/box/triggers.rst:227
msgid "nil"
msgstr ""

#: ../book/box/box_index.rst:745
msgid "Possible errors: Index does not exist, or the first index cannot be changed to {unique = false}, or the alter function is only applicable for the memtx storage engine."
msgstr ""

#: ../book/box/box_index.rst:749
msgid "Note re storage engine: vinyl does not support ``alter()``."
msgstr ""

#: ../book/box/box_index.rst:753
msgid "tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:761
msgid "Drop an index. Dropping a primary-key index has a side effect: all tuples are deleted."
msgstr ""

#: ../book/box/box_index.rst:768
msgid "nil."
msgstr ""

#: ../book/box/box_index.rst:770
msgid "Possible errors: Index does not exist, or a primary-key index cannot be dropped while a secondary-key index exists."
msgstr ""

#: ../book/box/box_index.rst:775
msgid "tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:783
msgid "Rename an index."
msgstr ""

#: ../book/box/box_index.rst:788
msgid ":samp:`{index-name}` (type = string) = new name for index."
msgstr ""

#: ../book/box/box_index.rst:792
msgid "Possible errors: index_object does not exist."
msgstr ""

#: ../book/box/box_index.rst:796
msgid "tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:806
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../book/box/box_index.rst:812
#: ../book/box/box_tuple.rst:109
msgid "number of bytes"
msgstr ""

#: ../book/box/box_index.rst:817
msgid "Example showing use of the box functions"
msgstr ""

#: ../book/box/box_index.rst:819
msgid "This example will work with the sandbox configuration described in the preface. That is, there is a space named tester with a numeric primary key. The example function will:"
msgstr ""

#: ../book/box/box_index.rst:823
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../book/box/box_index.rst:824
msgid "return an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../book/box/box_index.rst:827
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../book/box/box_index.rst:826
msgid "field[1] = 1000"
msgstr ""

#: ../book/box/box_index.rst:827
msgid "field[2] = a uuid"
msgstr ""

#: ../book/box/box_index.rst:828
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../book/box/box_index.rst:829
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../book/box/box_index.rst:830
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../book/box/box_index.rst:831
msgid "Return the formatted value."
msgstr ""

#: ../book/box/box_index.rst:833
msgid "The function uses Tarantool box functions :ref:`box.space...select <box_space-select>`, :ref:`box.space...replace <box_space-replace>`, :ref:`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function uses Lua functions `os.date()`_ and `string.sub()`_."
msgstr ""

#: ../book/box/box_index.rst:842
msgid "function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:867
#: ../book/box/box_tuple.rst:337
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../book/box/box_index.rst:869
msgid "tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:886
msgid "Example showing a user-defined iterator"
msgstr ""

#: ../book/box/box_index.rst:888
msgid "Here is an example that shows how to build one's own iterator. The ``paged_iter`` function is an \"iterator function\", which will only be understood by programmers who have read the Lua manual section `Iterators and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated retrievals, that is, it returns 10 tuples at a time from a table named \"t\", whose primary key was defined with :codenormal:`create_index('primary',{parts={1,'STR'}})`."
msgstr ""

#: ../book/box/box_index.rst:898
msgid "function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:912
msgid "Programmers who use ``paged_iter`` do not need to know why it works, they only need to know that, if they call it within a loop, they will get 10 tuples at a time until there are no more tuples. In this example the tuples are merely printed, a page at a time. But it should be simple to change the functionality, for example by yielding after each retrieval, or by breaking when the tuples fail to match some additional criteria."
msgstr ""

#: ../book/box/box_index.rst:922
msgid "for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i=1,#page,1 do print(page[i]) end\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:933
msgid "Package `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../book/box/box_index.rst:935
msgid "The :ref:`box.index <box_index>` package may be used for spatial searches if the index type is RTREE. There are operations for searching *rectangles* (geometric objects with 4 corners and 4 sides) and *boxes* (geometric objects with more than 4 corners and more than 4 sides, sometimes called hyperrectangles). This manual uses the term *rectangle-or-box* for the whole class of objects that includes both rectangles and boxes. Only rectangles will be illustrated."
msgstr ""

#: ../book/box/box_index.rst:942
msgid "Rectangles are described according to their X-axis (horizontal axis) and Y-axis (vertical axis) coordinates in a grid of arbitrary size. Here is a picture of four rectangles on a grid with 11 horizontal points and 11 vertical points:"
msgstr ""

#: ../book/box/box_index.rst:948
msgid "           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""

#: ../book/box/box_index.rst:962
msgid "The rectangles are defined according to this scheme: {X-axis coordinate of top left, Y-axis coordinate of top left, X-axis coordinate of bottom right, Y-axis coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So in the picture ... Rectangle#1 starts at position 1 on the X axis and position 2 on the Y axis, and ends at position 3 on the X axis and position 4 on the Y axis, so its coordinates are {1,2,3,4}. Rectangle#2's coordinates are {3,5,9,10}. Rectangle#3's coordinates are {4,7,5,9}. And finally Rectangle#4's coordinates are {10,11,10,11}. Rectangle#4 is actually a \"point\" since it has zero width and zero height, so it could have been described with only two digits: {10,11}."
msgstr ""

#: ../book/box/box_index.rst:972
msgid "Some relationships between the rectangles are: \"Rectangle#1's nearest neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside Rectangle#2\"."
msgstr ""

#: ../book/box/box_index.rst:975
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../book/box/box_index.rst:977
msgid "tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'NUM'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:990
msgid "Field#1 doesn't matter, we just make it because we need a primary-key index. (RTREE indexes cannot be unique and therefore cannot be primary-key indexes.) The second field must be an \"array\", which means its values must represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let us populate the table by inserting two tuples, containing the coordinates of Rectangle#2 and Rectangle#4."
msgstr ""

#: ../book/box/box_index.rst:996
msgid "tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../book/box/box_index.rst:1001
msgid "And now, following the description of `RTREE iterator types`_, we can search the rectangles with these requests:"
msgstr ""

#: ../book/box/box_index.rst:1006
msgid "tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:1022
msgid "Request#1 returns 1 tuple because the point {10,11} is the same as the rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns 1 tuple because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the picture, is entirely within{3,5,9,10} which was Rectangle#2. Request#3 returns 2 tuples, because the NEIGHBOR iterator always returns all tuples, and the first returned tuple will be {3,5,9,10} (\"Rectangle#2\" in the picture) because it is the closest neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""

#: ../book/box/box_index.rst:1030
msgid "Now let us create a space and index for cuboids, which are rectangle-or-boxes that have 6 corners and 6 sides."
msgstr ""

#: ../book/box/box_index.rst:1033
msgid "tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'NUM'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:1044
msgid "The additional field here is ``dimension=3``. The default dimension is 2, which is why it didn't need to be specified for the examples of rectangle. The maximum dimension is 20. Now for insertions and selections there will usually be 6 coordinates. For example:"
msgstr ""

#: ../book/box/box_index.rst:1048
msgid "tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../book/box/box_index.rst:1053
msgid "Now let us create a space and index for Manhattan-style spatial objects, which are rectangle-or-boxes that have a different way to calculate neighbors."
msgstr ""

#: ../book/box/box_index.rst:1056
msgid "tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'NUM'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:1067
msgid "The additional field here is ``distance='manhattan'``. The default distance calculator is 'euclid', which is the straightforward as-the-crow-flies method. The optional distance calculator is 'manhattan', which can be a more appropriate method if one is following the lines of a grid rather than traveling in a straight line."
msgstr ""

#: ../book/box/box_index.rst:1072
msgid "tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../book/box/box_index.rst:1078
msgid "More examples of spatial searching are online in the file `R tree index quick start and usage`_."
msgstr ""

#: ../book/box/box_introspection.rst:28
msgid "Server introspection"
msgstr ""

#: ../book/box/box_introspection.rst:34
msgid "Package `box.cfg`"
msgstr ""

#: ../book/box/box_introspection.rst:38
msgid "The ``box.cfg`` package is for administrators to specify all the server configuration parameters; the full description of the parameters is in section :ref:`book-cfg <index-book_cfg>`. Use ``box.cfg`` without braces to get read-only access to those parameters."
msgstr ""

#: ../book/box/box_introspection.rst:45
msgid "tarantool> box.cfg\n"
"---\n"
"- snapshot_count: 6\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  slab_alloc_maximal: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:59
msgid "Package `box.info`"
msgstr ""

#: ../book/box/box_introspection.rst:63
msgid "The ``box.info`` package provides access to information about server variables. Some important ones:"
msgstr ""

#: ../book/box/box_introspection.rst:66
msgid "**server.uuid** holds the unique identifier of the server. This value is also in the :ref:`box.space._cluster <box_space-cluster>` system space."
msgstr ""

#: ../book/box/box_introspection.rst:68
msgid "**pid** is the process ID of the server. This value is also shown by the :ref:`tarantool <tarantool-build>` package."
msgstr ""

#: ../book/box/box_introspection.rst:70
msgid "**version** is the Tarantool version. This value is also shown by :ref:`tarantool --version <index-tarantool_version>`."
msgstr ""

#: ../book/box/box_introspection.rst:72
msgid "**uptime** is the number of seconds since the server started."
msgstr ""

#: ../book/box/box_introspection.rst:78
msgid "Since ``box.info`` contents are dynamic, it's not possible to iterate over keys with the Lua ``pairs()`` function. For this purpose, ``box.info()`` builds and returns a Lua table with all keys and values provided in the package."
msgstr ""

#: ../book/box/box_introspection.rst:83
msgid "keys and values in the package."
msgstr ""

#: ../book/box/box_introspection.rst:88
msgid "tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 158\n"
"    ro: false\n"
"    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
"    id: 1\n"
"  version: 1.7.0-1216-g73f7154\n"
"  pid: 12932\n"
"  status: running\n"
"  vclock:\n"
"  - 158\n"
"  replication:\n"
"    status: off\n"
"  uptime: 908\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-66-g9093daa\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:125
msgid "Package `box.slab`"
msgstr ""

#: ../book/box/box_introspection.rst:129
msgid "The ``box.slab`` package provides access to slab allocator statistics. The slab allocator is the main allocator used to store tuples. This can be used to monitor the total memory use and memory fragmentation."
msgstr ""

#: ../book/box/box_introspection.rst:133
msgid "The display of slabs is broken down by the slab size -- 64-byte, 136-byte, and so on. The example omits the slabs which are empty. The example display is saying that: there are 16 items stored in the 64-byte slab (and 16*64=102 so bytes_used = 1024); there is 1 item stored in the 136-byte slab (and 136*1=136 so bytes_used = 136); the arena_used value is the total of all the bytes_used values (1024+136 = 1160); the arena_size value is the arena_used value plus the total of all the bytes_free values (1160+4193200+4194088 = 8388448). The arena_size and arena_used values are the amount of the % of :ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` that is already distributed to the slab allocator."
msgstr ""

#: ../book/box/box_introspection.rst:145
msgid "tarantool> box.slab.info().arena_used\n"
"---\n"
"- 4194304\n"
"...\n"
"tarantool> box.slab.info().arena_size\n"
"---\n"
"- 104857600\n"
"...\n"
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16248\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15736\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"    <...>\n"
"...\n"
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 15736\n"
"  mem_used: 560\n"
"  item_count: 14\n"
"  item_size: 40\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:185
msgid "Package `box.stat`"
msgstr ""

#: ../book/box/box_introspection.rst:187
msgid "The ``box.stat`` package provides access to request and network statistics. Show the average number of requests per second, and the total number of requests since startup, broken down by request type and network events statistics."
msgstr ""

#: ../book/box/box_introspection.rst:191
msgid "tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: []\n"
"- []\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVENTS:\n"
"    total: 2\n"
"    rps: 0\n"
"  LOCKS:\n"
"    total: 6\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../book/box/box_schema.rst:30
msgid "Package `box.schema`"
msgstr ""

#: ../book/box/box_schema.rst:34
msgid "The ``box.schema`` package has data-definition functions for spaces, users, roles, and function tuples."
msgstr ""

#: ../book/box/box_schema.rst:41
msgid "Create a space."
msgstr ""

#: ../book/box/box_schema.rst:43
msgid "name of space, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:45
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../book/box/box_schema.rst:47
msgid "space object"
msgstr ""

#: ../book/box/box_schema.rst:48
msgid "userdata"
msgstr ""

#: ../book/box/box_schema.rst:52
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../book/box/box_schema.rst:60
#: ../book/box/box_space.rst:163
msgid "Effect"
msgstr ""

#: ../book/box/box_schema.rst:60
#: ../book/box/box_space.rst:163
msgid "Default"
msgstr ""

#: ../book/box/box_schema.rst:62
msgid "temporary"
msgstr ""

#: ../book/box/box_schema.rst:62
msgid "space is temporary"
msgstr ""

#: ../book/box/box_schema.rst:62
#: ../book/box/box_schema.rst:68
msgid "false"
msgstr ""

#: ../book/box/box_schema.rst:64
#: ../book/box/box_space.rst:169
msgid "id"
msgstr ""

#: ../book/box/box_schema.rst:64
#: ../book/box/box_space.rst:169
msgid "unique identifier"
msgstr ""

#: ../book/box/box_schema.rst:64
msgid "last space's id, +1"
msgstr ""

#: ../book/box/box_schema.rst:66
msgid "field_count"
msgstr ""

#: ../book/box/box_schema.rst:66
msgid "fixed field count"
msgstr ""

#: ../book/box/box_schema.rst:66
msgid "0 i.e. not fixed"
msgstr ""

#: ../book/box/box_schema.rst:68
#: ../book/box/box_schema.rst:254
#: ../book/box/box_space.rst:173
msgid "if_not_exists"
msgstr ""

#: ../book/box/box_schema.rst:68
#: ../book/box/box_space.rst:173
msgid "no error if duplicate name"
msgstr ""

#: ../book/box/box_schema.rst:71
msgid "engine"
msgstr ""

#: ../book/box/box_schema.rst:71
msgid "storage engine = :ref:`'memtx' or 'vinyl' <index-two_storage_engines>`"
msgstr ""

#: ../book/box/box_schema.rst:71
#: ../book/box/box_schema.rst:75
#: ../book/box/box_schema.rst:208
#: ../book/box/box_session.rst:61
#: ../book/box/index.rst:174
msgid "string"
msgstr ""

#: ../book/box/box_schema.rst:71
msgid "'memtx'"
msgstr ""

#: ../book/box/box_schema.rst:75
msgid "user name"
msgstr ""

#: ../book/box/box_schema.rst:75
msgid "current user's name"
msgstr ""

#: ../book/box/box_schema.rst:77
msgid "format"
msgstr ""

#: ../book/box/box_schema.rst:77
msgid "field names+types"
msgstr ""

#: ../book/box/box_schema.rst:77
msgid "(blank)"
msgstr ""

#: ../book/box/box_schema.rst:80
msgid "the numeric identifier established by box.schema.space.create"
msgstr ""

#: ../book/box/box_schema.rst:82
msgid "There are five :ref:`syntax variations <index-object_reference>` for object references targeting space objects, for example :samp:`box.schema.space.drop({space-id})` will drop a space. However, the common approach is to use functions attached to the space objects, for example :ref:`space_object:drop() <box_space-drop>`."
msgstr ""

#: ../book/box/box_schema.rst:88
msgid "Note re storage engine: vinyl does not support temporary spaces."
msgstr ""

#: ../book/box/box_schema.rst:94
msgid "tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })"
msgstr ""

#: ../book/box/box_schema.rst:110
msgid "For an illustration with the :code:`format` clause, see :ref:`box.space._space <box_space-space>` example."
msgstr ""

#: ../book/box/box_schema.rst:113
msgid "After a space is created, usually the next step is to :ref:`create an index <box_space-create_index>` for it, and then it is available for insert, select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""

#: ../book/box/box_schema.rst:120
msgid "Create a user. For explanation of how Tarantool maintains user data, see section :ref:`Users and the _user space <authentication-users>`."
msgstr ""

#: ../book/box/box_schema.rst:124
msgid "name of user, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:126
msgid "if_not_exists, password"
msgstr ""

#: ../book/box/box_schema.rst:130
#: ../book/box/box_schema.rst:178
#: ../book/box/box_schema.rst:196
#: ../book/box/box_schema.rst:226
#: ../book/box/box_schema.rst:258
#: ../book/box/box_schema.rst:297
#: ../book/box/box_schema.rst:314
#: ../book/box/box_schema.rst:346
msgid "**Examples:**"
msgstr ""

#: ../book/box/box_schema.rst:132
msgid "box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../book/box/box_schema.rst:140
msgid "Drop a user. For explanation of how Tarantool maintains user data, see section :ref:`Users and the _user space <authentication-users>`."
msgstr ""

#: ../book/box/box_schema.rst:144
#: ../book/box/box_schema.rst:158
#: ../book/box/box_schema.rst:171
#: ../book/box/box_schema.rst:189
msgid "the name of the user"
msgstr ""

#: ../book/box/box_schema.rst:145
msgid "if_exists"
msgstr ""

#: ../book/box/box_schema.rst:149
msgid "box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../book/box/box_schema.rst:156
msgid "Return true if a user exists; return false if a user does not exist."
msgstr ""

#: ../book/box/box_schema.rst:159
#: ../book/box/box_schema.rst:280
#: ../book/box/box_schema.rst:370
msgid "bool"
msgstr ""

#: ../book/box/box_schema.rst:163
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../book/box/box_schema.rst:169
msgid "Grant :ref:`privileges <authentication-privileges>` to a user."
msgstr ""

#: ../book/box/box_schema.rst:172
#: ../book/box/box_schema.rst:190
#: ../book/box/box_schema.rst:291
msgid "either privilege,object-type,object-name or privilege,'universe' where privilege = 'read' or 'write' or 'execute' or a combination and object-type = 'space' or 'function'. Or: role-name."
msgstr ""

#: ../book/box/box_schema.rst:180
msgid "box.schema.user.grant('Lena', 'read', 'space', 'tester') |br| box.schema.user.grant('Lena', 'execute', 'function', 'f') |br| box.schema.user.grant('Lena', 'read,write', 'universe') |br| box.schema.user.grant('Lena', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:187
msgid "Revoke :ref:`privileges <authentication-privileges>` from a user."
msgstr ""

#: ../book/box/box_schema.rst:198
msgid "box.schema.user.revoke('Lena', 'read', 'space', 'tester') |br| box.schema.user.revoke('Lena', 'execute', 'function', 'f') |br| box.schema.user.revoke('Lena', 'read,write', 'universe') |br| box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:205
msgid "Return a hash of a password."
msgstr ""

#: ../book/box/box_schema.rst:207
#: ../book/box/box_schema.rst:224
msgid "password"
msgstr ""

#: ../book/box/box_schema.rst:212
msgid "box.schema.user.password('')"
msgstr ""

#: ../book/box/box_schema.rst:216
msgid "Associate a password with the user who is currently logged in. or with another user. Users who wish to change their own passwords should use box.schema.user.passwd(password). Administrators who wish to change passwords of other users should use box.schema.user.passwd(user-name, password)."
msgstr ""

#: ../book/box/box_schema.rst:223
msgid "user-name"
msgstr ""

#: ../book/box/box_schema.rst:228
msgid "box.schema.user.passwd('') |br| box.schema.user.passwd('Lena', '')"
msgstr ""

#: ../book/box/box_schema.rst:233
msgid "Return a description of a user's privileges."
msgstr ""

#: ../book/box/box_schema.rst:235
msgid "the name of the user. This is optional; if it is not supplied, then the information will be for the user who is currently logged in."
msgstr ""

#: ../book/box/box_schema.rst:243
msgid "box.schema.user.info() |br| box.schema.user.info('Lena')"
msgstr ""

#: ../book/box/box_schema.rst:248
msgid "Create a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../book/box/box_schema.rst:252
msgid "name of role, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:260
msgid "box.schema.role.create('Accountant') |br| box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../book/box/box_schema.rst:265
msgid "Drop a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../book/box/box_schema.rst:269
#: ../book/box/box_schema.rst:279
#: ../book/box/box_schema.rst:290
#: ../book/box/box_schema.rst:308
msgid "the name of the role"
msgstr ""

#: ../book/box/box_schema.rst:273
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:277
msgid "Return true if a role exists; return false if a role does not exist."
msgstr ""

#: ../book/box/box_schema.rst:284
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:288
msgid "Grant :ref:`privileges <authentication-privileges>` to a role."
msgstr ""

#: ../book/box/box_schema.rst:299
msgid "box.schema.role.grant('Accountant', 'read', 'space', 'tester') |br| box.schema.role.grant('Accountant', 'execute', 'function', 'f') |br| box.schema.role.grant('Accountant', 'read,write', 'universe') |br| box.schema.role.grant('public', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:306
msgid "Revoke :ref:`privileges <authentication-privileges>` to a role."
msgstr ""

#: ../book/box/box_schema.rst:309
msgid "either privilege,object-type,object-name or privilege,'universe' where privilege = 'read' or 'write' or 'execute' or a combination and object-type = 'space' or 'function'"
msgstr ""

#: ../book/box/box_schema.rst:316
msgid "box.schema.role.revoke('Accountant', 'read', 'space', 'tester') |br| box.schema.role.revoke('Accountant', 'execute', 'function', 'f') |br| box.schema.role.revoke('Accountant', 'read,write', 'universe') |br| box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:323
msgid "Return a description of a role's privileges."
msgstr ""

#: ../book/box/box_schema.rst:325
msgid "the name of the role."
msgstr ""

#: ../book/box/box_schema.rst:329
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:333
msgid "Create a function tuple. This does not create the function itself -- that is done with Lua -- but if it is necessary to grant privileges for a function, box.schema.func.create must be done first. For explanation of how Tarantool maintains function data, see section :ref:`Functions and the _func space <authentication-funcs>`."
msgstr ""

#: ../book/box/box_schema.rst:340
msgid "name of function, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:342
msgid "if_not_exists, setuid, language"
msgstr ""

#: ../book/box/box_schema.rst:348
msgid "box.schema.func.create('calculate') |br| box.schema.func.create('calculate', {if_not_exists = false}) |br| box.schema.func.create('calculate', {setuid = false}) |br| box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../book/box/box_schema.rst:355
msgid "Drop a function tuple. For explanation of how Tarantool maintains function data, see section :ref:`Functions and the _func space <authentication-funcs>`."
msgstr ""

#: ../book/box/box_schema.rst:359
#: ../book/box/box_schema.rst:369
msgid "the name of the function"
msgstr ""

#: ../book/box/box_schema.rst:363
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../book/box/box_schema.rst:367
msgid "Return true if a function tuple exists; return false if a function tuple does not exist."
msgstr ""

#: ../book/box/box_schema.rst:374
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../book/box/box_session.rst:28
msgid "Package `box.session`"
msgstr ""

#: ../book/box/box_session.rst:30
msgid "The ``box.session`` package allows querying the session state, writing to a session-specific temporary Lua table, or setting up triggers which will fire when a session starts or ends. A *session* is an object associated with each client connection."
msgstr ""

#: ../book/box/box_session.rst:39
msgid "the unique identifier (ID) for the current session. The result can be 0 meaning there is no session."
msgstr ""

#: ../book/box/box_session.rst:45
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../book/box/box_session.rst:50
msgid "This function works only if there is a peer, that is, if a connection has been made to a separate server."
msgstr ""

#: ../book/box/box_session.rst:53
msgid "The host address and port of the session peer, for example \"127.0.0.1:55457\". If the session exists but there is no connection to a separate server, the return is null. The command is executed on the server, so the \"local name\" is the server's host and port, and the \"peer name\" is the client's host and port."
msgstr ""

#: ../book/box/box_session.rst:63
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../book/box/box_session.rst:67
msgid "the value of the :code:`sync` integer constant used in the `binary protocol <https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants.h>`_."
msgstr ""

#: ../book/box/box_session.rst:77
msgid "A Lua table that can hold arbitrary unordered session-specific names and values, which will last until the session ends."
msgstr ""

#: ../book/box/box_session.rst:84
msgid "tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../book/box/box_session.rst:109
msgid "See the section :ref:`Triggers <triggers-box_triggers>` for instructions about defining triggers for connect and disconnect events with ``box.session.on_connect()`` and ``box.session.on_disconnect()``. See the section :ref:`Access control <authentication>` for instructions about ``box.session`` functions that affect user identification and security."
msgstr ""

#: ../book/box/box_space.rst:30
msgid "Package `box.space`"
msgstr ""

#: ../book/box/box_space.rst:32
msgid "The ``box.space`` package has the data-manipulation functions ``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``get``, ``put``. It also has members, such as id, and whether or not a space is enabled. Package source code is available in file `src/box/lua/schema.lua <https://github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."
msgstr ""

#: ../book/box/box_space.rst:38
msgid "A list of all ``box.space`` functions follows, then comes a list of all ``box.space`` members."
msgstr ""

#: ../book/box/box_space.rst:43
msgid "**The functions and members of box.space**"
msgstr ""

#: ../book/box/box_space.rst:49
msgid "Use"
msgstr ""

#: ../book/box/box_space.rst:51
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../book/box/box_space.rst:51
msgid "Create an index"
msgstr ""

#: ../book/box/box_space.rst:54
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../book/box/box_space.rst:54
msgid "Insert a tuple"
msgstr ""

#: ../book/box/box_space.rst:57
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../book/box/box_space.rst:57
msgid "Select one or more tuples"
msgstr ""

#: ../book/box/box_space.rst:60
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../book/box/box_space.rst:60
msgid "Select a tuple"
msgstr ""

#: ../book/box/box_space.rst:63
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../book/box/box_space.rst:63
msgid "Destroy a space"
msgstr ""

#: ../book/box/box_space.rst:66
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../book/box/box_space.rst:66
msgid "Rename a space"
msgstr ""

#: ../book/box/box_space.rst:69
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../book/box/box_space.rst:69
#: ../book/box/box_space.rst:72
msgid "Insert or replace a tuple"
msgstr ""

#: ../book/box/box_space.rst:72
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../book/box/box_space.rst:75
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../book/box/box_space.rst:75
#: ../book/box/box_space.rst:78
msgid "Update a tuple"
msgstr ""

#: ../book/box/box_space.rst:78
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../book/box/box_space.rst:81
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../book/box/box_space.rst:81
msgid "Delete a tuple"
msgstr ""

#: ../book/box/box_space.rst:84
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../book/box/box_space.rst:84
#: ../book/box/box_space.rst:87
msgid "Get count of tuples"
msgstr ""

#: ../book/box/box_space.rst:87
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../book/box/box_space.rst:90
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../book/box/box_space.rst:90
msgid "Delete all tuples"
msgstr ""

#: ../book/box/box_space.rst:93
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../book/box/box_space.rst:93
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../book/box/box_space.rst:96
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../book/box/box_space.rst:96
msgid "Prepare for iterating"
msgstr ""

#: ../book/box/box_space.rst:99
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../book/box/box_space.rst:99
msgid ".Numeric identifier of space"
msgstr ""

#: ../book/box/box_space.rst:102
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../book/box/box_space.rst:102
msgid ".Flag, true if space is enabled"
msgstr ""

#: ../book/box/box_space.rst:105
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../book/box/box_space.rst:105
msgid ".Required number of fields"
msgstr ""

#: ../book/box/box_space.rst:108
msgid ":ref:`space_object.index <box_space-field_count>`"
msgstr ""

#: ../book/box/box_space.rst:108
msgid ".Container of space's indexes"
msgstr ""

#: ../book/box/box_space.rst:111
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../book/box/box_space.rst:111
msgid ".(Metadata) List of schemas"
msgstr ""

#: ../book/box/box_space.rst:114
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../book/box/box_space.rst:114
msgid ".(Metadata) List of spaces"
msgstr ""

#: ../book/box/box_space.rst:117
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../book/box/box_space.rst:117
msgid ".(Metadata) List of indexes"
msgstr ""

#: ../book/box/box_space.rst:120
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../book/box/box_space.rst:120
msgid ".(Metadata) List of users"
msgstr ""

#: ../book/box/box_space.rst:123
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../book/box/box_space.rst:123
msgid ".(Metadata) List of privileges"
msgstr ""

#: ../book/box/box_space.rst:126
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../book/box/box_space.rst:126
msgid ".(Metadata) List of clusters"
msgstr ""

#: ../book/box/box_space.rst:140
msgid "Create an index. It is mandatory to create an index for a tuple set before trying to insert tuples into it, or select tuples from it. The first created index, which will be used as the primary-key index, must be unique."
msgstr ""

#: ../book/box/box_space.rst:145
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`index_name` (type = string) = name of index, which should not be a number and should not contain special characters; :codeitalic:`options`."
msgstr ""

#: ../book/box/box_space.rst:150
msgid "index object"
msgstr ""

#: ../book/box/box_space.rst:151
msgid "index_object"
msgstr ""

#: ../book/box/box_space.rst:155
msgid "Options for ``space_object:create_index``:"
msgstr ""

#: ../book/box/box_space.rst:165
msgid "type"
msgstr ""

#: ../book/box/box_space.rst:165
msgid "type of index"
msgstr ""

#: ../book/box/box_space.rst:165
msgid "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE')"
msgstr ""

#: ../book/box/box_space.rst:165
msgid "'TREE'"
msgstr ""

#: ../book/box/box_space.rst:169
msgid "last index's id, +1"
msgstr ""

#: ../book/box/box_space.rst:171
msgid "unique"
msgstr ""

#: ../book/box/box_space.rst:171
msgid "index is unique"
msgstr ""

#: ../book/box/box_space.rst:171
msgid "``true``"
msgstr ""

#: ../book/box/box_space.rst:173
msgid "``false``"
msgstr ""

#: ../book/box/box_space.rst:176
msgid "parts"
msgstr ""

#: ../book/box/box_space.rst:176
msgid "field-numbers  + types"
msgstr ""

#: ../book/box/box_space.rst:176
msgid "{field_no, 'NUM' or 'STR' or 'INT' or 'NUMBER' or 'ARRAY' or 'SCALAR'}"
msgstr ""

#: ../book/box/box_space.rst:176
msgid "``{1, 'NUM'}``"
msgstr ""

#: ../book/box/box_space.rst:181
msgid "Possible errors: too many parts. Index '...' already exists. Primary key must be unique."
msgstr ""

#: ../book/box/box_space.rst:183
msgid "Note re storage engine: vinyl supports only the TREE index type, and supports only one index per space, and supports only the unique = true option."
msgstr ""

#: ../book/box/box_space.rst:187
msgid "tarantool> s = box.space.space55\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, 'NUM', 2, 'STR'}})\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:198
msgid "Details about index field types: |br| The five index field types (NUM | STR | INT | NUMBER | ARRAY | SCALAR) differ depending on what values are allowed, and what index types are allowed. |br| NUM: unsigned integers between 0 and 18446744073709551615. Legal in memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes. |br| STR: strings -- any set of octets, up to the :ref:`maximum length <limitations_bytes_in_index_key>`. Legal in memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes. |br| INT: integers between -9223372036854775808 and 18446744073709551615. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes. |br| NUMBER: integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, or double-precision floating point numbers. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes. |br| ARRAY: array of integers between -9223372036854775808 and 9223372036854775807. Legal in memtx RTREE indexes. |br| SCALAR: booleans (true or false), or integers between -9223372036854775808 and 18446744073709551615, or single-precision floating point numbers, or double-precison floating-point numbers, or strings. When there is a mix of types, the key order is: booleans, then numbers, then strings. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../book/box/box_space.rst:221
msgid "Insert a tuple into a space."
msgstr ""

#: ../book/box/box_space.rst:223
#: ../book/box/box_space.rst:402
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`tuple` (type = Lua table or tuple) = tuple to be inserted."
msgstr ""

#: ../book/box/box_space.rst:226
msgid "the inserted tuple"
msgstr ""

#: ../book/box/box_space.rst:229
msgid "Possible errors: If a tuple with the same unique-key value already exists, returns :errcode:`ER_TUPLE_FOUND`."
msgstr ""

#: ../book/box/box_space.rst:234
msgid "tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:245
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../book/box/box_space.rst:251
msgid "the tuples whose primary-key fields are equal to the passed field-values. If the number of passed field-values is less than the number of fields in the primary key, then only the passed field-values are compared, so ``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../book/box/box_space.rst:258
msgid "Possible errors: No such space; wrong type."
msgstr ""

#: ../book/box/box_space.rst:260
msgid "**Complexity Factors:** Index size, Index type."
msgstr ""

#: ../book/box/box_space.rst:264
msgid "tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'NUM', 2, 'STR'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:309
msgid "For examples of complex ``select`` requests, where one can specify which index to search and what condition to use (for example \"greater than\" instead of \"equal to\") and how many tuples to return, see the later section :ref:`index_object:select <box_index-select>`."
msgstr ""

#: ../book/box/box_space.rst:318
msgid "Search for a tuple in the given space."
msgstr ""

#: ../book/box/box_space.rst:324
msgid "the tuple whose index key matches :codeitalic:`key`, or null."
msgstr ""

#: ../book/box/box_space.rst:327
#: ../book/box/box_space.rst:356
msgid "Possible errors: If space_object does not exist."
msgstr ""

#: ../book/box/box_space.rst:329
#: ../book/box/box_space.rst:358
#: ../book/box/box_space.rst:413
#: ../book/box/box_space.rst:822
msgid "**Complexity Factors:** Index size, Index type, Number of indexes accessed, WAL settings."
msgstr ""

#: ../book/box/box_space.rst:332
msgid "The ``box.space...select`` function returns a set of tuples as a Lua table; the ``box.space...get`` function returns at most a single tuple. And it is possible to get the first tuple in a tuple set by appending ``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as ``box.space.tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""

#: ../book/box/box_space.rst:342
msgid "box.space.tester:get{1}"
msgstr ""

#: ../book/box/box_space.rst:350
msgid "Drop a space."
msgstr ""

#: ../book/box/box_space.rst:352
#: ../book/box/box_space.rst:668
#: ../book/box/box_space.rst:686
#: ../book/box/box_space.rst:706
#: ../book/box/box_space.rst:723
#: ../book/box/box_space.rst:763
#: ../book/box/box_space.rst:787
#: ../book/box/box_space.rst:846
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`."
msgstr ""

#: ../book/box/box_space.rst:363
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../book/box/box_space.rst:371
msgid "Rename a space."
msgstr ""

#: ../book/box/box_space.rst:373
msgid "Parameters::samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`space-name` (type = string) = new name for space."
msgstr ""

#: ../book/box/box_space.rst:378
msgid "Possible errors: space_object does not exist."
msgstr ""

#: ../book/box/box_space.rst:382
msgid "tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:396
msgid "Insert a tuple into a space. If a tuple with the same primary key already exists, ``box.space...:replace()`` replaces the existing tuple with a new one. The syntax variants ``box.space...:replace()`` and ``box.space...:put()`` have the same effect; the latter is sometimes used to show that the effect is the converse of ``box.space...:get()``."
msgstr ""

#: ../book/box/box_space.rst:405
#: ../book/box/box_space.rst:819
msgid "the inserted tuple."
msgstr ""

#: ../book/box/box_space.rst:408
msgid "Possible errors: If a different tuple with the same unique-key value already exists, returns :errcode:`ER_TUPLE_FOUND`. (This will only happen if there is a secondary index. By default secondary indexes are unique.)"
msgstr ""

#: ../book/box/box_space.rst:418
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../book/box/box_space.rst:428
msgid "The ``update`` function supports operations on fields  assignment, arithmetic (if the field is unsigned numeric), cutting and pasting fragments of a field, deleting or inserting a field. Multiple operations can be combined in a single update request, and in this case they are performed atomically and sequentially. Each operation requires specification of a field number. When multiple operations are present, the field number for each operation is assumed to be relative to the most recent state of the tuple, that is, as if all previous operations in a multi-operation update have already been applied. In other words, it is always safe to merge multiple ``update`` invocations into a single invocation, with no change in semantics."
msgstr ""

#: ../book/box/box_space.rst:440
msgid "Possible operators are:"
msgstr ""

#: ../book/box/box_space.rst:442
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../book/box/box_space.rst:443
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../book/box/box_space.rst:444
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:445
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:446
msgid "``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:447
msgid "``:`` for string splice"
msgstr ""

#: ../book/box/box_space.rst:448
msgid "``!`` for insertion"
msgstr ""

#: ../book/box/box_space.rst:449
msgid "``#`` for deletion"
msgstr ""

#: ../book/box/box_space.rst:450
msgid "``=`` for assignment"
msgstr ""

#: ../book/box/box_space.rst:452
msgid "For ``!`` and ``=`` operations the field number can be ``-1``, meaning the last field in the tuple."
msgstr ""

#: ../book/box/box_space.rst:455
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = primary-key field values, must be passed as a Lua table if key is multi-part; :codeitalic:`{operator, field_no, value}` (type = table): a group of arguments for each operation, indicating what the operation is, what field the operation will apply to, and what value will be applied. The field number can be negative, meaning the position from the end of tuple (#tuple + negative field number + 1)."
msgstr ""

#: ../book/box/box_space.rst:467
msgid "Possible errors: it is illegal to modify a primary-key field."
msgstr ""

#: ../book/box/box_space.rst:469
msgid "**Complexity Factors:** Index size, Index type, number of indexes accessed, WAL settings."
msgstr ""

#: ../book/box/box_space.rst:472
msgid "Thus, in the instruction:"
msgstr ""

#: ../book/box/box_space.rst:474
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../book/box/box_space.rst:478
msgid "the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` meaning *add a value to a field and then assign a value to a field*, the first affected field is field ``1`` and the value which will be added to it is ``55``, the second affected field is field ``3`` and the value which will be assigned to it is ``'x'``."
msgstr ""

#: ../book/box/box_space.rst:486
msgid "Assume that the initial state of the database is ``tester`` that has one tuple set and one primary key whose type is ``NUM``. There is one tuple, with ``field[1]`` = ``999`` and ``field[2]`` = ``'A'``."
msgstr ""

#: ../book/box/box_space.rst:490
#: ../book/box/box_space.rst:505
#: ../book/box/box_space.rst:516
#: ../book/box/box_space.rst:527
#: ../book/box/box_space.rst:539
#: ../book/box/box_space.rst:552
#: ../book/box/box_space.rst:564
msgid "In the update:"
msgstr ""

#: ../book/box/box_space.rst:492
msgid "box.space.tester:update(999, {{'=', 2, 'B'}})"
msgstr ""

#: ../book/box/box_space.rst:496
msgid "The first argument is ``tester``, that is, the affected space is ``tester``. The second argument is ``999``, that is, the affected tuple is identified by primary key value = 999. The third argument is ``=``, that is, there is one operation  *assignment to a field*. The fourth argument is ``2``, that is, the affected field is ``field[2]``. The fifth argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'``."
msgstr ""

#: ../book/box/box_space.rst:507
msgid "box.space.tester:update({999}, {{'=', 2, 'B'}})"
msgstr ""

#: ../book/box/box_space.rst:511
msgid "the arguments are the same, except that the key is passed as a Lua table (inside braces). This is unnecessary when the primary key has only one field, but would be necessary if the primary key had more than one field. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../book/box/box_space.rst:518
msgid "box.space.tester:update({999}, {{'=', 3, 1}})"
msgstr ""

#: ../book/box/box_space.rst:522
msgid "the arguments are the same, except that the fourth argument is ``3``, that is, the affected field is ``field[3]``. It is okay that, until now, ``field[3]`` has not existed. It gets added. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``1``."
msgstr ""

#: ../book/box/box_space.rst:529
msgid "box.space.tester:update({999}, {{'+', 3, 1}})"
msgstr ""

#: ../book/box/box_space.rst:533
msgid "the arguments are the same, except that the third argument is ``'+'``, that is, the operation is addition rather than assignment. Since ``field[3]`` previously contained ``1``, this means we're adding ``1`` to ``1``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../book/box/box_space.rst:541
msgid "box.space.tester:update({999}, {{'|', 3, 1}, {'=', 2, 'C'}})"
msgstr ""

#: ../book/box/box_space.rst:545
msgid "the idea is to modify two fields at once. The formats are ``'|'`` and ``=``, that is, there are two operations, OR and assignment. The fourth and fifth arguments mean that ``field[3]`` gets OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]`` gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""

#: ../book/box/box_space.rst:554
msgid "box.space.tester:update({999}, {{'#', 2, 1}, {'-', 2, 3}})"
msgstr ""

#: ../book/box/box_space.rst:558
msgid "The idea is to delete ``field[2]``, then subtract ``3`` from ``field[3]``. But after the delete, there is a renumbering, so ``field[3]`` becomes ``field[2]``` before we subtract ``3`` from it, and that's why the seventh argument is ``2``, not ``3``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../book/box/box_space.rst:566
msgid "box.space.tester:update({999}, {{'=', 2, 'XYZ'}})"
msgstr ""

#: ../book/box/box_space.rst:570
msgid "we're making a long string so that splice will work in the next example. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../book/box/box_space.rst:573
msgid "In the update"
msgstr ""

#: ../book/box/box_space.rst:575
msgid "box.space.tester:update({999}, {{':', 2, 2, 1, '!!'}})"
msgstr ""

#: ../book/box/box_space.rst:579
msgid "The third argument is ``':'``, that is, this is the example of splice. The fourth argument is ``2`` because the change will occur in ``field[2]``. The fifth argument is 2 because deletion will begin with the second byte. The sixth argument is 1 because the number of bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'`` is to be added at this position. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../book/box/box_space.rst:590
msgid "Update or insert a tuple."
msgstr ""

#: ../book/box/box_space.rst:592
msgid "If there is an existing tuple which matches the key fields of ``tuple_value``, then the request has the same effect as :ref:`space_object:update() <box_space-update>` and the ``{{operator, field_no, value}, ...}`` parameter is used. If there is no existing tuple which matches the key fields of ``tuple_value``, then the request has the same effect as :ref:`space_object:insert() <box_space-insert>` and the ``{tuple_value}`` parameter is used. However, unlike ``insert`` or ``update``, ``upsert`` will not read a tuple and perform error checks before returning -- this is a design feature which enhances throughput but requires more caution on the part of the user."
msgstr ""

#: ../book/box/box_space.rst:602
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :samp:`{tuple_value}` (type = Lua table or scalar) = field values, must be passed as a Lua table; :codeitalic:`{operator, field_no, value}` (type = Lua table) = a group of arguments for each operation, indicating what the operation is, what field the operation will apply to, and what value will be applied. The field number can be negative, meaning the position from the end of the tuple (#tuple + negative field number + 1)."
msgstr ""

#: ../book/box/box_space.rst:611
msgid "null."
msgstr ""

#: ../book/box/box_space.rst:613
msgid "Possible errors: it is illegal to modify a primary-key field. It is illegal to use upsert with a space that has a unique secondary index."
msgstr ""

#: ../book/box/box_space.rst:616
msgid "**Complexity factors:** Index size, Index type, number of indexes accessed, WAL settings."
msgstr ""

#: ../book/box/box_space.rst:621
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../book/box/box_space.rst:629
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../book/box/box_space.rst:631
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>` :codeitalic:`key` (type = Lua table or scalar) = key to be matched against the index key, which may be multi-part."
msgstr ""

#: ../book/box/box_space.rst:635
msgid "the deleted tuple"
msgstr ""

#: ../book/box/box_space.rst:638
msgid "**Complexity Factors:** Index size, Index type"
msgstr ""

#: ../book/box/box_space.rst:640
msgid "Note re storage engine: vinyl will return nil, rather than the deleted tuple."
msgstr ""

#: ../book/box/box_space.rst:644
msgid "tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected NUM'\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:663
msgid "Ordinal space number. Spaces can be referenced by either name or number. Thus, if space ``tester`` has ``id = 800``, then ``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are equivalent requests."
msgstr ""

#: ../book/box/box_space.rst:672
msgid "tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:683
msgid "Whether or not this space is enabled. The value is ``false`` if the space has no index."
msgstr ""

#: ../book/box/box_space.rst:692
msgid "The required field count for all tuples in this space. The field_count can be set initially with:"
msgstr ""

#: ../book/box/box_space.rst:698
msgid "box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../book/box/box_space.rst:704
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../book/box/box_space.rst:710
msgid "tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:719
msgid "A container for all defined indexes. There is a Lua object of type :ref:`box.index <box_index>` with methods to search tuples and iterate over them in predefined order."
msgstr ""

#: ../book/box/box_space.rst:729
msgid "tarantool> #box.space.tester.index\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:744
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = key to be matched against the primary index key, which may be multi-part; :codeitalic:`iterator` = comparison method."
msgstr ""

#: ../book/box/box_space.rst:748
msgid "Number of tuples."
msgstr ""

#: ../book/box/box_space.rst:752
msgid "tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:765
msgid "Number of tuples in the space."
msgstr ""

#: ../book/box/box_space.rst:769
msgid "tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:776
msgid "Note re storage engine: vinyl does not support :codenormal:`len(...)`. One possible workaround is to say :codenormal:`#select(...)`."
msgstr ""

#: ../book/box/box_space.rst:783
msgid "Deletes all tuples. Note that ``truncate`` must be called only by the user who created the space OR under a `setuid` function created by that user. Read more about `setuid` functions :ref:`here <authentication-funcs>`."
msgstr ""

#: ../book/box/box_space.rst:789
msgid "**Complexity Factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../book/box/box_space.rst:793
msgid "Note re storage engine: vinyl does not support ``truncate``."
msgstr ""

#: ../book/box/box_space.rst:797
msgid "tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:811
msgid "Insert a new tuple using an auto-increment primary key. The space specified by space_object must have a ``NUM`` primary key index of type ``TREE``. The primary-key field will be incremented before the insert. Note re storage engine: vinyl does not support auto_increment."
msgstr ""

#: ../book/box/box_space.rst:816
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`field-value(s)` (type = Lua table or scalar) = tuple's fields, other than the primary-key field."
msgstr ""

#: ../book/box/box_space.rst:825
msgid "Possible errors: index has wrong type or primary-key indexed field is not a number."
msgstr ""

#: ../book/box/box_space.rst:829
msgid "tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:844
msgid "A helper function to prepare for iterating over all tuples in a space."
msgstr ""

#: ../book/box/box_space.rst:848
msgid "function which can be used in a for/end loop. Within the loop, a value is returned for each iteration."
msgstr ""

#: ../book/box/box_space.rst:853
msgid "tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'NUM'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:884
msgid "``_schema`` is a system tuple set. Its single tuple contains these fields: ``'version', major-version-number, minor-version-number``."
msgstr ""

#: ../book/box/box_space.rst:889
msgid "The following function will display all fields in all tuples of ``_schema``:"
msgstr ""

#: ../book/box/box_space.rst:891
msgid "function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._schema:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      line = line .. v[i] .. ' '\n"
"      i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:908
#: ../book/box/box_space.rst:950
#: ../book/box/box_space.rst:1043
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../book/box/box_space.rst:910
msgid "tarantool> example()\n"
"---\n"
"- - 'cluster 1ec4e1f8-8f1b-4304-bb22-6c47ce0cf9c6 '\n"
"  - 'max_id 520 '\n"
"  - 'version 1 7 0 '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:923
msgid "``_space`` is a system tuple set. Its tuples contain these fields: ``id``, ``uid``, ``space-name``, ``engine``, ``field_count``, ``temporary``, ``format``. These fields are established by :ref:`space.create() <box_schema-space_create>`."
msgstr ""

#: ../book/box/box_space.rst:929
msgid "The following function will display all simple fields in all tuples of ``_space``."
msgstr ""

#: ../book/box/box_space.rst:931
msgid "function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:952
msgid "tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:973
msgid "The following requests will create a space using ``box.schema.space.create`` with a ``format`` clause. Then it retrieves the _space tuple for the new space. This illustrates the typical use of the ``format`` clause, it shows the recommended names and data types for the fields."
msgstr ""

#: ../book/box/box_space.rst:979
msgid "tarantool> box.schema.space.create('TM', {\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field#1\"},\n"
"         >     [2] = {[\"type\"] = \"num\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 522\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(522)\n"
"---\n"
"- - [522, 1, 'TM', 'memtx', 0, '', [{'name': 'field#1'}, {'type': 'num'}]]\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:1007
msgid "``_index`` is a system tuple set. Its tuples contain these fields: ``space-id index-id index-name index-type is-index-unique [tuple-field-no, tuple-field-type ...]``."
msgstr ""

#: ../book/box/box_space.rst:1011
msgid "The following function will display all fields in all tuples of ``_index``: (notice that the fifth field gets special treatment as a map value and the sixth or later fields get special treatment as arrays):"
msgstr ""

#: ../book/box/box_space.rst:1015
msgid "function example()\n"
"  local ta = {}\n"
"  local i, line, value\n"
"  for k, v in box.space._index:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"     while v[i] ~= nil do\n"
"      if i < 5 then\n"
"        value = v[i]\n"
"        end\n"
"      if i == 5 then\n"
"        if v[i].unique == true then\n"
"          value = 'true'\n"
"          end\n"
"        end\n"
"      if i > 5 then\n"
"        value = v[i][1][1] .. ' ' .. v[i][1][2]\n"
"        end\n"
"      line = line .. value .. ' '\n"
"      i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"    end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:1045
msgid "tarantool> example()\n"
"---\n"
"- - '272 0 primary tree true 0 str '\n"
"  - '280 0 primary tree true 0 num '\n"
"  - '280 1 owner tree tree 1 num '\n"
"  - '280 2 name tree true 2 str '\n"
"  - '281 0 primary tree true 0 num '\n"
"  - '281 1 owner tree tree 1 num '\n"
"  - '281 2 name tree true 2 str '\n"
"  - '288 0 primary tree true 0 num '\n"
"  - '288 2 name tree true 0 num '\n"
"  - '289 0 primary tree true 0 num '\n"
"  - '289 2 name tree true 0 num '\n"
"  - '296 0 primary tree true 0 num '\n"
"  - '296 1 owner tree tree 1 num '\n"
"  - '296 2 name tree true 2 str '\n"
"  - '297 0 primary tree true 0 num '\n"
"  - '297 1 owner tree tree 1 num '\n"
"  - '297 2 name tree true 2 str '\n"
"  - '304 0 primary tree true 0 num '\n"
"  - '304 1 owner tree tree 1 num '\n"
"  - '304 2 name tree true 2 str '\n"
"  - '305 0 primary tree true 0 num '\n"
"  - '305 1 owner tree tree 1 num '\n"
"  - '305 2 name tree true 2 str '\n"
"  - '312 0 primary tree true 1 num '\n"
"  - '312 1 owner tree tree 0 num '\n"
"  - '312 2 object tree tree 2 str '\n"
"  - '313 0 primary tree true 1 num '\n"
"  - '313 1 owner tree tree 0 num '\n"
"  - '313 2 object tree tree 2 str '\n"
"  - '320 0 primary tree true 0 num '\n"
"  - '320 1 uuid tree true 1 str '\n"
"  - '512 0 primary tree true 0 num '\n"
"  - '513 0 primary tree true 0 num '\n"
"  - '516 0 primary tree true 0 STR '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:1089
msgid "``_user`` is a system tuple set for support of the :ref:`authorization feature <authentication>`."
msgstr ""

#: ../book/box/box_space.rst:1096
msgid "``_priv`` is a system tuple set for support of the :ref:`authorization feature <authentication>`."
msgstr ""

#: ../book/box/box_space.rst:1103
msgid "``_cluster`` is a system tuple set for support of the :ref:`replication feature <index-box_replication>`."
msgstr ""

#: ../book/box/box_space.rst:1108
msgid "Example: use box.space functions to read _space tuples"
msgstr ""

#: ../book/box/box_space.rst:1110
msgid "This function will illustrate how to look at all the spaces, and for each display: approximately how many tuples it contains, and the first field of its first tuple. The function uses Tarantool ``box.space`` functions ``len()`` and ``pairs()``. The iteration through the spaces is coded as a scan of the ``_space`` system tuple set, which contains metadata. The third field in ``_space`` contains the space name, so the key instruction ``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in the tuple of ``_space`` that we've just fetched with ``pairs()``. The function returns a table:"
msgstr ""

#: ../book/box/box_space.rst:1120
msgid "function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:1144
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../book/box/box_space.rst:1146
msgid "tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:1166
msgid "Example: use box.space functions to organize a _space tuple"
msgstr ""

#: ../book/box/box_space.rst:1168
msgid "The objective is to display field names and field types of a system space -- using metadata to find metadata."
msgstr ""

#: ../book/box/box_space.rst:1171
msgid "To begin: how can one select the _space tuple that describes _space?"
msgstr ""

#: ../book/box/box_space.rst:1173
msgid "A simple way is to look at the constants in box.schema, which tell us that there is an item named SPACE_ID == 288, so these statements will retrieve the correct tuple: |br| :codenormal:`box.space._space:select{288}` |br| or |br| :codenormal:`box.space._space:select{box.schema.SPACE_ID}` |br|"
msgstr ""

#: ../book/box/box_space.rst:1180
msgid "Another way is to look at the tuples in box.space._index, which tell us that there is a secondary index named 'name' for space number 288, so this statement also will retrieve the correct tuple: |br| :codenormal:`box.space._space.index.name:select{'_space'}`"
msgstr ""

#: ../book/box/box_space.rst:1185
msgid "However, the retrieved tuple is not easy to read: |br| :codenormal:`tarantool>` :codebold:`box.space._space.index.name:select{'_space'}` |br| :codenormal:`---` |br| :codenormal:`- - [280, 1, '_space', 'memtx', 0, '', [{'name': 'id',` |br| |nbsp| |nbsp| |nbsp| :codenormal:`'type': 'num'}, {'name': 'owner','type': 'num'},` |br| |nbsp| |nbsp| |nbsp| :codenormal:`{'name': 'name','type': 'str'}, {'name': 'engine',` |br| |nbsp| |nbsp| |nbsp| :codenormal:`'type': 'str'},{'name': 'field_count', 'type': 'num'},` |br| |nbsp| |nbsp| |nbsp| :codenormal:`{'name': 'flags','type': 'str'}, {'name': 'format',` |br| |nbsp| |nbsp| |nbsp| :codenormal:`'type': '*'}]]` |br| |nbsp| |nbsp| |nbsp| :codenormal:`...`"
msgstr ""

#: ../book/box/box_space.rst:1196
msgid "It looks disorganized because field number 7 has been formatted with recommended names and data types. How can one get those specific sub-fields? Since it's visible that field number 7 is an array of maps, this `for` loop will do the organizing: |br| :codenormal:`local tuple_of_space, field_name, field_type` |br| :codenormal:`tuple_of_space = box.space._space.index.name:select{'_space'}[1]` |br| :codenormal:`for i = 1, #tuple_of_space[7], 1` |br| :codenormal:`do` |br| |nbsp| |nbsp| |nbsp| :codenormal:`field_name = tuple_of_space[7][i]['name']` |br| |nbsp| |nbsp| |nbsp| :codenormal:`field_type = tuple_of_space[7][i]['type']` |br| |nbsp| |nbsp| |nbsp| :codenormal:`print(field_name .. ',' ..field_type)` |br| :codenormal:`end`"
msgstr ""

#: ../book/box/box_space.rst:1210
msgid "And here is what happens when one executes the `for` loop: |br| :codenormal:`id,num` |br| :codenormal:`owner,num` |br| :codenormal:`name,str` |br| :codenormal:`engine,str` |br| :codenormal:`field_count,num` |br| :codenormal:`flags,str` |br| :codenormal:`format,*`"
msgstr ""

#: ../book/box/box_tuple.rst:30
msgid "Package `box.tuple`"
msgstr ""

#: ../book/box/box_tuple.rst:34
msgid "The ``box.tuple`` package provides read-only access for the ``tuple`` userdata type. It allows, for a single tuple: selective retrieval of the field contents, retrieval of information about size, iteration over all the fields, and conversion to a Lua table."
msgstr ""

#: ../book/box/box_tuple.rst:43
msgid "Construct a new tuple from either a scalar or a Lua table. Alternatively, one can get new tuples from tarantool's :ref:`select <box_space-select>` or :ref:`insert <box_space-insert>` or :ref:`replace <box_space-replace>` or :ref:`update <box_space-update>` requests, which can be regarded as statements that do ``new()`` implicitly."
msgstr ""

#: ../book/box/box_tuple.rst:50
msgid "the value that will become the tuple contents."
msgstr ""

#: ../book/box/box_tuple.rst:52
msgid "a new tuple"
msgstr ""

#: ../book/box/box_tuple.rst:55
msgid "In the following example, ``x`` will be a new table object containing one tuple and ``t`` will be a new tuple object. Saying ``t`` returns the entire tuple ``t``."
msgstr ""

#: ../book/box/box_tuple.rst:61
msgid "tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:82
msgid "The ``#`` operator in Lua means \"return count of components\". So, if ``t`` is a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../book/box/box_tuple.rst:87
msgid "In the following example, a tuple named ``t`` is created and then the number of fields in ``t`` is returned."
msgstr ""

#: ../book/box/box_tuple.rst:90
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:102
msgid "If ``t`` is a tuple instance, ``t:bsize()`` will return the number of bytes in the tuple. It is useful to check this number when making changes to data, because there is a fixed maximum: one megabyte. Every field has one or more \"length\" bytes preceding the actual contents, so ``bsize()`` returns a value which is slightly greater than the sum of the lengths of the contents."
msgstr ""

#: ../book/box/box_tuple.rst:112
msgid "In the following example, a tuple named ``t`` is created which has three fields, and for each field it takes one byte to store the length and three bytes to store the contents, and a bit for overhead, so ``bsize()`` returns ``3*(1+3)+1``."
msgstr ""

#: ../book/box/box_tuple.rst:117
msgid "tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:129
msgid "If ``t`` is a tuple instance, ``t[field-number]`` will return the field numbered field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../book/box/box_tuple.rst:132
msgid "field value."
msgstr ""

#: ../book/box/box_tuple.rst:133
msgid "lua-value"
msgstr ""

#: ../book/box/box_tuple.rst:135
msgid "In the following example, a tuple named ``t`` is created and then the second field in ``t`` is returned."
msgstr ""

#: ../book/box/box_tuple.rst:138
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:151
msgid "If ``t`` is a tuple instance, ``t:find(search-value)`` will return the number of the first field in ``t`` that matches the search value, and ``t:findall(search-value [, search-value ...])`` will return numbers of all fields in ``t`` that match the search value. Optionally one can put a numeric argument ``field-number`` before the search-value to indicate start searching at field number ``field-number``."
msgstr ""

#: ../book/box/box_tuple.rst:158
msgid "the number of the field in the tuple."
msgstr ""

#: ../book/box/box_tuple.rst:161
msgid "In the following example, a tuple named ``t`` is created and then: the number of the first field in ``t`` which matches 'a' is returned, then the numbers of all the fields in ``t`` which match 'a' are returned, then the numbers of all the fields in t which match 'a' and are at or after the second field are returned."
msgstr ""

#: ../book/box/box_tuple.rst:167
msgid "tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:188
msgid "If ``t`` is a tuple instance, :samp:`t:transform({start-field-number},{fields-to-remove})` will return a tuple where, starting from field ``start-field-number``, a number of fields (``fields-to-remove``) are removed. Optionally one can add more arguments after ``fields-to-remove`` to indicate new values that will replace what was removed."
msgstr ""

#: ../book/box/box_tuple.rst:194
msgid "base 1, may be negative"
msgstr ""

#: ../book/box/box_tuple.rst:200
msgid "In the following example, a tuple named ``t`` is created and then, starting from the second field, two fields are removed but one new one is added, then the result is returned."
msgstr ""

#: ../book/box/box_tuple.rst:204
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:216
msgid "If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, ``t:unpack(1)`` will return all fields starting with field number 1, ``t:unpack(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../book/box/box_tuple.rst:220
msgid "field(s) from the tuple."
msgstr ""

#: ../book/box/box_tuple.rst:221
msgid "lua-value(s)"
msgstr ""

#: ../book/box/box_tuple.rst:223
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected, then the result is returned."
msgstr ""

#: ../book/box/box_tuple.rst:226
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:242
msgid "In Lua, ``lua-table-value:pairs()`` is a method which returns: ``function``, ``lua-table-value``, ``nil``. Tarantool has extended this so that ``tuple-value:pairs()`` returns: ``function``, ``tuple-value``, ``nil``. It is useful for Lua iterators, because Lua iterators traverse a value's components until an end marker is reached."
msgstr ""

#: ../book/box/box_tuple.rst:248
msgid "function, tuple-value, nil"
msgstr ""

#: ../book/box/box_tuple.rst:249
msgid "function, lua-value, nil"
msgstr ""

#: ../book/box/box_tuple.rst:251
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected using a Lua for-end loop."
msgstr ""

#: ../book/box/box_tuple.rst:254
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:276
msgid "This function updates a tuple which is not in a space. Compare the function :code:`box.space.`:samp:`{space-name}`:code:`:update{`:samp:`{key}, {format},` :code:`{`:samp:`{field_number}, {value}`:code:`}...)`, which updates a tuple in a space."
msgstr ""

#: ../book/box/box_tuple.rst:280
msgid "Parameters: briefly: ``format`` indicates the type of update operation such as '``=``' for 'assign new value', ``field_number`` indicates the field number to change such as 2 for field number 2, ``value`` indicates the string which operates on the field such as 'B' for a new assignable value = 'B'."
msgstr ""

#: ../book/box/box_tuple.rst:285
msgid "For details: see the description for ``format``, ``field_number``, and ``value`` in the section :ref:`box.space.space-name:update{key, format, {field_number, value}...) <box_space-update>`."
msgstr ""

#: ../book/box/box_tuple.rst:288
msgid "new tuple"
msgstr ""

#: ../book/box/box_tuple.rst:291
msgid "In the following example, a tuple named ``t`` is created and then its second field is updated to equal 'B'."
msgstr ""

#: ../book/box/box_tuple.rst:294
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:update({{'=',2,'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:308
msgid "This function will illustrate how to convert tuples to/from Lua tables and lists of scalars:"
msgstr ""

#: ../book/box/box_tuple.rst:311
msgid "tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to tuple"
msgstr ""

#: ../book/box/box_tuple.rst:318
msgid "Then it will find the field that contains 'b', remove that field from the tuple, and display how many bytes remain in the tuple. The function uses Tarantool ``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, ``transform()``, ``bsize()``."
msgstr ""

#: ../book/box/box_tuple.rst:323
msgid "function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = {tuple1:unpack()}\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1)\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../book/box/box_tuple.rst:339
msgid "tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../book/box/index.rst:30
msgid "Database"
msgstr ""

#: ../book/box/index.rst:32
msgid "This chapter describes how Tarantool stores values and what operations with data it supports."
msgstr ""

#: ../book/box/index.rst:37
msgid "Document data model"
msgstr ""

#: ../book/box/index.rst:39
msgid "If you tried out the :ref:`Starting Tarantool and making your first database <user_guide_getting_started-first_database>` exercise from the last chapter, then your database looks like this:"
msgstr ""

#: ../book/box/index.rst:43
msgid "+--------------------------------------------+\n"
"|                                            |\n"
"| SPACE 'tester'                             |\n"
"| +----------------------------------------+ |\n"
"| |                                        | |\n"
"| | TUPLE SET 'tester'                     | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Tuple: [ 1 ]                      |  | |\n"
"| | | Tuple: [ 2, 'Music' ]             |  | |\n"
"| | | Tuple: [ 3, 'length', 93 ]        |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| | INDEX 'primary'                        | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Key: 1                            |  | |\n"
"| | | Key: 2                            |  | |\n"
"| | | Key: 3                            |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| +----------------------------------------+ |\n"
"+--------------------------------------------+"
msgstr ""

#: ../book/box/index.rst:69
msgid "Space"
msgstr ""

#: ../book/box/index.rst:71
msgid "A *space* -- 'tester' in the example -- is a container."
msgstr ""

#: ../book/box/index.rst:73
msgid "When Tarantool is being used to store data, there is always at least one space. There can be many spaces. Each space has a unique name specified by the user. Each space has a unique numeric identifier which can be specified by the user but usually is assigned automatically by Tarantool. Spaces always contain one tuple set and one or more indexes."
msgstr ""

#: ../book/box/index.rst:83
msgid "Tuple Set"
msgstr ""

#: ../book/box/index.rst:85
msgid "A *tuple set* -- 'tester' in the example -- is a group of tuples."
msgstr ""

#: ../book/box/index.rst:87
msgid "There is always one tuple set in a space. The identifier of a tuple set is the same as the space name -- 'tester' in the example."
msgstr ""

#: ../book/box/index.rst:91
msgid "A tuple fills the same role as a row or a record, and the components of a tuple (which we call fields) fill the same role as a row column or record field, except that: the fields of a tuple can be composite structures, such as arrays or maps and don't need to have names. That's why there was no need to pre-define the tuple set when creating the space, and that's why each tuple can have a different number of elements. Tuples are stored as `MsgPack`_ arrays."
msgstr ""

#: ../book/box/index.rst:103
msgid "Any given tuple may have any number of fields and the fields may have a variety of types. The identifier of a field is the field's number, base 1. For example 1 can be used in some contexts to refer to the first field of a tuple."
msgstr ""

#: ../book/box/index.rst:108
msgid "When Tarantool returns a tuple value, it surrounds strings with single quotes, separates fields with commas, and encloses the tuple inside square brackets. For example: ``[ 3, 'length', 93 ]``."
msgstr ""

#: ../book/box/index.rst:117
msgid "Index"
msgstr ""

#: ../book/box/index.rst:119
msgid "An *index* -- 'primary' in the example -- is a group of key values and pointers."
msgstr ""

#: ../book/box/index.rst:121
msgid "In order for a tuple set to be useful, there must always be at least one index in a space. There can be many. As with spaces, the user can and should specify the index name, and let Tarantool come up with a unique numeric identifier (the \"index id\"). In our example there is one index and its name is primary."
msgstr ""

#: ../book/box/index.rst:128
msgid "An index may be *multi-part*, that is, the user can declare that an index key value is taken from two or more fields in the tuple, in any order. An index may be *unique*, that is, the user can declare that it would be illegal to have the same key value twice. An index may have *one of four types*: HASH which is fastest and uses the least memory but must be unique, TREE which allows partial-key searching and ordered results, BITSET which can be good for searches that contain '=' and multiple ANDed conditions, and RTREE for spatial coordinates. The first index is called the *primary key* index and it must be unique; all other indexes are called secondary indexes."
msgstr ""

#: ../book/box/index.rst:140
msgid "An index definition may include identifiers of tuple fields and their expected types. The allowed types for indexed fields are NUM (unsigned integer between 0 and 18,446,744,073,709,551,615), or INT (signed integer between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807), or NUMBER (unsigned integer or signed integer or floating-point value), or STR (string, any sequence of octets), or SCALAR (boolean or number or string), or ARRAY (a series of numbers for use with :ref:`RTREE indexes <box_index-rtree>`). Take our example, which has the request:"
msgstr ""

#: ../book/box/index.rst:150
msgid "tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})"
msgstr ""

#: ../book/box/index.rst:154
msgid "The effect is that, for all tuples in tester, field number 1 must exist and must contain an unsigned integer."
msgstr ""

#: ../book/box/index.rst:157
msgid "Space definitions and index definitions are stored permanently in system spaces. It is possible to add, drop, or alter the definitions at runtime, with some restrictions. The syntax details for defining spaces and indexes are in section :ref:`The box library <index-box_library>`."
msgstr ""

#: ../book/box/index.rst:165
msgid "Data types"
msgstr ""

#: ../book/box/index.rst:167
msgid "Tarantool can work with numbers, strings, booleans, tables, and userdata."
msgstr ""

#: ../book/box/index.rst:170
msgid "General type"
msgstr ""

#: ../book/box/index.rst:170
msgid "Specific type"
msgstr ""

#: ../book/box/index.rst:170
msgid "What Lua type()|would return"
msgstr ""

#: ../book/box/index.rst:172
#: ../book/box/index.rst:174
#: ../book/box/index.rst:176
#: ../book/box/index.rst:178
msgid "scalar"
msgstr ""

#: ../book/box/index.rst:172
msgid "\"`number`_\""
msgstr ""

#: ../book/box/index.rst:172
msgid "12345"
msgstr ""

#: ../book/box/index.rst:174
msgid "\"`string`_\""
msgstr ""

#: ../book/box/index.rst:174
msgid "'A B C'"
msgstr ""

#: ../book/box/index.rst:176
msgid "\"`boolean`_\""
msgstr ""

#: ../book/box/index.rst:176
msgid "true"
msgstr ""

#: ../book/box/index.rst:178
msgid "\"`nil`_\""
msgstr ""

#: ../book/box/index.rst:180
#: ../book/box/index.rst:182
msgid "compound"
msgstr ""

#: ../book/box/index.rst:180
msgid "Lua table"
msgstr ""

#: ../book/box/index.rst:180
msgid "\"`table`_\""
msgstr ""

#: ../book/box/index.rst:180
msgid "table: 0x410f8b10"
msgstr ""

#: ../book/box/index.rst:182
msgid "\"`Userdata`_\""
msgstr ""

#: ../book/box/index.rst:182
msgid "12345: {'A B C'}"
msgstr ""

#: ../book/box/index.rst:192
msgid "In Lua a *number* is double-precision floating-point, but Tarantool allows both integer and floating-point values. Tarantool will try to store a number as floating-point if the value contains a decimal point or is very large (greater than 100 billion = 1e14), otherwise Tarantool will store it as an integer. To ensure that even very large numbers will be treated as integers, use the :ref:`tonumber64 <other-tonumber64>` function, or the LL (Long Long) suffix, or the ULL (Unsigned Long Long) suffix. Here are examples of numbers using regular notation, exponential notation, the ULL suffix, and the tonumber64 function: -55,  -2.7e+20, 100000000000000ULL, tonumber64('18446744073709551615')."
msgstr ""

#: ../book/box/index.rst:205
msgid "For database storage Tarantool uses MsgPack rules. Storage is variable-length, so the smallest number requires only one byte but the largest number requires nine bytes. When a field has a 'NUM' index, all values must be unsigned integers between 0 and 18,446,744,073,709,551,615."
msgstr ""

#: ../book/box/index.rst:211
msgid "A *string* is a variable-length sequence of bytes, usually represented with alphanumeric characters inside single quotes."
msgstr ""

#: ../book/box/index.rst:214
msgid "A *boolean* is either ``true`` or ``false``."
msgstr ""

#: ../book/box/index.rst:216
msgid "A *nil* type has only one possible value, also called *nil*, but often displayed as *null*. Nils may be compared to values of any types with == (is-equal) or ~= (is-not-equal), but other operations will not work. Nils may not be used in Lua tables; the workaround is to use :ref:`yaml.NULL <yaml-null>` or :ref:`json.NULL <json-null>` or :ref:`msgpack.NULL <msgpack-null>`."
msgstr ""

#: ../book/box/index.rst:222
msgid "A *tuple* is returned in YAML format like ``- [120, 'a', 'b', 'c']``. A few functions may return tables with multiple tuples. A scalar may be converted to a tuple with only one field. A Lua table may contain all of a tuple's fields, but not nil."
msgstr ""

#: ../book/box/index.rst:227
msgid "For more tuple examples see :ref:`box.tuple <box_tuple>`."
msgstr ""

#: ../book/box/index.rst:231
msgid "Operations"
msgstr ""

#: ../book/box/index.rst:233
msgid "The basic operations are: the five data-change operations (insert, update, upsert, delete, replace), and the data-retrieval operation (select). There are also minor operations like ping which can only be used with the binary protocol. Also, there are :ref:`index iterator <box_index-index_pairs>` operations, which can only be used with Lua code. (Index iterators are for traversing indexes one key at a time, taking advantage of features that are specific to an index type, for example evaluating Boolean expressions when traversing BITSET indexes, or going in descending order when traversing TREE indexes.)"
msgstr ""

#: ../book/box/index.rst:244
msgid "Six examples of basic operations:"
msgstr ""

#: ../book/box/index.rst:246
msgid "-- Add a new tuple to tuple set tester.\n"
"-- The first field, field[1], will be 999 (type is NUM).\n"
"-- The second field, field[2], will be 'Taranto' (type is STR).\n"
"tarantool> box.space.tester:insert{999, 'Taranto'}\n"
"\n"
"-- Update the tuple, changing field field[2].\n"
"-- The clause \"{999}\", which has the value to look up in\n"
"-- the index of the tuple's primary-key field, is mandatory\n"
"-- because update() requests must always have a clause that\n"
"-- specifies the primary key, which in this case is field[1].\n"
"-- The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment\n"
"-- will happen to field[2] with the new value.\n"
"tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
"\n"
"-- Upsert the tuple, changing field field[2] again.\n"
"-- The syntax of upsert is similar to the syntax of update,\n"
"-- but the return value will be different.\n"
"tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
"\n"
"-- Replace the tuple, adding a new field.\n"
"-- This is also possible with the update() request but\n"
"-- the update() request is usually more complicated.\n"
"tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
"\n"
"-- Retrieve the tuple.\n"
"-- The clause \"{999}\" is still mandatory, although it does not have to\n"
"-- mention the primary key.\n"
"tarantool> box.space.tester:select{999}\n"
"\n"
"-- Delete the tuple.\n"
"-- Once again the clause to identify the primary-key field is mandatory.\n"
"tarantool> box.space.tester:delete{999}"
msgstr ""

#: ../book/box/index.rst:281
msgid "How does Tarantool do a basic operation? Let's take this example:"
msgstr ""

#: ../book/box/index.rst:283
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr ""

#: ../book/box/index.rst:287
msgid "which, for those who know SQL, is equivalent to a statement like"
msgstr ""

#: ../book/box/index.rst:289
msgid "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[[1]\" = 3"
msgstr ""

#: ../book/box/index.rst:293
msgid "**STEP #1**: if this is happening on a remote client, then the client parses the statement and changes it to a binary-protocol instruction which has already been checked, and which the server can understand without needing to parse everything again. The client ships a packet to the server."
msgstr ""

#: ../book/box/index.rst:299
msgid "**STEP #2**: the server's transaction processor thread uses the primary-key index on field[1] to find the location of the tuple in memory. It determines that the tuple can be updated (not much can go wrong when you're merely changing an unindexed field value to something shorter)."
msgstr ""

#: ../book/box/index.rst:305
msgid "**STEP #3**: the transaction processor thread sends a message to the write-ahead logging (WAL) thread."
msgstr ""

#: ../book/box/index.rst:308
msgid "At this point a *yield* takes place. To know the significance of that -- and it's quite significant -- you have to know a few facts and a few new words."
msgstr ""

#: ../book/box/index.rst:312
msgid "**FACT #1**: there is only one transaction processor thread. Some people are used to the idea that there can be multiple threads operating on the database, with (say) thread #1 reading row #x while thread#2 writes row#y. With Tarantool no such thing ever happens. Only the transaction processor thread can access the database, and there is only one transaction processor thread for each instance of the server."
msgstr ""

#: ../book/box/index.rst:320
msgid "**FACT #2**: the transaction processor thread can handle many *fibers*. A fiber is a set of computer instructions that may contain \"yield\" signals. The transaction processor thread will execute all computer instructions until a yield, then switch to execute the instructions of a different fiber. Thus (say) the thread reads row#x for the sake of fiber#1, then writes row#y for the sake of fiber#2."
msgstr ""

#: ../book/box/index.rst:329
msgid "**FACT #3**: yields must happen, otherwise the transaction processor thread would stick permanently on the same fiber. There are :ref:`implicit yields <atomic-the_implicit_yield_rules>`: every data-change operation or network-access causes an implicit yield, and every statement that goes through the tarantool client causes an implicit yield. And there are explicit yields: in a Lua function one can and should add yield statements to prevent hogging. This is called *cooperative multitasking*."
msgstr ""

#: ../book/box/index.rst:338
msgid "Since all data-change operations end with an implicit yield and an implicit commit, and since no data-change operation can change more than one tuple, there is no need for any locking. Consider, for example, a Lua function that does three Tarantool operations:"
msgstr ""

#: ../book/box/index.rst:343
msgid "s:select{999}             -- this does not yield and does not commit\n"
"s:update({...},{{...}})   -- this yields and commits\n"
"s:select{999}             -- this does not yield and does not commit"
msgstr ""

#: ../book/box/index.rst:349
msgid "The combination SELECT plus UPDATE is an atomic transaction: the function holds a consistent view of the database until the UPDATE ends. For the combination UPDATE plus SELECT the view is not consistent, because after the UPDATE the transaction processor thread can switch to another fiber, and delete the tuple that was just updated. Note re storage engine: vinyl handles yields differently, see :ref:`differences between memtx and vinyl <vinyl_diff>`. Note re multi-request transactions: there is a way to delay yields, see :ref:`Atomic execution <atomic-atomic_execution>`."
msgstr ""

#: ../book/box/index.rst:359
msgid "Since locks don't exist, and disk writes only involve the write-ahead log, transactions are usually fast. Also the Tarantool server may not be using up all the threads of a powerful multi-core processor, so advanced users may be able to start a second Tarantool server on the same processor without ill effects."
msgstr ""

#: ../book/box/index.rst:364
msgid "Additional examples of requests can be found in the Tarantool regression test suite (https://github.com/tarantool/tarantool/tree/1.7/test/box). A complete grammar of supported data-manipulation functions will come later in this chapter."
msgstr ""

#: ../book/box/index.rst:368
msgid "Since not all Tarantool operations can be expressed with the data-manipulation functions, or with Lua, to gain complete access to data manipulation functionality one must use a :ref:`Perl, PHP, Python or other programming language connector <index-box_connectors>`. The client/server protocol is open and documented. See this :ref:`annotated BNF <box_protocol-iproto_protocol>`."
msgstr ""

#: ../book/box/index.rst:377
msgid "Saving To Disk"
msgstr ""

#: ../book/box/index.rst:379
msgid "Tarantool maintains a set of write-ahead log (WAL) files. There is a separate thread -- the WAL writer -- which catches all requests that can change a database, such as box.schema.create or box.space.insert. Ordinarily the WAL writer writes the request, along with administrative fields and flags, to a WAL file immediately. This ensures data persistence, because, even if an in-memory database is lost when the power goes off, Tarantool recovers it automatically when it starts up again, by reading the WAL files and redoing the requests (this is called the \"recovery process\"). Users can change the timing of the WAL writer, or turn it off, by setting :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""

#: ../book/box/index.rst:391
msgid "Tarantool also maintains a set of snapshot files. A snapshot file is an on-disk copy of the entire data set for a given moment. Instead of reading every WAL file since the databases were created, the recovery process can load the latest snapshot and then read only the WAL files that were produced after the snapshot was made. A snapshot can be made even if there is no WAL file. Some snapshots are automatic, or users can make them at any time with the :ref:`box.snapshot() <admin-snapshot>` request."
msgstr ""

#: ../book/box/index.rst:400
msgid "Details about the WAL writer and the recovery process are in the :ref:`Internals <b_internals>` section."
msgstr ""

#: ../book/box/index.rst:405
msgid "Data manipulation"
msgstr ""

#: ../book/box/index.rst:407
msgid "The basic *data-manipulation* requests are: ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``select``. All of them are part of the ``box`` library. Most of them may return data. Usually both inputs and outputs are Lua tables."
msgstr ""

#: ../book/box/index.rst:411
msgid "The Lua syntax for data-manipulation functions can vary. Here are examples of the variations with ``select`` requests; the same rules exist for the other data-manipulation functions. Every one of the examples does the same thing: select a tuple set from a space named 'tester' where the primary-key field value equals 1. For the examples there is an assumption that the numeric id of 'tester' is 512, which happens to be the case in our sandbox example only."
msgstr ""

#: ../book/box/index.rst:420
msgid "First, there are five *object reference variations*:"
msgstr ""

#: ../book/box/index.rst:422
msgid "-- #1 package . sub-package . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 replace name with a numeric id in square brackets\n"
"tarantool> box.space[512]:select{1}\n"
"-- #4 use a variable instead of a literal for the name\n"
"tarantool> variable = 'tester'\n"
"tarantool> box.space[variable]:select{1}\n"
"-- #5 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""

#: ../book/box/index.rst:437
msgid "Later examples in this manual will usually have the \":samp:`box.space.{tester}:`\" form (#1); however, this is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../book/box/index.rst:441
msgid "Later descriptions in this manual will use the syntax \":code:`space_object:`\" for references to objects which are spaces as in the above examples, and \":code:`index_object:`\" for references to objects which are indexes (for example :samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""

#: ../book/box/index.rst:447
msgid "Then, there are seven *parameter variations*:"
msgstr ""

#: ../book/box/index.rst:449
msgid "-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""

#: ../book/box/index.rst:468
msgid "The primary-key value is enclosed in braces, and if it was a multi-part primary key then the value would be multi-part, for example ``...select{1,2,3}``. The braces can be enclosed inside parentheses  ``...select({...})``  which are optional unless it is necessary to pass something besides the primary-key value, as in example #5. Literal values such as 1 (a scalar value) or {1} (a Lua table value) may be replaced by variable names, as in examples #6 and #7. Although there are special cases where braces can be omitted, they are preferable because they signal \"Lua table\". Examples and descriptions in this manual have the \"{1}\" form; however, this too is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../book/box/index.rst:482
msgid "All the data-manipulation functions operate on tuple sets but, since primary keys are unique, the number of tuples in the tuple set is always 0 or 1. The only exception is ``box.space...select``, which may accept either a primary-key value or a secondary-key value."
msgstr ""

#: ../book/box/index.rst:489
msgid "Index operations"
msgstr ""

#: ../book/box/index.rst:491
msgid "Index operations are automatic: if a data-manipulation request changes a tuple, then it also changes the index keys defined for the tuple. Therefore the user only needs to know how and why to define."
msgstr ""

#: ../book/box/index.rst:496
msgid "The simple index-creation operation which has been illustrated before is:|br| :codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:create_index('index-name')` |br|"
msgstr ""

#: ../book/box/index.rst:499
msgid "By default, this creates a unique \"tree\" index on the first field of all tuples (often called \"Field#1\"), which is assumed to be numeric."
msgstr ""

#: ../book/box/index.rst:502
#: ../book/box/index.rst:546
msgid "These variations exist:"
msgstr ""

#: ../book/box/index.rst:504
msgid "An indexed field may be a string rather than a number.|br| :codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:create_index('index-name',{parts = {1, 'STR'}})` |br| For an ordinary index, the most common data types are 'NUM' = numeric = any non-negative integer, or 'STR' ='string' = any series of bytes. Numbers are ordered according to their point on the number line -- so 2345 is greater than 500 -- while strings are ordered according to the encoding of the first byte then the encoding of the second byte then the encoding of the third byte and so on -- so '2345' is less than '500'."
msgstr ""

#: ../book/box/index.rst:515
msgid "For details about other index types see :ref:`create_index <box_space-create_index>`."
msgstr ""

#: ../book/box/index.rst:517
msgid "There may be more than one field.|br| :codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:create_index('index-name', {parts = {3, 'NUM', 2, 'STR'}})` |br| For an ordinary index, the maximum number of parts is 255. The specification of each part consists of a field number and a type."
msgstr ""

#: ../book/box/index.rst:523
msgid "The index does not have to be unique. |br| :codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:create_index('index-name', {unique=false})` |br| The first index of a tuple set must be unique, but other indexes (\"secondary\" indexes) may be non-unique."
msgstr ""

#: ../book/box/index.rst:528
msgid "The index does not have to be a tree. |br| :codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:create_index('index-name', {type='hash'})` |br| The two ordinary index types are 'tree' which is the default, and 'hash' which must be unique and which may be faster or smaller. The third type is 'bitset' which is not unique and which works best for combinations of binary values. The fourth type is 'rtree' which is not unique and which, instead of 'STR' or 'NUM' values, works with arrays."
msgstr ""

#: ../book/box/index.rst:537
msgid "The existence of indexes does not affect the syntax of data-change requests, but does cause select requests to have more variety."
msgstr ""

#: ../book/box/index.rst:540
msgid "The simple select request which has been illustrated before is: |br| :samp:`box.space.{space-name}:select(value)` |br| By default, this looks for a single tuple via the first index. Since the first index is always unique, the maximum number of returned tuples will be: one."
msgstr ""

#: ../book/box/index.rst:548
msgid "The search can use comparisons other than equality. |br| :codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:select('value', {iterator='GT'})` |br| The comparison operators are LT LE EQ REQ GE GT for \"less than\" \"less than or equal\" \"equal\" \"reversed equal\" \"greater than or equal\" \"greater than\" respectively. Comparisons make sense if and only if the index type is 'tree'."
msgstr ""

#: ../book/box/index.rst:556
msgid "This type of search may return more than one tuple; if so, the tuples will be in descending order by key when the comparison operator is LT or LE or REQ, otherwise in ascending order."
msgstr ""

#: ../book/box/index.rst:561
msgid "The search can use a secondary index. |br| :samp:`box.space.{space-name}.index.{index-name}:select('value')` |br| For a primary-key search, it is optional to specify an index name. For a secondary-key search, it is mandatory."
msgstr ""

#: ../book/box/index.rst:566
msgid "The search may be for some or all key parts. |br| Suppose an index has two parts: {1,'NUM', 2, 'STR'}. |br| Suppose the space has three tuples: {1, 'A'},{1, 'B'},{2, ''}. |br| The search can be for all fields, using a table for the value: |br| :codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:select({1, 'A'})` |br| or the search can be for one field, using a table or a scalar: |br| :samp:`box.space.{space-name}:select(1)` |br| in the second case, the result will be two tuples: {1, 'A'} and {1, 'B'}. It's even possible to specify zero fields, causing all three tuples to be returned."
msgstr ""

#: ../book/box/index.rst:578
msgid "Examples:"
msgstr ""

#: ../book/box/index.rst:580
msgid "BITSET example:"
msgstr ""

#: ../book/box/index.rst:582
msgid "tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET', parts={2,'NUM'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, {iterator='BITS_ANY_SET'})"
msgstr ""

#: ../book/box/index.rst:593
#: ../book/box/index.rst:618
msgid "The result will be:"
msgstr ""

#: ../book/box/index.rst:595
msgid "---\n"
"- - [3, 7]\n"
"- [4, 3]\n"
"..."
msgstr ""

#: ../book/box/index.rst:602
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr ""

#: ../book/box/index.rst:604
msgid "Searches on BITSET indexes can be for BITS_ANY_SET, BITS_ALL_SET, BITS_ALL_NOT_SET, EQ, or ALL."
msgstr ""

#: ../book/box/index.rst:607
msgid "RTREE example:"
msgstr ""

#: ../book/box/index.rst:609
msgid "tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = 'GT'})"
msgstr ""

#: ../book/box/index.rst:620
msgid "---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""

#: ../book/box/index.rst:626
msgid "because a rectangle whose corners are at coordinates 4,7,5,9 is entirely within a rectangle whose corners are at coordinates 3,5,9,10."
msgstr ""

#: ../book/box/index.rst:629
msgid "Searches on RTREE indexes can be for GT, GE, LT, LE, OVERLAPS, or NEIGHBOR."
msgstr ""

#: ../book/box/index.rst:635
msgid "The box library"
msgstr ""

#: ../book/box/index.rst:637
msgid "As well as executing Lua chunks or defining their own functions, users can exploit the Tarantool server's storage functionality with the ``Lua library``."
msgstr ""

#: ../book/box/index.rst:642
msgid "Packages of the box library"
msgstr ""

#: ../book/box/index.rst:644
msgid "The contents of the ``box`` library can be inspected at runtime with ``box``, with no arguments. The packages inside the box library are: ``box.schema``, ``box.tuple``, ``box.space``, ``box.index``, ``box.cfg``, ``box.info``, ``box.slab``, ``box.stat``. Every package contains one or more Lua functions. A few packages contain members as well as functions. The functions allow data definition (create alter drop), data manipulation (insert delete update upsert select replace), and introspection (inspecting contents of spaces, accessing server configuration)."
msgstr ""

#: ../book/box/index.rst:656
msgid "**Complexity Factors that may affect data manipulation functions in the box library**"
msgstr ""

#: ../book/box/index.rst:663
msgid "Index size"
msgstr ""

#: ../book/box/index.rst:663
msgid "The number of index keys is the same as the number of tuples in the data set. For a TREE index, if there are more keys then the lookup time will be greater, although of course the effect is not linear. For a HASH index, if there are more keys then there is more RAM use, but the number of low-level steps tends to remain constant."
msgstr ""

#: ../book/box/index.rst:671
msgid "Index type"
msgstr ""

#: ../book/box/index.rst:671
msgid "Typically a HASH index is faster than a TREE index if the number of tuples in the tuple set is greater than one."
msgstr ""

#: ../book/box/index.rst:675
msgid "Number of indexes accessed"
msgstr ""

#: ../book/box/index.rst:675
msgid "Ordinarily only one index is accessed to retrieve one tuple. But to update the tuple, there must be N accesses if the tuple set has N different indexes."
msgstr ""

#: ../book/box/index.rst:679
msgid "Number of tuples accessed"
msgstr ""

#: ../book/box/index.rst:679
msgid "A few requests, for example select, can retrieve multiple tuples. This factor is usually less important than the others."
msgstr ""

#: ../book/box/index.rst:683
msgid "WAL settings"
msgstr ""

#: ../book/box/index.rst:683
msgid "The important setting for the write-ahead log is :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no writing or delayed writing, this factor is unimportant. If the setting causes every data-change request to wait for writing to finish on a slow device, this factor is more important than all the others."
msgstr ""

#: ../book/box/index.rst:692
msgid "In the discussion of each data-manipulation function there will be a note about which Complexity Factors might affect the function's resource usage."
msgstr ""

#: ../book/box/index.rst:699
msgid "The two storage engines: memtx and vinyl"
msgstr ""

#: ../book/box/index.rst:701
msgid "A storage engine is a set of very-low-level routines which actually store and retrieve tuple values. Tarantool offers a choice of two storage engines: memtx (the in-memory storage engine) and vinyl (the on-disk storage engine). To specify that the engine should be vinyl, add a clause: ``engine = 'vinyl'``. The manual concentrates on memtx because it is the default and has been around longer. But vinyl is a working key-value engine and will especially appeal to users who like to see data go directly to disk, so that recovery time might be shorter and database size might be larger. For architectural explanations and benchmarks, see Appendix D: :ref:`vinyl <index-vinyl>`. On the other hand, vinyl lacks some functions and options that are available with memtx. Where that is the case, the relevant description will contain a note beginning with the words \"Note re storage engine: vinyl\". The end of this chapter has coverage for all :ref:`the differences between memtx and vinyl <vinyl_diff>`."
msgstr ""

#: ../book/box/index.rst:718
msgid "Library Reference"
msgstr ""

#: ../book/box/limitations.rst:28
msgid "Limitations"
msgstr ""

#: ../book/box/limitations.rst:32
msgid "**Number of parts in an index**"
msgstr ""

#: ../book/box/limitations.rst:34
msgid "For TREE or HASH indexes, the maximum is 255 (``box.schema.INDEX_PART_MAX``). For RTREE indexes, the maximum is 1 but the field is an ARRAY. For BITSET indexes, the maximum is 1."
msgstr ""

#: ../book/box/limitations.rst:40
msgid "**Number of indexes in a space**"
msgstr ""

#: ../book/box/limitations.rst:42
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:44
msgid "Note re storage engine: vinyl allows 1 index in a space."
msgstr ""

#: ../book/box/limitations.rst:48
msgid "**Number of fields in a tuple**"
msgstr ""

#: ../book/box/limitations.rst:50
msgid "The theoretical maximum is 2147483647 (``box.schema.FIELD_MAX``). The practical maximum is whatever is specified by the space's :ref:`field_count <box_space-field_count>` member, or the maximum tuple length."
msgstr ""

#: ../book/box/limitations.rst:57
msgid "**Number of bytes in a tuple**"
msgstr ""

#: ../book/box/limitations.rst:59
msgid "By default the value of :ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal>` is 1048576, and the maximum tuple length is approximately one quarter of that: approximately 262,000 bytes. To increase it, when starting the server, specify a larger value. For example :code:`box.cfg{slab_alloc_maximal=2*1048576}`."
msgstr ""

#: ../book/box/limitations.rst:67
msgid "**Number of bytes in an index key**"
msgstr ""

#: ../book/box/limitations.rst:69
msgid "If a field in a tuple can contain a million bytes, then the index key can contain a million bytes, so the maximum is determined by factors such as :ref:`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by the index support."
msgstr ""

#: ../book/box/limitations.rst:76
msgid "**Number of spaces**"
msgstr ""

#: ../book/box/limitations.rst:78
msgid "The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:82
msgid "**Number of connections**"
msgstr ""

#: ../book/box/limitations.rst:84
msgid "The practical limit is the number of file descriptors that one can set with the operating system."
msgstr ""

#: ../book/box/limitations.rst:89
msgid "**Space size**"
msgstr ""

#: ../book/box/limitations.rst:91
msgid "The total maximum size for all spaces is in effect set by :ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>`, which in turn is limited by the total available memory."
msgstr ""

#: ../book/box/limitations.rst:97
msgid "**Update operations count**"
msgstr ""

#: ../book/box/limitations.rst:99
msgid "The maximum number of operations that can be in a single update is 4000 (``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:104
msgid "**Number of users and roles**"
msgstr ""

#: ../book/box/limitations.rst:106
msgid "32 (BOX_USER_MAX)."
msgstr ""

#: ../book/box/limitations.rst:110
msgid "**Length of an index name or space name or user name**"
msgstr ""

#: ../book/box/limitations.rst:112
msgid "32 (``box.schema.NAME_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:116
msgid "**Number of replicas in a cluster**"
msgstr ""

#: ../book/box/limitations.rst:118
msgid "32 (``box.schema.REPLICA_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:122
msgid "For additional limitations which apply only to the vinyl storage engine, see section :ref:`Differences between memtx and vinyl <vinyl_diff>`."
msgstr ""

#: ../book/box/triggers.rst:30
msgid "Triggers"
msgstr ""

#: ../book/box/triggers.rst:32
msgid "Triggers, also known as callbacks, are functions which the server executes when certain events happen. Currently the main types of triggers are `connection triggers`_, which are executed when a session begins or ends, and `replace triggers`_ which are for database events."
msgstr ""

#: ../book/box/triggers.rst:37
msgid "All triggers have the following characteristics:"
msgstr ""

#: ../book/box/triggers.rst:39
msgid "They associate a `function` with an `event`. The request to \"define a trigger\" consists of passing the name of the trigger's function to one of the \":samp:`on_{event-name}()`\" functions: :code:`on_connect()`, :code:`on_auth()`, :code:`on_disconnect()`, or :code:`on_replace()`."
msgstr ""

#: ../book/box/triggers.rst:43
msgid "They are `defined by any user`. There are no privilege requirements for defining triggers."
msgstr ""

#: ../book/box/triggers.rst:45
msgid "They are called `after` the event. They are not called if the event ends prematurely due to an error. (Exception: :code:`on_auth()` is called before the event.)"
msgstr ""

#: ../book/box/triggers.rst:47
msgid "They are in `server memory`. They are not stored in the database. Triggers disappear when the server is shut down. If there is a requirement to make them permanent, then the function definitions and trigger settings should be part of an initialization script."
msgstr ""

#: ../book/box/triggers.rst:51
msgid "They have `low overhead`. If a trigger is not defined, then the overhead is minimal: merely a pointer dereference and check. If a trigger is defined, then its overhead is equivalent to the overhead of calling a stored procedure."
msgstr ""

#: ../book/box/triggers.rst:54
msgid "They can be `multiple` for one event. Triggers are executed in the reverse order that they were defined in."
msgstr ""

#: ../book/box/triggers.rst:56
msgid "They must work `within the event context`. If the function contains requests which normally could not occur immediately after the event but before the return from the event, effects are undefined. For example, putting ``os.exit()`` or ``box.rollback()`` in a trigger function would be bringing in requests outside the event context."
msgstr ""

#: ../book/box/triggers.rst:61
msgid "They are `replaceable`. The request to \"redefine a trigger\" consists of passing the names of a new trigger function and an old trigger function to one of the \"on `event-name` ...\" functions."
msgstr ""

#: ../book/box/triggers.rst:67
msgid "Connection triggers"
msgstr ""

#: ../book/box/triggers.rst:71
msgid "Define a trigger for execution when a new session is created due to an event such as :ref:`console.connect <console-connect>`. The trigger function will be the first thing executed after a new session is created. If the trigger fails by raising an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../book/box/triggers.rst:76
#: ../book/box/triggers.rst:103
#: ../book/box/triggers.rst:175
#: ../book/box/triggers.rst:205
msgid "function which will become the trigger function"
msgstr ""

#: ../book/box/triggers.rst:77
#: ../book/box/triggers.rst:104
#: ../book/box/triggers.rst:176
#: ../book/box/triggers.rst:206
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../book/box/triggers.rst:78
#: ../book/box/triggers.rst:105
#: ../book/box/triggers.rst:207
msgid "nil or function list"
msgstr ""

#: ../book/box/triggers.rst:80
#: ../book/box/triggers.rst:107
#: ../book/box/triggers.rst:179
#: ../book/box/triggers.rst:209
msgid "If the parameters are (nil, old-trigger-function-name), then the old trigger is deleted."
msgstr ""

#: ../book/box/triggers.rst:84
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../book/box/triggers.rst:93
msgid "If a trigger always results in an error, it may become impossible to connect to the server to reset it."
msgstr ""

#: ../book/box/triggers.rst:98
msgid "Define a trigger for execution after a client has disconnected. If the trigger function causes an error, the error is logged but otherwise is ignored. The trigger is invoked while the session associated with the client still exists and can access session properties, such as box.session.id."
msgstr ""

#: ../book/box/triggers.rst:111
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../book/box/triggers.rst:122
msgid "After the following series of requests, the server will write a message using the :ref:`log <log>` package whenever any user connects or disconnects."
msgstr ""

#: ../book/box/triggers.rst:125
msgid "function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../book/box/triggers.rst:140
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../book/box/triggers.rst:142
msgid "2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../book/box/triggers.rst:153
msgid "Authentication triggers"
msgstr ""

#: ../book/box/triggers.rst:157
msgid "Define a trigger for execution during authentication."
msgstr ""

#: ../book/box/triggers.rst:159
msgid "The on_auth trigger function is invoked in these circumstances: (1) The :ref:`console.connect <console-connect>` function includes an authentication check for all users except 'guest'; for this case the on_auth trigger function is invoked after the on_connect trigger function, if and only if the connection has succeeded so far. (2) The binary protocol has a separate :ref:`authentication packet <box_protocol-authentication>` -- for this case, connection and authentication are considered to be separate steps."
msgstr ""

#: ../book/box/triggers.rst:166
msgid "Unlike other trigger types, on_auth trigger functions are invoked `before` the event. Therefore a trigger function like :code:`function auth_function () v = box.session.user(); end` will set :code:`v` to \"guest\", the user name before the authentication is done. To get the user name after the authentication is done, use the special syntax: :code:`function auth_function (user_name) v = user_name; end`"
msgstr ""

#: ../book/box/triggers.rst:172
msgid "If the trigger fails by raising an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../book/box/triggers.rst:183
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../book/box/triggers.rst:193
msgid "Replace triggers"
msgstr ""

#: ../book/box/triggers.rst:201
msgid "Create a \"``replace trigger``\". The ``function-name`` will be executed whenever a ``replace()`` or ``insert()`` or ``update()`` or ``upsert()`` or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../book/box/triggers.rst:213
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../book/box/triggers.rst:222
msgid "At the time that a trigger is defined, it is automatically enabled - that is, it will be executed. Replace triggers can be disabled with :samp:`box.space.{space-name}:run_triggers(false)` and re-enabled with :samp:`box.space.{space-name}:run_triggers(true)`."
msgstr ""

#: ../book/box/triggers.rst:231
msgid "tarantool> box.space.X:run_triggers(false)"
msgstr ""

#: ../book/box/triggers.rst:240
msgid "The following series of requests will create a space, create an index, create a function which increments a counter, create a trigger, do two inserts, drop the space, and display the counter value - which is 2, because the function is executed once after each insert."
msgstr ""

#: ../book/box/triggers.rst:245
msgid "tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'NUM'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../book/box/triggers.rst:261
msgid "Another Example"
msgstr ""

#: ../book/box/triggers.rst:263
msgid "The following series of requests will associate an existing function named F with an existing space named T, associate the function a second time with the same space (so it will be called twice), disable all triggers of T, and delete each trigger by replacing with ``nil``."
msgstr ""

#: ../book/box/triggers.rst:268
msgid "tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../book/box/triggers.rst:278
msgid "Getting a list of triggers"
msgstr ""

#: ../book/box/triggers.rst:280
msgid "The code :code:`on_connect()` -- with no arguments -- returns a table of all connect-trigger functions; :code:`on_auth()` returns all authentication-trigger functions; :code:`on_disconnect()` returns all disconnect-trigger functions; :code:`on_replace()` returns all replace-trigger functions. In the following example a user finds that there are three functions associated with :code:`on_connect` triggers, and executes the third function, which happens to contain the line \"print('function #3')\". Then it deletes the third trigger."
msgstr ""

#: ../book/box/triggers.rst:291
msgid "tarantool> box.session.on_connect()\n"
"---\n"
"- - 'function: 0x416ab6f8'\n"
"  - 'function: 0x416ab6f8'\n"
"  - 'function: 0x416ad800'\n"
"...\n"
"\n"
"tarantool> box.session.on_connect()[3]()\n"
"function #3\n"
"---\n"
"...\n"
"tarantool> box.session.on_connect(nil, box.session.on_connect()[3])\n"
"---\n"
"..."
msgstr ""

#: ../book/box/vinyl_diff.rst:30
msgid "Differences between memtx and vinyl storage engines"
msgstr ""

#: ../book/box/vinyl_diff.rst:32
msgid "The primary difference between memtx and vinyl is that memtx is an \"in-memory\" engine while vinyl is an \"on-disk\" engine. An in-memory storage engine is generally faster, and the memtx engine is justifiably the default for Tarantool, but there are two situations where an on-disk engine such as vinyl would be preferable:"
msgstr ""

#: ../book/box/vinyl_diff.rst:39
msgid "(1) when the database is larger than the available memory and adding more memory is not a realistic option; (2) when the server frequently goes down due to errors or a simple desire to save power -- bringing the server back up and restoring a memtx database into memory takes time."
msgstr ""

#: ../book/box/vinyl_diff.rst:45
msgid "Here are behavior differences which affect programmers. All of these differences have been noted elsewhere in sentences that begin with the words \"Note re storage engine: vinyl\"."
msgstr ""

#: ../book/box/vinyl_diff.rst:49
msgid "With memtx, the maximum number of indexes per space is 128. |br| With vinyl, the maximum is 1, that is, only primary indexes are supported. Since primary indexes are always unique, it follows that vinyl indexes must be unique."
msgstr ""

#: ../book/box/vinyl_diff.rst:53
msgid "With memtx, the index type can be TREE or HASH or RTREE or BITSET. |br| With vinyl, the only index type is TREE."
msgstr ""

#: ../book/box/vinyl_diff.rst:56
msgid "With memtx, for index searches, ``nil`` is considered to be equal to any scalar. With vinyl, ``nil`` or missing parts are not allowed."
msgstr ""

#: ../book/box/vinyl_diff.rst:59
msgid "With memtx, temporary spaces are supported. |br| With vinyl, they are not."
msgstr ""

#: ../book/box/vinyl_diff.rst:62
msgid "With memtx, the :ref:`alter() <box_index-alter>` and :ref:`len() <box_space-len>` and :ref:`random() <box_index-random>` and :ref:`auto_increment() <box_space-auto_increment>` and :ref:`truncate() <box_space-truncate>` functions are supported. |br| With vinyl, they are not."
msgstr ""

#: ../book/box/vinyl_diff.rst:67
msgid "With memtx, the :ref:`count() <box_index-count>` function takes a constant amount of time. |br| With vinyl, it takes a variable amount of time depending on index size."
msgstr ""

#: ../book/box/vinyl_diff.rst:71
msgid "With memtx, delete will return deleted tuple, if any. |br| With vinyl, delete will always return nil."
msgstr ""

#: ../book/box/vinyl_diff.rst:74
msgid "It was explained :ref:`earlier <index-yields_must_happen>` that memtx does not \"yield\" on a select request, it yields only on data-change requests. However, vinyl does yield on a select request, or on an equivalent such as get() or pairs(). This has significance for :ref:`cooperative multitasking <atomic-cooperative_multitasking>`."
msgstr ""

#: ../book/box/vinyl_diff.rst:79
msgid "For more about vinyl, see Appendix D :ref:`vinyl <index-vinyl>`."
msgstr ""

#: ../book/configuration/index.rst:30
msgid "Configuration reference"
msgstr ""

#: ../book/configuration/index.rst:32
msgid "This chapter provides a reference of options which can be set on the command line or in an initialization file."
msgstr ""

#: ../book/configuration/index.rst:38
msgid "Tarantool is started by entering the command:"
msgstr ""

#: ../book/configuration/index.rst:43
msgid "$ **tarantool**\n"
"# OR\n"
"$ **tarantool** *options*\n"
"# OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../book/configuration/index.rst:51
msgid "Command options"
msgstr ""

#: ../book/configuration/index.rst:55
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../book/configuration/index.rst:61
msgid "Print product name and version, for example:"
msgstr ""

#: ../book/configuration/index.rst:63
msgid "$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../book/configuration/index.rst:70
msgid "In this example:"
msgstr ""

#: ../book/configuration/index.rst:72
msgid "Tarantool is the name of the reusable asynchronous networking programming framework."
msgstr ""

#: ../book/configuration/index.rst:75
msgid "The 3-number version follows the standard ``<major>-<minor>-<patch>`` scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` is incremented for each new milestone and indicates possible incompatible changes, and ``<patch>`` stands for the number of bug fix releases made after the start of the milestone. For non-released versions only, there may be a commit number and commit SHA1 to indicate how much this particular build has diverged from the last release."
msgstr ""

#: ../book/configuration/index.rst:83
msgid "Target is the platform tarantool was built on. Some platform-specific details may follow this line."
msgstr ""

#: ../book/configuration/index.rst:88
msgid "Tarantool uses `git describe`_ to produce its version id, and this id can be used at any time to check out the corresponding source from our `git repository`_."
msgstr ""

#: ../book/configuration/index.rst:99
msgid "URI"
msgstr ""

#: ../book/configuration/index.rst:101
msgid "Some configuration parameters and some functions depend on a URI, or \"Universal Resource Identifier\". The URI string format is similar to the `generic syntax for a URI schema`_. So it may contain (in order) a user name for login, a password, a host name or host IP address, and a port number. Only the port number is always mandatory. The password is mandatory if the user name is specified, unless the user name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or ``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or '[::]' is assumed, meaning respectively any IPv4 address or any IPv6 address, on the local machine. If username:password is omitted, then 'guest' is assumed. Some examples:"
msgstr ""

#: ../book/configuration/index.rst:121
msgid "URI fragment"
msgstr ""

#: ../book/configuration/index.rst:123
msgid "port"
msgstr ""

#: ../book/configuration/index.rst:123
msgid "3301"
msgstr ""

#: ../book/configuration/index.rst:125
msgid "host:port"
msgstr ""

#: ../book/configuration/index.rst:125
msgid "127.0.0.1:3301"
msgstr ""

#: ../book/configuration/index.rst:127
msgid "username:password@host:port"
msgstr ""

#: ../book/configuration/index.rst:127
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../book/configuration/index.rst:130
msgid "In certain circumstances a Unix domain socket may be used where a URI is expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply \"/tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../book/configuration/index.rst:138
msgid "Initialization file"
msgstr ""

#: ../book/configuration/index.rst:140
msgid "If the command to start Tarantool includes :codeitalic:`lua-initialization-file`, then Tarantool begins by invoking the Lua program in the file, which by convention may have the name \"``script.lua``\". The Lua program may get further arguments from the command line or may use operating-system functions, such as ``getenv()``. The Lua program almost always begins by invoking ``box.cfg()``, if the database server will be used or if ports need to be opened. For example, suppose ``script.lua`` contains the lines"
msgstr ""

#: ../book/configuration/index.rst:148
msgid "#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    slab_alloc_arena    = 0.1,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../book/configuration/index.rst:159
msgid "and suppose the environment variable LISTEN_URI contains 3301, and suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``. Then the screen might look like this:"
msgstr ""

#: ../book/configuration/index.rst:163
msgid "$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../book/configuration/index.rst:177
msgid "If one wishes to start an interactive session on the same terminal after initialization is complete, one can use :ref:`console.start() <console-start>`."
msgstr ""

#: ../book/configuration/index.rst:191
msgid "Configuration parameters"
msgstr ""

#: ../book/configuration/index.rst:193
msgid "Configuration parameters have the form:"
msgstr ""

#: ../book/configuration/index.rst:198
msgid "box.cfg{ *key = value* [, *key = value* ...]]"
msgstr ""

#: ../book/configuration/index.rst:200
msgid "Since ``box.cfg`` may contain many configuration parameters and since some of the parameters (such as directory addresses) are semi-permanent, it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is the initialization file which is specified on the tarantool command line."
msgstr ""

#: ../book/configuration/index.rst:205
msgid "Most configuration parameters are for allocating resources, opening ports, and specifying database behavior. All parameters are optional. A few parameters are dynamic, that is, they can be changed at runtime by calling ``box.cfg{}`` a second time."
msgstr ""

#: ../book/configuration/index.rst:210
msgid "To see all the non-null parameters, say ``box.cfg`` (no parentheses). To see a particular parameter, for example the listen address, say ``box.cfg.listen``."
msgstr ""

#: ../book/configuration/index.rst:213
msgid "The following sections describe all parameters for basic operation, for storage, for binary logging and snapshots, for replication, for networking, and for logging."
msgstr ""

#: ../book/configuration/index.rst:218
msgid "Basic parameters"
msgstr ""

#: ../book/configuration/cfg_basic.rst:4
msgid "Run the server as a background task. The :ref:`logger <cfg_logging-logger>` and :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for this to work."
msgstr ""

#: ../book/configuration/cfg_basic.rst:7
#: ../book/configuration/cfg_basic.rst:15
msgid "Type: boolean |br| Default: false |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg_basic.rst:13
msgid "Deprecated. Do not use."
msgstr ""

#: ../book/configuration/cfg_basic.rst:23
msgid "Add the given string to the server's :ref:`Process title <administration-proctitle>` (whats shown in the COMMAND column for :samp:`ps -ef` and :samp:`top -c` commands)."
msgstr ""

#: ../book/configuration/cfg_basic.rst:26
msgid "For example, ordinarily :samp:`ps -ef` shows the Tarantool server process thus:"
msgstr ""

#: ../book/configuration/cfg_basic.rst:28
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../book/configuration/cfg_basic.rst:33
msgid "But if the configuration parameters include ``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""

#: ../book/configuration/cfg_basic.rst:36
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: sessions"
msgstr ""

#: ../book/configuration/cfg_basic.rst:41
msgid "Type: string |br| Default: null |br| Dynamic: yes |br|"
msgstr ""

#: ../book/configuration/cfg_basic.rst:49
msgid "The read/write data port number or :ref:`URI <index-uri>` (Universal Resource Identifier) string. Has no default value, so **must be specified** if connections will occur from remote clients that do not use the :ref:`admin port <administration-admin_ports>`. Connections made with :samp:`listen={URI}` are sometimes called \"binary protocol\" or \"primary port\" connections."
msgstr ""

#: ../book/configuration/cfg_basic.rst:54
msgid "A typical value is 3301. The listen parameter may also be set for :ref:`local hot standby <book_cfg_local_hot_standby>`."
msgstr ""

#: ../book/configuration/cfg_basic.rst:57
msgid "NOTE: A replica also binds to this port, and accepts connections, but these connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../book/configuration/cfg_basic.rst:60
msgid "Type: integer or string |br| Default: null |br| Dynamic: yes |br|"
msgstr ""

#: ../book/configuration/cfg_basic.rst:68
msgid "Store the process id in this file. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. A typical value is :file:`tarantool.pid`."
msgstr ""

#: ../book/configuration/cfg_basic.rst:71
#: ../book/configuration/cfg_basic.rst:113
#: ../book/configuration/cfg_basic.rst:144
#: ../book/configuration/cfg_logging.rst:85
msgid "Type: string |br| Default: null |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg_basic.rst:79
msgid "Put the server in read-only mode. After this, any requests that try to change data will fail with error ER_READONLY."
msgstr ""

#: ../book/configuration/cfg_basic.rst:82
msgid "Type: boolean |br| Default: false |br| Dynamic: yes |br|"
msgstr ""

#: ../book/configuration/cfg_basic.rst:90
msgid "A directory where snapshot (.snap) files will be stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to work_dir. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../book/configuration/cfg_basic.rst:94
#: ../book/configuration/cfg_basic.rst:105
#: ../book/configuration/cfg_basic.rst:127
msgid "Type: string |br| Default: \".\" |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg_basic.rst:102
msgid "A directory where vinyl files or sub-directories will be stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to work_dir."
msgstr ""

#: ../book/configuration/cfg_basic.rst:111
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../book/configuration/cfg_basic.rst:121
msgid "A directory where write-ahead log (.xlog) files are stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes wal_dir and :ref:`snap_dir <cfg_basic-snap_dir>` are specified with different values, so that write-ahead log files and snapshot files can be stored on different disks. If not specified, defaults to work_dir."
msgstr ""

#: ../book/configuration/cfg_basic.rst:135
msgid "A directory where database working files will be stored. The server switches to work_dir with :manpage:`chdir(2)` after start. Can be relative to the current directory. If not specified, defaults to the current directory. Other directory parameters may be relative to work_dir, for example |br| :codenormal:`box.cfg{work_dir='/home/user/A',wal_dir='B',snap_dir='C'}` |br| will put xlog files in /home/user/A/B, snapshot files in /home/user/A/C, and all other files or sub-directories in /home/user/A."
msgstr ""

#: ../book/configuration/index.rst:224
msgid "Configuring the storage"
msgstr ""

#: ../book/configuration/cfg_storage.rst:5
msgid "How much memory Tarantool allocates to actually store tuples, in gigabytes. When the limit is reached, INSERT or UPDATE requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the defined limit to allocate tuples, there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the limit set here."
msgstr ""

#: ../book/configuration/cfg_storage.rst:12
msgid "Type: float |br| Default: 1.0 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg_storage.rst:20
msgid "Use slab_alloc_factor as the multiplier for computing the sizes of memory chunks that tuples are stored in. A lower value may result in less wasted memory depending on the total amount of memory available and the distribution of item sizes."
msgstr ""

#: ../book/configuration/cfg_storage.rst:25
msgid "Type: float |br| Default: 1.1 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg_storage.rst:33
msgid "Size of the largest allocation unit. It can be increased if it is necessary to store large tuples."
msgstr ""

#: ../book/configuration/cfg_storage.rst:36
msgid "Type: integer |br| Default: 1048576 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg_storage.rst:44
msgid "Size of the smallest allocation unit. It can be decreased if most of the tuples are very small. The value must be between 8 and 1048280 inclusive."
msgstr ""

#: ../book/configuration/cfg_storage.rst:47
msgid "Type: integer |br| Default: 16 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg_storage.rst:55
msgid "The default vinyl configuration can be changed with"
msgstr ""

#: ../book/configuration/cfg_storage.rst:436
msgid "vinyl = {\n"
"  branch_age_wm = *number*,\n"
"  branch_age_period = *number of seconds*,\n"
"  memory_limit = *number of gigabytes*,\n"
"  compact_wm = *number*,\n"
"  threads = *number*,\n"
"  branch_prio = *number*,\n"
"  branch_age = *number*,\n"
"}"
msgstr ""

#: ../book/configuration/cfg_storage.rst:70
msgid "This method may change in the future."
msgstr ""

#: ../book/configuration/cfg_storage.rst:72
msgid "Default values are:"
msgstr ""

#: ../book/configuration/cfg_storage.rst:453
msgid "vinyl = {\n"
"  branch_age_wm = 0,\n"
"  branch_age_period = 0,\n"
"  memory_limit = 1,\n"
"  compact_wm = 2,\n"
"  threads = 5,\n"
"  branch_prio = 2,\n"
"  branch_age = 0,\n"
"}"
msgstr ""

#: ../book/configuration/index.rst:232
msgid "Snapshot daemon"
msgstr ""

#: ../book/configuration/cfg_snapshot_daemon.rst:4
msgid "The snapshot daemon is a fiber which is constantly running. At intervals, it may make new snapshot (.snap) files and then may remove old snapshot files. If the snapshot daemon removes an old snapshot file, it will also remove any write-ahead log (.xlog) files that are older than the snapshot file and contain information that is present in the snapshot file."
msgstr ""

#: ../book/configuration/cfg_snapshot_daemon.rst:12
msgid "The :ref:`snapshot_period <cfg_snapshot_daemon-snapshot_period>` and :ref:`snapshot_count <cfg_snapshot_daemon-snapshot_count>` configuration settings determine how long the intervals are, and how many snapshots should exist before removals occur."
msgstr ""

#: ../book/configuration/cfg_snapshot_daemon.rst:20
msgid "The interval between actions by the snapshot daemon, in seconds. If ``snapshot_period`` is set to a value greater than zero, and there is activity which causes change to a database, then the snapshot daemon will call :ref:`box.snapshot <admin-snapshot>` every ``snapshot_period`` seconds, creating a new snapshot file each time."
msgstr ""

#: ../book/configuration/cfg_snapshot_daemon.rst:26
msgid "For example: ``box.cfg{snapshot_period=3600}`` will cause the snapshot daemon to create a new database snapshot once per hour."
msgstr ""

#: ../book/configuration/cfg_snapshot_daemon.rst:30
msgid "Type: integer |br| Default: 0 |br| Dynamic: yes |br|"
msgstr ""

#: ../book/configuration/cfg_snapshot_daemon.rst:38
msgid "The maximum number of snapshots that may exist on the snap_dir directory before the snapshot daemon will remove old snapshots. If snapshot_count equals zero, then the snapshot daemon does not remove old snapshots. For example:"
msgstr ""

#: ../book/configuration/cfg_snapshot_daemon.rst:44
msgid "box.cfg{\n"
"    snapshot_period = 3600,\n"
"    snapshot_count  = 10\n"
"}"
msgstr ""

#: ../book/configuration/cfg_snapshot_daemon.rst:51
msgid "will cause the snapshot daemon to create a new snapshot each hour until it has created ten snapshots. After that, it will remove the oldest snapshot (and any associated write-ahead-log files) after creating a new one."
msgstr ""

#: ../book/configuration/cfg_snapshot_daemon.rst:56
msgid "Type: integer |br| Default: 6 |br| Dynamic: yes |br|"
msgstr ""

#: ../book/configuration/index.rst:238
msgid "Binary logging and snapshots"
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:1
msgid ":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-panic_on_snap_error>`, |br| :ref:`panic_on_wal_error <cfg_binary_logging_snapshots-panic_on_wal_error>`, |br| :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`, |br| :ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`, |br| :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`, |br| :ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-wal_dir_rescan_delay>` |br|"
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:12
msgid "If there is an error while reading the snapshot file (at server start), abort."
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:15
#: ../book/configuration/cfg_logging.rst:99
msgid "Type: boolean |br| Default: true |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:23
msgid "If there is an error while reading a write-ahead log file (at server start or to relay to a replica), abort."
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:26
msgid "Type: boolean |br| Default: true |br| Dynamic: yes |br|"
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:34
msgid "How many log records to store in a single write-ahead log file. When this limit is reached, Tarantool creates another WAL file named :samp:`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based backups."
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:39
msgid "Type: integer |br| Default: 500000 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:47
msgid "Reduce the throttling effect of :ref:`box.snapshot <admin-snapshot>` on INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes per second it can write to disk. The same can be achieved by splitting :ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`snap_dir <cfg_basic-snap_dir>` locations and moving snapshots to a separate disk."
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:53
#: ../book/configuration/cfg_networking.rst:13
msgid "Type: float |br| Default: null |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:61
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:63
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:64
msgid "``write``: fibers wait for their data to be written to the write-ahead log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:66
msgid "``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each :manpage:`write(2)`;"
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:69
msgid "Type: string |br| Default: \"write\" |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:77
msgid "Number of seconds between periodic scans of the write-ahead-log file directory, when checking for changes to write-ahead-log files for the sake of replication or local hot standby."
msgstr ""

#: ../book/configuration/cfg_binary_logging_snapshots.rst:81
msgid "Type: float |br| Default: 2 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/index.rst:244
#: ../book/replication/index.rst:30
msgid "Replication"
msgstr ""

#: ../book/configuration/cfg_replication.rst:5
msgid "If replication_source is not an empty string, the server is considered to be a Tarantool :ref:`replica <index-box_replication>`. The replica server will try to connect to the master which replication_source specifies with a :ref:`URI <index-uri>` (Universal Resource Identifier), for example :samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`."
msgstr ""

#: ../book/configuration/cfg_replication.rst:10
msgid "If there is more than one replication source in a cluster, specify an array of URIs, for example |br| :codenormal:`box.cfg{replication_source = {`:codeitalic:`uri#1,uri#2`:codenormal:`}}` |br|"
msgstr ""

#: ../book/configuration/cfg_replication.rst:14
msgid "If one of the URIs is \"self\" -- that is, if one of the URIs is for the same server that :codenormal:`box.cfg{}` is being executed on -- then it is ignored. Thus it is possible to use the same replication_source specification on multiple servers."
msgstr ""

#: ../book/configuration/cfg_replication.rst:19
msgid "The default user name is guest. A replica server does not accept data-change requests on the :ref:`listen <cfg_basic-listen>` port. The replication_source parameter is dynamic, that is, to enter master mode, simply set replication_source to an empty string and issue :code:`box.cfg{replication_source=`:samp:`{new-value}`:code:`}`."
msgstr ""

#: ../book/configuration/cfg_replication.rst:25
msgid "Type: string |br| Default: null |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/index.rst:250
msgid "Networking"
msgstr ""

#: ../book/configuration/cfg_networking.rst:1
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`, |br| :ref:`readahead <cfg_networking-readahead>`  |br|"
msgstr ""

#: ../book/configuration/cfg_networking.rst:8
msgid "The server will sleep for io_collect_interval seconds between iterations of the event loop. Can be used to reduce CPU load in deployments in which the number of client connections is large, but requests are not so frequent (for example, each connection issues just a handful of requests per second)."
msgstr ""

#: ../book/configuration/cfg_networking.rst:21
msgid "The size of the read-ahead buffer associated with a client connection. The larger the buffer, the more memory an active connection consumes and the more requests can be read from the operating system buffer in a single system call. The rule of thumb is to make sure the buffer can contain at least a few dozen requests. Therefore, if a typical tuple in a request is large, e.g. a few kilobytes or even megabytes, the read-ahead buffer size should be increased. If batched request processing is not used, its prudent to leave this setting at its default."
msgstr ""

#: ../book/configuration/cfg_networking.rst:30
msgid "Type: integer |br| Default: 16320 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/index.rst:256
msgid "Logging"
msgstr ""

#: ../book/configuration/cfg_logging.rst:5
msgid "How verbose the logging is. There are six log verbosity classes:"
msgstr ""

#: ../book/configuration/cfg_logging.rst:7
msgid "1  ``SYSERROR``"
msgstr ""

#: ../book/configuration/cfg_logging.rst:8
msgid "2  ``ERROR``"
msgstr ""

#: ../book/configuration/cfg_logging.rst:9
msgid "3  ``CRITICAL``"
msgstr ""

#: ../book/configuration/cfg_logging.rst:10
msgid "4  ``WARNING``"
msgstr ""

#: ../book/configuration/cfg_logging.rst:11
msgid "5  ``INFO``"
msgstr ""

#: ../book/configuration/cfg_logging.rst:12
msgid "6  ``DEBUG``"
msgstr ""

#: ../book/configuration/cfg_logging.rst:14
msgid "By setting log_level, one can enable logging of all classes below or equal to the given level. Tarantool prints its logs to the standard error stream by default, but this can be changed with the :ref:`logger <cfg_logging-logger>` configuration parameter."
msgstr ""

#: ../book/configuration/cfg_logging.rst:19
msgid "Type: integer |br| Default: 5 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/cfg_logging.rst:27
msgid "By default, the log is sent to the standard error stream (``stderr``). If ``logger`` is specified, the log is sent to a file, or to a pipe, or to the system logger."
msgstr ""

#: ../book/configuration/cfg_logging.rst:31
#: ../book/configuration/cfg_logging.rst:43
#: ../book/configuration/cfg_logging.rst:56
msgid "Example setting:"
msgstr ""

#: ../book/configuration/cfg_logging.rst:33
msgid "box.cfg{logger = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{logger = 'file: tarantool.log'}"
msgstr ""

#: ../book/configuration/cfg_logging.rst:39
msgid "This will open the file ``tarantool.log`` for output on the servers default directory. If the ``logger`` string has no prefix or has the prefix \"file:\", then the string is interpreted as a file path."
msgstr ""

#: ../book/configuration/cfg_logging.rst:45
msgid "box.cfg{logger = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{logger = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../book/configuration/cfg_logging.rst:51
msgid "This will start the program ``cronolog`` when the server starts, and will send all log messages to the standard input (``stdin``) of cronolog. If the ``logger`` string begins with '|' or has the prefix \"pipe:\", then the string is interpreted as a Unix `pipeline`_."
msgstr ""

#: ../book/configuration/cfg_logging.rst:58
msgid "box.cfg{logger = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{logger = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{logger = 'syslog:identity=tarantool,facility=user'}"
msgstr ""

#: ../book/configuration/cfg_logging.rst:66
msgid "If the ``logger`` string has the prefix \"syslog:\", then the string is interpreted as a message for the `syslogd`_ program which normally is running in the background of any Unix-like platform. One can optionally specify an ``identity``, a ``facility``, or both. The ``identity`` is an arbitrary string, default value = ``tarantool``, which will be placed at the beginning of all messages. The facility is an abbreviation for the name of one of the `syslog`_ facilities, default value = ``user``, which tell syslogd where the message should go."
msgstr ""

#: ../book/configuration/cfg_logging.rst:75
msgid "Possible values for ``facility`` are: auth, authpriv, cron, daemon, ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0, local1, local2, local3, local4, local5, local6, local7."
msgstr ""

#: ../book/configuration/cfg_logging.rst:79
msgid "The ``facility`` setting is currently ignored but will be used in the future."
msgstr ""

#: ../book/configuration/cfg_logging.rst:81
msgid "When logging to a file, tarantool reopens the log on SIGHUP. When log is a program, its pid is saved in the :ref:`log.logger_pid <log-logger_pid>` variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../book/configuration/cfg_logging.rst:93
msgid "If ``logger_nonblock`` equals true, Tarantool does not block on the log file descriptor when its not ready for write, and drops the message instead. If :ref:`log_level <cfg_logging-log_level>` is high, and a lot of messages go to the log file, setting ``logger_nonblock`` to true may improve logging performance at the cost of some log messages getting lost."
msgstr ""

#: ../book/configuration/cfg_logging.rst:107
msgid "If processing a request takes longer than the given value (in seconds), warn about it in the log. Has effect only if :ref:`log_level <cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../book/configuration/cfg_logging.rst:111
msgid "Type: float |br| Default: 0.5 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/cfg_logging.rst:117
msgid "**Logging Example:**"
msgstr ""

#: ../book/configuration/cfg_logging.rst:119
msgid "This will illustrate how \"rotation\" works, that is, what happens when the server is writing to a log and signals are used when archiving it."
msgstr ""

#: ../book/configuration/cfg_logging.rst:122
msgid "Start with two terminal shells, Terminal #1 and Terminal#2."
msgstr ""

#: ../book/configuration/cfg_logging.rst:124
msgid "On Terminal#1: start an interactive Tarantool session, then say the logging will go to \"Log_file\", then put a message \"Log Line #1\" in the log file:"
msgstr ""

#: ../book/configuration/cfg_logging.rst:127
msgid "box.cfg{logger='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../book/configuration/cfg_logging.rst:133
msgid "On Terminal#2: use :codenormal:`mv` so the log file is now named \"Log_file.bak\". The result of this is: the next log message will go to Log_file.bak. |br|"
msgstr ""

#: ../book/configuration/cfg_logging.rst:846
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../book/configuration/cfg_logging.rst:141
msgid "On Terminal#1: put a message \"Log Line #2\" in the log file. |br|"
msgstr ""

#: ../book/configuration/cfg_logging.rst:143
msgid "log.info('Log Line #2')"
msgstr ""

#: ../book/configuration/cfg_logging.rst:147
msgid "On Terminal#2: use :codenormal:`ps` to find the process ID of the Tarantool server. |br|"
msgstr ""

#: ../book/configuration/cfg_logging.rst:859
msgid "ps -A | grep tarantool"
msgstr ""

#: ../book/configuration/cfg_logging.rst:154
msgid "On Terminal#2: use 'kill -HUP' to send a SIGHUP signal to the Tarantool server. The result of this is: Tarantool will open Log_file again, and the next log message will go to Log_file. (The same effect could be accomplished by executing log.rotate() on the server.) |br|"
msgstr ""

#: ../book/configuration/cfg_logging.rst:869
msgid "kill -HUP *process_id*"
msgstr ""

#: ../book/configuration/cfg_logging.rst:164
msgid "On Terminal#1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../book/configuration/cfg_logging.rst:166
msgid "log.info('Log Line #3')"
msgstr ""

#: ../book/configuration/cfg_logging.rst:170
msgid "On Terminal#2: use 'less' to examine files. Log_file.bak will have these lines, except that the date and time will depend on when the example is done:"
msgstr ""

#: ../book/configuration/cfg_logging.rst:883
msgid "2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../book/configuration/cfg_logging.rst:179
msgid "and Log_file will have"
msgstr ""

#: ../book/configuration/cfg_logging.rst:891
msgid "log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../book/configuration/index.rst:264
msgid "Local hot standby"
msgstr ""

#: ../book/configuration/index.rst:266
msgid "Local hot standby is a feature which provides a simple form of failover without replication. To initiate it, start a second instance of the Tarantool server on the same computer with the same :ref:`box.cfg <box_introspection-box_cfg>` configuration settings - including the same directories and same non-null URIs. A warning should appear with a message like"
msgstr ""

#: ../book/configuration/index.rst:272
msgid "W> primary: [URI] is already in use, will retry binding after [n] seconds"
msgstr ""

#: ../book/configuration/index.rst:276
msgid "This is fine. It means that the second instance is ready to take over if the first instance goes down."
msgstr ""

#: ../book/configuration/index.rst:279
msgid "The expectation is that there will be two instances of the server using the same configuration. The first one to start will be the \"primary\" instance. The second one to start will be the \"standby\" instance. The standby instance will initialize and will try to connect on listen address, but will fail because the primary instance has already taken it. So the standby instance goes into a loop, reading the write ahead log which the primary instance is writing (so the two instances are always in synch), and trying to connect on the port. If the primary instance goes down for any reason, the port will become free so the standby instance will succeed in connecting, and will become the primary instance. Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""

#: ../book/configuration/index.rst:291
msgid "If this local_hot_standby feature is being used, then wal_mode should not be equal to \"none\"."
msgstr ""

#: ../book/connectors/index.rst:30
msgid "Connectors"
msgstr ""

#: ../book/connectors/index.rst:32
msgid "This chapter documents APIs for various programming languages."
msgstr ""

#: ../book/connectors/index.rst:36
msgid "Protocol"
msgstr ""

#: ../book/connectors/index.rst:38
msgid "Tarantool protocol was designed with a focus on asynchronous I/O and easy integration with proxies. Each client request starts with a variable-length binary header, containing request id, request type, server id, log sequence number, and so on."
msgstr ""

#: ../book/connectors/index.rst:42
msgid "The mandatory length, present in request header simplifies client or proxy I/O. A response to a request is sent to the client as soon as it is ready. It always carries in its header the same type and id as in the request. The id makes it possible to match a request to a response, even if the latter arrived out of order."
msgstr ""

#: ../book/connectors/index.rst:47
msgid "Unless implementing a client driver, one needn't concern oneself with the complications of the binary protocol. Language-specific drivers provide a friendly way to store domain language data structures in Tarantool. A complete description of the binary protocol is maintained in annotated Backus-Naur form in the source tree: please see :ref:`iproto protocol <box_protocol-iproto_protocol>`."
msgstr ""

#: ../book/connectors/index.rst:55
msgid "Packet example"
msgstr ""

#: ../book/connectors/index.rst:57
msgid "The Tarantool API exists so that a client program can send a request packet to the server, and receive a response. Here is an example of a what the client would send for :code:`box.space[513]:insert{'A', 'BB'}`. The BNF description of the components is in file :ref:`iproto protocol <box_protocol-iproto_protocol>`."
msgstr ""

#: ../book/connectors/index.rst:72
msgid "Component"
msgstr ""

#: ../book/connectors/index.rst:72
msgid "Byte #0"
msgstr ""

#: ../book/connectors/index.rst:72
msgid "Byte #1"
msgstr ""

#: ../book/connectors/index.rst:72
msgid "Byte #2"
msgstr ""

#: ../book/connectors/index.rst:72
msgid "Byte #3"
msgstr ""

#: ../book/connectors/index.rst:74
msgid "code for insert"
msgstr ""

#: ../book/connectors/index.rst:74
#: ../book/connectors/index.rst:78
msgid "02"
msgstr ""

#: ../book/connectors/index.rst:76
msgid "rest of header"
msgstr ""

#: ../book/connectors/index.rst:76
#: ../book/connectors/index.rst:76
#: ../book/connectors/index.rst:76
#: ../book/connectors/index.rst:76
msgid "..."
msgstr ""

#: ../book/connectors/index.rst:78
msgid "2-digit number: space id"
msgstr ""

#: ../book/connectors/index.rst:78
msgid "cd"
msgstr ""

#: ../book/connectors/index.rst:78
msgid "01"
msgstr ""

#: ../book/connectors/index.rst:80
msgid "code for tuple"
msgstr ""

#: ../book/connectors/index.rst:80
msgid "21"
msgstr ""

#: ../book/connectors/index.rst:82
msgid "1-digit number: field count = 2"
msgstr ""

#: ../book/connectors/index.rst:82
msgid "92"
msgstr ""

#: ../book/connectors/index.rst:84
msgid "1-character string: field[1]"
msgstr ""

#: ../book/connectors/index.rst:84
msgid "a1"
msgstr ""

#: ../book/connectors/index.rst:84
msgid "41"
msgstr ""

#: ../book/connectors/index.rst:86
msgid "2-character string: field[2]"
msgstr ""

#: ../book/connectors/index.rst:86
msgid "a2"
msgstr ""

#: ../book/connectors/index.rst:86
#: ../book/connectors/index.rst:86
msgid "42"
msgstr ""

#: ../book/connectors/index.rst:89
msgid "Now, one could send that packet to the tarantool server, and interpret the response (:ref:`iproto protocol <box_protocol-iproto_protocol>` has a description of the packet format for responses as well as requests). But it would be easier, and less error-prone, if one could invoke a routine that formats the packet according to typed parameters. Something like :code:`response=tarantool_routine(\"insert\",513,\"A\",\"B\");`. And that is why APIs exist for drivers for Perl, Python, PHP, and so on."
msgstr ""

#: ../book/connectors/index.rst:100
msgid "Setting up the server for connector examples"
msgstr ""

#: ../book/connectors/index.rst:102
msgid "This chapter has examples that show how to connect to the Tarantool server via the Perl, PHP, Python, and C connectors. The examples contain hard code that will work if and only if the server (tarantool) is running on localhost (127.0.0.1) and is listening on port 3301 (:code:`box.cfg.listen = '3301'`) and space 'examples' has id = 999 (:code:`box.space.examples.id = 999`), and space 'examples' has a primary-key index for a numeric field (:code:`box.space[999].index[0].parts[1].type = \"NUM\"`) and user 'guest' has privileges for reading and writing."
msgstr ""

#: ../book/connectors/index.rst:110
msgid "It is easy to meet all the conditions by starting the server and executing this script:"
msgstr ""

#: ../book/connectors/index.rst:113
msgid "box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""

#: ../book/connectors/__java.rst:3
msgid "Java"
msgstr ""

#: ../book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr ""

#: ../book/connectors/__go.rst:3
msgid "Go"
msgstr ""

#: ../book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool-1.6."
msgstr ""

#: ../book/connectors/__r.rst:3
msgid "R"
msgstr ""

#: ../book/connectors/__r.rst:5
msgid "See https://github.com/thekvs/tarantoolr."
msgstr ""

#: ../book/connectors/__perl.rst:3
msgid "Perl"
msgstr ""

#: ../book/connectors/__perl.rst:5
msgid "The most commonly used Perl driver is `DR::Tarantool`_. It is not supplied as part of the Tarantool repository; it must be installed separately. The most common way to install it is with `CPAN, the Comprehensive Perl Archive Network`_. `DR::Tarantool`_ requires other modules which should be installed first. For example, on Ubuntu, the installation could look like this:"
msgstr ""

#: ../book/connectors/__perl.rst:11
msgid "$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"
msgstr ""

#: ../book/connectors/__perl.rst:22
msgid "Here is a complete Perl program that inserts [99999,'BB'] into space[999] via the Perl API. Before trying to run, check that the server is listening and that :code:`examples` exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the code into a file named example.pl and say :code:`perl example.pl`. The program will connect using an application-specific definition of the space. The program will open a socket connection with the tarantool server at localhost:3301, then send an INSERT request, then  if all is well  end without displaying any messages. If tarantool is not running on localhost with listen address = 3301, the program will print Connection refused."
msgstr ""

#: ../book/connectors/__perl.rst:32
msgid "#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. one could also say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999] ...\n"
"      name => 'examples',                      #   space[999] name = 'examples'\n"
"      default_type => 'STR',                   #   space[999] field type is 'STR' if undefined\n"
"      fields => [ {                            #   definition of space[999].fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] name='field1',type='NUM'\n"
"      indexes => {                             #   definition of space[999] indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""

#: ../book/connectors/__perl.rst:56
msgid "The example program only shows one command and does not show all that's necessary for good practice. For that, please see `DR::Tarantool`_ CPAN repository."
msgstr ""

#: ../book/connectors/__php.rst:3
msgid "PHP"
msgstr ""

#: ../book/connectors/__php.rst:5
msgid "The PHP driver is `tarantool-php`_. It is not supplied as part of the Tarantool repository; it must be installed separately. It can be installed with git. It requires other modules which should be installed first. For example, on Ubuntu, the installation could look like this:"
msgstr ""

#: ../book/connectors/__php.rst:10
msgid "$ sudo apt-get install php5-cli\n"
"$ sudo apt-get install php5-dev\n"
"$ sudo apt-get install php-pear\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/tarantool-php.git\n"
"$ cd tarantool-php\n"
"$ phpize\n"
"$ ./configure\n"
"$ make\n"
"$ # make install is optional"
msgstr ""

#: ../book/connectors/__php.rst:24
msgid "At this point there is a file named :code:`~/tarantool-php/modules/tarantool.so`. PHP will only find it if the PHP initialization file :code:`php.ini` contains a line like :code:`extension=./tarantool.so`, or if PHP is started with the option :code:`-d extension=~/tarantool-php/modules/tarantool.so`."
msgstr ""

#: ../book/connectors/__php.rst:29
msgid "Here is a complete PHP program that inserts [99999,'BB'] into a space named 'examples' via the PHP API. Before trying to run, check that the server is listening and that :code:`examples` exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the code into a file named example.php and say :code:`php -d extension=~/tarantool-php/modules/tarantool.so example.php`. The program will open a socket connection with the tarantool server at localhost:3301, then send an INSERT request, then  if all is well  print \"Insert succeeded\". If the tuple already exists, the program will print Duplicate key exists in unique index 'primary' in space 'examples'."
msgstr ""

#: ../book/connectors/__php.rst:37
msgid "<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', [99999, 'BB']);\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""

#: ../book/connectors/__php.rst:49
msgid "The example program only shows one command and does not show all that's necessary for good practice. For that, please see `tarantool-php`_ project at GitHub."
msgstr ""

#: ../book/connectors/__python.rst:3
msgid "Python"
msgstr ""

#: ../book/connectors/__python.rst:5
msgid "Here is a complete Python program that inserts :code:`[99999,'Value','Value']` into space :code:`examples` via the high-level Python API."
msgstr ""

#: ../book/connectors/__python.rst:8
msgid "#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""

#: ../book/connectors/__python.rst:17
msgid "To prepare, paste the code into a file named example.py and install tarantool-python with either :code:`pip install tarantool\\>0.4` to install in :code:`/usr` (requires **root** privilege) or :code:`pip install tarantool\\>0.4 --user` to install in :code:`~` i.e. user's default directory. Before trying to run, check that the server is listening and that examples exists, as :ref:`described earlier <index-connector_setting>`. To run the program, say :code:`python example.py`. The program will connect to the server, will send the request, and will not throw an exception if all went well. If the tuple already exists, the program will throw :code:`tarantool.error.DatabaseError: (3, \"Duplicate key exists in unique index 'primary' in space 'examples'\")`."
msgstr ""

#: ../book/connectors/__python.rst:27
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, see http://github.com/tarantool/tarantool-python. For an example of a Python API for `Queue managers on Tarantool`_, see https://github.com/tarantool/tarantool-queue-python."
msgstr ""

#: ../book/connectors/__c.rst:3
msgid "C"
msgstr ""

#: ../book/connectors/__c.rst:5
msgid ":c:func:`tarantoolc:tnt_connect`"
msgstr ""

#: ../book/connectors/__c.rst:7
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr ""

#: ../book/connectors/__c.rst:11
msgid "Example 1"
msgstr ""

#: ../book/connectors/__c.rst:13
msgid "Here is a complete C program that inserts :code:`[99999,'B']` into space :code:`examples` via the high-level C API."
msgstr ""

#: ../book/connectors/__c.rst:16
msgid "#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE REQUEST */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND REQUEST */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../book/connectors/__c.rst:46
msgid "Paste the code into a file named :file:`example.c` and install ``tarantool-c``. One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr ""

#: ../book/connectors/__c.rst:49
msgid "$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../book/connectors/__c.rst:59
#: ../book/connectors/__c.rst:288
msgid "To compile and link the program, say:"
msgstr ""

#: ../book/connectors/__c.rst:61
msgid "$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""

#: ../book/connectors/__c.rst:67
msgid "Before trying to run, check that the server is listening and that the space :code:`examples` exists, as :ref:`described earlier <index-connector_setting>`. To run the program, say :code:`./example`. The program will connect to the server, and will send the request. If Tarantool is not running on localhost with listen address = 3301, the program will print Connection refused. If the insert fails, the program will print \"Insert failed\" and an error number (see all error codes in the file `/src/box/errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_)."
msgstr ""

#: ../book/connectors/__c.rst:78
msgid "Here are notes corresponding to comments in the example program."
msgstr ""

#: ../book/connectors/__c.rst:80
msgid "**SETUP:** The setup begins by creating a stream."
msgstr ""

#: ../book/connectors/__c.rst:82
msgid "struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""

#: ../book/connectors/__c.rst:87
msgid "In this program, the stream will be named :code:`tnt`. Before connecting on the :code:`tnt` stream, some options may have to be set. The most important option is TNT_OPT_URI. In this program, the URI is ``localhost:3301``, since that is where the Tarantool server is supposed to be listening."
msgstr ""

#: ../book/connectors/__c.rst:93
#: ../book/connectors/__c.rst:109
#: ../book/connectors/__c.rst:137
#: ../book/connectors/__c.rst:157
#: ../book/connectors/__c.rst:182
#: ../book/connectors/__c.rst:201
msgid "Function description:"
msgstr ""

#: ../book/connectors/__c.rst:406
msgid "`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"
msgstr ""

#: ../book/connectors/__c.rst:101
msgid "**CONNECT:** Now that the stream named ``tnt`` exists and is associated with a URI, this example program can connect to the server."
msgstr ""

#: ../book/connectors/__c.rst:104
msgid "if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""

#: ../book/connectors/__c.rst:422
msgid "int tnt_connect(struct tnt_stream \\*s)"
msgstr ""

#: ../book/connectors/__c.rst:116
msgid "The connection might fail for a variety of reasons, such as: the server is not running, or the URI contains an invalid password. If the connect fails, the return value will be -1."
msgstr ""

#: ../book/connectors/__c.rst:120
msgid "**MAKE REQUEST:** Most requests require passing a structured value, such as the contents of a tuple."
msgstr ""

#: ../book/connectors/__c.rst:123
msgid "struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""

#: ../book/connectors/__c.rst:128
msgid "In this program, the request will be an INSERT, and the tuple contents will be an integer and a string. This is a simple serial set of values, that is, there are no sub-structures or arrays. Therefore it is easy in this case to format what will be passed using the same sort of arguments that one would use with a C ``printf()`` function: ``%d`` for the integer, ``%s`` for the string, then the integer value, then a pointer to the string value."
msgstr ""

#: ../book/connectors/__c.rst:450
msgid "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"
msgstr ""

#: ../book/connectors/__c.rst:144
msgid "**SEND REQUEST:** The database-manipulation requests are analogous to the requests in the box library."
msgstr ""

#: ../book/connectors/__c.rst:147
msgid "tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""

#: ../book/connectors/__c.rst:152
msgid "In this program, the choice is to do an INSERT request, so the program passes the ``tnt_stream`` that was used for connection (:code:`tnt`) and the stream that was set up with :c:func:`tarantoolc:tnt_object_format` (:code:`tuple`)."
msgstr ""

#: ../book/connectors/__c.rst:470
msgid "ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"
msgstr ""

#: ../book/connectors/__c.rst:170
msgid "**GET REPLY:** For most requests, the client will receive a reply containing some indication whether the result was successful, and a set of tuples."
msgstr ""

#: ../book/connectors/__c.rst:173
msgid "struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""

#: ../book/connectors/__c.rst:180
msgid "This program checks for success but does not decode the rest of the reply."
msgstr ""

#: ../book/connectors/__c.rst:495
msgid "struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"
msgstr ""

#: ../book/connectors/__c.rst:191
msgid "**TEARDOWN:** When a session ends, the connection that was made with :c:func:`tarantoolc:tnt_connect()` should be closed, and the objects that were made in the setup should be destroyed."
msgstr ""

#: ../book/connectors/__c.rst:195
msgid "tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""

#: ../book/connectors/__c.rst:514
msgid "void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"
msgstr ""

#: ../book/connectors/__c.rst:211
msgid "Example 2"
msgstr ""

#: ../book/connectors/__c.rst:213
msgid "Here is a complete C program that selects, using index key :code:`[99999]`, from space :code:`examples` via the high-level C API. To display the results, the program uses functions in the `MsgPuck`_ library which allow decoding of `MessagePack`_  arrays."
msgstr ""

#: ../book/connectors/__c.rst:218
msgid "#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../book/connectors/__c.rst:285
msgid "Similarly to the first example, paste the code into a file named :file:`example2.c`."
msgstr ""

#: ../book/connectors/__c.rst:290
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr ""

#: ../book/connectors/__c.rst:294
msgid "To run the program, say :code:`./example2`."
msgstr ""

#: ../book/connectors/__c.rst:296
msgid "The two example programs only show a few requests and do not show all that's necessary for good practice. See more in the ``tarantool-c`` documentation at http://github.com/tarantool/tarantool-c."
msgstr ""

#: ../book/connectors/__results.rst:4
msgid "Interpreting function return values"
msgstr ""

#: ../book/connectors/__results.rst:7
msgid "For all Connectors, calling a function via Tarantool causes a return in MsgPack format. If the function is called using the connector's API, some conversions may occur. All scalar values are returned as tuples (with a MsgPack type-identifier followed by a value); all non-scalar values are returned as a group of tuples (with a MsgPack array-identifier followed by the scalar values). If the function is called via the binary protocol command layer -- \"eval\" -- rather than via the connector's API, no conversions occur."
msgstr ""

#: ../book/connectors/__results.rst:15
msgid "In the following example, a Lua function will be created. Since it will be accessed externally by a 'guest' user, a ``grant`` of an execute privilege will be necessary. The function returns an empty array, a scalar string, two booleans, and a short integer. The values are the ones described in the msgpack section in the table :ref:`Common Types and MsgPack Encodings <msgpack-common_types_and_msgpack_encodings>`."
msgstr ""

#: ../book/connectors/__results.rst:21
msgid "tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""

#: ../book/connectors/__results.rst:37
msgid "Here is a C program which calls the function. Although C is being used for the example, the result would be precisely the same if the calling program was written in Perl, PHP, Python, Go, or Java."
msgstr ""

#: ../book/connectors/__results.rst:41
msgid "#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);            /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                        /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);       /* MAKE REQUEST */\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL); /* CALL function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   tnt_request_set_tuple(req1, arg);\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                    /* SEND REQUEST */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);   /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data;/* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                    /* TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../book/connectors/__results.rst:81
msgid "When this program is executed, it will print: |br| :codenormal:`dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f` |br| The first five bytes -- :codenormal:`dd 0 0 0 5` -- are the msgpack encoding for \"32-bit array header with value 5\" (see the msgpack Specification_ page). The rest are as described in the Common Types and MsgPack Encodings table."
msgstr ""

#: ../book/index.rst:30
msgid "User Guide"
msgstr ""

#: ../book/intro.rst:28
msgid "Preface"
msgstr ""

#: ../book/intro.rst:30
msgid "Welcome to Tarantool. This is the User Guide. We recommend reading this first, and afterwards reading the Reference Manual which has more detail."
msgstr ""

#: ../book/intro.rst:36
msgid "How to read the documentation"
msgstr ""

#: ../book/intro.rst:38
msgid "To get started, one can either download the whole package as described in the first part of Chapter 2 \"Getting started\", or one can initially skip the download and connect to the online Tarantool server running on the web at http://try.tarantool.org. Either way, the first tryout can be a matter of following the example in the second part of chapter 2: \"Starting Tarantool and making your first database\"."
msgstr ""

#: ../book/intro.rst:45
msgid "Chapter 3 \"Database\" is about the Tarantool NoSQL DBMS. If the only intent is to use Tarantool as a Lua application server, most of the material in this chapter and in the following chapter (Chapter 4 \"Replication\") will not be necessary. Once again, the detailed instructions about each package can be regarded as reference material."
msgstr ""

#: ../book/intro.rst:51
msgid "Chapter 6 \"Server administration\" and Chapter 5 \"Configuration reference\" are primarily for administrators; however, every user should know something about how the server is configured so the section about box.cfg is not skippable. Chapter 7 \"Connectors\" is strictly for users who are connecting from a different language such as C or Perl or Python -- other users will find no immediate need for this chapter."
msgstr ""

#: ../book/intro.rst:57
msgid "The two long tutorials in Appendix C -- \"Insert one million tuples with a Lua stored procedure\" and \"Sum a JSON field for all tuples\" -- start slowly and contain commentary that is especially aimed at users who may not consider themselves experts at either Lua or NoSQL database management."
msgstr ""

#: ../book/intro.rst:61
msgid "Finally, Appendix D \"Modules\" has examples that will be essential for those users who want to connect the Tarantool server to another DBMS: MySQL or PostgreSQL."
msgstr ""

#: ../book/intro.rst:64
msgid "For experienced users, there is also a reference manual plus developer's guide, and an extensive set of comments in the source code."
msgstr ""

#: ../book/intro.rst:69
msgid "Getting In Touch With The Tarantool Community"
msgstr ""

#: ../book/intro.rst:71
msgid "Please report bugs or make feature requests at `http://github.com/tarantool/tarantool/issues`_."
msgstr ""

#: ../book/intro.rst:73
msgid "You can contact developers directly on the `#tarantool` IRC channel on freenode.net, or via a mailing list, `Tarantool Google group`_."
msgstr ""

#: ../book/intro.rst:76
msgid "There is also a `Forum for Russian speakers`_."
msgstr ""

#: ../book/replication/index.rst:32
msgid "Replication allows multiple Tarantool servers to work on copies of the same databases. The databases are kept in synch because each server can communicate its changes to all the other servers. Servers which share the same databases are a \"cluster\". Each server in a cluster also has a numeric identifier which is unique within the cluster, known as the \"server id\"."
msgstr ""

#: ../book/replication/index.rst:38
msgid "To set up replication, it's necessary to set up the master servers which make the original data-change requests, set up the replica servers which copy data-change requests from masters, and establish procedures for recovery from a degraded state."
msgstr ""

#: ../book/replication/index.rst:45
msgid "Replication architecture"
msgstr ""

#: ../book/replication/index.rst:47
msgid "A replica gets all updates from the master by continuously fetching and applying its write-ahead log (WAL). Each record in the WAL represents a single Tarantool data-change request such as INSERT or UPDATE or DELETE, and is assigned a monotonically growing log sequence number (LSN). In essence, Tarantool replication is row-based: each data change command is fully deterministic and operates on a single tuple."
msgstr ""

#: ../book/replication/index.rst:54
msgid "A stored program invocation is not written to the write-ahead log. Instead, log events for actual data-change requests, performed by the Lua code, are written to the log. This ensures that possible non-determinism of Lua does not cause replication to go out of sync."
msgstr ""

#: ../book/replication/index.rst:61
msgid "Setting up the master"
msgstr ""

#: ../book/replication/index.rst:63
msgid "To prepare the master for connections from the replica, it's only necessary to include \":ref:`listen <cfg_basic-listen>`\" in the initial ``box.cfg`` request, for example ``box.cfg{listen=3301}``. A master with enabled \"listen\" URI can accept connections from as many replicas as necessary on that URI. Each replica has its own replication state."
msgstr ""

#: ../book/replication/index.rst:71
msgid "Setting up a replica"
msgstr ""

#: ../book/replication/index.rst:73
msgid "A server requires a valid snapshot (.snap) file. A snapshot file is created for a server the first time that ``box.cfg`` occurs for it. If this first ``box.cfg`` request occurs without a \"replication source\" clause, then the server is a master and starts its own new cluster with a new unique UUID. If this first ``box.cfg`` request occurs with a \"replication source\" clause, then the server is a replica and its snapshot file, along with the cluster information, is constructed from the write-ahead logs of the master. Therefore, to start replication, specify :ref:`replication_source <cfg_replication-replication_source>` in a ``box.cfg`` request. When a replica contacts a master for the first time, it becomes part of a cluster. On subsequent occasions, it should always contact a master in the same cluster."
msgstr ""

#: ../book/replication/index.rst:85
msgid "Once connected to the master, the replica requests all changes that happened after the latest local LSN. It is therefore necessary to keep WAL files on the master host as long as there are replicas that haven't applied them yet. A replica can be \"re-seeded\" by deleting all its files (the snapshot .snap file and the WAL .xlog files), then starting replication again - the replica will then catch up with the master by retrieving all the master's tuples. Again, this procedure works only if the master's WAL files are present."
msgstr ""

#: ../book/replication/index.rst:93
msgid "NOTE: Replication parameters are \"dynamic\", which allows the replica to become a master and vice versa with the help of the :ref:`box.cfg <box_introspection-box_cfg>` statement."
msgstr ""

#: ../book/replication/index.rst:97
msgid "NOTE: The replica does not inherit the master's configuration parameters, such as the ones that cause the :ref:`snapshot daemon <book_cfg_snapshot_daemon>` to run on the master. To get the same behavior, one would have to set the relevant parameters explicitly so that they are the same on both master and replica."
msgstr ""

#: ../book/replication/index.rst:103
msgid "NOTE: Replication requires privileges. Privileges for accessing spaces could be granted directly to the user who will start the replica. However, it is more usual to grant privileges for accessing spaces to a :ref:`role <authentication-rep_role>`, and then grant the role to the user who will start the replica."
msgstr ""

#: ../book/replication/index.rst:111
msgid "Recovering from a degraded state"
msgstr ""

#: ../book/replication/index.rst:113
msgid "\"Degraded state\" is a situation when the master becomes unavailable - due to hardware or network failure, or due to a programming bug. There is no automatic way for a replica to detect that the master is gone forever, since sources of failure and replication environments vary significantly. So the detection of degraded state requires a human inspection."
msgstr ""

#: ../book/replication/index.rst:119
msgid "However, once a master failure is detected, the recovery is simple: declare that the replica is now the new master, by saying :codenormal:`box.cfg{... listen=`:codeitalic:`URI <index-uri>`:codenormal:`}`. Then, if there are updates on the old master that were not propagated before the old master went down, they would have to be re-applied manually."
msgstr ""

#: ../book/replication/index.rst:127
msgid "Instructions for quick startup of a new two-server simple cluster"
msgstr ""

#: ../book/replication/index.rst:129
msgid "Step 1. Start the first server thus:"
msgstr ""

#: ../book/replication/index.rst:134
msgid "box.cfg{listen = *uri#1*}\n"
"-- replace with more restrictive request\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"box.snapshot()"
msgstr ""

#: ../book/replication/index.rst:139
msgid "... Now a new cluster exists."
msgstr ""

#: ../book/replication/index.rst:141
msgid "Step 2. Check where the second server's files will go by looking at its directories (:ref:`snap_dir <cfg_basic-snap_dir>` for snapshot files, :ref:`wal_dir <cfg_basic-wal_dir>` for .xlog files). They must be empty - when the second server joins for the first time, it has to be working with a clean slate so that the initial copy of the first server's databases can happen without conflicts."
msgstr ""

#: ../book/replication/index.rst:147
msgid "Step 3. Start the second server thus:"
msgstr ""

#: ../book/replication/index.rst:152
msgid "box.cfg{\n"
"  listen = *uri#2*,\n"
"  replication_source = *uri#1*\n"
"}"
msgstr ""

#: ../book/replication/index.rst:157
msgid "... where ``uri#1`` = the :ref:`URI <index-uri>` that the first server is listening on."
msgstr ""

#: ../book/replication/index.rst:159
msgid "That's all."
msgstr ""

#: ../book/replication/index.rst:161
msgid "In this configuration, the first server is the \"master\" and the second server is the \"replica\". Henceforth every change that happens on the master will be visible on the replica. A simple two-server cluster with the master on one computer and the replica on a different computer is very common and provides two benefits: FAILOVER (because if the master goes down then the replica can take over), or LOAD BALANCING (because clients can connect to either the master or the replica for select requests). Sometimes the replica may be configured with the additional parameter :ref:`read_only = true <cfg_basic-read_only>`."
msgstr ""

#: ../book/replication/index.rst:172
msgid "Monitoring a Replica's Actions"
msgstr ""

#: ../book/replication/index.rst:174
msgid "In :ref:`box.info <box_introspection-box_info>` there is a :code:`box.info.replication.status` field: \"off\", \"stopped\", \"connecting\", \"auth\", \"follow\", or \"disconnected\". |br| If a replica's status is \"follow\", then there will be two more fields: |br| :code:`box.info.replication.idle` = the number of seconds the replica has been idle, |br| :code:`box.info.replication.lag` = the number of seconds the replica is behind the master."
msgstr ""

#: ../book/replication/index.rst:180
msgid "In the :ref:`log <log>` there is a record of replication activity. If a primary server is started with:"
msgstr ""

#: ../book/replication/index.rst:186
msgid "box.cfg{\n"
"  <...>,\n"
"  logger = *log file name*,\n"
"  <...>\n"
"}"
msgstr ""

#: ../book/replication/index.rst:192
msgid "then there will be lines in the log file, containing the word \"relay\", when a replica connects or disconnects."
msgstr ""

#: ../book/replication/index.rst:199
msgid "Preventing Duplicate Actions"
msgstr ""

#: ../book/replication/index.rst:201
msgid "Suppose that the replica tries to do something that the master has already done. For example: |br| :code:`box.schema.space.create('X')` |br| This would cause an error, \"Space X exists\". For this particular situation, the code could be changed to: |br| :code:`box.schema.space.create('X', {if_not_exists=true})` |br| But there is a more general solution: the :samp:`box.once({key}, {function})` method. If :code:`box.once()` has been called before with the same :samp:`{key}` value, then :samp:`{function}` is ignored; otherwise :samp:`{function}` is executed. Therefore, actions which should only occur once during the life of a replicated session should be placed in a function which is executed via :code:`box.once()`. For example:"
msgstr ""

#: ../book/replication/index.rst:216
msgid "function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"
msgstr ""

#: ../book/replication/index.rst:225
msgid "Master-Master Replication"
msgstr ""

#: ../book/replication/index.rst:227
msgid "In the simple master-replica configuration, the master's changes are seen by the replica, but not vice versa, because the master was specified as the sole replication source. In the master-master configuration, also sometimes called multi-master configuration, it's possible to go both ways. Starting with the simple configuration, the first server has to say:"
msgstr ""

#: ../book/replication/index.rst:237
msgid "box.cfg{ replication_source = *uri#2* }"
msgstr ""

#: ../book/replication/index.rst:239
msgid "This request can be performed at any time -- :ref:`replication_source <cfg_replication-replication_source>` is a dynamic parameter."
msgstr ""

#: ../book/replication/index.rst:242
msgid "In this configuration, both servers are \"masters\" and both servers are \"replicas\". Henceforth every change that happens on either server will be visible on the other. The failover benefit is still present, and the load-balancing benefit is enhanced (because clients can connect to either server for data-change requests as well as select requests)."
msgstr ""

#: ../book/replication/index.rst:248
msgid "If two operations for the same tuple take place \"concurrently\" (which can involve a long interval because replication is asynchronous), and one of the operations is ``delete`` or ``replace``, there is a possibility that servers will end up with different contents."
msgstr ""

#: ../book/replication/index.rst:256
msgid "All the \"What If?\" Questions"
msgstr ""

#: ../book/replication/index.rst:258
msgid "Q: What if there are more than two servers with master-master? |br| A: On each server, specify the :ref:`replication_source <cfg_replication-replication_source>` for all the others. For example, server #3 would have a request: |br| :codenormal:`box.cfg{` |br| |nbsp| |nbsp| |nbsp| :codenormal:`replication_source = {`:codeitalic:`uri#1, uri#2`:codenormal:`}` |br| :codenormal:`}`"
msgstr ""

#: ../book/replication/index.rst:265
msgid "Q: What if a server should be taken out of the cluster? |br| A: Run ``box.cfg{}`` again specifying a blank replication source: |br| ``box.cfg{replication_source=''}``"
msgstr ""

#: ../book/replication/index.rst:269
msgid "Q: What if a server leaves the cluster? |br| A: The other servers carry on. If the wayward server rejoins, it will receive all the updates that the other servers made while it was away."
msgstr ""

#: ../book/replication/index.rst:273
msgid "Q: What if two servers both change the same tuple? |br| A: The last changer wins. For example, suppose that server#1 changes the tuple, then server#2 changes the tuple. In that case server#2's change overrides whatever server#1 did. In order to keep track of who came last, Tarantool implements a `vector clock`_."
msgstr ""

#: ../book/replication/index.rst:279
msgid "Q: What if two servers both insert the same tuple? |br| A: If a master tries to insert a tuple which a replica has inserted already, this is an example of a severe error. Replication stops. It will have to be restarted manually."
msgstr ""

#: ../book/replication/index.rst:284
msgid "Q: What if a master disappears and the replica must take over? |br| A: A message will appear on the replica stating that the connection is lost. The replica must now become independent, which can be done by saying ``box.cfg{replication_source=''}``."
msgstr ""

#: ../book/replication/index.rst:289
msgid "Q: What if it's necessary to know what cluster a server is in? |br| A: The identification of the cluster is a UUID which is generated when the first master starts for the first time. This UUID is stored in a tuple of the :ref:`box.space._schema <box_space-schema>` system space. So to see it, say: ``box.space._schema:select{'cluster'}``"
msgstr ""

#: ../book/replication/index.rst:295
msgid "Q: What if it's necessary to know what other servers belong in the cluster? |br| A: The universal identification of a server is a UUID in ``box.info.server.uuid``. The ordinal identification of a server within a cluster is a number in ``box.info.server.id``. To see all the servers in the cluster, say: ``box.space._cluster:select{}``. This will return a table with all {server.id, server.uuid} tuples for every server that has ever joined the cluster."
msgstr ""

#: ../book/replication/index.rst:303
msgid "Q: What if one of the server's files is corrupted or deleted? |br| A: Stop the server, destroy all the database files (the ones with extension \"snap\" or \"xlog\" or \".inprogress\"), restart the server, and catch up with the master by contacting it again (just say ``box.cfg{...replication_source=...}``)."
msgstr ""

#: ../book/replication/index.rst:309
msgid "Q: What if replication causes security concerns? |br| A: Prevent unauthorized replication sources by associating a password with every user that has access privileges for the relevant spaces, and every user that has a replication :ref:`role <authentication-rep_role>`. That way, the :ref:`URI <index-uri>` for the ref:`replication_source <cfg_replication-replication_source>` parameter will always have to have the long form |br| ``replication_source='username:password@host:port'``"
msgstr ""

#: ../book/replication/index.rst:317
msgid "Q: What if advanced users want to understand better how it all works? |br| A: See the description of server startup with replication in the :ref:`Internals <b_internals-replication>` appendix."
msgstr ""

#: ../book/replication/index.rst:325
msgid "Hands-On Replication Tutorial"
msgstr ""

#: ../book/replication/index.rst:327
msgid "After following the steps here, an administrator will have experience creating a cluster and adding a replica."
msgstr ""

#: ../book/replication/index.rst:330
msgid "Start two shells. Put them side by side on the screen. (This manual has a tabbed display showing \"Terminal #1\". Click the \"Terminal #2\" tab to switch to the display of the other shell.)"
msgstr ""

#: ../book/replication/index.rst:356
#: ../book/replication/index.rst:363
#: ../book/replication/1_2.rst:1
msgid "$"
msgstr ""

#: ../book/replication/index.rst:397
msgid "On the first shell, which we'll call Terminal #1, execute these commands:"
msgstr ""

#: ../book/replication/index.rst:399
msgid "$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_1/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../book/replication/index.rst:411
msgid "The result is that a new cluster is set up, and the server's UUID is displayed. Now the screen looks like this: (except that UUID values are always different):"
msgstr ""

#: ../book/replication/1_1.rst:1
msgid "$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."
msgstr ""

#: ../book/replication/index.rst:473
msgid "On the second shell, which we'll call Terminal #2, execute these commands:"
msgstr ""

#: ../book/replication/index.rst:475
msgid "$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ~/tarantool_test_node_2/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../book/replication/index.rst:488
msgid "The result is that a replica is set up. Messages appear on Terminal #1 confirming that the replica has connected and that the WAL contents have been shipped to the replica. Messages appear on Terminal #2 showing that replication is starting. Also on Terminal#2 the _cluster UUID values are displayed, and one of them is the same as the _cluster UUID value that was displayed on Terminal #1, because both servers are in the same cluster."
msgstr ""

#: ../book/replication/2_1.rst:1
msgid "$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from `./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from `./00000000000000000000.xlog'"
msgstr ""

#: ../book/replication/2_2.rst:1
#: ../book/replication/3_2.rst:1
msgid "$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple arena...\n"
"<...> [11243] main/101/interactive C> starting replication from localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."
msgstr ""

#: ../book/replication/index.rst:554
msgid "On Terminal #1, execute these requests:"
msgstr ""

#: ../book/replication/index.rst:556
msgid "tarantool> s = box.schema.space.create('tester')\n"
"tarantool> i = s:create_index('primary', {})\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"
msgstr ""

#: ../book/replication/index.rst:562
#: ../book/replication/index.rst:849
msgid "Now the screen looks like this:"
msgstr ""

#: ../book/replication/3_1.rst:1
#: ../book/replication/4_1.rst:1
msgid "<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from `./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from `./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""

#: ../book/replication/index.rst:623
msgid "The creation and insertion were successful on Terminal #1. Nothing has happened on Terminal #2."
msgstr ""

#: ../book/replication/index.rst:626
msgid "On Terminal #2, execute these requests:"
msgstr ""

#: ../book/replication/index.rst:628
msgid "tarantool> s = box.space.tester\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"
msgstr ""

#: ../book/replication/index.rst:634
msgid "Now the screen looks like this (remember to click on the \"Terminal #2\" tab when looking at Terminal #2 results):"
msgstr ""

#: ../book/replication/4_2.rst:1
msgid "<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."
msgstr ""

#: ../book/replication/index.rst:695
msgid "The selection and insertion were successful on Terminal #2. Nothing has happened on Terminal #1."
msgstr ""

#: ../book/replication/index.rst:698
msgid "On Terminal #1, execute these Tarantool requests and shell commands:"
msgstr ""

#: ../book/replication/index.rst:700
msgid "$ os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"$ ls -l ~/tarantool_test_node_2"
msgstr ""

#: ../book/replication/index.rst:706
msgid "Now Tarantool #1 is stopped. Messages appear on Terminal #2 announcing that fact. The ``ls -l`` commands show that both servers have made snapshots, which have similar sizes because they both contain the same tuples."
msgstr ""

#: ../book/replication/5_1.rst:1
#: ../book/replication/6_1.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"
msgstr ""

#: ../book/replication/5_2.rst:1
msgid "<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"
msgstr ""

#: ../book/replication/index.rst:769
msgid "On Terminal #2, ignore the error messages, and execute these requests:"
msgstr ""

#: ../book/replication/index.rst:772
msgid "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"tarantool> box.space.tester:insert{3, 'Another'}"
msgstr ""

#: ../book/replication/index.rst:777
msgid "Now the screen looks like this (ignoring the error messages):"
msgstr ""

#: ../book/replication/6_2.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."
msgstr ""

#: ../book/replication/index.rst:839
msgid "Terminal #2 has done a select and an insert, even though Terminal #1 is down."
msgstr ""

#: ../book/replication/index.rst:841
msgid "On Terminal #1 execute these commands:"
msgstr ""

#: ../book/replication/index.rst:843
msgid "$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../book/replication/7_1.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""

#: ../book/replication/7_2.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"
msgstr ""

#: ../book/replication/index.rst:910
msgid "The master has reconnected to the cluster, and has NOT found what the replica wrote while the master was away. That is not a surprise -- the replica has not been asked to act as a replication source."
msgstr ""

#: ../book/replication/index.rst:914
msgid "On Terminal #1, say:"
msgstr ""

#: ../book/replication/index.rst:916
msgid "tarantool> box.cfg{\n"
"         >   replication_source = 'replicator:password@localhost:3302'\n"
"         > }\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../book/replication/8_1.rst:1
msgid "<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication_source='replicator:password@localhost:3302'\n"
"         > }\n"
" [28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication_source' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at 127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
"[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from `./00000000000000000008.xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."
msgstr ""

#: ../book/replication/8_2.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from `./00000000000000000000.xlog'"
msgstr ""

#: ../book/replication/index.rst:984
msgid "This shows that the two servers are once again in synch, and that each server sees what the other server wrote."
msgstr ""

#: ../book/replication/index.rst:987
msgid "To clean up, say \"``os.exit()``\" on both Terminal #1 and Terminal #2, and then on either terminal say:"
msgstr ""

#: ../book/replication/index.rst:990
msgid "$ cd ~\n"
"$ rm -R ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_2"
msgstr ""

#: ../book/user_guide_getting_started.rst:30
msgid "Getting started"
msgstr ""

#: ../book/user_guide_getting_started.rst:32
msgid "This chapter shows how to download, how to install, and how to start Tarantool for the first time."
msgstr ""

#: ../book/user_guide_getting_started.rst:35
msgid "For production, if possible, you should download a binary (executable) package. This will ensure that you have the same build of the same version that the developers have. That makes analysis easier if later you need to report a problem, and avoids subtle problems that might happen if you used different tools or different parameters when building from source. The section about binaries is :ref:`user_guide_getting_started-downloading_and_installing_a_binary_package`."
msgstr ""

#: ../book/user_guide_getting_started.rst:42
msgid "For development, you will want to download a source package and make the binary by yourself using a C/C++ compiler and common tools. Although this is a bit harder, it gives more control. And the source packages include additional files, for example the Tarantool test suite. The section about source is :ref:`building_from_source`."
msgstr ""

#: ../book/user_guide_getting_started.rst:47
msgid "If the installation has already been done, then you should try it out. So we've provided some instructions that you can use to make a temporary sandbox. In a few minutes you can start the server and type in some database-manipulation statements. The section about the sandbox is :ref:`user_guide_getting_started-first_database`."
msgstr ""

#: ../book/user_guide_getting_started.rst:57
msgid "Downloading and installing a binary package"
msgstr ""

#: ../book/user_guide_getting_started.rst:59
msgid "Binary packages for two Tarantool versions -- for the stable 1.6 and the latest 1.7 -- are provided at http://tarantool.org/download.html. An automatic build system creates, tests and publishes packages for every push into the 1.7 branch."
msgstr ""

#: ../book/user_guide_getting_started.rst:64
msgid "To download and install the package that's appropriate for your OS, start a shell (terminal) and enter the command-line instructions provided for your OS at http://tarantool.org/download.html."
msgstr ""

#: ../book/user_guide_getting_started.rst:72
msgid "Starting Tarantool and making your first database"
msgstr ""

#: ../book/user_guide_getting_started.rst:74
#: ../book/user_guide_getting_started.rst:83
msgid "Here is how to create a simple test database after installing."
msgstr ""

#: ../book/user_guide_getting_started.rst:76
msgid "Create a new directory. It's just for tests, you can delete it when the tests are over."
msgstr ""

#: ../book/user_guide_getting_started.rst:78
msgid "$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""

#: ../book/user_guide_getting_started.rst:85
msgid "Start the server. The server name is tarantool."
msgstr ""

#: ../book/user_guide_getting_started.rst:87
msgid "$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary\n"
"$ # tarball to ~/tarantool, say this:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # if you built from a source download, say this:\n"
"$ ~/tarantool/src/tarantool"
msgstr ""

#: ../book/user_guide_getting_started.rst:97
msgid "The server starts in interactive mode and outputs a command prompt. To turn on the database, :ref:`configure <box_introspection-box_cfg>` it. This minimal example is sufficient:"
msgstr ""

#: ../book/user_guide_getting_started.rst:100
msgid "tarantool> box.cfg{listen = 3301}"
msgstr ""

#: ../book/user_guide_getting_started.rst:104
msgid "If all goes well, you will see the server displaying progress as it initializes, something like this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:107
msgid "tarantool> box.cfg{listen = 3301}\n"
"2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
"2015-08-07 09:41:41.077 ... log level 5\n"
"2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
"2015-08-07 09:41:41.079 ... initialized\n"
"2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
"2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap.inprogress'\n"
"2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap.inprogress'\n"
"2015-08-07 09:41:41.127 ... done\n"
"2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
"2015-08-07 09:41:41.128 ... ready to accept requests"
msgstr ""

#: ../book/user_guide_getting_started.rst:121
msgid "Now that the server is up, you could start up a different shell and connect to its primary port with:"
msgstr ""

#: ../book/user_guide_getting_started.rst:124
msgid "$ telnet 0 3301"
msgstr ""

#: ../book/user_guide_getting_started.rst:128
msgid "but for example purposes it is simpler to just leave the server running in \"interactive mode\". On production machines the :ref:`interactive mode <administration-using_tarantool_as_a_client>` is just for administrators, but because it's convenient for learning it will be used for most examples in this manual. Tarantool is waiting for the user to type instructions."
msgstr ""

#: ../book/user_guide_getting_started.rst:134
msgid "To create the first space and the first :ref:`index <box_index>`, try this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:136
msgid "tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'NUM'}\n"
"         > })"
msgstr ""

#: ../book/user_guide_getting_started.rst:144
msgid "To insert three tuples (our name for records) into the first space of the database try this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:146
msgid "tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"
msgstr ""

#: ../book/user_guide_getting_started.rst:152
msgid "To select a tuple from the first space of the database, using the first defined key, try this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:154
msgid "tarantool> s:select{3}"
msgstr ""

#: ../book/user_guide_getting_started.rst:158
msgid "Your terminal screen should now look like this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:160
msgid "tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/user_guide_getting_started.rst:184
msgid "Now, to prepare for the example in the next section, try this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:186
msgid "tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../book/user_guide_getting_started.rst:194
msgid "Connecting remotely"
msgstr ""

#: ../book/user_guide_getting_started.rst:196
msgid "In the previous section the first request was with :code:`box.cfg{listen = 3301}`. The :code:`listen` value can be any form of URI (uniform resource identifier); in this case it's just a local port: port 3301. It's possible to send requests to the listen URI via (a) telnet, or (b) a connector (which will be the subject of the \":ref:`index-box_connectors`\" chapter), or (c) another instance of Tarantool via the :ref:`console package <console-package>`, or (d) ``tarantoolctl connect``. Let's try (d)."
msgstr ""

#: ../book/user_guide_getting_started.rst:206
msgid "Switch to another terminal. On Linux, for example, this means starting another instance of a Bash shell. There is no need to use cd to switch to the :code:`~/tarantool_sandbox` directory."
msgstr ""

#: ../book/user_guide_getting_started.rst:210
msgid "Start the tarantoolctl utility: |br| :codenormal:`$` :codebold:`tarantoolctl connect '3301'` |br| This means \"use the :ref:`tarantoolctl connect utility <administration-tarantoolctl_connect>` to connect to the Tarantool server that's listening on ``localhost:3301``.\""
msgstr ""

#: ../book/user_guide_getting_started.rst:216
msgid "Try this request: |br| :codenormal:`tarantool>` :codebold:`box.space.tester:select{2}` |br| This means \"send a request to that Tarantool server, and display the result.\" The result in this case is one of the tuples that was inserted earlier. Your terminal screen should now look like this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:223
msgid "$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Music']\n"
"...\n"
"\n"
"localhost:3301>"
msgstr ""

#: ../book/user_guide_getting_started.rst:234
msgid "You can repeat :code:`box.space...:insert{}` and :code:`box.space...:select{}` indefinitely, on either Tarantool instance. When the testing is over: To drop the space: :code:`s:drop()`. To stop tarantoolctl: Ctrl+C or Ctrl+D. To stop tarantool (an alternative): :ref:`os.exit() <os-exit>`. To stop tarantool (from another terminal): :code:`sudo pkill -f tarantool`. To destroy the test: :code:`rm -r ~/tarantool_sandbox`."
msgstr ""

#: ../book/user_guide_getting_started.rst:242
msgid "To review ... If you followed all the instructions in this chapter, then so far you have: installed Tarantool from either a binary or a source repository, started up the Tarantool server, inserted and selected tuples."
msgstr ""

