# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-22 20:32+0300\n"
"PO-Revision-Date: 2016-09-22 21:18+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"Language: ru\n"
"X-Generator: Poedit 1.8.9\n"
"X-Poedit-Bookmarks: 1698,-1,-1,-1,-1,-1,-1,-1,-1,-1\n"

#: ../book/administration.rst:30
msgid "Server administration"
msgstr "Администрирование серверной части"

#: ../book/administration.rst:32
msgid "Typical server administration tasks include starting and stopping the server, reloading configuration, taking snapshots, log rotation."
msgstr "Типичные задачи администрирования серверной части включают в себя запуск и остановку сервера, перезагрузку настроек, создание снимков, ротацию логов."

#: ../book/administration.rst:39
msgid "Using tarantool as a client"
msgstr "Использование tarantool в качестве клиента"

#: ../book/administration.rst:43
msgid "If :program:`tarantool` is started without an :ref:`initialization file <index-init_label>`, or if the initialization file contains :ref:`console.start() <console-start>`, then :program:`tarantool` enters interactive mode. There will be a prompt (\"``tarantool>``\") and it will be possible to enter requests. When used this way, :program:`tarantool` can be a client for a remote server."
msgstr "Если :program:`tarantool` запущен без :ref:`файла инициализации <index-init_label>`, или же в файле инициализации указана функция :ref:`console.start() <console-start>`, то :program:`tarantool` стартует в интерактивном режиме: он выводит приглашение командной строки (\"``tarantool>``\"), и запросы можно вводить прямо в консоли. В таком режиме :program:`tarantool` можно использовать в качестве клиента для удаленного сервера."

#: ../book/administration.rst:49
msgid "This section shows all legal syntax for the :program:`tarantool` program, with short notes and examples. Other client programs may have similar options and request syntaxes. Some of the information in this section is duplicated in the chapter :ref:`Configuration reference <index-book_cfg>`."
msgstr "В этом разделе описаны синтаксические правила для ввода запросов в консоли Tarantool'а, с примечаниями и примерами. Другие клиентские программы могут иметь схожие параметры и синтаксис запросов. Некоторые сведения из этого раздела дублируются в главе :ref:`Справочник по конфигурированию <index-book_cfg>`."

#: ../book/administration.rst:56
msgid "Conventions used in this section"
msgstr "Условные обозначения, используемые в этом разделе"

#: ../book/administration.rst:58
msgid "Tokens are character sequences which are treated as syntactic units within requests. Square brackets [ and ] enclose optional syntax. Three dots in a row ... mean the preceding tokens may be repeated. A vertical bar | means the preceding and following tokens are mutually exclusive alternatives."
msgstr "Токены — это последовательности символов, которые рассматриваются как синтаксические единицы в рамках запроса. Квадратные скобки [ и ] используются для обозначения необязательных токенов. Три точки в строке ... означают, что предыдущие токены могут повторяться. Вертикальная черта | означает, что предыдущие и последующие токены являются взаимоисключающими альтернативами."

#: ../book/administration.rst:65
msgid "Options when starting client from the command line"
msgstr "Параметры запуска клиента из командной строки"

#: ../book/administration.rst:67
msgid "General form:"
msgstr "Общий вид:"

#: ../book/administration.rst:72
msgid ""
"$ **tarantool**\n"
"OR\n"
"$ **tarantool** *options*\n"
"OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""
"$ tarantool\n"
"ИЛИ\n"
"$ tarantool опции\n"
"ИЛИ\n"
"$ tarantool файл-инициализации-на-lua [ аргументы ]"

#: ../book/administration.rst:78
msgid "Here *lua-initialization-file* can be any script containing code for initializing. Effect: The code in the file is executed during startup. Example: :samp:`init.lua`. |br| Notes: If a script is used, there will be no prompt. The script should contain configuration information including :samp:`box.cfg{...listen=...}` or :samp:`box.listen(...)` so that a separate program can connect to the server via one of the ports."
msgstr "*файл-инициализации-на-lua* — это любой скрипт, содержащий логику инициализации. Код из этого файла выполняется при запуске Tarantool'а.  Например: :samp:`init.lua`. |br| Примечания: При использовании скрипта, Tarantool не выводит приглашение командной строки. Скрипт должен содержать конфигурационные настройки, в т.ч. :samp:`box.cfg{...listen=...}` или :samp:`box.listen(...)`, чтобы внешние программы могли установить соединение с Tarantool-сервером на одном из указанных портов."

#: ../book/administration.rst:85
msgid "*Option* is one of the following (in alphabetical order by the long form of the option):"
msgstr "*Опция* — это одно из следующих значений (указаны в алфавитном порядке, по полному имени опции):"

#: ../book/administration.rst:90
msgid "Client displays a help message including a list of options. Example: :samp:`tarantool --help` The program stops after displaying the help."
msgstr "Tarantool-клиент выводит краткую справку, включая список всех параметров. Например: :samp:`tarantool --help`. Вывод останавливается после показа справки."

#: ../book/administration.rst:96
msgid "Client displays version information. Example: :samp:`tarantool --version`. The program stops after displaying the version."
msgstr "Tarantool-клиент выводит свой номер версии. Например: :samp:`tarantool --version`. Вывод останавливается после показа номера версии."

#: ../book/administration.rst:102
msgid "Tokens, requests, and special key combinations"
msgstr "Токены, запросы и специальные комбинации клавиш"

#: ../book/administration.rst:104
msgid "Procedure identifiers are: Any sequence of letters, digits, or underscores which is legal according to the rules for Lua identifiers. Procedure identifiers are also called function names. |br| Note: function names are case sensitive so ``insert`` and ``Insert`` are not the same thing."
msgstr "Идентификатором процедуры может быть любая последовательность букв, цифр и/или подчеркиваний, которая отвечает правилам именования идентификаторов в Lua. Термин \"идентификаторы процедур\" также применяют к именам функций. |br| Примечание: в случае с именами функций регистр имеет значение, поэтому ``insert`` и ``Insert`` — это не одно и то же."

#: ../book/administration.rst:110
msgid "String literals are: Any sequence of zero or more characters enclosed in single quotes. Double quotes are legal but single quotes are preferred. Enclosing in double square brackets is good for multi-line strings as described in `Lua documentation <http://www.lua.org/pil/2.4.html>`_. |br| Examples: 'Hello, world', 'A', [[A\\\\B!]]."
msgstr "Строковым литералом может быть любая последовательность из нуля и более символов, которая заключена в *одинарные кавычки*. *Двойные кавычки* также допустимы, но предпочтительным вариантом являются одинарные кавычки. А *двойные квадратные скобки* нужны для многострочных литералов (см. `документацию по языку Lua <http://www.lua.org/pil/2.4.html>`_). |br| Например: 'Hello, world', 'A', [[A\\\\B!]]."

#: ../book/administration.rst:116
msgid "Numeric literals are: Any sequence of one or more digits, not enclosed in quotes, optionally preceded by - (minus sign). Large or floating-point numeric literals may include decimal points, exponential notation, or suffixes.|br| Examples: 500, -500, 5e2, 500.1, 5LL, 5ULL."
msgstr "Числовым литералом может быть любая последовательность символов, состоящая из одной и более цифр с необязательным знаком + или - в начале. В состав больших числовых литералов, а также числовых литералов с плавающей точкой может входить десятичный разделитель (запятая или точка), символы для экспоненциального представления и суффиксы. |br| Например: 500, -500, 5e2, 500.1, 5LL, 5ULL."

#: ../book/administration.rst:122
msgid "Single-byte tokens are: , or ( or ) or arithmetic operators. |br| Examples: * , ( )."
msgstr "Однобайтовым символом может быть запятая, открывающая или закрывающая круглая скобка, а также арифметический оператор. |br| Например: * , ( )."

#: ../book/administration.rst:125
msgid "Tokens must be separated from each other by one or more spaces, except that spaces are not necessary around single-byte tokens or string literals."
msgstr "Токены должны разделяться одним или бОльшим количеством пробелов. Исключением являются однобайтовые токены и строковые литералы — вокруг них пробелы не нужны."

#: ../book/administration.rst:132
msgid "Requests"
msgstr "Запросы"

#: ../book/administration.rst:134
msgid "Generally requests are entered following the prompt in interactive mode while :program:`tarantool` is running. (A prompt will be the word 'tarantool' and a greater-than sign, for example :samp:`tarantool>`). The end-of-request marker is by default a newline (line feed)."
msgstr "Запросы вводятся после приглашения командной строки, когда Tarantool работает в интерактивном режиме. (Приглашение — это слово tarantool и знак \"больше\", вот так: :samp:`tarantool>`). Маркером конца запроса по умолчанию является перевод строки."

#: ../book/administration.rst:139
msgid "For multi-line requests, it is possible to change the end-of-request marker. Syntax: :samp:`console = require('console'); console.delimiter({string-literal})`. The string-literal must be a value in single quotes. Effect: string becomes end-of-request delimiter, so newline alone is not treated as end of request. To go back to normal mode: :samp:`console.delimiter(''){string-literal}`. Delimiters are usually not necessary because Tarantool can tell when a multi-line request has not ended (for example, if it sees that a function declaration does not have an :samp:`end` keyword). Example:"
msgstr "Для ввода многострочных запросов можно задать другой маркер конца запроса. Для этого введите команду следующего вида: :samp:`console = require('console'); console.delimiter({новый-маркер})`. В качестве нового маркера укажите строковый литерал в одинарных кавычках. После этого вам нужно будет вводить указанный маркер в конце каждого запроса, потому что Tarantool перестанет интерпретировать перевод строки как конец запроса. Чтобы вернуться к обычному режиму, введите: :samp:`console.delimiter(''){string-literal}`. Как правило, задавать свой маркер нет необходимости, поскольку Tarantool сам распознает, что запрос введен не полностью (скажем, когда Tarantool не встречает слова :samp:`end` в объявлении функции). Например:"

#: ../book/administration.rst:148
msgid ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"  statement_1 = 'a'\n"
"  statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"
msgstr ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"  statement_1 = 'a'\n"
"  statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"

#: ../book/administration.rst:157
msgid "See :ref:`here <box_protocol-iproto_protocol>` a condensed Backus-Naur Form [BNF] description of the suggested form of client requests."
msgstr "См. также :ref:`описание формата клиентских запросов <box_protocol-iproto_protocol>` в виде аннотированных BNF-диаграмм (Backus-Naur Form)."

#: ../book/administration.rst:160
msgid "In *interactive* mode, one types requests and gets results. Typically the requests are typed in by the user following prompts. Here is an example of an interactive-mode Tarantool client session:"
msgstr "Работая в  *интерактивном* режиме, Tarantool-сервер принимает введенные запросы и выводит результаты. Запросы, как правило, вводит пользователь. Вот пример интерактивной пользовательской сессии:"

#: ../book/administration.rst:164
msgid ""
"$ tarantool\n"
"[ tarantool will display an introductory message\n"
"  including version number here ]\n"
"tarantool> box.cfg{listen = 3301}\n"
"[ tarantool will display configuration information here ]\n"
"tarantool> s = box.schema.space.create('tester')\n"
"[ tarantool may display an in-progress message here ]\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{1,'My first tuple'}\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:select(1)\n"
"---\n"
"- - [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:drop()\n"
"---\n"
"...\n"
"tarantool> os.exit()\n"
"2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master shutdown\n"
"$"
msgstr ""
"$ tarantool\n"
"[ здесь tarantool выводит приветствие и номер версии ]\n"
"tarantool> box.cfg{listen = 3301}\n"
"[ здесь tarantool выводит свои текущие настройки ]\n"
"tarantool> s = box.schema.space.create('tester')\n"
"[ здесь tarantool может вывести сообщение о том,\n"
"  что идет обработка запроса ]\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{1,'My first tuple'}\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:select(1)\n"
"---\n"
"- - [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:drop()\n"
"---\n"
"...\n"
"tarantool> os.exit()\n"
"2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master shutdown\n"
"$"

#: ../book/administration.rst:193
msgid "Explanatory notes about what Tarantool displayed in the above example:"
msgstr "Пояснения к приведенному выше примеру:"

#: ../book/administration.rst:195
msgid "Many requests return typed objects. In the case of :samp:`box.cfg{listen=3301}`, this result is displayed on the screen. If the request had assigned the result to a variable, for example :samp:`c = box.cfg{listen=3301}`, then the result would not have been displayed on the screen."
msgstr "На многие запросы Tarantool возвращает типизированные объекты. В ответ на запрос :samp:`box.cfg{listen=3301}` Tarantool выведет результат на экран. Если в запросе задано, что его результат должен быть записан в некоторую переменную, например :samp:`c = box.cfg{listen=3301}`, то в таком случае вывода результата на экран не происходит."

#: ../book/administration.rst:199
msgid "A display of an object always begins with \"``---``\" and ends with \"``...``\"."
msgstr "Вывод объекта в Tarantool'е всегда начинается со строки \"``---``\" и заканчивается строкой \"``...``\"."

#: ../book/administration.rst:200
msgid "The insert request returns an object of type = tuple, so the object display line begins with a single dash ('``-``'). However, the select request returns an object of type = table of tuples, so the object display line begins with two dashes ('``- -``')."
msgstr "По запросу на вставку данных возвращается объект типа кортеж (tuple), и в этом случае перед выводом будет стоять одиночное тире ('``-``'). А по запросу на выборку данных возвращается объект типа таблица кортежей (table of tuples), и в этом случае перед выводом будут стоять два тире ('``- -``')."

#: ../book/administration.rst:209
msgid "Utility tarantoolctl"
msgstr "Утилита tarantoolctl"

#: ../book/administration.rst:213
msgid "With :program:`tarantoolctl`, you can say: \"start an instance of the Tarantool server which runs a single user-written Lua program, allocating disk resources specifically for that program, via a standardized deployment method.\""
msgstr ""

#: ../book/administration.rst:217
msgid "If Tarantool was installed with Debian or Red Hat installation packages, the script is in :file:`/usr/bin/tarantoolctl` or :file:`/usr/local/bin/tarantoolctl`. The script handles such things as: starting, stopping, rotating logs, logging in to the application's console, and checking status."
msgstr ""

#: ../book/administration.rst:224
#, fuzzy
msgid "Also, you can use :program:`tarantoolctl` :ref:`as a client <administration-tarantoolctl_connect>` to connect to another instance of Tarantool server and pass requests."
msgstr "Данная команда означает \"использовать утилиту :ref:`tarantoolctl <administration-tarantoolctl_connect>` для соединения с Tarantool-сервером, который слушает на ``localhost:3301``.\""

#: ../book/administration.rst:230
msgid "Configuration for tarantoolctl"
msgstr "Конфигурирование tarantoolctl"

#: ../book/administration.rst:232
msgid "The :program:`tarantoolctl` script will look for a configuration file in the current directory (:file:`$PWD/.tarantoolctl`). If that fails, it looks in the current user's home directory (:file:`$HOME/.config/tarantool/tarantool`). If that fails, it looks in the SYSCONFDIR directory (usually :file:`/etc/sysconfig/tarantool`, but it may be different on some platforms). Most of the settings are similar to the settings used by :samp:`box.cfg{...}`; however, :program:`tarantoolctl` adjusts some of them by adding an application name. A copy of :file:`usr/local/etc/default/tarantool`, with defaults for all settings, would look like this:"
msgstr "Скрипт :program:`tarantoolctl` сначала проверяет наличие файла конфигурации в текущей директории (:file:`$PWD/.tarantoolctl`). Если не находит, то проверяет домашнюю директорию текущего пользователя (:file:`$HOME/.config/tarantool/tarantool`). Если опять не находит, то проверяет директорию, указанную в переменной SYSCONFDIR (обычно это :file:`/etc/sysconfig/tarantool`, но на разных платформах этот путь может различаться). Большинство параметров :program:`tarantoolctl` аналогичны тем, что задаются в запросе :samp:`box.cfg{...}`; однако :program:`tarantoolctl` меняет значение некоторых параметров, дописывая к ним имя приложения. Далее приводится копия файла :file:`usr/local/etc/default/tarantool`, где для всех параметров указаны их значения по умолчанию:"

#: ../book/administration.rst:243
msgid ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\",\n"
"    wal_dir    = \"/var/lib/tarantool\",\n"
"    snap_dir   = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    logger     = \"/var/log/tarantool\",\n"
"    username   = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\",\n"
"    wal_dir    = \"/var/lib/tarantool\",\n"
"    snap_dir   = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    logger     = \"/var/log/tarantool\",\n"
"    username   = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""

#: ../book/administration.rst:255
msgid "The settings in the above script are:"
msgstr "Комментарии к параметрам в приведенном выше скрипте:"

#: ../book/administration.rst:259
msgid "``pid_file``"
msgstr "``pid_file``"

#: ../book/administration.rst:258
msgid "The directory for the pid file and control-socket file. The script will add \":samp:`/{instance-name}`\" to the directory name."
msgstr "Директория, где хранятся pid-файл и socket-файл. Скрипт :program:`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:263
msgid "``wal_dir``"
msgstr "``wal_dir``"

#: ../book/administration.rst:262
msgid "The directory for the write-ahead :file:`*.xlog` files. The script will add \":samp:`/{instance-name}`\" to the directory-name."
msgstr "Директория, где хранятся :file:`*.xlog`-файлы. Скрипт :program:`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:267
msgid "``snap_dir``"
msgstr "``snap_dir``"

#: ../book/administration.rst:266
msgid "The directory for the snapshot :file:`*.snap` files. The script will add \":samp:`/{instance-name}`\" to the directory-name."
msgstr "Директория, где хранятся :file:`*.snap`-файлы. Скрипт :program:`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:271
msgid "``vinyl_dir``"
msgstr "``vinyl_dir``"

#: ../book/administration.rst:270
msgid "The directory for the vinyl-storage-engine files. The script will add \":samp:`/vinyl/{instance-name}`\" to the directory-name."
msgstr "Директория, где хранятся файлы движка vinyl. Скрипт :program:`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:275
msgid "``logger``"
msgstr "``logger``"

#: ../book/administration.rst:274
msgid "The place where the application log will go. The script will add \":samp:`/{instance-name}.log`\" to the name."
msgstr "Директория, где хранятся файлы журнала с сообщениями от Tarantool-приложений. Скрипт :program:`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:279
msgid "``username``"
msgstr "``username``"

#: ../book/administration.rst:278
msgid "The user that runs the Tarantool server. This is the operating-system user name rather than the Tarantool-client user name."
msgstr "Имя пользователя, из-под которого запущен Tarantool-сервер. Это имя пользователя в операционной системе, а не в Tarantool-клиенте."

#: ../book/administration.rst:286
msgid "``instance_dir``"
msgstr "``instance_dir``"

#: ../book/administration.rst:282
msgid "The directory where all applications for this host are stored. The user who writes an application for :program:`tarantoolctl` must put the application's source code in this directory, or a symbolic link. For examples in this section the application name ``my_app`` will be used, and its source will have to be in :samp:`{instance_dir}/my_app.lua`."
msgstr "Имя директории, где хранятся исходные файлы всех Tarantool-приложений для данного хоста. Пользователю, который пишет приложение для :program:`tarantoolctl`, нужно положить исходный код своего приложения в эту директорию или настроить симлинк. Далее для примеров в этом разделе мы используем Tarantool-приложение с именем ``my_app``, и его исходный код должен лежать в файле :samp:`{instance_dir}/my_app.lua`."

#: ../book/administration.rst:290
msgid "Commands for tarantoolctl"
msgstr "Команды для tarantoolctl"

#: ../book/administration.rst:292
msgid "The command format is :samp:`tarantoolctl {operation} {application_name}`, where operation is one of: start, stop, enter, logrotate, status, eval. Thus ..."
msgstr "Команды для :program:`tarantoolctl` имеют вид :samp:`tarantoolctl {операция} {имя_приложения}`. В качестве *операции* можно указать одно из следующих значений: start, stop, enter, logrotate, status, eval."

#: ../book/administration.rst:297
msgid "Start application *<application>*"
msgstr "Запустить приложение с именем *<application>*"

#: ../book/administration.rst:301
msgid "Stop application"
msgstr "Остановить приложение"

#: ../book/administration.rst:305
msgid "Show application's admin console"
msgstr "Вывести консоль для управления приложением"

#: ../book/administration.rst:309
msgid "Rotate application's log files (make new, remove old)"
msgstr "Произвести ротацию журналов указанного приложения (создать новые, удалить старые)"

#: ../book/administration.rst:313
msgid "Check application's status"
msgstr "Проверить статус приложения"

#: ../book/administration.rst:317
msgid "Execute code from *<scriptname>* on an instance of application"
msgstr "Выполнить код из файла *<scriptname>* от имени запущенного экземпляра приложения *<application>*"

#: ../book/administration.rst:321
msgid "Connect to a Tarantool server running at the specified :ref:`URI <index-uri>`"
msgstr ""

#: ../book/administration.rst:325
msgid "Typical code snippets for tarantoolctl"
msgstr "Примеры кода для tarantoolctl"

#: ../book/administration.rst:327
msgid "A user can check whether ``my_app`` is running with these lines:"
msgstr "Проверить, запущено ли приложение ``my_app``:"

#: ../book/administration.rst:329
msgid ""
"if tarantoolctl status my_app; then\n"
"...\n"
"fi"
msgstr ""
"if tarantoolctl status my_app; then\n"
"...\n"
"fi"

#: ../book/administration.rst:335
msgid "A user can initiate, for boot time, an :file:`init.d` set of instructions:"
msgstr "Выполнить инструкции из файла :file:`init.d` во время запуска приложения:"

#: ../book/administration.rst:337
msgid ""
"for (each file mentioned in the instance_dir directory):\n"
"    tarantoolctl start `basename $ file .lua`"
msgstr ""
"for (каждый файл в директории instance_dir):\n"
"    tarantoolctl start `basename $ file .lua`"

#: ../book/administration.rst:342
msgid "A user can set up a further configuration file for log rotation, like this:"
msgstr "Указать файл конфигурации для ротации журнала, например:"

#: ../book/administration.rst:347
msgid ""
"/path/to/tarantool/\\*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /path/to/tarantoolctl logrotate `basename $ 1 .log`\n"
"    endscript\n"
"}"
msgstr ""
"/path/to/tarantool/\\*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /path/to/tarantoolctl logrotate `basename $ 1 .log`\n"
"    endscript\n"
"}"

#: ../book/administration.rst:362
msgid "A detailed example for tarantoolctl"
msgstr "Подробный пример для tarantoolctl"

#: ../book/administration.rst:364
#, fuzzy
msgid "The example's objective is to make a temporary directory where :program:`tarantoolctl` can start a long-running application and monitor it."
msgstr "В этом примере мы создадим временную директорию, в которой :program:`tarantoolctl` сможет запускать и мониторить некое долго работающее приложение."

#: ../book/administration.rst:367
msgid "The assumptions are: the root password is known, the computer is only being used for tests, the Tarantool server is ready to run but is not currently running, tarantoolctl is installed along the user's path, and there currently is no directory named :file:`tarantool_test`."
msgstr "Итак, наши исходные условия: нам известен пароль root-пользователя; компьютер используется только для тестирования; Tarantool-сервер настроен и готов к запуску, но пока еще не запущен ;программа :program:`tarantoolctl` установлена в пользовательском окружении; пока не существует директории с именем :file:`tarantool_test`."

#: ../book/administration.rst:372
msgid "Create a directory named :file:`/tarantool_test`:"
msgstr "Создадим директорию с именем :file:`/tarantool_test`:"

#: ../book/administration.rst:374
msgid "$ sudo mkdir /tarantool_test"
msgstr "$ sudo mkdir /tarantool_test"

#: ../book/administration.rst:378
msgid "Edit :file:`/usr/local/etc/default/tarantool`. It might be necessary to say :samp:`sudo mkdir /usr/local/etc/default` first. Let the new file contents be:"
msgstr "Отредактируем файл :file:`/usr/local/etc/default/tarantool`. Для этого нам сначала может понадобиться выполнить команду :samp:`sudo mkdir /usr/local/etc/default`. Указанный файл будет содержать следующие настройки:"

#: ../book/administration.rst:382
msgid ""
"default_cfg = {\n"
"    pid_file = \"/tarantool_test/my_app.pid\",\n"
"    wal_dir = \"/tarantool_test\",\n"
"    snap_dir = \"/tarantool_test\",\n"
"    vinyl_dir = \"/tarantool_test\",\n"
"    logger = \"/tarantool_test/log\",\n"
"    username = \"tarantool\",\n"
"}\n"
"instance_dir = \"/tarantool_test\""
msgstr ""
"default_cfg = {\n"
"    pid_file = \"/tarantool_test/my_app.pid\",\n"
"    wal_dir = \"/tarantool_test\",\n"
"    snap_dir = \"/tarantool_test\",\n"
"    vinyl_dir = \"/tarantool_test\",\n"
"    logger = \"/tarantool_test/log\",\n"
"    username = \"tarantool\",\n"
"}\n"
"instance_dir = \"/tarantool_test\""

#: ../book/administration.rst:394
msgid "Make the ``my_app`` application file, that is, :file:`/tarantool_test/my_app.lua`. Let the file contents be:"
msgstr "Создадим файл :file:`/tarantool_test/my_app.lua` для приложения ``my_app``:"

#: ../book/administration.rst:397
msgid ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"

#: ../book/administration.rst:413
msgid "Tell :program:`tarantoolctl` to start the application ..."
msgstr "С помощью :program:`tarantoolctl` запустим наше приложение..."

#: ../book/administration.rst:415
msgid ""
"$ cd /tarantool_test\n"
"$ sudo tarantoolctl start my_app"
msgstr ""
"$ cd /tarantool_test\n"
"$ sudo tarantoolctl start my_app"

#: ../book/administration.rst:420
msgid "... expect to see messages indicating that the instance has started. Then ..."
msgstr "... и получим сообщения о том, что экземпляр нашего приложения запущен. Затем скажем:"

#: ../book/administration.rst:422
msgid "$ ls -l /tarantool_test/my_app"
msgstr "$ ls -l /tarantool_test/my_app"

#: ../book/administration.rst:426
msgid "... expect to see the :file:`.snap` file and the :file:`.xlog` file. Then ..."
msgstr "... и увидим :file:`.snap`-файл и :file:`.xlog`-файл. Затем скажем:"

#: ../book/administration.rst:428
msgid "$ sudo less /tarantool_test/log/my_app.log"
msgstr "$ sudo less /tarantool_test/log/my_app.log"

#: ../book/administration.rst:432
msgid "... expect to see the contents of ``my_app``'s log, including error messages, if any. Then ..."
msgstr "... и увидим содержимое файла журнала для приложения ``my_app``, в т.ч. сообщения об ошибках, если они были. Затем скажем:"

#: ../book/administration.rst:435
msgid ""
"$ cd /tarantool_test\n"
"$ # assume that 'tarantool' invokes the tarantool server\n"
"$ sudo tarantool\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ cd /tarantool_test\n"
"$ # допустим, что 'tarantool' запускает Tarantool-сервер\n"
"$ sudo tarantool\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../book/administration.rst:445
msgid "... expect to see several tuples that ``my_app`` has created."
msgstr "... и увидим те несколько кортежей, которые создало приложение ``my_app``."

#: ../book/administration.rst:447
msgid "Stop. The only clean way to stop ``my_app`` is with :program:`tarantoolctl`, thus:"
msgstr "Всё. Теперь остановим приложение ``my_app``. Единственный корректный способ — это использовать :program:`tarantoolctl`:"

#: ../book/administration.rst:449
msgid "$ sudo tarantoolctl stop my_app"
msgstr "$ sudo tarantoolctl stop my_app"

#: ../book/administration.rst:453
msgid "Clean up. Restore the original contents of :file:`/usr/local/etc/default/tarantool`, and ..."
msgstr "Почистим систему после тестирования. Приведем содержимое файла :file:`/usr/local/etc/default/tarantool` к исходному виду и удалим нашу тестовую директорию:"

#: ../book/administration.rst:456
msgid ""
"$ cd /\n"
"$ sudo rm -R tarantool_test"
msgstr ""
"$ cd /\n"
"$ sudo rm -R tarantool_test"

#: ../book/administration.rst:465
#, fuzzy
msgid "An example for tarantoolctl connect"
msgstr "Подробный пример для tarantoolctl"

#: ../book/administration.rst:467
msgid "$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr "$ tarantoolctl connect username:password@127.0.0.1:3306"

#: ../book/administration.rst:473
#, fuzzy
msgid "There are alternatives to :program:`tarantoolctl connect` -- you can use the :ref:`console module <console-module>` or the :ref:`net.box module <net_box-module>` from a Tarantool server. Also, you can write your client programs with any of the Connectors. However, most of the examples in this manual illustrate usage with either :program:`tarantoolctl connect` or with :ref:`using the Tarantool server as a client <administration-using_tarantool_as_a_client>`."
msgstr "Вместо :program:`tarantoolctl connect` вы можете использовать модули :ref:`console <console-module>` или :ref:`net.box <net_box-module>` из библиотеки Tarantool'а. Еще одна альтернатива — это написать клиентскую программу под любой из существующих Tarantool-коннекторов. Но для большинства примеров в текущей документации мы используем :program:`tarantoolctl connect` или :ref:`Tarantool-сервер в качестве клиента <administration-using_tarantool_as_a_client>`."

#: ../book/administration.rst:485
msgid "Administrative ports"
msgstr "Служебные порты"

#: ../book/administration.rst:487
msgid "\"Admin port\", \"admin console\", and \"text protocol\" all refer to the same thing: a connection which is set up with :ref:`console.listen(...) <console-listen>` for entry of requests by administrators."
msgstr "Термины \"порт для администрирования\", \"консоль для администрирования\", \"текстовый протокол\" относятся к установке соединения с помощью :ref:`console.listen(...) <console-listen>` для ввода запросов от администраторов."

#: ../book/administration.rst:492
msgid "\"Binary port\", \"binary protocol\", and \"primary port\" all refer to a different thing: a connection which is set up with :ref:`box.cfg{listen=...} <cfg_basic-listen>` for entry of requests by anyone."
msgstr "Термины \"бинарный порт\", \"бинарный протокол\", \"первичный порт\" относятся к другому виду соединения — тому, что устанавливается с помощью параметра :ref:`box.cfg{listen=...} <cfg_basic-listen>` и предназначено для ввода запросов от любых пользователей."

#: ../book/administration.rst:497
msgid "Ordinary connections to the Tarantool server should go via a binary port. But admin ports are useful for special cases involving security."
msgstr "Для обычных соединений с Tarantool-сервером должен использоваться бинарный протокол. А порты для администрирования нужны для особых случаев, когда повышены требования к безопасности."

#: ../book/administration.rst:500
msgid "When you connect to an admin port:"
msgstr "При установке соединение через порт для администрирования:"

#: ../book/administration.rst:502
msgid "No password is necessary"
msgstr "Пароль не требуется"

#: ../book/administration.rst:503
msgid "The user is automatically 'admin', a user with many privileges."
msgstr "Пользователь автоматически получает привилегии администратора."

#: ../book/administration.rst:505
msgid "Therefore you must set up admin ports very cautiously. If it is a TCP port, it should only be opened for a specific IP. Ideally it should not be a TCP port at all, it should be a Unix domain socket, so that access to the server machine is required. Thus a typical setup for an admin port is:"
msgstr "Поэтому порты для администрирования следует настраивать очень осторожно. Если это TCP-порт, то он должен быть открыть только для определенного IP-адреса. В идеале мы рекомендуем вовсе не использовать TCP-порты. Вместо них лучше настроить доменный Unix-сокет, который требует настройки прав доступа к серверной машине. Тогда типичная настройка порта для администрирования будет выглядеть следующим образом:"

#: ../book/administration.rst:511
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr "console.listen('/var/lib/tarantool/socket_name.sock')"

#: ../book/administration.rst:515
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr "а типичный :ref:`URI <index-uri>` для соединения будет таким:"

#: ../book/administration.rst:517
msgid "admin:any_string@/var/lib/tarantool/socket_name.sock"
msgstr "admin:any_string@/var/lib/tarantool/socket_name.sock"

#: ../book/administration.rst:521
msgid "if the listener has the privilege to write on :file:`/var/lib/tarantool` and the connector has the privilege to read on :file:`/var/lib/tarantool`. Alternatively both setup and connection can be done with :ref:`tarantoolctl <administration-tarantoolctl>`."
msgstr "Это в том случае, если у сервера (listener'а) есть привилегии на запись в файл :file:`/var/lib/tarantool`, а на стороне клиента (connector'а) есть привилегии на чтение из того же файла. Аналогично можно установить соединение и задать настройки с помощью :ref:`tarantoolctl <administration-tarantoolctl>`."

#: ../book/administration.rst:526
msgid "If no administrator password exists which could be given out to users, and admin ports are restricted or are sockets, then requests which require 'admin' privileges can only occur locally, and are subject to Unix security and monitoring."
msgstr "Если не задан пароль администратора, который можно сообщить пользователям, а порты для администрирования настроены с ограничением доступа по IP либо через сокеты, то запросы, требующие привилегий администратора, можно делать только локально, где вопросы безопасности и мониторинга регулируются с помощью средств Unix-системы."

#: ../book/administration.rst:531
msgid "For additional security, some requests are illegal. For example, :ref:`\"conn:eval\" <net_box-eval>`  will result in the error message \"- error: console does not support this request type\" because ``conn:eval`` requires the binary protocol."
msgstr "В целях дополнительной безопасности некоторые запросы на портах для администрирования запрещены. Например, :ref:`conn:eval <net_box-eval>` вернет сообщение об ошибке ``- error: console does not support this request type``, поскольку запрос ``conn:eval`` должен осуществляться в рамках бинарного протокола."

#: ../book/administration.rst:536
msgid "If security via admin ports is not necessary, it is still possible to be an admin user by :ref:`using the tarantool server as a client <administration-using_tarantool_as_a_client>`, or by connecting to a binary port with a valid password."
msgstr "Если вопросы безопасности на портах для администрирования неактуальны, то стать пользователем с правами администратора можно, :ref:`используя Tarantool-сервер в качестве клиента <administration-using_tarantool_as_a_client>` или указав администраторский пароль при установке соединения по бинарному протоколу."

#: ../book/administration.rst:541
msgid "To find out whether a TCP port is an admin port, use :program:`telnet`. For example:"
msgstr "Выяснить, является ли некий TCP-порт портом для администрирования, можно с помощью :program:`telnet`. Например:"

#: ../book/administration.rst:544
msgid ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.1-70-gbc479ad (Lua console)\n"
"type 'help' for interactive help"
msgstr ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.1-70-gbc479ad (Lua console)\n"
"type 'help' for interactive help"

#: ../book/administration.rst:553
msgid "In this example the response does not include the word \"binary\" and does include the words \"Lua console\". Therefore it is clear that this is a successful connection to an admin port, and admin requests can now be entered on this terminal."
msgstr "В этом примере в ответе от сервера нет слова \"binary\" и есть слова \"Lua console\". Это значит, что мы установили соединение на порту для администрирования и можем вводить администраторские запросы на этом терминале."

#: ../book/administration.rst:560
msgid "Administrative requests"
msgstr "Служебные запросы"

#: ../book/admin.rst:1
msgid "To learn which functions are considered to be administrative, type ``help()``. A reference description also follows below:"
msgstr ""

#: ../book/admin.rst:8
msgid "Take a snapshot of all data and store it in :ref:`snap_dir <cfg_basic-snap_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first enters the delayed garbage collection mode for all data. In this mode, tuples which were allocated before the snapshot has started are not freed until the snapshot has finished. To preserve consistency of the primary key, used to iterate over tuples, a copy-on-write technique is employed. If the master process changes part of a primary key, the corresponding process page is split, and the snapshot process obtains an old copy of the page. In effect, the snapshot process uses multi-version concurrency control in order to avoid copying changes which are superseded while it is running."
msgstr ""

#: ../book/admin.rst:19
#, python-format
msgid "Since a snapshot is written sequentially, one can expect a very high write performance (averaging to 80MB/second on modern disks), which means an average database instance gets saved in a matter of minutes. Note: as long as there are any changes to the parent index memory through concurrent updates, there are going to be page splits, and therefore one needs to have some extra free memory to run this command. 10% of :ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` is, on average, sufficient. This statement waits until a snapshot is taken and returns operation result."
msgstr ""

#: ../book/admin.rst:28
msgid "Change Notice: prior to Tarantool version 1.6.6, the snapshot process caused a fork, which could cause occasional latency spikes. Starting with Tarantool version 1.6.6, the snapshot process creates a consistent read view and writes this view to the snapshot file from a separate thread."
msgstr ""

#: ../book/admin.rst:33
msgid "Although box.snapshot() does not cause a fork, there is a separate fiber which may produce snapshots at regular intervals -- see the discussion of the :ref:`snapshot daemon <book_cfg_snapshot_daemon>`."
msgstr ""

#: ../book/admin.rst:37 ../book/box/authentication.rst:152
#: ../book/box/authentication.rst:275 ../book/box/box_index.rst:70
#: ../book/box/box_index.rst:443 ../book/box/box_index.rst:579
#: ../book/box/box_index.rst:608 ../book/box/box_index.rst:637
#: ../book/box/box_index.rst:666 ../book/box/box_index.rst:694
#: ../book/box/box_index.rst:765 ../book/box/box_index.rst:787
#: ../book/box/box_index.rst:808 ../book/box/box_introspection.rst:14
#: ../book/box/box_introspection.rst:57 ../book/box/box_introspection.rst:114
#: ../book/box/box_schema.rst:159 ../book/box/box_schema.rst:189
#: ../book/box/box_schema.rst:218 ../book/box/box_schema.rst:234
#: ../book/box/box_schema.rst:252 ../book/box/box_schema.rst:269
#: ../book/box/box_schema.rst:288 ../book/box/box_schema.rst:303
#: ../book/box/box_schema.rst:316 ../book/box/box_schema.rst:340
#: ../book/box/box_schema.rst:368 ../book/box/box_schema.rst:383
#: ../book/box/box_schema.rst:406 ../book/box/box_schema.rst:425
#: ../book/box/box_schema.rst:438 ../book/box/box_space.rst:284
#: ../book/box/box_space.rst:314 ../book/box/box_space.rst:392
#: ../book/box/box_space.rst:413 ../book/box/box_space.rst:432
#: ../book/box/box_space.rst:467 ../book/box/box_space.rst:535
#: ../book/box/box_space.rst:638 ../book/box/box_space.rst:661
#: ../book/box/box_space.rst:689 ../book/box/box_space.rst:727
#: ../book/box/box_space.rst:746 ../book/box/box_space.rst:769
#: ../book/box/box_space.rst:786 ../book/box/box_space.rst:818
#: ../book/box/box_space.rst:851 ../book/box/box_space.rst:875
#: ../book/box/box_space.rst:911 ../book/box/box_space.rst:953
#: ../book/box/box_space.rst:997 ../book/box/box_tuple.rst:59
#: ../book/box/triggers.rst:58 ../book/box/triggers.rst:85
#: ../book/box/triggers.rst:157 ../book/box/triggers.rst:188
#: ../book/box/triggers.rst:206
msgid "**Example:**"
msgstr ""

#: ../book/admin.rst:39
msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../book/admin.rst:54
msgid "Taking a snapshot does not cause the server to start a new write-ahead log. Once a snapshot is taken, old WALs can be deleted as long as all replicas are up to date. But the WAL which was current at the time ``box.snapshot()`` started must be kept for recovery, since it still contains log records written after the start of ``box.snapshot()``."
msgstr ""

#: ../book/admin.rst:60
msgid "An alternative way to save a snapshot is to send the server SIGUSR1 UNIX signal. While this approach could be handy, it is not recommended for use in automation: a signal provides no way to find out whether the snapshot was taken successfully or not."
msgstr ""

#: ../book/admin.rst:67
msgid "Fork and dump a core. Since Tarantool stores all tuples in memory, it can take some time. Mainly useful for debugging."
msgstr ""

#: ../book/administration.rst:566
msgid "Server introspection"
msgstr "Просмотр состояния сервера"

#: ../book/box/box_introspection.rst:5
msgid "Submodule `box.cfg`"
msgstr ""

#: ../book/box/box_introspection.rst:9
msgid "The ``box.cfg`` submodule is for administrators to specify all the server configuration parameters (see \"Configuration reference\" for :ref:`a complete description of all configuration parameters <box_cfg_params>`). Use ``box.cfg`` without braces to get read-only access to those parameters."
msgstr ""

#: ../book/box/box_introspection.rst:16
msgid ""
"tarantool> box.cfg\n"
"---\n"
"- snapshot_count: 6\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  slab_alloc_maximal: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:30
msgid "Submodule `box.info`"
msgstr ""

#: ../book/box/box_introspection.rst:34
msgid "The ``box.info`` submodule provides access to information about server variables. Some important ones:"
msgstr ""

#: ../book/box/box_introspection.rst:37
msgid "**server.uuid** holds the unique identifier of the server. This value is also in the :ref:`box.space._cluster <box_space-cluster>` system space."
msgstr ""

#: ../book/box/box_introspection.rst:39
msgid "**pid** is the process ID of the server. This value is also shown by the :ref:`tarantool <tarantool-build>` module."
msgstr ""

#: ../book/box/box_introspection.rst:41
msgid "**version** is the Tarantool version. This value is also shown by :ref:`tarantool --version <index-tarantool_version>`."
msgstr ""

#: ../book/box/box_introspection.rst:43
msgid "**uptime** is the number of seconds since the server started."
msgstr ""

#: ../book/box/box_introspection.rst:49
msgid "Since ``box.info`` contents are dynamic, it's not possible to iterate over keys with the Lua ``pairs()`` function. For this purpose, ``box.info()`` builds and returns a Lua table with all keys and values provided in the submodule."
msgstr ""

#: ../book/box/box_introspection.rst:54
msgid "keys and values in the submodule."
msgstr ""

#: ../book/box/box_index.rst:68 ../book/box/box_introspection.rst:55
#: ../book/box/box_schema.rst:77 ../book/box/box_space.rst:744
msgid "table"
msgstr ""

#: ../book/box/box_introspection.rst:59
msgid ""
"tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 158\n"
"    ro: false\n"
"    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
"    id: 1\n"
"  version: 1.7.0-1216-g73f7154\n"
"  pid: 12932\n"
"  status: running\n"
"  vclock:\n"
"  - 158\n"
"  replication:\n"
"    status: off\n"
"  uptime: 908\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-66-g9093daa\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:96
msgid "Submodule `box.slab`"
msgstr ""

#: ../book/box/box_introspection.rst:100
msgid "The ``box.slab`` submodule provides access to slab allocator statistics. The slab allocator is the main allocator used to store tuples. This can be used to monitor the total memory use and memory fragmentation."
msgstr ""

#: ../book/box/box_introspection.rst:104
#, python-format
msgid "The display of slabs is broken down by the slab size -- 64-byte, 136-byte, and so on. The example omits the slabs which are empty. The example display is saying that: there are 16 items stored in the 64-byte slab (and 16*64=102 so bytes_used = 1024); there is 1 item stored in the 136-byte slab (and 136*1=136 so bytes_used = 136); the arena_used value is the total of all the bytes_used values (1024+136 = 1160); the arena_size value is the arena_used value plus the total of all the bytes_free values (1160+4193200+4194088 = 8388448). The arena_size and arena_used values are the amount of the % of :ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` that is already distributed to the slab allocator."
msgstr ""

#: ../book/box/box_introspection.rst:116
msgid ""
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 4194304\n"
"...\n"
"tarantool> box.slab.info().arena_size\n"
"---\n"
"- 104857600\n"
"...\n"
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16248\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15736\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"    <...>\n"
"...\n"
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 15736\n"
"  mem_used: 560\n"
"  item_count: 14\n"
"  item_size: 40\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:156
msgid "Submodule `box.stat`"
msgstr ""

#: ../book/box/box_introspection.rst:158
msgid "The ``box.stat`` submodule provides access to request and network statistics. Show the average number of requests per second, and the total number of requests since startup, broken down by request type and network events statistics."
msgstr ""

#: ../book/box/box_introspection.rst:162
msgid ""
"tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: []\n"
"- []\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVENTS:\n"
"    total: 2\n"
"    rps: 0\n"
"  LOCKS:\n"
"    total: 6\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../book/administration.rst:572
msgid "Replication"
msgstr "Репликация"

#: ../book/replication.rst:3
msgid "Replication allows multiple Tarantool servers to work on copies of the same databases. The databases are kept in synch because each server can communicate its changes to all the other servers. Servers which share the same databases are a \"cluster\". Each server in a cluster also has a numeric identifier which is unique within the cluster, known as the \"server id\"."
msgstr "Механизм репликации позволяет сразу многим Tarantool-серверам работать с копиями одних и тех же баз данных. При этом все базы остаются в синхронизированном состоянии благодаря тому, что каждый сервер может сообщать другим серверам о совершенных им изменениях. Сервера, которые работают над одними и теми же базами, представляют собой \"кластер\". У каждого сервера в кластере есть числовой идентификатор (server id), уникальный в рамках кластера."

#: ../book/replication.rst:9
msgid "To set up replication, it's necessary to set up the master servers which make the original data-change requests, set up the replica servers which copy data-change requests from masters, and establish procedures for recovery from a degraded state."
msgstr "Чтобы настроить репликацию, необходимо настроить главные сервера (master), которые первыми обрабатывают запросы на изменение данных, затем настроить сервера-реплики (replica), которые копируют к себе запросы на изменение данных с главных серверов, и прописать процедуры для восстановления после сбоя."

#: ../book/replication.rst:16
msgid "Replication architecture"
msgstr "Архитектура механизма репликации"

#: ../book/replication.rst:18
msgid "A replica gets all updates from the master by continuously fetching and applying its write-ahead log (WAL). Each record in the WAL represents a single Tarantool data-change request such as INSERT or UPDATE or DELETE, and is assigned a monotonically growing log sequence number (LSN). In essence, Tarantool replication is row-based: each data change command is fully deterministic and operates on a single tuple."
msgstr "Чтобы знать о всех изменениях на стороне главного сервера, каждая реплика непрерывно опрашивает главный сервер на предмет обновлений в его WAL-файле (write ahead log) и применяет эти обновления на своей стороне. Каждая запись в WAL-файле представляет собой один запрос на изменение данных (например, INSERT, UPDATE или DELETE) и присвоенный данной записи номер (LSN = log sequence number). Номера присваиваются в порядке возрастания. По сути, репликация в Tarantool'е является построчной: все команды на изменение данных полностью детерминированы, и каждая такая команда относится только к одному кортежу."

#: ../book/replication.rst:25
msgid "A stored program invocation is not written to the write-ahead log. Instead, log events for actual data-change requests, performed by the Lua code, are written to the log. This ensures that possible non-determinism of Lua does not cause replication to go out of sync."
msgstr "Вызовы хранимых Lua-процедур фиксируются не в WAL-файле, а в журнале событий (event log). Таким образом гарантируется, что не детерминированное поведение логики на Lua не приведет к рассинхронизации реплицированных данных."

#: ../book/replication.rst:32
#, fuzzy
msgid "Setting up a master"
msgstr "Настройка главного сервера"

#: ../book/replication.rst:34
msgid "To prepare the master for connections from the replica, it's only necessary to include \":ref:`listen <cfg_basic-listen>`\" in the initial ``box.cfg`` request, for example ``box.cfg{listen=3301}``. A master with enabled \"listen\" URI can accept connections from as many replicas as necessary on that URI. Each replica has its own :ref:`replication state <index-monitoring_replica_actions>`."
msgstr "Чтобы настроить возможность установки соединения для реплик, на стороне главного сервера требуется лишь указать значение для параметра \":ref:`listen <cfg_basic-listen>`\" в init-запросе ``box.cfg``. Например, ``box.cfg{listen=3301}``. Когда URI для прослушивания задан, главный сервер готов принимать запросы на соединение от любого количества реплик. Каждая реплика при этом находится в некотором :ref:`статусе репликации <index-monitoring_replica_actions>`."

#: ../book/replication.rst:42
msgid "Setting up a replica"
msgstr "Настройка сервера-реплики"

#: ../book/replication.rst:44
msgid "A server requires a valid snapshot (.snap) file. A snapshot file is created for a server the first time that ``box.cfg`` occurs for it. If this first ``box.cfg`` request occurs without a \"replication source\" clause, then the server is a master and starts its own new cluster with a new unique UUID. If this first ``box.cfg`` request occurs with a \"replication source\" clause, then the server is a replica and its snapshot file, along with the cluster information, is constructed from the write-ahead logs of the master. Therefore, to start replication, specify :ref:`replication_source <cfg_replication-replication_source>` in a ``box.cfg`` request. When a replica contacts a master for the first time, it becomes part of a cluster. On subsequent occasions, it should always contact a master in the same cluster."
msgstr "Каждому Tarantool-серверу необходим корректный файл со статическим снимком данных (.snap-файл). Файл-снимок создается на сервере при первом запросе ``box.cfg``. Если при первом таком запросе на сервере не определен источник репликации (replication source), то сервер стартует в режиме главного сервера и создает для себя новый кластер с новым уникальными UUID. Если же источник репликации при первом ``box.cfg``-запросе определен, то сервер стартует в режиме реплики, а файл-снимок и информация о кластере берутся из WAL-файлов на главном сервере. Поэтому при настройке репликации нужно указать параметр :ref:`replication_source <cfg_replication-replication_source>` в запросе ``box.cfg``. При первом соединении с главным сервером сервер-реплика включается в состав кластера. В дальнейшем такая реплика общается только с главным сервером из данного кластера."

#: ../book/replication.rst:56
msgid "Once connected to the master, the replica requests all changes that happened after the latest local LSN. It is therefore necessary to keep WAL files on the master host as long as there are replicas that haven't applied them yet. A replica can be \"re-seeded\" by deleting all its files (the snapshot .snap file and the WAL .xlog files), then starting replication again - the replica will then catch up with the master by retrieving all the master's tuples. Again, this procedure works only if the master's WAL files are present."
msgstr "После установки соединения с главным сервером реплика запрашивает у него все изменения, чьи LSN-номера в WAL-файле больше номера последнего локального изменения на реплике. Поэтому WAL-файлы на главном сервере нужно хранить до тех пор, пока все реплики не применят изменения из этих WAL-файлов на своей стороне. Состояние реплики можно \"обнулить\", удалив все файлы репликации (.snap-файл со снимком и .xlog-файлы с записями WAL) и запустив сервер снова. Реплика при этом возьмет все кортежи с главного сервера и придет в синхронизированное состояние. Обратите внимание, что такая процедура \"обнуления\" сработает, только если на главном сервере будут доступны все нужные WAL-файлы."

#: ../book/replication.rst:66
msgid "Replication parameters are \"dynamic\", which allows the replica to become a master and vice versa with the help of the :ref:`box.cfg <box_introspection-box_cfg>` statement."
msgstr "Параметры репликации можно менять на лету, что позволяет назначать реплику на роль главного сервера и наоборот. Для этого используется запрос :ref:`box.cfg <box_introspection-box_cfg>`."

#: ../book/replication.rst:72
msgid "The replica does not inherit the master's configuration parameters, such as the ones that cause the :ref:`snapshot daemon <book_cfg_snapshot_daemon>` to run on the master. To get the same behavior, one would have to set the relevant parameters explicitly so that they are the same on both master and replica."
msgstr "Реплика не берет настройки конфигурации с главного сервера, например настройки запуска :ref:`фоновой программы для работы со снимками <book_cfg_snapshot_daemon>` на главном сервере. Чтобы получить те же настройки на реплике, нужно задать их явным образом."

#: ../book/replication.rst:80
msgid "Replication requires privileges. Privileges for accessing spaces could be granted directly to the user who will start the replica. However, it is more usual to grant privileges for accessing spaces to a :ref:`role <authentication-rep_role>`, and then grant the role to the user who will start the replica."
msgstr "Репликация требует настройки привилегий. Привилегии для доступа к пространствам можно задать напрямую для пользователя, под чьим именем запущен сервер-реплика. Но обычно привилегии на доступ к пространствам задаются с помощью :ref:`роли <authentication-rep_role>`, которая затем присваивается пользователю, под чьим именем запущен сервер-реплика."

#: ../book/replication.rst:88
msgid "Recovering from a degraded state"
msgstr "Восстановление после сбоя"

#: ../book/replication.rst:90
msgid "\"Degraded state\" is a situation when the master becomes unavailable - due to hardware or network failure, or due to a programming bug. There is no automatic way for a replica to detect that the master is gone forever, since sources of failure and replication environments vary significantly. So the detection of degraded state requires a human inspection."
msgstr "\"Сбой\" — это ситуация, когда главный сервер становится недоступен вследствие проблем с оборудованием, сетевых неполадок или программной ошибки. У реплики нет способа автоматически обнаружить, что связь с главным сервером утеряна насовсем, поскольку причины сбоя и окружение, в котором развернута репликация, могут быть очень разными. Поэтому обнаруживать сбой должен человек."

#: ../book/replication.rst:96
msgid "However, once a master failure is detected, the recovery is simple: declare that the replica is now the new master, by saying :codenormal:`box.cfg{... listen=`:codeitalic:`URI <index-uri>`:codenormal:`}`. Then, if there are updates on the old master that were not propagated before the old master went down, they would have to be re-applied manually."
msgstr "Но когда сбой уже обнаружен, процедура восстановления проста. Сначала нужно назначить одну из реплик на роль нового главного сервера, задав параметр :codenormal:`box.cfg{... listen=`:codeitalic:`URI <index-uri>`:codenormal:`}`. Затем, если на прежнем главном сервере остались изменения, которые не успели примениться на выбранной реплике перед сбоем, нужно применить эти изменения вручную."

#: ../book/replication.rst:104
#, fuzzy
msgid "Quick startup of a new simple two-server cluster"
msgstr "Инструкции по быстрому запуску простого кластера из двух серверов с нуля"

#: ../book/replication.rst:106
msgid "Step 1. Start the first server thus:"
msgstr "Шаг 1. Запустите первый сервер со следующими настройками:"

#: ../book/replication.rst:985
msgid ""
"box.cfg{listen = *uri#1*}\n"
"-- replace with more restrictive request\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"box.snapshot()"
msgstr ""
"box.cfg{listen = *uri#1*}\n"
"-- в этом запросе можно задать больше ограничений\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"box.snapshot()"

#: ../book/replication.rst:116
msgid "... Now a new cluster exists."
msgstr "... Итак, создался новый кластер."

#: ../book/replication.rst:118
msgid "Step 2. Check where the second server's files will go by looking at its directories (:ref:`snap_dir <cfg_basic-snap_dir>` for snapshot files, :ref:`wal_dir <cfg_basic-wal_dir>` for .xlog files). They must be empty - when the second server joins for the first time, it has to be working with a clean state so that the initial copy of the first server's databases can happen without conflicts."
msgstr "Шаг 2. На втором сервере проверьте пути, по которым будут храниться файлы репликации. Эти пути задаются в параметрах :ref:`snap_dir <cfg_basic-snap_dir>` (для .snap-файлов) и :ref:`wal_dir <cfg_basic-wal_dir>` (для .xlog-файлов). В указанных директориях должно быть пусто, чтобы не случилось конфликта с теми начальными данными, что придут с первого сервера, когда второй сервер присоединится к кластеру."

#: ../book/replication.rst:124
msgid "Step 3. Start the second server thus:"
msgstr "Step 3. Запустите второй сервер со следующими настройками:"

#: ../book/replication.rst:1003
msgid ""
"box.cfg{\n"
"  listen = *uri#2*,\n"
"  replication_source = *uri#1*\n"
"}"
msgstr ""
"box.cfg{\n"
"  listen = *uri#2*,\n"
"  replication_source = *uri#1*\n"
"}"

#: ../book/replication.rst:134
msgid "... where ``uri#1`` = the :ref:`URI <index-uri>` that the first server is listening on."
msgstr "... где ``uri#1`` = :ref:`URI <index-uri>`, на котором включено прослушивание у первого сервера."

#: ../book/replication.rst:136
msgid "That's all."
msgstr "Вот и всё."

#: ../book/replication.rst:138
msgid "In this configuration, the first server is the \"master\" and the second server is the \"replica\". Henceforth every change that happens on the master will be visible on the replica. A simple two-server cluster with the master on one computer and the replica on a different computer is very common and provides two benefits: FAILOVER (because if the master goes down then the replica can take over), or LOAD BALANCING (because clients can connect to either the master or the replica for select requests). Sometimes the replica may be configured with the additional parameter :ref:`read_only = true <cfg_basic-read_only>`."
msgstr "В описанной выше конфигурации первый сервер выполняет роль \"главного\", а второй служит \"репликой\". Далее все изменения, происходящие на стороне главного сервера, будут доступны с реплики. Простой кластер из двух серверов, где главный сервер запущен на одном компьютере, а сервер-реплика — на другом, встречается очень часто и обладает двумя важными преимуществами: FAILOVER (т.е. отказоустойчивость, поскольку в случае отключения главного сервера его место может занять сервер-реплика) и LOAD BALANCING (т.е. балансировка нагрузки, поскольку клиенты могут обращаться с SELECT-запросами как к главному серверу, так и к реплике). При необходимости в настройках реплики можно задать параметр :ref:`read_only = true <cfg_basic-read_only>`."

#: ../book/replication.rst:151
msgid "Monitoring a replica's actions"
msgstr "Мониторинг действий реплики"

#: ../book/replication.rst:153
msgid "In :ref:`box.info <box_introspection-box_info>` there is a ``box.info.replication.status`` field: \"off\", \"stopped\", \"connecting\", \"auth\", \"follow\", or \"disconnected\". |br| If a replica's status is \"follow\", then there will be two more fields: |br| ``box.info.replication.idle`` = the number of seconds the replica has been idle, |br| ``box.info.replication.lag`` = the number of seconds the replica is behind the master."
msgstr "В пакете :ref:`box.info <box_introspection-box_info>` есть поле :code:`box.info.replication.status`, которое отражает статус репликации для данной реплики: \"off\", \"stopped\", \"connecting\", \"auth\", \"follow\" или \"disconnected\". |br| Если реплика имеет статус \"follow\", то можно получить уточняющую информацию из еще двух полей: |br| :code:`box.info.replication.idle` = время (в секундах), которое реплика провела в состоянии бездействия, |br| :code:`box.info.replication.lag` = время (в секундах), на которое реплика отстает от главного сервера."

#: ../book/replication.rst:159
msgid "In the :ref:`log <log>` there is a record of replication activity. If a primary server is started with:"
msgstr "В :ref:`журнале <log>` ведется запись о действиях, связанных с репликацией. Если главный сервер запущен со следующими настройками:"

#: ../book/replication.rst:1039
msgid ""
"box.cfg{\n"
"  <...>,\n"
"  logger = *log file name*,\n"
"  <...>\n"
"}"
msgstr ""
"box.cfg{\n"
"  <...>,\n"
"  logger = *имя_файла_для_ведения_журнала*,\n"
"  <...>\n"
"}"

#: ../book/replication.rst:171
msgid "then there will be lines in the log file, containing the word \"relay\", when a replica connects or disconnects."
msgstr "то на каждую установку/потерю соединения реплики с главным сервером в журнале будут появляться строчки со словом \"relay\"."

#: ../book/replication.rst:178
msgid "Preventing duplicate actions"
msgstr "Предотвращение дублирующихся действий"

#: ../book/replication.rst:180
msgid "Suppose that the replica tries to do something that the master has already done. For example: |br| ``box.schema.space.create('X')`` |br| This would cause an error, \"Space X exists\". For this particular situation, the code could be changed to: |br| ``box.schema.space.create('X', {if_not_exists=true})`` |br| But there is a more general solution: the :samp:`box.once({key}, {function})` method. If ``box.once()`` has been called before with the same :samp:`{key}` value, then :samp:`{function}` is ignored; otherwise :samp:`{function}` is executed. Therefore, actions which should only occur once during the life of a replicated session should be placed in a function which is executed via ``box.once()``. For example:"
msgstr "Предположим, что реплика пытается сделать нечто, что уже было сделано на главном сервере. Например: |br| :code:`box.schema.space.create('X')` |br| Это приведет к ошибке \"Space X exists\" (\"Пространство X уже существует\"). В данном частном случае можно скорректировать инструкцию следующим образом: |br| :code:`box.schema.space.create('X', {if_not_exists=true})` |br| Но существует и более общее решение: использовать метод :samp:`box.once({key}, {function})`. Если :code:`box.once()` был вызван ранее с тем же значением параметра :samp:`{key}`, то функция :samp:`{function}` игнорируется; в противном случае функция :samp:`{function}` будет выполнена. Поэтому действия, которые должны совершаться только один раз за время текущей сессии репликации, нужно помещать в функцию и вызывать ее с помощью метода :code:`box.once()`. Например:"

#: ../book/replication.rst:195
msgid ""
"function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"
msgstr ""
"function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"

#: ../book/replication.rst:204
msgid "Master-master replication"
msgstr "Репликация по схеме master-master"

#: ../book/replication.rst:206
msgid "In the simple master-replica configuration, the master's changes are seen by the replica, but not vice versa, because the master was specified as the sole replication source. In the master-master configuration, also sometimes called multi-master configuration, it's possible to go both ways. Starting with the simple configuration, the first server has to say:"
msgstr "В случае настройки репликации по схеме master-replica изменения на главном сервере доступны для просмотра с реплики, но не наоборот, потому как главный сервер в такой схеме указан в качестве единственного источника репликации. В случае схемы master-master (иногда ее также называет multi-master) просмотр изменений возможен в любом направлении. В простом случае (master-master с двумя серверами) на первом сервере нужно задать следующие настройки:"

#: ../book/replication.rst:1090
msgid "box.cfg{ replication_source = *uri#2* }"
msgstr "box.cfg{ replication_source = *uri#2* }"

#: ../book/replication.rst:218
msgid "This request can be performed at any time -- :ref:`replication_source <cfg_replication-replication_source>` is a dynamic parameter."
msgstr "Этот запрос можно выполнить в любой момент, т.к. параметр :ref:`replication_source <cfg_replication-replication_source>` можно задавать на ходу."

#: ../book/replication.rst:221
msgid "In this configuration, both servers are \"masters\" and both servers are \"replicas\". Henceforth every change that happens on either server will be visible on the other. The failover benefit is still present, and the load-balancing benefit is enhanced (because clients can connect to either server for data-change requests as well as select requests)."
msgstr "В данном примере оба сервера являются одновременно и \"главными\", и \"репликами\". Поэтому каждое изменение, которое случается на одном сервере, становится доступно для просмотра с другого сервера. Отказоустойчивость в такой конфигурации сохраняется, а возможности по балансировке нагрузки становятся еще шире (теперь клиенты могут обращаться к обоим серверам со всеми типами запросов — как на чтение данных, так и на изменение)."

#: ../book/replication.rst:227
msgid "If two operations for the same tuple take place \"concurrently\" (which can involve a long interval because replication is asynchronous), and one of the operations is ``delete`` or ``replace``, there is a possibility that servers will end up with different contents."
msgstr "Если две операции над одним и тем же кортежем производятся \"параллельно\" (а это может потребовать много времени, поскольку репликация — это асинхронный процесс), причем одна из операций — это ``delete``, а вторая — ``replace``, то существует вероятность, что данные на серверах станут различаться."

#: ../book/replication.rst:234
msgid "All the \"What If?\" questions"
msgstr "Ответы на вопросы \"Что если?\""

#: ../book/replication.rst:236
msgid "Q: What if there are more than two servers with master-master? |br| A: On each server, specify the :ref:`replication_source <cfg_replication-replication_source>` for all the others. For example, server #3 would have a request: |br| :codenormal:`box.cfg{` |br| |nbsp| |nbsp| |nbsp| :codenormal:`replication_source = {`:codeitalic:`uri#1, uri#2`:codenormal:`}` |br| :codenormal:`}`"
msgstr "Вопрос: Что если в кластере вида master-master более двух серверов? |br| Ответ: На каждом сервере нужно задать параметр :ref:`replication_source <cfg_replication-replication_source>` и указать в нем все остальные сервера. Например, для сервера #3 настройки будут следующими: |br| :codenormal:`box.cfg{` |br| |nbsp| |nbsp| |nbsp| :codenormal:`replication_source = {`:codeitalic:`uri#1, uri#2`:codenormal:`}` |br| :codenormal:`}`"

#: ../book/replication.rst:243
msgid "Q: What if a server should be taken out of the cluster? |br| A: For a replica, run ``box.cfg{}`` again specifying a blank replication source: |br| ``box.cfg{replication_source=''}``"
msgstr "Вопрос: Что если какой-то сервер нужно убрать из кластера? |br| Ответ: Для реплики — выполните запрос ``box.cfg{}``, указав пустой источник репликации: |br| ``box.cfg{replication_source=''}``"

#: ../book/replication.rst:247
msgid "Q: What if a server leaves the cluster? |br| A: The other servers carry on. If the wayward server rejoins, it will receive all the updates that the other servers made while it was away."
msgstr "Вопрос: Что если какой-то сервер вдруг выбывает из кластера? |br| Ответ: Остальные сервера продолжают работать. Если выбывший сервер снова возвращается в кластер, то он получит информацию о всех изменениях, которые произошли на остальных серверах за время его отсутствия."

#: ../book/replication.rst:251
msgid "Q: What if two servers both change the same tuple? |br| A: The last changer wins. For example, suppose that server#1 changes the tuple, then server#2 changes the tuple. In that case server#2's change overrides whatever server#1 did. In order to keep track of who came last, Tarantool implements a `vector clock <https://en.wikipedia.org/wiki/Vector_clock>`_."
msgstr "Вопрос: Что если два сервера совершают изменения, связанные с одним и тем же кортежем? |br| Ответ: Применятся последние из совершенных изменений. Для примера предположим, что сервер #1 меняет некоторый кортеж, а затем сервер #2 меняет тот же кортеж. В данном случае изменения сервера #2 затрут изменения сервера #1. Чтобы отслеживать, кто был последним, в Tarantool'е используются `векторные часы <https://en.wikipedia.org/wiki/Vector_clock>`_."

#: ../book/replication.rst:257
msgid "Q: What if two servers both insert the same tuple? |br| A: If a master tries to insert a tuple which a replica has inserted already, this is an example of a severe error. Replication stops. It will have to be restarted manually."
msgstr "Вопрос: Что если оба сервера выполняют вставку одного и того же кортежа? |br| Ответ: Если главный сервер попытается вставить кортеж, который уже был вставлен на реплике, то это будет пример серьезной ошибки. Репликация остановится, и ее придется перезапускать в ручную."

#: ../book/replication.rst:262
msgid "Q: What if a master disappears and the replica must take over? |br| A: A message will appear on the replica stating that the connection is lost. The replica must now become independent, which can be done by saying ``box.cfg{replication_source=''}``."
msgstr "Вопрос: Что если главный сервер становится недоступен и пользователям приходится переключаться реплику? |br| Ответ: Реплика получает сообщение, что связь потеряна. Теперь реплика должна начать работать независимо. Для этого ей нужно задать пустой источник репликации, выполнив на стороне реплики запрос ``box.cfg{replication_source=''}``."

#: ../book/replication.rst:267
msgid "Q: What if it's necessary to know what cluster a server is in? |br| A: The identification of the cluster is a UUID which is generated when the first master starts for the first time. This UUID is stored in a tuple of the :ref:`box.space._schema <box_space-schema>` system space. So to see it, say: ``box.space._schema:select{'cluster'}``"
msgstr "Вопрос: Что если нужно посмотреть, к какому кластеру принадлежит данный сервер? |br| Ответ: Идентификатором кластера является UUID, который генерируется при первом запуске главного сервера. Данный UUID хранится в системном пространстве :ref:`box.space._schema <box_space-schema>`. Чтобы посмотреть UUID кластера, введите запрос ``box.space._schema:select{'cluster'}``"

#: ../book/replication.rst:273
msgid "Q: What if it's necessary to know what other servers belong in the cluster? |br| A: The universal identification of a server is a UUID in ``box.info.server.uuid``. The ordinal identification of a server within a cluster is a number in ``box.info.server.id``. To see all the servers in the cluster, say: ``box.space._cluster:select{}``. This will return a table with all {server.id, server.uuid} tuples for every server that has ever joined the cluster."
msgstr "Вопрос: Что если нужно посмотреть, какие сервера входят в кластер? |br| Ответ: У каждого сервера есть универсальный идентификатор — это его UUID в поле ``box.info.server.uuid``. Также у сервера есть его порядковый идентификатор в кластере — это номер в поле ``box.info.server.id``. Чтобы увидеть номера всех серверов в кластере, введите запрос: ``box.space._cluster:select{}``. Данный запрос возвращает таблицу со всеми кортежами вида {server.id, server.uuid} для всех серверов, что когда-либо входили в данный кластер."

#: ../book/replication.rst:281
msgid "Q: What if one of the server's files is corrupted or deleted? |br| A: Stop the server, destroy all the database files (the ones with extension \"snap\" or \"xlog\" or \".inprogress\"), restart the server, and catch up with the master by contacting it again (just say ``box.cfg{...replication_source=...}``)."
msgstr "Вопрос: Что если какой-то из файлов репликации на реплике поврежден или удален? |br| Ответ: Нужно остановить сервер, удалить все файлы, относящиеся к базе данных (это файлы с расширениями \"snap\", \"xlog\" и \".inprogress\"), снова запустить сервер и ввести запрос ``box.cfg{...replication_source=...}``, чтобы восстановить соединение с главным сервером и загрузить данные с него."

#: ../book/replication.rst:287
msgid "Q: What if replication causes security concerns? |br| A: Prevent unauthorized replication sources by associating a password with every user that has access privileges for the relevant spaces, and every user that has a replication :ref:`role <authentication-rep_role>`. That way, the :ref:`URI <index-uri>` for the :ref:`replication_source <cfg_replication-replication_source>` parameter will always have to have the long form |br| ``replication_source='username:password@host:port'``"
msgstr "Вопрос: Что если при репликации возникают вопросы, связанные с безопасностью? |br| Ответ: Чтобы предотвратить появление несанкционированных источников репликации, нужно задать пароль для каждого пользователя, у которого есть привилегии доступа к соответствующим пространствам, а также для каждого пользователя, у которого настроена :ref:`репликационная роль <authentication-rep_role>`. Заметьте, что :ref:`URI <index-uri>` для параметра :ref:`replication_source <cfg_replication-replication_source>` теперь нужно всегда указывать в полном виде: |br| ``replication_source='username:password@host:port'``"

#: ../book/replication.rst:295
msgid "Q: What if advanced users want to understand better how it all works? |br| A: See the description of server startup with replication in the :ref:`Internals <b_internals-replication>` appendix."
msgstr "Вопрос: Что если продвинутые пользователи хотят глубже разобраться с тем, как работает репликация? |br| Ответ: См. информацию о запуске сервера с репликацией в Приложении B. :ref:`Детали реализации <b_internals-replication>`."

#: ../book/replication.rst:301
msgid "Hands-on replication tutorial"
msgstr "Практическое руководство по репликации"

#: ../book/replication.rst:303
msgid "After following the steps here, an administrator will have experience creating a cluster and adding a replica."
msgstr "Ниже приводятся пошаговые инструкции, которые помогут вам получить практический опыт администрирования кластера, а именно опыт создания кластера и добавления реплики."

#: ../book/replication.rst:306
msgid "Start two shells. Put them side by side on the screen. (This manual has a tabbed display showing \"Terminal #1\". Click the \"Terminal #2\" tab to switch to the display of the other shell.)"
msgstr "Запустите два терминала, каждый в своем окне, и расположите их рядом на экране. (Далее в примерах оба терминала показаны в виде закладок. Щелкните на заголовок закладки — \"Terminal #1\" или \"Terminal #2\", — чтобы увидеть вывод на соответствующем терминале.)"

#: ../book/replication.rst:332 ../book/replication.rst:339
#: ../book/replication/1_2.rst:1
msgid "$"
msgstr "$"

#: ../book/replication.rst:343
msgid "On the first shell, which we'll call Terminal #1, execute these commands:"
msgstr "В первом терминале (Terminal #1) выполните следующие команды:"

#: ../book/replication.rst:345
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_1/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_1/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#: ../book/replication.rst:357
msgid "The result is that a new cluster is set up, and the server's UUID is displayed. Now the screen looks like this: (except that UUID values are always different):"
msgstr "В результате были заданы настройки нового кластера, а на экране был выведен UUID текущего сервера. Теперь вывод на экране выглядит следующим образом (за тем исключением, что UUID у вас будут другие):"

#: ../book/replication/1_1.rst:1
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."

#: ../book/replication.rst:389
msgid "On the second shell, which we'll call Terminal #2, execute these commands:"
msgstr "Во втором терминале (Terminal #2) выполните следующие команды:"

#: ../book/replication.rst:391
msgid ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ~/tarantool_test_node_2/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ~/tarantool_test_node_2/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#: ../book/replication.rst:404
msgid "The result is that a replica is set up. Messages appear on Terminal #1 confirming that the replica has connected and that the WAL contents have been shipped to the replica. Messages appear on Terminal #2 showing that replication is starting. Also on Terminal#2 the _cluster UUID values are displayed, and one of them is the same as the _cluster UUID value that was displayed on Terminal #1, because both servers are in the same cluster."
msgstr "В результате были заданы настройки сервера-реплики. На экране первого терминала (Terminal #1) появились сообщения с подтверждениями, что реплика установила соединение с главным сервером и что содержимое WAL-файла было отправлено на реплику. На экране второго терминала (Terminal #2) появились сообщения о том, что репликация начинается, а также там были выведены UUID из системного пространства _cluster (один из них совпадает с UUID в первом терминале, поскольку оба сервера входят в общий кластер)."

#: ../book/replication/2_1.rst:1
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from `./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from `./00000000000000000000.xlog'"
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from `./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from `./00000000000000000000.xlog'"

#: ../book/replication/2_2.rst:1 ../book/replication/3_2.rst:1
msgid ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple arena...\n"
"<...> [11243] main/101/interactive C> starting replication from localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."
msgstr ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple arena...\n"
"<...> [11243] main/101/interactive C> starting replication from localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."

#: ../book/replication.rst:440
msgid "On Terminal #1, execute these requests:"
msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#: ../book/replication.rst:442
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> i = s:create_index('primary', {})\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> i = s:create_index('primary', {})\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"

#: ../book/replication.rst:448 ../book/replication.rst:615
msgid "Now the screen looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../book/replication/3_1.rst:1 ../book/replication/4_1.rst:1
msgid ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from `./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from `./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from `./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from `./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../book/replication.rst:479
msgid "The creation and insertion were successful on Terminal #1. Nothing has happened on Terminal #2."
msgstr "В первом терминале успешно отработали операции CREATE и INSERT. Но во втором терминале ничего не произошло."

#: ../book/replication.rst:482
msgid "On Terminal #2, execute these requests:"
msgstr "Во втором терминале (Terminal #2) выполните следующие запросы:"

#: ../book/replication.rst:484
msgid ""
"tarantool> s = box.space.tester\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"
msgstr ""
"tarantool> s = box.space.tester\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"

#: ../book/replication.rst:490
msgid "Now the screen looks like this (remember to click on the \"Terminal #2\" tab when looking at Terminal #2 results):"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../book/replication/4_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."

#: ../book/replication.rst:521
msgid "The selection and insertion were successful on Terminal #2. Nothing has happened on Terminal #1."
msgstr "Во втором терминале успешно отработали операции SELECT и INSERT. Но в первом терминале ничего не произошло."

#: ../book/replication.rst:524
msgid "On Terminal #1, execute these Tarantool requests and shell commands:"
msgstr "В первом терминале (Terminal #1) выполните следующие запросы и команды:"

#: ../book/replication.rst:526
msgid ""
"$ os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"$ ls -l ~/tarantool_test_node_2"
msgstr ""
"$ os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"$ ls -l ~/tarantool_test_node_2"

#: ../book/replication.rst:532
msgid "Now Tarantool #1 is stopped. Messages appear on Terminal #2 announcing that fact. The ``ls -l`` commands show that both servers have made snapshots, which have similar sizes because they both contain the same tuples."
msgstr "Теперь Tarantool-сервер в первом терминале остановлен. В окне второго терминала появились сообщения об этом событии. С помощью команд ``ls -l`` мы убедились, что на обоих серверах создались файлы-снимки с одинаковыми размерами, поскольку там содержатся одни и те же кортежи."

#: ../book/replication/5_1.rst:1 ../book/replication/6_1.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"

#: ../book/replication/5_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"
msgstr ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"

#: ../book/replication.rst:565
msgid "On Terminal #2, ignore the error messages, and execute these requests:"
msgstr "Во втором терминале (Terminal #2) проигнорируйте сообщения об ошибках и выполните следующие запросы:"

#: ../book/replication.rst:568
msgid ""
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"tarantool> box.space.tester:insert{3, 'Another'}"
msgstr ""
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"tarantool> box.space.tester:insert{3, 'Another'}"

#: ../book/replication.rst:573
msgid "Now the screen looks like this (ignoring the error messages):"
msgstr "Теперь вывод на экране выглядит следующим образом (сообщения об ошибках мы не приводим):"

#: ../book/replication/6_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."

#: ../book/replication.rst:605
msgid "Terminal #2 has done a select and an insert, even though Terminal #1 is down."
msgstr "Запросы SELECT и INSERT во втором терминале отработали несмотря на то, что сервер в первом терминале остановлен."

#: ../book/replication.rst:607
msgid "On Terminal #1 execute these commands:"
msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#: ../book/replication.rst:609
msgid ""
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../book/replication/7_1.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../book/replication/7_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"

#: ../book/replication.rst:646
msgid "The master has reconnected to the cluster, and has NOT found what the replica wrote while the master was away. That is not a surprise -- the replica has not been asked to act as a replication source."
msgstr "Главный сервер снова установил соединение с кластером и НЕ обнаружил изменения, сделанные репликой за время его недоступности. Это и не удивительно: мы же не просили реплику выступать в качестве источника репликации."

#: ../book/replication.rst:650
msgid "On Terminal #1, say:"
msgstr "В первом терминале (Terminal #1) введите:"

#: ../book/replication.rst:652
msgid ""
"tarantool> box.cfg{\n"
"         >   replication_source = 'replicator:password@localhost:3302'\n"
"         > }\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"tarantool> box.cfg{\n"
"         >   replication_source = 'replicator:password@localhost:3302'\n"
"         > }\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../book/replication.rst:659
msgid "The screen now looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../book/replication/8_1.rst:1
msgid ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication_source='replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication_source' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at 127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
"[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from `./00000000000000000008.xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication_source='replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication_source' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at 127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
"[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from `./00000000000000000008.xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."

#: ../book/replication/8_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from `./00000000000000000000.xlog'"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from `./00000000000000000000.xlog'"

#: ../book/replication.rst:704
msgid "This shows that the two servers are once again in synch, and that each server sees what the other server wrote."
msgstr "Тут мы видим, что оба сервера снова синхронизовались и что каждый из них видит те записи, которые сделал другой."

#: ../book/replication.rst:707
msgid "To clean up, say \"``os.exit()``\" on both Terminal #1 and Terminal #2, and then on either terminal say:"
msgstr "Чтобы удалить все тестовые данные, выполните \"``os.exit()``\" на обоих терминалах, а затем на каждом из них выполните следующие команды:"

#: ../book/replication.rst:710
msgid ""
"$ cd ~\n"
"$ rm -R ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_2"
msgstr ""
"$ cd ~\n"
"$ rm -R ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_2"

#: ../book/administration.rst:578
msgid "Backups"
msgstr "Резервное копирование"

#: ../book/administration.rst:580
msgid "The exact procedure for backing up a database depends on: how up-to-date the database must be, how frequently backups must be taken, whether it is okay to disrupt other users, and whether the procedure should be optimized for size (saving disk space) or for speed (saving time). So there is a spectrum of possible policies, ranging from cold-and-simple to hot-and-difficult."
msgstr "При выборе конкретной процедуры для резервного копирования базы данных нужно учитывать следующие требования: насколько актуальной должна быть копия, можно ли временно отключать других пользователей, а также нужна ли оптимизация размера копии (чтобы копия занимала меньше места на диске) или скорости самой процедуры (чтобы процедура занимала меньше времени). Выбирать можно из нескольких вариантов в диапазоне от \"простого и холодного\" до \"трудного и горячего\"."

#: ../book/administration.rst:591
#, fuzzy
msgid "Cold backup"
msgstr "**\"Холодное\" резервирование**"

#: ../book/administration.rst:593
msgid "In essence: The last snapshot file is a backup of the entire database; and the WAL files that are made after the last snapshot are incremental backups. Therefore taking a backup is a matter of copying the snapshot and WAL files."
msgstr "Суть процедуры: последний созданный Tarantool'ом файл-снимок является резервной копией всей базы; а WAL-файлы, созданные следом, являются инкрементными копиями. Поэтому вся процедура резервирования сводится к копированию последнего файла-снимка и последующих WAL-файлов."

#: ../book/administration.rst:598
msgid "Prevent all users from writing to the database. This can be done by shutting down the server, or by saying ``box.cfg{read_only=true}`` and then ensuring that all earlier writes are complete (:program:`fsync` can be used for this purpose)."
msgstr "Временно запретите всем пользователям делать записи в базе. Для этого можно остановить Tarantool-сервер, либо ввести запрос ``box.cfg{read_only=true}`` и убедиться, что все обращения на запись завершились (для этого можно использовать :program:`fsync`)."

#: ../book/administration.rst:602
msgid "If this is a backup of the whole database, say :samp:`box.snapshot()`."
msgstr "Если вы хотите создать резеврную копию для всей базы целиком, введите запрос :samp:`box.snapshot()`."

#: ../book/administration.rst:604
msgid "Use :program:`tar` to make a (possibly compressed) copy of the latest :file:`.snap` and :file:`.xlog` files on the :ref:`snap_dir <cfg_basic-snap_dir>` and :ref:`wal_dir <cfg_basic-wal_dir>` directories."
msgstr "С помощью :program:`tar` создайте сжатую (насколько это можно) копию последнего :file:`.snap`-файла и последующих :file:`.xlog`-файлов из директорий :ref:`snap_dir <cfg_basic-snap_dir>` и :ref:`wal_dir <cfg_basic-wal_dir>`."

#: ../book/administration.rst:608
msgid "If there is a security policy, encrypt the tar file."
msgstr "Если того требуют правила безопасности, зашифруйте получившийся :file:`tar`-файл."

#: ../book/administration.rst:609
msgid "Copy the tar file to a safe place."
msgstr "Скопируйте :file:`tar`-файл в надежное место."

#: ../book/administration.rst:611
msgid "... Later, restoring the database is a matter of taking the tar file and putting its contents back in the ``snap_dir`` and ``wal_dir`` directories."
msgstr "... В дальнейшем вы сможете восстановить базу данных, просто взяв этот :file:`tar`-файл и разархивировав его содержимое в директории ``snap_dir`` и ``wal_dir``."

#: ../book/administration.rst:617
#, fuzzy
msgid "Continuous remote backup"
msgstr "**Постоянное удаленное резервирование**"

#: ../book/administration.rst:619
msgid "In essence: :ref:`replication <index-box_replication>` is useful for backup as well as for load balancing. Therefore taking a backup is a matter of ensuring that any given replica is up to date, and doing a cold backup on it. Since all the other replicas continue to operate, this is not a cold backup from the end user's point of view. This could be done on a regular basis, with a cron job or with a Tarantool fiber."
msgstr "Суть процедуры: для резервирования (а также для балансирования нагрузки) можно использовать :ref:`репликацию <index-box_replication>`. Процедура резервирования в рамках репликационного кластера сводится к тому, чтобы держать все реплики в актуальном состоянии и периодически делать с них \"холодные\" копии. Поскольку во время снятия копии с какой-либо одной реплики все остальные реплики продолжают синхронизироваться с главным сервером, то эта процедура несколько отличается от описанной выше процедуры \"холодного\" резервирования. Регулярное резервирование в кластере можно настроить с помощью планировщика :program:`cron` или Tarantool-файбера."

#: ../book/administration.rst:629
#, fuzzy
msgid "Hot backup"
msgstr "**\"Горячее\" резервирование**"

#: ../book/administration.rst:631
msgid "In essence: The logged changes done since the last cold backup must be secured, while the system is running."
msgstr "Суть процедуры: по ходу работы системы нужно сохранять записи об изменениях, сделанных со времени последнего \"холодного\" резервирования."

#: ../book/administration.rst:635
msgid "For this purpose you need a \"file copy\" utility that will do the copying remotely and continuously, copying only the parts of a file that are changing. One such utility is `rsync <https://en.wikipedia.org/wiki/rsync>`_."
msgstr "Для этого вам понадобится специальная утилита для копирования частей файлов (например, `rsync <https://en.wikipedia.org/wiki/rsync>`_), которая позволит удаленно и на постоянной основе копировать только изменившиеся части файлов-снимков и WAL-файлов, а не все эти файлы целиком."

#: ../book/administration.rst:640
msgid "Alternatively, you need an ordinary file copy utility, but there should be frequent production of new snapshot files or new WAL files as changes occur, so that only the new files need to be copied."
msgstr "Вы можете взять и обычную утилиту (для копирования файлов целиком), но тогда вам придется создавать файлы-снимки и WAL-файлы на каждое изменение, чтобы нужно было копировать только новые файлы."

#: ../book/administration.rst:644
msgid "Note re storage engine: vinyl databases require additional steps."
msgstr "Примечание про движок: при организации резервирования для баз данных на движке vinyl понадобятся дополнительные действия."

#: ../book/administration.rst:648
msgid "Updates/upgrades"
msgstr "Обновление сервера и базы данных"

#: ../book/administration.rst:652
msgid "Updating Tarantool in production"
msgstr "Обновление Tarantool'а в условиях эксплуатации"

#: ../book/administration.rst:654
msgid "First, put your application's business logic in a Tarantool-Lua module that exports its functions for CALL."
msgstr "Во-первых, вынесите всю бизнес-логику своего приложения в отдельный Tarantool-модуль на языке Lua так, чтобы все нужные функции были доступны для вызова извне (CALL)."

#: ../book/administration.rst:657
msgid "For example, :file:`/usr/share/tarantool/myapp.lua`:"
msgstr "Вот пример такого модуля, файл :file:`/usr/share/tarantool/myapp.lua`:"

#: ../book/administration.rst:659
#, fuzzy
msgid ""
"local function start()\n"
"  -- Initial version\n"
"  box.once(\"myapp:.1.0\", function()\n"
"  box.schema.space.create(\"somedata\")\n"
"  box.space.somedata:create_index(\"primary\")\n"
"  ...\n"
"\n"
"  -- migration code from 1.0 to 1.1\n"
"  box.once(\"myapp:.v1.1\", function()\n"
"  box.space.somedata.index.primary:alter(...)\n"
"  ...\n"
"\n"
"  -- migration code from 1.1 to 1.2\n"
"  box.once(\"myapp:.v1.2\", function()\n"
"  box.space.somedata.space:alter(...)\n"
"  box.space.somedata:insert(...)\n"
"  ...\n"
"end\n"
"\n"
"-- start some background fibers if you need\n"
"\n"
"local function stop()\n"
"  -- stop all background fibers and cleanup resources\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"  -- do some business\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"  stop = stop;\n"
"  api_for_call = api_for_call;\n"
"}"
msgstr ""
"local function start()\n"
"-- Первоначальная версия\n"
"box.once(\"myapp:.1.0\", function()\n"
"box.schema.space.create(\"somedata\")\n"
"box.space.somedata:create_index(\"primary\")\n"
"...\n"
"end\n"
"\n"
"-- Код для миграции с 1.0 на 1.1\n"
"box.once(\"myapp:.v1.1\", function()\n"
"box.space.somedata.index.primary:alter(...)\n"
"...\n"
"end\n"
"\n"
"-- Код для миграции с 1.1 на 1.2\n"
"box.once(\"myapp:.v1.2\", function()\n"
"box.space.somedata.space:alter(...)\n"
"box.space.somedata:insert(...)\n"
"...\n"
"end\n"
"\n"
"-- Если нужно, запустить файберы в фоновом режиме\n"
"\n"
"local function stop()\n"
"-- Остановить все фоновые файберы и освободить ресурсы\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"-- Сделать что-то полезное\n"
"end\n"
"\n"
"return {\n"
"start = start;\n"
"stop = stop;\n"
"api_for_call = api_for_call;\n"
"}"

#: ../book/administration.rst:696
msgid "This file is maintained by the application's developers. On its side, Tarantool Team provides templates for you to `assemble deb/rpm packages <https://github.com/tarantool/modulekit>`_ and utilities to quickly `assemble packages for specific platforms <https://github.com/tarantool/build>`_. If needed, you can split applications into standalone files and/or modules."
msgstr "Поддержка этого файла лежит на стороне разработчиков приложения. А команда разработки Tarantool'а со своей стороны предлагает шаблоны, для того чтобы вы могли `создать у себя deb/rpm-сборку <https://github.com/tarantool/modulekit>`_, а также утилиты для быстрого `создания сборок под разные платформы <https://github.com/tarantool/build>`_. Если понадобится, вы можете разбить приложения на отдельные файлы и/или модули."

#: ../book/administration.rst:703
msgid "Second, put an initialization script to the :file:`/etc/tarantool/instances.available` directory."
msgstr "Во вторых, положите скрипт инициализации в директорию :file:`/etc/tarantool/instances.available`."

#: ../book/administration.rst:706
msgid "For example, :file:`/etc/tarantool/instances.available/myappcfg.lua`:"
msgstr "Вот пример такого скрипта, файл :file:`/etc/tarantool/instances.available/myappcfg.lua`:"

#: ../book/administration.rst:708
#, fuzzy
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"  listen = 3301;\n"
"}\n"
"\n"
"if myapp ~= nil then\n"
"  -- hot code reload using tarantoolctl or dofile()\n"
"\n"
"  -- unload old application\n"
"  myapp.stop()\n"
"  -- clear cache for loaded modules and dependencies\n"
"  package.loaded['myapp'] = nil\n"
"  package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
"end\n"
"\n"
"-- load a new version of app and all dependencies\n"
"myapp = require('myapp').start({some app options controlled by sysadmins})"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"listen = 3301;\n"
"}\n"
"\n"
"if myapp ~= nil then\n"
"-- \"Горячая\" загрузка кода с помощью tarantoolctl или dofile()\n"
"\n"
"-- Выгрузка старого приложения\n"
"myapp.stop()\n"
"-- Очистка кеша от загруженных модулей и зависимостей\n"
"package.loaded['myapp'] = nil\n"
"package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
"end\n"
"\n"
"-- Загрузка новой версии приложения и всех зависимостей\n"
"myapp = require('myapp').start({some app options controlled by sysadmins})"

#: ../book/administration.rst:730
msgid "As a more detailed example, you can take the :file:`example.lua` script that ships with Tarantool and defines all configuration options."
msgstr "Более детальный пример (со всеми настройками) содержится в файле :file:`example.lua`, который входит в состав дистрибутива Tarantool'а."

#: ../book/administration.rst:733
msgid "This initialization script is actually a configuration file and should be maintained by system administrators, while developers only provide a template."
msgstr "Этот скрипт инициализации по сути является конфигурационным файлом. Его поддержкой должны заниматься системные администраторы, в то время как разработчики только предоставляют им шаблон."

#: ../book/administration.rst:737
msgid "Now update your app file in :file:`/usr/share/tarantool`. Replace your application file (for example, :file:`/usr/share/tarantool/myapp.lua`) and manually reload the :file:`myappcfg.lua` initialization script using :program:`tarantoolctl`:"
msgstr "Теперь обновите файл с вашим приложением в директории :file:`/usr/share/tarantool`. Замените старую версию файла (например, :file:`/usr/share/tarantool/myapp.lua`) и вручную загрузите скрипт инициализации :file:`myappcfg.lua` с помощью утилиты :program:`tarantoolctl`:"

#: ../book/administration.rst:742
msgid "$ tarantoolctl eval /etc/tarantool/instance.enabled/myappcfg.lua"
msgstr "$ tarantoolctl eval /etc/tarantool/instance.enabled/myappcfg.lua"

#: ../book/administration.rst:746
msgid "After that, you need to manually flush the cache of ``package.loaded`` modules."
msgstr "После этого вам нужно вручную очистить кеш модулей ``package.loaded``."

#: ../book/administration.rst:748
msgid "For deb/rpm packages, you can add the ``tarantoolctl eval`` instruction directly into Tarantool's specification in :file:`RPM.spec` and the :file:`/debian` directory."
msgstr "Чтобы создать deb/rpm-сборку, вы можете добавить инструкцию ``tarantoolctl eval`` прямо в спецификацию Tarantool'а в файле :file:`RPM.spec` и в директории :file:`/debian`."

#: ../book/administration.rst:752
msgid "Finally, clients make a CALL to ``myapp.api_for_call`` and other API functions."
msgstr "В итоге клиенты делают вызов (CALL) функции ``myapp.api_for_call`` и других функций из API."

#: ../book/administration.rst:754
msgid "In the case of ``tarantool-http``, there is no need to start the binary protocol at all."
msgstr "Если вы используете ``tarantool-http``, то запускать бинарный протокол не нужно."

#: ../book/administration.rst:759
msgid "Upgrading a Tarantool database"
msgstr ""

#: ../book/administration.rst:761
msgid "This information applies for users who created databases with older versions of the Tarantool server, and have now installed a newer version. The request to make in this case is: :samp:`box.schema.upgrade()`."
msgstr "Эта информация полезна в том случае, если у вас есть база данных, работающая на какой-либо старой версии Tarantool'а, а теперь вы установили Tarantool новой версии. В этом случае выполните запрос :samp:`box.schema.upgrade()`."

#: ../book/administration.rst:765
msgid "For example, here is what happens when one runs :samp:`box.schema.upgrade()` with a database that was created in early 2015. Only a small part of the output is shown."
msgstr "Например, вот что происходит, если выполнить запрос :samp:`box.schema.upgrade()` для базы, созданной в начале 2015 года (для примера показана лишь малая часть выводимых сообщений):"

#: ../book/administration.rst:769
msgid ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."

#: ../book/administration.rst:782
msgid "Server signal handling"
msgstr "Обработка сигналов от сервера"

#: ../book/administration.rst:784
msgid "The server processes these signals during the main thread event loop:"
msgstr "Во время основного цикла Tarantool-сервер обрабатывает следующие сигналы:"

#: ../book/administration.rst:787
msgid "SIGHUP"
msgstr "SIGHUP"

#: ../book/administration.rst:789
msgid "may cause log file rotation, see :ref:`the example in section \"Logging\" <cfg_logging-logging_example>`."
msgstr "может привести к ротации лога, см. :ref:`пример в разделе \"Запись в журнал\" <cfg_logging-logging_example>`."

#: ../book/administration.rst:791
msgid "SIGUSR1"
msgstr "SIGUSR1"

#: ../book/administration.rst:793
msgid "may cause saving of a snapshot, see the description of :ref:`box.snapshot <admin-snapshot>`."
msgstr "может привести к сохранению снимка, см. описание функции :ref:`box.snapshot <admin-snapshot>`."

#: ../book/administration.rst:795
msgid "SIGTERM"
msgstr "SIGTERM"

#: ../book/administration.rst:797
msgid "may cause graceful shutdown (information will be saved first)."
msgstr "может привести к корректному завершению работы (с предварительным сохранением всех данных)."

#: ../book/administration.rst:798
msgid "SIGINT"
msgstr "SIGINT"

#: ../book/administration.rst:800
msgid "(also known as keyboard interrupt) may cause graceful shutdown."
msgstr "(или \"прерывание с клавиатуры\") может привести к корректному завершению работы (с предварительным сохранением всех данных)."

#: ../book/administration.rst:801
msgid "SIGKILL"
msgstr "SIGKILL"

#: ../book/administration.rst:803
msgid "causes shutdown."
msgstr "приводит к аварийному завершению работы (с возможной потерей данных)."

#: ../book/administration.rst:805
msgid "Other signals will result in behavior defined by the operating system. Signals other than SIGKILL may be ignored, especially if the server is executing a long-running procedure which prevents return to the main thread event loop."
msgstr "Действие других сигналов определяется операционной системой. Все сигналы, кроме SIGKILL, могут быть проигнорированы, особенно если Tarantool-сервер выполняет длительную процедуру, которая позволяет вернуться к главному циклу."

#: ../book/administration.rst:813
msgid "Process title"
msgstr "Название процесса"

#: ../book/administration.rst:815
msgid "Linux and FreeBSD operating systems allow a running process to modify its title, which otherwise contains the program name. Tarantool uses this feature to help meet the needs of system administration, such as figuring out what services are running on a host, their status, and so on."
msgstr "Операционные системы Linux и FreeBSD позволяют запущенному процессу менять его название (title), в котором изначально содержится имя программы (name). Tarantool использует эту возможность, чтобы упростить работу системного администратора, например посмотреть, какие службы запущены на хосте, их статус и т.д."

#: ../book/administration.rst:820
msgid "A Tarantool server's process title has these components:"
msgstr "Название процесса Tarantool-сервера состоит из следующих частей:"

#: ../book/administration.rst:822
msgid ":extsamp:`{**{program_name}**} [{**{initialization_file_name}**}] {**{<role_name>}**} [{**{custom_proc_title}**}]`"
msgstr ":extsamp:`{**{имя_программы}**} [{**{имя_файла_инициализации}**}] {**{<имя_роли>}**} [{**{название_процесса}**}]`"

#: ../book/administration.rst:824
msgid "**program_name** is typically \"tarantool\"."
msgstr "**имя_программы** — это, как правило, \"tarantool\"."

#: ../book/administration.rst:825
msgid "**initialization_file_name** is the name of an :ref:`initialization file <index-init_label>`, if one was specified."
msgstr "**имя_файла_инициализации** — это имя  :ref:`файла инициализации на Lua <index-init_label>`, если этот файл был указан при запуске."

#: ../book/administration.rst:827
msgid "**role_name** is:"
msgstr "**имя_роли** — это может быть один из следующих вариантов:"

#: ../book/administration.rst:829
msgid "\"running\" (ordinary node \"ready to accept requests\"),"
msgstr "\"running\" (узел находится в режиме \"готов к принятию запросов\"),"

#: ../book/administration.rst:830
msgid "\"loading\" (ordinary node recovering from old snap and wal files),"
msgstr "\"loading\" (узел, который загружает данные из ранее сохраненного снимка и WAL-файла),"

#: ../book/administration.rst:831
msgid "\"orphan\" (not in a cluster),"
msgstr "\"orphan\" (узел не входит в состав кластера),"

#: ../book/administration.rst:832
msgid "\"hot_standby\", or"
msgstr ""

#: ../book/administration.rst:833
msgid "\"dumper\" + process-id (saving a snapshot)."
msgstr "\"dumper\" + process-id (идет сохранение снимка)."

#: ../book/administration.rst:835
msgid "**custom_proc_title** is taken from the :ref:`custom_proc_title <cfg_basic-custom_proc_title>` configuration parameter, if one was specified."
msgstr "**название_процесса** — это необязательное название Tarantool-процесса в системе, которое берется из конфигурационного параметра :ref:`custom_proc_title <cfg_basic-custom_proc_title>`, если он указан."

#: ../book/administration.rst:839
msgid "For example:"
msgstr "Например:"

#: ../book/administration.rst:841
msgid ""
"$ ps -AF | grep tarantool\n"
"1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool script.lua <running>"
msgstr ""
"$ ps -AF | grep tarantool\n"
"1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool script.lua <running>"

#: ../book/administration.rst:848
msgid "System-specific administration notes"
msgstr "Заметки по администрированию для разных платформ"

#: ../book/administration.rst:850
#, fuzzy
msgid "This section will contain information about issues or features which exist on some platforms but not others - for example, on certain versions of a particular Linux distribution."
msgstr "В этом разделе приводится информация по проблемам и особенностям, которые относятся только к конкретным платформам. Например, к определенным версиям Linux-систем."

#: ../book/administration.rst:856
msgid "Debian GNU/Linux and Ubuntu"
msgstr "Debian GNU/Linux and Ubuntu"

#: ../book/administration.rst:858
msgid "Setting up an instance:"
msgstr "Настройка конкретного экземпляра Tarantool-сервера:"

#: ../book/administration.rst:860
msgid "$ ln -s /etc/tarantool/instances.available/*instance-name.cfg* /etc/tarantool/instances.enabled/"
msgstr "$ ln -s /etc/tarantool/instances.available/*instance-name.cfg* /etc/tarantool/instances.enabled/"

#: ../book/administration.rst:864
msgid "Starting all instances:"
msgstr "Запуск всех экземпляров:"

#: ../book/administration.rst:866
msgid "$ service tarantool start"
msgstr "$ service tarantool start"

#: ../book/administration.rst:870
msgid "Stopping all instances:"
msgstr "Остановка всех экземпляров:"

#: ../book/administration.rst:872
msgid "$ service tarantool stop"
msgstr "$ service tarantool stop"

#: ../book/administration.rst:876
msgid "Starting/stopping one instance:"
msgstr "Запуск/остановка конкретного экземпляра:"

#: ../book/administration.rst:878
msgid "$ service tarantool-instance-name start/stop"
msgstr "$ service tarantool-instance-name start/stop"

#: ../book/administration.rst:884
msgid "Fedora, RHEL, CentOS"
msgstr "Fedora, RHEL, CentOS"

#: ../book/administration.rst:886
msgid "There are no known permanent issues. For transient issues, go to http://github.com/tarantool/tarantool/issues and enter \"RHEL\" or \"CentOS\" or \"Fedora\" or \"Red Hat\" in the search box."
msgstr "Известных воспроизводящихся дефектов для данных платформ нет. Если вы столкнулись с плавающим дефектом, посмотрите описания проблем на странице http://github.com/tarantool/tarantool/issues, введя в строке поиска слово \"RHEL\", \"CentOS\", \"Fedora\" или \"Red Hat\"."

#: ../book/administration.rst:892
msgid "FreeBSD"
msgstr "FreeBSD"

#: ../book/administration.rst:894
msgid "There are no known permanent issues. For transient issues, go to http://github.com/tarantool/tarantool/issues and enter \"FreeBSD\" in the search box."
msgstr "Известных воспроизводящихся дефектов для данной платформы нет. Если вы столкнулись с плавающим дефектом, посмотрите описания проблем на странице http://github.com/tarantool/tarantool/issues, введя в строке поиска слово \"FreeBSD\"."

#: ../book/administration.rst:900
msgid "Mac OS X"
msgstr "Mac OS X"

#: ../book/administration.rst:902
msgid "There are no known permanent issues. For transient issues, go to http://github.com/tarantool/tarantool/issues and enter \"OS X\" in the search box."
msgstr "Известных воспроизводящихся дефектов для данных платформ нет. Если вы столкнулись с плавающим дефектом, посмотрите описания проблем на странице http://github.com/tarantool/tarantool/issues, введя в строке поиска слово \"OS X\"."

#: ../book/administration.rst:908
msgid "Notes for systemd users"
msgstr "Заметки для пользователей systemd"

#: ../book/administration.rst:910
msgid "Tarantool fully supports :program:`systemd` for managing instances and supervising database daemons."
msgstr "Tarantool полностью поддерживает работу с :program:`systemd` как со средством для управления экземплярами и контроля за фоновыми программами базы данных."

#: ../book/administration.rst:915
msgid "Instance management"
msgstr "Управление экземплярами"

#: ../book/administration.rst:917
msgid "Tarantool was designed to have multiple running instances of Tarantool on the same machine. Use :samp:`systemctl {start|stop|restart|status} tarantool@${MYAPP}` to manage your databases and Lua applications."
msgstr "В архитектуре Tarantool'а заложена возможность запуска сразу многих экземпляров Tarantool-сервера на одной машине. С помощью :samp:`systemctl {start|stop|restart|status} tarantool@${MYAPP}` можно управлять базами данных и Lua-приложениями."

#: ../book/administration.rst:924
msgid "Creating instances"
msgstr "Создание экземпляров"

#: ../book/administration.rst:926
msgid "Simply put your Lua configuration to :file:`/etc/tarantool/instances.available/${MYAPP}.lua`:"
msgstr "Задайте все настройки в виде Lua-скрипта и поместите их в файл :file:`/etc/tarantool/instances.available/${MYAPP}.lua`:"

#: ../book/administration.rst:929
msgid ""
"box.cfg{listen = 3313}\n"
"require('myappcode').start()"
msgstr ""
"box.cfg{listen = 3313}\n"
"require('myappcode').start()"

#: ../book/administration.rst:934
msgid "(this minimal example is sufficient)."
msgstr "(это пример минимально достаточной конфигурации)."

#: ../book/administration.rst:936
msgid "Another starting point could be the :file:`example.lua` script that ships with Tarantool and defines all options."
msgstr "Также вы можете посмотреть пример Lua-скрипт в файле :file:`example.lua`, который входит в состав дистрибутива Tarantool'а и содержит значения всех опций."

#: ../book/administration.rst:941
msgid "Starting instances"
msgstr "Запуск экземпляров"

#: ../book/administration.rst:943
msgid "Use :samp:`systemctl start tarantool@${MYAPP}` to start ``${MYAPP}`` instance:"
msgstr "Для запуска экземпляра ``${MYAPP}`` выполните команду :samp:`systemctl start tarantool@${MYAPP}`:"

#: ../book/administration.rst:945
msgid ""
"$ systemctl start tarantool@example\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool example.lua <running>"
msgstr ""
"$ systemctl start tarantool@example\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool example.lua <running>"

#: ../book/administration.rst:951
msgid "(console examples here and further on are for Fedora)."
msgstr "(здесь и далее мы приводим примеры консольного вывода для Fedora)."

#: ../book/administration.rst:953
msgid "Use :samp:`systemctl enable tarantool@${MYAPP}` to enable ``${MYAPP}`` instance for auto-load during system startup."
msgstr "Для автоматической загрузки экземпляра ``${MYAPP}`` во время запуска всей системы используйте команду :samp:`systemctl enable tarantool@${MYAPP}`."

#: ../book/administration.rst:958
msgid "Monitoring instances"
msgstr "Мониторинг экземпляров"

#: ../book/administration.rst:960
msgid "Use :samp:`systemctl status tarantool@${MYAPP}` to check information about ``${MYAPP}`` instance:"
msgstr "Для проверки информации об экземпляре ``${MYAPP}`` выполните команду :samp:`systemctl status tarantool@${MYAPP}`:"

#: ../book/administration.rst:963
msgid ""
"$ systemctl status tarantool@example\n"
"tarantool@example.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"+ 5350 tarantool example.lua <running>"
msgstr ""
"$ systemctl status tarantool@example\n"
"tarantool@example.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"+ 5350 tarantool example.lua <running>"

#: ../book/administration.rst:976
msgid "Use :samp:`journalctl -u tarantool@${MYAPP}` to check the boot log:"
msgstr "Для проверки журнала загрузки выполните команду :samp:`journalctl -u tarantool@${MYAPP}`:"

#: ../book/administration.rst:978
msgid ""
"$ journalctl -u tarantool@example -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database Server"
msgstr ""
"$ journalctl -u tarantool@example -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database Server"

#: ../book/administration.rst:990
msgid "Attaching to instances"
msgstr "Подсоединение к экземплярам"

#: ../book/administration.rst:992
msgid "You can attach to a running Tarantool instance and evaluate some Lua code using the :program:`tarantoolctl` utility:"
msgstr "Вы можете подсоединиться к запущенному экземпляру Tarantool-сервера и выполнить некий Lua-скрипт с помощью утилиты :program:`tarantoolctl`:"

#: ../book/administration.rst:995
msgid ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/example.control>"
msgstr ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/example.control>"

#: ../book/administration.rst:1009
msgid "Checking logs"
msgstr "Проверка журнала"

#: ../book/administration.rst:1011
msgid "Tarantool logs important events to :file:`/var/log/tarantool/${MYAPP}.log`."
msgstr "Tarantool ведет записи о важных событиях в файле :file:`/var/log/tarantool/${MYAPP}.log`."

#: ../book/administration.rst:1013
msgid "Let's write something to the log file:"
msgstr "Давайте запишем что-нибудь в файл журнала:"

#: ../book/administration.rst:1015
msgid ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for README.systemd readers\")\n"
"---\n"
"..."
msgstr ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for README.systemd readers\")\n"
"---\n"
"..."

#: ../book/administration.rst:1025
msgid "Then check the logs:"
msgstr "Затем проверим содержимое журнала:"

#: ../book/administration.rst:1027
msgid ""
"$ tail /var/log/tarantool/example.log\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
"2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept requests\n"
"2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead UNIX socket: /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> started\n"
"2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
"2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: connected\n"
"2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README.systemd readers\n"
"2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: disconnected"
msgstr ""
"$ tail /var/log/tarantool/example.log\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
"2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept requests\n"
"2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead UNIX socket: /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> started\n"
"2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
"2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: connected\n"
"2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README.systemd readers\n"
"2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: disconnected"

#: ../book/administration.rst:1041
msgid "Log rotation is enabled by default if you have :program:`logrotate` installed. Please configure :file:`/etc/logrotate.d/tarantool` to change the default behavior."
msgstr "Для ротации журнала нужно установить программу :program:`logrotate`. Настройки для ротации можно задать в файле :file:`/etc/logrotate.d/tarantool`."

#: ../book/administration.rst:1047
msgid "Stopping instances"
msgstr "Остановка экземпляров"

#: ../book/administration.rst:1049
msgid "Use :samp:`systemctl stop tarantool@${MYAPP}` to see information about the running ``${MYAPP}`` instance."
msgstr "Для просмотра информации о запущенном экземпляре ``${MYAPP}`` выполните команду :samp:`systemctl stop tarantool@${MYAPP}`."

#: ../book/administration.rst:1052
msgid "$ systemctl stop tarantool@example"
msgstr "$ systemctl stop tarantool@example"

#: ../book/administration.rst:1058
msgid "Daemon supervision"
msgstr "Контроль за фоновыми программами"

#: ../book/administration.rst:1060
msgid "All instances are automatically restarted by :program:`systemd` in case of failure."
msgstr "Если какой-либо экземпляр Tarantool-сервера выходит из строя, :program:`systemd` автоматически перезапускает его."

#: ../book/administration.rst:1062
msgid "Let's try to destroy an instance:"
msgstr "Давайте попробуем вывести из строя один экземпляр:"

#: ../book/administration.rst:1064
msgid ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed connection"
msgstr ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed connection"

#: ../book/administration.rst:1075
msgid "Now let's make sure that :program:`systemd` has revived our Tarantool instance:"
msgstr "А теперь убедимся, что :program:`systemd` перезапустила его:"

#: ../book/administration.rst:1077
msgid ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5914 (tarantool)"

#: ../book/administration.rst:1082
msgid "Finally, let's check the boot logs:"
msgstr "И под конец проверим содержимое журнала загрузки:"

#: ../book/administration.rst:1084
msgid ""
"$ journalctl -u tarantool@example -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database Server."
msgstr ""
"$ journalctl -u tarantool@example -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database Server."

#: ../book/administration.rst:1099
msgid "Customizing the service file"
msgstr "Правка настроек сервисного файла"

#: ../book/administration.rst:1101
msgid "Please don't modify the :file:`tarantool@.service` file in-place, because it will be overwritten during package upgrades. It is recommended to copy this file to :file:`/etc/systemd/system` and then modify the required settings. Alternatively, you can create a directory named :file:`unit.d/` within :file:`/etc/systemd/system` and put there a drop-in file :file:`name.conf` that only changes the required settings. Please see ``systemd.unit(5)`` manual page for additional information."
msgstr "Пожалуйста, не редактируйте файл :file:`tarantool@.service` по месту, поскольку все ваши изменения будут перезаписаны при последующих обновлениях Tarantool'а. Мы рекомендуем скопировать этот файл в :file:`/etc/systemd/system` и править настройки уже в копии. Либо вы можете создать поддиректорию с именем :file:`unit.d/` в директории :file:`/etc/systemd/system` и положить туда drop-in файл с именем :file:`name.conf`, в котором будут указаны только те настройки, которые нужно поменять. См. подробности в ``systemd.unit(5)``."

#: ../book/administration.rst:1110
msgid "Debugging"
msgstr "Отладка"

#: ../book/administration.rst:1112
msgid ":program:`coredumpctl` automatically saves core dumps and stack traces in case of a crash. Here is how it works:"
msgstr "При аварийном завершении Tarantool-сервера, :program:`coredumpctl` автоматически сохраняет дампы памяти (core dumps) и трассировку стека (stack traces). Вот как работает этот механизм:"

#: ../book/administration.rst:1115
msgid ""
"$ # !!! please never do this on the production system !!!\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed connection"
msgstr ""
"$ # !!! ВНИМАНИЕ: никогда не делайте этого\n"
"  # в условиях промышленной эксплуатации !!!\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed connection"

#: ../book/administration.rst:1125
msgid ":samp:`coredumpctl list /usr/bin/tarantool` displays the latest crashes of the Tarantool daemon:"
msgstr "Введем :samp:`coredumpctl list /usr/bin/tarantool`, чтобы получить отчет о последних аварийных завершениях Tarantool-демона:"

#: ../book/administration.rst:1128
msgid ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"

#: ../book/administration.rst:1135
msgid ":samp:`coredumpctl info <pid>` shows the stack trace and other useful information:"
msgstr "Чтобы получить трассировку стека и прочую полезную информацию, введем :samp:`coredumpctl info <pid>`:"

#: ../book/administration.rst:1137
msgid ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool example.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"         Unit: tarantool@example.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c _ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool example.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"         Unit: tarantool@example.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c _ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."

#: ../book/administration.rst:1172
msgid ":samp:`coredumpctl -o filename.core info <pid>` saves the core dump into a file."
msgstr "Теперь введем :samp:`coredumpctl -o filename.core info <pid>`, чтобы сохранить дамп памяти в отдельный файл."

#: ../book/administration.rst:1174
msgid ":samp:`coredumpctl gdb <pid>` starts :program:`gdb` on the core dump."
msgstr "Далее с помощью команды :samp:`coredumpctl gdb <pid>` запустим отладчик :program:`gdb` и подадим сохраненный дамп памяти ему на вход."

#: ../book/administration.rst:1176
msgid "It is highly recommended to install the ``tarantool-debuginfo`` package to improve :program:`gdb` experience. Example:"
msgstr "Мы очень рекомендуем установить пакет ``tarantool-debuginfo``, чтобы сделать отладку средствами :program:`gdb` более эффективной. Например:"

#: ../book/administration.rst:1179
msgid "$ dnf debuginfo-install tarantool"
msgstr "$ dnf debuginfo-install tarantool"

#: ../book/administration.rst:1186
msgid ":program:`gdb` also provides information about the ``debuginfo`` packages you need to install:"
msgstr "С помощью :program:`gdb` вы можете узнать, какие еще ``debuginfo``-пакеты нужно установить:"

#: ../book/administration.rst:1188
msgid ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"

#: ../book/administration.rst:1199
msgid "Symbol names are present in stack traces even if you don't have the ``tarantool-debuginfo`` package installed."
msgstr "В трассировке стека используются символические имена, даже если у вас не установлен пакет ``tarantool-debuginfo``."

#: ../book/administration.rst:1202
msgid "For additional information, please refer to the documentation provided with your Linux distribution."
msgstr "Дополнительно см. документацию по вашей Linux-системе."

#: ../book/administration.rst:1207
msgid "Precautions"
msgstr "Особые указания"

#: ../book/administration.rst:1209
msgid "Please don't use ``tarantoolctl {start,stop,restart}`` to control instances started by :program:`systemd`. It is still possible to use :program:`tarantoolctl` to start and stop instances from your local directories (e.g. :file:`${HOME}`) without obtaining ``ROOT`` access."
msgstr "Пожалуйста, не используйте ``tarantoolctl {start,stop,restart}`` для управления экземплярами, которые были запущены с помощью :program:`systemd`. Но вы можете использовать :program:`tarantoolctl` для запуска/остановки экземпляров в ваших локальных директориях (например, :file:`${HOME}`), что не требует пользовательских прав уровня ``ROOT``."

#: ../book/administration.rst:1214
msgid ":program:`tarantoolctl` is configured to work properly with :program:`systemd`. Please don't modify system-wide settings of :program:`tarantoolctl`, such as paths, directory permissions and usernames. Otherwise, you have a chance to shoot yourself in the foot."
msgstr "Утилита :program:`tarantoolctl` уже настроена так, чтобы корректно работать с :program:`systemd`. Пожалуйста, не меняйте общесистемные настройки для :program:`tarantoolctl`, такие как пути, настройки прав для директорий и имена пользователей, т.к. это может привести к неожиданным проблемам."

#: ../book/administration.rst:1219
msgid ":program:`systemd` scripts are maintained by the Tarantool Team (http://tarantool.org). Please file tickets directly to the upstream's bug tracker (https://github.com/tarantool/tarantool/issues/) rather than to your Linux distribution."
msgstr "Поддержкой скриптов для :program:`systemd` занимается команда разработки Tarantool'а (http://tarantool.org). Если у вас возникли проблемы при работе Tarantool'а с :program:`systemd`, то мы просим сообщать об этом нашей команде (https://github.com/tarantool/tarantool/issues/), а не разработчикам вашего Linux-дистрибутива."

#: ../book/app_server.rst:30
msgid "Application server"
msgstr "Сервер приложений"

#: ../book/app_server.rst:36
msgid "About modules/rocks"
msgstr "Про модули/rocks"

#: ../book/app_server.rst:38
msgid "Alongside with using Tarantool as a database manager, you can also use it as an application server. This means that you can write your own logic, install it as a module in Tarantool — and see Tarantool perform your logic. So, a module is an optional library which enhances Tarantool functionality."
msgstr ""

#: ../book/app_server.rst:43
msgid "Tarantool's native language for writing modules is Lua. Modules in Lua are also called \"rocks\". If you are new to Lua, we recommend following this `Lua modules tutorial <http://lua-users.org/wiki/ModulesTutorial>`_ before reading this section."
msgstr ""

#: ../book/app_server.rst:51
msgid "Installing an existing module"
msgstr "Установка существующего модуля"

#: ../book/app_server.rst:53
msgid "Modules that come from Tarantool developers and community contributors are available at `rocks.tarantool.org <http://rocks.tarantool.org>`_. Some of them -- :ref:`expirationd <expirationd-module>`, :ref:`mysql <dbms_modules-mysql-example>`, :ref:`postgresql <dbms_modules-postgresql-example>`, :ref:`shard <shard-module>` -- are discussed elsewhere in this manual."
msgstr "Модули, созданные командой Tarantool'а и членами сообщества разработчиков, выложены на `rocks.tarantool.org <http://rocks.tarantool.org>`_. Про некоторые из этих модулей — :ref:`expirationd <expirationd-module>`, :ref:`mysql <dbms_modules-mysql-example>`, :ref:`postgresql <dbms_modules-postgresql-example>`, :ref:`shard <shard-module>` -- подробнее говорится в других разделах текущей документации."

#: ../book/app_server.rst:61
msgid "**Step 1:** Install LuaRocks. A general description of installing LuaRocks on a Unix system is given in the `LuaRocks Quick Start Guide <http://luarocks.org/#quick-start>`_. For example, on Ubuntu you could say:"
msgstr "**Шаг 1:** Установите LuaRocks. Общее описание того, как установить LuaRocks в Unix-системе, приводится в `кратком руководстве по LuaRocks <http://luarocks.org/#quick-start>`_. Например, установить LuaRocks в Ubuntu можно следующей командой:"

#: ../book/app_server.rst:66
msgid "$ sudo apt-get install luarocks"
msgstr "$ sudo apt-get install luarocks"

#: ../book/app_server.rst:70
msgid "**Step 2:** Add the Tarantool repository to the list of rocks servers. This is done by putting `rocks.tarantool.org <http://rocks.tarantool.org>`_ in the :file:`.luarocks/config.lua` file:"
msgstr "**Шаг 2:** Добавьте репозиторий Tarantool'а в список rocks-серверов. Для этого добавьте `rocks.tarantool.org <http://rocks.tarantool.org>`_ в файл :file:`.luarocks/config.lua`:"

#: ../book/app_server.rst:74
msgid ""
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> ~/.luarocks/config.lua"
msgstr ""
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> ~/.luarocks/config.lua"

#: ../book/app_server.rst:79
msgid "Once these steps are complete, you can:"
msgstr "Теперь можно:"

#: ../book/app_server.rst:81
msgid "search the repositories with"
msgstr "искать существующие модули в общем репозитории"

#: ../book/app_server.rst:88
msgid "add new modules to the local repository with"
msgstr "добавлять новые модули в свой локальный репозиторий"

#: ../book/app_server.rst:95
msgid "load any module for Tarantool with"
msgstr "загружать любой модуль для Tarantool'а с помощью ``require``"

#: ../book/app_server.rst:102
msgid "... and that is why examples in this manual often begin with ``require`` requests."
msgstr "(вот почему многие примеры в этой документации начинаются с вызова ``require``.)"

#: ../book/app_server.rst:104
msgid "See `\"tarantool/rocks\" repository at GitHub <https://github.com/tarantool/rocks>`_ for more examples and information about contributing."
msgstr "Далее на странице `репозитория \"tarantool/rocks\" на GitHub <https://github.com/tarantool/rocks>`_ вы можете посмотреть примеры модулей и инструкции по добавлению собственных модулей в общий репозиторий."

#: ../book/app_server.rst:107
msgid "For developers, we provide :ref:`instructions on creating their own Tarantool modules in Lua, C/C++ and Lua+C <develop_modules>`."
msgstr ""

#: ../book/app_server.rst:114
msgid "Creating a new Lua module locally"
msgstr "Создание нового модуля на языке Lua"

#: ../book/app_server.rst:116
msgid "As an example, let's create a new Lua file named :file:`mymodule.lua`, containing a named function which will be exported. Then, in Tarantool: load, examine, and call."
msgstr "Для примера создадим новый Lua-файл с именем :file:`mymodule.lua`, в котором опишем экспортируемую функцию с некоторым именем, а затем с помощью Tarantool'а загрузим и просмотрим наш новый модуль и вызовем описанную в нем функцию."

#: ../book/app_server.rst:120
msgid "The Lua file should look like this:"
msgstr "Lua-файл в нашем примере будет таким:"

#: ../book/app_server.rst:122
msgid ""
"-- mymodule - a simple Tarantool module\n"
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"    print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""
"-- mymodule - простейший Lua-модуль для Tarantool'а\n"
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"    print('Hello', input_string)\n"
"end\n"
"return exports"

#: ../book/app_server.rst:131 ../book/app_server.rst:210
msgid "The requests to load, examine and call look like this:"
msgstr "Для загрузки и просмотра модуля, а также вызова описанной в нем функции, выполним следующие команды:"

#: ../book/app_server.rst:136
msgid ""
"tarantool> **mymodule = require('mymodule')**\n"
"---\n"
"...\n"
"\n"
"tarantool> **mymodule**\n"
"---\n"
"- myfun: 'function: 0x405edf20'\n"
"...\n"
"\n"
"tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
"Hello world\n"
"---\n"
"..."
msgstr ""
"tarantool> **mymodule = require('mymodule')**\n"
"---\n"
"...\n"
"\n"
"tarantool> **mymodule**\n"
"---\n"
"- myfun: 'function: 0x405edf20'\n"
"...\n"
"\n"
"tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
"Hello world\n"
"---\n"
"..."

#: ../book/app_server.rst:154
msgid "Creating a new C/C++ module locally"
msgstr "Создание нового модуля на языке C/C++"

#: ../book/app_server.rst:156
msgid "As an example, let's create a new C file named :file:`mycmodule.c`, containing a named function which will be exported. Then, in Tarantool: load, examine, and call."
msgstr "Для примера создадим новый C-файл с именем :file:`mymodule.c`, в котором опишем экспортируемую функцию с некоторым именем, а затем с помощью Tarantool'а загрузим и просмотрим наш новый модуль и вызовем описанную в нем функцию."

#: ../book/app_server.rst:160
msgid "Prerequisite: install ``tarantool-dev`` first."
msgstr "Обратите внимание, что для корректной работы требуется заранее установить модуль ``tarantool-dev``."

#: ../book/app_server.rst:162
msgid "The C file should look like this:"
msgstr "C-файл в нашем примере будет таким:"

#: ../book/app_server.rst:164
#, python-format
msgid ""
"/* mycmodule - a simple Tarantool module */\n"
"#include <lua.h>\n"
"#include <lauxlib.h>\n"
"#include <lualib.h>\n"
"#include <tarantool.h>\n"
"static int\n"
"myfun(lua_State *L)\n"
"{\n"
"    if (lua_gettop(L) < 1)\n"
"        return luaL_error(L, \"Usage: myfun(name)\");\n"
"\n"
"    /* Get first argument */\n"
"    const char *name = lua_tostring(L, 1);\n"
"\n"
"    /* Push one result to Lua stack */\n"
"    lua_pushfstring(L, \"Hello, %s\", name);\n"
"    return 1; /* the function returns one result */\n"
"}\n"
"\n"
"LUA_API int\n"
"luaopen_mycmodule(lua_State *L)\n"
"{\n"
"    static const struct luaL_reg reg[] = {\n"
"        { \"myfun\", myfun },\n"
"        { NULL, NULL }\n"
"    };\n"
"    luaL_register(L, \"mycmodule\", reg);\n"
"    return 1;\n"
"}"
msgstr ""
"/* mycmodule - простейший C-модуль для Tarantool'а */\n"
"#include <lua.h>\n"
"#include <lauxlib.h>\n"
"#include <lualib.h>\n"
"#include <tarantool.h>\n"
"static int\n"
"myfun(lua_State *L)\n"
"{\n"
"    if (lua_gettop(L) < 1)\n"
"        return luaL_error(L, \"Usage: myfun(name)\");\n"
"\n"
"    /* Get first argument */\n"
"    const char *name = lua_tostring(L, 1);\n"
"\n"
"    /* Push one result to Lua stack */\n"
"    lua_pushfstring(L, \"Hello, %s\", name);\n"
"    return 1; /* the function returns one result */\n"
"}\n"
"\n"
"LUA_API int\n"
"luaopen_mycmodule(lua_State *L)\n"
"{\n"
"    static const struct luaL_reg reg[] = {\n"
"        { \"myfun\", myfun },\n"
"        { NULL, NULL }\n"
"    };\n"
"    luaL_register(L, \"mycmodule\", reg);\n"
"    return 1;\n"
"}"

#: ../book/app_server.rst:196
msgid "Use :program:`gcc` to compile the code for a shared library (without a \"lib\" prefix), then use :program:`ls` to examine it:"
msgstr "С помощью :program:`gcc` скомпилируем наш код в виде shared-библиотеки (без префикса \"lib\"), а затем просмотрим ее содержимое с помощью :program:`ls`:"

#: ../book/app_server.rst:202
msgid ""
"$ **gcc mycmodule.c -shared -fPIC -I/usr/include/tarantool -o mycmodule.so**\n"
"$ **ls mycmodule.so -l**\n"
"-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"
msgstr ""
"$ **gcc mycmodule.c -shared -fPIC -I/usr/include/tarantool -o mycmodule.so**\n"
"$ **ls mycmodule.so -l**\n"
"-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"

#: ../book/app_server.rst:206
msgid "Tarantool's developers recommend using Tarantool's `CMake scripts <https://github.com/tarantool/modulekit>`_ which will handle some of the build steps automatically."
msgstr "Для автоматизации сборки рекомендуется использовать `CMake-скрипты для Tarantool'а <https://github.com/tarantool/modulekit>`_."

#: ../book/app_server.rst:215
msgid ""
"tarantool> **myсmodule = require('myсmodule')**\n"
"---\n"
"...\n"
"tarantool> **myсmodule**\n"
"---\n"
"- myfun: 'function: 0x4100ec98'\n"
"...\n"
"tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
"---\n"
"- Hello, world\n"
"..."
msgstr ""
"tarantool> **myсmodule = require('myсmodule')**\n"
"---\n"
"...\n"
"tarantool> **myсmodule**\n"
"---\n"
"- myfun: 'function: 0x4100ec98'\n"
"...\n"
"tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
"---\n"
"- Hello, world\n"
"..."

#: ../book/app_server.rst:227
msgid "You can also create modules with C++, provided that the code does not throw exceptions."
msgstr "Вы можете аналогичным образом создавать модули на C++ при условии, что в их коде не будут выбрасываться исключения."

#: ../book/app_server.rst:232
msgid "Creating a mixed Lua/C module locally"
msgstr "Создание нового модуля на смеси языков Lua/C"

#: ../book/app_server.rst:234
msgid "Create a Lua module and name it as you like, say ``myfunmodule``."
msgstr "Создайте новый Lua-модуль и назовите его, например, ``myfunmodule``."

#: ../book/app_server.rst:236
msgid "Create a C module (submodule) and name it ``myfunmodule.internal`` or something like that."
msgstr "Создайте (вложенный) модуль на C и назовите его, например, ``myfunmodule.internal``."

#: ../book/app_server.rst:239
msgid "Load the C module from your Lua code using :samp:`require('myfunmodule.internal')` and then wrap or use it."
msgstr "Загрузите новый C-модуль из Lua-кода с помощью :samp:`require('myfunmodule.internal')`, а затем сделайте для него обертку или вызывайте его функции напрямую."

#: ../book/app_server.rst:242
msgid "For a sample of a mixed Lua/C module, see `\"tarantool/http\" repository at GitHub <https://github.com/tarantool/http>`_."
msgstr "Примеры модулей на смеси языков Lua/C можно посмотреть в `репозитории \"tarantool/http\" на GitHub <https://github.com/tarantool/http>`_."

#: ../book/app_server.rst:247
msgid "Tips for special situations"
msgstr "Примечания для особых случаев"

#: ../book/app_server.rst:249
msgid "Lua caches all loaded modules in the ``package.loaded`` table. To reload a module from disk, set its key to `nil`:"
msgstr "В среде Lua все загруженные модули кешируются в таблице ``package.loaded``. Чтобы перегрузить какой-либо модуль с диска, укажите для его ключа значение `nil`:"

#: ../book/app_server.rst:257
msgid "Use ``package.path`` to search for :file:`.lua` modules, and use ``package.cpath`` to search for C binary modules."
msgstr "Для поиска :file:`.lua`-модулей используйте команду ``package.path``, а для поиска бинарных модулей на C используйте команду ``package.cpath``."

#: ../book/app_server.rst:278
msgid "Question-marks stand for the module name that was specified earlier when saying :extsamp:`require('{*{modulename}*}')`."
msgstr "Знаки вопроса стоят вместо имени модуля, которое было указано ранее при вызове :extsamp:`require('{*{имя_модуля}*}')`."

#: ../book/app_server.rst:281
msgid "To see the internal state from within a Lua module, use :samp:`state` and create a local variable inside the scope of the file:"
msgstr "Для просмотра внутреннего состояния прямо изнутри Lua-модуля используйте :samp:`state` и соответствующую локальную переменную в рамках модуля:"

#: ../book/app_server.rst:284
msgid ""
"-- mymodule\n"
"local exports = {}\n"
"local state = {}\n"
"exports.myfun = function()\n"
"    state.x = 42 -- use state\n"
"end\n"
"return exports"
msgstr ""
"-- mymodule\n"
"local exports = {}\n"
"local state = {}\n"
"exports.myfun = function()\n"
"    state.x = 42 -- используем state\n"
"end\n"
"return exports"

#: ../book/app_server.rst:294
msgid "Notice that Lua examples in this manual use *local* variables. Use *global* variables with caution, since the module's users may be unaware of them."
msgstr "Обратите внимание, что в текущей документации в примерах Lua-кода используются *локальные* переменные. Будьте аккуратны, если в своих модулях вы будете использовать *глобальные* переменные, поскольку пользователи ваших модулей могут не знать об этих переменных."

#: ../book/app_server.rst:300
msgid "Cookbook recipes"
msgstr "Книга рецептов"

#: ../book/cookbook.rst:3
msgid "Here are contributions of Lua programs for some frequent or tricky situations."
msgstr ""

#: ../book/cookbook.rst:5
msgid "Any of the programs can be executed by copying the code into a .lua file, and then entering :samp:`chmod +x ./{program-name}.lua` and :samp:`./{program-name}.lua` on the terminal. As is usual for Tarantool/Lua programs, the first line is a \"hashbang\" |br| #!/usr/bin/env tarantool |br| This runs the Tarantool Lua application server, which should be on the execution path."
msgstr ""

#: ../book/cookbook.rst:13
msgid "Use freely."
msgstr ""

#: ../book/cookbook.rst:15
msgid "**hello_world.lua**"
msgstr ""

#: ../book/cookbook.rst:17
msgid "The standard example of a simple program."
msgstr ""

#: ../book/cookbook.rst:19
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""

#: ../book/cookbook.rst:25
msgid "**console_start.lua**"
msgstr ""

#: ../book/cookbook.rst:27
msgid "Use :ref:`box.once() <box-once>` to initialize a database (creating spaces) if this is the first time the server has been run. Then use :ref:`console.start() <console-start>` to start interactive mode."
msgstr ""

#: ../book/cookbook.rst:31
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""

#: ../book/cookbook.rst:48
msgid "**fio_read.lua**"
msgstr ""

#: ../book/cookbook.rst:50
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""

#: ../book/cookbook.rst:52
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../book/cookbook.rst:66
msgid "**fio_write.lua**"
msgstr ""

#: ../book/cookbook.rst:68
msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""

#: ../book/cookbook.rst:70
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""

#: ../book/cookbook.rst:86
msgid "**ffi_printf.lua**"
msgstr ""

#: ../book/cookbook.rst:88
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C built-in function: printf(). (For help understanding ffi, see the `FFI tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../book/cookbook.rst:91
#, python-format
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""

#: ../book/cookbook.rst:102
msgid "**ffi_gettimeofday.lua**"
msgstr ""

#: ../book/cookbook.rst:104
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C function: gettimeofday(). This delivers time with millisecond precision, unlike the time function in Tarantool's :ref:`clock module <clock-module>`."
msgstr ""

#: ../book/cookbook.rst:108
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / 1000))\n"
"end"
msgstr ""

#: ../book/cookbook.rst:129
msgid "**ffi_zlib.lua**"
msgstr ""

#: ../book/cookbook.rst:131
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C library function. (For help understanding ffi, see the `FFI tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../book/cookbook.rst:134
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""

#: ../book/cookbook.rst:176
msgid "**ffi_meta.lua**"
msgstr ""

#: ../book/cookbook.rst:178
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access a C object via a metamethod (a method which is defined with a metatable)."
msgstr ""

#: ../book/cookbook.rst:182
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""

#: ../book/cookbook.rst:208
msgid "**print_arrays.lua**"
msgstr ""

#: ../book/cookbook.rst:210
msgid "Create Lua tables, and print them. Notice that for the 'array' table the iterator function is ipairs(), while for the 'map' table the iterator function is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is recommended for map-like tables or mixed tables.) The display will look like: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2 v2\"."
msgstr ""

#: ../book/cookbook.rst:218
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""

#: ../book/cookbook.rst:228
msgid "**count_array.lua**"
msgstr ""

#: ../book/cookbook.rst:230
msgid "Use the '#' operator to get the number of items in an array-like Lua table. This operation has O(log(N)) complexity."
msgstr ""

#: ../book/cookbook.rst:233
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""

#: ../book/cookbook.rst:240
msgid "**count_array_with_nils.lua**"
msgstr ""

#: ../book/cookbook.rst:242
msgid "Missing elements in arrays, which Lua treats a \"nil\"s, cause the simple \"#\" operator to deliver improper results. The \"print(#t)\" instruction will print \"4\"; the \"print(counter)\" instruction will print \"3\"; the \"print(max)\" instruction will print \"10\". Other table functions, such as table.sort(), will also misbehave when \"nils\" are present."
msgstr ""

#: ../book/cookbook.rst:250
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../book/cookbook.rst:266
msgid "**count_array_with_nulls.lua**"
msgstr ""

#: ../book/cookbook.rst:268
msgid "Use explicit ``NULL`` values to avoid the problems caused by Lua's nil == missing value behavior. Although :code:`json.NULL == nil` is :code:`true`, all the print instructions in this program will print the correct value: 10."
msgstr ""

#: ../book/cookbook.rst:273
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../book/cookbook.rst:292
msgid "**count_map.lua**"
msgstr ""

#: ../book/cookbook.rst:294
msgid "Get the number of elements in a map-like table."
msgstr ""

#: ../book/cookbook.rst:296
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""

#: ../book/cookbook.rst:305
msgid "**swap.lua**"
msgstr ""

#: ../book/cookbook.rst:307
msgid "Use a Lua peculiarity to swap two variables without needing a third variable."
msgstr ""

#: ../book/cookbook.rst:309
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""

#: ../book/cookbook.rst:320
msgid "**uri.lua**"
msgstr ""

#: ../book/cookbook.rst:322
msgid "Use built-in function :code:`uri_parse` to see what is in a `URI <configuration-uri>`:"
msgstr ""

#: ../book/cookbook.rst:324
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local uri = require('uri')\n"
"local r= uri.parse(\"scheme://login:password@host:service:/path1/path2/path3?q1=v1&q2=v2#fragment\")\n"
"print('r.password=',r.password)\n"
"print('r.path=',r.path)\n"
"print('r.scheme',r.scheme)\n"
"print('r.login=',r.login)\n"
"print('r.query=',r.query)\n"
"print('r.service=',r.service)\n"
"print('r.fragment=',r.fragment)\n"
"print('r.host=',r.host)"
msgstr ""

#: ../book/cookbook.rst:339
msgid "**class.lua**"
msgstr ""

#: ../book/cookbook.rst:341
msgid "Create a class, create a metatable for the class, create an instance of the class. Another illustration is at `http://lua-users.org/wiki/LuaClassesWithMetatable <http://lua-users.org/wiki/LuaClassesWithMetatable>`_."
msgstr ""

#: ../book/cookbook.rst:345
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""

#: ../book/cookbook.rst:375
msgid "**garbage.lua**"
msgstr ""

#: ../book/cookbook.rst:377
msgid "Force Lua `garbage collection <https://www.lua.org/manual/5.1/manual.html#2.10>`_ with the `collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_."
msgstr ""

#: ../book/cookbook.rst:380
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""

#: ../book/cookbook.rst:386
msgid "**fiber_producer_and_consumer.lua**"
msgstr ""

#: ../book/cookbook.rst:388
msgid "Start one fiber for producer and one fiber for consumer. Use :ref:`fiber.channel() <fiber_ipc-channel>` to exchange data and synchronize. One can tweak the channel size (:code:`ch_size` in the program code) to control the number of simultaneous tasks waiting for processing."
msgstr ""

#: ../book/cookbook.rst:393
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""

#: ../book/cookbook.rst:444
msgid "**socket_tcpconnect.lua**"
msgstr ""

#: ../book/cookbook.rst:446
msgid "Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a remote host via TCP. Display the connection details and the result of a GET request."
msgstr ""

#: ../book/cookbook.rst:450
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""

#: ../book/cookbook.rst:465
msgid "**socket_tcp_echo.lua**"
msgstr ""

#: ../book/cookbook.rst:467
msgid "Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple TCP server, by creating a function that handles requests and echos them, and passing the function to :ref:`socket.tcp_server() <socket-tcp_server>`. This program has been used to test with 100,000 clients, with each client getting a separate fiber."
msgstr ""

#: ../book/cookbook.rst:475
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, handler)"
msgstr ""

#: ../book/cookbook.rst:494
msgid "**getaddrinfo.lua**"
msgstr ""

#: ../book/cookbook.rst:496
msgid "Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-blocking DNS resolution, getting both the AF_INET6 and AF_INET information for 'google.com'. This technique is not always necessary for tcp connections because :ref:`socket.tcp_connect() <socket-tcp_connect>` performs `socket.getaddrinfo` under the hood, before trying to connect to the first available address."
msgstr ""

#: ../book/cookbook.rst:504
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = 'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""

#: ../book/cookbook.rst:520
msgid "**socket_udp_echo.lua**"
msgstr ""

#: ../book/cookbook.rst:522
msgid "Tarantool does not currently have a `udp_server` function, therefore socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can be implemented with sockets and fibers."
msgstr ""

#: ../book/cookbook.rst:527
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background fiber\n"
"    return s\n"
"end"
msgstr ""

#: ../book/cookbook.rst:576
msgid "A function for a client that connects to this server could look something like this ..."
msgstr ""

#: ../book/cookbook.rst:579
msgid ""
"local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""

#: ../book/cookbook.rst:596
msgid "**http_get.lua**"
msgstr ""

#: ../book/cookbook.rst:598
msgid "Use the `http`_ `rock`_ (which must first be installed) to get data via HTTP."
msgstr ""

#: ../book/cookbook.rst:601
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = http_client.get('http://api.openweathermap.org/data/2.5/weather?q=Oakland,us')\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""

#: ../book/cookbook.rst:615
msgid "**http_send.lua**"
msgstr ""

#: ../book/cookbook.rst:617
msgid "Use the `http`_ `rock`_ (which must first be installed) to send data via HTTP."
msgstr ""

#: ../book/cookbook.rst:620
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""

#: ../book/cookbook.rst:633
msgid "**http_server.lua**"
msgstr ""

#: ../book/cookbook.rst:635
msgid "Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool into a web server."
msgstr ""

#: ../book/cookbook.rst:638
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""

#: ../book/cookbook.rst:651
msgid "**http_generate_html.lua**"
msgstr ""

#: ../book/cookbook.rst:653
msgid "Use the `http`_ `rock` (which must first be installed) to generate HTML pages from templates. The `http`_ `rock`_ has a fairly simple template engine which allows execution of regular Lua code inside text blocks (like PHP). Therefore there is no need to learn new languages in order to write templates."
msgstr ""

#: ../book/cookbook.rst:659
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""

#: ../book/cookbook.rst:672
msgid "An \"HTML\" file for this server, including Lua, could look like this (it would produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""

#: ../book/cookbook.rst:675
#, python-format
msgid ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""

#: ../book/box/box_index.rst:30
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.index`"

#: ../book/box/box_index.rst:32
msgid "The ``box.index`` submodule provides read-only access for index definitions and index keys. Indexes are contained in :samp:`box.space.{space-name}.index` array within each space object. They provide an API for ordered iteration over tuples. This API is a direct binding to corresponding methods of index objects of type ``box.index`` in the storage engine."
msgstr ""

#: ../book/box/box_index.rst:44
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../book/box/box_index.rst:46 ../book/box/box_index.rst:56
#: ../book/box/box_index.rst:64 ../book/box/box_index.rst:114
#: ../book/box/box_index.rst:431 ../book/box/box_index.rst:594
#: ../book/box/box_index.rst:623 ../book/box/box_index.rst:654
#: ../book/box/box_index.rst:682 ../book/box/box_index.rst:715
#: ../book/box/box_index.rst:734 ../book/box/box_index.rst:751
#: ../book/box/box_index.rst:778 ../book/box/box_index.rst:799
#: ../book/box/box_index.rst:822
msgid "Parameters:"
msgstr ""

#: ../book/box/box_index.rst:48 ../book/box/box_index.rst:58
#: ../book/box/box_index.rst:66 ../book/box/box_index.rst:780
#: ../book/box/box_index.rst:824
msgid ":samp:`{index_object}` = an :ref:`object reference <index-object_reference>`."
msgstr ""

#: ../book/box/box_index.rst:50 ../book/box/box_schema.rst:62
#: ../book/box/box_schema.rst:68 ../book/box/box_space.rst:174
#: ../book/box/box_space.rst:176 ../book/box/index.rst:165
msgid "boolean"
msgstr ""

#: ../book/box/box_index.rst:54
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../book/box/box_index.rst:62
msgid "An array describing index key fields."
msgstr ""

#: ../book/box/box_index.rst:72
msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:90
msgid "This method provides iteration support within an index. The :codeitalic:`bitset-value` or :codeitalic:`search-value` parameter specifies what must match within the index. The :codeitalic:`iterator-type` parameter specifies the rule for matching and ordering. Different index types support different iterators. For example, a TREE index maintains a strict order of keys and can return all tuples in ascending or descending order, starting from the specified key. Other index types, however, do not support ordering."
msgstr ""

#: ../book/box/box_index.rst:100
msgid "To understand consistency of tuples returned by an iterator, it's essential to know the principles of the Tarantool transaction processing subsystem. An iterator in Tarantool does not own a consistent read view. Instead, each procedure is granted exclusive access to all tuples and spaces until there is a \"context switch\": which may happen due to :ref:`the-implicit-yield-rules <atomic-the_implicit_yield_rules>`, or by an explicit call to :ref:`fiber.yield <fiber-yield>`. When the execution flow returns to the yielded procedure, the data set could have changed significantly. Iteration, resumed after a yield point, does not preserve the read view, but continues with the new content of the database. The tutorial :ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>` shows one way that iterators and yields can be used together."
msgstr ""

#: ../book/box/box_index.rst:116 ../book/box/box_index.rst:433
#: ../book/box/box_index.rst:596 ../book/box/box_index.rst:625
#: ../book/box/box_index.rst:656 ../book/box/box_index.rst:684
#: ../book/box/box_index.rst:717 ../book/box/box_index.rst:736
#: ../book/box/box_index.rst:753 ../book/box/box_index.rst:801
msgid ":samp:`{index_object}` = an :ref:`object reference <index-object_reference>`;"
msgstr ""

#: ../book/box/box_index.rst:117
msgid ":samp:`{bitset-value} | {search-value...}` = what to search for"
msgstr ""

#: ../book/box/box_index.rst:118
msgid ":samp:`{iterator-type}` = as defined in tables below."
msgstr ""

#: ../book/box/box_index.rst:120
msgid "this method returns an iterator closure, i.e. a function which can be used to get the next value on each invocation"
msgstr ""

#: ../book/box/box_index.rst:122 ../book/box/box_space.rst:873
msgid "function, tuple"
msgstr ""

#: ../book/box/box_index.rst:124
msgid "Possible errors: Selected iteration type is not supported for the index type, or search value is not supported for the iteration type."
msgstr ""

#: ../book/box/box_index.rst:127 ../book/box/box_index.rst:816
msgid "Complexity Factors: Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../book/box/box_index.rst:129
msgid "A search-value can be a number (for example ``1234``), a string (for example ``'abcd'``), or a table of numbers and strings (for example ``{1234, 'abcd'}``). Each part of a search-value will be compared to each part of an index key."
msgstr ""

#: ../book/box/box_index.rst:136
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../book/box/box_index.rst:140
msgid "Formally the logic for TREE index searches is: |br| comparison-operator is = or >= or > or <= or < depending on iterator-type"
msgstr ""

#: ../book/box/box_index.rst:153
msgid "if all comparison-results are true, then search-value \"matches\" index key."
msgstr ""

#: ../book/box/box_index.rst:156
msgid "Notice how, according to this logic, regardless what the index-key-part contains, the comparison-result for equality is always true when a search-value-part is ``nil`` or is missing. This behavior of searches with nil is subject to change."
msgstr ""

#: ../book/box/authentication.rst:73 ../book/box/box_index.rst:166
#: ../book/box/box_index.rst:219 ../book/box/box_index.rst:253
#: ../book/box/box_index.rst:289 ../book/box/box_schema.rst:60
#: ../book/box/box_space.rst:166
msgid "Type"
msgstr ""

#: ../book/box/box_index.rst:166 ../book/box/box_index.rst:219
#: ../book/box/box_index.rst:253 ../book/box/box_index.rst:289
msgid "Arguments"
msgstr ""

#: ../book/box/authentication.rst:73 ../book/box/box_index.rst:166
#: ../book/box/box_index.rst:219 ../book/box/box_index.rst:253
#: ../book/box/box_index.rst:289
msgid "Description"
msgstr ""

#: ../book/box/box_index.rst:168 ../book/box/box_index.rst:226
#: ../book/box/box_index.rst:259 ../book/box/box_index.rst:294
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../book/box/box_index.rst:168 ../book/box/box_index.rst:174
#: ../book/box/box_index.rst:179 ../book/box/box_index.rst:186
#: ../book/box/box_index.rst:193 ../book/box/box_index.rst:197
#: ../book/box/box_index.rst:203 ../book/box/box_index.rst:226
#: ../book/box/box_index.rst:232 ../book/box/box_index.rst:294
#: ../book/box/box_index.rst:302 ../book/box/box_index.rst:307
#: ../book/box/box_index.rst:312 ../book/box/box_index.rst:317
#: ../book/box/box_index.rst:327
msgid "search value"
msgstr ""

#: ../book/box/box_index.rst:168
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. Tuples are returned in ascending order by index key. This is the default."
msgstr ""

#: ../book/box/box_index.rst:174
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../book/box/box_index.rst:174
msgid "Matching is the same as for ``box.index.EQ``. Tuples are returned in descending order by index key."
msgstr ""

#: ../book/box/box_index.rst:179 ../book/box/box_index.rst:232
#: ../book/box/box_index.rst:302
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../book/box/box_index.rst:179
msgid "The comparison operator is '>' (greater than). If an index key is greater than a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../book/box/box_index.rst:186 ../book/box/box_index.rst:307
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../book/box/box_index.rst:186
msgid "The comparison operator is '>=' (greater than or equal to). If an index key is greater than or equal to a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../book/box/box_index.rst:193 ../book/box/box_index.rst:255
#: ../book/box/box_index.rst:291
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../book/box/box_index.rst:193
msgid "Same as box.index.GE."
msgstr ""

#: ../book/box/box_index.rst:197 ../book/box/box_index.rst:312
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../book/box/box_index.rst:197
msgid "The comparison operator is '<' (less than). If an index key is less than a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../book/box/box_index.rst:203 ../book/box/box_index.rst:317
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../book/box/box_index.rst:203
msgid "The comparison operator is '<=' (less than or equal to). If an index key is less than or equal to a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../book/box/box_index.rst:212
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../book/box/box_index.rst:221
msgid "box.index.ALL"
msgstr ""

#: ../book/box/box_index.rst:221 ../book/box/box_index.rst:255
#: ../book/box/box_index.rst:291
msgid "none"
msgstr ""

#: ../book/box/box_index.rst:221
msgid "All index keys match. Tuples are returned in ascending order by hash of index key, which will appear to be random."
msgstr ""

#: ../book/box/box_index.rst:226
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. The number of returned tuples will be 0 or 1. This is the default."
msgstr ""

#: ../book/box/box_index.rst:232
msgid "The comparison operator is '>' (greater than). If a hash of an index key is greater than a hash of a search value, it matches. Tuples are returned in ascending order by hash of index key, which will appear to be random. Provided that the space is not being updated, one can retrieve all the tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} in each search, and using the last returned value from the previous result as the start search value for the next search."
msgstr ""

#: ../book/box/box_index.rst:246
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../book/box/box_index.rst:255
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:259 ../book/box/box_index.rst:264
#: ../book/box/box_index.rst:269 ../book/box/box_index.rst:274
msgid "bitset value"
msgstr ""

#: ../book/box/box_index.rst:259
msgid "If an index key is equal to a bitset value, it matches. Tuples are returned in their order within the space. This is the default."
msgstr ""

#: ../book/box/box_index.rst:264
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../book/box/box_index.rst:264
msgid "If all of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:269
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../book/box/box_index.rst:269
msgid "If any of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:274
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../book/box/box_index.rst:274
msgid "If all of the bits which are 1 in the bitset value are 0 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:282
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../book/box/box_index.rst:291
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:294
msgid "If all points of the rectangle-or-box defined by the search value are the same as the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space. \"Rectangle-or-box\" means \"rectangle-or-box as explained in section about :ref:`RTREE <box_index-rtree>`\". This is the default."
msgstr ""

#: ../book/box/box_index.rst:302
msgid "If all points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:307
msgid "If all points of the rectangle-or-box defined by the search value are within, or at the side of, the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:312
msgid "If all points of the rectangle-or-box defined by the index key are within the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:317
msgid "If all points of the rectangle-or-box defined by the index key are within, or at the side of, the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:322
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../book/box/box_index.rst:322
msgid "search values"
msgstr ""

#: ../book/box/box_index.rst:322
msgid "If some points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:327
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../book/box/box_index.rst:327
msgid "If some points of the rectangle-or-box defined by the defined by the key are within, or at the side of, defined by the index key, it matches. Tuples are returned in order: nearest neighbor first."
msgstr ""

#: ../book/box/box_index.rst:333
msgid "**First Example of index pairs():**"
msgstr ""

#: ../book/box/box_index.rst:335
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../book/box/box_index.rst:337
msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:383
msgid "**Second Example of index pairs():**"
msgstr ""

#: ../book/box/box_index.rst:385
msgid "This Lua code finds all the tuples whose primary key values begin with 'XY'. The assumptions include that there is a one-part primary-key TREE index on the first field, which must be a string. The iterator loop ensures that the search will return tuples where the first value is greater than or equal to 'XY'. The conditional statement within the loop ensures that the looping will stop when the first two letters are not 'XY'."
msgstr ""

#: ../book/box/box_index.rst:393
msgid ""
"for tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:401
msgid "**Third Example of index pairs():**"
msgstr ""

#: ../book/box/box_index.rst:403
msgid "This Lua code finds all the tuples whose primary key values are greater than or equal to 1000, and less than or equal to 1999 (this type of request is sometimes called a \"range search\" or a \"between search\"). The assumptions include that there is a one-part primary-key TREE index on the first field, which must be a number. The iterator loop ensures that the search will return tuples where the first value is greater than or equal to 1000. The conditional statement within the loop ensures that the looping will stop when the first value is greater than 1999."
msgstr ""

#: ../book/box/box_index.rst:413
msgid ""
"for tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:425
msgid "This is an alternative to :ref:`box.space...select() <box_space-select>` which goes via a particular index and can make use of additional parameters that specify the iterator type, and the limit (that is, the maximum number of tuples to return) and the offset (that is, which tuple to start with in the list)."
msgstr ""

#: ../book/box/box_index.rst:434
msgid ":samp:`search-key` = values to be matched against the index key;"
msgstr ""

#: ../book/box/box_index.rst:438
msgid ":samp:`option(s)` any or all of"
msgstr ""

#: ../book/box/box_index.rst:436
msgid ":samp:`iterator = {iterator-type}`,"
msgstr ""

#: ../book/box/box_index.rst:437
msgid ":samp:`limit = {maximum-number-of-tuples}`,"
msgstr ""

#: ../book/box/box_index.rst:438
msgid ":samp:`offset = {start-tuple-number}`."
msgstr ""

#: ../book/box/box_index.rst:440
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../book/box/box_index.rst:441 ../book/box/box_space.rst:308
msgid "array of tuples"
msgstr ""

#: ../book/box/box_index.rst:445
msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:471
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../book/box/box_index.rst:473
msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:482
msgid ":samp:`index.{index-name}` is optional. If it is omitted, then the assumed index is the first (primary-key) index. Therefore, for the example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would have returned the same two rows, via the 'primary' index."
msgstr ""

#: ../book/box/box_index.rst:489
msgid ":samp:`iterator = {iterator-type}` is optional. If it is omitted, then ``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../book/box/box_index.rst:494
msgid ":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, then every key in the index is considered to be a match, regardless of iterator type. Therefore, for the example above, ``box.space.tester:select{}`` will select every tuple in the tester space via the first (primary-key) index."
msgstr ""

#: ../book/box/box_index.rst:504
msgid ":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That is, ``get`` can be used as a convenient shorthand to get the first tuple in the tuple set that would be returned by ``select``. However, if there is more than one tuple in the tuple set, then ``get`` returns an error."
msgstr ""

#: ../book/box/box_index.rst:512
msgid "**Example with BITSET index:**"
msgstr ""

#: ../book/box/box_index.rst:514
msgid "The following script shows creation and search with a BITSET index. Notice: BITSET cannot be unique, so first a primary-key index is created. Notice: bit values are entered as hexadecimal literals for easier reading."
msgstr ""

#: ../book/box/box_index.rst:518
msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:565
msgid "Search for a tuple via the given index, as described :ref:`earlier <box_index-note>`."
msgstr ""

#: ../book/box/box_index.rst:567 ../book/box/box_space.rst:299
#: ../book/box/box_space.rst:372
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = key to be matched against the index key, which may be multi-part."
msgstr ""

#: ../book/box/box_index.rst:571
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

#: ../book/box/box_index.rst:572 ../book/box/box_index.rst:602
#: ../book/box/box_index.rst:631 ../book/box/box_index.rst:660
#: ../book/box/box_index.rst:724 ../book/box/box_index.rst:741
#: ../book/box/box_space.rst:279 ../book/box/box_space.rst:377
#: ../book/box/box_space.rst:458 ../book/box/box_space.rst:516
#: ../book/box/box_space.rst:655 ../book/box/box_space.rst:844
#: ../book/box/box_tuple.rst:53 ../book/box/box_tuple.rst:197
#: ../book/box/box_tuple.rst:198 ../book/box/box_tuple.rst:289
#: ../book/box/index.rst:171
msgid "tuple"
msgstr ""

#: ../book/box/box_index.rst:574
msgid "Possible errors: No such index; wrong type; more than one tuple matches."
msgstr ""

#: ../book/box/box_index.rst:576
msgid "Complexity Factors: Index size, Index type. See also :ref:`space_object:get() <box_space-get>`."
msgstr ""

#: ../book/box/box_index.rst:581
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:592
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../book/box/box_index.rst:597 ../book/box/box_index.rst:626
msgid ":samp:`key-value`."
msgstr ""

#: ../book/box/box_index.rst:599
msgid "the tuple for the first key in the index. If optional ``key-value`` is supplied, returns the first key which is greater than or equal to ``key-value``."
msgstr ""

#: ../book/box/box_index.rst:604 ../book/box/box_index.rst:633
msgid "Possible errors: index is not of type 'TREE'."
msgstr ""

#: ../book/box/box_index.rst:606 ../book/box/box_index.rst:635
#: ../book/box/box_index.rst:662
msgid "Complexity Factors: Index size, Index type."
msgstr ""

#: ../book/box/box_index.rst:610
msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:621
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../book/box/box_index.rst:628
msgid "the tuple for the last key in the index. If optional ``key-value`` is supplied, returns the last key which is less than or equal to ``key-value``."
msgstr ""

#: ../book/box/box_index.rst:639
msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:650
msgid "Find a random value in the specified index. This method is useful when it's important to get insight into data distribution in an index without having to iterate over the entire data set."
msgstr ""

#: ../book/box/box_index.rst:657
msgid ":samp:`random-value` (type = number) = an arbitrary non-negative integer."
msgstr ""

#: ../book/box/box_index.rst:659
msgid "the tuple for the random key in the index."
msgstr ""

#: ../book/box/box_index.rst:664
msgid "Note re storage engine: vinyl does not support ``random()``."
msgstr ""

#: ../book/box/box_index.rst:668
msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:679
msgid "Iterate over an index, counting the number of tuples which match the key-value."
msgstr ""

#: ../book/box/box_index.rst:685
msgid ":samp:`{key-value}` (type = Lua table or scalar) = the value which must match the key(s) in the specified index. The type may be a list of field-values, or a tuple containing only the field-values;  :codeitalic:`iterator` = comparison method."
msgstr ""

#: ../book/box/box_index.rst:690
msgid "the number of matching index keys."
msgstr ""

#: ../book/box/box_index.rst:691 ../book/box/box_index.rst:827
#: ../book/box/box_schema.rst:64 ../book/box/box_schema.rst:66
#: ../book/box/box_session.rst:41 ../book/box/box_session.rst:46
#: ../book/box/box_session.rst:71 ../book/box/box_space.rst:172
#: ../book/box/box_tuple.rst:85 ../book/box/box_tuple.rst:110
#: ../book/box/box_tuple.rst:159 ../book/box/index.rst:161
msgid "number"
msgstr ""

#: ../book/box/box_index.rst:696
msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = 'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:709 ../book/box/box_space.rst:477
#: ../book/box/box_tuple.rst:274
msgid "Update a tuple."
msgstr ""

#: ../book/box/box_index.rst:711
msgid "Same as :ref:`box.space...update() <box_space-update>`, but key is searched in this index instead of primary key. This index ought to be unique."
msgstr ""

#: ../book/box/box_index.rst:718
msgid ":samp:`{key}` (type = Lua table or scalar) = key to be matched against the index key;"
msgstr ""

#: ../book/box/box_index.rst:720
msgid ":samp:`{operator, field_no, value}` (type = Lua table) = update operations (see: :ref:`box.space...update() <box_space-update>`)."
msgstr ""

#: ../book/box/box_index.rst:723 ../book/box/box_space.rst:515
msgid "the updated tuple."
msgstr ""

#: ../book/box/box_index.rst:728
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../book/box/box_index.rst:730
msgid "Same as :ref:`box.space...delete() <box_space-delete>`, but key is searched in this index instead of in the primary-key index. This index ought to be unique."
msgstr ""

#: ../book/box/box_index.rst:737
msgid ":samp:`key` (type = Lua table or scalar) = key to be matched against the index key."
msgstr ""

#: ../book/box/box_index.rst:740
msgid "the deleted tuple."
msgstr ""

#: ../book/box/box_index.rst:743
msgid "Note re storage engine: vinyl will return nil, rather than the deleted tuple."
msgstr ""

#: ../book/box/box_index.rst:749
msgid "Alter an index."
msgstr ""

#: ../book/box/box_index.rst:754
msgid ":samp:`{options}` = options list, same as the options list for :ref:`create_index <box_space-create_index>`."
msgstr ""

#: ../book/box/box_index.rst:757 ../book/box/box_index.rst:804
#: ../book/box/box_schema.rst:126 ../book/box/box_schema.rst:286
#: ../book/box/box_schema.rst:404 ../book/box/box_space.rst:406
#: ../book/box/box_space.rst:428 ../book/box/box_space.rst:808
#: ../book/box/index.rst:167 ../book/box/triggers.rst:153
#: ../book/box/triggers.rst:204
msgid "nil"
msgstr ""

#: ../book/box/box_index.rst:759
msgid "Possible errors: Index does not exist, or the first index cannot be changed to {unique = false}, or the alter function is only applicable for the memtx storage engine."
msgstr ""

#: ../book/box/box_index.rst:763
msgid "Note re storage engine: vinyl does not support ``alter()``."
msgstr ""

#: ../book/box/box_index.rst:767
msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:775
msgid "Drop an index. Dropping a primary-key index has a side effect: all tuples are deleted."
msgstr ""

#: ../book/box/box_index.rst:782
msgid "nil."
msgstr ""

#: ../book/box/box_index.rst:784
msgid "Possible errors: Index does not exist, or a primary-key index cannot be dropped while a secondary-key index exists."
msgstr ""

#: ../book/box/box_index.rst:789
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:797
msgid "Rename an index."
msgstr ""

#: ../book/box/box_index.rst:802
msgid ":samp:`{index-name}` (type = string) = new name for index."
msgstr ""

#: ../book/box/box_index.rst:806
msgid "Possible errors: index_object does not exist."
msgstr ""

#: ../book/box/box_index.rst:810
msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:820
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../book/box/box_index.rst:826 ../book/box/box_tuple.rst:109
msgid "number of bytes"
msgstr ""

#: ../book/box/box_index.rst:831
msgid "Example showing use of the box functions"
msgstr ""

#: ../book/box/box_index.rst:833
msgid "This example will work with the sandbox configuration described in the preface. That is, there is a space named tester with a numeric primary key. The example function will:"
msgstr ""

#: ../book/box/box_index.rst:837
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../book/box/box_index.rst:838
msgid "return an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../book/box/box_index.rst:841
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../book/box/box_index.rst:840
msgid "field[1] = 1000"
msgstr ""

#: ../book/box/box_index.rst:841
msgid "field[2] = a uuid"
msgstr ""

#: ../book/box/box_index.rst:842
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../book/box/box_index.rst:843
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../book/box/box_index.rst:844
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../book/box/box_index.rst:845
msgid "Return the formatted value."
msgstr ""

#: ../book/box/box_index.rst:847
msgid "The function uses Tarantool box functions :ref:`box.space...select <box_space-select>`, :ref:`box.space...replace <box_space-replace>`, :ref:`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function uses Lua functions `os.date()`_ and `string.sub()`_."
msgstr ""

#: ../book/box/box_index.rst:856
#, python-format
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:881 ../book/box/box_tuple.rst:337
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../book/box/box_index.rst:883
msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:900
msgid "Example showing a user-defined iterator"
msgstr ""

#: ../book/box/box_index.rst:902
msgid "Here is an example that shows how to build one's own iterator. The ``paged_iter`` function is an \"iterator function\", which will only be understood by programmers who have read the Lua manual section `Iterators and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated retrievals, that is, it returns 10 tuples at a time from a table named \"t\", whose primary key was defined with :codenormal:`create_index('primary',{parts={1,'string'}})`."
msgstr ""

#: ../book/box/box_index.rst:912
msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:926
msgid "Programmers who use ``paged_iter`` do not need to know why it works, they only need to know that, if they call it within a loop, they will get 10 tuples at a time until there are no more tuples. In this example the tuples are merely printed, a page at a time. But it should be simple to change the functionality, for example by yielding after each retrieval, or by breaking when the tuples fail to match some additional criteria."
msgstr ""

#: ../book/box/box_index.rst:936
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i=1,#page,1 do print(page[i]) end\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:947
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../book/box/box_index.rst:949
msgid "The :ref:`box.index <box_index>` submodule may be used for spatial searches if the index type is RTREE. There are operations for searching *rectangles* (geometric objects with 4 corners and 4 sides) and *boxes* (geometric objects with more than 4 corners and more than 4 sides, sometimes called hyperrectangles). This manual uses the term *rectangle-or-box* for the whole class of objects that includes both rectangles and boxes. Only rectangles will be illustrated."
msgstr ""

#: ../book/box/box_index.rst:956
msgid "Rectangles are described according to their X-axis (horizontal axis) and Y-axis (vertical axis) coordinates in a grid of arbitrary size. Here is a picture of four rectangles on a grid with 11 horizontal points and 11 vertical points:"
msgstr ""

#: ../book/box/box_index.rst:962
msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""

#: ../book/box/box_index.rst:976
msgid "The rectangles are defined according to this scheme: {X-axis coordinate of top left, Y-axis coordinate of top left, X-axis coordinate of bottom right, Y-axis coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So in the picture ... Rectangle#1 starts at position 1 on the X axis and position 2 on the Y axis, and ends at position 3 on the X axis and position 4 on the Y axis, so its coordinates are {1,2,3,4}. Rectangle#2's coordinates are {3,5,9,10}. Rectangle#3's coordinates are {4,7,5,9}. And finally Rectangle#4's coordinates are {10,11,10,11}. Rectangle#4 is actually a \"point\" since it has zero width and zero height, so it could have been described with only two digits: {10,11}."
msgstr ""

#: ../book/box/box_index.rst:986
msgid "Some relationships between the rectangles are: \"Rectangle#1's nearest neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside Rectangle#2\"."
msgstr ""

#: ../book/box/box_index.rst:989
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../book/box/box_index.rst:991
msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:1004
msgid "Field#1 doesn't matter, we just make it because we need a primary-key index. (RTREE indexes cannot be unique and therefore cannot be primary-key indexes.) The second field must be an \"array\", which means its values must represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let us populate the table by inserting two tuples, containing the coordinates of Rectangle#2 and Rectangle#4."
msgstr ""

#: ../book/box/box_index.rst:1010
msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../book/box/box_index.rst:1015
msgid "And now, following the description of `RTREE iterator types`_, we can search the rectangles with these requests:"
msgstr ""

#: ../book/box/box_index.rst:1020
msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:1036
msgid "Request#1 returns 1 tuple because the point {10,11} is the same as the rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns 1 tuple because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the picture, is entirely within{3,5,9,10} which was Rectangle#2. Request#3 returns 2 tuples, because the NEIGHBOR iterator always returns all tuples, and the first returned tuple will be {3,5,9,10} (\"Rectangle#2\" in the picture) because it is the closest neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""

#: ../book/box/box_index.rst:1044
msgid "Now let us create a space and index for cuboids, which are rectangle-or-boxes that have 6 corners and 6 sides."
msgstr ""

#: ../book/box/box_index.rst:1047
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:1058
msgid "The additional field here is ``dimension=3``. The default dimension is 2, which is why it didn't need to be specified for the examples of rectangle. The maximum dimension is 20. Now for insertions and selections there will usually be 6 coordinates. For example:"
msgstr ""

#: ../book/box/box_index.rst:1062
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../book/box/box_index.rst:1067
msgid "Now let us create a space and index for Manhattan-style spatial objects, which are rectangle-or-boxes that have a different way to calculate neighbors."
msgstr ""

#: ../book/box/box_index.rst:1070
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:1081
msgid "The additional field here is ``distance='manhattan'``. The default distance calculator is 'euclid', which is the straightforward as-the-crow-flies method. The optional distance calculator is 'manhattan', which can be a more appropriate method if one is following the lines of a grid rather than traveling in a straight line."
msgstr ""

#: ../book/box/box_index.rst:1086
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../book/box/box_index.rst:1092
msgid "More examples of spatial searching are online in the file `R tree index quick start and usage`_."
msgstr ""

#: ../book/box/box_schema.rst:30
msgid "Submodule `box.schema`"
msgstr "Вложенный модуль `box.schema`"

#: ../book/box/box_schema.rst:34
msgid "The ``box.schema`` submodule has data-definition functions for spaces, users, roles, and function tuples."
msgstr ""

#: ../book/box/box_schema.rst:41
msgid "Create a space."
msgstr ""

#: ../book/box/box_schema.rst:43
msgid "name of space, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:45
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../book/box/box_schema.rst:47
msgid "space object"
msgstr ""

#: ../book/box/box_schema.rst:48
msgid "userdata"
msgstr ""

#: ../book/box/box_schema.rst:52
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../book/box/authentication.rst:73 ../book/box/box_schema.rst:60
#: ../book/box/box_space.rst:49 ../book/box/box_space.rst:166
msgid "Name"
msgstr ""

#: ../book/box/box_schema.rst:60 ../book/box/box_space.rst:166
msgid "Effect"
msgstr ""

#: ../book/box/box_schema.rst:60 ../book/box/box_space.rst:166
msgid "Default"
msgstr ""

#: ../book/box/box_schema.rst:62
msgid "temporary"
msgstr ""

#: ../book/box/box_schema.rst:62
msgid "space is temporary"
msgstr ""

#: ../book/box/box_schema.rst:62 ../book/box/box_schema.rst:68
msgid "false"
msgstr ""

#: ../book/box/box_schema.rst:64 ../book/box/box_space.rst:172
msgid "id"
msgstr ""

#: ../book/box/box_schema.rst:64 ../book/box/box_space.rst:172
msgid "unique identifier"
msgstr ""

#: ../book/box/box_schema.rst:64
msgid "last space's id, +1"
msgstr ""

#: ../book/box/box_schema.rst:66
msgid "field_count"
msgstr ""

#: ../book/box/box_schema.rst:66
msgid "fixed field count"
msgstr ""

#: ../book/box/box_schema.rst:66
msgid "0 i.e. not fixed"
msgstr ""

#: ../book/box/box_schema.rst:68 ../book/box/box_space.rst:176
msgid "if_not_exists"
msgstr ""

#: ../book/box/box_schema.rst:68 ../book/box/box_space.rst:176
msgid "no error if duplicate name"
msgstr ""

#: ../book/box/box_schema.rst:71
msgid "engine"
msgstr ""

#: ../book/box/box_schema.rst:71
msgid "storage engine = :ref:`'memtx' or 'vinyl' <index-two_storage_engines>`"
msgstr ""

#: ../book/box/box_schema.rst:71 ../book/box/box_schema.rst:75
#: ../book/box/box_schema.rst:232 ../book/box/box_session.rst:61
#: ../book/box/index.rst:163
msgid "string"
msgstr ""

#: ../book/box/box_schema.rst:71
msgid "'memtx'"
msgstr ""

#: ../book/box/authentication.rst:75 ../book/box/authentication.rst:78
#: ../book/box/box_schema.rst:75
msgid "user"
msgstr ""

#: ../book/box/box_schema.rst:75
msgid "user name"
msgstr ""

#: ../book/box/box_schema.rst:75
msgid "current user's name"
msgstr ""

#: ../book/box/box_schema.rst:77
msgid "format"
msgstr ""

#: ../book/box/box_schema.rst:77
msgid "field names+types"
msgstr ""

#: ../book/box/box_schema.rst:77
msgid "(blank)"
msgstr ""

#: ../book/box/box_schema.rst:80
msgid "There are five :ref:`syntax variations <index-object_reference>` for object references targeting space objects, for example :samp:`box.schema.space.drop({space-id})` will drop a space. However, the common approach is to use functions attached to the space objects, for example :ref:`space_object:drop() <box_space-drop>`."
msgstr ""

#: ../book/box/box_schema.rst:86
msgid "Note re storage engine: vinyl does not support temporary spaces."
msgstr ""

#: ../book/box/box_schema.rst:88
#, fuzzy
msgid "**Example**"
msgstr "**Примеры:**"

#: ../book/box/box_schema.rst:90
msgid ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_schema.rst:108
msgid "For an illustration with the ``format`` clause, see :ref:`box.space._space <box_space-space>` example."
msgstr ""

#: ../book/box/box_schema.rst:111
msgid "After a space is created, usually the next step is to :ref:`create an index <box_space-create_index>` for it, and then it is available for insert, select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""

#: ../book/box/box_schema.rst:118
msgid "Create a user. For explanation of how Tarantool maintains user data, see section :ref:`Users and the _user space <authentication-users>`."
msgstr ""

#: ../book/box/box_schema.rst:122
msgid "name of user, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:124
msgid "``if_not_exists``, ``password``"
msgstr ""

#: ../book/box/box_schema.rst:128 ../book/box/box_schema.rst:145
#: ../book/box/index.rst:667
msgid "**Examples:**"
msgstr "**Примеры:**"

#: ../book/box/box_schema.rst:130
msgid ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../book/box/box_schema.rst:138
msgid "Drop a user. For explanation of how Tarantool maintains user data, see section :ref:`Users and the _user space <authentication-users>`."
msgstr ""

#: ../book/box/box_schema.rst:142 ../book/box/box_schema.rst:156
#: ../book/box/box_schema.rst:173 ../book/box/box_schema.rst:204
msgid "the name of the user"
msgstr ""

#: ../book/box/box_schema.rst:143
msgid "``if_exists``"
msgstr ""

#: ../book/box/box_schema.rst:147
msgid ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../book/box/box_schema.rst:154
msgid "Return true if a user exists; return false if a user does not exist."
msgstr ""

#: ../book/box/box_schema.rst:157 ../book/box/box_schema.rst:314
#: ../book/box/box_schema.rst:436
msgid "bool"
msgstr ""

#: ../book/box/box_schema.rst:161
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../book/box/box_schema.rst:171
msgid "Grant :ref:`privileges <authentication-privileges>` to a user."
msgstr ""

#: ../book/box/box_schema.rst:174
msgid "'read' or 'write' or 'execute' or a combination,"
msgstr ""

#: ../book/box/box_schema.rst:175
msgid "'space' or 'function'."
msgstr ""

#: ../book/box/box_schema.rst:176
msgid "name of object to grant permissions to"
msgstr ""

#: ../book/box/box_schema.rst:177
msgid "name of role to grant to user."
msgstr ""

#: ../book/box/box_schema.rst:178
msgid "``grantor``, ``if_not_exists``"
msgstr ""

#: ../book/box/box_schema.rst:180
msgid "If :samp:`'function','{object-name}'` is specified, then a _func tuple with that object-name must exist."
msgstr ""

#: ../book/box/box_schema.rst:183 ../book/box/box_schema.rst:212
#: ../book/box/box_schema.rst:334 ../book/box/box_schema.rst:362
msgid "**Variation:** instead of ``object-type, object-name`` say 'universe' which means 'all object-types and all objects'."
msgstr ""

#: ../book/box/box_schema.rst:186 ../book/box/box_schema.rst:215
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""

#: ../book/box/box_schema.rst:191
msgid ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""

#: ../book/box/box_schema.rst:202
msgid "Revoke :ref:`privileges <authentication-privileges>` from a user."
msgstr ""

#: ../book/box/box_schema.rst:205 ../book/box/box_schema.rst:327
#: ../book/box/box_schema.rst:355
msgid "'read' or 'write' or 'execute' or a combination"
msgstr ""

#: ../book/box/box_schema.rst:206 ../book/box/box_schema.rst:328
#: ../book/box/box_schema.rst:356
msgid "'space' or 'function'"
msgstr ""

#: ../book/box/box_schema.rst:207 ../book/box/box_schema.rst:329
#: ../book/box/box_schema.rst:357
msgid "the name of a function or space"
msgstr ""

#: ../book/box/box_schema.rst:209
msgid "The user must exist, and the object must exist, but it is not an error if the user does not have the privilege."
msgstr ""

#: ../book/box/box_schema.rst:220
msgid ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:229
msgid "Return a hash of a password."
msgstr ""

#: ../book/box/box_schema.rst:231 ../book/box/box_schema.rst:250
msgid "password"
msgstr ""

#: ../book/box/box_schema.rst:236
msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

#: ../book/box/box_schema.rst:242
msgid "Associate a password with the user who is currently logged in. or with another user. Users who wish to change their own passwords should use box.schema.user.passwd(password). Administrators who wish to change passwords of other users should use box.schema.user.passwd(user-name, password)."
msgstr ""

#: ../book/box/box_schema.rst:249
msgid "user-name"
msgstr ""

#: ../book/box/box_schema.rst:254
msgid ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

#: ../book/box/box_schema.rst:261
msgid "Return a description of a user's privileges."
msgstr ""

#: ../book/box/box_schema.rst:263
msgid "the name of the user. This is optional; if it is not supplied, then the information will be for the user who is currently logged in."
msgstr ""

#: ../book/box/box_schema.rst:271
msgid ""
"box.schema.user.info()\n"
"box.schema.user.info('Lena')"
msgstr ""

#: ../book/box/box_schema.rst:278
msgid "Create a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../book/box/box_schema.rst:282
msgid "name of role, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:284
msgid "``if_not_exists``"
msgstr ""

#: ../book/box/box_schema.rst:290
msgid ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../book/box/box_schema.rst:297
msgid "Drop a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../book/box/box_schema.rst:301 ../book/box/box_schema.rst:313
#: ../book/box/box_schema.rst:326 ../book/box/box_schema.rst:354
msgid "the name of the role"
msgstr ""

#: ../book/box/box_schema.rst:305
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:311
msgid "Return true if a role exists; return false if a role does not exist."
msgstr ""

#: ../book/box/box_schema.rst:318
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:324
msgid "Grant :ref:`privileges <authentication-privileges>` to a role."
msgstr ""

#: ../book/box/box_schema.rst:330
msgid "{if_not_exists=true} or {if_not_exists=false}"
msgstr ""

#: ../book/box/box_schema.rst:332
msgid "The role must exist, and the object must exist."
msgstr ""

#: ../book/box/box_schema.rst:337
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name`` -- to grant a role to a role."
msgstr ""

#: ../book/box/box_schema.rst:342
msgid ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""

#: ../book/box/box_schema.rst:352
msgid "Revoke :ref:`privileges <authentication-privileges>` from a role."
msgstr ""

#: ../book/box/box_schema.rst:359
msgid "The role must exist, and the object must exist, but it is not an error if the role does not have the privilege."
msgstr ""

#: ../book/box/box_schema.rst:365
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name``."
msgstr ""

#: ../book/box/box_schema.rst:370
msgid ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:379
msgid "Return a description of a role's privileges."
msgstr ""

#: ../book/box/box_schema.rst:381
msgid "the name of the role."
msgstr ""

#: ../book/box/box_schema.rst:385
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:393
msgid "Create a function tuple. This does not create the function itself -- that is done with Lua -- but if it is necessary to grant privileges for a function, box.schema.func.create must be done first. For explanation of how Tarantool maintains function data, see section :ref:`Functions and the _func space <authentication-funcs>`."
msgstr ""

#: ../book/box/box_schema.rst:400
msgid "name of function, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:402
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr ""

#: ../book/box/box_schema.rst:408
msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../book/box/box_schema.rst:419
msgid "Drop a function tuple. For explanation of how Tarantool maintains function data, see section :ref:`Functions and the _func space <authentication-funcs>`."
msgstr ""

#: ../book/box/box_schema.rst:423 ../book/box/box_schema.rst:435
msgid "the name of the function"
msgstr ""

#: ../book/box/box_schema.rst:427
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../book/box/box_schema.rst:433
msgid "Return true if a function tuple exists; return false if a function tuple does not exist."
msgstr ""

#: ../book/box/box_schema.rst:440
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../book/box/box_session.rst:28
msgid "Submodule `box.session`"
msgstr "Вложенный модуль `box.session`"

#: ../book/box/box_session.rst:30
msgid "The ``box.session`` submodule allows querying the session state, writing to a session-specific temporary Lua table, or setting up triggers which will fire when a session starts or ends. A *session* is an object associated with each client connection."
msgstr ""

#: ../book/box/box_session.rst:39
msgid "the unique identifier (ID) for the current session. The result can be 0 meaning there is no session."
msgstr ""

#: ../book/box/box_session.rst:45
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../book/box/box_session.rst:50
msgid "This function works only if there is a peer, that is, if a connection has been made to a separate server."
msgstr ""

#: ../book/box/box_session.rst:53
msgid "The host address and port of the session peer, for example \"127.0.0.1:55457\". If the session exists but there is no connection to a separate server, the return is null. The command is executed on the server, so the \"local name\" is the server's host and port, and the \"peer name\" is the client's host and port."
msgstr ""

#: ../book/box/box_session.rst:63
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../book/box/box_session.rst:67
msgid "the value of the :code:`sync` integer constant used in the `binary protocol <https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants.h>`_."
msgstr ""

#: ../book/box/box_session.rst:77
msgid "A Lua table that can hold arbitrary unordered session-specific names and values, which will last until the session ends."
msgstr ""

#: ../book/box/atomic.rst:95 ../book/box/box_session.rst:82
#: ../book/box/box_tuple.rst:306 ../book/box/index.rst:159
#: ../book/box/triggers.rst:96 ../book/box/triggers.rst:214
msgid "Example"
msgstr "Пример"

#: ../book/box/box_session.rst:84
msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../book/box/box_session.rst:109
msgid "See the section :ref:`Triggers <triggers-box_triggers>` for instructions about defining triggers for connect and disconnect events with ``box.session.on_connect()`` and ``box.session.on_disconnect()``. See the section :ref:`Access control <authentication>` for instructions about ``box.session`` functions that affect user identification and security."
msgstr ""

#: ../book/box/box_space.rst:30
msgid "Submodule `box.space`"
msgstr "Вложенный модуль `box.space`"

#: ../book/box/box_space.rst:32
msgid "The ``box.space`` submodule has the data-manipulation functions ``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``get``, ``put``. It also has members, such as id, and whether or not a space is enabled. Submodule source code is available in file `src/box/lua/schema.lua <https://github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."
msgstr ""

#: ../book/box/box_space.rst:38
msgid "A list of all ``box.space`` functions follows, then comes a list of all ``box.space`` members."
msgstr ""

#: ../book/box/box_space.rst:43
msgid "**The functions and members of box.space**"
msgstr ""

#: ../book/box/box_space.rst:49
msgid "Use"
msgstr ""

#: ../book/box/box_space.rst:51
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../book/box/box_space.rst:51
msgid "Create an index"
msgstr ""

#: ../book/box/box_space.rst:54
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../book/box/box_space.rst:54
msgid "Insert a tuple"
msgstr ""

#: ../book/box/box_space.rst:57
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../book/box/box_space.rst:57
msgid "Select one or more tuples"
msgstr ""

#: ../book/box/box_space.rst:60
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../book/box/box_space.rst:60
msgid "Select a tuple"
msgstr ""

#: ../book/box/box_space.rst:63
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../book/box/box_space.rst:63
msgid "Destroy a space"
msgstr ""

#: ../book/box/box_space.rst:66
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../book/box/box_space.rst:66
msgid "Rename a space"
msgstr ""

#: ../book/box/box_space.rst:69
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../book/box/box_space.rst:69 ../book/box/box_space.rst:72
msgid "Insert or replace a tuple"
msgstr ""

#: ../book/box/box_space.rst:72
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../book/box/box_space.rst:75
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../book/box/box_space.rst:75 ../book/box/box_space.rst:78
msgid "Update a tuple"
msgstr ""

#: ../book/box/box_space.rst:78
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../book/box/box_space.rst:81
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../book/box/box_space.rst:81
msgid "Delete a tuple"
msgstr ""

#: ../book/box/box_space.rst:84
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../book/box/box_space.rst:84 ../book/box/box_space.rst:87
msgid "Get count of tuples"
msgstr ""

#: ../book/box/box_space.rst:87
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../book/box/box_space.rst:90
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../book/box/box_space.rst:90
msgid "Delete all tuples"
msgstr ""

#: ../book/box/box_space.rst:93
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../book/box/box_space.rst:93
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../book/box/box_space.rst:96
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../book/box/box_space.rst:96
msgid "Prepare for iterating"
msgstr ""

#: ../book/box/box_space.rst:99
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../book/box/box_space.rst:99
msgid ".Numeric identifier of space"
msgstr ""

#: ../book/box/box_space.rst:102
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../book/box/box_space.rst:102
msgid ".Flag, true if space is enabled"
msgstr ""

#: ../book/box/box_space.rst:105
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../book/box/box_space.rst:105
msgid ".Required number of fields"
msgstr ""

#: ../book/box/box_space.rst:108
msgid ":ref:`space_object.index <box_space-field_count>`"
msgstr ""

#: ../book/box/box_space.rst:108
msgid ".Container of space's indexes"
msgstr ""

#: ../book/box/box_space.rst:111
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../book/box/box_space.rst:111
msgid ".(Metadata) List of schemas"
msgstr ""

#: ../book/box/box_space.rst:114
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../book/box/box_space.rst:114
msgid ".(Metadata) List of spaces"
msgstr ""

#: ../book/box/box_space.rst:117
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../book/box/box_space.rst:117
msgid ".(Metadata) List of indexes"
msgstr ""

#: ../book/box/box_space.rst:120
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../book/box/box_space.rst:120
msgid ".(Metadata) List of users"
msgstr ""

#: ../book/box/box_space.rst:123
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../book/box/box_space.rst:123
msgid ".(Metadata) List of privileges"
msgstr ""

#: ../book/box/box_space.rst:126
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../book/box/box_space.rst:126
msgid ".(Metadata) List of clusters"
msgstr ""

#: ../book/box/box_space.rst:129
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ""

#: ../book/box/box_space.rst:129
msgid ".(Metadata) List of function tuples"
msgstr ""

#: ../book/box/box_space.rst:143
msgid "Create an index. It is mandatory to create an index for a tuple set before trying to insert tuples into it, or select tuples from it. The first created index, which will be used as the primary-key index, must be unique."
msgstr ""

#: ../book/box/box_space.rst:148
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`index_name` (type = string) = name of index, which should not be a number and should not contain special characters; :codeitalic:`options`."
msgstr ""

#: ../book/box/box_space.rst:153
msgid "index object"
msgstr ""

#: ../book/box/box_space.rst:154
msgid "index_object"
msgstr ""

#: ../book/box/box_space.rst:158
msgid "Options for ``space_object:create_index``:"
msgstr ""

#: ../book/box/box_space.rst:168
msgid "type"
msgstr ""

#: ../book/box/box_space.rst:168
msgid "type of index"
msgstr ""

#: ../book/box/box_space.rst:168
msgid "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE')"
msgstr ""

#: ../book/box/box_space.rst:168
msgid "'TREE'"
msgstr ""

#: ../book/box/box_space.rst:172
msgid "last index's id, +1"
msgstr ""

#: ../book/box/box_space.rst:174
msgid "unique"
msgstr ""

#: ../book/box/box_space.rst:174
msgid "index is unique"
msgstr ""

#: ../book/box/box_space.rst:174
msgid "``true``"
msgstr ""

#: ../book/box/box_space.rst:176
msgid "``false``"
msgstr ""

#: ../book/box/box_space.rst:179
msgid "parts"
msgstr ""

#: ../book/box/box_space.rst:179
msgid "field-numbers  + types"
msgstr ""

#: ../book/box/box_space.rst:179
msgid "{field_no, 'unsigned' or 'string' or 'integer' or 'number' or 'array' or 'scalar'}"
msgstr ""

#: ../book/box/box_space.rst:179
msgid "``{1, 'unsigned'}``"
msgstr ""

#: ../book/box/box_space.rst:185
msgid "Possible errors: too many parts. Index '...' already exists. Primary key must be unique."
msgstr ""

#: ../book/box/box_space.rst:187
msgid "Note re storage engine: vinyl supports only the TREE index type, and vinyl secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../book/box/box_space.rst:190
msgid ""
"tarantool> s = box.space.space55\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, 'unsigned', 2, 'string'}})\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:201
msgid "Details about index field types: |br| The six index field types (unsigned | string | integer | number | array | scalar) differ depending on what values are allowed, and what index types are allowed. |br| **unsigned**: unsigned integers between 0 and 18446744073709551615, about 18 quintillion. May also be called 'uint' or 'num', but 'num' is deprecated. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes. |br| **string**: any set of octets, up to the :ref:`maximum length <limitations_bytes_in_index_key>`. May also be called 'str'. Legal in memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes. |br| **integer**: integers between -9223372036854775808 and 18446744073709551615. May also be called 'int'. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes. |br| **number**: integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, or double-precision floating point numbers. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes. |br| **array**: array of integers between -9223372036854775808 and 9223372036854775807. Legal in memtx RTREE indexes. |br| **scalar**: booleans (true or false), or integers between -9223372036854775808 and 18446744073709551615, or single-precision floating point numbers, or double-precison floating-point numbers, or strings. When there is a mix of types, the key order is: booleans, then numbers, then strings. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../book/box/box_space.rst:225
msgid "**Index field types to use in create_index**"
msgstr ""

#: ../book/box/box_space.rst:234
msgid "Index field type"
msgstr "Тип поля для индексирования"

#: ../book/box/box_space.rst:234
msgid "What can be in it"
msgstr ""

#: ../book/box/box_space.rst:234
msgid "Where is it legal"
msgstr ""

#: ../book/box/box_space.rst:234
msgid "Examples"
msgstr "Примеры:"

#: ../book/box/box_space.rst:236
msgid "**unsigned**"
msgstr ""

#: ../book/box/box_space.rst:236
msgid "integers between 0 and 18446744073709551615"
msgstr ""

#: ../book/box/box_space.rst:236 ../book/box/box_space.rst:243
#: ../book/box/box_space.rst:247 ../book/box/box_space.rst:259
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr ""

#: ../book/box/box_space.rst:236
msgid "123456 |br|"
msgstr "123456 |br|"

#: ../book/box/box_space.rst:240
msgid "**string**"
msgstr ""

#: ../book/box/box_space.rst:240
msgid "strings -- any set of octets"
msgstr ""

#: ../book/box/box_space.rst:240
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr ""

#: ../book/box/box_space.rst:240
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr ""

#: ../book/box/box_space.rst:243
msgid "**integer**"
msgstr ""

#: ../book/box/box_space.rst:243
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr ""

#: ../book/box/box_space.rst:243
msgid "-2^63 |br|"
msgstr ""

#: ../book/box/box_space.rst:247
msgid "**number**"
msgstr ""

#: ../book/box/box_space.rst:247
msgid "integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, double-precision floating point numbers"
msgstr ""

#: ../book/box/box_space.rst:247
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr ""

#: ../book/box/box_space.rst:255
msgid "**array**"
msgstr ""

#: ../book/box/box_space.rst:255
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""

#: ../book/box/box_space.rst:255
msgid "memtx RTREE indexes"
msgstr ""

#: ../book/box/box_space.rst:255
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr ""

#: ../book/box/box_space.rst:259
msgid "**scalar**"
msgstr "**scalar**"

#: ../book/box/box_space.rst:259
msgid "booleans (true or false), integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, double-precision floating point numbers, strings"
msgstr ""

#: ../book/box/box_space.rst:259
msgid "true |br| -1 |br| 1.234 |br| '' |br| '俄國'"
msgstr ""

#: ../book/box/box_space.rst:273
msgid "Insert a tuple into a space."
msgstr ""

#: ../book/box/box_space.rst:275 ../book/box/box_space.rst:454
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`tuple` (type = Lua table or tuple) = tuple to be inserted."
msgstr ""

#: ../book/box/box_space.rst:278
msgid "the inserted tuple"
msgstr ""

#: ../book/box/box_space.rst:281
msgid "Possible errors: If a tuple with the same unique-key value already exists, returns :errcode:`ER_TUPLE_FOUND`."
msgstr ""

#: ../book/box/box_space.rst:286
msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:297
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../book/box/box_space.rst:303
msgid "the tuples whose primary-key fields are equal to the passed field-values. If the number of passed field-values is less than the number of fields in the primary key, then only the passed field-values are compared, so ``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../book/box/box_space.rst:310
msgid "Possible errors: No such space; wrong type."
msgstr ""

#: ../book/box/box_space.rst:312
msgid "**Complexity Factors:** Index size, Index type."
msgstr ""

#: ../book/box/box_space.rst:316
msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, 'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:361
msgid "For examples of complex ``select`` requests, where one can specify which index to search and what condition to use (for example \"greater than\" instead of \"equal to\") and how many tuples to return, see the later section :ref:`index_object:select <box_index-select>`."
msgstr ""

#: ../book/box/box_space.rst:370
msgid "Search for a tuple in the given space."
msgstr ""

#: ../book/box/box_space.rst:376
msgid "the tuple whose index key matches :codeitalic:`key`, or null."
msgstr ""

#: ../book/box/box_space.rst:379 ../book/box/box_space.rst:408
msgid "Possible errors: If space_object does not exist."
msgstr ""

#: ../book/box/box_space.rst:381 ../book/box/box_space.rst:410
#: ../book/box/box_space.rst:464 ../book/box/box_space.rst:846
msgid "**Complexity Factors:** Index size, Index type, Number of indexes accessed, WAL settings."
msgstr ""

#: ../book/box/box_space.rst:384
msgid "The ``box.space...select`` function returns a set of tuples as a Lua table; the ``box.space...get`` function returns at most a single tuple. And it is possible to get the first tuple in a tuple set by appending ``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as ``box.space.tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""

#: ../book/box/box_space.rst:394
msgid "box.space.tester:get{1}"
msgstr ""

#: ../book/box/box_space.rst:402
msgid "Drop a space."
msgstr ""

#: ../book/box/box_space.rst:404 ../book/box/box_space.rst:687
#: ../book/box/box_space.rst:705 ../book/box/box_space.rst:725
#: ../book/box/box_space.rst:742 ../book/box/box_space.rst:782
#: ../book/box/box_space.rst:804 ../book/box/box_space.rst:870
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`."
msgstr ""

#: ../book/box/box_space.rst:415
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../book/box/box_space.rst:423
msgid "Rename a space."
msgstr ""

#: ../book/box/box_space.rst:425
msgid "Parameters::samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`space-name` (type = string) = new name for space."
msgstr ""

#: ../book/box/box_space.rst:430
msgid "Possible errors: space_object does not exist."
msgstr ""

#: ../book/box/box_space.rst:434
msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:448
msgid "Insert a tuple into a space. If a tuple with the same primary key already exists, ``box.space...:replace()`` replaces the existing tuple with a new one. The syntax variants ``box.space...:replace()`` and ``box.space...:put()`` have the same effect; the latter is sometimes used to show that the effect is the converse of ``box.space...:get()``."
msgstr ""

#: ../book/box/box_space.rst:457 ../book/box/box_space.rst:843
msgid "the inserted tuple."
msgstr ""

#: ../book/box/box_space.rst:460
msgid "Possible errors: If a different tuple with the same unique-key value already exists, returns :errcode:`ER_TUPLE_FOUND`. (This will only happen if there is a unique secondary index.)"
msgstr ""

#: ../book/box/box_space.rst:469
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../book/box/box_space.rst:479
msgid "The ``update`` function supports operations on fields — assignment, arithmetic (if the field is numeric), cutting and pasting fragments of a field, deleting or inserting a field. Multiple operations can be combined in a single update request, and in this case they are performed atomically and sequentially. Each operation requires specification of a field number. When multiple operations are present, the field number for each operation is assumed to be relative to the most recent state of the tuple, that is, as if all previous operations in a multi-operation update have already been applied. In other words, it is always safe to merge multiple ``update`` invocations into a single invocation, with no change in semantics."
msgstr ""

#: ../book/box/box_space.rst:491
msgid "Possible operators are:"
msgstr ""

#: ../book/box/box_space.rst:493
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../book/box/box_space.rst:494
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../book/box/box_space.rst:495
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:496
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:497
msgid "``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:498
msgid "``:`` for string splice"
msgstr ""

#: ../book/box/box_space.rst:499
msgid "``!`` for insertion"
msgstr ""

#: ../book/box/box_space.rst:500
msgid "``#`` for deletion"
msgstr ""

#: ../book/box/box_space.rst:501
msgid "``=`` for assignment"
msgstr ""

#: ../book/box/box_space.rst:503
msgid "For ``!`` and ``=`` operations the field number can be ``-1``, meaning the last field in the tuple."
msgstr ""

#: ../book/box/box_space.rst:506
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = primary-key field values, must be passed as a Lua table if key is multi-part; :codeitalic:`{operator, field_no, value}` (type = table): a group of arguments for each operation, indicating what the operation is, what field the operation will apply to, and what value will be applied. The field number can be negative, meaning the position from the end of tuple (#tuple + negative field number + 1)."
msgstr ""

#: ../book/box/box_space.rst:518
msgid "Possible errors: it is illegal to modify a primary-key field."
msgstr ""

#: ../book/box/box_space.rst:520
msgid "**Complexity Factors:** Index size, Index type, number of indexes accessed, WAL settings."
msgstr ""

#: ../book/box/box_space.rst:523
msgid "Thus, in the instruction:"
msgstr ""

#: ../book/box/box_space.rst:525
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../book/box/box_space.rst:529
msgid "the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` meaning *add a value to a field and then assign a value to a field*, the first affected field is field ``1`` and the value which will be added to it is ``55``, the second affected field is field ``3`` and the value which will be assigned to it is ``'x'``."
msgstr ""

#: ../book/box/box_space.rst:537
msgid "Assume that initially there is a space named ``tester`` with a primary-key index whose type is ``unsigned``. There is one tuple, with ``field[1]`` = ``999`` and ``field[2]`` = ``'A'``."
msgstr ""

#: ../book/box/box_space.rst:541
msgid "In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` |br| The first argument is ``tester``, that is, the affected space is ``tester``. The second argument is ``999``, that is, the affected tuple is identified by primary key value = 999. The third argument is ``=``, that is, there is one operation — *assignment to a field*. The fourth argument is ``2``, that is, the affected field is ``field[2]``. The fifth argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'``."
msgstr ""

#: ../book/box/box_space.rst:552
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` |br| the arguments are the same, except that the key is passed as a Lua table (inside braces). This is unnecessary when the primary key has only one field, but would be necessary if the primary key had more than one field. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../book/box/box_space.rst:559
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` |br| the arguments are the same, except that the fourth argument is ``3``, that is, the affected field is ``field[3]``. It is okay that, until now, ``field[3]`` has not existed. It gets added. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``1``."
msgstr ""

#: ../book/box/box_space.rst:566
msgid "In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` |br| the arguments are the same, except that the third argument is ``'+'``, that is, the operation is addition rather than assignment. Since ``field[3]`` previously contained ``1``, this means we're adding ``1`` to ``1``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../book/box/box_space.rst:574
msgid "In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', 2, 'C'}})`` |br| the idea is to modify two fields at once. The formats are ``'|'`` and ``=``, that is, there are two operations, OR and assignment. The fourth and fifth arguments mean that ``field[3]`` gets OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]`` gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""

#: ../book/box/box_space.rst:583
msgid "In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', 2, 3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` from ``field[3]``. But after the delete, there is a renumbering, so ``field[3]`` becomes ``field[2]``` before we subtract ``3`` from it, and that's why the seventh argument is ``2``, not ``3``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../book/box/box_space.rst:591
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})`` |br| we're making a long string so that splice will work in the next example. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../book/box/box_space.rst:596
msgid "In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, '!!'}})`` |br| The third argument is ``':'``, that is, this is the example of splice. The fourth argument is ``2`` because the change will occur in ``field[2]``. The fifth argument is 2 because deletion will begin with the second byte. The sixth argument is 1 because the number of bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'`` is to be added at this position. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../book/box/box_space.rst:609
msgid "Update or insert a tuple."
msgstr ""

#: ../book/box/box_space.rst:611
msgid "If there is an existing tuple which matches the key fields of ``tuple_value``, then the request has the same effect as :ref:`space_object:update() <box_space-update>` and the ``{{operator, field_no, value}, ...}`` parameter is used. If there is no existing tuple which matches the key fields of ``tuple_value``, then the request has the same effect as :ref:`space_object:insert() <box_space-insert>` and the ``{tuple_value}`` parameter is used. However, unlike ``insert`` or ``update``, ``upsert`` will not read a tuple and perform error checks before returning -- this is a design feature which enhances throughput but requires more caution on the part of the user."
msgstr ""

#: ../book/box/box_space.rst:621
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :samp:`{tuple_value}` (type = Lua table or scalar) = field values, must be passed as a Lua table; :codeitalic:`{operator, field_no, value}` (type = Lua table) = a group of arguments for each operation, indicating what the operation is, what field the operation will apply to, and what value will be applied. The field number can be negative, meaning the position from the end of the tuple (#tuple + negative field number + 1)."
msgstr ""

#: ../book/box/box_space.rst:630
msgid "null."
msgstr ""

#: ../book/box/box_space.rst:632
msgid "Possible errors: it is illegal to modify a primary-key field. It is illegal to use upsert with a space that has a unique secondary index."
msgstr ""

#: ../book/box/box_space.rst:635
msgid "**Complexity factors:** Index size, Index type, number of indexes accessed, WAL settings."
msgstr ""

#: ../book/box/box_space.rst:640
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../book/box/box_space.rst:648
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../book/box/box_space.rst:650
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>` :codeitalic:`key` (type = Lua table or scalar) = key to be matched against the index key, which may be multi-part."
msgstr ""

#: ../book/box/box_space.rst:654
msgid "the deleted tuple"
msgstr ""

#: ../book/box/box_space.rst:657
msgid "**Complexity Factors:** Index size, Index type"
msgstr ""

#: ../book/box/box_space.rst:659
msgid "Note re storage engine: vinyl will return ``nil``, rather than the deleted tuple."
msgstr ""

#: ../book/box/box_space.rst:663
msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:682
msgid "Ordinal space number. Spaces can be referenced by either name or number. Thus, if space ``tester`` has ``id = 800``, then ``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are equivalent requests."
msgstr ""

#: ../book/box/box_space.rst:691
msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:702
msgid "Whether or not this space is enabled. The value is ``false`` if the space has no index."
msgstr ""

#: ../book/box/box_space.rst:711
msgid "The required field count for all tuples in this space. The field_count can be set initially with:"
msgstr ""

#: ../book/box/box_space.rst:717
msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../book/box/box_space.rst:723
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../book/box/box_space.rst:729
msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:738
msgid "A container for all defined indexes. There is a Lua object of type :ref:`box.index <box_index>` with methods to search tuples and iterate over them in predefined order."
msgstr ""

#: ../book/box/box_space.rst:748
msgid ""
"tarantool> #box.space.tester.index\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:763
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = key to be matched against the primary index key, which may be multi-part; :codeitalic:`iterator` = comparison method."
msgstr ""

#: ../book/box/box_space.rst:767
msgid "Number of tuples."
msgstr ""

#: ../book/box/box_space.rst:771
msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:784
msgid "Number of tuples in the space."
msgstr ""

#: ../book/box/box_space.rst:788
msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:795
msgid "Note re storage engine: vinyl does not support ``len()``.  One possible workaround is to say ``#select(...)``."
msgstr ""

#: ../book/box/box_space.rst:802
msgid "Deletes all tuples. ."
msgstr ""

#: ../book/box/box_space.rst:806
msgid "**Complexity Factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../book/box/box_space.rst:812
msgid "Note that ``truncate`` must be called only by the user who created the space OR under a `setuid` function created by that user. Read more about `setuid` functions :ref:`here <authentication-funcs>`"
msgstr ""

#: ../book/box/box_space.rst:816
msgid "Note re storage engine: vinyl does not support ``truncate()``."
msgstr ""

#: ../book/box/box_space.rst:820
msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:834
msgid "Insert a new tuple using an auto-increment primary key. The space specified by space_object must have an ``unsigned`` or ``integer`` or ``numeric`` primary key index of type ``TREE``. The primary-key field will be incremented before the insert."
msgstr ""

#: ../book/box/box_space.rst:838
msgid "Note re storage engine: vinyl does not support ``auto_increment()``."
msgstr ""

#: ../book/box/box_space.rst:840
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <index-object_reference>`; :codeitalic:`field-value(s)` (type = Lua table or scalar) = tuple's fields, other than the primary-key field."
msgstr ""

#: ../book/box/box_space.rst:849
msgid "Possible errors: index has wrong type or primary-key indexed field is not a number."
msgstr ""

#: ../book/box/box_space.rst:853
msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:868
msgid "A helper function to prepare for iterating over all tuples in a space."
msgstr ""

#: ../book/box/box_space.rst:872
msgid "function which can be used in a for/end loop. Within the loop, a value is returned for each iteration."
msgstr ""

#: ../book/box/box_space.rst:877
msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:908
msgid "``_schema`` is a system tuple set. Its single tuple contains these fields: ``'version', major-version-number, minor-version-number``."
msgstr ""

#: ../book/box/box_space.rst:913
msgid "The following function will display all fields in all tuples of ``_schema``:"
msgstr ""

#: ../book/box/box_space.rst:915
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._schema:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      line = line .. v[i] .. ' '\n"
"      i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:932 ../book/box/box_space.rst:976
#: ../book/box/box_space.rst:1071
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../book/box/box_space.rst:934
msgid ""
"tarantool> example()\n"
"---\n"
"- - 'cluster 1ec4e1f8-8f1b-4304-bb22-6c47ce0cf9c6 '\n"
"  - 'max_id 520 '\n"
"  - 'version 1 7 0 '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:947
msgid "``_space`` is a system tuple set. Its tuples contain these fields: ``id``, ``owner`` (= id of user who owns the space), ``name``, ``engine``, ``field_count``, ``flags`` (e.g. temporary), ``format``. These fields are established by :ref:`space.create() <box_schema-space_create>`."
msgstr ""

#: ../book/box/box_space.rst:955
msgid "The following function will display all simple fields in all tuples of ``_space``."
msgstr ""

#: ../book/box/box_space.rst:957
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:978
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:999
msgid "The following requests will create a space using ``box.schema.space.create`` with a ``format`` clause. Then it retrieves the _space tuple for the new space. This illustrates the typical use of the ``format`` clause, it shows the recommended names and data types for the fields."
msgstr ""

#: ../book/box/box_space.rst:1005
msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': 'unsigned'}]]\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:1034
msgid "``_index`` is a system tuple set. Its tuples contain these fields: ``id`` (= id of space), ``iid`` (= index number within space), ``name``, ``type``, ``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` ...]."
msgstr ""

#: ../book/box/box_space.rst:1039
msgid "The following function will display all fields in all tuples of ``_index``: (notice that the fifth field gets special treatment as a map value and the sixth or later fields get special treatment as arrays):"
msgstr ""

#: ../book/box/box_space.rst:1043
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line, value\n"
"  for k, v in box.space._index:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"     while v[i] ~= nil do\n"
"      if i < 5 then\n"
"        value = v[i]\n"
"        end\n"
"      if i == 5 then\n"
"        if v[i].unique == true then\n"
"          value = 'true'\n"
"          end\n"
"        end\n"
"      if i > 5 then\n"
"        value = v[i][1][1] .. ' ' .. v[i][1][2]\n"
"        end\n"
"      line = line .. value .. ' '\n"
"      i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"    end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:1073
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 0 primary tree true 0 str '\n"
"  - '280 0 primary tree true 0 num '\n"
"  - '280 1 owner tree tree 1 num '\n"
"  - '280 2 name tree true 2 str '\n"
"  - '281 0 primary tree true 0 num '\n"
"  - '281 1 owner tree tree 1 num '\n"
"  - '281 2 name tree true 2 str '\n"
"  - '288 0 primary tree true 0 num '\n"
"  - '288 2 name tree true 0 num '\n"
"  - '289 0 primary tree true 0 num '\n"
"  - '289 2 name tree true 0 num '\n"
"  - '296 0 primary tree true 0 num '\n"
"  - '296 1 owner tree tree 1 num '\n"
"  - '296 2 name tree true 2 str '\n"
"  - '297 0 primary tree true 0 num '\n"
"  - '297 1 owner tree tree 1 num '\n"
"  - '297 2 name tree true 2 str '\n"
"  - '304 0 primary tree true 0 num '\n"
"  - '304 1 owner tree tree 1 num '\n"
"  - '304 2 name tree true 2 str '\n"
"  - '305 0 primary tree true 0 num '\n"
"  - '305 1 owner tree tree 1 num '\n"
"  - '305 2 name tree true 2 str '\n"
"  - '312 0 primary tree true 1 num '\n"
"  - '312 1 owner tree tree 0 num '\n"
"  - '312 2 object tree tree 2 str '\n"
"  - '313 0 primary tree true 1 num '\n"
"  - '313 1 owner tree tree 0 num '\n"
"  - '313 2 object tree tree 2 str '\n"
"  - '320 0 primary tree true 0 num '\n"
"  - '320 1 uuid tree true 1 str '\n"
"  - '512 0 primary tree true 0 num '\n"
"  - '513 0 primary tree true 0 num '\n"
"  - '516 0 primary tree true 0 STR '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:1117
msgid "``_user`` is a system tuple set for support of the :ref:`authorization feature <authentication>`."
msgstr ""

#: ../book/box/box_space.rst:1124
msgid "``_priv`` is a system tuple set for support of the :ref:`authorization feature <authentication>`."
msgstr ""

#: ../book/box/box_space.rst:1131
msgid "``_cluster`` is a system tuple set for support of the :ref:`replication feature <index-box_replication>`."
msgstr ""

#: ../book/box/box_space.rst:1138
msgid "``_func`` is a system tuple set with function tuples made by :ref:`box.schema.func.create <box_schema-func_create>`."
msgstr ""

#: ../book/box/box_space.rst:1143
msgid "Example: use box.space functions to read _space tuples"
msgstr ""

#: ../book/box/box_space.rst:1145
msgid "This function will illustrate how to look at all the spaces, and for each display: approximately how many tuples it contains, and the first field of its first tuple. The function uses Tarantool ``box.space`` functions ``len()`` and ``pairs()``. The iteration through the spaces is coded as a scan of the ``_space`` system tuple set, which contains metadata. The third field in ``_space`` contains the space name, so the key instruction ``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in the tuple of ``_space`` that we've just fetched with ``pairs()``. The function returns a table:"
msgstr ""

#: ../book/box/box_space.rst:1155
msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:1179
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../book/box/box_space.rst:1181
msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:1201
msgid "Example: use box.space functions to organize a _space tuple"
msgstr ""

#: ../book/box/box_space.rst:1203
msgid "The objective is to display field names and field types of a system space -- using metadata to find metadata."
msgstr ""

#: ../book/box/box_space.rst:1206
msgid "To begin: how can one select the _space tuple that describes _space?"
msgstr ""

#: ../book/box/box_space.rst:1208
msgid "A simple way is to look at the constants in box.schema, which tell us that there is an item named SPACE_ID == 288, so these statements will retrieve the correct tuple: |br| :codenormal:`box.space._space:select{288}` |br| or |br| :codenormal:`box.space._space:select{box.schema.SPACE_ID}` |br|"
msgstr ""

#: ../book/box/box_space.rst:1215
msgid "Another way is to look at the tuples in box.space._index, which tell us that there is a secondary index named 'name' for space number 288, so this statement also will retrieve the correct tuple: |br| :codenormal:`box.space._space.index.name:select{'_space'}`"
msgstr ""

#: ../book/box/box_space.rst:1220
msgid "However, the retrieved tuple is not easy to read: |br| :codenormal:`tarantool>` :codebold:`box.space._space.index.name:select{'_space'}` |br| :codenormal:`---` |br| :codenormal:`- - [280, 1, '_space', 'memtx', 0, '', [{'name': 'id',` |br| |nbsp| |nbsp| |nbsp| :codenormal:`'type': 'num'}, {'name': 'owner','type': 'num'},` |br| |nbsp| |nbsp| |nbsp| :codenormal:`{'name': 'name','type': 'str'}, {'name': 'engine',` |br| |nbsp| |nbsp| |nbsp| :codenormal:`'type': 'str'},{'name': 'field_count', 'type': 'num'},` |br| |nbsp| |nbsp| |nbsp| :codenormal:`{'name': 'flags','type': 'str'}, {'name': 'format',` |br| |nbsp| |nbsp| |nbsp| :codenormal:`'type': '*'}]]` |br| |nbsp| |nbsp| |nbsp| :codenormal:`...`"
msgstr ""

#: ../book/box/box_space.rst:1231
msgid "It looks disorganized because field number 7 has been formatted with recommended names and data types. How can one get those specific sub-fields? Since it's visible that field number 7 is an array of maps, this `for` loop will do the organizing: |br| :codenormal:`local tuple_of_space, field_name, field_type` |br| :codenormal:`tuple_of_space = box.space._space.index.name:select{'_space'}[1]` |br| :codenormal:`for i = 1, #tuple_of_space[7], 1` |br| :codenormal:`do` |br| |nbsp| |nbsp| |nbsp| :codenormal:`field_name = tuple_of_space[7][i]['name']` |br| |nbsp| |nbsp| |nbsp| :codenormal:`field_type = tuple_of_space[7][i]['type']` |br| |nbsp| |nbsp| |nbsp| :codenormal:`print(field_name .. ',' ..field_type)` |br| :codenormal:`end`"
msgstr ""

#: ../book/box/box_space.rst:1245
msgid "And here is what happens when one executes the `for` loop: |br| :codenormal:`id,num` |br| :codenormal:`owner,num` |br| :codenormal:`name,str` |br| :codenormal:`engine,str` |br| :codenormal:`field_count,num` |br| :codenormal:`flags,str` |br| :codenormal:`format,*`"
msgstr ""

#: ../book/box/box_tuple.rst:30
msgid "Submodule `box.tuple`"
msgstr "Вложенный модуль `box.tuple`"

#: ../book/box/box_tuple.rst:34
msgid "The ``box.tuple`` submodule provides read-only access for the ``tuple`` userdata type. It allows, for a single tuple: selective retrieval of the field contents, retrieval of information about size, iteration over all the fields, and conversion to a Lua table."
msgstr ""

#: ../book/box/box_tuple.rst:43
msgid "Construct a new tuple from either a scalar or a Lua table. Alternatively, one can get new tuples from tarantool's :ref:`select <box_space-select>` or :ref:`insert <box_space-insert>` or :ref:`replace <box_space-replace>` or :ref:`update <box_space-update>` requests, which can be regarded as statements that do ``new()`` implicitly."
msgstr ""

#: ../book/box/box_tuple.rst:50
msgid "the value that will become the tuple contents."
msgstr ""

#: ../book/box/box_tuple.rst:52
msgid "a new tuple"
msgstr ""

#: ../book/box/box_tuple.rst:55
msgid "In the following example, ``x`` will be a new table object containing one tuple and ``t`` will be a new tuple object. Saying ``t`` returns the entire tuple ``t``."
msgstr ""

#: ../book/box/box_tuple.rst:61
msgid ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:82
msgid "The ``#`` operator in Lua means \"return count of components\". So, if ``t`` is a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../book/box/box_tuple.rst:87
msgid "In the following example, a tuple named ``t`` is created and then the number of fields in ``t`` is returned."
msgstr ""

#: ../book/box/box_tuple.rst:90
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:102
msgid "If ``t`` is a tuple instance, ``t:bsize()`` will return the number of bytes in the tuple. It is useful to check this number when making changes to data, because there is a fixed maximum: one megabyte. Every field has one or more \"length\" bytes preceding the actual contents, so ``bsize()`` returns a value which is slightly greater than the sum of the lengths of the contents."
msgstr ""

#: ../book/box/box_tuple.rst:112
msgid "In the following example, a tuple named ``t`` is created which has three fields, and for each field it takes one byte to store the length and three bytes to store the contents, and a bit for overhead, so ``bsize()`` returns ``3*(1+3)+1``."
msgstr ""

#: ../book/box/box_tuple.rst:117
msgid ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:129
msgid "If ``t`` is a tuple instance, ``t[field-number]`` will return the field numbered field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../book/box/box_tuple.rst:132
msgid "field value."
msgstr ""

#: ../book/box/box_tuple.rst:133
msgid "lua-value"
msgstr ""

#: ../book/box/box_tuple.rst:135
msgid "In the following example, a tuple named ``t`` is created and then the second field in ``t`` is returned."
msgstr ""

#: ../book/box/box_tuple.rst:138
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:151
msgid "If ``t`` is a tuple instance, ``t:find(search-value)`` will return the number of the first field in ``t`` that matches the search value, and ``t:findall(search-value [, search-value ...])`` will return numbers of all fields in ``t`` that match the search value. Optionally one can put a numeric argument ``field-number`` before the search-value to indicate “start searching at field number ``field-number``.”"
msgstr ""

#: ../book/box/box_tuple.rst:158
msgid "the number of the field in the tuple."
msgstr ""

#: ../book/box/box_tuple.rst:161
msgid "In the following example, a tuple named ``t`` is created and then: the number of the first field in ``t`` which matches 'a' is returned, then the numbers of all the fields in ``t`` which match 'a' are returned, then the numbers of all the fields in t which match 'a' and are at or after the second field are returned."
msgstr ""

#: ../book/box/box_tuple.rst:167
msgid ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:188
msgid "If ``t`` is a tuple instance, :samp:`t:transform({start-field-number},{fields-to-remove})` will return a tuple where, starting from field ``start-field-number``, a number of fields (``fields-to-remove``) are removed. Optionally one can add more arguments after ``fields-to-remove`` to indicate new values that will replace what was removed."
msgstr ""

#: ../book/box/box_tuple.rst:194
msgid "base 1, may be negative"
msgstr ""

#: ../book/box/box_tuple.rst:200
msgid "In the following example, a tuple named ``t`` is created and then, starting from the second field, two fields are removed but one new one is added, then the result is returned."
msgstr ""

#: ../book/box/box_tuple.rst:204
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:216
msgid "If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, ``t:unpack(1)`` will return all fields starting with field number 1, ``t:unpack(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../book/box/box_tuple.rst:220
msgid "field(s) from the tuple."
msgstr ""

#: ../book/box/box_tuple.rst:221
msgid "lua-value(s)"
msgstr ""

#: ../book/box/box_tuple.rst:223
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected, then the result is returned."
msgstr ""

#: ../book/box/box_tuple.rst:226
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:242
msgid "In Lua, ``lua-table-value:pairs()`` is a method which returns: ``function``, ``lua-table-value``, ``nil``. Tarantool has extended this so that ``tuple-value:pairs()`` returns: ``function``, ``tuple-value``, ``nil``. It is useful for Lua iterators, because Lua iterators traverse a value's components until an end marker is reached."
msgstr ""

#: ../book/box/box_tuple.rst:248
msgid "function, tuple-value, nil"
msgstr ""

#: ../book/box/box_tuple.rst:249
msgid "function, lua-value, nil"
msgstr ""

#: ../book/box/box_tuple.rst:251
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected using a Lua for-end loop."
msgstr ""

#: ../book/box/box_tuple.rst:254
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:276
msgid "This function updates a tuple which is not in a space. Compare the function :code:`box.space.`:samp:`{space-name}`:code:`:update{`:samp:`{key}, {format},` :code:`{`:samp:`{field_number}, {value}`:code:`}...)`, which updates a tuple in a space."
msgstr ""

#: ../book/box/box_tuple.rst:280
msgid "Parameters: briefly: ``format`` indicates the type of update operation such as '``=``' for 'assign new value', ``field_number`` indicates the field number to change such as 2 for field number 2, ``value`` indicates the string which operates on the field such as 'B' for a new assignable value = 'B'."
msgstr ""

#: ../book/box/box_tuple.rst:285
msgid "For details: see the description for ``format``, ``field_number``, and ``value`` in the section :ref:`box.space.space-name:update{key, format, {field_number, value}...) <box_space-update>`."
msgstr ""

#: ../book/box/box_tuple.rst:288
msgid "new tuple"
msgstr ""

#: ../book/box/box_tuple.rst:291
msgid "In the following example, a tuple named ``t`` is created and then its second field is updated to equal 'B'."
msgstr ""

#: ../book/box/box_tuple.rst:294
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:update({{'=',2,'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:308
msgid "This function will illustrate how to convert tuples to/from Lua tables and lists of scalars:"
msgstr ""

#: ../book/box/box_tuple.rst:311
msgid ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to tuple"
msgstr ""

#: ../book/box/box_tuple.rst:318
msgid "Then it will find the field that contains 'b', remove that field from the tuple, and display how many bytes remain in the tuple. The function uses Tarantool ``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, ``transform()``, ``bsize()``."
msgstr ""

#: ../book/box/box_tuple.rst:323
msgid ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = {tuple1:unpack()}\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1)\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../book/box/box_tuple.rst:339
msgid ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../book/box/index.rst:30
msgid "Database"
msgstr "Функционал СУБД"

#: ../book/box/index.rst:34
msgid "Data model"
msgstr "Модель данных"

#: ../book/box/index.rst:36
msgid "This section describes how Tarantool stores values and what operations with data it supports."
msgstr "В этом разделе описывается то, как в Tarantool'е организовано хранение данных и какие операции с данным он поддерживает."

#: ../book/box/index.rst:39
msgid "If you tried out the :ref:`Starting Tarantool and making your first database <user_guide_getting_started-first_database>` exercise from the last chapter, then your database looks like this:"
msgstr "Если вы уже выполнили тестовое задание из раздела :ref:`Первичный запуск Tarantool'а и создание базы данных <user_guide_getting_started-first_database>` в предыдущей главе, то ваша база данных имеет следующий вид:"

#: ../book/box/index.rst:43
msgid ""
"+--------------------------------------------+\n"
"|                                            |\n"
"| SPACE 'tester'                             |\n"
"| +----------------------------------------+ |\n"
"| |                                        | |\n"
"| | TUPLE SET 'tester'                     | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Tuple: [ 1 ]                      |  | |\n"
"| | | Tuple: [ 2, 'Music' ]             |  | |\n"
"| | | Tuple: [ 3, 'length', 93 ]        |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| | INDEX 'primary'                        | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Key: 1                            |  | |\n"
"| | | Key: 2                            |  | |\n"
"| | | Key: 3                            |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| +----------------------------------------+ |\n"
"+--------------------------------------------+"
msgstr ""
"+--------------------------------------------+\n"
"|                                            |\n"
"| ПРОСТРАНСТВО 'tester'                      |\n"
"| +----------------------------------------+ |\n"
"| |                                        | |\n"
"| | НАБОР КОРТЕЖЕЙ 'tester'                | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Кортеж: [ 1 ]                     |  | |\n"
"| | | Кортеж: [ 2, 'Music' ]            |  | |\n"
"| | | Кортеж: [ 3, 'length', 93 ]       |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| | ИНДЕКС 'primary'                       | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Ключ: 1                           |  | |\n"
"| | | Ключ: 2                           |  | |\n"
"| | | Ключ: 3                           |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| +----------------------------------------+ |\n"
"+--------------------------------------------+"

#: ../book/box/index.rst:69
msgid "Space"
msgstr "Пространство"

#: ../book/box/index.rst:71
msgid "A *space* -- 'tester' in the example -- is a container."
msgstr "*Пространство* с именем 'tester' в нашем примере — это контейнер."

#: ../book/box/index.rst:73
msgid "When Tarantool is being used to store data, there is always at least one space. There can be many spaces. Each space has a unique name specified by the user. Each space has a unique numeric identifier which can be specified by the user but usually is assigned automatically by Tarantool. Spaces always contain one tuple set and one or more indexes."
msgstr "Когда Tarantool используется для хранения данных, то он создает по меньшей мере одно пространство (space). В общем же случае пространств может быть много. Каждое пространство имеет уникальное имя, заданное пользователем, а также уникальный числовой идентификатор, который тоже может быть задан пользователем, но обычно назначается автоматически самим Tarantool'ом. Пространство всегда содержит один набор кортежей и один или более индексов."

#: ../book/box/index.rst:81
msgid "Tuple set"
msgstr "Набор кортежей"

#: ../book/box/index.rst:83
msgid "A *tuple set* -- 'tester' in the example -- is a group of tuples."
msgstr "*Набор кортежей* — в нашем примере он назван 'tester' — это группа кортежей."

#: ../book/box/index.rst:85
msgid "There is always one tuple set in a space. The identifier of a tuple set is the same as the space name -- 'tester' in the example."
msgstr "Каждое пространство всегда содержит один набор кортежей. Идентификатор набора кортежей совпадает с именем самого пространства, в нашем примере — `tester`."

#: ../book/box/index.rst:88
msgid "A tuple fills the same role as a “row” or a “record”, and the components of a tuple (which we call “fields”) fill the same role as a “row column” or “record field”, except that: the fields of a tuple can be composite structures, such as arrays or maps and don't need to have names. That's why there was no need to pre-define the tuple set when creating the space, and that's why each tuple can have a different number of elements. Tuples are stored as `MsgPack`_ arrays."
msgstr "Кортеж (tuple) выполняет ту же роль, что \"строка\" или \"запись\", а компоненты кортежа (его \"полЯ\") выполняют ту же роль, что \"поле столбца, соответствующее данной строке\" или \"поле в записи\" за тем исключением, что поля кортежа могут быть составными (например, они могут быть массивами или отображениями) и им не нужны имена. Поэтому нет необходимости предварительно определять набор кортежей при создании пространства, а каждый кортеж может иметь различное количество элементов. Кортежи хранятся в виде `MsgPack`_-массивов."

#: ../book/box/index.rst:97
msgid "Any given tuple may have any number of fields and the fields may have a variety of types. The identifier of a field is the field's number, base 1. For example “1” can be used in some contexts to refer to the first field of a tuple."
msgstr "Кортеж может иметь любое количество полей, и это могут быть поля разных типов. Идентификатором поля является его номер. Поля нумеруются, начиная с 1. Так, например, “1” может использоваться в некоторых контекстах для обозначения первого поля кортежа."

#: ../book/box/index.rst:101
msgid "When Tarantool returns a tuple value, it surrounds strings with single quotes, separates fields with commas, and encloses the tuple inside square brackets. For example: ``[3, 'length', 93]``."
msgstr "Когда Tarantool возвращает значение кортежа, он берет строки в одинарные кавычки, отделяет поля с запятыми и заключает кортеж в квадратные скобки. Например, ``[ 3, 'length', 93 ]``."

#: ../book/box/index.rst:109
msgid "Index"
msgstr "Индекс"

#: ../book/box/index.rst:111
msgid "An *index* -- 'primary' in the example -- is a group of key values and pointers."
msgstr "*Индекс* — в нашем примере он первичный — это совокупность значений ключей и указателей."

#: ../book/box/index.rst:113
msgid "In order for a tuple set to be useful, there must always be at least one index in a space. There can be many indexes. As with spaces, the user can and should specify the index name, and let Tarantool come up with a unique numeric identifier (the \"index id\"). In our example there is one index and its name is “primary”."
msgstr "Чтобы набором кортежей было можно пользоваться, в пространстве необходим по крайней мере один индекс. Вообще же индексов в пространстве может быть много. Как и в случае с пространствами, пользователь может — и должен — указать имя индекса, а Tarantool подставляет уникальный числовой идентификатор (\"идентификатор индекса\"). В нашем примере всего один индекс с именем “primary”."

#: ../book/box/index.rst:118
msgid "An index may be *multi-part*, that is, the user can declare that an index key value is taken from two or more fields in the tuple, in any order. An index may be *unique*, that is, the user can declare that it would be illegal to have the same key value twice. An index may have *one of four types*: HASH which is fastest and uses the least memory but must be unique, TREE which allows partial-key searching and ordered results, BITSET which can be good for searches that contain '=' and multiple ANDed conditions, and RTREE for spatial coordinates. The first index is called the “*primary key*” index and it must be unique; all other indexes are called “secondary” indexes."
msgstr "Индекс может быть *составным*. Значение ключа в таком индексе составляется из значений двух или более полей кортежа, причем они могут браться в любом порядке. Индекс может быть *уникальным*. В этом случае один и тот же ключ не может встречаться в индексе более одного раза. Также индекс может быть одного из следующих *четырех типов*: HASH (он самый быстрый и самый экономный в плане использования памяти, но он должен быть уникальным), TREE (он позволяет делать поиск по части ключа и получать отсортированные результаты), BITSET (он хорош для поиска с '=' и больших количеством AND-условий) или RTREE (для пространственных координат). Первый индекс называется “*первичным*” (primary) и должен быть уникальным. Все остальные индексы называются “вторичными” (secondary)."

#: ../book/box/index.rst:128
msgid "An index definition may include identifiers of tuple fields and their expected types. The allowed types for indexed fields are:"
msgstr "Индекс может содержать идентификаторы полей кортежа и типы данных для этих полей. Индексированные поля могут содержать данные следующих типов:"

#: ../book/box/index.rst:131
msgid "``unsigned`` (unsigned integer between 0 and 18,446,744,073,709,551,615)"
msgstr "``unsigned`` (беззнаковое целое число в диапазоне от 0 до 18,446,744,073,709,551,615)"

#: ../book/box/index.rst:132
msgid "``integer`` (signed integer between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807)"
msgstr "``integer`` (знаковое целое число в диапазоне от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807)"

#: ../book/box/index.rst:133
msgid "``number`` (unsigned integer or signed integer or floating-point value)"
msgstr "``number`` (беззнаковое целое число, либо знаковое целое число, либо число с плавающей точкой)"

#: ../book/box/index.rst:134
msgid "``string`` (string, any sequence of octets)"
msgstr "``string`` (строковое значение, т.е. любая последовательность октетов)"

#: ../book/box/index.rst:135
msgid "``scalar`` (boolean or number or string)"
msgstr "``scalar`` (логическое значение, либо число, либо строковое значение)"

#: ../book/box/index.rst:136
msgid "``array`` (a series of numbers for use with :ref:`RTREE indexes <box_index-rtree>`)"
msgstr "``array`` (последовательность чисел для :ref:`RTREE-индексов <box_index-rtree>`)"

#: ../book/box/index.rst:138
msgid "Take our example, which has the request:"
msgstr "В рамках нашего примера рассмотрим следующий запрос:"

#: ../book/box/index.rst:140
msgid "tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})"
msgstr "tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})"

#: ../book/box/index.rst:144
msgid "The effect is that, for all tuples in tester, field number 1 must exist and must contain an unsigned integer."
msgstr "В результате у всех кортежей в пространстве `tester` должно быть поле с номером 1, содержащее беззнаковое целое число."

#: ../book/box/index.rst:147
#, fuzzy
msgid "Space definitions and index definitions are stored permanently in system spaces. It is possible to add, drop, or alter the definitions at runtime, with some restrictions. See syntax details for defining spaces and indexes in :ref:`reference on Tarantool's \"box\" module <index-box_library>`."
msgstr "Определения пространств и индексов хранятся в системных пространствах. Можно (с некоторыми ограничениями) на ходу добавлять, удалять и менять эти определения. Правила синтаксиса в определениях пространств и индексов даны в разделе :ref:`Библиотека \"box\" <index-box_library>`."

#: ../book/box/index.rst:154
msgid "Data types"
msgstr "Типы данных"

#: ../book/box/index.rst:156
msgid "Tarantool can work with numbers, strings, booleans, tables, and userdata."
msgstr "Tarantool работает с числами (numbers), строками (strings), логическими значениями (booleans), таблицами (tables) и пользовательскими типами данных (userdata)."

#: ../book/box/index.rst:159
msgid "General type"
msgstr "Общий тип"

#: ../book/box/index.rst:159
msgid "Specific type"
msgstr "Особый тип"

#: ../book/box/index.rst:159
msgid "What Lua ``type()`` would return"
msgstr "Результат Lua type()"

#: ../book/box/index.rst:161 ../book/box/index.rst:163
#: ../book/box/index.rst:165 ../book/box/index.rst:167
msgid "scalar"
msgstr "scalar"

#: ../book/box/index.rst:161
msgid "\"`number`_\""
msgstr "\"`number`_\""

#: ../book/box/index.rst:161
msgid "12345"
msgstr "12345"

#: ../book/box/index.rst:163
msgid "\"`string`_\""
msgstr "\"`string`_\""

#: ../book/box/index.rst:163
msgid "'A B C'"
msgstr "'A B C'"

#: ../book/box/index.rst:165
msgid "\"`boolean`_\""
msgstr "\"`boolean`_\""

#: ../book/box/index.rst:165
msgid "true"
msgstr "true"

#: ../book/box/index.rst:167
msgid "\"`nil`_\""
msgstr "\"`nil`_\""

#: ../book/box/index.rst:169 ../book/box/index.rst:171
msgid "compound"
msgstr "compound"

#: ../book/box/index.rst:169
msgid "Lua table"
msgstr "Lua table"

#: ../book/box/index.rst:169
msgid "\"`table`_\""
msgstr "\"`table`_\""

#: ../book/box/index.rst:169
msgid "table: 0x410f8b10"
msgstr "table: 0x410f8b10"

#: ../book/box/index.rst:171
msgid "\"`Userdata`_\""
msgstr "\"`Userdata`_\""

#: ../book/box/index.rst:171
msgid "12345: {'A B C'}"
msgstr "12345: {'A B C'}"

#: ../book/box/index.rst:181
#, fuzzy
msgid "In Lua, a *number* is double-precision floating-point, but Tarantool allows both integer and floating-point values. Tarantool will try to store a number as floating-point if the value contains a decimal point or is very large (greater than 100 billion = 1e14), otherwise Tarantool will store it as an integer. To ensure that even very large numbers will be treated as integers, use the :ref:`tonumber64 <other-tonumber64>` function, or the ``LL`` (Long Long) suffix, or the ``ULL`` (Unsigned Long Long) suffix. Here are examples of numbers using regular notation, exponential notation, the ULL suffix, and the tonumber64 function: ``-55``, ``-2.7e+20``, ``100000000000000ULL``, ``tonumber64('18446744073709551615')``."
msgstr "В языке Lua тип *number* (число) — это число с плавающей точкой двойной точности, но в Tarantool'е можно использовать как целые числа, так и числа с плавающей запятой. Tarantool по возможности сохраняет числовые значения в виде чисел с плавающей точкой, если числовое значение содержит десятичную запятую или если оно очень велико (более 100 триллионов = 1e14). Если в формате с плавающей точкой сохранить не удается, то Tarantool сохраняет такое значение в виде целого числа. Чтобы даже очень большие величины гарантированно обрабатывались как целые числа, используйте функцию :ref:`tonumber64 <other-tonumber64>`, либо приписывайте в конце суффикс LL (Long Long) или ULL (Unsigned Long Long). Вот примеры записи чисел в различных представлениях (обычном, экспоненциальном, с суффиксом ULL и с использованием функции tonumber64): ``-55``, ``-2.7e+20``, ``100000000000000ULL``, ``tonumber64('18446744073709551615')``."

#: ../book/box/index.rst:192
#, fuzzy
msgid "For database storage, Tarantool uses MsgPack rules. Storage is variable-length, so the smallest number requires only one byte but the largest number requires nine bytes. When a field has an 'unsigned' index, all values must be unsigned integers between 0 and 18,446,744,073,709,551,615."
msgstr "Для хранения данных в базе Tarantool использует формат MsgPack. Данные при хранении имеют переменную длину, поэтому для самого маленького числа потребуется только один байт, а самое большее число потребует девять байтов. Если поле имеет индекс 'unsigned', то оно может содержать только целые беззнаковые числа со значениями в диапазоне от 0 до 18,446,744,073,709,551,615."

#: ../book/box/index.rst:197
msgid "A *string* is a variable-length sequence of bytes, usually represented with alphanumeric characters inside single quotes."
msgstr "Тип *string* (строка) — это последовательность байтов, имеющая переменную длину. Как правило, строки представлены в виде алфавитно-числовых символы, заключенных в одинарные кавычки."

#: ../book/box/index.rst:200
msgid "A *boolean* is either ``true`` or ``false``."
msgstr "Тип *boolean* (логический) может иметь только значения ``true`` или ``false``."

#: ../book/box/index.rst:202
msgid "A *nil* type has only one possible value, also called *nil*, but often displayed as *null*. Nils may be compared to values of any types with == (is-equal) or ~= (is-not-equal), but other operations will not work. Nils may not be used in Lua tables; the workaround is to use :ref:`yaml.NULL <yaml-null>` or :ref:`json.NULL <json-null>` or :ref:`msgpack.NULL <msgpack-null>`."
msgstr "Тип *nil* (нулевой) может иметь только одно значение, также называемое *nil*, но часто отображаемое как *null*. Нулевое значение можно сравнивать со значениями любых типов с помощью операторов == (равен) или ~= (не равен), но никакие другие операции для нулевых значений не доступны. Нулевые значения также нельзя использовать в Lua-таблицах; вместо нулевого значения в таком случае можно указать :ref:`yaml.NULL <yaml-null>`, либо :ref:`json.NULL <json-null>`, либо :ref:`msgpack.NULL <msgpack-null>`."

#: ../book/box/index.rst:208
msgid "A *tuple* is returned in YAML format like ``- [120, 'a', 'b', 'c']``. A few functions may return tables with multiple tuples. A scalar may be converted to a tuple with only one field. A Lua table may contain all of a tuple's fields, but not nil."
msgstr "Тип *tuple* возвращается в формате YAML, например ``- [120, 'a', 'b', 'c']``. Некоторые функции могут возвращать таблицы с несколькими кортежами. Скалярная величина может быть конвертирована в кортеж с 1 полем. Lua-таблица может содержать все типы полей, допустимые для кортежей, кроме нулевого типа (nil)."

#: ../book/box/index.rst:213
msgid "Some of the data types may be used in :ref:`indexed fields <details_about_index_field_types>`."
msgstr "Некоторые из этих типов данных подходят для :ref:`индексируемых полей <details_about_index_field_types>`."

#: ../book/box/index.rst:215
msgid "For more tuple examples see :ref:`box.tuple <box_tuple>`."
msgstr "См. также примеры кортежей в разделе про модуль :ref:`box.tuple <box_tuple>`."

#: ../book/box/index.rst:219
msgid "Operations"
msgstr "Операции"

#: ../book/box/index.rst:221
msgid "The basic operations are: the five data-change operations (``insert``, ``update``, ``upsert``, ``delete``, ``replace``), and the data-retrieval operation (``select``). There are also minor operations like “ping” which can only be used with the binary protocol. Also, there are :ref:`index iterator <box_index-index_pairs>` operations, which can only be used with Lua code. (Index iterators are for traversing indexes one key at a time, taking advantage of features that are specific to an index type, for example evaluating Boolean expressions when traversing BITSET indexes, or going in descending order when traversing TREE indexes.)"
msgstr "Основные операции — это пять операций для изменения данных (INSERT, UPDATE, UPSERT, DELETE, REPLACE) и одна операция для возвращения данных (SELECT). Также в Tarantool'е поддерживаются второстепенные операции типа PING, которые можно использовать только в рамках бинарного протокола. Кроме того, в Tarantool'е есть операции для :ref:`индекс-итераторов <box_index-index_pairs>`, которые можно использовать только в коде на языке Lua. (Индекс-итераторы нужны для обхода индексов от одного ключа к другому и дают возможность пользоваться преимуществами разных типов индексов, например вычислять значение выражений логического типа при обходе BITSET-индексов или двигаться в порядке убывания значений при обходе TREE-индексов.)"

#: ../book/box/index.rst:231
msgid "Six examples of basic operations:"
msgstr "Шесть примеров основных операций:"

#: ../book/box/index.rst:233
msgid ""
"-- Add a new tuple to tuple set tester.\n"
"-- The first field, field[1], will be 999 (type is unsigned).\n"
"-- The second field, field[2], will be 'Taranto' (type is string).\n"
"tarantool> box.space.tester:insert{999, 'Taranto'}\n"
"\n"
"-- Update the tuple, changing field field[2].\n"
"-- The clause \"{999}\", which has the value to look up in\n"
"-- the index of the tuple's primary-key field, is mandatory\n"
"-- because update() requests must always have a clause that\n"
"-- specifies the primary key, which in this case is field[1].\n"
"-- The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment\n"
"-- will happen to field[2] with the new value.\n"
"tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
"\n"
"-- Upsert the tuple, changing field field[2] again.\n"
"-- The syntax of upsert is similar to the syntax of update,\n"
"-- but the return value will be different.\n"
"tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
"\n"
"-- Replace the tuple, adding a new field.\n"
"-- This is also possible with the update() request but\n"
"-- the update() request is usually more complicated.\n"
"tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
"\n"
"-- Retrieve the tuple.\n"
"-- The clause \"{999}\" is still mandatory, although it does not have to\n"
"-- mention the primary key.\n"
"tarantool> box.space.tester:select{999}\n"
"\n"
"-- Delete the tuple.\n"
"-- Once again the clause to identify the primary-key field is mandatory.\n"
"tarantool> box.space.tester:delete{999}"
msgstr ""
"-- Добавляем новый кортеж в набор кортежей с именем tester.\n"
"-- Первое поле, field[1], будет равно 999 (тип = unsigned).\n"
"-- Второе поле, field[2], будет равно 'Taranto' (тип = string).\n"
"tarantool> box.space.tester:insert{999, 'Taranto'}\n"
"\n"
"-- Обновляем кортеж, меняем значение поля field[2].\n"
"-- Условие \"{999}\", содержащее значение ключа, которое нужно\n"
"-- искать в первичном индексе, построенном по первому полю\n"
"-- кортежа, является обязательным, поскольку запросам update()\n"
"-- всегда требуется условие, определяющее значение первичного\n"
"-- ключа, в данном случае field[1].\n"
"-- Условие \"{{'=', 2, 'Tarantino'}}\" определяет, что полю field[2] нужно \n"
"-- присвоить новое значение.\n"
"tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
"\n"
"-- Выполняем операцию upsert() для кортежа и снова меняем\n"
"-- значение поля field[2].\n"
"-- Синтаксис запроса upsert() аналогичен синтаксису update(),\n"
"-- но возвращаемые значения у этих запросов разные.\n"
"tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
"\n"
"-- Производим замену кортежа с помощью replace(), добавляем новое поле.\n"
"-- Это можно сделать и с помощью запроса update(),\n"
"-- но такой вариант часто оказывается более сложным.\n"
"tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
"\n"
"-- Возвращаем значение кортежа.\n"
"-- Условие \"{999}\" все еще обязательно, хотя оно и не должно\n"
"-- содержать значение первичного ключа.\n"
"tarantool> box.space.tester:select{999}\n"
"\n"
"-- Удаляем кортеж.\n"
"-- Условие, определяющее значение первичного ключа,\n"
"-- снова является обязательным.\n"
"tarantool> box.space.tester:delete{999}"

#: ../book/box/index.rst:268
msgid "How does Tarantool do a basic operation? Let's take this example:"
msgstr "Как Tarantool выполняет основные операции? Давайте рассмотрим это на следующем примере:"

#: ../book/box/index.rst:270
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../book/box/index.rst:274
msgid "which, for those who know SQL, is equivalent to a statement like"
msgstr "Это аналогично следующему выражению на языке SQL:"

#: ../book/box/index.rst:276
msgid "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[[1]\" = 3"
msgstr "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[[1]\" = 3"

#: ../book/box/index.rst:280
#, fuzzy
msgid "If this is happening on a remote client, then the client parses the statement and changes it to a binary-protocol instruction which has already been checked, and which the server can understand without needing to parse everything again. The client ships a packet to the server."
msgstr "Если запрос делается с удаленного клиента, то клиент разбирает введенное выражение, проверяет на корректность и переводит его в формат инструкций бинарного протокола, которые Tarantool-сервер сможет понять без повторного разбора. Затем клиент отправляет всё в виде пакета на сторону сервера."

#: ../book/box/index.rst:285
#, fuzzy
msgid "The server's “transaction processor” thread uses the primary-key index on field[1] to find the location of the tuple in memory. It determines that the tuple can be updated (not much can go wrong when you're merely changing an unindexed field value to something shorter)."
msgstr "Поток, выполняющий обработку транзакций на стороне сервера, использует первичный индекс по полю field[1], чтобы найти нужный кортеж в памяти. Он проверяет, что данный кортеж можно обновить (мы хотим лишь изменить значение не индексированного поля, и вряд ли что-то пойдет не так в таком простом случае)."

#: ../book/box/index.rst:290
#, fuzzy
msgid "The transaction processor thread sends a message to the write-ahead logging (WAL) thread."
msgstr "Поток обработки транзакций посылает сообщение другому потоку, который занимается записью в WAL."

#: ../book/box/index.rst:293
#, fuzzy
msgid "At this point, a *yield* takes place. To know the significance of that -- and it's quite significant -- you have to know a few facts and a few new words."
msgstr "В этот момент происходит *передача управления* (yield). Чтобы понять важность этого события — а оно действительно важно, — нужно пояснить несколько фактов и ввести ряд новых терминов."

#: ../book/box/index.rst:296
msgid "FACT 1:"
msgstr "ФАКТ #1:"

#: ../book/box/index.rst:299
#, fuzzy
msgid "There is only one transaction processor thread. Some people are used to the idea that there can be multiple threads operating on the database, with (say) thread #1 reading row #x while thread #2 writes row #y. With Tarantool no such thing ever happens. Only the transaction processor thread can access the database, and there is only one transaction processor thread for each instance of the server."
msgstr "В Tarantool'е есть только один поток обработки транзакций. Многие люди уже привыкли к мысли, что потоков для обработки данных может быть много (например, поток #1 читает данные из строки #x, в то время как поток #2 записывает данные в столбец #y). В случае с Tarantool'ом такого не происходит. доступ к базе есть только у потока обработки транзакций, и на каждый экземпляр Tarantool'а есть только один такой поток."

#: ../book/box/index.rst:306
msgid "FACT 2:"
msgstr "ФАКТ #2:"

#: ../book/box/index.rst:309
#, fuzzy
msgid "The transaction processor thread can handle many *fibers*. A fiber is a set of computer instructions that may contain \"yield\" signals. The transaction processor thread will execute all computer instructions until a yield, then switch to execute the instructions of a different fiber. Thus (say) the thread reads row #x for the sake of fiber #1, then writes row #y for the sake of fiber #2."
msgstr "Поток обработки транзакций может управлять множеством *файберов*. Файбер — это набор инструкций, среди которых могут быть и сигналы \"передать управление\". Поток обработки транзакций выполняет инструкции, пока не увидит такой сигнал, и тогда он переключается на выполнение инструкций из другого файбера. Например, таким образом поток обработки транзакций сначала выполняет чтение данных из строки #x для файбера #1, а затем выполняет запись в строку #y для файбер #2."

#: ../book/box/index.rst:317
msgid "FACT 3:"
msgstr "ФАКТ #3:"

#: ../book/box/index.rst:320
#, fuzzy
msgid "Yields must happen, otherwise the transaction processor thread would stick permanently on the same fiber. There are :ref:`implicit yields <atomic-the_implicit_yield_rules>`: every data-change operation or network-access causes an implicit yield, and every statement that goes through the tarantool client causes an implicit yield. And there are explicit yields: in a Lua function one can and should add “yield” statements to prevent hogging. This is called *cooperative multitasking*."
msgstr "Без передачи управления не обойтись, т.к. иначе поток обработки транзакций сможет выполнять инструкции только для одного файбера. Передача управления может осуществляться один их двух способов. Первый — это :ref:`неявная передача <atomic-the_implicit_yield_rules>`. Она делается при каждой операции, связанной с изменением данных, при каждом обращении к сетевому соединению, а также при каждом запросе, который передается через Tarantool-клиент. Второй способ передачи управления — это явная передача. Ее можно — и нужно — вызывать внутри Lua-функций с помощью инструкции “yield”, чтобы не допустить захвата процессора одним файбером. Это называется *взаимная многозадачность*."

#: ../book/box/index.rst:327
msgid "Since all data-change operations end with an implicit yield and an implicit commit, and since no data-change operation can change more than one tuple, there is no need for any locking. Consider, for example, a Lua function that does three Tarantool operations:"
msgstr "Поскольку все операции, связанные с изменением данных, заканчиваются неявной передачей управления и неявным коммитом, и поскольку каждая такая операция может затрагивать не более одного кортежа, то не возникает нужды в блокировках. Для примера рассмотрим следующую Lua-функцию, которая осуществляет три операции в Tarantool'е:"

#: ../book/box/index.rst:332
msgid ""
"s:select{999}             -- this does not yield and does not commit\n"
"s:update({...},{{...}})   -- this yields and commits\n"
"s:select{999}             -- this does not yield and does not commit"
msgstr ""
"s:select{999}             -- не происходит ни передачи управления, ни коммита\n"
"s:update({...},{{...}})   -- происходит и передача управления, и коммит\n"
"s:select{999}             -- не происходит ни передачи управления, ни коммита"

#: ../book/box/index.rst:338
msgid "The combination “SELECT plus UPDATE” is an atomic transaction: the function holds a consistent view of the database until the UPDATE ends. For the combination “UPDATE plus SELECT” the view is not consistent, because after the UPDATE the transaction processor thread can switch to another fiber, and delete the tuple that was just updated."
msgstr "Последовательность операций “SELECT + UPDATE” является атомарной транзакцией: функция сохраняет базу данных в согласованном виде, пока не отработает UPDATE. А в случае “UPDATE + SELECT” согласованности нет, поскольку после операции UPDATE поток обработки транзакций может переключится на другой файбер и удалить тот кортеж, что был обновлен в рамках предыдущей операции UPDATE."

#: ../book/box/index.rst:344
msgid "Note re storage engine: vinyl handles yields differently, see :ref:`differences between memtx and vinyl <vinyl_diff>`."
msgstr "Примечание про движок: в движке vinyl передача управления происходит по-другому, см. раздел про :ref:`различия между движками memtx и vinyl <vinyl_diff>`."

#: ../book/box/index.rst:347
msgid "Note re multi-request transactions"
msgstr "Примечание про составные транзакции:"

#: ../book/box/index.rst:349
msgid "There is a way to delay yields. Read about execution atomicity in section :ref:`Transaction control <transaction_control>`."
msgstr ""

#: ../book/box/index.rst:352
msgid "Since locks don't exist, and disk writes only involve the write-ahead log, transactions are usually fast. Also the Tarantool server may not be using up all the threads of a powerful multi-core processor, so advanced users may be able to start a second Tarantool server on the same processor without ill effects."
msgstr "Посколько блокировки не используются, а запись на диск производится только при работе с WAL-файлом, то транзакции в Tarantool'е обычно совершаются быстро. Кроме того, если мы имеем дело с мощным многоядерным процессором, то Tarantool-сервер может задействовать для работы не все потоки такого процессора, и продвинутые пользователи могут безболезненно запускать второй Tarantool-сервер на том же процессоре."

#: ../book/box/index.rst:357
msgid "Additional examples of requests can be found in the Tarantool regression test suite (https://github.com/tarantool/tarantool/tree/1.7/test/box). A complete grammar of supported data-manipulation functions will come later in this chapter."
msgstr "См. также примеры с запросами в регрессионных тестах для Tarantool'а (https://github.com/tarantool/tarantool/tree/1.7/test/box). Полное описание грамматики поддерживаемых в Tarantool'е функций для манипулирования данными см. далее в этой главе."

#: ../book/box/index.rst:361
msgid "Since not all Tarantool operations can be expressed with the data-manipulation functions, or with Lua, to gain complete access to data manipulation functionality one must use a :ref:`Perl, PHP, Python or other programming language connector <index-box_connectors>`. The client/server protocol is open and documented. See this :ref:`annotated BNF <box_protocol-iproto_protocol>`."
msgstr "Не все операции в Tarantool'е можно выразить с помощью функций по манипулированию данными или с помощью языка Lua. Чтобы получить доступ ко всем возможностями манипулирования данными, вам понадобится :ref:`коннектор для Perl, PHP, Python или другого языка программирования <index-box_connectors>`. Бинарный клиент-серверный протокол для коннекторов является открытым. Документация по нему доступна в виде аннотированных :ref:`BNF-диаграмм <box_protocol-iproto_protocol>`."

#: ../book/box/index.rst:370
msgid "Persistence"
msgstr ""

#: ../book/box/index.rst:372
msgid "Tarantool maintains a set of write-ahead log (WAL) files. There is a separate thread -- the WAL writer -- which catches all requests that can change a database, such as ``box.schema.create`` or ``box.space.insert``. Ordinarily the WAL writer writes the request, along with administrative fields and flags, to a WAL file immediately. This ensures data persistence, because, even if an in-memory database is lost when the power goes off, Tarantool recovers it automatically when it starts up again, by reading the WAL files and redoing the requests (this is called the \"recovery process\"). Users can change the timing of the WAL writer, or turn it off, by setting :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
msgstr "Tarantool сохраняет данные и информацию об изменениях в нескольких WAL-файлах (write-ahead log). Записью в WAL занимается отдельный поток. Он ловит все запросы, которые могут привести к изменению данных в базе, например ``box.schema.create`` или ``box.space.insert``. Как правило, запись о запросе, включая служебные поля и флаги, делается в WAL-файл немедленно. Это обеспечивает сохранность данных, поскольку, даже если данные из памяти утеряны вследствие перебоя в электроснабжении, Tarantool восстановит их автоматически при следующем старте: он загрузит данные из WAL-файлов, а затем применит все записанные в WAL-файлах запросы (это называется \"процесс восстановления\"). Пользователи могут менять частоту записи или вовсе отключать запись в WAL с помощью параметра :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."

#: ../book/box/index.rst:383
msgid "Tarantool also maintains a set of snapshot files. A snapshot file is an on-disk copy of the entire data set for a given moment. Instead of reading every WAL file since the databases were created, the recovery process can load the latest snapshot and then read only the WAL files that were produced after the snapshot was made. A snapshot can be made even if there is no WAL file. Some snapshots are automatic, or users can make them at any time with the :ref:`box.snapshot() <admin-snapshot>` request."
msgstr "Tarantool также сохраняет ряд файлов со статическими снимками данных (snapshots). Файл со снимком — это дисковая копия всех данных в базе на какой-то момент. Вместо того, чтобы зачитывать все WAL-файлы, появившиеся с момента создания базы, Tarantool в процессе восстановления может загрузить самый свежий снимок и затем зачитать только те WAL-файлы, которые были сделаны с момента сохранения снимка. Снимки могут делаться автоматически, или же пользователи могут создавать их сами в любой момент с помощью запроса :ref:`box.snapshot() <admin-snapshot>`."

#: ../book/box/index.rst:391
msgid "Details about the WAL writer and the recovery process are in the :ref:`Internals <b_internals>` section."
msgstr "См. подробности о работе потока записи в WAL в разделе  :ref:`Детали реализации <b_internals>`."

#: ../book/box/index.rst:396
msgid "Data manipulation"
msgstr "Манипулирование данными"

#: ../book/box/index.rst:398
msgid "The basic *data-manipulation* requests are: ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``select``. All of them are part of the ``box`` library. Most of them may return data. Usually both inputs and outputs are Lua tables."
msgstr "Основные запросы для *манипулирования данными* — это ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``select``. Все они реализованы в библиотеке ``box``. Многие из этих запросов могут возвращать данные. Как правило, и вводимые, и возвращаемые значения являются Lua-таблицами."

#: ../book/box/index.rst:402
msgid "The Lua syntax for data-manipulation functions can vary. Here are examples of the variations with ``select`` requests; the same rules exist for the other data-manipulation functions. Every one of the examples does the same thing: select a tuple set from a space named 'tester' where the primary-key field value equals 1. For the examples there is an assumption that the numeric id of 'tester' is 512, which happens to be the case in our sandbox example only."
msgstr "Lua-синтаксис в данных функциях может различаться. Далее приводятся варианты таких различий на примере SELECT-запросов. Аналогичные правила существуют и для остальных функций. В каждом из приведенных примеров выполняются следующие действия: производится выборка по набору кортежей из пространства с именем 'tester', где значение поля, которое соответствует ключу в первичном индексе, равно 1. Также во всех примерах мы подразумеваем, что числовой идентификатор пространства 'tester' равен 512, но это верно только для нашей тестовой базы."

#: ../book/box/index.rst:411
msgid "First, there are five *object reference variations*:"
msgstr "Во-первых, есть пять *способов ссылки на объект*:"

#: ../book/box/index.rst:413
msgid ""
"-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 replace name with a numeric id in square brackets\n"
"tarantool> box.space[512]:select{1}\n"
"-- #4 use a variable instead of a literal for the name\n"
"tarantool> variable = 'tester'\n"
"tarantool> box.space[variable]:select{1}\n"
"-- #5 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""
"-- #1 имя_модуля . имя_вложенного_модуля . имя_объекта\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 вместо имени объекта указываем литерал в квадратных скобках\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 вместо имени объекта указываем числовой идентификатор в квадратных скобках\n"
"tarantool> box.space[512]:select{1}\n"
"-- #4 вместо литерала, обозначающего имя объекта, указываем переменную\n"
"tarantool> variable = 'tester'\n"
"tarantool> box.space[variable]:select{1}\n"
"-- #5 указываем переменную вместо ссылки на весь объект\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"

#: ../book/box/index.rst:428
msgid "Later examples in this manual will usually have the \":samp:`box.space.{tester}:`\" form (#1); however, this is a matter of user preference and all the variations exist in the wild."
msgstr "Для примеров в остальной части документации мы будем, как правило, использовать вариант синтаксиса #1, например \":samp:`box.space.{tester}:`\". Но вы можете с тем же успехом пользоваться любым из пяти описанных выше вариантов."

#: ../book/box/index.rst:432
msgid "Later descriptions in this manual will use the syntax \"``space_object:``\" for references to objects which are spaces as in the above examples, and \"``index_object:``\" for references to objects which are indexes (for example :samp:`box.space.{tester}.index.{primary}:`)."
msgstr "Также мы в дальнейшем будем использовать синтаксис типа  \":code:`space_object:`\" для ссылки на пространства (как в приведенных выше примерах) и \":code:`index_object:`\" для ссылки на индексы (например, :samp:`box.space.{tester}.index.{primary}:`)."

#: ../book/box/index.rst:437
msgid "Then, there are seven *parameter variations*:"
msgstr "Во-вторых, есть семь *способов задания параметров*:"

#: ../book/box/index.rst:439
msgid ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"

#: ../book/box/index.rst:458
msgid "The primary-key value is enclosed in braces, and if it was a multi-part primary key then the value would be multi-part, for example ``...select{1,2,3}``. The braces can be enclosed inside parentheses — ``...select({...})`` — which are optional unless it is necessary to pass something besides the primary-key value, as in example #5. Literal values such as 1 (a scalar value) or {1} (a Lua table value) may be replaced by variable names, as in examples #6 and #7. Although there are special cases where braces can be omitted, they are preferable because they signal \"Lua table\". Examples and descriptions in this manual have the \"{1}\" form; however, this too is a matter of user preference and all the variations exist in the wild."
msgstr "Значение первичного ключа заключается в фигурные скобки. Если же этот первичный ключ является составным, то и значение будет составным, например ``...select{1,2,3}``. Фигурные скобки в свою очередь могут заключаться в круглые скобки — например, ``...select({...})``. Это опциональный вариант синтаксиса, и он необходим только в том случае, если нужно передать что-то помимо первичного ключа, как в примере #5. Вместо значений-литералов — например, 1 (скалярное значение) или {1} (Lua-таблица) — можно использовать имена переменных, как в примерах #6 и #7. Хотя в некоторых случаях фигурные скобки можно опускать, мы рекомендуем всегда их использовать. Так вы явно обозначите, что значение имеет тип \"Lua-таблица\". В примерах и описаниях в документации мы везде используем фигурные скобки, например \"{1}\".  Но как и в случае со ссылками на объект, вы можете пользоваться любым допустимым вариантом синтаксиса."

#: ../book/box/index.rst:469
msgid "All the data-manipulation functions operate on tuple sets but, since primary keys are unique, the number of tuples in the tuple set is always 0 or 1. The only exception is ``box.space...select``, which may accept either a primary-key value or a secondary-key value."
msgstr "Все функции для манипулирования данными оперируют наборами кортежей. Однако, поскольку первичные ключи всегда уникальны, количество кортежей в таком наборе всегда равно 0 или 1. Единственным исключением является функция ``box.space...select``, которая может брать на вход как первичный, так и вторичный ключ."

#: ../book/box/index.rst:477
#, fuzzy
msgid "**Complexity factors that may affect data-manipulation functions**"
msgstr "**Факторы, которые могут влиять на быстродействие функций для манипулирования данными из библиотеки box**"

#: ../book/box/index.rst:483
msgid "Index size"
msgstr "Размер индекса"

#: ../book/box/index.rst:483
msgid "The number of index keys is the same as the number of tuples in the data set. For a TREE index, if there are more keys then the lookup time will be greater, although of course the effect is not linear. For a HASH index, if there are more keys then there is more RAM use, but the number of low-level steps tends to remain constant."
msgstr "Количество ключей в индексе равно количеству кортежей в наборе данных. В случае с TREE-индексом: с ростом количества ключей увеличивается время поиска, хотя зависимость здесь, конечно же, не линейная. В случае с HASH-индексом: с ростом количества ключей увеличивается объем используемой памяти, но количество низкоуровневых шагов остается примерно тем же."

#: ../book/box/index.rst:491
msgid "Index type"
msgstr "Тип индекса"

#: ../book/box/index.rst:491
msgid "Typically a HASH index is faster than a TREE index if the number of tuples in the tuple set is greater than one."
msgstr "Как правило, поиск по HASH-индексу работает быстрее, чем по TREE-индексу, если в наборе есть более одного кортежа."

#: ../book/box/index.rst:495
msgid "Number of indexes accessed"
msgstr "Количество обращений к индексам"

#: ../book/box/index.rst:495
msgid "Ordinarily only one index is accessed to retrieve one tuple. But to update the tuple, there must be N accesses if the tuple set has N different indexes."
msgstr "Обычно для выборки значений одного кортежа используется только один индекс. Но при обновлении значений в кортеже требуется N обращений, если у набора кортежей есть N индексов."

#: ../book/box/index.rst:499
msgid "Number of tuples accessed"
msgstr "Количество обращений к кортежам"

#: ../book/box/index.rst:499
msgid "A few requests, for example select, can retrieve multiple tuples. This factor is usually less important than the others."
msgstr "Некоторые запросы, например SELECT, могут возвращать несколько кортежей. Как правило, это наименее важный фактор из всех."

#: ../book/box/index.rst:503
msgid "WAL settings"
msgstr "Настройки WAL"

#: ../book/box/index.rst:503
msgid "The important setting for the write-ahead log is :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no writing or delayed writing, this factor is unimportant. If the setting causes every data-change request to wait for writing to finish on a slow device, this factor is more important than all the others."
msgstr "Важным параметром для записи в WAL является :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`. Если запись в WAL отключена или задана запись с задержкой, но этот фактор не так важен. Если же запись в WAL производится при каждом запросе на изменение данных, то при каждом таком запросе приходится ждать, пока отработает обращение к более медленному диску, и данный фактор становится важнее всех остальных."

#: ../book/box/index.rst:512
#, fuzzy
msgid "In the discussion of each data-manipulation function, there will be a note about which complexity factors might affect the function's resource usage."
msgstr "Далее в описании каждой функции для манипулирования данными будет дано примечание, какие из перечисленных выше факторов могут влиять на ее быстродействие."

#: ../book/box/index.rst:517
msgid "Index operations"
msgstr "Операции с индексами"

#: ../book/box/index.rst:519
msgid "Index operations are automatic: if a data-manipulation request changes a tuple, then it also changes the index keys defined for the tuple. Therefore the user only needs to know how and why to define."
msgstr "Операции с индексами производятся автоматически. Если запрос по манипулированию данными меняет данные в кортеже, то меняются и ключи в индексе для данного кортежа. Поэтому пользователю нужно знать только как и зачем задавать индексы."

#: ../book/box/index.rst:523
msgid "The simple index-creation operation which has been illustrated before is"
msgstr "Простая операция для создания индекса, которую мы рассматривали ранее, имела следующий вид:"

#: ../book/box/index.rst:528
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ":samp:`box.space.{имя-пространства}:create_index('{имя-индекса}')`"

#: ../book/box/index.rst:530
msgid "By default, this creates a unique \"tree\" index on the first field of all tuples (often called \"Field#1\"), which is assumed to be numeric."
msgstr "По умолчанию, при этом создается TREE-индекс по первому полю (обычно его называют \"Field#1\") для всех кортежей в пространстве. Предполагается, что индексируемое поле является числовым."

#: ../book/box/index.rst:533 ../book/box/index.rst:600
msgid "These variations exist:"
msgstr "Также возможны следующие варианты:"

#: ../book/box/index.rst:535
msgid "An indexed field may be a string rather than a number."
msgstr "Индексируемое поле может быть строкой, а не числом."

#: ../book/box/index.rst:542
msgid "For an ordinary index, the most common data types are 'unsigned' = any non-negative integer, or 'string' = any series of bytes. Numbers are ordered according to their point on the number line -- so 2345 is greater than 500 -- while strings are ordered according to the encoding of the first byte then the encoding of the second byte then the encoding of the third byte and so on -- so '2345' is less than '500'."
msgstr "Обычный индекс, как правило, строится по полям одного из двух типов: 'NUM' = числовой (numeric) = любое неотрицательное целое число, либо 'STR' = строка (string) = любая последовательность байтов. Числа в индексе упорядочены по числовой прямой (например, число 2345 больше, чем число 500), а строки — по коду первого байта, затем по коду второго, третьего и т.д. (и теперь строка '2345' будет меньше, чем строка '500')."

#: ../book/box/index.rst:549
msgid "For details about other index types see :ref:`create_index <box_space-create_index>`."
msgstr "Подробнее о других типах индексов см. в описании функции :ref:`create_index <box_space-create_index>`."

#: ../book/box/index.rst:551
msgid "There may be more than one field."
msgstr "Индекс может строиться по нескольким полям."

#: ../book/box/index.rst:560
msgid "For an ordinary index, the maximum number of parts is 255. The specification of each part consists of a field number and a type."
msgstr "В обычном индексе может быть максимум 255 частей. Каждая часть характеризуется номером поля и его типом."

#: ../book/box/index.rst:563
msgid "The index does not have to be unique."
msgstr "Индекс может быть неуникальным."

#: ../book/box/index.rst:570
msgid "The first index of a tuple set must be unique, but other indexes (\"secondary\" indexes) may be non-unique."
msgstr "Первичный индекс для кортежа должен строиться по уникальным значениям полей, но остальные (вторичные) индексы могут строиться по неуникальным значениям."

#: ../book/box/index.rst:573
msgid "The index does not have to be a tree."
msgstr "Индекс может представлять собой не только дерево."

#: ../book/box/index.rst:580
msgid "The two ordinary index types are 'tree' which is the default, and 'hash' which must be unique and which may be faster or smaller. The third type is 'bitset' which is not unique and which works best for combinations of binary values. The fourth type is 'rtree' which is not unique and which works with arrays, instead of 'string' or 'unsigned' values."
msgstr "Чаще всего индекс — это дерево (по умолчанию) или хеш (в этом случае индекс должен быть уникальным; в определенных случаях такой индекс занимает меньше места и поиск по нему работает быстрее). Третий тип индекса — это набор битов (bitset); это неуникальный индекс, предназначенный для работы с различными бинарными значениями. Четвертый тип индекса — это R-дерево; это тоже неуникальный индекс, предназначенный для работы с массивами, а не со строками или беззнаковыми числами."

#: ../book/box/index.rst:586
msgid "The existence of indexes does not affect the syntax of data-change requests, but does cause select requests to have more variety."
msgstr "Наличие индексов никак не влияет на синтаксис запросов на изменение данных. А вот SELECT-запросы, благодаря индексам, становятся более разнообразными."

#: ../book/box/index.rst:589
msgid "The simple select request which has been illustrated before is:"
msgstr "Вот простой SELECT-запрос, который мы рассматривали ранее:"

#: ../book/box/index.rst:594
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{*{имя-пространства}*}:select({*{значение}*})`"

#: ../book/box/index.rst:596
msgid "By default, this looks for a single tuple via the first index. Since the first index is always unique, the maximum number of returned tuples will be: one."
msgstr "По умолчанию, такой запрос ищет нужный кортеж по значению в первом (первичном) индексе. Поскольку первичный индекс всегда уникален, то данный запрос вернет не более одного кортежа."

#: ../book/box/index.rst:602
msgid "The search can use comparisons other than equality."
msgstr "Помимо условия равенства, при поиске могут использоваться и другие условия сравнения."

#: ../book/box/index.rst:609
msgid "The comparison operators are LT, LE, EQ, REQ, GE, GT for \"less than\", \"less than or equal\", \"equal\", \"reversed equal\", \"greater than or equal\", \"greater than\" respectively. Comparisons make sense if and only if the index type is 'tree'."
msgstr "Можно использовать следующие операторы сравнения: LT (меньше), LE (меньше или равно), EQ (равно), REQ (неравно), GE (больше или равно), GT (больше). Сравнения имеют смысл только для индексов типа 'tree'."

#: ../book/box/index.rst:614
msgid "This type of search may return more than one tuple; if so, the tuples will be in descending order by key when the comparison operator is LT or LE or REQ, otherwise in ascending order."
msgstr "Этот вариант поиска может вернуть более одного кортежа. В таком случае кортежи будут отсортированы в порядке убывания по ключу (если использовался оператор LT, LE или REQ), либо в порядке возрастания (во всех остальных случаях)."

#: ../book/box/index.rst:618
msgid "The search can use a secondary index."
msgstr "Поиск может производиться по вторичному индексу."

#: ../book/box/index.rst:625
msgid "For a primary-key search, it is optional to specify an index name. For a secondary-key search, it is mandatory."
msgstr "При поиске по первичному индексу имя индекса можно не указывать. При поиске же по вторичному индексу имя индекса указывать необходимо."

#: ../book/box/index.rst:628
msgid "The search may be for some or all key parts."
msgstr "Поиск может производиться как по всему ключу, так и по его частям."

#: ../book/box/index.rst:649
msgid "The search can be for all fields, using a table for the value:"
msgstr "Поиск может производиться по всем полям (в этом случае используется таблица значений):"

#: ../book/box/index.rst:656
msgid "or the search can be for one field, using a table or a scalar:"
msgstr "Либо же по одному полю (в этом случае используется таблица или скалярное значение):"

#: ../book/box/index.rst:663
msgid "in the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1, 'B'}``. It's even possible to specify zero fields, causing all three tuples to be returned."
msgstr "Во втором случае Tarantool вернет два кортежа: ``{1, 'A'}`` и ``{1, 'B'}``. При необходимости можно задать даже нулевые поля, в результате чего Tarantool вернет все три кортежа."

#: ../book/box/index.rst:669
msgid "BITSET example:"
msgstr "Пример работы с BITSET-индексом:"

#: ../book/box/index.rst:671
msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, {iterator='BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, {iterator='BITS_ANY_SET'})"

#: ../book/box/index.rst:682 ../book/box/index.rst:707
msgid "The result will be:"
msgstr "Мы получим следующий результат:"

#: ../book/box/index.rst:684
msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

#: ../book/box/index.rst:691
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0 и (3 AND 2) не равно 0."

#: ../book/box/index.rst:693
msgid "Searches on BITSET indexes can be for BITS_ANY_SET, BITS_ALL_SET, BITS_ALL_NOT_SET, EQ, or ALL."
msgstr "При поиске по BITSET-индексам можно использовать операторы BITS_ANY_SET, BITS_ALL_SET, BITS_ALL_NOT_SET, EQ и ALL."

#: ../book/box/index.rst:696
msgid "RTREE example:"
msgstr "Пример работы с RTREE-индексом:"

#: ../book/box/index.rst:698
msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = 'GT'})"
msgstr ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = 'GT'})"

#: ../book/box/index.rst:709
msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."

#: ../book/box/index.rst:715
msgid "because a rectangle whose corners are at coordinates 4,7,5,9 is entirely within a rectangle whose corners are at coordinates 3,5,9,10."
msgstr "поскольку прямоугольник с углами в координатах 4,7,5,9 лежит целиком внутри прямоугольника с углами в координатах 3,5,9,10."

#: ../book/box/index.rst:718
msgid "Searches on RTREE indexes can be for GT, GE, LT, LE, OVERLAPS, or NEIGHBOR."
msgstr "При поиске по RTREE-индексам можно использовать операторы GT, GE, LT, LE, OVERLAPS и NEIGHBOR."

#: ../book/box/index.rst:724
msgid "Transaction control"
msgstr "Контроль транзакций"

#: ../book/box/atomic.rst:3
msgid "In several places in this manual, it's been noted that Lua processes occur in fibers on a single thread. That is why there can be a guarantee of execution atomicity. That requires emphasis."
msgstr ""

#: ../book/box/atomic.rst:11
msgid "Cooperative multitasking environment"
msgstr "Среда взаимной многозадачности"

#: ../book/box/atomic.rst:13
msgid "Tarantool uses cooperative multitasking: unless a running fiber deliberately yields control, it is not preempted by some other fiber. But a running fiber will deliberately yield when it encounters a \"yield point\": an explicit `yield()` request, or an implicit yield due to an operating-system call. Any system call which can block will be performed asynchronously, and any running fiber which must wait for a system call will be preempted so that another ready-to-run fiber takes its place and becomes the new running fiber. This model makes all programmatic locks unnecessary: cooperative multitasking ensures that there will be no concurrency around a resource, no race conditions, and no memory consistency issues."
msgstr ""

#: ../book/box/atomic.rst:24
msgid "When requests are small, for example simple UPDATE or INSERT or DELETE or SELECT, fiber scheduling is fair: it takes only a little time to process the request, schedule a disk write, and yield to a fiber serving the next client."
msgstr ""

#: ../book/box/atomic.rst:28
msgid "However, a function might perform complex computations or might be written in such a way that yields do not occur for a long time. This can lead to unfair scheduling, when a single client throttles the rest of the system, or to apparent stalls in request processing. Avoiding this situation is the responsibility of the function's author. For the default memtx storage engine some of the box calls, including the data-change requests :ref:`box.space...insert <box_space-insert>` or :ref:`box.space...update <box_space-update>` or :ref:`box.space...delete <box_space-delete>`, will usually cause yielding; however, :ref:`box.space...select <box_space-select>` will not. A fuller description will appear in section :ref:`Implicit yields <atomic-the_implicit_yield_rules>`."
msgstr ""

#: ../book/box/atomic.rst:41
msgid "Note re storage engine: vinyl has different rules: insert or update or delete will very rarely cause a yield, but select can cause a yield."
msgstr ""

#: ../book/box/atomic.rst:45
msgid "In the absence of transactions, any function that contains yield points may see changes in the database state caused by fibers that preempt. Then the only safe atomic functions for memtx databases would be functions which contain only one database request, or functions which contain a select request followed by a data-change request."
msgstr ""

#: ../book/box/atomic.rst:51
msgid "At this point an objection could arise: \"It's good that a single data-change request will commit and yield, but surely there are times when multiple data-change requests must happen without yielding.\" The standard example is the money-transfer, where $1 is withdrawn from account #1 and deposited into account #2. If something interrupted after the withdrawal, then the institution would be out of balance. For such cases, the ``begin ... commit|rollback`` block was designed."
msgstr ""

#: ../book/box/atomic.rst:63
msgid "Begin the transaction. Disable implicit yields until the transaction ends. Signal that writes to the write-ahead log will be deferred until the transaction ends. In effect the fiber which executes ``box.begin()`` is starting an \"active multi-request transaction\", blocking all other fibers."
msgstr ""

#: ../book/box/atomic.rst:72
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../book/box/atomic.rst:79
msgid "End the transaction, but cancel all its data-change operations. An explicit call to functions outside ``box.space`` that always yield, such as ``fiber.yield`` or ``fiber.sleep``, will have the same effect."
msgstr ""

#: ../book/box/atomic.rst:83
msgid "The **requests in a transaction must be sent to the server as a single block**. It is not enough to enclose them between ``begin`` and ``commit`` or ``rollback``. To ensure they are sent as a single block: put them in a function, or put them all on one line, or use a delimiter so that multi-line requests are handled together."
msgstr ""

#: ../book/box/atomic.rst:88
msgid "**All database operations in a transaction should use the same storage engine**. It is not safe to access tuple sets that are defined with ``{engine='vinyl'}`` and also access tuple sets that are defined with ``{engine='memtx'}``, in the same transaction."
msgstr ""

#: ../book/box/atomic.rst:97
msgid "Assuming that in tuple set 'tester' there are tuples in which the third field represents a positive dollar amount ... Start a transaction, withdraw from tuple#1, deposit in tuple#2, and end the transaction, making its effects permanent."
msgstr ""

#: ../book/box/atomic.rst:101
msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""

#: ../book/box/atomic.rst:121
#, fuzzy
msgid "Implicit yields"
msgstr "Правила неявной передачи управления"

#: ../book/box/atomic.rst:123
msgid "The only explicit yield requests are :ref:`fiber.sleep() <fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other requests \"imply\" yields because Tarantool is designed to avoid blocking."
msgstr ""

#: ../book/box/atomic.rst:127
msgid "The implicit yield requests are: :ref:`insert <box_space-insert>` :ref:`replace <box_space-replace>` :ref:`update <box_space-update>` :ref:`upsert <box_space-upsert>` :ref:`delete <box_space-delete>` (the \"data-change\" requests), and functions in module :ref:`fio <fio-section>`, :ref:`net_box <net_box-module>`, :ref:`console <console-module>`, or :ref:`socket <socket-module>` (the \"os\" and \"network\" requests)."
msgstr ""

#: ../book/box/atomic.rst:134
msgid "Note re storage engine: vinyl causes :ref:`select <box_space-select>` to be an implicit yield request, but data-change requests may not be."
msgstr ""

#: ../book/box/atomic.rst:137
msgid "The yield occurs just before a blocking syscall, such as a write to the Write-Ahead Log (WAL) or a network message reception."
msgstr ""

#: ../book/box/atomic.rst:140
msgid "Implicit yield requests are disabled by :ref:`box.begin <atomic-box_begin>`, and enabled again by :ref:`commit <atomic-box_commit>`. Therefore the sequence"
msgstr ""

#: ../book/box/atomic.rst:874
msgid ""
"begin\n"
"implicit yield request #1\n"
"implicit yield request #2\n"
"implicit yield request #3\n"
"commit"
msgstr ""

#: ../book/box/atomic.rst:152
msgid "will not cause implicit yield until the commit occurs (specifically: just before the writes to the WAL, which are delayed until commit time). The commit request is not itself an implicit yield request, it only enables yields caused by earlier implicit yield requests."
msgstr ""

#: ../book/box/atomic.rst:157
msgid "Despite their resemblance to implicit yield requests, :ref:`truncate <box_space-truncate>` and :ref:`drop <box_space-drop>` do not cause implicit yield. Despite their resemblance to functions of the fio module, functions of the :ref:`os <os-module>` module do not cause implicit yield. Despite its resemblance to commit, :ref:`rollback <atomic-box_rollback>` does not enable yields."
msgstr ""

#: ../book/box/atomic.rst:164
msgid "If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = 'none', then implicit yielding is disabled, because there are no writes to the WAL."
msgstr ""

#: ../book/box/atomic.rst:167
msgid "If a task is interactive -- sending requests to the server and receiving responses -- then it involves network IO, and therefore there is an implicit yield, even if the request that is sent to the server is not itself an implicit yield request. Therefore the sequence"
msgstr ""

#: ../book/box/atomic.rst:903
msgid ""
"select\n"
"select\n"
"select"
msgstr ""

#: ../book/box/atomic.rst:179
msgid "causes blocking if it is inside a function or Lua program being executed on the server, but causes yielding if it is done as a series of transmissions from a client, including a client which operates via telnet, via one of the connectors, or via the MySQL and PostgreSQL rocks, or via the interactive mode when :ref:`\"Using tarantool as a client\" <administration-using_tarantool_as_a_client>`."
msgstr ""

#: ../book/box/atomic.rst:185
msgid "After a fiber has yielded and then has regained control, it immediately issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""

#: ../book/box/index.rst:730
msgid "Access control"
msgstr "Ограничение доступа"

#: ../book/box/authentication.rst:3
msgid "Understanding the details of security is primarily an issue for administrators, but ordinary users should at least skim this section so that they will have an idea of how Tarantool makes it possible for administrators to prevent unauthorized access to the database and to certain functions."
msgstr ""

#: ../book/box/authentication.rst:8
msgid "Briefly: there is a method to guarantee with password checks that users really are who they say they are (\"authentication\"). There is a _user space where user names and password-hashes are stored. There are functions for saying that certain users are allowed to do certain things (\"privileges\"). There is a _priv space where privileges are stored. Whenever a user tries to do an operation, there is a check whether the user has the privilege to do the operation (\"access control\")."
msgstr ""

#: ../book/box/authentication.rst:18
msgid "Passwords"
msgstr ""

#: ../book/box/authentication.rst:20
msgid "Each user may have a password. The password is any alphanumeric string. Administrators should advise users to choose long unobvious passwords, but it is ultimately up to the users to choose or change their own passwords."
msgstr ""

#: ../book/box/authentication.rst:24
msgid "Tarantool passwords are stored in the _user space with a `Cryptographic hash function`_ so that, if the password is 'x', the stored hashed-password is a long string like '``lL3OvhkIPOKh+Vn9Avlkx69M/Ck=``'. When a client connects to a Tarantool server, the server sends a random `Salt Value`_ which the client must mix with the hashed-password before sending to the server. Thus the original value 'x' is never stored anywhere except in the user's head, and the hashed value is never passed down a network wire except when mixed with a random salt. This system prevents malicious onlookers from finding passwords by snooping in the log files or snooping on the wire. It is the same system that `MySQL introduced several years ago`_ which has proved adequate for medium-security installations. Nevertheless administrators should warn users that no system is foolproof against determined long-term attacks, so passwords should be guarded and changed occasionally."
msgstr ""

#: ../book/box/authentication.rst:39
msgid "To get the hash-password of a string 'X', say ``box.schema.user.password('X')``. To see more about the details of the algorithm for the purpose of writing a new client application, read the `scramble.h`_ header file."
msgstr ""

#: ../book/box/authentication.rst:53
msgid "Users and the _user space"
msgstr ""

#: ../book/box/authentication.rst:55
msgid "The fields in the _user space are:"
msgstr ""

#: ../book/box/authentication.rst:57
msgid "the numeric id of the tuple"
msgstr ""

#: ../book/box/authentication.rst:58
msgid "the numeric id of the tuple's creator"
msgstr ""

#: ../book/box/authentication.rst:59
msgid "the user name"
msgstr ""

#: ../book/box/authentication.rst:60
msgid "the type"
msgstr ""

#: ../book/box/authentication.rst:61
msgid "optional password"
msgstr ""

#: ../book/box/authentication.rst:63
msgid "There are four special tuples in the _user space: 'guest', 'admin', 'public', and 'replication'."
msgstr ""

#: ../book/box/authentication.rst:73
msgid "ID"
msgstr ""

#: ../book/box/authentication.rst:75
msgid "guest"
msgstr ""

#: ../book/box/authentication.rst:75
msgid "0"
msgstr ""

#: ../book/box/authentication.rst:75
msgid "Default when connecting remotely. Usually an untrusted user with few privileges."
msgstr ""

#: ../book/box/authentication.rst:78
msgid "admin"
msgstr ""

#: ../book/box/authentication.rst:78
msgid "1"
msgstr ""

#: ../book/box/authentication.rst:78
msgid "Default when using ``tarantool`` as a console. Usually an administrative user with all privileges."
msgstr ""

#: ../book/box/authentication.rst:81
msgid "public"
msgstr ""

#: ../book/box/authentication.rst:81
msgid "2"
msgstr ""

#: ../book/box/authentication.rst:81 ../book/box/authentication.rst:84
msgid "role"
msgstr ""

#: ../book/box/authentication.rst:81 ../book/box/authentication.rst:84
msgid "Not a user in the usual sense. Described later in section `Roles`_."
msgstr ""

#: ../book/box/authentication.rst:84
msgid "replication"
msgstr ""

#: ../book/box/authentication.rst:84
msgid "3"
msgstr ""

#: ../book/box/authentication.rst:89
msgid "To select a row from the _user space, use ``box.space._user:select``. For example, here is what happens with a select for user id = 0, which is the 'guest' user, which by default has no password:"
msgstr ""

#: ../book/box/authentication.rst:93
msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:100
msgid "To change tuples in the _user space, do not use ordinary ``box.space`` functions for insert or update or delete - the _user space is special so there are special functions which have appropriate error checking."
msgstr ""

#: ../book/box/authentication.rst:104
msgid "To create a new user, say:"
msgstr ""

#: ../book/box/authentication.rst:1031
msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})."
msgstr ""

#: ../book/box/authentication.rst:113
msgid "The :samp:`password={password}` specification is good because in a :ref:`URI <index-uri>` (Uniform Resource Identifier) it is usually illegal to include a user-name without a password."
msgstr ""

#: ../book/box/authentication.rst:116
msgid "To change the user's password, say:"
msgstr ""

#: ../book/box/authentication.rst:1043
msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../book/box/authentication.rst:127
msgid "(Usually it is only the admin user who can change a different user's password.)"
msgstr ""

#: ../book/box/authentication.rst:129
msgid "To drop a user, say:"
msgstr ""

#: ../book/box/authentication.rst:1056
msgid "box.schema.user.drop(*user-name*)."
msgstr ""

#: ../book/box/authentication.rst:136
msgid "To check whether a user exists, say:"
msgstr ""

#: ../book/box/authentication.rst:1063
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../book/box/authentication.rst:143
msgid "which returns true or false."
msgstr ""

#: ../book/box/authentication.rst:145
msgid "To find what privileges a user has, say:"
msgstr ""

#: ../book/box/authentication.rst:1072
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../book/box/authentication.rst:154
msgid "Here is a session which creates a new user with a strong password, selects a tuple in the _user space, and then drops the user."
msgstr ""

#: ../book/box/authentication.rst:157
msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = 'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': 't3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:172
msgid "The maximum number of users is 32."
msgstr ""

#: ../book/box/authentication.rst:178
msgid "Privileges and the _priv space"
msgstr ""

#: ../book/box/authentication.rst:180
msgid "The fields in the _priv space are:"
msgstr ""

#: ../book/box/authentication.rst:182
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../book/box/authentication.rst:183
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../book/box/authentication.rst:184
msgid "the type of object - \"space\" or \"function\" or \"universe\","
msgstr ""

#: ../book/box/authentication.rst:185
msgid "the numeric id of the object,"
msgstr ""

#: ../book/box/authentication.rst:186
msgid "the type of operation - \"read\" = 1, or \"write\" = 2, or \"execute\" = 4, or a combination such as \"read,write,execute\"."
msgstr ""

#: ../book/box/authentication.rst:189
msgid "The function for granting a privilege is:"
msgstr ""

#: ../book/box/authentication.rst:1116
msgid ""
"box.schema.user.grant(*grantee*, *operation*, *object-type*, *object-name*[, *options*])\n"
"-- OR\n"
"box.schema.user.grant(*grantee*, *operation*, 'universe' [, nil, *options*])"
msgstr ""

#: ../book/box/authentication.rst:198 ../book/box/authentication.rst:211
msgid "where 'universe' means 'all objects', and the optional grant-option can be:"
msgstr ""

#: ../book/box/authentication.rst:200
msgid ":samp:`grantor={grantor_name_or_id}` - string or number, for custom grantor"
msgstr ""

#: ../book/box/authentication.rst:201
msgid ":samp:`if_not_exists=true|false` - bool, do not throw error if user already has the privilege"
msgstr ""

#: ../book/box/authentication.rst:203
msgid "The function for revoking a privilege is:"
msgstr ""

#: ../book/box/authentication.rst:1130
msgid ""
"box.schema.user.revoke(*grantee*, *operation*, *object-type*, *object-name*[, *options*])\n"
"box.schema.user.revoke(*grantee*, *operation*, 'universe'[, nil, *options*])"
msgstr ""

#: ../book/box/authentication.rst:213
msgid ":samp:`if_not_exists=true|false` - bool, do not throw error if user already lacks the privilege"
msgstr ""

#: ../book/box/authentication.rst:215
msgid "For example, here is a session where the admin user gave the guest user the privilege to read from a space named ``space55``, and then took the privilege away:"
msgstr ""

#: ../book/box/authentication.rst:218
msgid ""
"tarantool> box.schema.user.grant('guest', 'read', 'space', 'space55')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'read', 'space', 'space55')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:229
msgid "Generally privileges are granted or revoked by the owner of the object (the user who created it), or by the 'admin' user. Before dropping any objects or users, steps should be taken to ensure that all their associated privileges have been revoked."
msgstr ""

#: ../book/box/authentication.rst:236
msgid "Only the 'admin' user can grant privileges for the 'universe'."
msgstr ""

#: ../book/box/authentication.rst:240
msgid "Only the creator of a space can drop, alter, or truncate the space. Only the creator of a user can change a different user's password."
msgstr ""

#: ../book/box/authentication.rst:247
msgid "Functions and the _func space"
msgstr ""

#: ../book/box/authentication.rst:249
msgid "The fields in the _func space are:"
msgstr ""

#: ../book/box/authentication.rst:251
msgid "the numeric function id, a number,"
msgstr ""

#: ../book/box/authentication.rst:252
msgid "the function name"
msgstr ""

#: ../book/box/authentication.rst:253
msgid "flag"
msgstr ""

#: ../book/box/authentication.rst:254
msgid "possibly a language name."
msgstr ""

#: ../book/box/authentication.rst:256
msgid "The _func space does not include the function's body. One continues to create Lua functions in the usual way, by saying \":samp:`function {function_name} () ... end`\", without adding anything in the _func space. The _func space only exists for storing function tuples so that their names can be used within grant/revoke functions."
msgstr ""

#: ../book/box/authentication.rst:262
msgid "The function for creating a _func tuple is:"
msgstr ""

#: ../book/box/authentication.rst:1189
msgid "box.schema.func.create(*function-name* [, *options*])"
msgstr ""

#: ../book/box/authentication.rst:269
msgid "The possible options are:"
msgstr ""

#: ../book/box/authentication.rst:271
msgid ":samp:`if_not_exists = {true|false}` - default = false,"
msgstr ""

#: ../book/box/authentication.rst:272
msgid ":samp:`setuid = {true|false}` - default = false,"
msgstr ""

#: ../book/box/authentication.rst:273
msgid ":samp:`language = {'LUA'|'C'}` - default = 'LUA'."
msgstr ""

#: ../book/box/authentication.rst:277
msgid "box.schema.func.create('f', {language = 'C', setuid = false})"
msgstr ""

#: ../book/box/authentication.rst:281
msgid "Specifying :code:`if_not_exists=false` would cause ``error: Function '...' already exists`` if the _func tuple already exists."
msgstr ""

#: ../book/box/authentication.rst:284
msgid "Specifying :code:`setuid=true` would cause the setuid flag (the fourth field in the _func tuple) to have a value meaning \"true\", and the effect of that is that the function's caller is treated as the function's creator, with full privileges. The setuid behavior does not apply for users who connect via :code:`console.connect`."
msgstr ""

#: ../book/box/authentication.rst:289
msgid "Specifying :code:`language='C'` would cause the language field (the fifth field in the _func tuple) to have a value 'C', which means the function was written in C. Tarantool functions are normally written in Lua but can be written in C as well."
msgstr ""

#: ../book/box/authentication.rst:293
msgid "The function for dropping a _func tuple is:"
msgstr ""

#: ../book/box/authentication.rst:1220
msgid "box.schema.func.drop(*function-name*)"
msgstr ""

#: ../book/box/authentication.rst:300
msgid "The function for checking whether a _func tuple exists is:"
msgstr ""

#: ../book/box/authentication.rst:1227
msgid "box.schema.func.exists(*function-name*)"
msgstr ""

#: ../book/box/authentication.rst:307
msgid "In the following example, a function named 'f7' is created, then it is put in the _func space, then it is used in a ``box.schema.user.grant`` function, then it is dropped:"
msgstr ""

#: ../book/box/authentication.rst:311
msgid ""
"tarantool> function f7()\n"
"         >   box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.func.drop('f7')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:333
msgid "box.session and security"
msgstr ""

#: ../book/box/authentication.rst:335
msgid "After a connection has taken place, the user has access to a \"session\" object which has several functions. The ones which are of interest for security purposes are:"
msgstr ""

#: ../book/box/authentication.rst:1264
msgid ""
"box.session.uid()         -- returns the id of the current user\n"
"box.session.user()        -- returns the name of the current user\n"
"box.session.su(*user-name*) -- allows changing current user to 'user-name'"
msgstr ""

#: ../book/box/authentication.rst:346
msgid "If a user types requests directly on the Tarantool server in its :ref:`interactive mode <administration-using_tarantool_as_a_client>`, or if a user connects to the :ref:`admin port <administration-admin_ports>`, then the user by default is 'admin' and has many privileges. If a user connects from an application program via one of the :ref:`connectors <index-box_connectors>`, then the user by default is 'guest' and has few privileges. Typically an admin user will set up and configure objects, then grant privileges to appropriate non-admin users. Typically a guest user will use ``box.session.su()`` to change into a non-generic user to whom admin has granted more than the default privileges. For example, admin might say:"
msgstr ""

#: ../book/box/authentication.rst:359
msgid ""
"box.space._user:insert{123456,0,'manager','user'}\n"
"box.schema.user.grant('manager', 'read', 'space', '_space')\n"
"box.schema.user.grant('manager', 'read', 'space', 'payroll')"
msgstr ""

#: ../book/box/authentication.rst:365
msgid "and later a guest user, who wishes to see the payroll, might say:"
msgstr ""

#: ../book/box/authentication.rst:367
msgid ""
"box.session.su('manager')\n"
"box.space.payroll:select{'Jones'}"
msgstr ""

#: ../book/box/authentication.rst:376
msgid "Roles"
msgstr ""

#: ../book/box/authentication.rst:378
msgid "A role is a container for privileges which can be granted to regular users. Instead of granting and revoking individual privileges, one can put all the privileges in a role and then grant or revoke the role. Role information is in the _user space but the third field - the type field - is 'role' rather than 'user'."
msgstr ""

#: ../book/box/authentication.rst:386
msgid "If a role R1 is granted a privilege X, and user U1 is granted a privilege \"role R1\", then user U1 in effect has privilege X. Then if a role R2 is granted a privilege Y, and role R1 is granted a privilege \"role R2\", then user U1 in effect has both privilege X and privilege Y. In other words, a user gets all the privileges that are granted to a user's roles, directly or indirectly."
msgstr ""

#: ../book/box/authentication.rst:397
msgid "Create a new role."
msgstr ""

#: ../book/box/authentication.rst:401
msgid "Put a privilege in a role."
msgstr ""

#: ../book/box/authentication.rst:405
msgid "Take a privilege out of a role."
msgstr ""

#: ../book/box/authentication.rst:409
msgid "Drop a role."
msgstr ""

#: ../book/box/authentication.rst:413
msgid "Grant a role to a role."
msgstr ""

#: ../book/box/authentication.rst:417
msgid "Revoke a role from a role."
msgstr ""

#: ../book/box/authentication.rst:421
msgid "Check whether a role exists. Returns (type = boolean) true if role-name identifies a role, otherwise false."
msgstr ""

#: ../book/box/authentication.rst:428
msgid "Grant a role to a user."
msgstr ""

#: ../book/box/authentication.rst:432
msgid "Revoke a role from a user."
msgstr ""

#: ../book/box/authentication.rst:434
msgid "There are two predefined roles. The first predefined role, named 'public', is automatically assigned to new users when they are created with :samp:`box.schema.user.create({user-name})` - Therefore a convenient way to grant 'read' on space 't' to every user that will ever exist is: :code:`box.schema.role.grant('public','read','space','t')`. The second predefined role, named 'replication', can be assigned by the 'admin' user to users who need to use replication features."
msgstr ""

#: ../book/box/authentication.rst:444
msgid "Example showing a role within a role"
msgstr ""

#: ../book/box/authentication.rst:446
msgid "In this example, a new user named U1 will insert a new tuple into a new space named T, and will succeed even though user U1 has no direct privilege to do such an insert -- that privilege is inherited from role R1, which in turn inherits from role R2."
msgstr ""

#: ../book/box/authentication.rst:451
msgid ""
"-- This example will work for a user with many privileges, such as 'admin'\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create a user U1 so that later it's possible to say box.session.su('U1')\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to U1 (order doesn't matter)\n"
"box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
"box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
"-- Grant read and execute privileges to R2 (but not to R1 and not to U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"box.schema.role.grant('R2', 'execute', 'universe')\n"
"-- Use box.session.su to say \"now become user U1\"\n"
"box.session.su('U1')\n"
"-- Next insert succeeds because U1 in effect has write privilege on T\n"
"box.space.T:insert{1}"
msgstr ""

#: ../book/box/index.rst:736
msgid "Triggers"
msgstr "Триггеры"

#: ../book/box/triggers.rst:4
msgid "*Triggers*, also known as *callbacks*, are functions which the server executes when certain events happen. Currently the main types of triggers are :ref:`connection triggers <triggers-connection_triggers>`, which are executed when a session begins or ends, and :ref:`replace triggers <triggers-replace_triggers>`, which are for database events."
msgstr ""

#: ../book/box/triggers.rst:11
msgid "All triggers have the following characteristics:"
msgstr ""

#: ../book/box/triggers.rst:13
msgid "They associate a `function` with an `event`. The request to \"define a trigger\" consists of passing the name of the trigger's function to one of the \":samp:`on_{event-name}()`\" functions: :code:`on_connect()`, :code:`on_auth()`, :code:`on_disconnect()`, or :code:`on_replace()`."
msgstr ""

#: ../book/box/triggers.rst:17
msgid "They are `defined by any user`. There are no privilege requirements for defining triggers."
msgstr ""

#: ../book/box/triggers.rst:19
msgid "They are called `after` the event. They are not called if the event ends prematurely due to an error. (Exception: :code:`on_auth()` is called before the event.)"
msgstr ""

#: ../book/box/triggers.rst:21
msgid "They are in `server memory`. They are not stored in the database. Triggers disappear when the server is shut down. If there is a requirement to make them permanent, then the function definitions and trigger settings should be part of an initialization script."
msgstr ""

#: ../book/box/triggers.rst:25
msgid "They have `low overhead`. If a trigger is not defined, then the overhead is minimal: merely a pointer dereference and check. If a trigger is defined, then its overhead is equivalent to the overhead of calling a stored procedure."
msgstr ""

#: ../book/box/triggers.rst:28
msgid "They can be `multiple` for one event. Triggers are executed in the reverse order that they were defined in."
msgstr ""

#: ../book/box/triggers.rst:30
msgid "They must work `within the event context`. If the function contains requests which normally could not occur immediately after the event but before the return from the event, effects are undefined. For example, putting ``os.exit()`` or ``box.rollback()`` in a trigger function would be bringing in requests outside the event context."
msgstr ""

#: ../book/box/triggers.rst:35
msgid "They are `replaceable`. The request to \"redefine a trigger\" consists of passing the names of a new trigger function and an old trigger function to one of the \"on `event-name` ...\" functions."
msgstr ""

#: ../book/box/triggers.rst:43
msgid "Connection triggers"
msgstr ""

#: ../book/box/triggers.rst:47
msgid "Define a trigger for execution when a new session is created due to an event such as :ref:`console.connect <console-connect>`. The trigger function will be the first thing executed after a new session is created. If the trigger fails by raising an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../book/box/triggers.rst:52 ../book/box/triggers.rst:79
#: ../book/box/triggers.rst:151 ../book/box/triggers.rst:182
msgid "function which will become the trigger function"
msgstr ""

#: ../book/box/triggers.rst:53 ../book/box/triggers.rst:80
#: ../book/box/triggers.rst:152 ../book/box/triggers.rst:183
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../book/box/triggers.rst:54 ../book/box/triggers.rst:81
#: ../book/box/triggers.rst:184
msgid "nil or function list"
msgstr ""

#: ../book/box/triggers.rst:56 ../book/box/triggers.rst:83
#: ../book/box/triggers.rst:155 ../book/box/triggers.rst:186
msgid "If the parameters are (nil, old-trigger-function-name), then the old trigger is deleted."
msgstr ""

#: ../book/box/triggers.rst:60
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../book/box/triggers.rst:69
msgid "If a trigger always results in an error, it may become impossible to connect to the server to reset it."
msgstr ""

#: ../book/box/triggers.rst:74
msgid "Define a trigger for execution after a client has disconnected. If the trigger function causes an error, the error is logged but otherwise is ignored. The trigger is invoked while the session associated with the client still exists and can access session properties, such as box.session.id."
msgstr ""

#: ../book/box/triggers.rst:87
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../book/box/triggers.rst:98
msgid "After the following series of requests, the server will write a message using the :ref:`log <log>` module whenever any user connects or disconnects."
msgstr ""

#: ../book/box/triggers.rst:101
msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../book/box/triggers.rst:116
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../book/box/triggers.rst:118
msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../book/box/triggers.rst:129
msgid "Authentication triggers"
msgstr ""

#: ../book/box/triggers.rst:133
msgid "Define a trigger for execution during authentication."
msgstr ""

#: ../book/box/triggers.rst:135
msgid "The on_auth trigger function is invoked in these circumstances: (1) The :ref:`console.connect <console-connect>` function includes an authentication check for all users except 'guest'; for this case the on_auth trigger function is invoked after the on_connect trigger function, if and only if the connection has succeeded so far. (2) The binary protocol has a separate :ref:`authentication packet <box_protocol-authentication>` -- for this case, connection and authentication are considered to be separate steps."
msgstr ""

#: ../book/box/triggers.rst:142
msgid "Unlike other trigger types, on_auth trigger functions are invoked `before` the event. Therefore a trigger function like :code:`function auth_function () v = box.session.user(); end` will set :code:`v` to \"guest\", the user name before the authentication is done. To get the user name after the authentication is done, use the special syntax: :code:`function auth_function (user_name) v = user_name; end`"
msgstr ""

#: ../book/box/triggers.rst:148
msgid "If the trigger fails by raising an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../book/box/triggers.rst:159
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../book/box/triggers.rst:170
msgid "Replace triggers"
msgstr ""

#: ../book/box/triggers.rst:178
msgid "Create a \"``replace trigger``\". The ``function-name`` will be executed whenever a ``replace()`` or ``insert()`` or ``update()`` or ``upsert()`` or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../book/box/triggers.rst:190
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../book/box/triggers.rst:199
msgid "At the time that a trigger is defined, it is automatically enabled - that is, it will be executed. Replace triggers can be disabled with :samp:`box.space.{space-name}:run_triggers(false)` and re-enabled with :samp:`box.space.{space-name}:run_triggers(true)`."
msgstr ""

#: ../book/box/triggers.rst:208
msgid "tarantool> box.space.X:run_triggers(false)"
msgstr ""

#: ../book/box/triggers.rst:216
msgid "The following series of requests will create a space, create an index, create a function which increments a counter, create a trigger, do two inserts, drop the space, and display the counter value - which is 2, because the function is executed once after each insert."
msgstr ""

#: ../book/box/triggers.rst:221
msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../book/box/triggers.rst:237
#, fuzzy
msgid "Another example"
msgstr "Например:"

#: ../book/box/triggers.rst:239
msgid "The following series of requests will associate an existing function named F with an existing space named T, associate the function a second time with the same space (so it will be called twice), disable all triggers of T, and delete each trigger by replacing with ``nil``."
msgstr ""

#: ../book/box/triggers.rst:244
msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../book/box/triggers.rst:256
msgid "Getting a list of triggers"
msgstr ""

#: ../book/box/triggers.rst:258
msgid "You can use:"
msgstr ""

#: ../book/box/triggers.rst:260
msgid ":code:`on_connect()` -- with no arguments -- to return a table of all connect-trigger functions;"
msgstr ""

#: ../book/box/triggers.rst:262
msgid ":code:`on_auth()` to return all authentication-trigger functions;"
msgstr ""

#: ../book/box/triggers.rst:263
msgid ":code:`on_disconnect()` to return all disconnect-trigger functions;"
msgstr ""

#: ../book/box/triggers.rst:264
msgid ":code:`on_replace()` to return all replace-trigger functions."
msgstr ""

#: ../book/box/triggers.rst:266
msgid "In the following example, we find that there are three functions associated with :code:`on_connect` triggers, and execute the third function, which happens to contain the line \"print('function #3')\". Then we delete the third trigger."
msgstr ""

#: ../book/box/triggers.rst:272
msgid ""
"tarantool> box.session.on_connect()\n"
"---\n"
"- - 'function: 0x416ab6f8'\n"
"  - 'function: 0x416ab6f8'\n"
"  - 'function: 0x416ad800'\n"
"...\n"
"\n"
"tarantool> box.session.on_connect()[3]()\n"
"function #3\n"
"---\n"
"...\n"
"tarantool> box.session.on_connect(nil, box.session.on_connect()[3])\n"
"---\n"
"..."
msgstr ""

#: ../book/box/index.rst:742
msgid "Limitations"
msgstr "Ограничения"

#: ../book/box/limitations.rst:3 ../book/box/limitations.rst:28
msgid "**Number of parts in an index**"
msgstr ""

#: ../book/box/limitations.rst:5 ../book/box/limitations.rst:30
msgid "For TREE or HASH indexes, the maximum is 255 (``box.schema.INDEX_PART_MAX``). For RTREE indexes, the maximum is 1 but the field is an ARRAY. For BITSET indexes, the maximum is 1."
msgstr ""

#: ../book/box/limitations.rst:11 ../book/box/limitations.rst:36
msgid "**Number of indexes in a space**"
msgstr ""

#: ../book/box/limitations.rst:13 ../book/box/limitations.rst:38
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:17 ../book/box/limitations.rst:42
msgid "**Number of fields in a tuple**"
msgstr ""

#: ../book/box/limitations.rst:19 ../book/box/limitations.rst:44
msgid "The theoretical maximum is 2147483647 (``box.schema.FIELD_MAX``). The practical maximum is whatever is specified by the space's :ref:`field_count <box_space-field_count>` member, or the maximum tuple length."
msgstr ""

#: ../book/box/limitations.rst:26 ../book/box/limitations.rst:51
msgid "**Number of bytes in a tuple**"
msgstr ""

#: ../book/box/limitations.rst:28 ../book/box/limitations.rst:53
msgid "By default the value of :ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal>` is 1048576, and the maximum tuple length is approximately one quarter of that: approximately 262,000 bytes. To increase it, when starting the server, specify a larger value. For example :code:`box.cfg{slab_alloc_maximal=2*1048576}`."
msgstr ""

#: ../book/box/limitations.rst:36 ../book/box/limitations.rst:61
msgid "**Number of bytes in an index key**"
msgstr ""

#: ../book/box/limitations.rst:38 ../book/box/limitations.rst:63
msgid "If a field in a tuple can contain a million bytes, then the index key can contain a million bytes, so the maximum is determined by factors such as :ref:`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by the index support."
msgstr ""

#: ../book/box/limitations.rst:45 ../book/box/limitations.rst:70
msgid "**Number of spaces**"
msgstr ""

#: ../book/box/limitations.rst:47 ../book/box/limitations.rst:72
msgid "The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:51 ../book/box/limitations.rst:76
msgid "**Number of connections**"
msgstr ""

#: ../book/box/limitations.rst:53 ../book/box/limitations.rst:78
msgid "The practical limit is the number of file descriptors that one can set with the operating system."
msgstr ""

#: ../book/box/limitations.rst:58 ../book/box/limitations.rst:83
msgid "**Space size**"
msgstr ""

#: ../book/box/limitations.rst:60 ../book/box/limitations.rst:85
msgid "The total maximum size for all spaces is in effect set by :ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>`, which in turn is limited by the total available memory."
msgstr ""

#: ../book/box/limitations.rst:66 ../book/box/limitations.rst:91
msgid "**Update operations count**"
msgstr ""

#: ../book/box/limitations.rst:68 ../book/box/limitations.rst:93
msgid "The maximum number of operations that can be in a single update is 4000 (``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:73 ../book/box/limitations.rst:98
msgid "**Number of users and roles**"
msgstr ""

#: ../book/box/limitations.rst:75 ../book/box/limitations.rst:100
msgid "32 (BOX_USER_MAX)."
msgstr ""

#: ../book/box/limitations.rst:79 ../book/box/limitations.rst:104
msgid "**Length of an index name or space name or user name**"
msgstr ""

#: ../book/box/limitations.rst:81 ../book/box/limitations.rst:106
msgid "32 (``box.schema.NAME_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:85 ../book/box/limitations.rst:110
msgid "**Number of replicas in a cluster**"
msgstr ""

#: ../book/box/limitations.rst:87 ../book/box/limitations.rst:112
msgid "32 (``box.schema.REPLICA_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:91 ../book/box/limitations.rst:116
msgid "For additional limitations which apply only to the vinyl storage engine, see section :ref:`Differences between memtx and vinyl <vinyl_diff>`."
msgstr ""

#: ../book/box/index.rst:750
msgid "Vinyl storage engine"
msgstr "Дисковый движок vinyl"

#: ../book/box/vinyl.rst:3
msgid "A storage engine is a set of very-low-level routines which actually store and retrieve tuple values. Tarantool offers a choice of two storage engines:"
msgstr ""

#: ../book/box/vinyl.rst:6
msgid "memtx (the in-memory storage engine) is the default and was the first to arrive."
msgstr ""

#: ../book/box/vinyl.rst:9
msgid "vinyl (the on-disk storage engine) is a working key-value engine and will especially appeal to users who like to see data go directly to disk, so that recovery time might be shorter and database size might be larger. On the other hand, vinyl lacks some functions and options that are available with memtx. Where that is the case, the relevant description in this manual will contain a note beginning with the words \"Note re storage engine\". See also a coverage for all :ref:`the differences between memtx and vinyl <vinyl_diff>` further on this page."
msgstr ""

#: ../book/box/vinyl.rst:18
msgid "To specify that the engine should be vinyl, add the clause ``engine = 'vinyl'`` when creating a space, for example: ``space = box.schema.space.create('name', {engine='vinyl'})``."
msgstr ""

#: ../book/box/vinyl.rst:26
msgid "Differences between memtx and vinyl storage engines"
msgstr "Различия между движками memtx и vinyl"

#: ../book/box/vinyl.rst:28
msgid "The primary difference between memtx and vinyl is that memtx is an \"in-memory\" engine while vinyl is an \"on-disk\" engine. An in-memory storage engine is generally faster, and the memtx engine is justifiably the default for Tarantool, but there are two situations where an on-disk engine such as vinyl would be preferable:"
msgstr ""

#: ../book/box/vinyl.rst:34
msgid "when the database is larger than the available memory and adding more memory is not a realistic option;"
msgstr ""

#: ../book/box/vinyl.rst:36
msgid "when the server frequently goes down due to errors or a simple desire to save power -- bringing the server back up and restoring a memtx database into memory takes time."
msgstr ""

#: ../book/box/vinyl.rst:40
msgid "Here are behavior differences which affect programmers. All of these differences have been noted elsewhere in sentences that begin with the words \"Note re storage engine: vinyl\"."
msgstr ""

#: ../book/box/vinyl.rst:44
msgid "With memtx, the index type can be TREE or HASH or RTREE or BITSET. |br| With vinyl, the only index type is TREE."
msgstr ""

#: ../book/box/vinyl.rst:47
msgid "With memtx, :ref:`create_index <box_space-create_index>` can be done at any time. |br| With vinyl, secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../book/box/vinyl.rst:50
msgid "With memtx, for index searches, ``nil`` is considered to be equal to any scalar. |br| With vinyl, ``nil`` or missing parts are not allowed."
msgstr ""

#: ../book/box/vinyl.rst:53
msgid "With memtx, temporary spaces are supported. |br| With vinyl, they are not."
msgstr ""

#: ../book/box/vinyl.rst:56
msgid "With memtx, the :ref:`alter() <box_index-alter>` and :ref:`len() <box_space-len>` and :ref:`random() <box_index-random>` and :ref:`auto_increment() <box_space-auto_increment>` and :ref:`truncate() <box_space-truncate>` functions are supported. |br| With vinyl, they are not."
msgstr ""

#: ../book/box/vinyl.rst:61
msgid "With memtx, the :ref:`count() <box_index-count>` function takes a constant amount of time. |br| With vinyl, it takes a variable amount of time depending on index size."
msgstr ""

#: ../book/box/vinyl.rst:65
msgid "With memtx, delete will return deleted tuple, if any. |br| With vinyl, delete will always return nil."
msgstr ""

#: ../book/box/vinyl.rst:68
msgid "It was explained :ref:`earlier <index-yields_must_happen>` that memtx does not \"yield\" on a select request, it yields only on data-change requests. However, vinyl does yield on a select request, or on an equivalent such as ``get()`` or ``pairs()``. This has significance for :ref:`cooperative multitasking <atomic-cooperative_multitasking>`."
msgstr ""

#: ../book/box/vinyl.rst:76
msgid "Vinyl features"
msgstr ""

#: ../book/box/vinyl.rst:78
msgid "Full ACID compliance"
msgstr ""

#: ../book/box/vinyl.rst:79
msgid "Multi-Version Concurrency Control (MVCC)"
msgstr ""

#: ../book/box/vinyl.rst:80
msgid "Pure Append-Only"
msgstr ""

#: ../book/box/vinyl.rst:81
msgid "Multi-threaded (Client access and Engine scalability)"
msgstr ""

#: ../book/box/vinyl.rst:82
msgid "Multi-databases support (Single environment and WAL)"
msgstr ""

#: ../book/box/vinyl.rst:83
msgid "Multi-Statement and Single-Statement Transactions (Snapshot Isolation (SI), multi-databases)"
msgstr ""

#: ../book/box/vinyl.rst:85
msgid "Asynchronous or synchronous transaction execution (Callback triggered versus blocking)"
msgstr ""

#: ../book/box/vinyl.rst:87
msgid "Separate storage formats: key-value (Default), or document (Keys are part of value)"
msgstr ""

#: ../book/box/vinyl.rst:89
msgid "Update without read"
msgstr ""

#: ../book/box/vinyl.rst:90
msgid "Consistent Cursors"
msgstr ""

#: ../book/box/vinyl.rst:91
msgid "Prefix search"
msgstr ""

#: ../book/box/vinyl.rst:92
msgid "Point-in-Time Snapshots"
msgstr ""

#: ../book/box/vinyl.rst:93
msgid "Versional database creation and asynchronous shutdown/drop"
msgstr ""

#: ../book/box/vinyl.rst:94
msgid "Asynchronous Online/Hot Backup"
msgstr ""

#: ../book/box/vinyl.rst:95
msgid "Compression (Per region, both lz4 and zstd are supported)"
msgstr ""

#: ../book/box/vinyl.rst:96
msgid "Metadata Compression (By default)"
msgstr ""

#: ../book/box/vinyl.rst:97
msgid "Key Compression (Compress key duplicates, including suffixes)"
msgstr ""

#: ../book/box/vinyl.rst:98
msgid "Easy to use (Minimalist API)"
msgstr ""

#: ../book/box/vinyl.rst:99
msgid "Easy to integrate (Native support of using as storage engine)"
msgstr ""

#: ../book/box/vinyl.rst:100
msgid "Easy to write bindings (Very FFI-friendly, API designed to be stable in future)"
msgstr ""

#: ../book/box/vinyl.rst:101
msgid "Easy to build in (Amalgamated, compiles into two C files)"
msgstr ""

#: ../book/box/vinyl.rst:102
msgid "Event loop friendly"
msgstr ""

#: ../book/box/vinyl.rst:103
msgid "Zero-Configuration (Tuned by default)"
msgstr ""

#: ../book/box/vinyl.rst:104
msgid "Implemented as a small library **written in C** with zero dependencies"
msgstr ""

#: ../book/box/vinyl.rst:105
msgid "BSD Licensed"
msgstr ""

#: ../book/box/vinyl.rst:107
msgid "It is appropriate for databases that cannot fit in memory, where access via secondary keys is not required."
msgstr ""

#: ../book/box/vinyl.rst:110
msgid "In vinyl terminology:"
msgstr ""

#: ../book/box/vinyl.rst:112
msgid "There is one **Environment**."
msgstr ""

#: ../book/box/vinyl.rst:113
msgid "An Environment has N **Databases** - a vinyl database is like a Tarantool `space`."
msgstr ""

#: ../book/box/vinyl.rst:114
msgid "A Database has N **Ranges**."
msgstr ""

#: ../book/box/vinyl.rst:115
msgid "A Range has one **Range File**."
msgstr ""

#: ../book/box/vinyl.rst:116
msgid "A Range File has N **Runs**."
msgstr ""

#: ../book/box/vinyl.rst:117
msgid "A Run has N **Regions** - a vinyl Region is like a B-tree `page`."
msgstr ""

#: ../book/box/vinyl.rst:118
msgid "A Region has **keys** and **values** - a vinyl key-value is like a Tarantool `tuple`."
msgstr ""

#: ../book/box/vinyl.rst:120
msgid "A key and its associated value are together, so when one accesses a key one gets the whole tuple. In other words, in vinyl the data is stored in the index. There are up to two in-memory copies of an index, as well as the copy in the Range File."
msgstr ""

#: ../book/box/vinyl.rst:124
msgid "For operations that insert or update tuples - called Set operations in vinyl - vinyl makes changes to in-memory copies of the index, and writes to Tarantool's Write-ahead Log. A scheduler assigns tasks to multiple background threads for transferring index data from memory to disk, and for reorganizing Runs. To support transactions, Set operations can be delayed until an explicit commit. If multiple users access the same tuples simultaneously, the concurrency control method is `MVCC`_ and the isolation level is `Snapshot`_."
msgstr ""

#: ../book/box/vinyl.rst:135
msgid "Formally, in terms of disk accesses, vinyl has the following algorithmic complexity:"
msgstr ""

#: ../book/box/vinyl.rst:137
msgid "**Set** - the worst case is O(*1*) append-only key writes to the Write-Ahead Log + in-memory Range index searches + in-memory index inserts"
msgstr ""

#: ../book/box/vinyl.rst:139
msgid "**Delete** - the worst case is O(*1*) key writes and in-memory index inserts (the same as **Set**)"
msgstr ""

#: ../book/box/vinyl.rst:141
msgid "**Get** - the worst case is `amortized`_ O(*max\\_run\\_count\\_per\\_node*) random Region reads from a single Range file, which itself does in-memory index search + in-memory Region search"
msgstr ""

#: ../book/box/vinyl.rst:144
msgid "**Range** - queries, the worst case of full Database scan is amortized O(*total\\_Region\\_count*) + in-memory key-index searches for each Range"
msgstr ""

#: ../book/box/vinyl.rst:151
msgid "Under the hood"
msgstr "А что там \"под капотом\"?"

#: ../book/box/vinyl.rst:153
msgid "In this section, to illustrate internals, we will discuss this example:"
msgstr ""

#: ../book/box/vinyl.rst:155
msgid "filling an empty database with one million tuples (we'll call them \"keys\" to emphasize the indexed nature)"
msgstr ""

#: ../book/box/vinyl.rst:157
msgid "reading all stored tuples in the original order."
msgstr ""

#: ../book/box/vinyl.rst:161
msgid "Inserting the first 200.000 keys"
msgstr ""

#: ../book/box/vinyl.rst:163
msgid "During the first 200,000 Set operations, inserted keys first go to the in-memory index. To maintain persistence, information about each Set operation is written to Tarantool's Write-ahead Log."
msgstr ""

#: ../book/box/vinyl.rst:171
msgid "At this point, we have keys in an in-memory index and records in the Write-ahead Log."
msgstr ""

#: ../book/box/vinyl.rst:175
msgid "Inserting the next 300.000 keys"
msgstr ""

#: ../book/box/vinyl.rst:177
msgid "As the in-memory index becomes too large for available memory, the index must be copied from memory to disk. The on-disk copy of the in-memory index is called a Run. To save the Run, a new file is created, the Range File. We will call it **db file** for this example."
msgstr ""

#: ../book/box/vinyl.rst:182
msgid "The scheduler wakes a worker thread in the background, a Run Creation Thread. The thread creates a second in-memory index. If there are Set operations taking place while the thread is working, their contention effect will be small because they will operate on the second in-memory index."
msgstr ""

#: ../book/box/vinyl.rst:191
msgid "When the Run Creation Thread finishes the task, the first in-memory index is freed."
msgstr ""

#: ../book/box/vinyl.rst:200
msgid "Inserting the next 200.000 keys"
msgstr ""

#: ../book/box/vinyl.rst:202
msgid "Several times, the in-memory index becomes too large and a Run Creation Thread transfers the keys to a Run. The Runs have been appended to the end of db file. The number of created Runs becomes large."
msgstr ""

#: ../book/box/vinyl.rst:210
msgid "There is a user-settable maximum number of Runs per Range. When the number of Runs reaches this maximum, the vinyl scheduler wakes a **Compaction Thread** for the db file. The Compaction Thread merges the keys in all the Runs, and creates one or more new db files."
msgstr ""

#: ../book/box/vinyl.rst:219
msgid "Now there are multiple pairs of in-memory indexes, and each pair has an associated db file. The combination of the in-memory indexes and the db file is called a **Range**, and the db file is called a **Range File**."
msgstr ""

#: ../book/box/vinyl.rst:227
msgid "Thus the contents of a Range are: a range of sorted key values, stored in Runs of a Range File and (when necessary) in memory. Since the ranges do not overlap, each Range can be handled independently. Therefore, while one of the background threads is working on Range 1, another background thread can be working on Range 2, without contention. That means that all the background operations (Run Creation, Compaction, Garbage Collection, and Backup) can take place in parallel on multiple threads."
msgstr ""

#: ../book/box/vinyl.rst:235
msgid "The foregoing explanation will now be repeated with different wording."
msgstr ""

#: ../book/box/vinyl.rst:237
msgid "Before the Compaction there was one Range, which was created automatically when the Database was initialized. The Range had:"
msgstr ""

#: ../book/box/vinyl.rst:240
msgid "an in-memory index with some keys in it,"
msgstr ""

#: ../book/box/vinyl.rst:241
msgid "a Range File with several Runs,"
msgstr ""

#: ../book/box/vinyl.rst:242
msgid "a Write-Ahead Log file recording the Set operations, in the order they happened."
msgstr ""

#: ../book/box/vinyl.rst:244
msgid "The number of Runs became too big, so the vinyl scheduler starts the Compaction Thread and creates two new Ranges."
msgstr ""

#: ../book/box/vinyl.rst:251
msgid "So, each of the two new Range Files contains half of the keys that were in the original Range. The Range's in-memory indexes are split in the same way."
msgstr ""

#: ../book/box/vinyl.rst:254
msgid "After the splitting, vinyl must take into account that: while the Compaction was going on in the background, there might have been more Set operations taking place in parallel. These Set operations would have changed one of the in-memory indexes, and these changes too will be merged."
msgstr ""

#: ../book/box/vinyl.rst:259
msgid "When the Compaction Thread finishes, the original Range is deleted, and information about the new Ranges is inserted into an in-memory **Range Index**."
msgstr ""

#: ../book/box/vinyl.rst:266
msgid "This Range Index is used for all Set operations and all searches. Since the Range Index has the minimum and maximum key values that are in each Range, it is straightforward to scan it to find what Range would contain a particular key value."
msgstr ""

#: ../book/box/vinyl.rst:276
msgid "Inserting the last 300.000 keys"
msgstr ""

#: ../book/box/vinyl.rst:278
msgid "The final 300,000 Set operations take place; the background threads continue to create new Runs and do more Compactions. After the millionth insertion, the Database has four Ranges."
msgstr ""

#: ../book/box/vinyl.rst:286
msgid "The inserting is done. Now, because the words \"memory\" and \"disk\" have appeared in this explanation several times, here are a few words about how vinyl is designed to use these resources most efficiently:"
msgstr ""

#: ../book/box/vinyl.rst:290
msgid "If there is more memory available, then Run Creation and Compaction will be less frequent, and there will be fewer disk accesses."
msgstr ""

#: ../book/box/vinyl.rst:292
msgid "The best vinyl performance will occur if there is no setting of a memory limit, but this must be balanced against other considerations, such as requirements for the memtx storage engine. If there is a setting of a memory limit, the vinyl scheduler will give priority to the Ranges that have the largest in-memory indexes, so that the largest memory blocks are freed first."
msgstr ""

#: ../book/box/vinyl.rst:297
msgid "To make the most of hard drives and Flash, vinyl will delay operations that require disk access (except the writing of the Write-ahead Log which is specially tunable), so that the accesses are done in large sequential blocks."
msgstr ""

#: ../book/box/vinyl.rst:300
msgid "Overwriting does not occur; vinyl is an \"append-only\" engine."
msgstr ""

#: ../book/box/vinyl.rst:304
msgid "Reading million keys"
msgstr ""

#: ../book/box/vinyl.rst:306
msgid "We will now start to read the million rows in the order that they were inserted, which was random."
msgstr ""

#: ../book/box/vinyl.rst:313
msgid "During the Get (search), vinyl first finds the correct Range by looking in the Range Index. Then it searches the Range's first in-memory index, and/or the Range's second in-memory index, and/or each Run of the Range, starting from the end of the Range File."
msgstr ""

#: ../book/box/vinyl.rst:318
msgid "Remember that a Run is divided into Regions, which are like what would be called \"pages\" or \"blocks\" in a B-tree. For each Run, there is a list of the Regions and their minimum/maximum key values - the Region Index - as well as some metadata."
msgstr ""

#: ../book/box/vinyl.rst:327
msgid "Region Indexes are loaded into memory when the Database is opened. Since the Database's Range Index and the Region Indexes are normally in-memory, searching and retrieving a tuple might require only zero or one disk accesses. However, when memory is limited and there are many Runs, search time may rise. For each additional Run there is a possible additional disk access during a search. Also, it is impossible to maintain memory limits without doing a Run Creation process, because new Set operations might occur more quickly than the Compaction process can run."
msgstr ""

#: ../book/box/vinyl.rst:340
msgid "Vinyl is read optimized. It is very likely that the most recently created Runs (hot data) will be in the file system cache. The scheduler will give priority to the Ranges which have the largest in-memory indexes and the most Runs."
msgstr ""

#: ../book/box/vinyl.rst:345
msgid "The scheduler may also try to arrange that a Range will have only one Run, which will ensure the average number of disk seeks for each search is O(*1*)."
msgstr ""

#: ../book/connectors/index.rst:30
msgid "Connectors"
msgstr "Коннекторы"

#: ../book/connectors/index.rst:32
msgid "This chapter documents APIs for various programming languages."
msgstr "В этой главе описаны API для различных языков программирования."

#: ../book/connectors/index.rst:36
msgid "Protocol"
msgstr "Протокол"

#: ../book/connectors/index.rst:38
msgid "Tarantool's binary protocol was designed with a focus on asynchronous I/O and easy integration with proxies. Each client request starts with a variable-length binary header, containing request id, request type, server id, log sequence number, and so on."
msgstr "Бинарный протокол для передачи данных в Tarantool'е был разработан с учетом потребностей асинхронного ввода-вывода. Основная его задача — облегчить интеграцию Tarantool'а с клиентскими приложениями. Клиентский запрос в Tarantool-протоколе начинается с бинарного заголовка переменной длины. В заголовке указывается идентификатор и тип запроса, идентификатор сервера, номер записи в журнале и т.д."

#: ../book/connectors/index.rst:43
msgid "The mandatory length, present in request header simplifies client or proxy I/O. A response to a request is sent to the client as soon as it is ready. It always carries in its header the same type and id as in the request. The id makes it possible to match a request to a response, even if the latter arrived out of order."
msgstr "Также в заголовке обязательно указывается длина запроса, что облегчает обработку данных. Ответ на запрос посылается по мере готовности. В заголовке ответа указывается тот же идентификатор и тип запроса, что и в изначальном запросе. По идентификатору можно легко соотнести запрос с ответом, даже если ответ был получен не в порядке отсылки запросов."

#: ../book/connectors/index.rst:49
msgid "Unless implementing a client driver, you needn't concern yourself with the complications of the binary protocol. Language-specific drivers provide a friendly way to store domain language data structures in Tarantool. A complete description of the binary protocol is maintained in annotated Backus-Naur form in the source tree: please see the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr "Вдаваться в тонкости реализации Tarantool-протокола нужно только при разработке нового коннектора для Tarantool'а — см. :ref:`полное описание бинарного протокола в Tarantool'е <box_protocol-iproto_protocol>` в виде аннотированных BNF-диаграмм (Backus-Naur Form). В остальных случаях достаточно взять уже существующий коннектор для нужного вам языка программирования. Такие коннекторы позволяют легко хранить структуры данных из разных языков в формате Tarantool'а."

#: ../book/connectors/index.rst:58
msgid "Packet example"
msgstr "Пример пакета данных"

#: ../book/connectors/index.rst:60
msgid "The Tarantool API exists so that a client program can send a request packet to the server, and receive a response. Here is an example of a what the client would send for :samp:`box.space[513]:insert{'A', 'BB'}`. The BNF description of the components is on the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr "С помощью Tarantool API клиентские программы могут посылать в адрес Tarantool-сервера пакеты с запросами и получать на них ответы. Вот пример исходящего пакета, который будет сформирован для запроса :code:`box.space[513]:insert{'A', 'BB'}`. Описания компонентов запроса (в виде BNF-диаграмм) вы найдете на странице о :ref:`бинарном протоколе в Tarantool'е <box_protocol-iproto_protocol>`."

#: ../book/connectors/index.rst:76
msgid "Component"
msgstr "Компонент"

#: ../book/connectors/index.rst:76
msgid "Byte #0"
msgstr "Байт #0"

#: ../book/connectors/index.rst:76
msgid "Byte #1"
msgstr "Байт #1"

#: ../book/connectors/index.rst:76
msgid "Byte #2"
msgstr "Байт #2"

#: ../book/connectors/index.rst:76
msgid "Byte #3"
msgstr "Байт #3"

#: ../book/connectors/index.rst:78
msgid "code for insert"
msgstr "код для вставки"

#: ../book/connectors/index.rst:78 ../book/connectors/index.rst:82
msgid "02"
msgstr "02"

#: ../book/connectors/index.rst:80
msgid "rest of header"
msgstr "остаток заголовка"

#: ../book/connectors/index.rst:80
msgid "..."
msgstr "..."

#: ../book/connectors/index.rst:82
msgid "2-digit number: space id"
msgstr "число из 2 цифр: ID пространства"

#: ../book/connectors/index.rst:82
msgid "cd"
msgstr "cd"

#: ../book/connectors/index.rst:82
msgid "01"
msgstr "01"

#: ../book/connectors/index.rst:84
msgid "code for tuple"
msgstr "код для кортежа"

#: ../book/connectors/index.rst:84
msgid "21"
msgstr "21"

#: ../book/connectors/index.rst:86
msgid "1-digit number: field count = 2"
msgstr "число из 1 цифры: количество полей = 2"

#: ../book/connectors/index.rst:86
msgid "92"
msgstr "92"

#: ../book/connectors/index.rst:88
msgid "1-character string: field[1]"
msgstr "строка из 1 символа: поле[1]"

#: ../book/connectors/index.rst:88
msgid "a1"
msgstr "a1"

#: ../book/connectors/index.rst:88
msgid "41"
msgstr "41"

#: ../book/connectors/index.rst:90
msgid "2-character string: field[2]"
msgstr "строка из 2 символов: поле[2]"

#: ../book/connectors/index.rst:90
msgid "a2"
msgstr "a2"

#: ../book/connectors/index.rst:90
msgid "42"
msgstr "42"

#: ../book/connectors/index.rst:93
msgid "Now, you could send that packet to the Tarantool server, and interpret the response (the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>` has a description of the packet format for responses as well as requests). But it would be easier, and less error-prone, if you could invoke a routine that formats the packet according to typed parameters. Something like :samp:`response=tarantool_routine(\"insert\",513,\"A\",\"B\");`. And that is why APIs exist for drivers for Perl, Python, PHP, and so on."
msgstr "Теперь получившийся пакет можно послать Tarantool-серверу и затем проинтерпретировать полученный ответ (описания компонентов ответа вы найдете на той же странице о :ref:`бинарном протоколе в Tarantool'е <box_protocol-iproto_protocol>`). Но более простым и верным способом будет вызвать процедуру, которая за вас сформирует готовый пакет с заданными параметрами. Что-то вроде :samp:`response=tarantool_routine(\"insert\",513,\"A\",\"B\");`. Для этого в Tarantool'е существуют API для Perl, Python, PHP и других программных языков."

#: ../book/connectors/index.rst:106
msgid "Setting up the server for connector examples"
msgstr "Настройка окружения для примеров работы с коннекторами"

#: ../book/connectors/index.rst:108
msgid "This chapter has examples that show how to connect to the Tarantool server via the Perl, PHP, Python, and C connectors. The examples contain hard code that will work if and only if the following conditions are met:"
msgstr "В этой главе приводятся примеры того, как можно установить соединение с Tarantool-сервером с помощью коннекторов для языков Perl, PHP, Python и C. Обратите внимание, что в примерах исходного кода указаны фиксированные значения для элементов тестового окружения, поэтому для корректной работы всех примеров нужно соблюсти следующие условия:"

#: ../book/connectors/index.rst:112
msgid "the server (tarantool) is running on localhost (127.0.0.1) and is listening on port 3301 (:samp:`box.cfg.listen = '3301'`),"
msgstr "Tarantool-сервер запущен на локальной машине (``localhost = 127.0.0.1``), а прослушивание для него настроено на порту 3301 (:samp:`box.cfg.listen = '3301'`),"

#: ../book/connectors/index.rst:115
msgid "space ``examples`` has id = 999 (:samp:`box.space.examples.id = 999`) and has a primary-key index for a numeric field (:samp:`box.space[999].index[0].parts[1].type = \"unsigned\"`),"
msgstr "в базе есть пространство ``examples`` с идентификатором 999 (:samp:`box.space.examples.id = 999`) и у него есть первичный индекс, построенный по ключу числового типа (:samp:`box.space[999].index[0].parts[1].type = \"unsigned\"`),"

#: ../book/connectors/index.rst:119
msgid "user 'guest' has privileges for reading and writing."
msgstr "для пользователя 'guest' настроены привилегии на чтение и запись."

#: ../book/connectors/index.rst:121
msgid "It is easy to meet all the conditions by starting the server and executing this script:"
msgstr "Такое тестовое окружение легко настроить, запустив Tarantool-сервер локально и выполнив следующие запросы:"

#: ../book/connectors/index.rst:124
msgid ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"

#: ../book/connectors/__java.rst:3
msgid "Java"
msgstr "Java"

#: ../book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../book/connectors/__go.rst:3
msgid "Go"
msgstr "Go"

#: ../book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr "См. https://github.com/mialinx/go-tarantool."

#: ../book/connectors/__r.rst:3
msgid "R"
msgstr "R"

#: ../book/connectors/__r.rst:5
msgid "See https://github.com/thekvs/tarantoolr."
msgstr "См. https://github.com/thekvs/tarantoolr."

#: ../book/connectors/__perl.rst:3
msgid "Perl"
msgstr "Perl"

#: ../book/connectors/__perl.rst:5
msgid "The most commonly used Perl driver is `DR::Tarantool <http://search.cpan.org/~unera/DR-Tarantool/>`_. It is not supplied as part of the Tarantool repository; it must be installed separately. The most common way to install it is with `CPAN, the Comprehensive Perl Archive Network <https://en.wikipedia.org/wiki/Cpan>`_. ``DR::Tarantool`` requires other modules which should be installed first. For example, on Ubuntu, the installation could look like this:"
msgstr "Наиболее популярным Tarantool-коннектором для языка Perl является `DR::Tarantool <http://search.cpan.org/~unera/DR-Tarantool/>`_. Он устанавливается отдельно от Tarantool'а, например с помощью :program:`cpan` (см. `CPAN, the Comprehensive Perl Archive Network <https://en.wikipedia.org/wiki/Cpan>`_), и требует предварительной установки еще несколько зависимых модулей. Вот пример установки этого коннектора под Ubuntu:"

#: ../book/connectors/__perl.rst:13
msgid ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"
msgstr ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"

#: ../book/connectors/__perl.rst:24
msgid "Here is a complete Perl program that inserts ``[99999,'BB']`` into ``space[999]`` via the Perl API. Before trying to run, check that the server is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the code into a file named :file:`example.pl` and say :samp:`perl example.pl`. The program will connect using an application-specific definition of the space. The program will open a socket connection with the Tarantool server at ``localhost:3301``, then send an INSERT request, then — if all is well — end without displaying any messages. If Tarantool is not running on ``localhost`` with listen port = 3301, the program will print “Connection refused”."
msgstr "Далее приводится пример полноценной программы на языке Perl, которая осуществляет вставку кортежа ``[99999,'BB']`` в пространство ``space[999]`` с помощью Tarantool API для языка Perl. Перед запуском данной программы проверьте, что ваше тестовое окружение настроено так, как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера задан порт для прослушивания и в базе создано пространство ``examples``). Чтобы запустить тестовую программу, сохраните ее исходный код в файл с именем :file:`example.pl` и выполните команду :samp:`perl example.pl`. Программа установит соединение, используя указанное в ней описание пространства, откроет сокет для соединения с Tarantool-сервером по адресу ``localhost:3301``, пошлет INSERT-запрос, а затем — если всё хорошо — закончит работу без каких-либо сообщений. Если окажется, что Tarantool-сервер не запущен на прослушивание по указанному адресу, то программа выдаст сообщение об ошибке “Connection refused”."

#: ../book/connectors/__perl.rst:36
msgid ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. one could also say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999] ...\n"
"      name => 'examples',                      #   space[999] name = 'examples'\n"
"      default_type => 'STR',                   #   space[999] field type is 'STR' if undefined\n"
"      fields => [ {                            #   definition of space[999].fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] name='field1',type='NUM'\n"
"      indexes => {                             #   definition of space[999] indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # поиск Tarantool-сервера по адресу localhost\n"
"  port    => 3301,                             # на порту 3301\n"
"  user    => 'guest',                          # имя пользователя; здесь же можно добавить 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # определение пространства space[999] ...\n"
"      name => 'examples',                      # имя пространства space[999] = 'examples'\n"
"      default_type => 'STR',                   # если тип поля в space[999] не задан, то = 'STR'\n"
"      fields => [ {                            # определение полей в пространстве space[999] ...\n"
"          name => 'field1', type => 'NUM' } ], # имя поля space[999].field[1]='field1', тип ='NUM'\n"
"      indexes => {                             # определение индексов пространства space[999] ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"

#: ../book/connectors/__perl.rst:60
msgid "The example program uses field type names 'STR' and 'NUM' instead of 'string' and 'unsigned', due to a temporary Perl limitation."
msgstr "Из-за существующих ограничений в языке Perl, вместо полей типа 'string' и 'unsigned' в тестовой программе указаны поля типа 'STR' и 'NUM'."

#: ../book/connectors/__perl.rst:63
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see `DR::Tarantool CPAN repository <http://search.cpan.org/~unera/DR-Tarantool/>`_."
msgstr "В этой программе мы привели пример использования лишь одного запроса. Для полноценной работы с Tarantool'ом с помощью Perl API, пожалуйста, обратитесь к документации из `CPAN-репозитория DR::Tarantool <http://search.cpan.org/~unera/DR-Tarantool/>`_."

#: ../book/connectors/__php.rst:3
msgid "PHP"
msgstr "PHP"

#: ../book/connectors/__php.rst:5
msgid "The PHP driver is `tarantool-php <https://github.com/tarantool/tarantool-php>`_. It is not supplied as part of the Tarantool repository; it must be installed separately. It can be installed with :program:`git`. It requires other modules which should be installed first. For example, on Ubuntu, the installation could look like this:"
msgstr "Tarantool-коннектор для языка PHP называется `tarantool-php <https://github.com/tarantool/tarantool-php>`_. Он устанавливается отдельно от Tarantool'а с помощью :program:`git` и требует предварительной установки еще несколько зависимых модулей. Вот пример установки этого коннектора под Ubuntu:"

#: ../book/connectors/__php.rst:11
msgid ""
"$ sudo apt-get install php5-cli\n"
"$ sudo apt-get install php5-dev\n"
"$ sudo apt-get install php-pear\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/tarantool-php.git\n"
"$ cd tarantool-php\n"
"$ phpize\n"
"$ ./configure\n"
"$ make\n"
"$ # make install is optional"
msgstr ""
"$ sudo apt-get install php5-cli\n"
"$ sudo apt-get install php5-dev\n"
"$ sudo apt-get install php-pear\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/tarantool-php.git\n"
"$ cd tarantool-php\n"
"$ phpize\n"
"$ ./configure\n"
"$ make\n"
"$ # make install is optional"

#: ../book/connectors/__php.rst:25
msgid "At this point there is a file named :file:`~/tarantool-php/modules/tarantool.so`. PHP will only find it if the PHP initialization file :file:`php.ini` contains a line like :samp:`extension=./tarantool.so`, or if PHP is started with the option :samp:`-d extension=~/tarantool-php/modules/tarantool.so`."
msgstr "После отработки всех команд будет создан файл с именем :file:`~/tarantool-php/modules/tarantool.so`. PHP увидит его, только если в файле инициализации :file:`php.ini` есть строка вида :samp:`extension=./tarantool.so`, либо если при запуске PHP вы укажете опцию :samp:`-d extension=~/tarantool-php/modules/tarantool.so`."

#: ../book/connectors/__php.rst:30
msgid "Here is a complete PHP program that inserts ``[99999,'BB']`` into a space named ``examples`` via the PHP API. Before trying to run, check that the server is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the code into a file named :file:`example.php` and say :samp:`php -d extension=~/tarantool-php/modules/tarantool.so example.php`. The program will open a socket connection with the Tarantool server at ``localhost:3301``, then send an INSERT request, then — if all is well — print \"Insert succeeded\". If the tuple already exists, the program will print “Duplicate key exists in unique index 'primary' in space 'examples'”."
msgstr "Далее приводится пример полноценной программы на языке PHP, которая осуществляет вставку кортежа ``[99999,'BB']`` в пространство ``examples`` с помощью Tarantool API для языка PHP. Перед запуском данной программы проверьте, что ваше тестовое окружение настроено так, как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера задан порт для прослушивания и в базе создано пространство ``examples``). Чтобы запустить тестовую программу, сохраните ее исходный код в файл с именем :file:`example.php` и выполните команду :samp:`php -d extension=~/tarantool-php/modules/tarantool.so example.php`. Программа откроет сокет для соединения с Tarantool-сервером по адресу ``localhost:3301``, пошлет INSERT-запрос, а затем — если всё хорошо — выдаст сообщение \"Insert succeeded\". Если окажется, что такой кортеж уже существует, то программа выдаст сообщение об ошибке “Duplicate key exists in unique index 'primary' in space 'examples'”."

#: ../book/connectors/__php.rst:41
msgid ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"

#: ../book/connectors/__php.rst:53
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see `tarantool-php project at GitHub <https://github.com/tarantool/tarantool-php>`_."
msgstr "В этой программе мы привели пример использования лишь одного запроса. Для полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, обратитесь к документации из `проекта tarantool-php на GitHub <https://github.com/tarantool/tarantool-php>`_."

#: ../book/connectors/__python.rst:3
msgid "Python"
msgstr "Python"

#: ../book/connectors/__python.rst:5
msgid "Here is a complete Python program that inserts ``[99999,'Value','Value']`` into space ``examples`` via the high-level Python API."
msgstr "Далее приводится пример полноценной программы на языке Python, которая осуществляет вставку кортежа ``[99999,'Value','Value']`` в пространство ``examples`` с помощью высокоуровневого Tarantool API для языка Python. "

#: ../book/connectors/__python.rst:8
msgid ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"

#: ../book/connectors/__python.rst:17
msgid "To prepare, paste the code into a file named :file:`example.py` and install the ``tarantool-python`` connector with either :samp:`pip install tarantool\\>0.4` to install in :file:`/usr` (requires **root** privilege) or :samp:`pip install tarantool\\>0.4 --user` to install in :file:`~` i.e. user's default directory. Before trying to run, check that the server is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run the program, say :samp:`python example.py`. The program will connect to the server, will send the request, and will not throw any exception if all went well. If the tuple already exists, the program will throw ``tarantool.error.DatabaseError: (3, \"Duplicate key exists in unique index 'primary' in space 'examples'\")``."
msgstr "Перед запуском данной программы проверьте, что ваше тестовое окружение настроено так, как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера задан порт для прослушивания и в базе создано пространство ``examples``), и установите коннектор ``tarantool-python``. Для установки коннектора воспользуйтесь либо командой :samp:`pip install tarantool\\>0.4` (для установки в директорию :file:`/usr`; вам потребуются права уровня  **root**), либо командой :samp:`pip install tarantool\\>0.4 --user` (для установки в директорию :file:`~`, т.е. в используемую по умолчанию директорию текущего пользователя). Чтобы запустить тестовую программу, сохраните ее исходный код в файл с именем :file:`example.py` и выполните команду :samp:`python example.py`. Программа установит соединение с Tarantool-сервером, пошлет запрос и не сгенерирует никакого исключения, если всё прошло хорошо. Если окажется, что такой кортеж уже существует, то программа сгенерирует исключение :samp:`tarantool.error.DatabaseError: (3, \"Duplicate key exists in unique index 'primary' in space 'examples'\")`."

#: ../book/connectors/__python.rst:29
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see `tarantool-python project at GitHub <http://github.com/tarantool/tarantool-python>`_. For an example of using Python API with `queue managers for Tarantool <https://github.com/tarantool/queue>`_, see `queue-python project at GitHub <https://github.com/tarantool/queue-python>`_."
msgstr "В этой программе мы привели пример использования лишь одного запроса. Для полноценной работы с Tarantool'ом с помощью Python API, пожалуйста, обратитесь к документации из `проекта tarantool-python на GitHub <http://github.com/tarantool/tarantool-python>`_. А на странице `проекта queue-python на GitHub <https://github.com/tarantool/queue-python>`_ вы сможете найти примеры использования Python API для работы с `очередями сообщений в Tarantool'е <https://github.com/tarantool/queue>`_."

#: ../book/connectors/__c.rst:3
msgid "C"
msgstr "C"

#: ../book/connectors/__c.rst:5
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr "В этом разделе даны два примера использования высокоуровневого API для Tarantool'а и языка C."

#: ../book/connectors/__c.rst:9
msgid "Example 1"
msgstr "Пример 1"

#: ../book/connectors/__c.rst:11
msgid "Here is a complete C program that inserts :code:`[99999,'B']` into space :code:`examples` via the high-level C API."
msgstr "Далее приводится пример полноценной программы на языке C, которая осуществляет вставку кортежа ``[99999,'B']`` в пространство ``examples`` с помощью высокоуровневого Tarantool API для языка C. "

#: ../book/connectors/__c.rst:14
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE REQUEST */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND REQUEST */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* См. ниже = НАСТРОЙКА */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* См. ниже = СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* См. ниже = СОЗДАНИЕ ЗАПРОСА */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* См. ниже = ОТПРАВКА ЗАПРОСА */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* См. ниже = ПОЛУЧЕНИЕ ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* См. ниже = ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../book/connectors/__c.rst:44
msgid "Paste the code into a file named :file:`example.c` and install ``tarantool-c``. One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr "Скопируйте исходный код программы в файл с именем :file:`example.c` и установите коннектор ``tarantool-c``. Вот один из способов установки ``tarantool-c`` (под Ubuntu):"

#: ../book/connectors/__c.rst:47
msgid ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"

#: ../book/connectors/__c.rst:57 ../book/connectors/__c.rst:288
msgid "To compile and link the program, say:"
msgstr "Чтобы скомпилировать и слинковать тестовую программу, выполните следующую команду:"

#: ../book/connectors/__c.rst:59
msgid ""
"$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""
"$ # иногда это необходимо:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"

#: ../book/connectors/__c.rst:65
msgid "Before trying to run, check that the server is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run the program, say :samp:`./example`. The program will connect to the server, and will send the request. If Tarantool is not running on localhost with listen address = 3301, the program will print “Connection refused”. If the insert fails, the program will print \"Insert failed\" and an error number (see all error codes in the source file `/src/box/errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_)."
msgstr "Перед запуском программы проверьте, что ваше тестовое окружение настроено так, как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера задан порт для прослушивания и в базе создано пространство ``examples``). Чтобы запустить тестовую программу, выполните команду :samp:`./example`. Программа установит соединение с Tarantool-сервером и пошлет запрос. Если окажется, что Tarantool-сервер не запущен на прослушивание по указанному адресу, то программа выдаст сообщение об ошибке “Connection refused”. А если не пройдет INSERT-запрос, то программа выдаст сообщение \"Insert failed\" и код ошибки (все коды ошибок в Tarantool'е см. в исходном файле `/src/box/errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_)."

#: ../book/connectors/__c.rst:77
msgid "Here are notes corresponding to comments in the example program."
msgstr "Далее следуют примечания, на которые мы ссылались в комментариях к исходному коду тестовой программы."

#: ../book/connectors/__c.rst:79
msgid "**SETUP:** The setup begins by creating a stream."
msgstr "**НАСТРОЙКА:** Настройка начинается с создания потока (``tnt_stream``)."

#: ../book/connectors/__c.rst:81
msgid ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"

#: ../book/connectors/__c.rst:86
msgid "In this program, the stream will be named ``tnt``. Before connecting on the ``tnt`` stream, some options may have to be set. The most important option is TNT_OPT_URI. In this program, the URI is ``localhost:3301``, since that is where the Tarantool server is supposed to be listening."
msgstr "В нашей тестовой программе поток назван ``tnt``. Перед установкой соединения нужно задать ряд настроечных опций. Самая важная из них — TNT_OPT_URI. Для этой опции указана URI-строка ``localhost:3301``, т.е. адрес, по которому должно быть настроено прослушивание на стороне Tarantool-сервера."

#: ../book/connectors/__c.rst:92 ../book/connectors/__c.rst:108
#: ../book/connectors/__c.rst:136 ../book/connectors/__c.rst:156
#: ../book/connectors/__c.rst:181 ../book/connectors/__c.rst:200
msgid "Function description:"
msgstr "Описание функции:"

#: ../book/connectors/__c.rst:425
msgid ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"
msgstr ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"

#: ../book/connectors/__c.rst:100
msgid "**CONNECT:** Now that the stream named ``tnt`` exists and is associated with a URI, this example program can connect to the server."
msgstr "**СОЕДИНЕНИЕ:** Теперь когда мы создали поток с именем ``tnt`` и связали его с конкретным URI, наша программа может устанавливать соединение с Tarantool-сервером."

#: ../book/connectors/__c.rst:103
msgid ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"

#: ../book/connectors/__c.rst:441
msgid "int tnt_connect(struct tnt_stream \\*s)"
msgstr "int tnt_connect(struct tnt_stream \\*s)"

#: ../book/connectors/__c.rst:115
msgid "The connection might fail for a variety of reasons, such as: the server is not running, or the URI contains an invalid password. If the connection fails, the return value will be -1."
msgstr "Попытка соединения может и не удаться, например если Tarantool-сервер не запущен или в URI-строке указан неверный пароль. В случае неудачи функция ``tnt_connect()`` вернет -1."

#: ../book/connectors/__c.rst:119
msgid "**MAKE REQUEST:** Most requests require passing a structured value, such as the contents of a tuple."
msgstr "**СОЗДАНИЕ ЗАПРОСА:** В большинстве запросов требуется передавать структурированные данные, например содержимое кортежа."

#: ../book/connectors/__c.rst:122
#, python-format
msgid ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"

#: ../book/connectors/__c.rst:127
#, python-format
msgid "In this program, the request will be an INSERT, and the tuple contents will be an integer and a string. This is a simple serial set of values, that is, there are no sub-structures or arrays. Therefore it is easy in this case to format what will be passed using the same sort of arguments that one would use with a C ``printf()`` function: ``%d`` for the integer, ``%s`` for the string, then the integer value, then a pointer to the string value."
msgstr "В данной программе мы используем запрос INSERT, а кортеж содержит целое число и строку.  Это простой набор значений без каких-либо вложенных структур или массивов. И передаваемые значения мы можем указать самым простым образом — аналогично тому, как это сделано в стандартной C-функции ``printf()``: ``%d`` для обозначения целого числа, ``%s`` для обозначения строки, затем числовое значение, затем указатель на строковое значение."

#: ../book/connectors/__c.rst:469
msgid "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"
msgstr "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"

#: ../book/connectors/__c.rst:143
msgid "**SEND REQUEST:** The database-manipulation requests are analogous to the requests in the box library."
msgstr "**ОТПРАВКА ЗАПРОСА:** Отправка запросов на изменение данных в базе делается аналогично тому, как это делается в Tarantool-библиотеке ``box``."

#: ../book/connectors/__c.rst:146
msgid ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"

#: ../book/connectors/__c.rst:151
msgid "In this program, the choice is to do an INSERT request, so the program passes the ``tnt_stream`` that was used for connection (``tnt``) and the ``tnt_stream`` that was set up with :c:func:`tarantoolc:tnt_object_format` (``tuple``)."
msgstr "В данной программе мы делаем INSERT-запрос. В этом запросе мы передаем поток ``tnt``, который ранее использовали для установки соединения, и поток :code:`tuple`, который также ранее настроили с помощью функции :c:func:`tarantoolc:tnt_object_format`."

#: ../book/connectors/__c.rst:489
msgid ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"
msgstr ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"

#: ../book/connectors/__c.rst:169
msgid "**GET REPLY:** For most requests, the client will receive a reply containing some indication whether the result was successful, and a set of tuples."
msgstr "**ПОЛУЧЕНИЕ ОТВЕТА:** На большинство запросов клиент получает ответ, который содержит информацию о том, был ли данный запрос успешно выполнен, а также содержит набор кортежей."

#: ../book/connectors/__c.rst:172
#, python-format
msgid ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"

#: ../book/connectors/__c.rst:179
msgid "This program checks for success but does not decode the rest of the reply."
msgstr "Данная программа проверяет, был ли запрос выполнен успешно, но никак не интерпретирует оставшуюся часть ответа."

#: ../book/connectors/__c.rst:514
msgid ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"
msgstr ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"

#: ../book/connectors/__c.rst:190
msgid "**TEARDOWN:** When a session ends, the connection that was made with :c:func:`tarantoolc:tnt_connect()` should be closed, and the objects that were made in the setup should be destroyed."
msgstr "**ЗАВЕРШЕНИЕ:** По окончании сессии нам нужно закрыть соединение, созданное с помощью функции :c:func:`tarantoolc:tnt_connect()`, и удалить объекты, созданные на этапе настройки."

#: ../book/connectors/__c.rst:194
msgid ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"

#: ../book/connectors/__c.rst:533
msgid ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"
msgstr ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"

#: ../book/connectors/__c.rst:210
msgid "Example 2"
msgstr "Пример 2"

#: ../book/connectors/__c.rst:212
msgid "Here is a complete C program that selects, using index key ``[99999]``, from space ``examples`` via the high-level C API. To display the results, the program uses functions in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library which allow decoding of `MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_  arrays."
msgstr "Далее приводится еще один пример полноценной программы на языке C, которая осуществляет выборку по индекс-ключу ``[99999]`` из пространства ``examples`` с помощью высокоуровневого Tarantool API для языка C. Для вывода результатов в этой программе используются функции из библиотеки `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_. Эти функции нужны для декодирования массивов значений в формате `MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_."

#: ../book/connectors/__c.rst:218
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* кортеж tuple = ключ для поиска */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"

#: ../book/connectors/__c.rst:285
msgid "Similarly to the first example, paste the code into a file named :file:`example2.c`."
msgstr "Аналогично первому примеру, сохраните исходный код программы в файле с именем :file:`example2.c`."

#: ../book/connectors/__c.rst:290
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr "$ gcc -o example2 example2.c -ltarantool"

#: ../book/connectors/__c.rst:294
msgid "To run the program, say :samp:`./example2`."
msgstr "Для запуска программы выполните команду :samp:`./example2`."

#: ../book/connectors/__c.rst:296
msgid "The two example programs only show a few requests and do not show all that's necessary for good practice. See more in the `tarantool-c documentation at GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr "В этих двух программах мы привели пример использования лишь двух запросов. Для полноценной работы с Tarantool'ом с помощью C API, пожалуйста, обратитесь к документации из `проекта tarantool-c на GitHub <http://github.com/tarantool/tarantool-c>`_."

#: ../book/connectors/__results.rst:4
msgid "Interpreting function return values"
msgstr "Интерпретация возвращаемых значений"

#: ../book/connectors/__results.rst:6
msgid "For all connectors, calling a function via Tarantool causes a return in the MsgPack format. If the function is called using the connector's API, some conversions may occur. All scalar values are returned as tuples (with a MsgPack type-identifier followed by a value); all non-scalar values are returned as a group of tuples (with a MsgPack array-identifier followed by the scalar values). If the function is called via the binary protocol command layer -- \"eval\" -- rather than via the connector's API, no conversions occur."
msgstr "При работе с любым Tarantool-коннектором функции, вызванные с помощью Tarantool'а, возвращают значения в формате MsgPack. Если функция была вызвана через API коннектора, то формат возвращаемых значений будет следующим: скалярные значения возвращаются в виде кортежей (сначала идет идентификатор типа из формата MsgPack, а затем идет значение); все прочие (не скалярные) значения возвращаются в виде групп кортежей (сначала идет идентификатор массива в формате MsgPack, а затем идут скалярные значения). Но если функция была вызвана в рамках бинарного протокола (с помощью команды ``eval``), а не через API коннектора, то подобных изменений формата возвращаемых значений не происходит."

#: ../book/connectors/__results.rst:14
msgid "In the following example, a Lua function will be created. Since it will be accessed externally by a 'guest' user, a ``grant`` of an execute privilege will be necessary. The function returns an empty array, a scalar string, two booleans, and a short integer. The values are the ones described in the table :ref:`Common Types and MsgPack Encodings <msgpack-common_types_and_msgpack_encodings>`."
msgstr "Далее приводится пример создания Lua-функции. Поскольку эту функцию будет вызывать внешний пользователь 'guest', то нужно настроить привилегии на исполнение с помощью ``grant``. Эта функция возвращает пустой массив, строку-скаляр, два логических значения и короткое целое число. Значение будут теми же, что описаны в разделе про MsgPack в таблице :ref:`Стандартные типы в MsgPack-кодировке <msgpack-common_types_and_msgpack_encodings>`."

#: ../book/connectors/__results.rst:20
msgid ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."

#: ../book/connectors/__results.rst:36
msgid "Here is a C program which calls the function. Although C is being used for the example, the result would be precisely the same if the calling program was written in Perl, PHP, Python, Go, or Java."
msgstr "Далее идет пример программы на C, из который мы вызываем эту Lua-функцию. Хотя в примере использован код на C, результат будет одинаковым, на каком бы языке ни была написана вызываемая программа: Perl, PHP, Python, Go или Java."

#: ../book/connectors/__results.rst:40
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);            /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                        /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);       /* MAKE REQUEST */\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL); /* CALL function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   tnt_request_set_tuple(req1, arg);\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                    /* SEND REQUEST */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);   /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data;/* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                    /* TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);            /* НАСТРОЙКА */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                        /* СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);       /* СОЗДАНИЕ ЗАПРОСА */\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL); /* ВЫЗОВ function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   tnt_request_set_tuple(req1, arg);\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                    /* ОТПРАВКА ЗАПРОСА */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);   /* ПОЛУЧЕНИЕ ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data;/* ВЫВОД ОТВЕТА */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                    /* ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../book/connectors/__results.rst:80
msgid "When this program is executed, it will print:"
msgstr "По завершении программа выведет на экран следующие значения:"

#: ../book/connectors/__results.rst:82
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"

#: ../book/connectors/__results.rst:86
msgid "The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for \"32-bit array header with value 5\" (see `MsgPack specification <http://github.com/msgpack/msgpack/blob/master/spec.md>`_). The rest are as described in the table :ref:`Common Types and MsgPack Encodings <msgpack-common_types_and_msgpack_encodings>`."
msgstr "Первые пять байт — ``dd 0 0 0 5`` — это фрагмент данных в формате MsgPack, означающий \"32-битный заголовок массива со значением 5\" (см. `спецификацию на формат MsgPack <http://github.com/msgpack/msgpack/blob/master/spec.md>`_). Остальные значения описаны в таблице :ref:`Стандартные типы в MsgPack-кодировке <msgpack-common_types_and_msgpack_encodings>`."

#: ../book/faq.rst:30
msgid "FAQ"
msgstr "Вопросы и ответы"

#: ../book/faq.rst:41 ../book/faq.rst:46 ../book/faq.rst:53 ../book/faq.rst:64
#: ../book/faq.rst:70 ../book/faq.rst:76 ../book/faq.rst:81
msgid "Q: |br| A: |br|"
msgstr "Вопрос: |br| Ответ: |br|"

#: ../book/faq.rst:41
msgid "Why Tarantool? |br| Tarantool is the latest generation of a family of in-memory data servers developed for web applications. It is the result of practical experience and trials within Mail.Ru since development began in 2008."
msgstr "Почему Tarantool? |br| Tarantool — это in-memory сервер баз данных последнего поколения, предназначенный для работы с веб-приложениями. Разработка ведется с учетом многолетнего опыта использования Tarantool'а в стенах Mail.Ru. Первый релиз состоялся в 2008 году."

#: ../book/faq.rst:46
msgid "Why Lua? |br| Lua is a lightweight, fast, extensible multi-paradigm language. Lua also happens to be very easy to embed. Lua coroutines relate very closely to Tarantool fibers, and Lua architecture works well with Tarantool internals. Lua acts well as a stored program language for Tarantool, although connecting with other languages is also easy."
msgstr "Почему Lua? |br| Lua — это легкий, быстрый и расширяемый язык, позволяющий использовать различные парадигмы программирования. Lua также легко встраивается в различные приложения. Ко-рутины (coroutines) в Lua близко соотносятся с файберами (fibers) в Tarantool'е, а вся Lua-архитектура гладко ложится на его внутреннюю реализацию. Lua — это первый язык, на котором можно писать хранимые процедуры для Tarantool'а. В будущем список поддерживаемых языков планируется расширить."

#: ../book/faq.rst:53
msgid "What's the key advantage of Tarantool? |br| Tarantool provides a rich database feature set (HASH, TREE, RTREE, BITSET indexes, secondary indexes, composite indexes, transactions, triggers, asynchronous replication) in a flexible environment of a Lua interpreter. |br| These two properties make it possible to be a fast, atomic and reliable in-memory data server which handles non-trivial application-specific logic. The advantage over traditional SQL servers is in performance: low-overhead, lock-free architecture means Tarantool can serve an order of magnitude more requests per second, on comparable hardware. The advantage over NoSQL alternatives is in flexibility: Lua allows flexible processing of data stored in a compact, denormalized format."
msgstr "В чем состоит главное преимущество Tarantool'а? |br| Tarantool предоставляет богатый набор функций по работе с базами данных (HASH, TREE, RTREE, BitSet-индексы, вторичные индексы, составные индексы, транзакции, триггеры, асинхронная репликация), и всё это — в гибкой среде Lua-интерпретатора. |br| Эти два обстоятельства делают Tarantool быстрым и надежным in-memory сервером баз данных с атомарными операциями и сложной логикой на стороне сервера. Преимуществом Tarantool'а по сравнению с традиционными SQL СУБД является его высокая производительность: низкие накладные расходы и безблокировочная архитектура позволяют Tarantool'у обрабатывать на порядок больше запросов в секунду на аналогичном оборудовании. Преимущество же перед другими NoSQL СУБД заключается в большей гибкости Tarantool'а: язык Lua позволяет гибко обрабатывать данные, хранящиеся в компактном, ненормализованном формате."

#: ../book/faq.rst:64
msgid "What are your development plans? |br| We continuously improve server performance. On the feature front, automatic sharding and synchronous replication, and a subset of SQL are the major goals for 2016-2018. We have an open roadmap to which we encourage anyone to add feature requests."
msgstr "Каковы ваши планы по развитию? |br| Мы постоянно улучшаем производительность серверной части. Наши главные цели на 2016-2018 год — это автоматический шардинг и синхронная репликация, а также частичная поддержка SQL. План работ находится в открытом доступе, и все желающие могут оставлять запросы на добавление функционала."

#: ../book/faq.rst:70
msgid "Who is developing Tarantool? |br| There is an engineering team employed by Mail.Ru -- check out our commit logs on github.com/tarantool. The development is fully open. Most of the connectors' authors, and the maintainers for different distributions, come from the wider community."
msgstr "Кто разрабатывает Tarantool? |br| Во-первых, этим занимается команда разработки в Mail.Ru — см. историю коммитов на github.com/tarantool. Вся разработка ведется открытым образом. Кроме того, активную роль играют члены сообщества разработчиков Tarantool'а. Их силами было создано большинство коннекторов и ведутся доработки под разные дистрибутивы."

#: ../book/faq.rst:76
msgid "How serious is Mail.Ru about Tarantool? |br| Tarantool is an open source project, distributed under a BSD license, so it does not depend on any one sponsor. However, it is an integral part of the Mail.Ru backbone, so it gets a lot of support from Mail.Ru."
msgstr "Насколько серьезны планы Mail.Ru в отношении Tarantool'а? |br| Tarantool — это проект с открытым кодом, распространяемый под лицензией BSD, поэтому он не зависит от внешних спонсоров. В то же время, Tarantool — это часть технологического \"костяка\" Mail.Ru, и поэтому он пользуется сильной поддержкой со стороны Mail.Ru."

#: ../book/faq.rst:81
msgid "Are there problems associated with being an in-memory server? |br| The principal storage engine is designed for RAM plus persistent storage. It is immune to data loss because there is a write-ahead log. Its memory-allocation and compression techniques ensure there is no waste. And if Tarantool runs out of memory, then it will stop accepting updates until more memory is available, but will continue to handle read and delete requests without difficulty. However, for databases which are much larger than the available RAM space, Tarantool has a second storage engine which is only limited by the available disk space."
msgstr "Возникают ли проблемы из-за того, что Tarantool является in-memory решением? |br| Основной движок баз данных в Tarantool'е работает с оперативной памятью, но при этом он гарантирует сохранность данных благодаря механизму WAL (write ahead log), т.е. журналу упреждающей записи. Также в Tarantool'е используются технологии сжатия и распределения данных, которые позволяют использовать все виды памяти наиболее эффективно. Если Tarantool сталкивается с нехваткой оперативной памяти, то он приостанавливает прием запросов на изменение данных до тех пор, пока не появится свободная память, но при этом с успехом продолжает обработку запросов на чтение и удаление данных. А для больших баз, где объем данных значительно превосходит имеющийся объем оперативной памяти, у Tarantool'а есть второй движок, чьи возможности ограничены лишь размером жесткого диска."

#: ../book/index.rst:30
msgid "User's Guide"
msgstr "Руководство пользователя"

#: ../book/intro.rst:28
msgid "Preface"
msgstr "Предисловие"

#: ../book/intro.rst:30
msgid "Welcome to Tarantool! This is the User's Guide. We recommend reading it first, and consulting :ref:`Reference <reference>` materials for more detail afterwards, if needed."
msgstr "Добро пожаловать в мир Tarantool! Сейчас вы читаете \"Руководство пользователя\". Мы советуем начинать именно с него, а затем переходить к ref:`\"Справочникам\" <reference>`, если вам понадобятся более подробные сведения."

#: ../book/intro.rst:36
msgid "How to read the documentation"
msgstr "Как пользоваться документацией"

#: ../book/intro.rst:38
msgid "To get started, you can either *download the whole Tarantool package* as described in the first part of :ref:`Chapter 2 \"Getting Started\" <user_guide_getting_started>`, or you can skip the download and *connect to the online Tarantool server* running on the web at http://try.tarantool.org. Either way, as the first tryout, you can follow the introductory example \"Starting Tarantool and making your first database\" from the second part of Chapter 2. If you want more hands-on experience, proceed to the :ref:`\"Tutorials\" <tutorials>` part after you are through with Chapter 2."
msgstr "Знакомство с Tarantool'ом вы можете начать с того, что скачаете готовый установочный пакет (как описано в начале :ref:`главы 2 \"Начало работы\" <user_guide_getting_started>`) или воспользуетесь нашим онлайн-стендом на http://try.tarantool.org. В любом случае для первого знакомства вы можете выполнить тренировочный пример \"Первичный запуск Tarantool'а и создание базы данных\" из второй части главы 2. После этого вы можете заглянуть в нащ :ref:`\"Практикум\" <tutorials>`, где содержится еще больше практических заданий."

#: ../book/intro.rst:49
msgid ":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool as a NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" <app_server>` is about using Tarantool as an application server."
msgstr "В :ref:`главе 3 \"Функционал СУБД\" <database-chapter>` рассказано о возможностях Tarantool'а как NoSQL СУБД, а в :ref:`главе 4 \"Сервер приложений\" <app_server>` — о возможностях Tarantool'а как сервера приложений Lua."

#: ../book/intro.rst:53
msgid ":ref:`Chapter 5 \"Server administration\" <server_admin>` is primarily for administrators."
msgstr ":ref:`Глава 5 \"Администрирование серверной части\" <server_admin>` предназначена в первую очередь для системных администраторов."

#: ../book/intro.rst:56
msgid ":ref:`Chapter 6 \"Connectors\" <index-box_connectors>` is strictly for users who are connecting from a different language such as C or Perl or Python — other users will find no immediate need for this chapter."
msgstr ":ref:`Глава 6 \"Коннекторы\" <index-box_connectors>` актуальна только для тех пользователей, которые хотят устанавливать соединение с Tarantool'ом с помощью программ на других языках программирования (например C, Perl или Python) — для прочих пользователей эта глава неактуальна."

#: ../book/intro.rst:60
msgid ":ref:`Chapter 7 \"FAQ\" <faq>` gives answers to some frequently asked questions about Tarantool."
msgstr ":ref:`Глава 7 \"Вопросы и ответы\" <faq>` содержит ответы на некоторые часто задаваемые вопросы о Tarantool'е."

#: ../book/intro.rst:63
msgid "For experienced users, there are also :ref:`Reference <reference>` materials, a :ref:`Contributor's Guide <contrib_guide>` and an extensive set of comments in the source code."
msgstr "Опытным же пользователям будут полезны :ref:`Справочники <reference>`, :ref:`Руководство участника проекта <contrib_guide>` и комментарии в исходном коде."

#: ../book/intro.rst:69
msgid "Getting in touch with the Tarantool community"
msgstr "Как связаться с сообществом разработчиков Tarantool'а"

#: ../book/intro.rst:71
msgid "Please report bugs or make feature requests at http://github.com/tarantool/tarantool/issues."
msgstr "Оставить сообщение о найденых дефектах или сделать запрос на новый функционал можно тут: http://github.com/tarantool/tarantool/issues"

#: ../book/intro.rst:73
msgid "You can contact developers directly in `telegram <http://telegram.me/tarantool>`_ or in a Tarantool discussion group (`English <https://groups.google.com/forum/#!forum/tarantool>`_ or `Russian <https://googlegroups.com/group/tarantool-ru>`_)."
msgstr "Пообщаться напрямую с командой разработки Tarantool'а можно в `telegram <http://telegram.me/tarantool>`_ или на форумах (`англоязычном <https://groups.google.com/forum/#!forum/tarantool>`_ или `русскоязычном <https://googlegroups.com/group/tarantool-ru>`_)."

#: ../book/user_guide_getting_started.rst:30
msgid "Getting started"
msgstr "Начало работы"

#: ../book/user_guide_getting_started.rst:32
msgid "This chapter shows how to download, how to install, and how to start Tarantool for the first time."
msgstr "В этой главе рассказывается, как скачать, установить и начать работать с Tarantool'ом с нуля."

#: ../book/user_guide_getting_started.rst:35
msgid "For production, if possible, you should download a binary (executable) package. This will ensure that you have the same build of the same version that the developers have. That makes analysis easier if later you need to report a problem, and avoids subtle problems that might happen if you used different tools or different parameters when building from source. The section about binaries is \":ref:`user_guide_getting_started-downloading_and_installing_a_binary_package`\"."
msgstr "Для промышленной эксплуатации рекомендуется скачать бинарный (исполняемый) пакет. Тогда вы гарантированно получите сборку той же версии, что и у разработчиков. Это существенно упростит поиск ошибок, если вам в будущем понадобится помощь, а также позволит избежать проблем из-за того, что вы использовали инструменты или параметры отличные от тех, что использовали при сборке сами разработчики. См. раздел “:ref:`user_guide_getting_started-downloading_and_installing_a_binary_package`”."

#: ../book/user_guide_getting_started.rst:42
#, fuzzy
msgid "For development, you will want to download a source package and make the binary by yourself using a C/C++ compiler and common tools. Although this is a bit harder, it gives more control. And the source packages include additional files, for example the Tarantool test suite. The section about source is \":ref:`Building from source <building_from_source>`\" in :ref:`Contributor's Guide <contrib_guide>`."
msgstr "Для разработческих целей вы можете скачать исходные файлы и собрать бинарный пакет самостоятельно с помощью компилятора C/C++ и обычных инструментов для сборки. Хотя это и более трудный способ получить бинарный пакет, но он дает вам больший контроль над результатом. Также в состав исходных файлов входят дополнительные пакеты, например набор тестов для Tarantool'а. См. раздел \":ref:`building_from_source`\"."

#: ../book/user_guide_getting_started.rst:49
#, fuzzy
msgid "If the installation has already been done, then you should try it out. So we've provided some instructions that you can use to make a temporary “sandbox”. In a few minutes you can start the server and type in some database-manipulation statements. The section about the sandbox is \":ref:`user_guide_getting_started-first_database`\"."
msgstr "После установки вы можете сразу опробовать Tarantool в действии. Ниже вы найдете инструкции по созданию безопасной тестовой среды. Всего за несколько минут вы сможете запустить Tarantool-сервер и задать несколько инструкций по манипулированию данными. См. раздел \":ref:`user_guide_getting_started-first_database`”."

#: ../book/user_guide_getting_started.rst:59
msgid "Downloading and installing a binary package"
msgstr "Скачивание и установка бинарного пакета"

#: ../book/user_guide_getting_started.rst:61
msgid "Binary packages for two Tarantool versions -- for the stable 1.6 and the latest 1.7 -- are provided at http://tarantool.org/download.html. An automatic build system creates, tests and publishes packages for every push into the 1.7 branch."
msgstr "Бинарные пакеты для двух версий Tarantool'а — стабильной 1.6 и самой свежей 1.7 — выложены на странице http://tarantool.org/download.html. При каждом изменении исходного кода на GitHub (репозиторий http://github.com/tarantool/tarantool, ветка \"1.7\") происходит сборка, автоматическое тестирование и выкладка бинарных пакетов на вышеуказанную страницу."

#: ../book/user_guide_getting_started.rst:65
msgid "To download and install the package that's appropriate for your OS, start a shell (terminal) and enter the command-line instructions provided for your OS at http://tarantool.org/download.html."
msgstr "Чтобы скачать и установить бинарный пакет для вашей операционной системы, откройте терминал с командной строкой и введите инструкции, которые даны для вашей операционной системы на странице http://tarantool.org/download.html."

#: ../book/user_guide_getting_started.rst:73
msgid "Starting Tarantool and making your first database"
msgstr "Первичный запуск Tarantool'а и создание базы данных"

#: ../book/user_guide_getting_started.rst:75
#: ../book/user_guide_getting_started.rst:85
msgid "Here is how to create a simple test database after installing."
msgstr "Далее рассказывается, как создать простую тестовую базу данных после установки Tarantool'а."

#: ../book/user_guide_getting_started.rst:77
msgid "Create a new directory. It's just for tests, you can delete it when the tests are over."
msgstr "Создайте новую директорию. Она понадобится только для тестовых целей, и ее можно будет удалить по окончании экспериментов."

#: ../book/user_guide_getting_started.rst:80
msgid ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"

#: ../book/user_guide_getting_started.rst:87
msgid "Start the server. The server name is tarantool."
msgstr "Запустите Tarantool-сервер. Имя программы — :program:`tarantool`."

#: ../book/user_guide_getting_started.rst:89
msgid ""
"$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary\n"
"$ # tarball to ~/tarantool, say this:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # if you built from a source download, say this:\n"
"$ ~/tarantool/src/tarantool"
msgstr ""
"$ # Если вы скачали бинарный пакет с помощью apt-get или yum, введите:\n"
"$ /usr/bin/tarantool\n"
"$ # Если вы скачали бинарный пакет в формате TAR\n"
"$ # и разархивировали его в директорию ~/tarantool, введите:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # Если вы собрали Tarantool из исходных файлов, введите:\n"
"$ ~/tarantool/src/tarantool"

#: ../book/user_guide_getting_started.rst:99
msgid "The server starts in interactive mode and outputs a command prompt. To turn on the database, :ref:`configure <box_introspection-box_cfg>` it. This minimal example is sufficient:"
msgstr "Tarantool-сервер запускается в интерактивном режиме и выводит приглашение командной строки. Чтобы создать базу данных, задайте ее настройки с помощью вызова :ref:`box.cfg <box_introspection-box_cfg>`. Вот пример минимальной конфигурации:"

#: ../book/user_guide_getting_started.rst:103
msgid "tarantool> box.cfg{listen = 3301}"
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../book/user_guide_getting_started.rst:107
msgid "If all goes well, you will see the server displaying progress as it initializes, something like this:"
msgstr "Если все в порядке, то Tarantool-сервер начнет в прогрессе отображать процесс инициализации, например:"

#: ../book/user_guide_getting_started.rst:110
msgid ""
"tarantool> box.cfg{listen = 3301}\n"
"2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
"2015-08-07 09:41:41.077 ... log level 5\n"
"2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
"2015-08-07 09:41:41.079 ... initialized\n"
"2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
"2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap.inprogress'\n"
"2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap.inprogress'\n"
"2015-08-07 09:41:41.127 ... done\n"
"2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
"2015-08-07 09:41:41.128 ... ready to accept requests"
msgstr ""
"tarantool> box.cfg{listen = 3301}\n"
"2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
"2015-08-07 09:41:41.077 ... log level 5\n"
"2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
"2015-08-07 09:41:41.079 ... initialized\n"
"2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
"2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap.inprogress'\n"
"2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap.inprogress'\n"
"2015-08-07 09:41:41.127 ... done\n"
"2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
"2015-08-07 09:41:41.128 ... ready to accept requests"

#: ../book/user_guide_getting_started.rst:124
msgid "Now that the server is up, you could start up a different shell and connect to its primary port with:"
msgstr "Поскольку Tarantool-сервер уже запущен, вы можете запустить новый терминал и присоединиться к основному порту Tarantool-сервера, введя следующую команду:"

#: ../book/user_guide_getting_started.rst:127
msgid "$ telnet 0 3301"
msgstr "$ telnet 0 3301"

#: ../book/user_guide_getting_started.rst:131
msgid "but for example purposes it is simpler to just leave the server running in \"interactive mode\". On production machines the :ref:`interactive mode <administration-using_tarantool_as_a_client>` is just for administrators, but because it's convenient for learning it will be used for most examples in this manual. Tarantool is waiting for the user to type instructions."
msgstr "но пока что будет лучше оставить Tarantool-сервер работать в интерактивном режиме. На промышленных серверах :ref:`интерактивный режим <administration-using_tarantool_as_a_client>` нужен лишь для администрирования, однако для наглядности большинство примеров в данном руководстве даны именно в интерактивном режиме. Итак, Tarantool ждет от вас ввода инструкций."

#: ../book/user_guide_getting_started.rst:138
msgid "To create the first space and the first :ref:`index <box_index>`, try this:"
msgstr "Создайте первое пространство и первый :ref:`индекс <box_index>`:"

#: ../book/user_guide_getting_started.rst:140
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../book/user_guide_getting_started.rst:148
msgid "To insert three “tuples” (our name for “records”) into the first “space” of the database try this:"
msgstr "Выполните вставку трех \"кортежей\" (tuple) в первое \"пространство\" (space) из вашей базы данных:"

#: ../book/user_guide_getting_started.rst:151
msgid ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"
msgstr ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"

#: ../book/user_guide_getting_started.rst:157
msgid "To select a tuple from the first space of the database, using the first defined key, try this:"
msgstr "Произведите выборку кортежа из первого пространства в базе по первому указанному ключу:"

#: ../book/user_guide_getting_started.rst:160
msgid "tarantool> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../book/user_guide_getting_started.rst:164
msgid "Your terminal screen should now look like this:"
msgstr "Вот что должно отображаться на вашем терминале к этому моменту:"

#: ../book/user_guide_getting_started.rst:166
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"

#: ../book/user_guide_getting_started.rst:190
msgid "Now, to prepare for the example in the next section, try this:"
msgstr "Далее, чтобы подготовиться к тестовому примеру в следующем разделе, введите:"

#: ../book/user_guide_getting_started.rst:192
msgid "tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr "tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"

#: ../book/user_guide_getting_started.rst:198
msgid "Connecting remotely"
msgstr "Установка удаленного соединения"

#: ../book/user_guide_getting_started.rst:200
msgid "In the previous section the first request was with ``box.cfg{listen = 3301}``. The ``listen`` value can be any form of URI (uniform resource identifier); in this case it's just a local port: port 3301. It's possible to send requests to the listen URI via:"
msgstr "В предыдущем разделе ваш первый запрос был :samp:`box.cfg{listen = 3301}`. Значением ``listen`` может быть любой URI (универсальный код ресурса), в данном случае — просто номер локального порта (3301). Вы можете отправлять запросы на URI для прослушивания с помощью:"

#: ../book/user_guide_getting_started.rst:205
msgid "telnet,"
msgstr "telnet,"

#: ../book/user_guide_getting_started.rst:206
msgid "a connector (which will be the subject of the \":ref:`index-box_connectors`\" chapter),"
msgstr "коннектора (см. главу \":ref:`index-box_connectors`\"),"

#: ../book/user_guide_getting_started.rst:208
msgid "another instance of Tarantool via the :ref:`console module <console-module>`,"
msgstr "другого экземпляра Tarantool'а с помощью :ref:`console module <console-module>`, либо"

#: ../book/user_guide_getting_started.rst:209
msgid "``tarantoolctl connect``."
msgstr "``tarantoolctl connect``."

#: ../book/user_guide_getting_started.rst:211
msgid "Let's try (d)."
msgstr "Давайте попробуем вариант с ``tarantoolctl connect``."

#: ../book/user_guide_getting_started.rst:213
msgid "Switch to another terminal. On Linux, for example, this means starting another instance of a Bash shell. There is no need to use cd to switch to the ``~/tarantool_sandbox`` directory."
msgstr "Переключитесь на другой терминал. Например, в Linux-системе для этого нужно запустить новый экземпляр Bash. При этом вам не потребуется вызывать cd, чтобы переключиться на директорию :code:`~/tarantool_sandbox`."

#: ../book/user_guide_getting_started.rst:217
msgid "Start the tarantoolctl utility:"
msgstr "Запустите утилиту ``tarantoolctl``:"

#: ../book/user_guide_getting_started.rst:222
msgid ":extsamp:`$ {**{tarantoolctl connect '3301'}**}`"
msgstr ":extsamp:`$ {**{tarantoolctl connect '3301'}**}`"

#: ../book/user_guide_getting_started.rst:224
msgid "This means \"use the :ref:`tarantoolctl connect utility <administration-tarantoolctl_connect>` to connect to the Tarantool server that's listening on ``localhost:3301``.\""
msgstr "Данная команда означает \"использовать утилиту :ref:`tarantoolctl <administration-tarantoolctl_connect>` для соединения с Tarantool-сервером, который слушает на ``localhost:3301``.\""

#: ../book/user_guide_getting_started.rst:227
msgid "Try this request:"
msgstr "Введите следующий запрос:"

#: ../book/user_guide_getting_started.rst:232
msgid "tarantool> {**{box.space.tester:select{2}}**}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../book/user_guide_getting_started.rst:234
msgid "This means \"send a request to that Tarantool server, and display the result\". The result in this case is one of the tuples that was inserted earlier. Your terminal screen should now look like this:"
msgstr "Это означает \"послать запрос тому Tarantool-серверу и вывести результат на экран.\" Результатом в данном случае будет один из кортежей, что вы вставляли ранее. На терминале теперь должно отображаться примерно следующее:"

#: ../book/user_guide_getting_started.rst:238
msgid ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Music']\n"
"...\n"
"\n"
"localhost:3301>"
msgstr ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Music']\n"
"...\n"
"\n"
"localhost:3301>"

#: ../book/user_guide_getting_started.rst:249
msgid "You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` indefinitely, on either Tarantool instance. When the testing is over: To drop the space: ``s:drop()``. To stop tarantoolctl: Ctrl+C or Ctrl+D. To stop tarantool (an alternative): :ref:`os.exit() <os-exit>`. To stop tarantool (from another terminal): ``sudo pkill -f tarantool``. To destroy the test: ``rm -r ~/tarantool_sandbox``."
msgstr "Вы можете повторно вводить команды :code:`box.space...:insert{}` и :code:`box.space...:select{}` сколько угодно раз, на любом экземпляре Tarantool'а. В конце тестирования воспользуйтесь следующими командами. Чтобы удалить пространство: :code:`s:drop()`. Чтобы остановить  ``tarantoolctl``: Ctrl+C или Ctrl+D. Чтобы остановить Tarantool (альтернативный вариант): :ref:`os.exit() <os-exit>`. Чтобы остановить Tarantool (с другого терминала): :code:`sudo pkill -f tarantool`. Чтобы удалить тестовую базу: :code:`rm -r ~/tarantool_sandbox`."

#: ../book/user_guide_getting_started.rst:256
msgid "**To review...** If you followed all the instructions in this chapter, then so far you have: installed Tarantool from either a binary or a source repository, started up the Tarantool server, inserted and selected tuples."
msgstr "Если вы выполнили все инструкции из этой главы, то к данному моменту вы уже установили Tarantool (из бинарного пакета, либо из исходных файлов), запустили Tarantool-сервер, а также выполнили вставку и выборку кортежей."
