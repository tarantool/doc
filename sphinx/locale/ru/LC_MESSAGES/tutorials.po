# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-22 21:33+0300\n"
"PO-Revision-Date: 2016-09-22 21:35+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"Language: ru\n"
"X-Generator: Poedit 1.8.9\n"

#: ../tutorials/c_tutorial.rst:28
msgid "C tutorial"
msgstr "Практическое задание на C"

#: ../tutorials/c_tutorial.rst:30
msgid ""
"Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-"
"c_stored_procedures>`."
msgstr ""

#: ../tutorials/c_tutorial.rst:37
msgid "C stored procedures"
msgstr "Хранимые процедуры на языке C"

#: ../tutorials/c_tutorial.rst:39
msgid ""
"Tarantool can call C code with :ref:`modules <modules-example_c>`, or with :"
"ref:`ffi <e_cookbook-ffi_printf>`, or with C stored procedures. This tutorial "
"only is about the third option, C stored procedures. In fact the routines are "
"always \"C functions\" but the phrase \"stored procedure\" is commonly used "
"for historical reasons."
msgstr ""

#: ../tutorials/c_tutorial.rst:46
msgid ""
"In this tutorial, which can be followed by anyone with a Tarantool development "
"package and a C compiler, there are three tasks. The first -- :code:`easy.c` "
"-- prints \"hello world\". The second -- :code:`harder.c` -- decodes a passed "
"parameter value. The third -- :code:`hardest.c` -- uses the C API to do DBMS "
"work."
msgstr ""

#: ../tutorials/c_tutorial.rst:52
msgid ""
"After following the instructions, and seeing that the results are what is "
"described here, users should feel confident about writing their own stored "
"procedures."
msgstr ""

#: ../tutorials/c_tutorial.rst:56
msgid "**Preparation**"
msgstr ""

#: ../tutorials/c_tutorial.rst:58
msgid ""
"Check that these items exist on the computer: |br| * Tarantool 1.7 |br| * A "
"gcc compiler, any modern version should work |br| * \"module.h\" |br| * "
"\"msgpuck.h\" |br|"
msgstr ""

#: ../tutorials/c_tutorial.rst:64
msgid ""
"The \"module.h\" file will exist if Tarantool 1.7 was installed from source. "
"Otherwise Tarantool's \"developer\" package must be installed. For example on "
"Ubuntu say |br| :code:`sudo apt-get install tarantool-dev` |br| or on Fedora "
"say |br| :code:`dnf -y install tarantool-devel`"
msgstr ""

#: ../tutorials/c_tutorial.rst:71
msgid ""
"The \"msgpuck.h\" file will exist if Tarantool 1.7 was installed from source. "
"Otherwise the \"msgpuck\" package must be installed from `https://github.com/"
"rtsisyk/msgpuck <https://github.com/rtsisyk/msgpuck>`_."
msgstr ""

#: ../tutorials/c_tutorial.rst:75
msgid ""
"Both module.h and msgpuck.h must be on the include path for the C compiler to "
"see them. For example, if module.h address is /usr/local/include/tarantool/"
"module.h, and msgpuck.h address is /usr/local/include/msgpuck/msgpuck.h, and "
"they are not currently on the include path, say |br| :code:`export CPATH=/usr/"
"local/include/tarantool:/usr/local/include/msgpuck`"
msgstr ""

#: ../tutorials/c_tutorial.rst:81
msgid ""
"Requests will be done using tarantool as a :ref:`client <administration-"
"using_tarantool_as_a_client>`. Start tarantool, and enter these requests."
msgstr ""

#: ../tutorials/c_tutorial.rst:84
msgid ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""

#: ../tutorials/c_tutorial.rst:92
msgid ""
"In plainer language: create a space named capi_test, and make a connection to "
"self named capi_connection."
msgstr ""

#: ../tutorials/c_tutorial.rst:95
msgid ""
"Leave the client running. It will be necessary to enter more requests later."
msgstr ""

#: ../tutorials/c_tutorial.rst:97
msgid "**easy.c**"
msgstr ""

#: ../tutorials/c_tutorial.rst:99
msgid ""
"Start another shell. Change directory (cd) so that it is the same as the "
"directory that the client is running on."
msgstr ""

#: ../tutorials/c_tutorial.rst:102
msgid "Create a file. Name it easy.c. Put these six lines in it."
msgstr ""

#: ../tutorials/c_tutorial.rst:104
msgid ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}"
msgstr ""

#: ../tutorials/c_tutorial.rst:113
msgid ""
"Compile the program, producing a library file named easy.so: |br| :code:`gcc -"
"shared -o easy.so -fPIC easy.c`"
msgstr ""

#: ../tutorials/c_tutorial.rst:116 ../tutorials/c_tutorial.rst:185
#: ../tutorials/c_tutorial.rst:268
msgid "Now go back to the client and execute these requests:"
msgstr ""

#: ../tutorials/c_tutorial.rst:118
msgid ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""

#: ../tutorials/c_tutorial.rst:124
msgid ""
"If these requests appear unfamiliar, re-read the descriptions of :ref:`box."
"schema.func.create <box_schema-func_create>` and :ref:`box.schema.user.grant "
"<box_schema-user_grant>` and :ref:`conn:call <net_box-call>`."
msgstr ""

#: ../tutorials/c_tutorial.rst:130
msgid "The function that matters is capi_connection:call('easy')."
msgstr ""

#: ../tutorials/c_tutorial.rst:132
msgid ""
"Its first job is to find the 'easy' function, which should be easy because by "
"default Tarantool looks on the current directory for a file named easy.so."
msgstr ""

#: ../tutorials/c_tutorial.rst:136
msgid ""
"Its second job is to call the 'easy' function. Since the easy() function in "
"easy.c begins with :code:`printf(\"hello world\\n\")`, the words \"hello world"
"\" will appear on the screen."
msgstr ""

#: ../tutorials/c_tutorial.rst:140
msgid ""
"Its third job is to check that the call was successful. Since the easy() "
"function in easy.c ends with :code:`return 0`, there is no error message to "
"display and the request is over."
msgstr ""

#: ../tutorials/c_tutorial.rst:144 ../tutorials/c_tutorial.rst:286
msgid "The result should look like this:"
msgstr ""

#: ../tutorials/c_tutorial.rst:146
msgid ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../tutorials/c_tutorial.rst:154
msgid "Conclusion: calling a C function is easy."
msgstr ""

#: ../tutorials/c_tutorial.rst:156
msgid "**harder.c**"
msgstr ""

#: ../tutorials/c_tutorial.rst:158
msgid "Go back to the shell where the easy.c program was created."
msgstr ""

#: ../tutorials/c_tutorial.rst:160
msgid "Create a file. Name it harder.c. Put these 17 lines in it:"
msgstr ""

#: ../tutorials/c_tutorial.rst:162
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""

#: ../tutorials/c_tutorial.rst:182
msgid ""
"Compile the program, producing a library file named harder.so: |br| :code:`gcc "
"-shared -o harder.so -fPIC harder.c`"
msgstr ""

#: ../tutorials/c_tutorial.rst:187
msgid ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"
msgstr ""

#: ../tutorials/c_tutorial.rst:197
msgid ""
"This time the call is passing a Lua table (passable_table) to the harder() "
"function. The harder() function will see it, it's in the :code:`char *args` "
"parameter."
msgstr ""

#: ../tutorials/c_tutorial.rst:201
msgid ""
"At this point the harder() function will start using functions defined in "
"msgpuck.h, which are documented in `http://rtsisyk.github.io/msgpuck <http://"
"rtsisyk.github.io/msgpuck>`_. The routines that begin with \"mp\" are msgpuck "
"functions that handle data formatted according to the MsgPack_ specification. "
"Passes and returns are always done with this format so one must become "
"acquainted with msgpuck to become proficient with the C API."
msgstr ""

#: ../tutorials/c_tutorial.rst:210
msgid ""
"For now, though, it's enough to know that mp_decode_array() returns the number "
"of elements in an array, and mp_decode_uint returns an unsigned integer, from :"
"code:`args`. And there's a side effect: when the decoding finishes, :code:"
"`args` has changed and is now pointing to the next element."
msgstr ""

#: ../tutorials/c_tutorial.rst:216
msgid ""
"Therefore the first displayed line will be \"arg_count = 1\" because there was "
"only one item passed: passable_table. |br| The second displayed line will be "
"\"field_count = 3\" because there are three items in the table. |br| The next "
"three lines will be \"1\" and \"2\" and \"3\" because those are the values in "
"the items in the table."
msgstr ""

#: ../tutorials/c_tutorial.rst:223
msgid "And now the screen looks like this:"
msgstr ""

#: ../tutorials/c_tutorial.rst:225
msgid ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../tutorials/c_tutorial.rst:237
msgid ""
"Conclusion: decoding parameter values passed to a C function is not easy at "
"first, but there are routines to do the job, and they're documented, and there "
"aren't very many of them."
msgstr ""

#: ../tutorials/c_tutorial.rst:242
msgid "**hardest.c**"
msgstr ""

#: ../tutorials/c_tutorial.rst:244
msgid ""
"Go back to the shell where the easy.c and the harder.c programs were created."
msgstr ""

#: ../tutorials/c_tutorial.rst:247
msgid "Create a file. Name it hardest.c. Put these 13 lines in it:"
msgstr ""

#: ../tutorials/c_tutorial.rst:249
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test"
"\"));\n"
"  char tuple[1024];\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""

#: ../tutorials/c_tutorial.rst:265
msgid ""
"Compile the program, producing a library file named hardest.so: |br| :code:"
"`gcc -shared -o hardest.so -fPIC hardest.c`"
msgstr ""

#: ../tutorials/c_tutorial.rst:270
msgid ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""

#: ../tutorials/c_tutorial.rst:277
msgid ""
"This time the C function is doing three things: (1) finding the numeric "
"identifier of the \"capi_test\" space by calling box_space_id_by_name(); |br| "
"(2) formatting a tuple using more msgpuck.h functions; |br| (3) inserting a "
"row using box_insert."
msgstr ""

#: ../tutorials/c_tutorial.rst:283
msgid ""
"Now, still on the client, execute this request: |br| :code:`box.space."
"capi_test:select()`"
msgstr ""

#: ../tutorials/c_tutorial.rst:288
msgid ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""

#: ../tutorials/c_tutorial.rst:295
msgid ""
"This proves that the hardest() function succeeded, but where did "
"box_space_id_by_name() and box_insert() come from? Answer: the C API. The "
"whole C API is documented :ref:`here <index-c_api_reference>`. The function "
"box_space_id_by_name() is documented :ref:`here <box-box_space_id_by_name>`. "
"The function box_insert() is documented :ref:`here <box-box_insert>`."
msgstr ""

#: ../tutorials/c_tutorial.rst:301
msgid ""
"Conclusion: the long description of the C API is there for a good reason. All "
"of the functions in it can be called from C functions which are called from "
"Lua. So C \"stored procedures\" have full access to the database."
msgstr ""

#: ../tutorials/c_tutorial.rst:307
msgid "**Cleaning up**"
msgstr ""

#: ../tutorials/c_tutorial.rst:309
msgid ""
"Get rid of each of the function tuples with :ref:`box.schema.func.drop "
"<box_schema-func_drop>`, and get rid of the capi_test space with :ref:`box."
"schema.capi_test:drop() <box_space-drop>`, and remove the .c and .so files "
"that were created for this tutorial."
msgstr ""

#: ../tutorials/c_tutorial.rst:314
msgid "**An example in the test suite**"
msgstr ""

#: ../tutorials/c_tutorial.rst:316
msgid ""
"Download the source code of Tarantool. Look in a subdirectory :code:`test/"
"box`. Notice that there is a file named :code:`tuple_bench.test.lua` and "
"another file named :code:`tuple_bench.c`. Examine the Lua file and observe "
"that it is calling a function in the C file, using the same techniques that "
"this tutorial has shown."
msgstr ""

#: ../tutorials/c_tutorial.rst:323
msgid ""
"Conclusion: parts of the standard test suite use C stored procedures, and they "
"must work, because releases don't happen if Tarantool doesn't pass the tests."
msgstr ""

#: ../tutorials/index.rst:30
msgid "Tutorials"
msgstr "Практикум"

#: ../tutorials/lua_tutorials.rst:30
msgid "Lua tutorials"
msgstr "Практические задания на Lua"

#: ../tutorials/lua_tutorials.rst:32
msgid "Here are three tutorials on using Lua stored procedures with Tarantool:"
msgstr ""

#: ../tutorials/lua_tutorials.rst:34
msgid ""
":ref:`Insert one million tuples with a Lua stored procedure <c_lua_tutorial-"
"insert_one_million_tuples>`,"
msgstr ""

#: ../tutorials/lua_tutorials.rst:35
msgid ":ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>`,"
msgstr ""

#: ../tutorials/lua_tutorials.rst:36
msgid ":ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>`."
msgstr ""

#: ../tutorials/lua_tutorials.rst:42
msgid "Insert one million tuples with a Lua stored procedure"
msgstr "Вставка 1 млн кортежей с помощью хранимой процедуры на языке Lua"

#: ../tutorials/lua_tutorials.rst:44
msgid ""
"This is an exercise assignment: “Insert one million tuples. Each tuple should "
"have a constantly-increasing numeric primary-key field and a random alphabetic "
"10-character string field.”"
msgstr ""

#: ../tutorials/lua_tutorials.rst:48
msgid ""
"The purpose of the exercise is to show what Lua functions look like inside "
"Tarantool. It will be necessary to employ the Lua math library, the Lua string "
"library, the Tarantool box library, the Tarantool box.tuple library, loops, "
"and concatenations. It should be easy to follow even for a person who has not "
"used either Lua or Tarantool before. The only requirement is a knowledge of "
"how other programming languages work and a memory of the first two chapters of "
"this manual. But for better understanding, follow the comments and the links, "
"which point to the Lua manual or to elsewhere in this Tarantool manual. To "
"further enhance learning, type the statements in with the tarantool client "
"while reading along."
msgstr ""

#: ../tutorials/lua_tutorials.rst:60
msgid "Configure"
msgstr ""

#: ../tutorials/lua_tutorials.rst:62
msgid ""
"We are going to use the \"tarantool_sandbox\" that was created in section :ref:"
"`first database <user_guide_getting_started-first_database>`. So there is a "
"single space, and a numeric primary key, and a running tarantool server which "
"also serves as a client."
msgstr ""

#: ../tutorials/lua_tutorials.rst:68
msgid "Delimiter"
msgstr ""

#: ../tutorials/lua_tutorials.rst:70
msgid ""
"In earlier versions of Tarantool, multi-line functions had to be enclosed "
"within \"delimiters\". They are no longer necessary, and so they will not be "
"used in this tutorial. However, they are still supported. Users who wish to "
"use delimiters, or users of older versions of Tarantool, should check the "
"syntax description for :ref:`declaring a delimiter <administration-"
"setting_delimiter>` before proceeding."
msgstr ""

#: ../tutorials/lua_tutorials.rst:79
msgid "Create a function that returns a string"
msgstr ""

#: ../tutorials/lua_tutorials.rst:81
msgid ""
"We will start by making a function that returns a fixed string, “Hello world”."
msgstr ""

#: ../tutorials/lua_tutorials.rst:83
msgid ""
"function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""

#: ../tutorials/lua_tutorials.rst:89
msgid ""
"The word \"``function``\" is a Lua keyword -- we're about to go into Lua. The "
"function name is string_function. The function has one executable statement, "
"``return \"hello world\"``. The string \"hello world\" is enclosed in double "
"quotes here, although Lua doesn't care -- one could use single quotes instead. "
"The word \"``end``\" means “this is the end of the Lua function declaration.” "
"To confirm that the function works, we can say"
msgstr ""

#: ../tutorials/lua_tutorials.rst:96
msgid "string_function()"
msgstr ""

#: ../tutorials/lua_tutorials.rst:100
msgid ""
"Sending ``function-name()`` means “invoke the Lua function.” The effect is "
"that the string which the function returns will end up on the screen."
msgstr ""

#: ../tutorials/lua_tutorials.rst:103
msgid ""
"For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . For "
"more about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../tutorials/lua_tutorials.rst:109 ../tutorials/lua_tutorials.rst:153
#: ../tutorials/lua_tutorials.rst:205 ../tutorials/lua_tutorials.rst:261
#: ../tutorials/lua_tutorials.rst:307 ../tutorials/lua_tutorials.rst:365
#: ../tutorials/lua_tutorials.rst:456
msgid "The screen now looks like this:"
msgstr ""

#: ../tutorials/lua_tutorials.rst:111
msgid ""
"tarantool> function string_funciton()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../tutorials/lua_tutorials.rst:126
msgid "Create a function that calls another function and sets a variable"
msgstr ""

#: ../tutorials/lua_tutorials.rst:128
msgid ""
"Now that ``string_function`` exists, we can invoke it from another function."
msgstr ""

#: ../tutorials/lua_tutorials.rst:131
msgid ""
"function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""

#: ../tutorials/lua_tutorials.rst:139
msgid ""
"We begin by declaring a variable \"``string_value``\". The word \"``local``\" "
"means that string_value appears only in ``main_function``. If we didn't use "
"\"``local``\" then ``string_value`` would be visible everywhere - even by "
"other users using other clients connected to this server! Sometimes that's a "
"very desirable feature for inter-client communication, but not this time."
msgstr ""

#: ../tutorials/lua_tutorials.rst:145
msgid ""
"Then we assign a value to ``string_value``, namely, the result of "
"``string_function()``. Soon we will invoke ``main_function()`` to check that "
"it got the value."
msgstr ""

#: ../tutorials/lua_tutorials.rst:149
msgid ""
"For more about Lua variables see Lua manual `chapter 4.2 \"Local Variables and "
"Blocks\"`_ ."
msgstr ""

#: ../tutorials/lua_tutorials.rst:155
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../tutorials/lua_tutorials.rst:172
msgid "Modify the function so it returns a one-letter random string"
msgstr ""

#: ../tutorials/lua_tutorials.rst:174
msgid ""
"Now that it's a bit clearer how to make a variable, we can change "
"``string_function()`` so that, instead of returning a fixed literal 'Hello "
"world\", it returns a random letter between 'A' and 'Z'."
msgstr ""

#: ../tutorials/lua_tutorials.rst:178
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""

#: ../tutorials/lua_tutorials.rst:188
msgid ""
"It is not necessary to destroy the old ``string_function()`` contents, they're "
"simply overwritten. The first assignment invokes a random-number function in "
"Lua's math library; the parameters mean “the number must be an integer between "
"65 and 90.” The second assignment invokes an integer-to-character function in "
"Lua's string library; the parameter is the code point of the character. "
"Luckily the ASCII value of 'A' is 65 and the ASCII value of 'Z' is 90 so the "
"result will always be a letter between A and Z."
msgstr ""

#: ../tutorials/lua_tutorials.rst:196
msgid ""
"For more about Lua math-library functions see Lua users \"`Math Library "
"Tutorial`_\". For more about Lua string-library functions see Lua users "
"\"`String Library Tutorial`_\" ."
msgstr ""

#: ../tutorials/lua_tutorials.rst:202
msgid ""
"Once again the ``string_function()`` can be invoked from main_function() which "
"can be invoked with ``main_function()``."
msgstr ""

#: ../tutorials/lua_tutorials.rst:207
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""

#: ../tutorials/lua_tutorials.rst:224
msgid ""
"... Well, actually it won't always look like this because ``math.random()`` "
"produces random numbers. But for the illustration purposes it won't matter "
"what the random string values are."
msgstr ""

#: ../tutorials/lua_tutorials.rst:230
msgid "Modify the function so it returns a ten-letter random string"
msgstr ""

#: ../tutorials/lua_tutorials.rst:232
msgid ""
"Now that it's clear how to produce one-letter random strings, we can reach our "
"goal of producing a ten-letter string by concatenating ten one-letter strings, "
"in a loop."
msgstr ""

#: ../tutorials/lua_tutorials.rst:236
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""

#: ../tutorials/lua_tutorials.rst:249
msgid ""
"The words \"for x = 1,10,1\" mean “start with x equals 1, loop until x equals "
"10, increment x by 1 for each iteration.” The symbol \"..\" means \"concatenate"
"\", that is, add the string on the right of the \"..\" sign to the string on "
"the left of the \"..\" sign. Since we start by saying that random_string is "
"\"\" (a blank string), the end result is that random_string has 10 random "
"letters. Once again the ``string_function()`` can be invoked from "
"``main_function()`` which can be invoked with ``main_function()``."
msgstr ""

#: ../tutorials/lua_tutorials.rst:257
msgid "For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr ""

#: ../tutorials/lua_tutorials.rst:263
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""

#: ../tutorials/lua_tutorials.rst:285
msgid "Make a tuple out of a number and a string"
msgstr ""

#: ../tutorials/lua_tutorials.rst:287
msgid ""
"Now that it's clear how to make a 10-letter random string, it's possible to "
"make a tuple that contains a number and a 10-letter random string, by invoking "
"a function in Tarantool's library of Lua functions."
msgstr ""

#: ../tutorials/lua_tutorials.rst:291
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""

#: ../tutorials/lua_tutorials.rst:300
msgid ""
"Once this is done, t will be the value of a new tuple which has two fields. "
"The first field is numeric: 1. The second field is a random string. Once again "
"the ``string_function()`` can be invoked from ``main_function()`` which can be "
"invoked with  ``main_function()``."
msgstr ""

#: ../tutorials/lua_tutorials.rst:305
msgid ""
"For more about Tarantool tuples see Tarantool manual section :ref:`Submodule "
"box.tuple <box_tuple>`."
msgstr ""

#: ../tutorials/lua_tutorials.rst:309
msgid ""
"tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../tutorials/lua_tutorials.rst:327
msgid "Modify main_function to insert a tuple into the database"
msgstr ""

#: ../tutorials/lua_tutorials.rst:329
msgid ""
"Now that it's clear how to make a tuple that contains a number and a 10-letter "
"random string, the only trick remaining is putting that tuple into tester. "
"Remember that tester is the first space that was defined in the sandbox, so "
"it's like a database table."
msgstr ""

#: ../tutorials/lua_tutorials.rst:334
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""

#: ../tutorials/lua_tutorials.rst:343
msgid ""
"The new line here is ``box.space.tester:replace(t)``. The name contains "
"'tester' because the insertion is going to be to tester. The second parameter "
"is the tuple value. To be perfectly correct we could have said ``box.space."
"tester:insert(t)`` here, rather than ``box.space.tester:replace(t)``, but "
"\"replace\" means “insert even if there is already a tuple whose primary-key "
"value is a duplicate”, and that makes it easier to re-run the exercise even if "
"the sandbox database isn't empty. Once this is done, tester will contain a "
"tuple with two fields. The first field will be 1. The second field will be a "
"random 10-letter string. Once again the ``string_function(``) can be invoked "
"from ``main_function()`` which can be invoked with ``main_function()``. But "
"``main_function()`` won't tell the whole story, because it does not return t, "
"it only puts t into the database. To confirm that something got inserted, "
"we'll use a SELECT request."
msgstr ""

#: ../tutorials/lua_tutorials.rst:357
msgid ""
"main_function()\n"
"box.space.tester:select{1}"
msgstr ""

#: ../tutorials/lua_tutorials.rst:362
msgid ""
"For more about Tarantool insert and replace calls, see Tarantool manual "
"section :ref:`Submodule box.space <box_space>`."
msgstr ""

#: ../tutorials/lua_tutorials.rst:367
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../tutorials/lua_tutorials.rst:388
msgid "Modify main_function to insert a million tuples into the database"
msgstr ""

#: ../tutorials/lua_tutorials.rst:390
msgid ""
"Now that it's clear how to insert one tuple into the database, it's no big "
"deal to figure out how to scale up: instead of inserting with a literal value "
"= 1 for the primary key, insert with a variable value = between 1 and 1 "
"million, in a loop. Since we already saw how to loop, that's a simple thing. "
"The only extra wrinkle that we add here is a timing function."
msgstr ""

#: ../tutorials/lua_tutorials.rst:396
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../tutorials/lua_tutorials.rst:411
msgid ""
"The :ref:`os.clock() <os-clock>` function will return the number of CPU "
"seconds since the start. Therefore, by getting start_time = number of seconds "
"just before the inserting, and then getting end_time = number of seconds just "
"after the inserting, we can calculate (end_time - start_time) = elapsed time "
"in seconds. We will display that value by putting it in a request without any "
"assignments, which causes Tarantool to send the value to the client, which "
"prints it. (Lua's answer to the C ``printf()`` function, which is ``print()``, "
"will also work.)"
msgstr ""

#: ../tutorials/lua_tutorials.rst:419
msgid ""
"For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and Time"
"\"`_. For more on Lua print() see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../tutorials/lua_tutorials.rst:425
msgid ""
"Since this is the grand finale, we will redo the final versions of all the "
"necessary requests: the request that created ``string_function()``, the "
"request that created ``main_function()``, and the request that invokes "
"``main_function()``."
msgstr ""

#: ../tutorials/lua_tutorials.rst:430
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../tutorials/lua_tutorials.rst:458
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""

#: ../tutorials/lua_tutorials.rst:497
msgid ""
"What has been shown is that Lua functions are quite expressive (in fact one "
"can do more with Tarantool's Lua stored procedures than one can do with stored "
"procedures in some SQL DBMSs), and that it's straightforward to combine Lua-"
"library functions and Tarantool-library functions."
msgstr ""

#: ../tutorials/lua_tutorials.rst:502
msgid ""
"What has also been shown is that inserting a million tuples took 37 seconds. "
"The host computer was a Linux laptop. By changing :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>` to 'none' before running the test, "
"one can reduce the elapsed time to 4 seconds."
msgstr ""

#: ../tutorials/lua_tutorials.rst:510
msgid "Sum a JSON field for all tuples"
msgstr "Подсчет суммы по JSON-полям во всех кортежах"

#: ../tutorials/lua_tutorials.rst:512
msgid ""
"This is an exercise assignment: “Assume that inside every tuple there is a "
"string formatted as JSON. Inside that string there is a JSON numeric field. "
"For each tuple, find the numeric field's value and add it to a 'sum' variable. "
"At end, return the 'sum' variable.” The purpose of the exercise is to get "
"experience in one way to read and process tuples."
msgstr ""

#: ../tutorials/lua_tutorials.rst:518
msgid ""
"json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""

#: ../tutorials/lua_tutorials.rst:535
msgid ""
"**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will be "
"used in the function. Actually it's not necessary to declare all variables at "
"the start, and in a long function it would be better to declare variables just "
"before using them. In fact it's not even necessary to declare variables at "
"all, but an undeclared variable is \"global\". That's not desirable for any of "
"the variables that are declared in line 1, because all of them are for use "
"only within the function."
msgstr ""

#: ../tutorials/lua_tutorials.rst:542
msgid ""
"**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and there "
"are two ways to do it: with :ref:`box.space.space_object:pairs() <box_space-"
"pairs>` or with ``variable = select(...)`` followed by :samp:`for i, {n}, 1 do "
"{some-function}(variable[i]) end`. We preferred ``pairs()`` for this example."
msgstr ""

#: ../tutorials/lua_tutorials.rst:547
msgid ""
"**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop will "
"be repeated as long as there is another index key. A tuple is fetched and can "
"be referenced with variable :code:`t`."
msgstr ""

#: ../tutorials/lua_tutorials.rst:551
msgid ""
"**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = json."
"decode(t[2]))``, then the function would abort with an error if it encountered "
"something wrong with the JSON string - a missing colon, for example. By "
"putting the function inside \"``pcall``\" (`protected call`_), we're saying: "
"we want to intercept that sort of error, so if there's a problem just set "
"``is_valid_json = false`` and we will know what to do about it later."
msgstr ""

#: ../tutorials/lua_tutorials.rst:558
msgid ""
"**LINE 6: MEANING.** The function is :ref:`json.decode <json-decode>` which "
"means decode a JSON string, and the parameter is t[2] which is a reference to "
"a JSON string. There's a bit of hard coding here, we're assuming that the "
"second field in the tuple is where the JSON string was inserted. For example, "
"we're assuming a tuple looks like"
msgstr ""

#: ../tutorials/lua_tutorials.rst:568
msgid ""
"field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""

#: ../tutorials/lua_tutorials.rst:571
msgid ""
"meaning that the tuple's first field, the primary key field, is a number while "
"the tuple's second field, the JSON string, is a string. Thus the entire "
"statement means \"decode ``t[2]`` (the tuple's second field) as a JSON string; "
"if there's an error set ``is_valid_json = false``; if there's no error set "
"``is_valid_json = true`` and set ``lua_table =`` a Lua table which has the "
"decoded string\"."
msgstr ""

#: ../tutorials/lua_tutorials.rst:577
msgid ""
"**LINE 8.** At last we are ready to get the JSON field value from the Lua "
"table that came from the JSON string. The value in field_name, which is the "
"parameter for the whole function, must be a name of a JSON field. For example, "
"inside the JSON string ``'{\"Hello\": \"world\", \"Quantity\": 15}'``, there "
"are two JSON fields: \"Hello\" and \"Quantity\". If the whole function is "
"invoked with ``sum_json_field(\"Quantity\")``, then ``field_value = "
"lua_table[field_name]`` is effectively the same as ``field_value = "
"lua_table[\"Quantity\"]`` or even ``field_value = lua_table.Quantity``. Those "
"are just three different ways of saying: for the Quantity field in the Lua "
"table, get the value and put it in variable :code:`field_value`."
msgstr ""

#: ../tutorials/lua_tutorials.rst:587
msgid ""
"**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but the "
"JSON field is not a number, or is missing. In that case, the function would be "
"aborted when there was an attempt to add it to the sum. By first checking "
"``type(field_value) == \"number\"``, we avoid that abortion. Anyone who knows "
"that the database is in perfect shape can skip this kind of thing."
msgstr ""

#: ../tutorials/lua_tutorials.rst:593
msgid ""
"And the function is complete. Time to test it. Starting with an empty "
"database, defined the same way as the sandbox database that was introduced in :"
"ref:`first database <user_guide_getting_started-first_database>`,"
msgstr ""

#: ../tutorials/lua_tutorials.rst:597
msgid ""
"-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"
msgstr ""

#: ../tutorials/lua_tutorials.rst:604
msgid ""
"then add some tuples where the first field is a number and the second field is "
"a string."
msgstr ""

#: ../tutorials/lua_tutorials.rst:607
msgid ""
"box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": "
"\"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": 3}'}"
msgstr ""

#: ../tutorials/lua_tutorials.rst:614
msgid ""
"Since this is a test, there are deliberate errors. The \"golf club\" and the "
"\"waffle iron\" do not have numeric Quantity fields, so must be ignored. "
"Therefore the real sum of the Quantity field in the JSON strings should be: 15 "
"+ 7 = 22."
msgstr ""

#: ../tutorials/lua_tutorials.rst:619
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr ""

#: ../tutorials/lua_tutorials.rst:621
msgid ""
"tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../tutorials/lua_tutorials.rst:628
msgid ""
"It works. We'll just leave, as exercises for future improvement, the "
"possibility that the \"hard coding\" assumptions could be removed, that there "
"might have to be an overflow check if some field values are huge, and that the "
"function should contain a \"yield\" instruction if the count of tuples is huge."
msgstr ""

#: ../tutorials/lua_tutorials.rst:637
msgid "Indexed pattern search"
msgstr "Индексированный поиск по шаблонам"

#: ../tutorials/lua_tutorials.rst:639
msgid ""
"Here is a generic function which takes a field identifier and a search "
"pattern, and returns all tuples that match. |br| * The field must be the first "
"field of a TREE index. |br| * The function will use `Lua pattern matching "
"<http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, which allows \"magic "
"characters\" in regular expressions. |br| * The initial characters in the "
"pattern, as far as the first magic character, will be used as an index search "
"key. For each tuple that is found via the index, there will be a match of the "
"whole pattern. |br| * To be :ref:`cooperative <atomic-"
"cooperative_multitasking>`, the function should yield after every 10 tuples, "
"unless there is a reason to delay yielding. |br| With this function, we can "
"take advantage of Tarantool's indexes for speed, and take advantage of Lua's "
"pattern matching for flexibility. It does everything that an SQL \"LIKE\" "
"search can do, and far more."
msgstr ""

#: ../tutorials/lua_tutorials.rst:656
msgid ""
"Read the following Lua code to see how it works. The comments that begin with "
"\"SEE NOTE ...\" refer to long explanations that follow the code."
msgstr ""

#: ../tutorials/lua_tutorials.rst:660
msgid ""
"function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"string\")) then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == \".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == \"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too short"
"\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- SEE NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\"\n"
"      number_of_tuples_since_last_yield = number_of_tuples_since_last_yield + "
"1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- SEE NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set + 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"
msgstr ""

#: ../tutorials/lua_tutorials.rst:751
msgid ""
"NOTE #1 \"FIND AN APPROPRIATE INDEX\" |br| The caller has passed space_name (a "
"string) and field_no (a number). The requirements are: |br| (a) index type "
"must be \"TREE\" because for other index types (HASH, BITSET, RTREE) a search "
"with iterator=GE will not return strings in order by string value; |br| (b) "
"field_no must be the first index part; |br| (c) the field must contain "
"strings, because for other data types (such as \"unsigned\") pattern searches "
"are not possible; |br| If these requirements are not met by any index, then "
"print an error message and return nil."
msgstr ""

#: ../tutorials/lua_tutorials.rst:763
msgid ""
"NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\" |br| The caller has passed "
"pattern (a string). The index search key will be the characters in the pattern "
"as far as the first magic character. Lua's magic characters are % ^ $ ( ) . "
"[ ] * + - ?. For example, if the pattern is \"ABC.E\", the period is a magic "
"character and therefore the index search key will be \"ABC\". But there is a "
"complication ... If we see \"%\" followed by a punctuation character, that "
"punctuation character is \"escaped\" so remove the \"%\" when making the index "
"search key. For example, if the pattern is \"AB%$E\", the dollar sign is "
"escaped and therefore the index search key will be \"AB$E\". Finally there is "
"a check that the index search key length must be at least three -- this is an "
"arbitrary number, and in fact zero would be okay, but short index search keys "
"will cause long search times."
msgstr ""

#: ../tutorials/lua_tutorials.rst:780
msgid ""
"NOTE #3 -- \"OUTER LOOP: INITIATE\" |br| The function's job is to return a "
"result set, just as box.space.select would. We will fill it within an outer "
"loop that contains an inner loop. The outer loop's job is to execute the inner "
"loop, and possibly yield, until the search ends. The inner loop's job is to "
"find tuples via the index, and put them in the result set if they match the "
"pattern."
msgstr ""

#: ../tutorials/lua_tutorials.rst:789
msgid ""
"NOTE #4 \"INNER LOOP: ITERATOR\" |br| The for loop here is using pairs(), see "
"the :ref:`explanation of what index iterators are <box_index-index_pairs>`. "
"Within the inner loop, there will be a local variable named \"tuple\" which "
"contains the latest tuple found via the index search key."
msgstr ""

#: ../tutorials/lua_tutorials.rst:796
msgid ""
"NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\" |br| The iterator is "
"GE (Greater or Equal), and we must be more specific: if the search index key "
"has N characters, then the leftmost N characters of the result's index field "
"must not be greater than the search index key. For example, if the search "
"index key is 'ABC', then 'ABCDE' is a potential match, but 'ABD' is a signal "
"that no more matches are possible."
msgstr ""

#: ../tutorials/lua_tutorials.rst:805
msgid ""
"NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\" |br| This chunk "
"of code is for cooperative multitasking. The number 10 is arbitrary, and "
"usually a larger number would be okay. The simple rule would be \"after "
"checking 10 tuples, yield, and then resume the search (that is, do the inner "
"loop again) starting after the last value that was found\". However, if the "
"index is non-unique or if there is more than one field in the index, then we "
"might have duplicates -- for example {\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", 3}\" "
"-- and it would be difficult to decide which \"ABC\" tuple to resume with. "
"Therefore, if the result's index field is the same as the previous result's "
"index field, there is no break."
msgstr ""

#: ../tutorials/lua_tutorials.rst:818
msgid ""
"NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\" |br| Compare the "
"result's index field to the entire pattern. For example, suppose that the "
"caller passed pattern \"ABC.E\" and there is an indexed field containing "
"\"ABCDE\". Therefore the initial index search key is \"ABC\". Therefore a "
"tuple containing an indexed field with \"ABCDE\" will be found by the "
"iterator, because \"ABCDE\" > \"ABC\". In that case string.match will return a "
"value which is not nil. Therefore this tuple can be added to the result set."
msgstr ""

#: ../tutorials/lua_tutorials.rst:828
msgid ""
"NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\" |br| There are three "
"conditions which will cause a break from the inner loop: (1) the for loop ends "
"naturally because there are no more index keys which are greater than or equal "
"to the index search key, (2) the index key is too great as described in NOTE "
"#5, (3) it is time for a yield as described in NOTE #6. If condition (1) or "
"condition (2) is true, then there is nothing more to do, the outer loop ends "
"too. If and only if condition (3) is true, the outer loop must yield and then "
"continue. If it does continue, then the inner loop -- the iterator search -- "
"will happen again with a new value for the index search key."
msgstr ""

#: ../tutorials/lua_tutorials.rst:841
msgid "EXAMPLE:"
msgstr ""

#: ../tutorials/lua_tutorials.rst:843
msgid ""
"Start Tarantool, cut and paste the code for function "
"``indexed_pattern_search``, and try the following:"
msgstr ""

#: ../tutorials/lua_tutorials.rst:849
msgid ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,"
"parts={2,'string',3,'string'}})\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"
msgstr ""

#: ../tutorials/lua_tutorials.rst:863
msgid "The result will be:"
msgstr ""

#: ../tutorials/lua_tutorials.rst:868
msgid ""
"tarantool> **indexed_pattern_search(\"t\", 2, \"ABC.E.\")**\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."
msgstr ""
